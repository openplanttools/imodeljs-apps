(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("bentleyjs_core"), require("geometry_core"), require("imodeljs_clients"), require("imodeljs_common"), require("imodeljs_i18n"), require("imodeljs_quantity"));
	else if(typeof define === 'function' && define.amd)
		define("imodeljs_frontend", ["bentleyjs_core", "geometry_core", "imodeljs_clients", "imodeljs_common", "imodeljs_i18n", "imodeljs_quantity"], factory);
	else if(typeof exports === 'object')
		exports["imodeljs_frontend"] = factory(require("bentleyjs_core"), require("geometry_core"), require("imodeljs_clients"), require("imodeljs_common"), require("imodeljs_i18n"), require("imodeljs_quantity"));
	else
		root["imodeljs_frontend"] = factory(root["bentleyjs_core"], root["geometry_core"], root["imodeljs_clients"], root["imodeljs_common"], root["imodeljs_i18n"], root["imodeljs_quantity"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__, __WEBPACK_EXTERNAL_MODULE__bentley_geometry_core__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_clients__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_common__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_i18n__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_quantity__) {
return (this["webpackJsonp"] = this["webpackJsonp"] || []).push([["imodeljs-frontend"],{

/***/ "../../common/temp/node_modules/.registry.npmjs.org/fuse.js/3.4.5/node_modules/fuse.js/dist/fuse.js":
/*!******************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/fuse.js/3.4.5/node_modules/fuse.js/dist/fuse.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*!
 * Fuse.js v3.4.5 - Lightweight fuzzy-search (http://fusejs.io)
 * 
 * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)
 * All Rights Reserved. Apache Software License 2.0
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 */
!function(e,t){ true?module.exports=t():undefined}(this,function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=1)}([function(e,t){e.exports=function(e){return Array.isArray?Array.isArray(e):"[object Array]"===Object.prototype.toString.call(e)}},function(e,t,n){function r(e){return(r="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var i=n(2),a=n(8),s=n(0),c=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.caseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m,S=n.id,x=void 0===S?null:S,b=n.keys,M=void 0===b?[]:b,_=n.shouldSort,L=void 0===_||_,w=n.getFn,A=void 0===w?a:w,C=n.sortFn,I=void 0===C?function(e,t){return e.score-t.score}:C,O=n.tokenize,j=void 0!==O&&O,P=n.matchAllTokens,F=void 0!==P&&P,T=n.includeMatches,z=void 0!==T&&T,E=n.includeScore,K=void 0!==E&&E,$=n.verbose,J=void 0!==$&&$;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k,id:x,keys:M,includeMatches:z,includeScore:K,shouldSort:L,getFn:A,sortFn:I,verbose:J,tokenize:j,matchAllTokens:F},this.setCollection(t)}var t,n,c;return t=e,(n=[{key:"setCollection",value:function(e){return this.list=e,e}},{key:"search",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\nSearch pattern: "'.concat(e,'"'));var n=this._prepareSearchers(e),r=n.tokenSearchers,o=n.fullSearcher,i=this._search(r,o),a=i.weights,s=i.results;return this._computeScore(a,s),this.options.shouldSort&&this._sort(s),t.limit&&"number"==typeof t.limit&&(s=s.slice(0,t.limit)),this._format(s)}},{key:"_prepareSearchers",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"",t=[];if(this.options.tokenize)for(var n=e.split(this.options.tokenSeparator),r=0,o=n.length;r<o;r+=1)t.push(new i(n[r],this.options));return{tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:"_search",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,n=this.list,r={},o=[];if("string"==typeof n[0]){for(var i=0,a=n.length;i<a;i+=1)this._analyze({key:"",value:n[i],record:i,index:i},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t});return{weights:null,results:o}}for(var s={},c=0,h=n.length;c<h;c+=1)for(var l=n[c],u=0,f=this.options.keys.length;u<f;u+=1){var d=this.options.keys[u];if("string"!=typeof d){if(s[d.name]={weight:1-d.weight||1},d.weight<=0||d.weight>1)throw new Error("Key weight has to be > 0 and <= 1");d=d.name}else s[d]={weight:1};this._analyze({key:d,value:this.options.getFn(l,d),record:l,index:c},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t})}return{weights:s,results:o}}},{key:"_analyze",value:function(e,t){var n=e.key,r=e.arrayIndex,o=void 0===r?-1:r,i=e.value,a=e.record,c=e.index,h=t.tokenSearchers,l=void 0===h?[]:h,u=t.fullSearcher,f=void 0===u?[]:u,d=t.resultMap,v=void 0===d?{}:d,p=t.results,g=void 0===p?[]:p;if(null!=i){var y=!1,m=-1,k=0;if("string"==typeof i){this._log("\nKey: ".concat(""===n?"-":n));var S=f.search(i);if(this._log('Full text: "'.concat(i,'", score: ').concat(S.score)),this.options.tokenize){for(var x=i.split(this.options.tokenSeparator),b=[],M=0;M<l.length;M+=1){var _=l[M];this._log('\nPattern: "'.concat(_.pattern,'"'));for(var L=!1,w=0;w<x.length;w+=1){var A=x[w],C=_.search(A),I={};C.isMatch?(I[A]=C.score,y=!0,L=!0,b.push(C.score)):(I[A]=1,this.options.matchAllTokens||b.push(1)),this._log('Token: "'.concat(A,'", score: ').concat(I[A]))}L&&(k+=1)}m=b[0];for(var O=b.length,j=1;j<O;j+=1)m+=b[j];m/=O,this._log("Token score average:",m)}var P=S.score;m>-1&&(P=(P+m)/2),this._log("Score average:",P);var F=!this.options.tokenize||!this.options.matchAllTokens||k>=l.length;if(this._log("\nCheck Matches: ".concat(F)),(y||S.isMatch)&&F){var T=v[c];T?T.output.push({key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}):(v[c]={item:a,output:[{key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}]},g.push(v[c]))}}else if(s(i))for(var z=0,E=i.length;z<E;z+=1)this._analyze({key:n,arrayIndex:z,value:i[z],record:a,index:c},{resultMap:v,results:g,tokenSearchers:l,fullSearcher:f})}}},{key:"_computeScore",value:function(e,t){this._log("\n\nComputing score:\n");for(var n=0,r=t.length;n<r;n+=1){for(var o=t[n].output,i=o.length,a=1,s=1,c=0;c<i;c+=1){var h=e?e[o[c].key].weight:1,l=(1===h?o[c].score:o[c].score||.001)*h;1!==h?s=Math.min(s,l):(o[c].nScore=l,a*=l)}t[n].score=1===s?a:s,this._log(t[n])}}},{key:"_sort",value:function(e){this._log("\n\nSorting...."),e.sort(this.options.sortFn)}},{key:"_format",value:function(e){var t=[];if(this.options.verbose){var n=[];this._log("\n\nOutput:\n\n",JSON.stringify(e,function(e,t){if("object"===r(t)&&null!==t){if(-1!==n.indexOf(t))return;n.push(t)}return t})),n=null}var o=[];this.options.includeMatches&&o.push(function(e,t){var n=e.output;t.matches=[];for(var r=0,o=n.length;r<o;r+=1){var i=n[r];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty("arrayIndex")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a)}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1)o[h](s,c);t.push(c)}else t.push(s.item)}return t}},{key:"_log",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments)}}])&&o(t.prototype,n),c&&o(t,c),e}();e.exports=c},function(e,t,n){function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,"value"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var o=n(3),i=n(4),a=n(7),s=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.isCaseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m;!function(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k},this.pattern=this.options.isCaseSensitive?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern))}var t,n,s;return t=e,(n=[{key:"search",value:function(e){if(this.options.isCaseSensitive||(e=e.toLowerCase()),this.pattern===e)return{isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]};var t=this.options,n=t.maxPatternLength,r=t.tokenSeparator;if(this.pattern.length>n)return o(e,this.pattern,r);var a=this.options,s=a.location,c=a.distance,h=a.threshold,l=a.findAllMatches,u=a.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:s,distance:c,threshold:h,findAllMatches:l,minMatchCharLength:u})}}])&&r(t.prototype,n),s&&r(t,s),e}();e.exports=s},function(e,t){var n=/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g;e.exports=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(n,"\\$&").replace(r,"|")),i=e.match(o),a=!!i,s=[];if(a)for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1])}return{score:a?.5:1,isMatch:a,matchedIndices:s}}},function(e,t,n){var r=n(5),o=n(6);e.exports=function(e,t,n,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,d=void 0!==f&&f,v=i.minMatchCharLength,p=void 0===v?1:v,g=s,y=e.length,m=u,k=e.indexOf(t,g),S=t.length,x=[],b=0;b<y;b+=1)x[b]=0;if(-1!==k){var M=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});if(m=Math.min(M,m),-1!==(k=e.lastIndexOf(t,g+S))){var _=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});m=Math.min(_,m)}}k=-1;for(var L=[],w=1,A=S+y,C=1<<S-1,I=0;I<S;I+=1){for(var O=0,j=A;O<j;){r(t,{errors:I,currentLocation:g+j,expectedLocation:g,distance:h})<=m?O=j:A=j,j=Math.floor((A-O)/2+O)}A=j;var P=Math.max(1,g-j+1),F=d?y:Math.min(g+j,y)+S,T=Array(F+2);T[F+1]=(1<<I)-1;for(var z=F;z>=P;z-=1){var E=z-1,K=n[e.charAt(E)];if(K&&(x[E]=1),T[z]=(T[z+1]<<1|1)&K,0!==I&&(T[z]|=(L[z+1]|L[z])<<1|1|L[z+1]),T[z]&C&&(w=r(t,{errors:I,currentLocation:E,expectedLocation:g,distance:h}))<=m){if(m=w,(k=E)<=g)break;P=Math.max(1,2*g-k)}}if(r(t,{errors:I+1,currentLocation:g,expectedLocation:g,distance:h})>m)break;L=T}return{isMatch:k>=0,score:0===w?.001:w,matchedIndices:o(x,p)}}},function(e,t){e.exports=function(e,t){var n=t.errors,r=void 0===n?0:n,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=r/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l}},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=[],r=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===r?r=i:s||-1===r||((o=i-1)-r+1>=t&&n.push([r,o]),r=-1)}return e[i-1]&&i-r>=t&&n.push([r,i-1]),n}},function(e,t){e.exports=function(e){for(var t={},n=e.length,r=0;r<n;r+=1)t[e.charAt(r)]=0;for(var o=0;o<n;o+=1)t[e.charAt(o)]|=1<<n-o-1;return t}},function(e,t,n){var r=n(0);e.exports=function(e,t){return function e(t,n,o){if(n){var i=n.indexOf("."),a=n,s=null;-1!==i&&(a=n.slice(0,i),s=n.slice(i+1));var c=t[a];if(null!=c)if(s||"string"!=typeof c&&"number"!=typeof c)if(r(c))for(var h=0,l=c.length;h<l;h+=1)e(c[h],s,o);else s&&e(c,s,o);else o.push(c.toString())}else o.push(t);return o}(e,t,[])}}])});

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/oidc-client/1.7.1/node_modules/oidc-client/lib/oidc-client.min.js":
/*!************************************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/oidc-client/1.7.1/node_modules/oidc-client/lib/oidc-client.min.js ***!
  \************************************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

!function webpackUniversalModuleDefinition(e,t){if(true)module.exports=t();else { var n, r; }}(this,function(){return function(e){var t={};function __webpack_require__(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=e,__webpack_require__.c=t,__webpack_require__.d=function(e,t,r){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},__webpack_require__.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},__webpack_require__.t=function(e,t){if(1&t&&(e=__webpack_require__(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var n in e)__webpack_require__.d(r,n,function(t){return e[t]}.bind(null,n));return r},__webpack_require__.n=function(e){var t=e&&e.__esModule?function getDefault(){return e.default}:function getModuleExports(){return e};return __webpack_require__.d(t,"a",t),t},__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},__webpack_require__.p="",__webpack_require__(__webpack_require__.s=22)}([function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}();var i={debug:function debug(){},info:function info(){},warn:function warn(){},error:function error(){}},o=void 0,s=void 0;(t.Log=function(){function Log(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,Log)}return Log.reset=function reset(){s=3,o=i},Log.debug=function debug(){if(s>=4){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];o.debug.apply(o,Array.from(t))}},Log.info=function info(){if(s>=3){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];o.info.apply(o,Array.from(t))}},Log.warn=function warn(){if(s>=2){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];o.warn.apply(o,Array.from(t))}},Log.error=function error(){if(s>=1){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];o.error.apply(o,Array.from(t))}},n(Log,null,[{key:"NONE",get:function get(){return 0}},{key:"ERROR",get:function get(){return 1}},{key:"WARN",get:function get(){return 2}},{key:"INFO",get:function get(){return 3}},{key:"DEBUG",get:function get(){return 4}},{key:"level",get:function get(){return s},set:function set(e){if(!(0<=e&&e<=4))throw new Error("Invalid log level");s=e}},{key:"logger",get:function get(){return o},set:function set(e){if(!e.debug&&e.info&&(e.debug=e.info),!(e.debug&&e.info&&e.warn&&e.error))throw new Error("Invalid logger");o=e}}]),Log}()).reset()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}();var i={setInterval:function(e){function setInterval(t,r){return e.apply(this,arguments)}return setInterval.toString=function(){return e.toString()},setInterval}(function(e,t){return setInterval(e,t)}),clearInterval:function(e){function clearInterval(t){return e.apply(this,arguments)}return clearInterval.toString=function(){return e.toString()},clearInterval}(function(e){return clearInterval(e)})},o=!1,s=null;t.Global=function(){function Global(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,Global)}return Global._testing=function _testing(){o=!0},Global.setXMLHttpRequest=function setXMLHttpRequest(e){s=e},n(Global,null,[{key:"location",get:function get(){if(!o)return location}},{key:"localStorage",get:function get(){if(!o&&"undefined"!=typeof window)return localStorage}},{key:"sessionStorage",get:function get(){if(!o&&"undefined"!=typeof window)return sessionStorage}},{key:"XMLHttpRequest",get:function get(){if(!o&&"undefined"!=typeof window)return s||XMLHttpRequest}},{key:"timer",get:function get(){if(!o)return i}}]),Global}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.MetadataService=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(7);t.MetadataService=function(){function MetadataService(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.JsonService;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,MetadataService),!e)throw i.Log.error("MetadataService: No settings passed to MetadataService"),new Error("settings");this._settings=e,this._jsonService=new t(["application/jwk-set+json"])}return MetadataService.prototype.getMetadata=function getMetadata(){var e=this;return this._settings.metadata?(i.Log.debug("MetadataService.getMetadata: Returning metadata from settings"),Promise.resolve(this._settings.metadata)):this.metadataUrl?(i.Log.debug("MetadataService.getMetadata: getting metadata from",this.metadataUrl),this._jsonService.getJson(this.metadataUrl).then(function(t){return i.Log.debug("MetadataService.getMetadata: json received"),e._settings.metadata=t,t})):(i.Log.error("MetadataService.getMetadata: No authority or metadataUrl configured on settings"),Promise.reject(new Error("No authority or metadataUrl configured on settings")))},MetadataService.prototype.getIssuer=function getIssuer(){return this._getMetadataProperty("issuer")},MetadataService.prototype.getAuthorizationEndpoint=function getAuthorizationEndpoint(){return this._getMetadataProperty("authorization_endpoint")},MetadataService.prototype.getUserInfoEndpoint=function getUserInfoEndpoint(){return this._getMetadataProperty("userinfo_endpoint")},MetadataService.prototype.getTokenEndpoint=function getTokenEndpoint(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this._getMetadataProperty("token_endpoint",e)},MetadataService.prototype.getCheckSessionIframe=function getCheckSessionIframe(){return this._getMetadataProperty("check_session_iframe",!0)},MetadataService.prototype.getEndSessionEndpoint=function getEndSessionEndpoint(){return this._getMetadataProperty("end_session_endpoint",!0)},MetadataService.prototype.getRevocationEndpoint=function getRevocationEndpoint(){return this._getMetadataProperty("revocation_endpoint",!0)},MetadataService.prototype.getKeysEndpoint=function getKeysEndpoint(){return this._getMetadataProperty("jwks_uri",!0)},MetadataService.prototype._getMetadataProperty=function _getMetadataProperty(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return i.Log.debug("MetadataService.getMetadataProperty for: "+e),this.getMetadata().then(function(r){if(i.Log.debug("MetadataService.getMetadataProperty: metadata recieved"),void 0===r[e]){if(!0===t)return void i.Log.warn("MetadataService.getMetadataProperty: Metadata does not contain optional property "+e);throw i.Log.error("MetadataService.getMetadataProperty: Metadata does not contain property "+e),new Error("Metadata does not contain property "+e)}return r[e]})},MetadataService.prototype.getSigningKeys=function getSigningKeys(){var e=this;return this._settings.signingKeys?(i.Log.debug("MetadataService.getSigningKeys: Returning signingKeys from settings"),Promise.resolve(this._settings.signingKeys)):this._getMetadataProperty("jwks_uri").then(function(t){return i.Log.debug("MetadataService.getSigningKeys: jwks_uri received",t),e._jsonService.getJson(t).then(function(t){if(i.Log.debug("MetadataService.getSigningKeys: key set received",t),!t.keys)throw i.Log.error("MetadataService.getSigningKeys: Missing keys on keyset"),new Error("Missing keys on keyset");return e._settings.signingKeys=t.keys,e._settings.signingKeys})})},n(MetadataService,[{key:"metadataUrl",get:function get(){return this._metadataUrl||(this._settings.metadataUrl?this._metadataUrl=this._settings.metadataUrl:(this._metadataUrl=this._settings.authority,this._metadataUrl&&this._metadataUrl.indexOf(".well-known/openid-configuration")<0&&("/"!==this._metadataUrl[this._metadataUrl.length-1]&&(this._metadataUrl+="/"),this._metadataUrl+=".well-known/openid-configuration"))),this._metadataUrl}}]),MetadataService}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.UrlUtility=void 0;var n=r(0),i=r(1);t.UrlUtility=function(){function UrlUtility(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,UrlUtility)}return UrlUtility.addQueryParam=function addQueryParam(e,t,r){return e.indexOf("?")<0&&(e+="?"),"?"!==e[e.length-1]&&(e+="&"),e+=encodeURIComponent(t),e+="=",e+=encodeURIComponent(r)},UrlUtility.parseUrlFragment=function parseUrlFragment(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#",r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.Global;"string"!=typeof e&&(e=r.location.href);var o=e.lastIndexOf(t);o>=0&&(e=e.substr(o+1)),"?"===t&&(o=e.indexOf("#"))>=0&&(e=e.substr(0,o));for(var s,a={},u=/([^&=]+)=([^&]*)/g,c=0;s=u.exec(e);)if(a[decodeURIComponent(s[1])]=decodeURIComponent(s[2]),c++>50)return n.Log.error("UrlUtility.parseUrlFragment: response exceeded expected number of parameters",e),{error:"Response exceeded expected number of parameters"};for(var h in a)return a;return{}},UrlUtility}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.JoseUtil=void 0;var n=r(25),i=r(0);var o=["RS256","RS384","RS512","PS256","PS384","PS512","ES256","ES384","ES512"];t.JoseUtil=function(){function JoseUtil(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,JoseUtil)}return JoseUtil.parseJwt=function parseJwt(e){i.Log.debug("JoseUtil.parseJwt");try{var t=n.jws.JWS.parse(e);return{header:t.headerObj,payload:t.payloadObj}}catch(e){i.Log.error(e)}},JoseUtil.validateJwt=function validateJwt(e,t,r,o,s,a,u){i.Log.debug("JoseUtil.validateJwt");try{if("RSA"===t.kty)if(t.e&&t.n)t=n.KEYUTIL.getKey(t);else{if(!t.x5c||!t.x5c.length)return i.Log.error("JoseUtil.validateJwt: RSA key missing key material",t),Promise.reject(new Error("RSA key missing key material"));var c=(0,n.b64tohex)(t.x5c[0]);t=n.X509.getPublicKeyFromCertHex(c)}else{if("EC"!==t.kty)return i.Log.error("JoseUtil.validateJwt: Unsupported key type",t&&t.kty),Promise.reject(new Error(t.kty));if(!(t.crv&&t.x&&t.y))return i.Log.error("JoseUtil.validateJwt: EC key missing key material",t),Promise.reject(new Error("EC key missing key material"));t=n.KEYUTIL.getKey(t)}return JoseUtil._validateJwt(e,t,r,o,s,a,u)}catch(e){return i.Log.error(e&&e.message||e),Promise.reject("JWT validation failed")}},JoseUtil.validateJwtAttributes=function validateJwtAttributes(e,t,r,n,o,s){n||(n=0),o||(o=parseInt(Date.now()/1e3));var a=JoseUtil.parseJwt(e).payload;if(!a.iss)return i.Log.error("JoseUtil._validateJwt: issuer was not provided"),Promise.reject(new Error("issuer was not provided"));if(a.iss!==t)return i.Log.error("JoseUtil._validateJwt: Invalid issuer in token",a.iss),Promise.reject(new Error("Invalid issuer in token: "+a.iss));if(!a.aud)return i.Log.error("JoseUtil._validateJwt: aud was not provided"),Promise.reject(new Error("aud was not provided"));if(!(a.aud===r||Array.isArray(a.aud)&&a.aud.indexOf(r)>=0))return i.Log.error("JoseUtil._validateJwt: Invalid audience in token",a.aud),Promise.reject(new Error("Invalid audience in token: "+a.aud));if(a.azp&&a.azp!==r)return i.Log.error("JoseUtil._validateJwt: Invalid azp in token",a.azp),Promise.reject(new Error("Invalid azp in token: "+a.azp));if(!s){var u=o+n,c=o-n;if(!a.iat)return i.Log.error("JoseUtil._validateJwt: iat was not provided"),Promise.reject(new Error("iat was not provided"));if(u<a.iat)return i.Log.error("JoseUtil._validateJwt: iat is in the future",a.iat),Promise.reject(new Error("iat is in the future: "+a.iat));if(a.nbf&&u<a.nbf)return i.Log.error("JoseUtil._validateJwt: nbf is in the future",a.nbf),Promise.reject(new Error("nbf is in the future: "+a.nbf));if(!a.exp)return i.Log.error("JoseUtil._validateJwt: exp was not provided"),Promise.reject(new Error("exp was not provided"));if(a.exp<c)return i.Log.error("JoseUtil._validateJwt: exp is in the past",a.exp),Promise.reject(new Error("exp is in the past:"+a.exp))}return Promise.resolve(a)},JoseUtil._validateJwt=function _validateJwt(e,t,r,s,a,u,c){return JoseUtil.validateJwtAttributes(e,r,s,a,u,c).then(function(r){try{return n.jws.JWS.verify(e,t,o)?r:(i.Log.error("JoseUtil._validateJwt: signature validation failed"),Promise.reject(new Error("signature validation failed")))}catch(e){return i.Log.error(e&&e.message||e),Promise.reject(new Error("signature validation failed"))}})},JoseUtil.hashString=function hashString(e,t){try{return n.crypto.Util.hashString(e,t)}catch(e){i.Log.error(e)}},JoseUtil.hexToBase64Url=function hexToBase64Url(e){try{return(0,n.hextob64u)(e)}catch(e){i.Log.error(e)}},JoseUtil}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OidcClientSettings=void 0;var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),o=r(0),s=r(6),a=r(23),u=r(2);var c="id_token",h="openid",l=900,f=300;t.OidcClientSettings=function(){function OidcClientSettings(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.authority,r=e.metadataUrl,i=e.metadata,o=e.signingKeys,g=e.client_id,p=e.client_secret,d=e.response_type,v=void 0===d?c:d,y=e.scope,m=void 0===y?h:y,_=e.redirect_uri,S=e.post_logout_redirect_uri,b=e.prompt,F=e.display,w=e.max_age,E=e.ui_locales,x=e.acr_values,C=e.resource,k=e.response_mode,A=e.filterProtocolClaims,P=void 0===A||A,I=e.loadUserInfo,B=void 0===I||I,R=e.staleStateAge,T=void 0===R?l:R,U=e.clockSkew,D=void 0===U?f:U,L=e.userInfoJwtIssuer,M=void 0===L?"OP":L,N=e.stateStore,O=void 0===N?new s.WebStorageStateStore:N,H=e.ResponseValidatorCtor,j=void 0===H?a.ResponseValidator:H,K=e.MetadataServiceCtor,V=void 0===K?u.MetadataService:K,q=e.extraQueryParams,W=void 0===q?{}:q;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,OidcClientSettings),this._authority=t,this._metadataUrl=r,this._metadata=i,this._signingKeys=o,this._client_id=g,this._client_secret=p,this._response_type=v,this._scope=m,this._redirect_uri=_,this._post_logout_redirect_uri=S,this._prompt=b,this._display=F,this._max_age=w,this._ui_locales=E,this._acr_values=x,this._resource=C,this._response_mode=k,this._filterProtocolClaims=!!P,this._loadUserInfo=!!B,this._staleStateAge=T,this._clockSkew=D,this._userInfoJwtIssuer=M,this._stateStore=O,this._validator=new j(this),this._metadataService=new V(this),this._extraQueryParams="object"===(void 0===W?"undefined":n(W))?W:{}}return i(OidcClientSettings,[{key:"client_id",get:function get(){return this._client_id},set:function set(e){if(this._client_id)throw o.Log.error("OidcClientSettings.set_client_id: client_id has already been assigned."),new Error("client_id has already been assigned.");this._client_id=e}},{key:"client_secret",get:function get(){return this._client_secret}},{key:"response_type",get:function get(){return this._response_type}},{key:"scope",get:function get(){return this._scope}},{key:"redirect_uri",get:function get(){return this._redirect_uri}},{key:"post_logout_redirect_uri",get:function get(){return this._post_logout_redirect_uri}},{key:"prompt",get:function get(){return this._prompt}},{key:"display",get:function get(){return this._display}},{key:"max_age",get:function get(){return this._max_age}},{key:"ui_locales",get:function get(){return this._ui_locales}},{key:"acr_values",get:function get(){return this._acr_values}},{key:"resource",get:function get(){return this._resource}},{key:"response_mode",get:function get(){return this._response_mode}},{key:"authority",get:function get(){return this._authority},set:function set(e){if(this._authority)throw o.Log.error("OidcClientSettings.set_authority: authority has already been assigned."),new Error("authority has already been assigned.");this._authority=e}},{key:"metadataUrl",get:function get(){return this._metadataUrl||(this._metadataUrl=this.authority,this._metadataUrl&&this._metadataUrl.indexOf(".well-known/openid-configuration")<0&&("/"!==this._metadataUrl[this._metadataUrl.length-1]&&(this._metadataUrl+="/"),this._metadataUrl+=".well-known/openid-configuration")),this._metadataUrl}},{key:"metadata",get:function get(){return this._metadata},set:function set(e){this._metadata=e}},{key:"signingKeys",get:function get(){return this._signingKeys},set:function set(e){this._signingKeys=e}},{key:"filterProtocolClaims",get:function get(){return this._filterProtocolClaims}},{key:"loadUserInfo",get:function get(){return this._loadUserInfo}},{key:"staleStateAge",get:function get(){return this._staleStateAge}},{key:"clockSkew",get:function get(){return this._clockSkew}},{key:"userInfoJwtIssuer",get:function get(){return this._userInfoJwtIssuer}},{key:"stateStore",get:function get(){return this._stateStore}},{key:"validator",get:function get(){return this._validator}},{key:"metadataService",get:function get(){return this._metadataService}},{key:"extraQueryParams",get:function get(){return this._extraQueryParams},set:function set(e){"object"===(void 0===e?"undefined":n(e))?this._extraQueryParams=e:this._extraQueryParams={}}}]),OidcClientSettings}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.WebStorageStateStore=void 0;var n=r(0),i=r(1);t.WebStorageStateStore=function(){function WebStorageStateStore(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.prefix,r=void 0===t?"oidc.":t,n=e.store,o=void 0===n?i.Global.localStorage:n;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,WebStorageStateStore),this._store=o,this._prefix=r}return WebStorageStateStore.prototype.set=function set(e,t){return n.Log.debug("WebStorageStateStore.set",e),e=this._prefix+e,this._store.setItem(e,t),Promise.resolve()},WebStorageStateStore.prototype.get=function get(e){n.Log.debug("WebStorageStateStore.get",e),e=this._prefix+e;var t=this._store.getItem(e);return Promise.resolve(t)},WebStorageStateStore.prototype.remove=function remove(e){n.Log.debug("WebStorageStateStore.remove",e),e=this._prefix+e;var t=this._store.getItem(e);return this._store.removeItem(e),Promise.resolve(t)},WebStorageStateStore.prototype.getAllKeys=function getAllKeys(){n.Log.debug("WebStorageStateStore.getAllKeys");for(var e=[],t=0;t<this._store.length;t++){var r=this._store.key(t);0===r.indexOf(this._prefix)&&e.push(r.substr(this._prefix.length))}return Promise.resolve(e)},WebStorageStateStore}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.JsonService=void 0;var n=r(0),i=r(1);t.JsonService=function(){function JsonService(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.Global.XMLHttpRequest,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,JsonService),e&&Array.isArray(e)?this._contentTypes=e.slice():this._contentTypes=[],this._contentTypes.push("application/json"),r&&this._contentTypes.push("application/jwt"),this._XMLHttpRequest=t,this._jwtHandler=r}return JsonService.prototype.getJson=function getJson(e,t){var r=this;if(!e)throw n.Log.error("JsonService.getJson: No url passed"),new Error("url");return n.Log.debug("JsonService.getJson, url: ",e),new Promise(function(i,o){var s=new r._XMLHttpRequest;s.open("GET",e);var a=r._contentTypes,u=r._jwtHandler;s.onload=function(){if(n.Log.debug("JsonService.getJson: HTTP response received, status",s.status),200===s.status){var t=s.getResponseHeader("Content-Type");if(t){var r=a.find(function(e){if(t.startsWith(e))return!0});if("application/jwt"==r)return void u(s).then(i,o);if(r)try{return void i(JSON.parse(s.responseText))}catch(e){return n.Log.error("JsonService.getJson: Error parsing JSON response",e.message),void o(e)}}o(Error("Invalid response Content-Type: "+t+", from URL: "+e))}else o(Error(s.statusText+" ("+s.status+")"))},s.onerror=function(){n.Log.error("JsonService.getJson: network error"),o(Error("Network Error"))},t&&(n.Log.debug("JsonService.getJson: token passed, setting Authorization header"),s.setRequestHeader("Authorization","Bearer "+t)),s.send()})},JsonService.prototype.postForm=function postForm(e,t){var r=this;if(!e)throw n.Log.error("JsonService.postForm: No url passed"),new Error("url");return n.Log.debug("JsonService.postForm, url: ",e),new Promise(function(i,o){var s=new r._XMLHttpRequest;s.open("POST",e);var a=r._contentTypes;s.onload=function(){if(n.Log.debug("JsonService.postForm: HTTP response received, status",s.status),200!==s.status){if(400===s.status)if(r=s.getResponseHeader("Content-Type"))if(a.find(function(e){if(r.startsWith(e))return!0}))try{var t=JSON.parse(s.responseText);if(t&&t.error)return n.Log.error("JsonService.postForm: Error from server: ",t.error),void o(new Error(t.error))}catch(e){return n.Log.error("JsonService.postForm: Error parsing JSON response",e.message),void o(e)}o(Error(s.statusText+" ("+s.status+")"))}else{var r;if((r=s.getResponseHeader("Content-Type"))&&a.find(function(e){if(r.startsWith(e))return!0}))try{return void i(JSON.parse(s.responseText))}catch(e){return n.Log.error("JsonService.postForm: Error parsing JSON response",e.message),void o(e)}o(Error("Invalid response Content-Type: "+r+", from URL: "+e))}},s.onerror=function(){n.Log.error("JsonService.postForm: network error"),o(Error("Network Error"))};var u="";for(var c in t){var h=t[c];h&&(u.length>0&&(u+="&"),u+=encodeURIComponent(c),u+="=",u+=encodeURIComponent(h))}s.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),s.send(u)})},JsonService}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.State=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}(r(14));t.State=function(){function State(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.id,r=e.data,n=e.created;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,State),this._id=t||(0,o.default)(),this._data=r,this._created="number"==typeof n&&n>0?n:parseInt(Date.now()/1e3)}return State.prototype.toStorageString=function toStorageString(){return i.Log.debug("State.toStorageString"),JSON.stringify({id:this.id,data:this.data,created:this.created})},State.fromStorageString=function fromStorageString(e){return i.Log.debug("State.fromStorageString"),new State(JSON.parse(e))},State.clearStaleState=function clearStaleState(e,t){var r=Date.now()/1e3-t;return e.getAllKeys().then(function(t){i.Log.debug("State.clearStaleState: got keys",t);for(var n=[],o=function _loop(o){var s=t[o];a=e.get(s).then(function(t){var n=!1;if(t)try{var o=State.fromStorageString(t);i.Log.debug("State.clearStaleState: got item from key: ",s,o.created),o.created<=r&&(n=!0)}catch(e){i.Log.error("State.clearStaleState: Error parsing state for key",s,e.message),n=!0}else i.Log.debug("State.clearStaleState: no item in storage for key: ",s),n=!0;if(n)return i.Log.debug("State.clearStaleState: removed item for key: ",s),e.remove(s)}),n.push(a)},s=0;s<t.length;s++){var a;o(s)}return i.Log.debug("State.clearStaleState: waiting on promise count:",n.length),Promise.all(n)})},n(State,[{key:"id",get:function get(){return this._id}},{key:"data",get:function get(){return this._data}},{key:"created",get:function get(){return this._created}}]),State}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.OidcClient=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(5),s=r(11),a=r(12),u=r(34),c=r(35),h=r(36),l=r(13),f=r(8);t.OidcClient=function(){function OidcClient(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,OidcClient),e instanceof o.OidcClientSettings?this._settings=e:this._settings=new o.OidcClientSettings(e)}return OidcClient.prototype.createSigninRequest=function createSigninRequest(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.response_type,n=t.scope,o=t.redirect_uri,s=t.data,u=t.state,c=t.prompt,h=t.display,l=t.max_age,f=t.ui_locales,g=t.id_token_hint,p=t.login_hint,d=t.acr_values,v=t.resource,y=t.request,m=t.request_uri,_=t.response_mode,S=t.extraQueryParams,b=arguments[1];i.Log.debug("OidcClient.createSigninRequest");var F=this._settings.client_id;r=r||this._settings.response_type,n=n||this._settings.scope,o=o||this._settings.redirect_uri,c=c||this._settings.prompt,h=h||this._settings.display,l=l||this._settings.max_age,f=f||this._settings.ui_locales,d=d||this._settings.acr_values,v=v||this._settings.resource,_=_||this._settings.response_mode,S=S||this._settings.extraQueryParams;var w=this._settings.authority;return a.SigninRequest.isCode(r)&&"code"!==r?Promise.reject(new Error("OpenID Connect hybrid flow is not supported")):this._metadataService.getAuthorizationEndpoint().then(function(t){i.Log.debug("OidcClient.createSigninRequest: Received authorization endpoint",t);var E=new a.SigninRequest({url:t,client_id:F,redirect_uri:o,response_type:r,scope:n,data:s||u,authority:w,prompt:c,display:h,max_age:l,ui_locales:f,id_token_hint:g,login_hint:p,acr_values:d,resource:v,request:y,request_uri:m,extraQueryParams:S,response_mode:_}),x=E.state;return(b=b||e._stateStore).set(x.id,x.toStorageString()).then(function(){return E})})},OidcClient.prototype.processSigninResponse=function processSigninResponse(e,t){var r=this;i.Log.debug("OidcClient.processSigninResponse");var n="query"===this._settings.response_mode||!this._settings.response_mode&&a.SigninRequest.isCode(this._settings.response_type)?"?":"#",o=new u.SigninResponse(e,n);return o.state?(t=t||this._stateStore).remove(o.state).then(function(e){if(!e)throw i.Log.error("OidcClient.processSigninResponse: No matching state found in storage"),new Error("No matching state found in storage");var t=l.SigninState.fromStorageString(e);return i.Log.debug("OidcClient.processSigninResponse: Received state from storage; validating response"),r._validator.validateSigninResponse(t,o)}):(i.Log.error("OidcClient.processSigninResponse: No state in response"),Promise.reject(new Error("No state in response")))},OidcClient.prototype.createSignoutRequest=function createSignoutRequest(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.id_token_hint,n=t.data,o=t.state,s=t.post_logout_redirect_uri,a=t.extraQueryParams,u=arguments[1];return i.Log.debug("OidcClient.createSignoutRequest"),s=s||this._settings.post_logout_redirect_uri,a=a||this._settings.extraQueryParams,this._metadataService.getEndSessionEndpoint().then(function(t){if(!t)throw i.Log.error("OidcClient.createSignoutRequest: No end session endpoint url returned"),new Error("no end session endpoint");i.Log.debug("OidcClient.createSignoutRequest: Received end session endpoint",t);var h=new c.SignoutRequest({url:t,id_token_hint:r,post_logout_redirect_uri:s,data:n||o,extraQueryParams:a}),l=h.state;return l&&(i.Log.debug("OidcClient.createSignoutRequest: Signout request has state to persist"),(u=u||e._stateStore).set(l.id,l.toStorageString())),h})},OidcClient.prototype.processSignoutResponse=function processSignoutResponse(e,t){var r=this;i.Log.debug("OidcClient.processSignoutResponse");var n=new h.SignoutResponse(e);if(!n.state)return i.Log.debug("OidcClient.processSignoutResponse: No state in response"),n.error?(i.Log.warn("OidcClient.processSignoutResponse: Response was error: ",n.error),Promise.reject(new s.ErrorResponse(n))):Promise.resolve(n);var o=n.state;return(t=t||this._stateStore).remove(o).then(function(e){if(!e)throw i.Log.error("OidcClient.processSignoutResponse: No matching state found in storage"),new Error("No matching state found in storage");var t=f.State.fromStorageString(e);return i.Log.debug("OidcClient.processSignoutResponse: Received state from storage; validating response"),r._validator.validateSignoutResponse(t,n)})},OidcClient.prototype.clearStaleState=function clearStaleState(e){return i.Log.debug("OidcClient.clearStaleState"),e=e||this._stateStore,f.State.clearStaleState(e,this.settings.staleStateAge)},n(OidcClient,[{key:"_stateStore",get:function get(){return this.settings.stateStore}},{key:"_validator",get:function get(){return this.settings.validator}},{key:"_metadataService",get:function get(){return this.settings.metadataService}},{key:"settings",get:function get(){return this._settings}},{key:"metadataService",get:function get(){return this._metadataService}}]),OidcClient}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TokenClient=void 0;var n=r(7),i=r(2),o=r(0);t.TokenClient=function(){function TokenClient(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.JsonService,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,TokenClient),!e)throw o.Log.error("TokenClient.ctor: No settings passed"),new Error("settings");this._settings=e,this._jsonService=new t,this._metadataService=new r(this._settings)}return TokenClient.prototype.exchangeCode=function exchangeCode(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.grant_type=t.grant_type||"authorization_code",t.client_id=t.client_id||this._settings.client_id,t.redirect_uri=t.redirect_uri||this._settings.redirect_uri,t.code?t.redirect_uri?t.code_verifier?t.client_id?this._metadataService.getTokenEndpoint(!1).then(function(r){return o.Log.debug("TokenClient.exchangeCode: Received token endpoint"),e._jsonService.postForm(r,t).then(function(e){return o.Log.debug("TokenClient.exchangeCode: response received"),e})}):(o.Log.error("TokenClient.exchangeCode: No client_id passed"),Promise.reject(new Error("A client_id is required"))):(o.Log.error("TokenClient.exchangeCode: No code_verifier passed"),Promise.reject(new Error("A code_verifier is required"))):(o.Log.error("TokenClient.exchangeCode: No redirect_uri passed"),Promise.reject(new Error("A redirect_uri is required"))):(o.Log.error("TokenClient.exchangeCode: No code passed"),Promise.reject(new Error("A code is required")))},TokenClient.prototype.exchangeRefreshToken=function exchangeRefreshToken(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.grant_type=t.grant_type||"refresh_token",t.client_id=t.client_id||this._settings.client_id,t.refresh_token?t.client_id?this._metadataService.getTokenEndpoint(!1).then(function(r){return o.Log.debug("TokenClient.exchangeRefreshToken: Received token endpoint"),e._jsonService.postForm(r,t).then(function(e){return o.Log.debug("TokenClient.exchangeRefreshToken: response received"),e})}):(o.Log.error("TokenClient.exchangeRefreshToken: No client_id passed"),Promise.reject(new Error("A client_id is required"))):(o.Log.error("TokenClient.exchangeRefreshToken: No refresh_token passed"),Promise.reject(new Error("A refresh_token is required")))},TokenClient}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ErrorResponse=void 0;var n=r(0);t.ErrorResponse=function(e){function ErrorResponse(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.error,i=t.error_description,o=t.error_uri,s=t.state;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,ErrorResponse),!r)throw n.Log.error("No error passed to ErrorResponse"),new Error("error");var a=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,e.call(this,i||r));return a.name="ErrorResponse",a.error=r,a.error_description=i,a.error_uri=o,a.state=s,a}return function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(ErrorResponse,e),ErrorResponse}(Error)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SigninRequest=void 0;var n=r(0),i=r(3),o=r(13);t.SigninRequest=function(){function SigninRequest(e){var t=e.url,r=e.client_id,s=e.redirect_uri,a=e.response_type,u=e.scope,c=e.authority,h=e.data,l=e.prompt,f=e.display,g=e.max_age,p=e.ui_locales,d=e.id_token_hint,v=e.login_hint,y=e.acr_values,m=e.resource,_=e.response_mode,S=e.request,b=e.request_uri,F=e.extraQueryParams;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,SigninRequest),!t)throw n.Log.error("SigninRequest.ctor: No url passed"),new Error("url");if(!r)throw n.Log.error("SigninRequest.ctor: No client_id passed"),new Error("client_id");if(!s)throw n.Log.error("SigninRequest.ctor: No redirect_uri passed"),new Error("redirect_uri");if(!a)throw n.Log.error("SigninRequest.ctor: No response_type passed"),new Error("response_type");if(!u)throw n.Log.error("SigninRequest.ctor: No scope passed"),new Error("scope");if(!c)throw n.Log.error("SigninRequest.ctor: No authority passed"),new Error("authority");var w=SigninRequest.isOidc(a),E=SigninRequest.isCode(a);this.state=new o.SigninState({nonce:w,data:h,client_id:r,authority:c,redirect_uri:s,code_verifier:E}),t=i.UrlUtility.addQueryParam(t,"client_id",r),t=i.UrlUtility.addQueryParam(t,"redirect_uri",s),t=i.UrlUtility.addQueryParam(t,"response_type",a),t=i.UrlUtility.addQueryParam(t,"scope",u),t=i.UrlUtility.addQueryParam(t,"state",this.state.id),w&&(t=i.UrlUtility.addQueryParam(t,"nonce",this.state.nonce)),E&&(t=i.UrlUtility.addQueryParam(t,"code_challenge",this.state.code_challenge),t=i.UrlUtility.addQueryParam(t,"code_challenge_method","S256"));var x={prompt:l,display:f,max_age:g,ui_locales:p,id_token_hint:d,login_hint:v,acr_values:y,resource:m,request:S,request_uri:b,response_mode:_};for(var C in x)x[C]&&(t=i.UrlUtility.addQueryParam(t,C,x[C]));for(var k in F)t=i.UrlUtility.addQueryParam(t,k,F[k]);this.url=t}return SigninRequest.isOidc=function isOidc(e){return!!e.split(/\s+/g).filter(function(e){return"id_token"===e})[0]},SigninRequest.isOAuth=function isOAuth(e){return!!e.split(/\s+/g).filter(function(e){return"token"===e})[0]},SigninRequest.isCode=function isCode(e){return!!e.split(/\s+/g).filter(function(e){return"code"===e})[0]},SigninRequest}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SigninState=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(8),s=r(4),a=function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}(r(14));t.SigninState=function(e){function SigninState(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.nonce,n=t.authority,i=t.client_id,o=t.redirect_uri,u=t.code_verifier;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,SigninState);var c=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,e.call(this,arguments[0]));if(!0===r?c._nonce=(0,a.default)():r&&(c._nonce=r),!0===u?c._code_verifier=(0,a.default)()+(0,a.default)()+(0,a.default)():u&&(c._code_verifier=u),c.code_verifier){var h=s.JoseUtil.hashString(c.code_verifier,"SHA256");c._code_challenge=s.JoseUtil.hexToBase64Url(h)}return c._redirect_uri=o,c._authority=n,c._client_id=i,c}return function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(SigninState,e),SigninState.prototype.toStorageString=function toStorageString(){return i.Log.debug("SigninState.toStorageString"),JSON.stringify({id:this.id,data:this.data,created:this.created,nonce:this.nonce,code_verifier:this.code_verifier,redirect_uri:this.redirect_uri,authority:this.authority,client_id:this.client_id})},SigninState.fromStorageString=function fromStorageString(e){return i.Log.debug("SigninState.fromStorageString"),new SigninState(JSON.parse(e))},n(SigninState,[{key:"nonce",get:function get(){return this._nonce}},{key:"authority",get:function get(){return this._authority}},{key:"client_id",get:function get(){return this._client_id}},{key:"redirect_uri",get:function get(){return this._redirect_uri}},{key:"code_verifier",get:function get(){return this._code_verifier}},{key:"code_challenge",get:function get(){return this._code_challenge}}]),SigninState}(o.State)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.default=function random(){return n().replace(/-/g,"")};var n=r(31);e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.User=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);t.User=function(){function User(e){var t=e.id_token,r=e.session_state,n=e.access_token,i=e.refresh_token,o=e.token_type,s=e.scope,a=e.profile,u=e.expires_at,c=e.state;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,User),this.id_token=t,this.session_state=r,this.access_token=n,this.refresh_token=i,this.token_type=o,this.scope=s,this.profile=a,this.expires_at=u,this.state=c}return User.prototype.toStorageString=function toStorageString(){return i.Log.debug("User.toStorageString"),JSON.stringify({id_token:this.id_token,session_state:this.session_state,access_token:this.access_token,refresh_token:this.refresh_token,token_type:this.token_type,scope:this.scope,profile:this.profile,expires_at:this.expires_at})},User.fromStorageString=function fromStorageString(e){return i.Log.debug("User.fromStorageString"),new User(JSON.parse(e))},n(User,[{key:"expires_in",get:function get(){if(this.expires_at){var e=parseInt(Date.now()/1e3);return this.expires_at-e}},set:function set(e){var t=parseInt(e);if("number"==typeof t&&t>0){var r=parseInt(Date.now()/1e3);this.expires_at=r+t}}},{key:"expired",get:function get(){var e=this.expires_in;if(void 0!==e)return e<=0}},{key:"scopes",get:function get(){return(this.scope||"").split(" ")}}]),User}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.AccessTokenEvents=void 0;var n=r(0),i=r(46);var o=60;t.AccessTokenEvents=function(){function AccessTokenEvents(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.accessTokenExpiringNotificationTime,r=void 0===t?o:t,n=e.accessTokenExpiringTimer,s=void 0===n?new i.Timer("Access token expiring"):n,a=e.accessTokenExpiredTimer,u=void 0===a?new i.Timer("Access token expired"):a;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,AccessTokenEvents),this._accessTokenExpiringNotificationTime=r,this._accessTokenExpiring=s,this._accessTokenExpired=u}return AccessTokenEvents.prototype.load=function load(e){if(e.access_token&&void 0!==e.expires_in){var t=e.expires_in;if(n.Log.debug("AccessTokenEvents.load: access token present, remaining duration:",t),t>0){var r=t-this._accessTokenExpiringNotificationTime;r<=0&&(r=1),n.Log.debug("AccessTokenEvents.load: registering expiring timer in:",r),this._accessTokenExpiring.init(r)}else n.Log.debug("AccessTokenEvents.load: canceling existing expiring timer becase we're past expiration."),this._accessTokenExpiring.cancel();var i=t+1;n.Log.debug("AccessTokenEvents.load: registering expired timer in:",i),this._accessTokenExpired.init(i)}else this._accessTokenExpiring.cancel(),this._accessTokenExpired.cancel()},AccessTokenEvents.prototype.unload=function unload(){n.Log.debug("AccessTokenEvents.unload: canceling existing access token timers"),this._accessTokenExpiring.cancel(),this._accessTokenExpired.cancel()},AccessTokenEvents.prototype.addAccessTokenExpiring=function addAccessTokenExpiring(e){this._accessTokenExpiring.addHandler(e)},AccessTokenEvents.prototype.removeAccessTokenExpiring=function removeAccessTokenExpiring(e){this._accessTokenExpiring.removeHandler(e)},AccessTokenEvents.prototype.addAccessTokenExpired=function addAccessTokenExpired(e){this._accessTokenExpired.addHandler(e)},AccessTokenEvents.prototype.removeAccessTokenExpired=function removeAccessTokenExpired(e){this._accessTokenExpired.removeHandler(e)},AccessTokenEvents}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Event=void 0;var n=r(0);t.Event=function(){function Event(e){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,Event),this._name=e,this._callbacks=[]}return Event.prototype.addHandler=function addHandler(e){this._callbacks.push(e)},Event.prototype.removeHandler=function removeHandler(e){var t=this._callbacks.findIndex(function(t){return t===e});t>=0&&this._callbacks.splice(t,1)},Event.prototype.raise=function raise(){n.Log.debug("Event: Raising event: "+this._name);for(var e=0;e<this._callbacks.length;e++){var t;(t=this._callbacks)[e].apply(t,arguments)}},Event}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SessionMonitor=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(19);t.SessionMonitor=function(){function SessionMonitor(e){var t=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.CheckSessionIFrame;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,SessionMonitor),!e)throw i.Log.error("SessionMonitor.ctor: No user manager passed to SessionMonitor"),new Error("userManager");this._userManager=e,this._CheckSessionIFrameCtor=r,this._userManager.events.addUserLoaded(this._start.bind(this)),this._userManager.events.addUserUnloaded(this._stop.bind(this)),this._userManager.getUser().then(function(e){e&&t._start(e)}).catch(function(e){i.Log.error("SessionMonitor ctor: error from getUser:",e.message)})}return SessionMonitor.prototype._start=function _start(e){var t=this,r=e.session_state;r&&(this._sub=e.profile.sub,this._sid=e.profile.sid,i.Log.debug("SessionMonitor._start: session_state:",r,", sub:",this._sub),this._checkSessionIFrame?this._checkSessionIFrame.start(r):this._metadataService.getCheckSessionIframe().then(function(e){if(e){i.Log.debug("SessionMonitor._start: Initializing check session iframe");var n=t._client_id,o=t._checkSessionInterval,s=t._stopCheckSessionOnError;t._checkSessionIFrame=new t._CheckSessionIFrameCtor(t._callback.bind(t),n,e,o,s),t._checkSessionIFrame.load().then(function(){t._checkSessionIFrame.start(r)})}else i.Log.warn("SessionMonitor._start: No check session iframe found in the metadata")}).catch(function(e){i.Log.error("SessionMonitor._start: Error from getCheckSessionIframe:",e.message)}))},SessionMonitor.prototype._stop=function _stop(){this._sub=null,this._sid=null,this._checkSessionIFrame&&(i.Log.debug("SessionMonitor._stop"),this._checkSessionIFrame.stop())},SessionMonitor.prototype._callback=function _callback(){var e=this;this._userManager.querySessionStatus().then(function(t){var r=!0;t?t.sub===e._sub?(r=!1,e._checkSessionIFrame.start(t.session_state),t.sid===e._sid?i.Log.debug("SessionMonitor._callback: Same sub still logged in at OP, restarting check session iframe; session_state:",t.session_state):(i.Log.debug("SessionMonitor._callback: Same sub still logged in at OP, session state has changed, restarting check session iframe; session_state:",t.session_state),e._userManager.events._raiseUserSessionChanged())):i.Log.debug("SessionMonitor._callback: Different subject signed into OP:",t.sub):i.Log.debug("SessionMonitor._callback: Subject no longer signed into OP"),r&&(i.Log.debug("SessionMonitor._callback: SessionMonitor._callback; raising signed out event"),e._userManager.events._raiseUserSignedOut())}).catch(function(t){i.Log.debug("SessionMonitor._callback: Error calling queryCurrentSigninSession; raising signed out event",t.message),e._userManager.events._raiseUserSignedOut()})},n(SessionMonitor,[{key:"_settings",get:function get(){return this._userManager.settings}},{key:"_metadataService",get:function get(){return this._userManager.metadataService}},{key:"_client_id",get:function get(){return this._settings.client_id}},{key:"_checkSessionInterval",get:function get(){return this._settings.checkSessionInterval}},{key:"_stopCheckSessionOnError",get:function get(){return this._settings.stopCheckSessionOnError}}]),SessionMonitor}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CheckSessionIFrame=void 0;var n=r(0);var i=2e3;t.CheckSessionIFrame=function(){function CheckSessionIFrame(e,t,r,n){var o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,CheckSessionIFrame),this._callback=e,this._client_id=t,this._url=r,this._interval=n||i,this._stopOnError=o;var s=r.indexOf("/",r.indexOf("//")+2);this._frame_origin=r.substr(0,s),this._frame=window.document.createElement("iframe"),this._frame.style.visibility="hidden",this._frame.style.position="absolute",this._frame.style.display="none",this._frame.style.width=0,this._frame.style.height=0,this._frame.src=r}return CheckSessionIFrame.prototype.load=function load(){var e=this;return new Promise(function(t){e._frame.onload=function(){t()},window.document.body.appendChild(e._frame),e._boundMessageEvent=e._message.bind(e),window.addEventListener("message",e._boundMessageEvent,!1)})},CheckSessionIFrame.prototype._message=function _message(e){e.origin===this._frame_origin&&e.source===this._frame.contentWindow&&("error"===e.data?(n.Log.error("CheckSessionIFrame: error message from check session op iframe"),this._stopOnError&&this.stop()):"changed"===e.data?(n.Log.debug("CheckSessionIFrame: changed message from check session op iframe"),this.stop(),this._callback()):n.Log.debug("CheckSessionIFrame: "+e.data+" message from check session op iframe"))},CheckSessionIFrame.prototype.start=function start(e){var t=this;if(this._session_state!==e){n.Log.debug("CheckSessionIFrame.start"),this.stop(),this._session_state=e;var r=function send(){t._frame.contentWindow.postMessage(t._client_id+" "+t._session_state,t._frame_origin)};r(),this._timer=window.setInterval(r,this._interval)}},CheckSessionIFrame.prototype.stop=function stop(){this._session_state=null,this._timer&&(n.Log.debug("CheckSessionIFrame.stop"),window.clearInterval(this._timer),this._timer=null)},CheckSessionIFrame}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.TokenRevocationClient=void 0;var n=r(0),i=r(2),o=r(1);t.TokenRevocationClient=function(){function TokenRevocationClient(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.Global.XMLHttpRequest,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,TokenRevocationClient),!e)throw n.Log.error("TokenRevocationClient.ctor: No settings provided"),new Error("No settings provided.");this._settings=e,this._XMLHttpRequestCtor=t,this._metadataService=new r(this._settings)}return TokenRevocationClient.prototype.revoke=function revoke(e,t){var r=this,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"access_token";if(!e)throw n.Log.error("TokenRevocationClient.revoke: No token provided"),new Error("No token provided.");if("access_token"!==i&&"refresh_token"!=i)throw n.Log.error("TokenRevocationClient.revoke: Invalid token type"),new Error("Invalid token type.");return this._metadataService.getRevocationEndpoint().then(function(o){if(o){n.Log.debug("TokenRevocationClient.revoke: Revoking "+i);var s=r._settings.client_id,a=r._settings.client_secret;return r._revoke(o,s,a,e,i)}if(t)throw n.Log.error("TokenRevocationClient.revoke: Revocation not supported"),new Error("Revocation not supported")})},TokenRevocationClient.prototype._revoke=function _revoke(e,t,r,i,o){var s=this;return new Promise(function(a,u){var c=new s._XMLHttpRequestCtor;c.open("POST",e),c.onload=function(){n.Log.debug("TokenRevocationClient.revoke: HTTP response received, status",c.status),200===c.status?a():u(Error(c.statusText+" ("+c.status+")"))},c.onerror=function(){n.Log.debug("TokenRevocationClient.revoke: Network Error."),u("Network Error")};var h="client_id="+encodeURIComponent(t);r&&(h+="&client_secret="+encodeURIComponent(r)),h+="&token_type_hint="+encodeURIComponent(o),h+="&token="+encodeURIComponent(i),c.setRequestHeader("Content-Type","application/x-www-form-urlencoded"),c.send(h)})},TokenRevocationClient}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CordovaPopupWindow=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);var o="location=no,toolbar=no,zoom=no",s="_blank";t.CordovaPopupWindow=function(){function CordovaPopupWindow(e){var t=this;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,CordovaPopupWindow),this._promise=new Promise(function(e,r){t._resolve=e,t._reject=r}),this.features=e.popupWindowFeatures||o,this.target=e.popupWindowTarget||s,this.redirect_uri=e.startUrl,i.Log.debug("CordovaPopupWindow.ctor: redirect_uri: "+this.redirect_uri)}return CordovaPopupWindow.prototype._isInAppBrowserInstalled=function _isInAppBrowserInstalled(e){return["cordova-plugin-inappbrowser","cordova-plugin-inappbrowser.inappbrowser","org.apache.cordova.inappbrowser"].some(function(t){return e.hasOwnProperty(t)})},CordovaPopupWindow.prototype.navigate=function navigate(e){if(e&&e.url){if(!window.cordova)return this._error("cordova is undefined");var t=window.cordova.require("cordova/plugin_list").metadata;if(!1===this._isInAppBrowserInstalled(t))return this._error("InAppBrowser plugin not found");this._popup=cordova.InAppBrowser.open(e.url,this.target,this.features),this._popup?(i.Log.debug("CordovaPopupWindow.navigate: popup successfully created"),this._exitCallbackEvent=this._exitCallback.bind(this),this._loadStartCallbackEvent=this._loadStartCallback.bind(this),this._popup.addEventListener("exit",this._exitCallbackEvent,!1),this._popup.addEventListener("loadstart",this._loadStartCallbackEvent,!1)):this._error("Error opening popup window")}else this._error("No url provided");return this.promise},CordovaPopupWindow.prototype._loadStartCallback=function _loadStartCallback(e){0===e.url.indexOf(this.redirect_uri)&&this._success({url:e.url})},CordovaPopupWindow.prototype._exitCallback=function _exitCallback(e){this._error(e)},CordovaPopupWindow.prototype._success=function _success(e){this._cleanup(),i.Log.debug("CordovaPopupWindow: Successful response from cordova popup window"),this._resolve(e)},CordovaPopupWindow.prototype._error=function _error(e){this._cleanup(),i.Log.error(e),this._reject(new Error(e))},CordovaPopupWindow.prototype.close=function close(){this._cleanup()},CordovaPopupWindow.prototype._cleanup=function _cleanup(){this._popup&&(i.Log.debug("CordovaPopupWindow: cleaning up popup"),this._popup.removeEventListener("exit",this._exitCallbackEvent,!1),this._popup.removeEventListener("loadstart",this._loadStartCallbackEvent,!1),this._popup.close()),this._popup=null},n(CordovaPopupWindow,[{key:"promise",get:function get(){return this._promise}}]),CordovaPopupWindow}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0});var n=r(0),i=r(9),o=r(5),s=r(6),a=r(37),u=r(38),c=r(16),h=r(2),l=r(48),f=r(49),g=r(19),p=r(20),d=r(18),v=r(1),y=r(15);t.default={Log:n.Log,OidcClient:i.OidcClient,OidcClientSettings:o.OidcClientSettings,WebStorageStateStore:s.WebStorageStateStore,InMemoryWebStorage:a.InMemoryWebStorage,UserManager:u.UserManager,AccessTokenEvents:c.AccessTokenEvents,MetadataService:h.MetadataService,CordovaPopupNavigator:l.CordovaPopupNavigator,CordovaIFrameNavigator:f.CordovaIFrameNavigator,CheckSessionIFrame:g.CheckSessionIFrame,TokenRevocationClient:p.TokenRevocationClient,SessionMonitor:d.SessionMonitor,Global:v.Global,User:y.User},e.exports=t.default},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.ResponseValidator=void 0;var n="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},i=r(0),o=r(2),s=r(24),a=r(10),u=r(11),c=r(4);var h=["nonce","at_hash","iat","nbf","exp","aud","iss","c_hash"];t.ResponseValidator=function(){function ResponseValidator(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.MetadataService,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:s.UserInfoService,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c.JoseUtil,u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:a.TokenClient;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,ResponseValidator),!e)throw i.Log.error("ResponseValidator.ctor: No settings passed to ResponseValidator"),new Error("settings");this._settings=e,this._metadataService=new t(this._settings),this._userInfoService=new r(this._settings),this._joseUtil=n,this._tokenClient=new u(this._settings)}return ResponseValidator.prototype.validateSigninResponse=function validateSigninResponse(e,t){var r=this;return i.Log.debug("ResponseValidator.validateSigninResponse"),this._processSigninParams(e,t).then(function(t){return i.Log.debug("ResponseValidator.validateSigninResponse: state processed"),r._validateTokens(e,t).then(function(e){return i.Log.debug("ResponseValidator.validateSigninResponse: tokens validated"),r._processClaims(e).then(function(e){return i.Log.debug("ResponseValidator.validateSigninResponse: claims processed"),e})})})},ResponseValidator.prototype.validateSignoutResponse=function validateSignoutResponse(e,t){return e.id!==t.state?(i.Log.error("ResponseValidator.validateSignoutResponse: State does not match"),Promise.reject(new Error("State does not match"))):(i.Log.debug("ResponseValidator.validateSignoutResponse: state validated"),t.state=e.data,t.error?(i.Log.warn("ResponseValidator.validateSignoutResponse: Response was error",t.error),Promise.reject(new u.ErrorResponse(t))):Promise.resolve(t))},ResponseValidator.prototype._processSigninParams=function _processSigninParams(e,t){if(e.id!==t.state)return i.Log.error("ResponseValidator._processSigninParams: State does not match"),Promise.reject(new Error("State does not match"));if(!e.client_id)return i.Log.error("ResponseValidator._processSigninParams: No client_id on state"),Promise.reject(new Error("No client_id on state"));if(!e.authority)return i.Log.error("ResponseValidator._processSigninParams: No authority on state"),Promise.reject(new Error("No authority on state"));if(this._settings.authority){if(this._settings.authority&&this._settings.authority!==e.authority)return i.Log.error("ResponseValidator._processSigninParams: authority mismatch on settings vs. signin state"),Promise.reject(new Error("authority mismatch on settings vs. signin state"))}else this._settings.authority=e.authority;if(this._settings.client_id){if(this._settings.client_id&&this._settings.client_id!==e.client_id)return i.Log.error("ResponseValidator._processSigninParams: client_id mismatch on settings vs. signin state"),Promise.reject(new Error("client_id mismatch on settings vs. signin state"))}else this._settings.client_id=e.client_id;return i.Log.debug("ResponseValidator._processSigninParams: state validated"),t.state=e.data,t.error?(i.Log.warn("ResponseValidator._processSigninParams: Response was error",t.error),Promise.reject(new u.ErrorResponse(t))):e.nonce&&!t.id_token?(i.Log.error("ResponseValidator._processSigninParams: Expecting id_token in response"),Promise.reject(new Error("No id_token in response"))):!e.nonce&&t.id_token?(i.Log.error("ResponseValidator._processSigninParams: Not expecting id_token in response"),Promise.reject(new Error("Unexpected id_token in response"))):e.code_verifier&&!t.code?(i.Log.error("ResponseValidator._processSigninParams: Expecting code in response"),Promise.reject(new Error("No code in response"))):!e.code_verifier&&t.code?(i.Log.error("ResponseValidator._processSigninParams: Not expecting code in response"),Promise.reject(new Error("Unexpected code in response"))):Promise.resolve(t)},ResponseValidator.prototype._processClaims=function _processClaims(e){var t=this;if(e.isOpenIdConnect){if(i.Log.debug("ResponseValidator._processClaims: response is OIDC, processing claims"),e.profile=this._filterProtocolClaims(e.profile),this._settings.loadUserInfo&&e.access_token)return i.Log.debug("ResponseValidator._processClaims: loading user info"),this._userInfoService.getClaims(e.access_token).then(function(r){return i.Log.debug("ResponseValidator._processClaims: user info claims received from user info endpoint"),r.sub!==e.profile.sub?(i.Log.error("ResponseValidator._processClaims: sub from user info endpoint does not match sub in access_token"),Promise.reject(new Error("sub from user info endpoint does not match sub in access_token"))):(e.profile=t._mergeClaims(e.profile,r),i.Log.debug("ResponseValidator._processClaims: user info claims received, updated profile:",e.profile),e)});i.Log.debug("ResponseValidator._processClaims: not loading user info")}else i.Log.debug("ResponseValidator._processClaims: response is not OIDC, not processing claims");return Promise.resolve(e)},ResponseValidator.prototype._mergeClaims=function _mergeClaims(e,t){var r=Object.assign({},e);for(var i in t){var o=t[i];Array.isArray(o)||(o=[o]);for(var s=0;s<o.length;s++){var a=o[s];r[i]?Array.isArray(r[i])?r[i].indexOf(a)<0&&r[i].push(a):r[i]!==a&&("object"===(void 0===a?"undefined":n(a))?r[i]=this._mergeClaims(r[i],a):r[i]=[r[i],a]):r[i]=a}}return r},ResponseValidator.prototype._filterProtocolClaims=function _filterProtocolClaims(e){i.Log.debug("ResponseValidator._filterProtocolClaims, incoming claims:",e);var t=Object.assign({},e);return this._settings._filterProtocolClaims?(h.forEach(function(e){delete t[e]}),i.Log.debug("ResponseValidator._filterProtocolClaims: protocol claims filtered",t)):i.Log.debug("ResponseValidator._filterProtocolClaims: protocol claims not filtered"),t},ResponseValidator.prototype._validateTokens=function _validateTokens(e,t){return t.code?(i.Log.debug("ResponseValidator._validateTokens: Validating code"),this._processCode(e,t)):t.id_token?t.access_token?(i.Log.debug("ResponseValidator._validateTokens: Validating id_token and access_token"),this._validateIdTokenAndAccessToken(e,t)):(i.Log.debug("ResponseValidator._validateTokens: Validating id_token"),this._validateIdToken(e,t)):(i.Log.debug("ResponseValidator._validateTokens: No code to process or id_token to validate"),Promise.resolve(t))},ResponseValidator.prototype._processCode=function _processCode(e,t){var r=this,n={client_id:e.client_id,client_secret:this._settings.client_secret,code:t.code,redirect_uri:e.redirect_uri,code_verifier:e.code_verifier};return this._tokenClient.exchangeCode(n).then(function(n){for(var o in n)t[o]=n[o];return t.id_token?(i.Log.debug("ResponseValidator._processCode: token response successful, processing id_token"),r._validateIdTokenAttributes(e,t)):(i.Log.debug("ResponseValidator._processCode: token response successful, returning response"),t)})},ResponseValidator.prototype._validateIdTokenAttributes=function _validateIdTokenAttributes(e,t){var r=this;return this._metadataService.getIssuer().then(function(n){var o=e.client_id,s=r._settings.clockSkew;return i.Log.debug("ResponseValidator._validateIdTokenAttributes: Validaing JWT attributes; using clock skew (in seconds) of: ",s),r._joseUtil.validateJwtAttributes(t.id_token,n,o,s).then(function(r){return e.nonce&&e.nonce!==r.nonce?(i.Log.error("ResponseValidator._validateIdTokenAttributes: Invalid nonce in id_token"),Promise.reject(new Error("Invalid nonce in id_token"))):r.sub?(t.profile=r,t):(i.Log.error("ResponseValidator._validateIdTokenAttributes: No sub present in id_token"),Promise.reject(new Error("No sub present in id_token")))})})},ResponseValidator.prototype._validateIdTokenAndAccessToken=function _validateIdTokenAndAccessToken(e,t){var r=this;return this._validateIdToken(e,t).then(function(e){return r._validateAccessToken(e)})},ResponseValidator.prototype._validateIdToken=function _validateIdToken(e,t){var r=this;if(!e.nonce)return i.Log.error("ResponseValidator._validateIdToken: No nonce on state"),Promise.reject(new Error("No nonce on state"));var n=this._joseUtil.parseJwt(t.id_token);if(!n||!n.header||!n.payload)return i.Log.error("ResponseValidator._validateIdToken: Failed to parse id_token",n),Promise.reject(new Error("Failed to parse id_token"));if(e.nonce!==n.payload.nonce)return i.Log.error("ResponseValidator._validateIdToken: Invalid nonce in id_token"),Promise.reject(new Error("Invalid nonce in id_token"));var o=n.header.kid;return this._metadataService.getIssuer().then(function(s){return i.Log.debug("ResponseValidator._validateIdToken: Received issuer"),r._metadataService.getSigningKeys().then(function(a){if(!a)return i.Log.error("ResponseValidator._validateIdToken: No signing keys from metadata"),Promise.reject(new Error("No signing keys from metadata"));i.Log.debug("ResponseValidator._validateIdToken: Received signing keys");var u=void 0;if(o)u=a.filter(function(e){return e.kid===o})[0];else{if((a=r._filterByAlg(a,n.header.alg)).length>1)return i.Log.error("ResponseValidator._validateIdToken: No kid found in id_token and more than one key found in metadata"),Promise.reject(new Error("No kid found in id_token and more than one key found in metadata"));u=a[0]}if(!u)return i.Log.error("ResponseValidator._validateIdToken: No key matching kid or alg found in signing keys"),Promise.reject(new Error("No key matching kid or alg found in signing keys"));var c=e.client_id,h=r._settings.clockSkew;return i.Log.debug("ResponseValidator._validateIdToken: Validaing JWT; using clock skew (in seconds) of: ",h),r._joseUtil.validateJwt(t.id_token,u,s,c,h).then(function(){return i.Log.debug("ResponseValidator._validateIdToken: JWT validation successful"),n.payload.sub?(t.profile=n.payload,t):(i.Log.error("ResponseValidator._validateIdToken: No sub present in id_token"),Promise.reject(new Error("No sub present in id_token")))})})})},ResponseValidator.prototype._filterByAlg=function _filterByAlg(e,t){var r=null;if(t.startsWith("RS"))r="RSA";else if(t.startsWith("PS"))r="PS";else{if(!t.startsWith("ES"))return i.Log.debug("ResponseValidator._filterByAlg: alg not supported: ",t),[];r="EC"}return i.Log.debug("ResponseValidator._filterByAlg: Looking for keys that match kty: ",r),e=e.filter(function(e){return e.kty===r}),i.Log.debug("ResponseValidator._filterByAlg: Number of keys that match kty: ",r,e.length),e},ResponseValidator.prototype._validateAccessToken=function _validateAccessToken(e){if(!e.profile)return i.Log.error("ResponseValidator._validateAccessToken: No profile loaded from id_token"),Promise.reject(new Error("No profile loaded from id_token"));if(!e.profile.at_hash)return i.Log.error("ResponseValidator._validateAccessToken: No at_hash in id_token"),Promise.reject(new Error("No at_hash in id_token"));if(!e.id_token)return i.Log.error("ResponseValidator._validateAccessToken: No id_token"),Promise.reject(new Error("No id_token"));var t=this._joseUtil.parseJwt(e.id_token);if(!t||!t.header)return i.Log.error("ResponseValidator._validateAccessToken: Failed to parse id_token",t),Promise.reject(new Error("Failed to parse id_token"));var r=t.header.alg;if(!r||5!==r.length)return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:",r),Promise.reject(new Error("Unsupported alg: "+r));var n=r.substr(2,3);if(!n)return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:",r,n),Promise.reject(new Error("Unsupported alg: "+r));if(256!==(n=parseInt(n))&&384!==n&&512!==n)return i.Log.error("ResponseValidator._validateAccessToken: Unsupported alg:",r,n),Promise.reject(new Error("Unsupported alg: "+r));var o="sha"+n,s=this._joseUtil.hashString(e.access_token,o);if(!s)return i.Log.error("ResponseValidator._validateAccessToken: access_token hash failed:",o),Promise.reject(new Error("Failed to validate at_hash"));var a=s.substr(0,s.length/2),u=this._joseUtil.hexToBase64Url(a);return u!==e.profile.at_hash?(i.Log.error("ResponseValidator._validateAccessToken: Failed to validate at_hash",u,e.profile.at_hash),Promise.reject(new Error("Failed to validate at_hash"))):(i.Log.debug("ResponseValidator._validateAccessToken: success"),Promise.resolve(e))},ResponseValidator}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.UserInfoService=void 0;var n=r(7),i=r(2),o=r(0),s=r(4);t.UserInfoService=function(){function UserInfoService(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.JsonService,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:s.JoseUtil;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,UserInfoService),!e)throw o.Log.error("UserInfoService.ctor: No settings passed"),new Error("settings");this._settings=e,this._jsonService=new t(void 0,void 0,this._getClaimsFromJwt.bind(this)),this._metadataService=new r(this._settings),this._joseUtil=a}return UserInfoService.prototype.getClaims=function getClaims(e){var t=this;return e?this._metadataService.getUserInfoEndpoint().then(function(r){return o.Log.debug("UserInfoService.getClaims: received userinfo url",r),t._jsonService.getJson(r,e).then(function(e){return o.Log.debug("UserInfoService.getClaims: claims received",e),e})}):(o.Log.error("UserInfoService.getClaims: No token passed"),Promise.reject(new Error("A token is required")))},UserInfoService.prototype._getClaimsFromJwt=function _getClaimsFromJwt(e){var t=this;try{var r=this._joseUtil.parseJwt(e.responseText);if(!r||!r.header||!r.payload)return o.Log.error("UserInfoService._getClaimsFromJwt: Failed to parse JWT",r),Promise.reject(new Error("Failed to parse id_token"));var n=r.header.kid,i=void 0;switch(this._settings.userInfoJwtIssuer){case"OP":i=this._metadataService.getIssuer();break;case"ANY":i=Promise.resolve(r.payload.iss);break;default:i=Promise.resolve(this._settings.userInfoJwtIssuer)}return i.then(function(i){return o.Log.debug("UserInfoService._getClaimsFromJwt: Received issuer:"+i),t._metadataService.getSigningKeys().then(function(s){if(!s)return o.Log.error("UserInfoService._getClaimsFromJwt: No signing keys from metadata"),Promise.reject(new Error("No signing keys from metadata"));o.Log.debug("UserInfoService._getClaimsFromJwt: Received signing keys");var a=void 0;if(n)a=s.filter(function(e){return e.kid===n})[0];else{if((s=t._filterByAlg(s,r.header.alg)).length>1)return o.Log.error("UserInfoService._getClaimsFromJwt: No kid found in id_token and more than one key found in metadata"),Promise.reject(new Error("No kid found in id_token and more than one key found in metadata"));a=s[0]}if(!a)return o.Log.error("UserInfoService._getClaimsFromJwt: No key matching kid or alg found in signing keys"),Promise.reject(new Error("No key matching kid or alg found in signing keys"));var u=t._settings.client_id,c=t._settings.clockSkew;return o.Log.debug("UserInfoService._getClaimsFromJwt: Validaing JWT; using clock skew (in seconds) of: ",c),t._joseUtil.validateJwt(e.responseText,a,i,u,c,void 0,!0).then(function(){return o.Log.debug("UserInfoService._getClaimsFromJwt: JWT validation successful"),r.payload})})})}catch(e){return o.Log.error("UserInfoService._getClaimsFromJwt: Error parsing JWT response",e.message),void reject(e)}},UserInfoService.prototype._filterByAlg=function _filterByAlg(e,t){var r=null;if(t.startsWith("RS"))r="RSA";else if(t.startsWith("PS"))r="PS";else{if(!t.startsWith("ES"))return o.Log.debug("UserInfoService._filterByAlg: alg not supported: ",t),[];r="EC"}return o.Log.debug("UserInfoService._filterByAlg: Looking for keys that match kty: ",r),e=e.filter(function(e){return e.kty===r}),o.Log.debug("UserInfoService._filterByAlg: Number of keys that match kty: ",r,e.length),e},UserInfoService}()},function(e,t,r){"use strict";(function(n){Object.defineProperty(t,"__esModule",{value:!0});var i="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&"function"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?"symbol":typeof e},u={userAgent:!1},p={};
/*!
Copyright (c) 2011, Yahoo! Inc. All rights reserved.
Code licensed under the BSD License:
http://developer.yahoo.com/yui/license.html
version: 2.9.0
*/
if(void 0===v)var v={};v.lang={extend:function extend(t,r,n){if(!r||!t)throw new Error("YAHOO.lang.extend failed, please check that all dependencies are included.");var i=function d(){};if(i.prototype=r.prototype,t.prototype=new i,t.prototype.constructor=t,t.superclass=r.prototype,r.prototype.constructor==Object.prototype.constructor&&(r.prototype.constructor=r),n){var o;for(o in n)t.prototype[o]=n[o];var s=function e(){},a=["toString","valueOf"];try{/MSIE/.test(u.userAgent)&&(s=function e(t,r){for(o=0;o<a.length;o+=1){var n=a[o],i=r[n];"function"==typeof i&&i!=Object.prototype[n]&&(t[n]=i)}})}catch(e){}s(t.prototype,n)}}};
/*! CryptoJS v3.1.2 core-fix.js
 * code.google.com/p/crypto-js
 * (c) 2009-2013 by Jeff Mott. All rights reserved.
 * code.google.com/p/crypto-js/wiki/License
 * THIS IS FIX of 'core.js' to fix Hmac issue.
 * https://code.google.com/p/crypto-js/issues/detail?id=84
 * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js
 */
var y=y||function(e,t){var r={},n=r.lib={},i=n.Base=function(){function n(){}return{extend:function extend(e){n.prototype=this;var t=new n;return e&&t.mixIn(e),t.hasOwnProperty("init")||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function create(){var e=this.extend();return e.init.apply(e,arguments),e},init:function init(){},mixIn:function mixIn(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty("toString")&&(this.toString=e.toString)},clone:function clone(){return this.init.prototype.extend(this)}}}(),o=n.WordArray=i.extend({init:function init(e,t){e=this.words=e||[],this.sigBytes=void 0!=t?t:4*e.length},toString:function toString(e){return(e||a).stringify(this)},concat:function concat(e){var t=this.words,r=e.words,n=this.sigBytes,i=e.sigBytes;if(this.clamp(),n%4)for(var o=0;o<i;o++){var s=r[o>>>2]>>>24-o%4*8&255;t[n+o>>>2]|=s<<24-(n+o)%4*8}else for(o=0;o<i;o+=4)t[n+o>>>2]=r[o>>>2];return this.sigBytes+=i,this},clamp:function clamp(){var t=this.words,r=this.sigBytes;t[r>>>2]&=4294967295<<32-r%4*8,t.length=e.ceil(r/4)},clone:function clone(){var e=i.clone.call(this);return e.words=this.words.slice(0),e},random:function random(t){for(var r=[],n=0;n<t;n+=4)r.push(4294967296*e.random()|0);return new o.init(r,t)}}),s=r.enc={},a=s.Hex={stringify:function stringify(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i++){var o=t[i>>>2]>>>24-i%4*8&255;n.push((o>>>4).toString(16)),n.push((15&o).toString(16))}return n.join("")},parse:function parse(e){for(var t=e.length,r=[],n=0;n<t;n+=2)r[n>>>3]|=parseInt(e.substr(n,2),16)<<24-n%8*4;return new o.init(r,t/2)}},u=s.Latin1={stringify:function stringify(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i++){var o=t[i>>>2]>>>24-i%4*8&255;n.push(String.fromCharCode(o))}return n.join("")},parse:function parse(e){for(var t=e.length,r=[],n=0;n<t;n++)r[n>>>2]|=(255&e.charCodeAt(n))<<24-n%4*8;return new o.init(r,t)}},c=s.Utf8={stringify:function stringify(e){try{return decodeURIComponent(escape(u.stringify(e)))}catch(e){throw new Error("Malformed UTF-8 data")}},parse:function parse(e){return u.parse(unescape(encodeURIComponent(e)))}},h=n.BufferedBlockAlgorithm=i.extend({reset:function reset(){this._data=new o.init,this._nDataBytes=0},_append:function _append(e){"string"==typeof e&&(e=c.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function _process(t){var r=this._data,n=r.words,i=r.sigBytes,s=this.blockSize,a=i/(4*s),u=(a=t?e.ceil(a):e.max((0|a)-this._minBufferSize,0))*s,c=e.min(4*u,i);if(u){for(var h=0;h<u;h+=s)this._doProcessBlock(n,h);var l=n.splice(0,u);r.sigBytes-=c}return new o.init(l,c)},clone:function clone(){var e=i.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),l=(n.Hasher=h.extend({cfg:i.extend(),init:function init(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function reset(){h.reset.call(this),this._doReset()},update:function update(e){return this._append(e),this._process(),this},finalize:function finalize(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function _createHelper(e){return function(t,r){return new e.init(r).finalize(t)}},_createHmacHelper:function _createHmacHelper(e){return function(t,r){return new l.HMAC.init(e,r).finalize(t)}}}),r.algo={});return r}(Math);!function(e){var t,r=(t=y).lib,n=r.Base,i=r.WordArray;(t=t.x64={}).Word=n.extend({init:function init(e,t){this.high=e,this.low=t}}),t.WordArray=n.extend({init:function init(e,t){e=this.words=e||[],this.sigBytes=void 0!=t?t:8*e.length},toX32:function toX32(){for(var e=this.words,t=e.length,r=[],n=0;n<t;n++){var o=e[n];r.push(o.high),r.push(o.low)}return i.create(r,this.sigBytes)},clone:function clone(){for(var e=n.clone.call(this),t=e.words=this.words.slice(0),r=t.length,i=0;i<r;i++)t[i]=t[i].clone();return e}})}(),function(){var e=y,t=e.lib.WordArray;e.enc.Base64={stringify:function stringify(e){var t=e.words,r=e.sigBytes,n=this._map;e.clamp(),e=[];for(var i=0;i<r;i+=3)for(var o=(t[i>>>2]>>>24-i%4*8&255)<<16|(t[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|t[i+2>>>2]>>>24-(i+2)%4*8&255,s=0;4>s&&i+.75*s<r;s++)e.push(n.charAt(o>>>6*(3-s)&63));if(t=n.charAt(64))for(;e.length%4;)e.push(t);return e.join("")},parse:function parse(e){var r=e.length,n=this._map;(i=n.charAt(64))&&(-1!=(i=e.indexOf(i))&&(r=i));for(var i=[],o=0,s=0;s<r;s++)if(s%4){var a=n.indexOf(e.charAt(s-1))<<s%4*2,u=n.indexOf(e.charAt(s))>>>6-s%4*2;i[o>>>2]|=(a|u)<<24-o%4*8,o++}return t.create(i,o)},_map:"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/="}}(),function(e){for(var t=y,r=(i=t.lib).WordArray,n=i.Hasher,i=t.algo,o=[],s=[],a=function u(e){return 4294967296*(e-(0|e))|0},u=2,c=0;64>c;){var h;e:{h=u;for(var l=e.sqrt(h),f=2;f<=l;f++)if(!(h%f)){h=!1;break e}h=!0}h&&(8>c&&(o[c]=a(e.pow(u,.5))),s[c]=a(e.pow(u,1/3)),c++),u++}var g=[];i=i.SHA256=n.extend({_doReset:function _doReset(){this._hash=new r.init(o.slice(0))},_doProcessBlock:function _doProcessBlock(e,t){for(var r=this._hash.words,n=r[0],i=r[1],o=r[2],a=r[3],u=r[4],c=r[5],h=r[6],l=r[7],f=0;64>f;f++){if(16>f)g[f]=0|e[t+f];else{var p=g[f-15],d=g[f-2];g[f]=((p<<25|p>>>7)^(p<<14|p>>>18)^p>>>3)+g[f-7]+((d<<15|d>>>17)^(d<<13|d>>>19)^d>>>10)+g[f-16]}p=l+((u<<26|u>>>6)^(u<<21|u>>>11)^(u<<7|u>>>25))+(u&c^~u&h)+s[f]+g[f],d=((n<<30|n>>>2)^(n<<19|n>>>13)^(n<<10|n>>>22))+(n&i^n&o^i&o),l=h,h=c,c=u,u=a+p|0,a=o,o=i,i=n,n=p+d|0}r[0]=r[0]+n|0,r[1]=r[1]+i|0,r[2]=r[2]+o|0,r[3]=r[3]+a|0,r[4]=r[4]+u|0,r[5]=r[5]+c|0,r[6]=r[6]+h|0,r[7]=r[7]+l|0},_doFinalize:function _doFinalize(){var t=this._data,r=t.words,n=8*this._nDataBytes,i=8*t.sigBytes;return r[i>>>5]|=128<<24-i%32,r[14+(i+64>>>9<<4)]=e.floor(n/4294967296),r[15+(i+64>>>9<<4)]=n,t.sigBytes=4*r.length,this._process(),this._hash},clone:function clone(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}});t.SHA256=n._createHelper(i),t.HmacSHA256=n._createHmacHelper(i)}(Math),function(){function a(){return r.create.apply(r,arguments)}for(var e=y,t=e.lib.Hasher,r=(i=e.x64).Word,n=i.WordArray,i=e.algo,o=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],s=[],u=0;80>u;u++)s[u]=a();i=i.SHA512=t.extend({_doReset:function _doReset(){this._hash=new n.init([new r.init(1779033703,4089235720),new r.init(3144134277,2227873595),new r.init(1013904242,4271175723),new r.init(2773480762,1595750129),new r.init(1359893119,2917565137),new r.init(2600822924,725511199),new r.init(528734635,4215389547),new r.init(1541459225,327033209)])},_doProcessBlock:function _doProcessBlock(e,t){for(var r=(l=this._hash.words)[0],n=l[1],i=l[2],a=l[3],u=l[4],c=l[5],h=l[6],l=l[7],f=r.high,g=r.low,p=n.high,d=n.low,v=i.high,y=i.low,m=a.high,_=a.low,S=u.high,b=u.low,F=c.high,w=c.low,E=h.high,x=h.low,C=l.high,k=l.low,A=f,P=g,I=p,B=d,R=v,T=y,U=m,D=_,L=S,M=b,N=F,O=w,H=E,j=x,K=C,V=k,q=0;80>q;q++){var W=s[q];if(16>q)var J=W.high=0|e[t+2*q],z=W.low=0|e[t+2*q+1];else{J=((z=(J=s[q-15]).high)>>>1|(Y=J.low)<<31)^(z>>>8|Y<<24)^z>>>7;var Y=(Y>>>1|z<<31)^(Y>>>8|z<<24)^(Y>>>7|z<<25),G=((z=(G=s[q-2]).high)>>>19|(X=G.low)<<13)^(z<<3|X>>>29)^z>>>6,X=(X>>>19|z<<13)^(X<<3|z>>>29)^(X>>>6|z<<26),Q=(z=s[q-7]).high,$=(Z=s[q-16]).high,Z=Z.low;J=(J=(J=J+Q+((z=Y+z.low)>>>0<Y>>>0?1:0))+G+((z=z+X)>>>0<X>>>0?1:0))+$+((z=z+Z)>>>0<Z>>>0?1:0);W.high=J,W.low=z}Q=L&N^~L&H,Z=M&O^~M&j,W=A&I^A&R^I&R;var ee=P&B^P&T^B&T,te=(Y=(A>>>28|P<<4)^(A<<30|P>>>2)^(A<<25|P>>>7),G=(P>>>28|A<<4)^(P<<30|A>>>2)^(P<<25|A>>>7),(X=o[q]).high),re=X.low;$=($=($=($=K+((L>>>14|M<<18)^(L>>>18|M<<14)^(L<<23|M>>>9))+((X=V+((M>>>14|L<<18)^(M>>>18|L<<14)^(M<<23|L>>>9)))>>>0<V>>>0?1:0))+Q+((X=X+Z)>>>0<Z>>>0?1:0))+te+((X=X+re)>>>0<re>>>0?1:0))+J+((X=X+z)>>>0<z>>>0?1:0),W=Y+W+((z=G+ee)>>>0<G>>>0?1:0),K=H,V=j,H=N,j=O,N=L,O=M,L=U+$+((M=D+X|0)>>>0<D>>>0?1:0)|0,U=R,D=T,R=I,T=B,I=A,B=P,A=$+W+((P=X+z|0)>>>0<X>>>0?1:0)|0}g=r.low=g+P,r.high=f+A+(g>>>0<P>>>0?1:0),d=n.low=d+B,n.high=p+I+(d>>>0<B>>>0?1:0),y=i.low=y+T,i.high=v+R+(y>>>0<T>>>0?1:0),_=a.low=_+D,a.high=m+U+(_>>>0<D>>>0?1:0),b=u.low=b+M,u.high=S+L+(b>>>0<M>>>0?1:0),w=c.low=w+O,c.high=F+N+(w>>>0<O>>>0?1:0),x=h.low=x+j,h.high=E+H+(x>>>0<j>>>0?1:0),k=l.low=k+V,l.high=C+K+(k>>>0<V>>>0?1:0)},_doFinalize:function _doFinalize(){var e=this._data,t=e.words,r=8*this._nDataBytes,n=8*e.sigBytes;return t[n>>>5]|=128<<24-n%32,t[30+(n+128>>>10<<5)]=Math.floor(r/4294967296),t[31+(n+128>>>10<<5)]=r,e.sigBytes=4*t.length,this._process(),this._hash.toX32()},clone:function clone(){var e=t.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32}),e.SHA512=t._createHelper(i),e.HmacSHA512=t._createHmacHelper(i)}(),function(){var e=y,t=(i=e.x64).Word,r=i.WordArray,n=(i=e.algo).SHA512,i=i.SHA384=n.extend({_doReset:function _doReset(){this._hash=new r.init([new t.init(3418070365,3238371032),new t.init(1654270250,914150663),new t.init(2438529370,812702999),new t.init(355462360,4144912697),new t.init(1731405415,4290775857),new t.init(2394180231,1750603025),new t.init(3675008525,1694076839),new t.init(1203062813,3204075428)])},_doFinalize:function _doFinalize(){var e=n._doFinalize.call(this);return e.sigBytes-=16,e}});e.SHA384=n._createHelper(i),e.HmacSHA384=n._createHmacHelper(i)}();
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
var _,S="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",F="=";function hex2b64(e){var t,r,n="";for(t=0;t+3<=e.length;t+=3)r=parseInt(e.substring(t,t+3),16),n+=S.charAt(r>>6)+S.charAt(63&r);if(t+1==e.length?(r=parseInt(e.substring(t,t+1),16),n+=S.charAt(r<<2)):t+2==e.length&&(r=parseInt(e.substring(t,t+2),16),n+=S.charAt(r>>2)+S.charAt((3&r)<<4)),F)for(;(3&n.length)>0;)n+=F;return n}function b64tohex(e){var t,r,n,i="",o=0;for(t=0;t<e.length&&e.charAt(t)!=F;++t)(n=S.indexOf(e.charAt(t)))<0||(0==o?(i+=int2char(n>>2),r=3&n,o=1):1==o?(i+=int2char(r<<2|n>>4),r=15&n,o=2):2==o?(i+=int2char(r),i+=int2char(n>>2),r=3&n,o=3):(i+=int2char(r<<2|n>>4),i+=int2char(15&n),o=0));return 1==o&&(i+=int2char(r<<2)),i}function b64toBA(e){var t,r=b64tohex(e),n=new Array;for(t=0;2*t<r.length;++t)n[t]=parseInt(r.substring(2*t,2*t+2),16);return n}function BigInteger(e,t,r){null!=e&&("number"==typeof e?this.fromNumber(e,t,r):null==t&&"string"!=typeof e?this.fromString(e,256):this.fromString(e,t))}function nbi(){return new BigInteger(null)}"Microsoft Internet Explorer"==u.appName?(BigInteger.prototype.am=function am2(e,t,r,n,i,o){for(var s=32767&t,a=t>>15;--o>=0;){var u=32767&this[e],c=this[e++]>>15,h=a*u+c*s;i=((u=s*u+((32767&h)<<15)+r[n]+(1073741823&i))>>>30)+(h>>>15)+a*c+(i>>>30),r[n++]=1073741823&u}return i},_=30):"Netscape"!=u.appName?(BigInteger.prototype.am=function am1(e,t,r,n,i,o){for(;--o>=0;){var s=t*this[e++]+r[n]+i;i=Math.floor(s/67108864),r[n++]=67108863&s}return i},_=26):(BigInteger.prototype.am=function am3(e,t,r,n,i,o){for(var s=16383&t,a=t>>14;--o>=0;){var u=16383&this[e],c=this[e++]>>14,h=a*u+c*s;i=((u=s*u+((16383&h)<<14)+r[n]+i)>>28)+(h>>14)+a*c,r[n++]=268435455&u}return i},_=28),BigInteger.prototype.DB=_,BigInteger.prototype.DM=(1<<_)-1,BigInteger.prototype.DV=1<<_;BigInteger.prototype.FV=Math.pow(2,52),BigInteger.prototype.F1=52-_,BigInteger.prototype.F2=2*_-52;var w,E,C="0123456789abcdefghijklmnopqrstuvwxyz",P=new Array;for(w="0".charCodeAt(0),E=0;E<=9;++E)P[w++]=E;for(w="a".charCodeAt(0),E=10;E<36;++E)P[w++]=E;for(w="A".charCodeAt(0),E=10;E<36;++E)P[w++]=E;function int2char(e){return C.charAt(e)}function intAt(e,t){var r=P[e.charCodeAt(t)];return null==r?-1:r}function nbv(e){var t=nbi();return t.fromInt(e),t}function nbits(e){var t,r=1;return 0!=(t=e>>>16)&&(e=t,r+=16),0!=(t=e>>8)&&(e=t,r+=8),0!=(t=e>>4)&&(e=t,r+=4),0!=(t=e>>2)&&(e=t,r+=2),0!=(t=e>>1)&&(e=t,r+=1),r}function Classic(e){this.m=e}function Montgomery(e){this.m=e,this.mp=e.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function op_and(e,t){return e&t}function op_or(e,t){return e|t}function op_xor(e,t){return e^t}function op_andnot(e,t){return e&~t}function lbit(e){if(0==e)return-1;var t=0;return 0==(65535&e)&&(e>>=16,t+=16),0==(255&e)&&(e>>=8,t+=8),0==(15&e)&&(e>>=4,t+=4),0==(3&e)&&(e>>=2,t+=2),0==(1&e)&&++t,t}function cbit(e){for(var t=0;0!=e;)e&=e-1,++t;return t}function NullExp(){}function nNop(e){return e}function Barrett(e){this.r2=nbi(),this.q3=nbi(),BigInteger.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}Classic.prototype.convert=function cConvert(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e},Classic.prototype.revert=function cRevert(e){return e},Classic.prototype.reduce=function cReduce(e){e.divRemTo(this.m,null,e)},Classic.prototype.mulTo=function cMulTo(e,t,r){e.multiplyTo(t,r),this.reduce(r)},Classic.prototype.sqrTo=function cSqrTo(e,t){e.squareTo(t),this.reduce(t)},Montgomery.prototype.convert=function montConvert(e){var t=nbi();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(BigInteger.ZERO)>0&&this.m.subTo(t,t),t},Montgomery.prototype.revert=function montRevert(e){var t=nbi();return e.copyTo(t),this.reduce(t),t},Montgomery.prototype.reduce=function montReduce(e){for(;e.t<=this.mt2;)e[e.t++]=0;for(var t=0;t<this.m.t;++t){var r=32767&e[t],n=r*this.mpl+((r*this.mph+(e[t]>>15)*this.mpl&this.um)<<15)&e.DM;for(e[r=t+this.m.t]+=this.m.am(0,n,e,t,0,this.m.t);e[r]>=e.DV;)e[r]-=e.DV,e[++r]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)},Montgomery.prototype.mulTo=function montMulTo(e,t,r){e.multiplyTo(t,r),this.reduce(r)},Montgomery.prototype.sqrTo=function montSqrTo(e,t){e.squareTo(t),this.reduce(t)},BigInteger.prototype.copyTo=function bnpCopyTo(e){for(var t=this.t-1;t>=0;--t)e[t]=this[t];e.t=this.t,e.s=this.s},BigInteger.prototype.fromInt=function bnpFromInt(e){this.t=1,this.s=e<0?-1:0,e>0?this[0]=e:e<-1?this[0]=e+this.DV:this.t=0},BigInteger.prototype.fromString=function bnpFromString(e,t){var r;if(16==t)r=4;else if(8==t)r=3;else if(256==t)r=8;else if(2==t)r=1;else if(32==t)r=5;else{if(4!=t)return void this.fromRadix(e,t);r=2}this.t=0,this.s=0;for(var n=e.length,i=!1,o=0;--n>=0;){var s=8==r?255&e[n]:intAt(e,n);s<0?"-"==e.charAt(n)&&(i=!0):(i=!1,0==o?this[this.t++]=s:o+r>this.DB?(this[this.t-1]|=(s&(1<<this.DB-o)-1)<<o,this[this.t++]=s>>this.DB-o):this[this.t-1]|=s<<o,(o+=r)>=this.DB&&(o-=this.DB))}8==r&&0!=(128&e[0])&&(this.s=-1,o>0&&(this[this.t-1]|=(1<<this.DB-o)-1<<o)),this.clamp(),i&&BigInteger.ZERO.subTo(this,this)},BigInteger.prototype.clamp=function bnpClamp(){for(var e=this.s&this.DM;this.t>0&&this[this.t-1]==e;)--this.t},BigInteger.prototype.dlShiftTo=function bnpDLShiftTo(e,t){var r;for(r=this.t-1;r>=0;--r)t[r+e]=this[r];for(r=e-1;r>=0;--r)t[r]=0;t.t=this.t+e,t.s=this.s},BigInteger.prototype.drShiftTo=function bnpDRShiftTo(e,t){for(var r=e;r<this.t;++r)t[r-e]=this[r];t.t=Math.max(this.t-e,0),t.s=this.s},BigInteger.prototype.lShiftTo=function bnpLShiftTo(e,t){var r,n=e%this.DB,i=this.DB-n,o=(1<<i)-1,s=Math.floor(e/this.DB),a=this.s<<n&this.DM;for(r=this.t-1;r>=0;--r)t[r+s+1]=this[r]>>i|a,a=(this[r]&o)<<n;for(r=s-1;r>=0;--r)t[r]=0;t[s]=a,t.t=this.t+s+1,t.s=this.s,t.clamp()},BigInteger.prototype.rShiftTo=function bnpRShiftTo(e,t){t.s=this.s;var r=Math.floor(e/this.DB);if(r>=this.t)t.t=0;else{var n=e%this.DB,i=this.DB-n,o=(1<<n)-1;t[0]=this[r]>>n;for(var s=r+1;s<this.t;++s)t[s-r-1]|=(this[s]&o)<<i,t[s-r]=this[s]>>n;n>0&&(t[this.t-r-1]|=(this.s&o)<<i),t.t=this.t-r,t.clamp()}},BigInteger.prototype.subTo=function bnpSubTo(e,t){for(var r=0,n=0,i=Math.min(e.t,this.t);r<i;)n+=this[r]-e[r],t[r++]=n&this.DM,n>>=this.DB;if(e.t<this.t){for(n-=e.s;r<this.t;)n+=this[r],t[r++]=n&this.DM,n>>=this.DB;n+=this.s}else{for(n+=this.s;r<e.t;)n-=e[r],t[r++]=n&this.DM,n>>=this.DB;n-=e.s}t.s=n<0?-1:0,n<-1?t[r++]=this.DV+n:n>0&&(t[r++]=n),t.t=r,t.clamp()},BigInteger.prototype.multiplyTo=function bnpMultiplyTo(e,t){var r=this.abs(),n=e.abs(),i=r.t;for(t.t=i+n.t;--i>=0;)t[i]=0;for(i=0;i<n.t;++i)t[i+r.t]=r.am(0,n[i],t,i,0,r.t);t.s=0,t.clamp(),this.s!=e.s&&BigInteger.ZERO.subTo(t,t)},BigInteger.prototype.squareTo=function bnpSquareTo(e){for(var t=this.abs(),r=e.t=2*t.t;--r>=0;)e[r]=0;for(r=0;r<t.t-1;++r){var n=t.am(r,t[r],e,2*r,0,1);(e[r+t.t]+=t.am(r+1,2*t[r],e,2*r+1,n,t.t-r-1))>=t.DV&&(e[r+t.t]-=t.DV,e[r+t.t+1]=1)}e.t>0&&(e[e.t-1]+=t.am(r,t[r],e,2*r,0,1)),e.s=0,e.clamp()},BigInteger.prototype.divRemTo=function bnpDivRemTo(e,t,r){var n=e.abs();if(!(n.t<=0)){var i=this.abs();if(i.t<n.t)return null!=t&&t.fromInt(0),void(null!=r&&this.copyTo(r));null==r&&(r=nbi());var o=nbi(),s=this.s,a=e.s,u=this.DB-nbits(n[n.t-1]);u>0?(n.lShiftTo(u,o),i.lShiftTo(u,r)):(n.copyTo(o),i.copyTo(r));var c=o.t,h=o[c-1];if(0!=h){var l=h*(1<<this.F1)+(c>1?o[c-2]>>this.F2:0),f=this.FV/l,g=(1<<this.F1)/l,p=1<<this.F2,d=r.t,v=d-c,y=null==t?nbi():t;for(o.dlShiftTo(v,y),r.compareTo(y)>=0&&(r[r.t++]=1,r.subTo(y,r)),BigInteger.ONE.dlShiftTo(c,y),y.subTo(o,o);o.t<c;)o[o.t++]=0;for(;--v>=0;){var m=r[--d]==h?this.DM:Math.floor(r[d]*f+(r[d-1]+p)*g);if((r[d]+=o.am(0,m,r,v,0,c))<m)for(o.dlShiftTo(v,y),r.subTo(y,r);r[d]<--m;)r.subTo(y,r)}null!=t&&(r.drShiftTo(c,t),s!=a&&BigInteger.ZERO.subTo(t,t)),r.t=c,r.clamp(),u>0&&r.rShiftTo(u,r),s<0&&BigInteger.ZERO.subTo(r,r)}}},BigInteger.prototype.invDigit=function bnpInvDigit(){if(this.t<1)return 0;var e=this[0];if(0==(1&e))return 0;var t=3&e;return(t=(t=(t=(t=t*(2-(15&e)*t)&15)*(2-(255&e)*t)&255)*(2-((65535&e)*t&65535))&65535)*(2-e*t%this.DV)%this.DV)>0?this.DV-t:-t},BigInteger.prototype.isEven=function bnpIsEven(){return 0==(this.t>0?1&this[0]:this.s)},BigInteger.prototype.exp=function bnpExp(e,t){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),n=nbi(),i=t.convert(this),o=nbits(e)-1;for(i.copyTo(r);--o>=0;)if(t.sqrTo(r,n),(e&1<<o)>0)t.mulTo(n,i,r);else{var s=r;r=n,n=s}return t.revert(r)},BigInteger.prototype.toString=function bnToString(e){if(this.s<0)return"-"+this.negate().toString(e);var t;if(16==e)t=4;else if(8==e)t=3;else if(2==e)t=1;else if(32==e)t=5;else{if(4!=e)return this.toRadix(e);t=2}var r,n=(1<<t)-1,i=!1,o="",s=this.t,a=this.DB-s*this.DB%t;if(s-- >0)for(a<this.DB&&(r=this[s]>>a)>0&&(i=!0,o=int2char(r));s>=0;)a<t?(r=(this[s]&(1<<a)-1)<<t-a,r|=this[--s]>>(a+=this.DB-t)):(r=this[s]>>(a-=t)&n,a<=0&&(a+=this.DB,--s)),r>0&&(i=!0),i&&(o+=int2char(r));return i?o:"0"},BigInteger.prototype.negate=function bnNegate(){var e=nbi();return BigInteger.ZERO.subTo(this,e),e},BigInteger.prototype.abs=function bnAbs(){return this.s<0?this.negate():this},BigInteger.prototype.compareTo=function bnCompareTo(e){var t=this.s-e.s;if(0!=t)return t;var r=this.t;if(0!=(t=r-e.t))return this.s<0?-t:t;for(;--r>=0;)if(0!=(t=this[r]-e[r]))return t;return 0},BigInteger.prototype.bitLength=function bnBitLength(){return this.t<=0?0:this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)},BigInteger.prototype.mod=function bnMod(e){var t=nbi();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(BigInteger.ZERO)>0&&e.subTo(t,t),t},BigInteger.prototype.modPowInt=function bnModPowInt(e,t){var r;return r=e<256||t.isEven()?new Classic(t):new Montgomery(t),this.exp(e,r)},BigInteger.ZERO=nbv(0),BigInteger.ONE=nbv(1),NullExp.prototype.convert=nNop,NullExp.prototype.revert=nNop,NullExp.prototype.mulTo=function nMulTo(e,t,r){e.multiplyTo(t,r)},NullExp.prototype.sqrTo=function nSqrTo(e,t){e.squareTo(t)},Barrett.prototype.convert=function barrettConvert(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=nbi();return e.copyTo(t),this.reduce(t),t},Barrett.prototype.revert=function barrettRevert(e){return e},Barrett.prototype.reduce=function barrettReduce(e){for(e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);e.compareTo(this.r2)<0;)e.dAddOffset(1,this.m.t+1);for(e.subTo(this.r2,e);e.compareTo(this.m)>=0;)e.subTo(this.m,e)},Barrett.prototype.mulTo=function barrettMulTo(e,t,r){e.multiplyTo(t,r),this.reduce(r)},Barrett.prototype.sqrTo=function barrettSqrTo(e,t){e.squareTo(t),this.reduce(t)};var I=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],R=(1<<26)/I[I.length-1];
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function Arcfour(){this.i=0,this.j=0,this.S=new Array}BigInteger.prototype.chunkSize=function bnpChunkSize(e){return Math.floor(Math.LN2*this.DB/Math.log(e))},BigInteger.prototype.toRadix=function bnpToRadix(e){if(null==e&&(e=10),0==this.signum()||e<2||e>36)return"0";var t=this.chunkSize(e),r=Math.pow(e,t),n=nbv(r),i=nbi(),o=nbi(),s="";for(this.divRemTo(n,i,o);i.signum()>0;)s=(r+o.intValue()).toString(e).substr(1)+s,i.divRemTo(n,i,o);return o.intValue().toString(e)+s},BigInteger.prototype.fromRadix=function bnpFromRadix(e,t){this.fromInt(0),null==t&&(t=10);for(var r=this.chunkSize(t),n=Math.pow(t,r),i=!1,o=0,s=0,a=0;a<e.length;++a){var u=intAt(e,a);u<0?"-"==e.charAt(a)&&0==this.signum()&&(i=!0):(s=t*s+u,++o>=r&&(this.dMultiply(n),this.dAddOffset(s,0),o=0,s=0))}o>0&&(this.dMultiply(Math.pow(t,o)),this.dAddOffset(s,0)),i&&BigInteger.ZERO.subTo(this,this)},BigInteger.prototype.fromNumber=function bnpFromNumber(e,t,r){if("number"==typeof t)if(e<2)this.fromInt(1);else for(this.fromNumber(e,r),this.testBit(e-1)||this.bitwiseTo(BigInteger.ONE.shiftLeft(e-1),op_or,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(t);)this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(BigInteger.ONE.shiftLeft(e-1),this);else{var n=new Array,i=7&e;n.length=1+(e>>3),t.nextBytes(n),i>0?n[0]&=(1<<i)-1:n[0]=0,this.fromString(n,256)}},BigInteger.prototype.bitwiseTo=function bnpBitwiseTo(e,t,r){var n,i,o=Math.min(e.t,this.t);for(n=0;n<o;++n)r[n]=t(this[n],e[n]);if(e.t<this.t){for(i=e.s&this.DM,n=o;n<this.t;++n)r[n]=t(this[n],i);r.t=this.t}else{for(i=this.s&this.DM,n=o;n<e.t;++n)r[n]=t(i,e[n]);r.t=e.t}r.s=t(this.s,e.s),r.clamp()},BigInteger.prototype.changeBit=function bnpChangeBit(e,t){var r=BigInteger.ONE.shiftLeft(e);return this.bitwiseTo(r,t,r),r},BigInteger.prototype.addTo=function bnpAddTo(e,t){for(var r=0,n=0,i=Math.min(e.t,this.t);r<i;)n+=this[r]+e[r],t[r++]=n&this.DM,n>>=this.DB;if(e.t<this.t){for(n+=e.s;r<this.t;)n+=this[r],t[r++]=n&this.DM,n>>=this.DB;n+=this.s}else{for(n+=this.s;r<e.t;)n+=e[r],t[r++]=n&this.DM,n>>=this.DB;n+=e.s}t.s=n<0?-1:0,n>0?t[r++]=n:n<-1&&(t[r++]=this.DV+n),t.t=r,t.clamp()},BigInteger.prototype.dMultiply=function bnpDMultiply(e){this[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()},BigInteger.prototype.dAddOffset=function bnpDAddOffset(e,t){if(0!=e){for(;this.t<=t;)this[this.t++]=0;for(this[t]+=e;this[t]>=this.DV;)this[t]-=this.DV,++t>=this.t&&(this[this.t++]=0),++this[t]}},BigInteger.prototype.multiplyLowerTo=function bnpMultiplyLowerTo(e,t,r){var n,i=Math.min(this.t+e.t,t);for(r.s=0,r.t=i;i>0;)r[--i]=0;for(n=r.t-this.t;i<n;++i)r[i+this.t]=this.am(0,e[i],r,i,0,this.t);for(n=Math.min(e.t,t);i<n;++i)this.am(0,e[i],r,i,0,t-i);r.clamp()},BigInteger.prototype.multiplyUpperTo=function bnpMultiplyUpperTo(e,t,r){--t;var n=r.t=this.t+e.t-t;for(r.s=0;--n>=0;)r[n]=0;for(n=Math.max(t-this.t,0);n<e.t;++n)r[this.t+n-t]=this.am(t-n,e[n],r,0,0,this.t+n-t);r.clamp(),r.drShiftTo(1,r)},BigInteger.prototype.modInt=function bnpModInt(e){if(e<=0)return 0;var t=this.DV%e,r=this.s<0?e-1:0;if(this.t>0)if(0==t)r=this[0]%e;else for(var n=this.t-1;n>=0;--n)r=(t*r+this[n])%e;return r},BigInteger.prototype.millerRabin=function bnpMillerRabin(e){var t=this.subtract(BigInteger.ONE),r=t.getLowestSetBit();if(r<=0)return!1;var n=t.shiftRight(r);(e=e+1>>1)>I.length&&(e=I.length);for(var i=nbi(),o=0;o<e;++o){i.fromInt(I[Math.floor(Math.random()*I.length)]);var s=i.modPow(n,this);if(0!=s.compareTo(BigInteger.ONE)&&0!=s.compareTo(t)){for(var a=1;a++<r&&0!=s.compareTo(t);)if(0==(s=s.modPowInt(2,this)).compareTo(BigInteger.ONE))return!1;if(0!=s.compareTo(t))return!1}}return!0},BigInteger.prototype.clone=
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function bnClone(){var e=nbi();return this.copyTo(e),e},BigInteger.prototype.intValue=function bnIntValue(){if(this.s<0){if(1==this.t)return this[0]-this.DV;if(0==this.t)return-1}else{if(1==this.t)return this[0];if(0==this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]},BigInteger.prototype.byteValue=function bnByteValue(){return 0==this.t?this.s:this[0]<<24>>24},BigInteger.prototype.shortValue=function bnShortValue(){return 0==this.t?this.s:this[0]<<16>>16},BigInteger.prototype.signum=function bnSigNum(){return this.s<0?-1:this.t<=0||1==this.t&&this[0]<=0?0:1},BigInteger.prototype.toByteArray=function bnToByteArray(){var e=this.t,t=new Array;t[0]=this.s;var r,n=this.DB-e*this.DB%8,i=0;if(e-- >0)for(n<this.DB&&(r=this[e]>>n)!=(this.s&this.DM)>>n&&(t[i++]=r|this.s<<this.DB-n);e>=0;)n<8?(r=(this[e]&(1<<n)-1)<<8-n,r|=this[--e]>>(n+=this.DB-8)):(r=this[e]>>(n-=8)&255,n<=0&&(n+=this.DB,--e)),0!=(128&r)&&(r|=-256),0==i&&(128&this.s)!=(128&r)&&++i,(i>0||r!=this.s)&&(t[i++]=r);return t},BigInteger.prototype.equals=function bnEquals(e){return 0==this.compareTo(e)},BigInteger.prototype.min=function bnMin(e){return this.compareTo(e)<0?this:e},BigInteger.prototype.max=function bnMax(e){return this.compareTo(e)>0?this:e},BigInteger.prototype.and=function bnAnd(e){var t=nbi();return this.bitwiseTo(e,op_and,t),t},BigInteger.prototype.or=function bnOr(e){var t=nbi();return this.bitwiseTo(e,op_or,t),t},BigInteger.prototype.xor=function bnXor(e){var t=nbi();return this.bitwiseTo(e,op_xor,t),t},BigInteger.prototype.andNot=function bnAndNot(e){var t=nbi();return this.bitwiseTo(e,op_andnot,t),t},BigInteger.prototype.not=function bnNot(){for(var e=nbi(),t=0;t<this.t;++t)e[t]=this.DM&~this[t];return e.t=this.t,e.s=~this.s,e},BigInteger.prototype.shiftLeft=function bnShiftLeft(e){var t=nbi();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t},BigInteger.prototype.shiftRight=function bnShiftRight(e){var t=nbi();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t},BigInteger.prototype.getLowestSetBit=function bnGetLowestSetBit(){for(var e=0;e<this.t;++e)if(0!=this[e])return e*this.DB+lbit(this[e]);return this.s<0?this.t*this.DB:-1},BigInteger.prototype.bitCount=function bnBitCount(){for(var e=0,t=this.s&this.DM,r=0;r<this.t;++r)e+=cbit(this[r]^t);return e},BigInteger.prototype.testBit=function bnTestBit(e){var t=Math.floor(e/this.DB);return t>=this.t?0!=this.s:0!=(this[t]&1<<e%this.DB)},BigInteger.prototype.setBit=function bnSetBit(e){return this.changeBit(e,op_or)},BigInteger.prototype.clearBit=function bnClearBit(e){return this.changeBit(e,op_andnot)},BigInteger.prototype.flipBit=function bnFlipBit(e){return this.changeBit(e,op_xor)},BigInteger.prototype.add=function bnAdd(e){var t=nbi();return this.addTo(e,t),t},BigInteger.prototype.subtract=function bnSubtract(e){var t=nbi();return this.subTo(e,t),t},BigInteger.prototype.multiply=function bnMultiply(e){var t=nbi();return this.multiplyTo(e,t),t},BigInteger.prototype.divide=function bnDivide(e){var t=nbi();return this.divRemTo(e,t,null),t},BigInteger.prototype.remainder=function bnRemainder(e){var t=nbi();return this.divRemTo(e,null,t),t},BigInteger.prototype.divideAndRemainder=function bnDivideAndRemainder(e){var t=nbi(),r=nbi();return this.divRemTo(e,t,r),new Array(t,r)},BigInteger.prototype.modPow=function bnModPow(e,t){var r,n,i=e.bitLength(),o=nbv(1);if(i<=0)return o;r=i<18?1:i<48?3:i<144?4:i<768?5:6,n=i<8?new Classic(t):t.isEven()?new Barrett(t):new Montgomery(t);var s=new Array,a=3,u=r-1,c=(1<<r)-1;if(s[1]=n.convert(this),r>1){var h=nbi();for(n.sqrTo(s[1],h);a<=c;)s[a]=nbi(),n.mulTo(h,s[a-2],s[a]),a+=2}var l,f,g=e.t-1,p=!0,d=nbi();for(i=nbits(e[g])-1;g>=0;){for(i>=u?l=e[g]>>i-u&c:(l=(e[g]&(1<<i+1)-1)<<u-i,g>0&&(l|=e[g-1]>>this.DB+i-u)),a=r;0==(1&l);)l>>=1,--a;if((i-=a)<0&&(i+=this.DB,--g),p)s[l].copyTo(o),p=!1;else{for(;a>1;)n.sqrTo(o,d),n.sqrTo(d,o),a-=2;a>0?n.sqrTo(o,d):(f=o,o=d,d=f),n.mulTo(d,s[l],o)}for(;g>=0&&0==(e[g]&1<<i);)n.sqrTo(o,d),f=o,o=d,d=f,--i<0&&(i=this.DB-1,--g)}return n.revert(o)},BigInteger.prototype.modInverse=function bnModInverse(e){var t=e.isEven();if(this.isEven()&&t||0==e.signum())return BigInteger.ZERO;for(var r=e.clone(),n=this.clone(),i=nbv(1),o=nbv(0),s=nbv(0),a=nbv(1);0!=r.signum();){for(;r.isEven();)r.rShiftTo(1,r),t?(i.isEven()&&o.isEven()||(i.addTo(this,i),o.subTo(e,o)),i.rShiftTo(1,i)):o.isEven()||o.subTo(e,o),o.rShiftTo(1,o);for(;n.isEven();)n.rShiftTo(1,n),t?(s.isEven()&&a.isEven()||(s.addTo(this,s),a.subTo(e,a)),s.rShiftTo(1,s)):a.isEven()||a.subTo(e,a),a.rShiftTo(1,a);r.compareTo(n)>=0?(r.subTo(n,r),t&&i.subTo(s,i),o.subTo(a,o)):(n.subTo(r,n),t&&s.subTo(i,s),a.subTo(o,a))}return 0!=n.compareTo(BigInteger.ONE)?BigInteger.ZERO:a.compareTo(e)>=0?a.subtract(e):a.signum()<0?(a.addTo(e,a),a.signum()<0?a.add(e):a):a},BigInteger.prototype.pow=function bnPow(e){return this.exp(e,new NullExp)},BigInteger.prototype.gcd=function bnGCD(e){var t=this.s<0?this.negate():this.clone(),r=e.s<0?e.negate():e.clone();if(t.compareTo(r)<0){var n=t;t=r,r=n}var i=t.getLowestSetBit(),o=r.getLowestSetBit();if(o<0)return t;for(i<o&&(o=i),o>0&&(t.rShiftTo(o,t),r.rShiftTo(o,r));t.signum()>0;)(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),(i=r.getLowestSetBit())>0&&r.rShiftTo(i,r),t.compareTo(r)>=0?(t.subTo(r,t),t.rShiftTo(1,t)):(r.subTo(t,r),r.rShiftTo(1,r));return o>0&&r.lShiftTo(o,r),r},BigInteger.prototype.isProbablePrime=function bnIsProbablePrime(e){var t,r=this.abs();if(1==r.t&&r[0]<=I[I.length-1]){for(t=0;t<I.length;++t)if(r[0]==I[t])return!0;return!1}if(r.isEven())return!1;for(t=1;t<I.length;){for(var n=I[t],i=t+1;i<I.length&&n<R;)n*=I[i++];for(n=r.modInt(n);t<i;)if(n%I[t++]==0)return!1}return r.millerRabin(e)},BigInteger.prototype.square=function bnSquare(){var e=nbi();return this.squareTo(e),e},Arcfour.prototype.init=function ARC4init(e){var t,r,n;for(t=0;t<256;++t)this.S[t]=t;for(r=0,t=0;t<256;++t)r=r+this.S[t]+e[t%e.length]&255,n=this.S[t],this.S[t]=this.S[r],this.S[r]=n;this.i=0,this.j=0},Arcfour.prototype.next=function ARC4next(){var e;return this.i=this.i+1&255,this.j=this.j+this.S[this.i]&255,e=this.S[this.i],this.S[this.i]=this.S[this.j],this.S[this.j]=e,this.S[e+this.S[this.i]&255]};var T,U,D,L=256;
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */function rng_seed_time(){!function rng_seed_int(e){U[D++]^=255&e,U[D++]^=e>>8&255,U[D++]^=e>>16&255,U[D++]^=e>>24&255,D>=L&&(D-=L)}((new Date).getTime())}if(null==U){var M;if(U=new Array,D=0,void 0!==p&&(void 0!==p.crypto||void 0!==p.msCrypto)){var N=p.crypto||p.msCrypto;if(N.getRandomValues){var O=new Uint8Array(32);for(N.getRandomValues(O),M=0;M<32;++M)U[D++]=O[M]}else if("Netscape"==u.appName&&u.appVersion<"5"){var H=p.crypto.random(32);for(M=0;M<H.length;++M)U[D++]=255&H.charCodeAt(M)}}for(;D<L;)M=Math.floor(65536*Math.random()),U[D++]=M>>>8,U[D++]=255&M;D=0,rng_seed_time()}function rng_get_byte(){if(null==T){for(rng_seed_time(),(T=function prng_newstate(){return new Arcfour}()).init(U),D=0;D<U.length;++D)U[D]=0;D=0}return T.next()}function SecureRandom(){}
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function parseBigInt(e,t){return new BigInteger(e,t)}function oaep_mgf1_arr(e,t,r){for(var n="",i=0;n.length<t;)n+=r(String.fromCharCode.apply(String,e.concat([(4278190080&i)>>24,(16711680&i)>>16,(65280&i)>>8,255&i]))),i+=1;return n}function RSAKey(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}
/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/
 */
function ECFieldElementFp(e,t){this.x=t,this.q=e}function ECPointFp(e,t,r,n){this.curve=e,this.x=t,this.y=r,this.z=null==n?BigInteger.ONE:n,this.zinv=null}function ECCurveFp(e,t,r){this.q=e,this.a=this.fromBigInteger(t),this.b=this.fromBigInteger(r),this.infinity=new ECPointFp(this,null,null)}SecureRandom.prototype.nextBytes=function rng_get_bytes(e){var t;for(t=0;t<e.length;++t)e[t]=rng_get_byte()},RSAKey.prototype.doPublic=function RSADoPublic(e){return e.modPowInt(this.e,this.n)},RSAKey.prototype.setPublic=function RSASetPublic(e,t){if(this.isPublic=!0,this.isPrivate=!1,"string"!=typeof e)this.n=e,this.e=t;else{if(!(null!=e&&null!=t&&e.length>0&&t.length>0))throw"Invalid RSA public key";this.n=parseBigInt(e,16),this.e=parseInt(t,16)}},RSAKey.prototype.encrypt=function RSAEncrypt(e){var t=function pkcs1pad2(e,t){if(t<e.length+11)throw"Message too long for RSA";for(var r=new Array,n=e.length-1;n>=0&&t>0;){var i=e.charCodeAt(n--);i<128?r[--t]=i:i>127&&i<2048?(r[--t]=63&i|128,r[--t]=i>>6|192):(r[--t]=63&i|128,r[--t]=i>>6&63|128,r[--t]=i>>12|224)}r[--t]=0;for(var o=new SecureRandom,s=new Array;t>2;){for(s[0]=0;0==s[0];)o.nextBytes(s);r[--t]=s[0]}return r[--t]=2,r[--t]=0,new BigInteger(r)}(e,this.n.bitLength()+7>>3);if(null==t)return null;var r=this.doPublic(t);if(null==r)return null;var n=r.toString(16);return 0==(1&n.length)?n:"0"+n},RSAKey.prototype.encryptOAEP=function RSAEncryptOAEP(e,t,r){var n=function oaep_pad(e,t,r,n){var i=V.crypto.MessageDigest,o=V.crypto.Util,s=null;if(r||(r="sha1"),"string"==typeof r&&(s=i.getCanonicalAlgName(r),n=i.getHashLength(s),r=function f(e){return hextorstr(o.hashHex(rstrtohex(e),s))}),e.length+2*n+2>t)throw"Message too long for RSA";var a,u="";for(a=0;a<t-e.length-2*n-2;a+=1)u+="\0";var c=r("")+u+""+e,h=new Array(n);(new SecureRandom).nextBytes(h);var l=oaep_mgf1_arr(h,c.length,r),g=[];for(a=0;a<c.length;a+=1)g[a]=c.charCodeAt(a)^l.charCodeAt(a);var p=oaep_mgf1_arr(g,h.length,r),d=[0];for(a=0;a<h.length;a+=1)d[a+1]=h[a]^p.charCodeAt(a);return new BigInteger(d.concat(g))}(e,this.n.bitLength()+7>>3,t,r);if(null==n)return null;var i=this.doPublic(n);if(null==i)return null;var o=i.toString(16);return 0==(1&o.length)?o:"0"+o},RSAKey.prototype.type="RSA",ECFieldElementFp.prototype.equals=function feFpEquals(e){return e==this||this.q.equals(e.q)&&this.x.equals(e.x)},ECFieldElementFp.prototype.toBigInteger=function feFpToBigInteger(){return this.x},ECFieldElementFp.prototype.negate=function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))},ECFieldElementFp.prototype.add=function feFpAdd(e){return new ECFieldElementFp(this.q,this.x.add(e.toBigInteger()).mod(this.q))},ECFieldElementFp.prototype.subtract=function feFpSubtract(e){return new ECFieldElementFp(this.q,this.x.subtract(e.toBigInteger()).mod(this.q))},ECFieldElementFp.prototype.multiply=function feFpMultiply(e){return new ECFieldElementFp(this.q,this.x.multiply(e.toBigInteger()).mod(this.q))},ECFieldElementFp.prototype.square=function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))},ECFieldElementFp.prototype.divide=function feFpDivide(e){return new ECFieldElementFp(this.q,this.x.multiply(e.toBigInteger().modInverse(this.q)).mod(this.q))},ECPointFp.prototype.getX=function pointFpGetX(){return null==this.zinv&&(this.zinv=this.z.modInverse(this.curve.q)),this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))},ECPointFp.prototype.getY=function pointFpGetY(){return null==this.zinv&&(this.zinv=this.z.modInverse(this.curve.q)),this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))},ECPointFp.prototype.equals=function pointFpEquals(e){return e==this||(this.isInfinity()?e.isInfinity():e.isInfinity()?this.isInfinity():!!e.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(e.z)).mod(this.curve.q).equals(BigInteger.ZERO)&&e.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(e.z)).mod(this.curve.q).equals(BigInteger.ZERO))},ECPointFp.prototype.isInfinity=function pointFpIsInfinity(){return null==this.x&&null==this.y||this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)},ECPointFp.prototype.negate=function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)},ECPointFp.prototype.add=function pointFpAdd(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(e.z)).mod(this.curve.q),r=e.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(e.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(r))return BigInteger.ZERO.equals(t)?this.twice():this.curve.getInfinity();var n=new BigInteger("3"),i=this.x.toBigInteger(),o=this.y.toBigInteger(),s=(e.x.toBigInteger(),e.y.toBigInteger(),r.square()),a=s.multiply(r),u=i.multiply(s),c=t.square().multiply(this.z),h=c.subtract(u.shiftLeft(1)).multiply(e.z).subtract(a).multiply(r).mod(this.curve.q),l=u.multiply(n).multiply(t).subtract(o.multiply(a)).subtract(c.multiply(t)).multiply(e.z).add(t.multiply(a)).mod(this.curve.q),f=a.multiply(this.z).multiply(e.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(h),this.curve.fromBigInteger(l),f)},ECPointFp.prototype.twice=function pointFpTwice(){if(this.isInfinity())return this;if(0==this.y.toBigInteger().signum())return this.curve.getInfinity();var e=new BigInteger("3"),t=this.x.toBigInteger(),r=this.y.toBigInteger(),n=r.multiply(this.z),i=n.multiply(r).mod(this.curve.q),o=this.curve.a.toBigInteger(),s=t.square().multiply(e);BigInteger.ZERO.equals(o)||(s=s.add(this.z.square().multiply(o)));var a=(s=s.mod(this.curve.q)).square().subtract(t.shiftLeft(3).multiply(i)).shiftLeft(1).multiply(n).mod(this.curve.q),u=s.multiply(e).multiply(t).subtract(i.shiftLeft(1)).shiftLeft(2).multiply(i).subtract(s.square().multiply(s)).mod(this.curve.q),c=n.square().multiply(n).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(a),this.curve.fromBigInteger(u),c)},ECPointFp.prototype.multiply=function pointFpMultiply(e){if(this.isInfinity())return this;if(0==e.signum())return this.curve.getInfinity();var t,r=e,n=r.multiply(new BigInteger("3")),i=this.negate(),o=this;for(t=n.bitLength()-2;t>0;--t){o=o.twice();var s=n.testBit(t);s!=r.testBit(t)&&(o=o.add(s?this:i))}return o},ECPointFp.prototype.multiplyTwo=function pointFpMultiplyTwo(e,t,r){var n;n=e.bitLength()>r.bitLength()?e.bitLength()-1:r.bitLength()-1;for(var i=this.curve.getInfinity(),o=this.add(t);n>=0;)i=i.twice(),e.testBit(n)?i=r.testBit(n)?i.add(o):i.add(this):r.testBit(n)&&(i=i.add(t)),--n;return i},ECCurveFp.prototype.getQ=function curveFpGetQ(){return this.q},ECCurveFp.prototype.getA=function curveFpGetA(){return this.a},ECCurveFp.prototype.getB=function curveFpGetB(){return this.b},ECCurveFp.prototype.equals=function curveFpEquals(e){return e==this||this.q.equals(e.q)&&this.a.equals(e.a)&&this.b.equals(e.b)},ECCurveFp.prototype.getInfinity=function curveFpGetInfinity(){return this.infinity},ECCurveFp.prototype.fromBigInteger=function curveFpFromBigInteger(e){return new ECFieldElementFp(this.q,e)},ECCurveFp.prototype.decodePointHex=function curveFpDecodePointHex(e){switch(parseInt(e.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var t=(e.length-2)/2,r=e.substr(2,t),n=e.substr(t+2,t);return new ECPointFp(this,this.fromBigInteger(new BigInteger(r,16)),this.fromBigInteger(new BigInteger(n,16)));default:return null}},
/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib
 */
ECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)},ECPointFp.prototype.getEncoded=function(e){var t=function d(e,t){var r=e.toByteArrayUnsigned();if(t<r.length)r=r.slice(r.length-t);else for(;t>r.length;)r.unshift(0);return r},r=this.getX().toBigInteger(),n=this.getY().toBigInteger(),i=t(r,32);return e?n.isEven()?i.unshift(2):i.unshift(3):(i.unshift(4),i=i.concat(t(n,32))),i},ECPointFp.decodeFrom=function(e,t){t[0];var r=t.length-1,n=t.slice(1,1+r/2),i=t.slice(1+r/2,1+r);n.unshift(0),i.unshift(0);var o=new BigInteger(n),s=new BigInteger(i);return new ECPointFp(e,e.fromBigInteger(o),e.fromBigInteger(s))},ECPointFp.decodeFromHex=function(e,t){t.substr(0,2);var r=t.length-2,n=t.substr(2,r/2),i=t.substr(2+r/2,r/2),o=new BigInteger(n,16),s=new BigInteger(i,16);return new ECPointFp(e,e.fromBigInteger(o),e.fromBigInteger(s))},ECPointFp.prototype.add2D=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;if(this.x.equals(e.x))return this.y.equals(e.y)?this.twice():this.curve.getInfinity();var t=e.x.subtract(this.x),r=e.y.subtract(this.y).divide(t),n=r.square().subtract(this.x).subtract(e.x),i=r.multiply(this.x.subtract(n)).subtract(this.y);return new ECPointFp(this.curve,n,i)},ECPointFp.prototype.twice2D=function(){if(this.isInfinity())return this;if(0==this.y.toBigInteger().signum())return this.curve.getInfinity();var e=this.curve.fromBigInteger(BigInteger.valueOf(2)),t=this.curve.fromBigInteger(BigInteger.valueOf(3)),r=this.x.square().multiply(t).add(this.curve.a).divide(this.y.multiply(e)),n=r.square().subtract(this.x.multiply(e)),i=r.multiply(this.x.subtract(n)).subtract(this.y);return new ECPointFp(this.curve,n,i)},ECPointFp.prototype.multiply2D=function(e){if(this.isInfinity())return this;if(0==e.signum())return this.curve.getInfinity();var t,r=e,n=r.multiply(new BigInteger("3")),i=this.negate(),o=this;for(t=n.bitLength()-2;t>0;--t){o=o.twice();var s=n.testBit(t);s!=r.testBit(t)&&(o=o.add2D(s?this:i))}return o},ECPointFp.prototype.isOnCurve=function(){var e=this.getX().toBigInteger(),t=this.getY().toBigInteger(),r=this.curve.getA().toBigInteger(),n=this.curve.getB().toBigInteger(),i=this.curve.getQ(),o=t.multiply(t).mod(i),s=e.multiply(e).multiply(e).add(r.multiply(e)).add(n).mod(i);return o.equals(s)},ECPointFp.prototype.toString=function(){return"("+this.getX().toBigInteger().toString()+","+this.getY().toBigInteger().toString()+")"},ECPointFp.prototype.validate=function(){var e=this.curve.getQ();if(this.isInfinity())throw new Error("Point is at infinity.");var t=this.getX().toBigInteger(),r=this.getY().toBigInteger();if(t.compareTo(BigInteger.ONE)<0||t.compareTo(e.subtract(BigInteger.ONE))>0)throw new Error("x coordinate out of bounds");if(r.compareTo(BigInteger.ONE)<0||r.compareTo(e.subtract(BigInteger.ONE))>0)throw new Error("y coordinate out of bounds");if(!this.isOnCurve())throw new Error("Point is not on the curve.");if(this.multiply(e).isInfinity())throw new Error("Point is not a scalar multiple of G.");return!0};
/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval
 */
var K=function(){var e=new RegExp('(?:false|true|null|[\\{\\}\\[\\]]|(?:-?\\b(?:0|[1-9][0-9]*)(?:\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\b)|(?:"(?:[^\\0-\\x08\\x0a-\\x1f"\\\\]|\\\\(?:["/\\\\bfnrt]|u[0-9A-Fa-f]{4}))*"))',"g"),t=new RegExp("\\\\(?:([^u])|u(.{4}))","g"),r={'"':'"',"/":"/","\\":"\\",b:"\b",f:"\f",n:"\n",r:"\r",t:"\t"};function h(e,t,n){return t?r[t]:String.fromCharCode(parseInt(n,16))}var n=new String(""),o=(Object,Array,Object.hasOwnProperty);return function(r,a){var u,c,l=r.match(e),f=l[0],g=!1;"{"===f?u={}:"["===f?u=[]:(u=[],g=!0);for(var p=[u],d=1-g,v=l.length;d<v;++d){var y;switch((f=l[d]).charCodeAt(0)){default:(y=p[0])[c||y.length]=+f,c=void 0;break;case 34:if(-1!==(f=f.substring(1,f.length-1)).indexOf("\\")&&(f=f.replace(t,h)),y=p[0],!c){if(!(y instanceof Array)){c=f||n;break}c=y.length}y[c]=f,c=void 0;break;case 91:y=p[0],p.unshift(y[c||y.length]=[]),c=void 0;break;case 93:p.shift();break;case 102:(y=p[0])[c||y.length]=!1,c=void 0;break;case 110:(y=p[0])[c||y.length]=null,c=void 0;break;case 116:(y=p[0])[c||y.length]=!0,c=void 0;break;case 123:y=p[0],p.unshift(y[c||y.length]={}),c=void 0;break;case 125:p.shift()}}if(g){if(1!==p.length)throw new Error;u=u[0]}else if(p.length)throw new Error;if(a){u=function s(e,t){var r=e[t];if(r&&"object"===(void 0===r?"undefined":i(r))){var n=null;for(var u in r)if(o.call(r,u)&&r!==e){var c=s(r,u);void 0!==c?r[u]=c:(n||(n=[]),n.push(u))}if(n)for(var h=n.length;--h>=0;)delete r[n[h]]}return a.call(e,t,r)}({"":u},"")}return u}}();void 0!==V&&V||(t.KJUR=V={}),void 0!==V.asn1&&V.asn1||(V.asn1={}),V.asn1.ASN1Util=new function(){this.integerToByteHex=function(e){var t=e.toString(16);return t.length%2==1&&(t="0"+t),t},this.bigIntToMinTwosComplementsHex=function(e){var t=e.toString(16);if("-"!=t.substr(0,1))t.length%2==1?t="0"+t:t.match(/^[0-7]/)||(t="00"+t);else{var r=t.substr(1).length;r%2==1?r+=1:t.match(/^[0-7]/)||(r+=2);for(var n="",i=0;i<r;i++)n+="f";t=new BigInteger(n,16).xor(e).add(BigInteger.ONE).toString(16).replace(/^-/,"")}return t},this.getPEMStringFromHex=function(e,t){return hextopem(e,t)},this.newObject=function(e){var t=V.asn1,r=t.DERBoolean,n=t.DERInteger,i=t.DERBitString,o=t.DEROctetString,s=t.DERNull,a=t.DERObjectIdentifier,u=t.DEREnumerated,c=t.DERUTF8String,h=t.DERNumericString,l=t.DERPrintableString,f=t.DERTeletexString,g=t.DERIA5String,p=t.DERUTCTime,d=t.DERGeneralizedTime,v=t.DERSequence,y=t.DERSet,m=t.DERTaggedObject,_=t.ASN1Util.newObject,S=Object.keys(e);if(1!=S.length)throw"key of param shall be only one.";var b=S[0];if(-1==":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:".indexOf(":"+b+":"))throw"undefined key: "+b;if("bool"==b)return new r(e[b]);if("int"==b)return new n(e[b]);if("bitstr"==b)return new i(e[b]);if("octstr"==b)return new o(e[b]);if("null"==b)return new s(e[b]);if("oid"==b)return new a(e[b]);if("enum"==b)return new u(e[b]);if("utf8str"==b)return new c(e[b]);if("numstr"==b)return new h(e[b]);if("prnstr"==b)return new l(e[b]);if("telstr"==b)return new f(e[b]);if("ia5str"==b)return new g(e[b]);if("utctime"==b)return new p(e[b]);if("gentime"==b)return new d(e[b]);if("seq"==b){for(var F=e[b],w=[],E=0;E<F.length;E++){var x=_(F[E]);w.push(x)}return new v({array:w})}if("set"==b){for(F=e[b],w=[],E=0;E<F.length;E++){x=_(F[E]);w.push(x)}return new y({array:w})}if("tag"==b){var C=e[b];if("[object Array]"===Object.prototype.toString.call(C)&&3==C.length){var k=_(C[2]);return new m({tag:C[0],explicit:C[1],obj:k})}var A={};if(void 0!==C.explicit&&(A.explicit=C.explicit),void 0!==C.tag&&(A.tag=C.tag),void 0===C.obj)throw"obj shall be specified for 'tag'.";return A.obj=_(C.obj),new m(A)}},this.jsonToASN1HEX=function(e){return this.newObject(e).getEncodedHex()}},V.asn1.ASN1Util.oidHexToInt=function(e){for(var t="",r=parseInt(e.substr(0,2),16),n=(t=Math.floor(r/40)+"."+r%40,""),i=2;i<e.length;i+=2){var o=("00000000"+parseInt(e.substr(i,2),16).toString(2)).slice(-8);if(n+=o.substr(1,7),"0"==o.substr(0,1))t=t+"."+new BigInteger(n,2).toString(10),n=""}return t},V.asn1.ASN1Util.oidIntToHex=function(e){var t=function e(t){var r=t.toString(16);return 1==r.length&&(r="0"+r),r},r=function d(e){var r="",n=new BigInteger(e,10).toString(2),i=7-n.length%7;7==i&&(i=0);for(var o="",s=0;s<i;s++)o+="0";n=o+n;for(s=0;s<n.length-1;s+=7){var a=n.substr(s,7);s!=n.length-7&&(a="1"+a),r+=t(parseInt(a,2))}return r};if(!e.match(/^[0-9.]+$/))throw"malformed oid string: "+e;var n="",i=e.split("."),o=40*parseInt(i[0])+parseInt(i[1]);n+=t(o),i.splice(0,2);for(var s=0;s<i.length;s++)n+=r(i[s]);return n},V.asn1.ASN1Object=function(){this.getLengthHexFromValue=function(){if(void 0===this.hV||null==this.hV)throw"this.hV is null or undefined.";if(this.hV.length%2==1)throw"value hex must be even length: n="+"".length+",v="+this.hV;var e=this.hV.length/2,t=e.toString(16);if(t.length%2==1&&(t="0"+t),e<128)return t;var r=t.length/2;if(r>15)throw"ASN.1 length too long to represent by 8x: n = "+e.toString(16);return(128+r).toString(16)+t},this.getEncodedHex=function(){return(null==this.hTLV||this.isModified)&&(this.hV=this.getFreshValueHex(),this.hL=this.getLengthHexFromValue(),this.hTLV=this.hT+this.hL+this.hV,this.isModified=!1),this.hTLV},this.getValueHex=function(){return this.getEncodedHex(),this.hV},this.getFreshValueHex=function(){return""}},V.asn1.DERAbstractString=function(e){V.asn1.DERAbstractString.superclass.constructor.call(this);this.getString=function(){return this.s},this.setString=function(e){this.hTLV=null,this.isModified=!0,this.s=e,this.hV=utf8tohex(this.s).toLowerCase()},this.setStringHex=function(e){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&("string"==typeof e?this.setString(e):void 0!==e.str?this.setString(e.str):void 0!==e.hex&&this.setStringHex(e.hex))},v.lang.extend(V.asn1.DERAbstractString,V.asn1.ASN1Object),V.asn1.DERAbstractTime=function(e){V.asn1.DERAbstractTime.superclass.constructor.call(this);this.localDateToUTC=function(e){return utc=e.getTime()+6e4*e.getTimezoneOffset(),new Date(utc)},this.formatDate=function(e,t,r){var n=this.zeroPadding,i=this.localDateToUTC(e),o=String(i.getFullYear());"utc"==t&&(o=o.substr(2,2));var s=o+n(String(i.getMonth()+1),2)+n(String(i.getDate()),2)+n(String(i.getHours()),2)+n(String(i.getMinutes()),2)+n(String(i.getSeconds()),2);if(!0===r){var a=i.getMilliseconds();if(0!=a){var u=n(String(a),3);s=s+"."+(u=u.replace(/[0]+$/,""))}}return s+"Z"},this.zeroPadding=function(e,t){return e.length>=t?e:new Array(t-e.length+1).join("0")+e},this.getString=function(){return this.s},this.setString=function(e){this.hTLV=null,this.isModified=!0,this.s=e,this.hV=stohex(e)},this.setByDateValue=function(e,t,r,n,i,o){var s=new Date(Date.UTC(e,t-1,r,n,i,o,0));this.setByDate(s)},this.getFreshValueHex=function(){return this.hV}},v.lang.extend(V.asn1.DERAbstractTime,V.asn1.ASN1Object),V.asn1.DERAbstractStructured=function(e){V.asn1.DERAbstractString.superclass.constructor.call(this);this.setByASN1ObjectArray=function(e){this.hTLV=null,this.isModified=!0,this.asn1Array=e},this.appendASN1Object=function(e){this.hTLV=null,this.isModified=!0,this.asn1Array.push(e)},this.asn1Array=new Array,void 0!==e&&void 0!==e.array&&(this.asn1Array=e.array)},v.lang.extend(V.asn1.DERAbstractStructured,V.asn1.ASN1Object),V.asn1.DERBoolean=function(){V.asn1.DERBoolean.superclass.constructor.call(this),this.hT="01",this.hTLV="0101ff"},v.lang.extend(V.asn1.DERBoolean,V.asn1.ASN1Object),V.asn1.DERInteger=function(e){V.asn1.DERInteger.superclass.constructor.call(this),this.hT="02",this.setByBigInteger=function(e){this.hTLV=null,this.isModified=!0,this.hV=V.asn1.ASN1Util.bigIntToMinTwosComplementsHex(e)},this.setByInteger=function(e){var t=new BigInteger(String(e),10);this.setByBigInteger(t)},this.setValueHex=function(e){this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.bigint?this.setByBigInteger(e.bigint):void 0!==e.int?this.setByInteger(e.int):"number"==typeof e?this.setByInteger(e):void 0!==e.hex&&this.setValueHex(e.hex))},v.lang.extend(V.asn1.DERInteger,V.asn1.ASN1Object),V.asn1.DERBitString=function(e){if(void 0!==e&&void 0!==e.obj){var t=V.asn1.ASN1Util.newObject(e.obj);e.hex="00"+t.getEncodedHex()}V.asn1.DERBitString.superclass.constructor.call(this),this.hT="03",this.setHexValueIncludingUnusedBits=function(e){this.hTLV=null,this.isModified=!0,this.hV=e},this.setUnusedBitsAndHexValue=function(e,t){if(e<0||7<e)throw"unused bits shall be from 0 to 7: u = "+e;var r="0"+e;this.hTLV=null,this.isModified=!0,this.hV=r+t},this.setByBinaryString=function(e){var t=8-(e=e.replace(/0+$/,"")).length%8;8==t&&(t=0);for(var r=0;r<=t;r++)e+="0";var n="";for(r=0;r<e.length-1;r+=8){var i=e.substr(r,8),o=parseInt(i,2).toString(16);1==o.length&&(o="0"+o),n+=o}this.hTLV=null,this.isModified=!0,this.hV="0"+t+n},this.setByBooleanArray=function(e){for(var t="",r=0;r<e.length;r++)1==e[r]?t+="1":t+="0";this.setByBinaryString(t)},this.newFalseArray=function(e){for(var t=new Array(e),r=0;r<e;r++)t[r]=!1;return t},this.getFreshValueHex=function(){return this.hV},void 0!==e&&("string"==typeof e&&e.toLowerCase().match(/^[0-9a-f]+$/)?this.setHexValueIncludingUnusedBits(e):void 0!==e.hex?this.setHexValueIncludingUnusedBits(e.hex):void 0!==e.bin?this.setByBinaryString(e.bin):void 0!==e.array&&this.setByBooleanArray(e.array))},v.lang.extend(V.asn1.DERBitString,V.asn1.ASN1Object),V.asn1.DEROctetString=function(e){if(void 0!==e&&void 0!==e.obj){var t=V.asn1.ASN1Util.newObject(e.obj);e.hex=t.getEncodedHex()}V.asn1.DEROctetString.superclass.constructor.call(this,e),this.hT="04"},v.lang.extend(V.asn1.DEROctetString,V.asn1.DERAbstractString),V.asn1.DERNull=function(){V.asn1.DERNull.superclass.constructor.call(this),this.hT="05",this.hTLV="0500"},v.lang.extend(V.asn1.DERNull,V.asn1.ASN1Object),V.asn1.DERObjectIdentifier=function(e){var t=function b(e){var t=e.toString(16);return 1==t.length&&(t="0"+t),t},r=function a(e){var r="",n=new BigInteger(e,10).toString(2),i=7-n.length%7;7==i&&(i=0);for(var o="",s=0;s<i;s++)o+="0";n=o+n;for(s=0;s<n.length-1;s+=7){var u=n.substr(s,7);s!=n.length-7&&(u="1"+u),r+=t(parseInt(u,2))}return r};V.asn1.DERObjectIdentifier.superclass.constructor.call(this),this.hT="06",this.setValueHex=function(e){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=e},this.setValueOidString=function(e){if(!e.match(/^[0-9.]+$/))throw"malformed oid string: "+e;var n="",i=e.split("."),o=40*parseInt(i[0])+parseInt(i[1]);n+=t(o),i.splice(0,2);for(var s=0;s<i.length;s++)n+=r(i[s]);this.hTLV=null,this.isModified=!0,this.s=null,this.hV=n},this.setValueName=function(e){var t=V.asn1.x509.OID.name2oid(e);if(""===t)throw"DERObjectIdentifier oidName undefined: "+e;this.setValueOidString(t)},this.getFreshValueHex=function(){return this.hV},void 0!==e&&("string"==typeof e?e.match(/^[0-2].[0-9.]+$/)?this.setValueOidString(e):this.setValueName(e):void 0!==e.oid?this.setValueOidString(e.oid):void 0!==e.hex?this.setValueHex(e.hex):void 0!==e.name&&this.setValueName(e.name))},v.lang.extend(V.asn1.DERObjectIdentifier,V.asn1.ASN1Object),V.asn1.DEREnumerated=function(e){V.asn1.DEREnumerated.superclass.constructor.call(this),this.hT="0a",this.setByBigInteger=function(e){this.hTLV=null,this.isModified=!0,this.hV=V.asn1.ASN1Util.bigIntToMinTwosComplementsHex(e)},this.setByInteger=function(e){var t=new BigInteger(String(e),10);this.setByBigInteger(t)},this.setValueHex=function(e){this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.int?this.setByInteger(e.int):"number"==typeof e?this.setByInteger(e):void 0!==e.hex&&this.setValueHex(e.hex))},v.lang.extend(V.asn1.DEREnumerated,V.asn1.ASN1Object),V.asn1.DERUTF8String=function(e){V.asn1.DERUTF8String.superclass.constructor.call(this,e),this.hT="0c"},v.lang.extend(V.asn1.DERUTF8String,V.asn1.DERAbstractString),V.asn1.DERNumericString=function(e){V.asn1.DERNumericString.superclass.constructor.call(this,e),this.hT="12"},v.lang.extend(V.asn1.DERNumericString,V.asn1.DERAbstractString),V.asn1.DERPrintableString=function(e){V.asn1.DERPrintableString.superclass.constructor.call(this,e),this.hT="13"},v.lang.extend(V.asn1.DERPrintableString,V.asn1.DERAbstractString),V.asn1.DERTeletexString=function(e){V.asn1.DERTeletexString.superclass.constructor.call(this,e),this.hT="14"},v.lang.extend(V.asn1.DERTeletexString,V.asn1.DERAbstractString),V.asn1.DERIA5String=function(e){V.asn1.DERIA5String.superclass.constructor.call(this,e),this.hT="16"},v.lang.extend(V.asn1.DERIA5String,V.asn1.DERAbstractString),V.asn1.DERUTCTime=function(e){V.asn1.DERUTCTime.superclass.constructor.call(this,e),this.hT="17",this.setByDate=function(e){this.hTLV=null,this.isModified=!0,this.date=e,this.s=this.formatDate(this.date,"utc"),this.hV=stohex(this.s)},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,"utc"),this.hV=stohex(this.s)),this.hV},void 0!==e&&(void 0!==e.str?this.setString(e.str):"string"==typeof e&&e.match(/^[0-9]{12}Z$/)?this.setString(e):void 0!==e.hex?this.setStringHex(e.hex):void 0!==e.date&&this.setByDate(e.date))},v.lang.extend(V.asn1.DERUTCTime,V.asn1.DERAbstractTime),V.asn1.DERGeneralizedTime=function(e){V.asn1.DERGeneralizedTime.superclass.constructor.call(this,e),this.hT="18",this.withMillis=!1,this.setByDate=function(e){this.hTLV=null,this.isModified=!0,this.date=e,this.s=this.formatDate(this.date,"gen",this.withMillis),this.hV=stohex(this.s)},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,"gen",this.withMillis),this.hV=stohex(this.s)),this.hV},void 0!==e&&(void 0!==e.str?this.setString(e.str):"string"==typeof e&&e.match(/^[0-9]{14}Z$/)?this.setString(e):void 0!==e.hex?this.setStringHex(e.hex):void 0!==e.date&&this.setByDate(e.date),!0===e.millis&&(this.withMillis=!0))},v.lang.extend(V.asn1.DERGeneralizedTime,V.asn1.DERAbstractTime),V.asn1.DERSequence=function(e){V.asn1.DERSequence.superclass.constructor.call(this,e),this.hT="30",this.getFreshValueHex=function(){for(var e="",t=0;t<this.asn1Array.length;t++){e+=this.asn1Array[t].getEncodedHex()}return this.hV=e,this.hV}},v.lang.extend(V.asn1.DERSequence,V.asn1.DERAbstractStructured),V.asn1.DERSet=function(e){V.asn1.DERSet.superclass.constructor.call(this,e),this.hT="31",this.sortFlag=!0,this.getFreshValueHex=function(){for(var e=new Array,t=0;t<this.asn1Array.length;t++){var r=this.asn1Array[t];e.push(r.getEncodedHex())}return 1==this.sortFlag&&e.sort(),this.hV=e.join(""),this.hV},void 0!==e&&void 0!==e.sortflag&&0==e.sortflag&&(this.sortFlag=!1)},v.lang.extend(V.asn1.DERSet,V.asn1.DERAbstractStructured),V.asn1.DERTaggedObject=function(e){V.asn1.DERTaggedObject.superclass.constructor.call(this),this.hT="a0",this.hV="",this.isExplicit=!0,this.asn1Object=null,this.setASN1Object=function(e,t,r){this.hT=t,this.isExplicit=e,this.asn1Object=r,this.isExplicit?(this.hV=this.asn1Object.getEncodedHex(),this.hTLV=null,this.isModified=!0):(this.hV=null,this.hTLV=r.getEncodedHex(),this.hTLV=this.hTLV.replace(/^../,t),this.isModified=!1)},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.tag&&(this.hT=e.tag),void 0!==e.explicit&&(this.isExplicit=e.explicit),void 0!==e.obj&&(this.asn1Object=e.obj,this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)))},v.lang.extend(V.asn1.DERTaggedObject,V.asn1.ASN1Object);var V,q,W,J=new function(){};function stoBA(e){for(var t=new Array,r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t}function BAtos(e){for(var t="",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t}function BAtohex(e){for(var t="",r=0;r<e.length;r++){var n=e[r].toString(16);1==n.length&&(n="0"+n),t+=n}return t}function stohex(e){return BAtohex(stoBA(e))}function b64tob64u(e){return e=(e=(e=e.replace(/\=/g,"")).replace(/\+/g,"-")).replace(/\//g,"_")}function b64utob64(e){return e.length%4==2?e+="==":e.length%4==3&&(e+="="),e=(e=e.replace(/-/g,"+")).replace(/_/g,"/")}function hextob64u(e){return e.length%2==1&&(e="0"+e),b64tob64u(hex2b64(e))}function b64utohex(e){return b64tohex(b64utob64(e))}function utf8tohex(e){return uricmptohex(encodeURIComponentAll(e))}function hextoutf8(e){return decodeURIComponent(hextouricmp(e))}function hextorstr(e){for(var t="",r=0;r<e.length-1;r+=2)t+=String.fromCharCode(parseInt(e.substr(r,2),16));return t}function rstrtohex(e){for(var t="",r=0;r<e.length;r++)t+=("0"+e.charCodeAt(r).toString(16)).slice(-2);return t}function hextob64(e){return hex2b64(e)}function hextob64nl(e){var t=hextob64(e).replace(/(.{64})/g,"$1\r\n");return t=t.replace(/\r\n$/,"")}function b64nltohex(e){return b64tohex(e.replace(/[^0-9A-Za-z\/+=]*/g,""))}function hextopem(e,t){return"-----BEGIN "+t+"-----\r\n"+hextob64nl(e)+"\r\n-----END "+t+"-----\r\n"}function pemtohex(e,t){if(-1==e.indexOf("-----BEGIN "))throw"can't find PEM header: "+t;return b64nltohex(e=void 0!==t?(e=e.replace("-----BEGIN "+t+"-----","")).replace("-----END "+t+"-----",""):(e=e.replace(/-----BEGIN [^-]+-----/,"")).replace(/-----END [^-]+-----/,""))}function zulutomsec(e){var t,r,n,i,o,s,a,u,c,h,l;if(l=e.match(/^(\d{2}|\d{4})(\d\d)(\d\d)(\d\d)(\d\d)(\d\d)(|\.\d+)Z$/))return u=l[1],t=parseInt(u),2===u.length&&(50<=t&&t<100?t=1900+t:0<=t&&t<50&&(t=2e3+t)),r=parseInt(l[2])-1,n=parseInt(l[3]),i=parseInt(l[4]),o=parseInt(l[5]),s=parseInt(l[6]),a=0,""!==(c=l[7])&&(h=(c.substr(1)+"00").substr(0,3),a=parseInt(h)),Date.UTC(t,r,n,i,o,s,a);throw"unsupported zulu format: "+e}function zulutosec(e){return~~(zulutomsec(e)/1e3)}function uricmptohex(e){return e.replace(/%/g,"")}function hextouricmp(e){return e.replace(/(..)/g,"%$1")}function ipv6tohex(e){var t="malformed IPv6 address";if(!e.match(/^[0-9A-Fa-f:]+$/))throw t;var r=(e=e.toLowerCase()).split(":").length-1;if(r<2)throw t;var n=":".repeat(7-r+2),i=(e=e.replace("::",n)).split(":");if(8!=i.length)throw t;for(var o=0;o<8;o++)i[o]=("0000"+i[o]).slice(-4);return i.join("")}function hextoipv6(e){if(!e.match(/^[0-9A-Fa-f]{32}$/))throw"malformed IPv6 address octet";for(var t=(e=e.toLowerCase()).match(/.{1,4}/g),r=0;r<8;r++)t[r]=t[r].replace(/^0+/,""),""==t[r]&&(t[r]="0");var n=(e=":"+t.join(":")+":").match(/:(0:){2,}/g);if(null===n)return e.slice(1,-1);var i="";for(r=0;r<n.length;r++)n[r].length>i.length&&(i=n[r]);return(e=e.replace(i,"::")).slice(1,-1)}function hextoip(e){var t="malformed hex value";if(!e.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/))throw t;if(8!=e.length)return 32==e.length?hextoipv6(e):e;try{return parseInt(e.substr(0,2),16)+"."+parseInt(e.substr(2,2),16)+"."+parseInt(e.substr(4,2),16)+"."+parseInt(e.substr(6,2),16)}catch(e){throw t}}function encodeURIComponentAll(e){for(var t=encodeURIComponent(e),r="",n=0;n<t.length;n++)"%"==t[n]?(r+=t.substr(n,3),n+=2):r=r+"%"+stohex(t[n]);return r}function hextoposhex(e){return e.length%2==1?"0"+e:e.substr(0,1)>"7"?"00"+e:e}J.getLblen=function(e,t){if("8"!=e.substr(t+2,1))return 1;var r=parseInt(e.substr(t+3,1));return 0==r?-1:0<r&&r<10?r+1:-2},J.getL=function(e,t){var r=J.getLblen(e,t);return r<1?"":e.substr(t+2,2*r)},J.getVblen=function(e,t){var r;return""==(r=J.getL(e,t))?-1:("8"===r.substr(0,1)?new BigInteger(r.substr(2),16):new BigInteger(r,16)).intValue()},J.getVidx=function(e,t){var r=J.getLblen(e,t);return r<0?r:t+2*(r+1)},J.getV=function(e,t){var r=J.getVidx(e,t),n=J.getVblen(e,t);return e.substr(r,2*n)},J.getTLV=function(e,t){return e.substr(t,2)+J.getL(e,t)+J.getV(e,t)},J.getNextSiblingIdx=function(e,t){return J.getVidx(e,t)+2*J.getVblen(e,t)},J.getChildIdx=function(e,t){var r=J,n=new Array,i=r.getVidx(e,t);"03"==e.substr(t,2)?n.push(i+2):n.push(i);for(var o=r.getVblen(e,t),s=i,a=0;;){var u=r.getNextSiblingIdx(e,s);if(null==u||u-i>=2*o)break;if(a>=200)break;n.push(u),s=u,a++}return n},J.getNthChildIdx=function(e,t,r){return J.getChildIdx(e,t)[r]},J.getIdxbyList=function(e,t,r,n){var i,o,s=J;if(0==r.length){if(void 0!==n&&e.substr(t,2)!==n)throw"checking tag doesn't match: "+e.substr(t,2)+"!="+n;return t}return i=r.shift(),o=s.getChildIdx(e,t),s.getIdxbyList(e,o[i],r,n)},J.getTLVbyList=function(e,t,r,n){var i=J,o=i.getIdxbyList(e,t,r);if(void 0===o)throw"can't find nthList object";if(void 0!==n&&e.substr(o,2)!=n)throw"checking tag doesn't match: "+e.substr(o,2)+"!="+n;return i.getTLV(e,o)},J.getVbyList=function(e,t,r,n,i){var o,s,a=J;if(void 0===(o=a.getIdxbyList(e,t,r,n)))throw"can't find nthList object";return s=a.getV(e,o),!0===i&&(s=s.substr(2)),s},J.hextooidstr=function(e){var t=function h(e,t){return e.length>=t?e:new Array(t-e.length+1).join("0")+e},r=[],n=e.substr(0,2),i=parseInt(n,16);r[0]=new String(Math.floor(i/40)),r[1]=new String(i%40);for(var o=e.substr(2),s=[],a=0;a<o.length/2;a++)s.push(parseInt(o.substr(2*a,2),16));var u=[],c="";for(a=0;a<s.length;a++)128&s[a]?c+=t((127&s[a]).toString(2),7):(c+=t((127&s[a]).toString(2),7),u.push(new String(parseInt(c,2))),c="");var h=r.join(".");return u.length>0&&(h=h+"."+u.join(".")),h},J.dump=function(e,t,r,n){var i=J,o=i.getV,s=i.dump,a=i.getChildIdx,u=e;e instanceof V.asn1.ASN1Object&&(u=e.getEncodedHex());var c=function q(e,t){return e.length<=2*t?e:e.substr(0,t)+"..(total "+e.length/2+"bytes).."+e.substr(e.length-t,t)};void 0===t&&(t={ommit_long_octet:32}),void 0===r&&(r=0),void 0===n&&(n="");var h=t.ommit_long_octet;if("01"==u.substr(r,2))return"00"==(l=o(u,r))?n+"BOOLEAN FALSE\n":n+"BOOLEAN TRUE\n";if("02"==u.substr(r,2))return n+"INTEGER "+c(l=o(u,r),h)+"\n";if("03"==u.substr(r,2))return n+"BITSTRING "+c(l=o(u,r),h)+"\n";if("04"==u.substr(r,2)){var l=o(u,r);if(i.isASN1HEX(l)){var f=n+"OCTETSTRING, encapsulates\n";return f+=s(l,t,0,n+"  ")}return n+"OCTETSTRING "+c(l,h)+"\n"}if("05"==u.substr(r,2))return n+"NULL\n";if("06"==u.substr(r,2)){var g=o(u,r),p=V.asn1.ASN1Util.oidHexToInt(g),d=V.asn1.x509.OID.oid2name(p),v=p.replace(/\./g," ");return""!=d?n+"ObjectIdentifier "+d+" ("+v+")\n":n+"ObjectIdentifier ("+v+")\n"}if("0c"==u.substr(r,2))return n+"UTF8String '"+hextoutf8(o(u,r))+"'\n";if("13"==u.substr(r,2))return n+"PrintableString '"+hextoutf8(o(u,r))+"'\n";if("14"==u.substr(r,2))return n+"TeletexString '"+hextoutf8(o(u,r))+"'\n";if("16"==u.substr(r,2))return n+"IA5String '"+hextoutf8(o(u,r))+"'\n";if("17"==u.substr(r,2))return n+"UTCTime "+hextoutf8(o(u,r))+"\n";if("18"==u.substr(r,2))return n+"GeneralizedTime "+hextoutf8(o(u,r))+"\n";if("30"==u.substr(r,2)){if("3000"==u.substr(r,4))return n+"SEQUENCE {}\n";f=n+"SEQUENCE\n";var y=t;if((2==(S=a(u,r)).length||3==S.length)&&"06"==u.substr(S[0],2)&&"04"==u.substr(S[S.length-1],2)){d=i.oidname(o(u,S[0]));var m=JSON.parse(JSON.stringify(t));m.x509ExtName=d,y=m}for(var _=0;_<S.length;_++)f+=s(u,y,S[_],n+"  ");return f}if("31"==u.substr(r,2)){f=n+"SET\n";var S=a(u,r);for(_=0;_<S.length;_++)f+=s(u,t,S[_],n+"  ");return f}var b=parseInt(u.substr(r,2),16);if(0!=(128&b)){var F=31&b;if(0!=(32&b)){var f=n+"["+F+"]\n";for(S=a(u,r),_=0;_<S.length;_++)f+=s(u,t,S[_],n+"  ");return f}return"68747470"==(l=o(u,r)).substr(0,8)&&(l=hextoutf8(l)),"subjectAltName"===t.x509ExtName&&2==F&&(l=hextoutf8(l)),f=n+"["+F+"] "+l+"\n"}return n+"UNKNOWN("+u.substr(r,2)+") "+o(u,r)+"\n"},J.isASN1HEX=function(e){var t=J;if(e.length%2==1)return!1;var r=t.getVblen(e,0),n=e.substr(0,2),i=t.getL(e,0);return e.length-n.length-i.length==2*r},J.oidname=function(e){var t=V.asn1;V.lang.String.isHex(e)&&(e=t.ASN1Util.oidHexToInt(e));var r=t.x509.OID.oid2name(e);return""===r&&(r=e),r},void 0!==V&&V||(t.KJUR=V={}),void 0!==V.lang&&V.lang||(V.lang={}),V.lang.String=function(){},"function"==typeof n?(t.utf8tob64u=q=function utf8tob64u(e){return b64tob64u(new n(e,"utf8").toString("base64"))},t.b64utoutf8=W=function b64utoutf8(e){return new n(b64utob64(e),"base64").toString("utf8")}):(t.utf8tob64u=q=function utf8tob64u(e){return hextob64u(uricmptohex(encodeURIComponentAll(e)))},t.b64utoutf8=W=function b64utoutf8(e){return decodeURIComponent(hextouricmp(b64utohex(e)))}),V.lang.String.isInteger=function(e){return!!e.match(/^[0-9]+$/)||!!e.match(/^-[0-9]+$/)},V.lang.String.isHex=function(e){return!(e.length%2!=0||!e.match(/^[0-9a-f]+$/)&&!e.match(/^[0-9A-F]+$/))},V.lang.String.isBase64=function(e){return!(!(e=e.replace(/\s+/g,"")).match(/^[0-9A-Za-z+\/]+={0,3}$/)||e.length%4!=0)},V.lang.String.isBase64URL=function(e){return!e.match(/[+/=]/)&&(e=b64utob64(e),V.lang.String.isBase64(e))},V.lang.String.isIntegerArray=function(e){return!!(e=e.replace(/\s+/g,"")).match(/^\[[0-9,]+\]$/)};void 0!==V&&V||(t.KJUR=V={}),void 0!==V.crypto&&V.crypto||(V.crypto={}),V.crypto.Util=new function(){this.DIGESTINFOHEAD={sha1:"3021300906052b0e03021a05000414",sha224:"302d300d06096086480165030402040500041c",sha256:"3031300d060960864801650304020105000420",sha384:"3041300d060960864801650304020205000430",sha512:"3051300d060960864801650304020305000440",md2:"3020300c06082a864886f70d020205000410",md5:"3020300c06082a864886f70d020505000410",ripemd160:"3021300906052b2403020105000414"},this.DEFAULTPROVIDER={md5:"cryptojs",sha1:"cryptojs",sha224:"cryptojs",sha256:"cryptojs",sha384:"cryptojs",sha512:"cryptojs",ripemd160:"cryptojs",hmacmd5:"cryptojs",hmacsha1:"cryptojs",hmacsha224:"cryptojs",hmacsha256:"cryptojs",hmacsha384:"cryptojs",hmacsha512:"cryptojs",hmacripemd160:"cryptojs",MD5withRSA:"cryptojs/jsrsa",SHA1withRSA:"cryptojs/jsrsa",SHA224withRSA:"cryptojs/jsrsa",SHA256withRSA:"cryptojs/jsrsa",SHA384withRSA:"cryptojs/jsrsa",SHA512withRSA:"cryptojs/jsrsa",RIPEMD160withRSA:"cryptojs/jsrsa",MD5withECDSA:"cryptojs/jsrsa",SHA1withECDSA:"cryptojs/jsrsa",SHA224withECDSA:"cryptojs/jsrsa",SHA256withECDSA:"cryptojs/jsrsa",SHA384withECDSA:"cryptojs/jsrsa",SHA512withECDSA:"cryptojs/jsrsa",RIPEMD160withECDSA:"cryptojs/jsrsa",SHA1withDSA:"cryptojs/jsrsa",SHA224withDSA:"cryptojs/jsrsa",SHA256withDSA:"cryptojs/jsrsa",MD5withRSAandMGF1:"cryptojs/jsrsa",SHA1withRSAandMGF1:"cryptojs/jsrsa",SHA224withRSAandMGF1:"cryptojs/jsrsa",SHA256withRSAandMGF1:"cryptojs/jsrsa",SHA384withRSAandMGF1:"cryptojs/jsrsa",SHA512withRSAandMGF1:"cryptojs/jsrsa",RIPEMD160withRSAandMGF1:"cryptojs/jsrsa"},this.CRYPTOJSMESSAGEDIGESTNAME={md5:y.algo.MD5,sha1:y.algo.SHA1,sha224:y.algo.SHA224,sha256:y.algo.SHA256,sha384:y.algo.SHA384,sha512:y.algo.SHA512,ripemd160:y.algo.RIPEMD160},this.getDigestInfoHex=function(e,t){if(void 0===this.DIGESTINFOHEAD[t])throw"alg not supported in Util.DIGESTINFOHEAD: "+t;return this.DIGESTINFOHEAD[t]+e},this.getPaddedDigestInfoHex=function(e,t,r){var n=this.getDigestInfoHex(e,t),i=r/4;if(n.length+22>i)throw"key is too short for SigAlg: keylen="+r+","+t;for(var o="0001",s="00"+n,a="",u=i-o.length-s.length,c=0;c<u;c+=2)a+="ff";return o+a+s},this.hashString=function(e,t){return new V.crypto.MessageDigest({alg:t}).digestString(e)},this.hashHex=function(e,t){return new V.crypto.MessageDigest({alg:t}).digestHex(e)},this.sha1=function(e){return new V.crypto.MessageDigest({alg:"sha1",prov:"cryptojs"}).digestString(e)},this.sha256=function(e){return new V.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"}).digestString(e)},this.sha256Hex=function(e){return new V.crypto.MessageDigest({alg:"sha256",prov:"cryptojs"}).digestHex(e)},this.sha512=function(e){return new V.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"}).digestString(e)},this.sha512Hex=function(e){return new V.crypto.MessageDigest({alg:"sha512",prov:"cryptojs"}).digestHex(e)}},V.crypto.Util.md5=function(e){return new V.crypto.MessageDigest({alg:"md5",prov:"cryptojs"}).digestString(e)},V.crypto.Util.ripemd160=function(e){return new V.crypto.MessageDigest({alg:"ripemd160",prov:"cryptojs"}).digestString(e)},V.crypto.Util.SECURERANDOMGEN=new SecureRandom,V.crypto.Util.getRandomHexOfNbytes=function(e){var t=new Array(e);return V.crypto.Util.SECURERANDOMGEN.nextBytes(t),BAtohex(t)},V.crypto.Util.getRandomBigIntegerOfNbytes=function(e){return new BigInteger(V.crypto.Util.getRandomHexOfNbytes(e),16)},V.crypto.Util.getRandomHexOfNbits=function(e){var t=e%8,r=new Array((e-t)/8+1);return V.crypto.Util.SECURERANDOMGEN.nextBytes(r),r[0]=(255<<t&255^255)&r[0],BAtohex(r)},V.crypto.Util.getRandomBigIntegerOfNbits=function(e){return new BigInteger(V.crypto.Util.getRandomHexOfNbits(e),16)},V.crypto.Util.getRandomBigIntegerZeroToMax=function(e){for(var t=e.bitLength();;){var r=V.crypto.Util.getRandomBigIntegerOfNbits(t);if(-1!=e.compareTo(r))return r}},V.crypto.Util.getRandomBigIntegerMinToMax=function(e,t){var r=e.compareTo(t);if(1==r)throw"biMin is greater than biMax";if(0==r)return e;var n=t.subtract(e);return V.crypto.Util.getRandomBigIntegerZeroToMax(n).add(e)},V.crypto.MessageDigest=function(e){this.setAlgAndProvider=function(e,t){if(null!==(e=V.crypto.MessageDigest.getCanonicalAlgName(e))&&void 0===t&&(t=V.crypto.Util.DEFAULTPROVIDER[e]),-1!=":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(e)&&"cryptojs"==t){try{this.md=V.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[e].create()}catch(t){throw"setAlgAndProvider hash alg set fail alg="+e+"/"+t}this.updateString=function(e){this.md.update(e)},this.updateHex=function(e){var t=y.enc.Hex.parse(e);this.md.update(t)},this.digest=function(){return this.md.finalize().toString(y.enc.Hex)},this.digestString=function(e){return this.updateString(e),this.digest()},this.digestHex=function(e){return this.updateHex(e),this.digest()}}if(-1!=":sha256:".indexOf(e)&&"sjcl"==t){try{this.md=new sjcl.hash.sha256}catch(t){throw"setAlgAndProvider hash alg set fail alg="+e+"/"+t}this.updateString=function(e){this.md.update(e)},this.updateHex=function(e){var t=sjcl.codec.hex.toBits(e);this.md.update(t)},this.digest=function(){var e=this.md.finalize();return sjcl.codec.hex.fromBits(e)},this.digestString=function(e){return this.updateString(e),this.digest()},this.digestHex=function(e){return this.updateHex(e),this.digest()}}},this.updateString=function(e){throw"updateString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName},this.updateHex=function(e){throw"updateHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName},this.digest=function(){throw"digest() not supported for this alg/prov: "+this.algName+"/"+this.provName},this.digestString=function(e){throw"digestString(str) not supported for this alg/prov: "+this.algName+"/"+this.provName},this.digestHex=function(e){throw"digestHex(hex) not supported for this alg/prov: "+this.algName+"/"+this.provName},void 0!==e&&void 0!==e.alg&&(this.algName=e.alg,void 0===e.prov&&(this.provName=V.crypto.Util.DEFAULTPROVIDER[this.algName]),this.setAlgAndProvider(this.algName,this.provName))},V.crypto.MessageDigest.getCanonicalAlgName=function(e){return"string"==typeof e&&(e=(e=e.toLowerCase()).replace(/-/,"")),e},V.crypto.MessageDigest.getHashLength=function(e){var t=V.crypto.MessageDigest,r=t.getCanonicalAlgName(e);if(void 0===t.HASHLENGTH[r])throw"not supported algorithm: "+e;return t.HASHLENGTH[r]},V.crypto.MessageDigest.HASHLENGTH={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,ripemd160:20},V.crypto.Mac=function(e){this.setAlgAndProvider=function(e,t){if(null==(e=e.toLowerCase())&&(e="hmacsha1"),"hmac"!=(e=e.toLowerCase()).substr(0,4))throw"setAlgAndProvider unsupported HMAC alg: "+e;void 0===t&&(t=V.crypto.Util.DEFAULTPROVIDER[e]),this.algProv=e+"/"+t;var r=e.substr(4);if(-1!=":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(r)&&"cryptojs"==t){try{var n=V.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[r];this.mac=y.algo.HMAC.create(n,this.pass)}catch(e){throw"setAlgAndProvider hash alg set fail hashAlg="+r+"/"+e}this.updateString=function(e){this.mac.update(e)},this.updateHex=function(e){var t=y.enc.Hex.parse(e);this.mac.update(t)},this.doFinal=function(){return this.mac.finalize().toString(y.enc.Hex)},this.doFinalString=function(e){return this.updateString(e),this.doFinal()},this.doFinalHex=function(e){return this.updateHex(e),this.doFinal()}}},this.updateString=function(e){throw"updateString(str) not supported for this alg/prov: "+this.algProv},this.updateHex=function(e){throw"updateHex(hex) not supported for this alg/prov: "+this.algProv},this.doFinal=function(){throw"digest() not supported for this alg/prov: "+this.algProv},this.doFinalString=function(e){throw"digestString(str) not supported for this alg/prov: "+this.algProv},this.doFinalHex=function(e){throw"digestHex(hex) not supported for this alg/prov: "+this.algProv},this.setPassword=function(e){if("string"==typeof e){var t=e;return e.length%2!=1&&e.match(/^[0-9A-Fa-f]+$/)||(t=rstrtohex(e)),void(this.pass=y.enc.Hex.parse(t))}if("object"!=(void 0===e?"undefined":i(e)))throw"KJUR.crypto.Mac unsupported password type: "+e;t=null;if(void 0!==e.hex){if(e.hex.length%2!=0||!e.hex.match(/^[0-9A-Fa-f]+$/))throw"Mac: wrong hex password: "+e.hex;t=e.hex}if(void 0!==e.utf8&&(t=utf8tohex(e.utf8)),void 0!==e.rstr&&(t=rstrtohex(e.rstr)),void 0!==e.b64&&(t=b64tohex(e.b64)),void 0!==e.b64u&&(t=b64utohex(e.b64u)),null==t)throw"KJUR.crypto.Mac unsupported password type: "+e;this.pass=y.enc.Hex.parse(t)},void 0!==e&&(void 0!==e.pass&&this.setPassword(e.pass),void 0!==e.alg&&(this.algName=e.alg,void 0===e.prov&&(this.provName=V.crypto.Util.DEFAULTPROVIDER[this.algName]),this.setAlgAndProvider(this.algName,this.provName)))},V.crypto.Signature=function(e){var t=null;if(this._setAlgNames=function(){var e=this.algName.match(/^(.+)with(.+)$/);e&&(this.mdAlgName=e[1].toLowerCase(),this.pubkeyAlgName=e[2].toLowerCase())},this._zeroPaddingOfSignature=function(e,t){for(var r="",n=t/4-e.length,i=0;i<n;i++)r+="0";return r+e},this.setAlgAndProvider=function(e,t){if(this._setAlgNames(),"cryptojs/jsrsa"!=t)throw"provider not supported: "+t;if(-1!=":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:".indexOf(this.mdAlgName)){try{this.md=new V.crypto.MessageDigest({alg:this.mdAlgName})}catch(e){throw"setAlgAndProvider hash alg set fail alg="+this.mdAlgName+"/"+e}this.init=function(e,t){var r=null;try{r=void 0===t?z.getKey(e):z.getKey(e,t)}catch(e){throw"init failed:"+e}if(!0===r.isPrivate)this.prvKey=r,this.state="SIGN";else{if(!0!==r.isPublic)throw"init failed.:"+r;this.pubKey=r,this.state="VERIFY"}},this.updateString=function(e){this.md.updateString(e)},this.updateHex=function(e){this.md.updateHex(e)},this.sign=function(){if(this.sHashHex=this.md.digest(),void 0!==this.ecprvhex&&void 0!==this.eccurvename){var e=new V.crypto.ECDSA({curve:this.eccurvename});this.hSign=e.signHex(this.sHashHex,this.ecprvhex)}else if(this.prvKey instanceof RSAKey&&"rsaandmgf1"===this.pubkeyAlgName)this.hSign=this.prvKey.signWithMessageHashPSS(this.sHashHex,this.mdAlgName,this.pssSaltLen);else if(this.prvKey instanceof RSAKey&&"rsa"===this.pubkeyAlgName)this.hSign=this.prvKey.signWithMessageHash(this.sHashHex,this.mdAlgName);else if(this.prvKey instanceof V.crypto.ECDSA)this.hSign=this.prvKey.signWithMessageHash(this.sHashHex);else{if(!(this.prvKey instanceof V.crypto.DSA))throw"Signature: unsupported private key alg: "+this.pubkeyAlgName;this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}return this.hSign},this.signString=function(e){return this.updateString(e),this.sign()},this.signHex=function(e){return this.updateHex(e),this.sign()},this.verify=function(e){if(this.sHashHex=this.md.digest(),void 0!==this.ecpubhex&&void 0!==this.eccurvename)return new V.crypto.ECDSA({curve:this.eccurvename}).verifyHex(this.sHashHex,e,this.ecpubhex);if(this.pubKey instanceof RSAKey&&"rsaandmgf1"===this.pubkeyAlgName)return this.pubKey.verifyWithMessageHashPSS(this.sHashHex,e,this.mdAlgName,this.pssSaltLen);if(this.pubKey instanceof RSAKey&&"rsa"===this.pubkeyAlgName)return this.pubKey.verifyWithMessageHash(this.sHashHex,e);if(void 0!==V.crypto.ECDSA&&this.pubKey instanceof V.crypto.ECDSA)return this.pubKey.verifyWithMessageHash(this.sHashHex,e);if(void 0!==V.crypto.DSA&&this.pubKey instanceof V.crypto.DSA)return this.pubKey.verifyWithMessageHash(this.sHashHex,e);throw"Signature: unsupported public key alg: "+this.pubkeyAlgName}}},this.init=function(e,t){throw"init(key, pass) not supported for this alg:prov="+this.algProvName},this.updateString=function(e){throw"updateString(str) not supported for this alg:prov="+this.algProvName},this.updateHex=function(e){throw"updateHex(hex) not supported for this alg:prov="+this.algProvName},this.sign=function(){throw"sign() not supported for this alg:prov="+this.algProvName},this.signString=function(e){throw"digestString(str) not supported for this alg:prov="+this.algProvName},this.signHex=function(e){throw"digestHex(hex) not supported for this alg:prov="+this.algProvName},this.verify=function(e){throw"verify(hSigVal) not supported for this alg:prov="+this.algProvName},this.initParams=e,void 0!==e&&(void 0!==e.alg&&(this.algName=e.alg,void 0===e.prov?this.provName=V.crypto.Util.DEFAULTPROVIDER[this.algName]:this.provName=e.prov,this.algProvName=this.algName+":"+this.provName,this.setAlgAndProvider(this.algName,this.provName),this._setAlgNames()),void 0!==e.psssaltlen&&(this.pssSaltLen=e.psssaltlen),void 0!==e.prvkeypem)){if(void 0!==e.prvkeypas)throw"both prvkeypem and prvkeypas parameters not supported";try{t=z.getKey(e.prvkeypem);this.init(t)}catch(e){throw"fatal error to load pem private key: "+e}}},V.crypto.Cipher=function(e){},V.crypto.Cipher.encrypt=function(e,t,r){if(t instanceof RSAKey&&t.isPublic){var n=V.crypto.Cipher.getAlgByKeyAndName(t,r);if("RSA"===n)return t.encrypt(e);if("RSAOAEP"===n)return t.encryptOAEP(e,"sha1");var i=n.match(/^RSAOAEP(\d+)$/);if(null!==i)return t.encryptOAEP(e,"sha"+i[1]);throw"Cipher.encrypt: unsupported algorithm for RSAKey: "+r}throw"Cipher.encrypt: unsupported key or algorithm"},V.crypto.Cipher.decrypt=function(e,t,r){if(t instanceof RSAKey&&t.isPrivate){var n=V.crypto.Cipher.getAlgByKeyAndName(t,r);if("RSA"===n)return t.decrypt(e);if("RSAOAEP"===n)return t.decryptOAEP(e,"sha1");var i=n.match(/^RSAOAEP(\d+)$/);if(null!==i)return t.decryptOAEP(e,"sha"+i[1]);throw"Cipher.decrypt: unsupported algorithm for RSAKey: "+r}throw"Cipher.decrypt: unsupported key or algorithm"},V.crypto.Cipher.getAlgByKeyAndName=function(e,t){if(e instanceof RSAKey){if(-1!=":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:".indexOf(t))return t;if(null===t||void 0===t)return"RSA";throw"getAlgByKeyAndName: not supported algorithm name for RSAKey: "+t}throw"getAlgByKeyAndName: not supported algorithm name: "+t},V.crypto.OID=new function(){this.oidhex2name={"2a864886f70d010101":"rsaEncryption","2a8648ce3d0201":"ecPublicKey","2a8648ce380401":"dsa","2a8648ce3d030107":"secp256r1","2b8104001f":"secp192k1","2b81040021":"secp224r1","2b8104000a":"secp256k1","2b81040023":"secp521r1","2b81040022":"secp384r1","2a8648ce380403":"SHA1withDSA","608648016503040301":"SHA224withDSA","608648016503040302":"SHA256withDSA"}},void 0!==V&&V||(t.KJUR=V={}),void 0!==V.crypto&&V.crypto||(V.crypto={}),V.crypto.ECDSA=function(e){var t=new SecureRandom;this.type="EC",this.isPrivate=!1,this.isPublic=!1,this.getBigRandom=function(e){return new BigInteger(e.bitLength(),t).mod(e.subtract(BigInteger.ONE)).add(BigInteger.ONE)},this.setNamedCurve=function(e){this.ecparams=V.crypto.ECParameterDB.getByName(e),this.prvKeyHex=null,this.pubKeyHex=null,this.curveName=e},this.setPrivateKeyHex=function(e){this.isPrivate=!0,this.prvKeyHex=e},this.setPublicKeyHex=function(e){this.isPublic=!0,this.pubKeyHex=e},this.getPublicKeyXYHex=function(){var e=this.pubKeyHex;if("04"!==e.substr(0,2))throw"this method supports uncompressed format(04) only";var t=this.ecparams.keylen/4;if(e.length!==2+2*t)throw"malformed public key hex length";var r={};return r.x=e.substr(2,t),r.y=e.substr(2+t),r},this.getShortNISTPCurveName=function(){var e=this.curveName;return"secp256r1"===e||"NIST P-256"===e||"P-256"===e||"prime256v1"===e?"P-256":"secp384r1"===e||"NIST P-384"===e||"P-384"===e?"P-384":null},this.generateKeyPairHex=function(){var e=this.ecparams.n,t=this.getBigRandom(e),r=this.ecparams.G.multiply(t),n=r.getX().toBigInteger(),i=r.getY().toBigInteger(),o=this.ecparams.keylen/4,s=("0000000000"+t.toString(16)).slice(-o),a="04"+("0000000000"+n.toString(16)).slice(-o)+("0000000000"+i.toString(16)).slice(-o);return this.setPrivateKeyHex(s),this.setPublicKeyHex(a),{ecprvhex:s,ecpubhex:a}},this.signWithMessageHash=function(e){return this.signHex(e,this.prvKeyHex)},this.signHex=function(e,t){var r=new BigInteger(t,16),n=this.ecparams.n,i=new BigInteger(e,16);do{var o=this.getBigRandom(n),s=this.ecparams.G.multiply(o).getX().toBigInteger().mod(n)}while(s.compareTo(BigInteger.ZERO)<=0);var a=o.modInverse(n).multiply(i.add(r.multiply(s))).mod(n);return V.crypto.ECDSA.biRSSigToASN1Sig(s,a)},this.sign=function(e,t){var r=t,n=this.ecparams.n,i=BigInteger.fromByteArrayUnsigned(e);do{var o=this.getBigRandom(n),s=this.ecparams.G.multiply(o).getX().toBigInteger().mod(n)}while(s.compareTo(BigInteger.ZERO)<=0);var a=o.modInverse(n).multiply(i.add(r.multiply(s))).mod(n);return this.serializeSig(s,a)},this.verifyWithMessageHash=function(e,t){return this.verifyHex(e,t,this.pubKeyHex)},this.verifyHex=function(e,t,r){var n,i,o,s=V.crypto.ECDSA.parseSigHex(t);n=s.r,i=s.s,o=ECPointFp.decodeFromHex(this.ecparams.curve,r);var a=new BigInteger(e,16);return this.verifyRaw(a,n,i,o)},this.verify=function(e,t,r){var n,o,s;if(Bitcoin.Util.isArray(t)){var a=this.parseSig(t);n=a.r,o=a.s}else{if("object"!==(void 0===t?"undefined":i(t))||!t.r||!t.s)throw"Invalid value for signature";n=t.r,o=t.s}if(r instanceof ECPointFp)s=r;else{if(!Bitcoin.Util.isArray(r))throw"Invalid format for pubkey value, must be byte array or ECPointFp";s=ECPointFp.decodeFrom(this.ecparams.curve,r)}var u=BigInteger.fromByteArrayUnsigned(e);return this.verifyRaw(u,n,o,s)},this.verifyRaw=function(e,t,r,n){var i=this.ecparams.n,o=this.ecparams.G;if(t.compareTo(BigInteger.ONE)<0||t.compareTo(i)>=0)return!1;if(r.compareTo(BigInteger.ONE)<0||r.compareTo(i)>=0)return!1;var s=r.modInverse(i),a=e.multiply(s).mod(i),u=t.multiply(s).mod(i);return o.multiply(a).add(n.multiply(u)).getX().toBigInteger().mod(i).equals(t)},this.serializeSig=function(e,t){var r=e.toByteArraySigned(),n=t.toByteArraySigned(),i=[];return i.push(2),i.push(r.length),(i=i.concat(r)).push(2),i.push(n.length),(i=i.concat(n)).unshift(i.length),i.unshift(48),i},this.parseSig=function(e){var t;if(48!=e[0])throw new Error("Signature not a valid DERSequence");if(2!=e[t=2])throw new Error("First element in signature must be a DERInteger");var r=e.slice(t+2,t+2+e[t+1]);if(2!=e[t+=2+e[t+1]])throw new Error("Second element in signature must be a DERInteger");var n=e.slice(t+2,t+2+e[t+1]);return t+=2+e[t+1],{r:BigInteger.fromByteArrayUnsigned(r),s:BigInteger.fromByteArrayUnsigned(n)}},this.parseSigCompact=function(e){if(65!==e.length)throw"Signature has the wrong length";var t=e[0]-27;if(t<0||t>7)throw"Invalid signature type";var r=this.ecparams.n;return{r:BigInteger.fromByteArrayUnsigned(e.slice(1,33)).mod(r),s:BigInteger.fromByteArrayUnsigned(e.slice(33,65)).mod(r),i:t}},this.readPKCS5PrvKeyHex=function(e){var t,r,n,i=J,o=V.crypto.ECDSA.getName,s=i.getVbyList;if(!1===i.isASN1HEX(e))throw"not ASN.1 hex string";try{t=s(e,0,[2,0],"06"),r=s(e,0,[1],"04");try{n=s(e,0,[3,0],"03").substr(2)}catch(e){}}catch(e){throw"malformed PKCS#1/5 plain ECC private key"}if(this.curveName=o(t),void 0===this.curveName)throw"unsupported curve name";this.setNamedCurve(this.curveName),this.setPublicKeyHex(n),this.setPrivateKeyHex(r),this.isPublic=!1},this.readPKCS8PrvKeyHex=function(e){var t,r,n,i=J,o=V.crypto.ECDSA.getName,s=i.getVbyList;if(!1===i.isASN1HEX(e))throw"not ASN.1 hex string";try{s(e,0,[1,0],"06"),t=s(e,0,[1,1],"06"),r=s(e,0,[2,0,1],"04");try{n=s(e,0,[2,0,2,0],"03").substr(2)}catch(e){}}catch(e){throw"malformed PKCS#8 plain ECC private key"}if(this.curveName=o(t),void 0===this.curveName)throw"unsupported curve name";this.setNamedCurve(this.curveName),this.setPublicKeyHex(n),this.setPrivateKeyHex(r),this.isPublic=!1},this.readPKCS8PubKeyHex=function(e){var t,r,n=J,i=V.crypto.ECDSA.getName,o=n.getVbyList;if(!1===n.isASN1HEX(e))throw"not ASN.1 hex string";try{o(e,0,[0,0],"06"),t=o(e,0,[0,1],"06"),r=o(e,0,[1],"03").substr(2)}catch(e){throw"malformed PKCS#8 ECC public key"}if(this.curveName=i(t),null===this.curveName)throw"unsupported curve name";this.setNamedCurve(this.curveName),this.setPublicKeyHex(r)},this.readCertPubKeyHex=function(e,t){5!==t&&(t=6);var r,n,i=J,o=V.crypto.ECDSA.getName,s=i.getVbyList;if(!1===i.isASN1HEX(e))throw"not ASN.1 hex string";try{r=s(e,0,[0,t,0,1],"06"),n=s(e,0,[0,t,1],"03").substr(2)}catch(e){throw"malformed X.509 certificate ECC public key"}if(this.curveName=o(r),null===this.curveName)throw"unsupported curve name";this.setNamedCurve(this.curveName),this.setPublicKeyHex(n)},void 0!==e&&void 0!==e.curve&&(this.curveName=e.curve),void 0===this.curveName&&(this.curveName="secp256r1"),this.setNamedCurve(this.curveName),void 0!==e&&(void 0!==e.prv&&this.setPrivateKeyHex(e.prv),void 0!==e.pub&&this.setPublicKeyHex(e.pub))},V.crypto.ECDSA.parseSigHex=function(e){var t=V.crypto.ECDSA.parseSigHexInHexRS(e);return{r:new BigInteger(t.r,16),s:new BigInteger(t.s,16)}},V.crypto.ECDSA.parseSigHexInHexRS=function(e){var t=J,r=t.getChildIdx,n=t.getV;if("30"!=e.substr(0,2))throw"signature is not a ASN.1 sequence";var i=r(e,0);if(2!=i.length)throw"number of signature ASN.1 sequence elements seem wrong";var o=i[0],s=i[1];if("02"!=e.substr(o,2))throw"1st item of sequene of signature is not ASN.1 integer";if("02"!=e.substr(s,2))throw"2nd item of sequene of signature is not ASN.1 integer";return{r:n(e,o),s:n(e,s)}},V.crypto.ECDSA.asn1SigToConcatSig=function(e){var t=V.crypto.ECDSA.parseSigHexInHexRS(e),r=t.r,n=t.s;if("00"==r.substr(0,2)&&r.length%32==2&&(r=r.substr(2)),"00"==n.substr(0,2)&&n.length%32==2&&(n=n.substr(2)),r.length%32==30&&(r="00"+r),n.length%32==30&&(n="00"+n),r.length%32!=0)throw"unknown ECDSA sig r length error";if(n.length%32!=0)throw"unknown ECDSA sig s length error";return r+n},V.crypto.ECDSA.concatSigToASN1Sig=function(e){if(e.length/2*8%128!=0)throw"unknown ECDSA concatinated r-s sig  length error";var t=e.substr(0,e.length/2),r=e.substr(e.length/2);return V.crypto.ECDSA.hexRSSigToASN1Sig(t,r)},V.crypto.ECDSA.hexRSSigToASN1Sig=function(e,t){var r=new BigInteger(e,16),n=new BigInteger(t,16);return V.crypto.ECDSA.biRSSigToASN1Sig(r,n)},V.crypto.ECDSA.biRSSigToASN1Sig=function(e,t){var r=V.asn1,n=new r.DERInteger({bigint:e}),i=new r.DERInteger({bigint:t});return new r.DERSequence({array:[n,i]}).getEncodedHex()},V.crypto.ECDSA.getName=function(e){return"2a8648ce3d030107"===e?"secp256r1":"2b8104000a"===e?"secp256k1":"2b81040022"===e?"secp384r1":-1!=="|secp256r1|NIST P-256|P-256|prime256v1|".indexOf(e)?"secp256r1":-1!=="|secp256k1|".indexOf(e)?"secp256k1":-1!=="|secp384r1|NIST P-384|P-384|".indexOf(e)?"secp384r1":null},void 0!==V&&V||(t.KJUR=V={}),void 0!==V.crypto&&V.crypto||(V.crypto={}),V.crypto.ECParameterDB=new function(){var e={},t={};function a(e){return new BigInteger(e,16)}this.getByName=function(r){var n=r;if(void 0!==t[n]&&(n=t[r]),void 0!==e[n])return e[n];throw"unregistered EC curve name: "+n},this.regist=function(r,n,i,o,s,u,c,h,l,f,g,p){e[r]={};var d=a(i),v=a(o),y=a(s),m=a(u),_=a(c),S=new ECCurveFp(d,v,y),b=S.decodePointHex("04"+h+l);e[r].name=r,e[r].keylen=n,e[r].curve=S,e[r].G=b,e[r].n=m,e[r].h=_,e[r].oid=g,e[r].info=p;for(var F=0;F<f.length;F++)t[f[F]]=r}},V.crypto.ECParameterDB.regist("secp128r1",128,"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC","E87579C11079F43DD824993C2CEE5ED3","FFFFFFFE0000000075A30D1B9038A115","1","161FF7528B899B2D0C28607CA52C5B86","CF5AC8395BAFEB13C02DA292DDED7A83",[],"","secp128r1 : SECG curve over a 128 bit prime field"),V.crypto.ECParameterDB.regist("secp160k1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73","0","7","0100000000000000000001B8FA16DFAB9ACA16B6B3","1","3B4C382CE37AA192A4019E763036F4F5DD4D7EBB","938CF935318FDCED6BC28286531733C3F03C4FEE",[],"","secp160k1 : SECG curve over a 160 bit prime field"),V.crypto.ECParameterDB.regist("secp160r1",160,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC","1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45","0100000000000000000001F4C8F927AED3CA752257","1","4A96B5688EF573284664698968C38BB913CBFC82","23A628553168947D59DCC912042351377AC5FB32",[],"","secp160r1 : SECG curve over a 160 bit prime field"),V.crypto.ECParameterDB.regist("secp192k1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37","0","3","FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D","1","DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D","9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D",[]),V.crypto.ECParameterDB.regist("secp192r1",192,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC","64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1","FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831","1","188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012","07192B95FFC8DA78631011ED6B24CDD573F977A11E794811",[]),V.crypto.ECParameterDB.regist("secp224r1",224,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE","B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4","FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D","1","B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21","BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34",[]),V.crypto.ECParameterDB.regist("secp256k1",256,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F","0","7","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141","1","79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798","483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8",[]),V.crypto.ECParameterDB.regist("secp256r1",256,"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF","FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC","5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B","FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551","1","6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296","4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5",["NIST P-256","P-256","prime256v1"]),V.crypto.ECParameterDB.regist("secp384r1",384,"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC","B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF","FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973","1","AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7","3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f",["NIST P-384","P-384"]),V.crypto.ECParameterDB.regist("secp521r1",521,"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC","051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00","1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409","1","C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66","011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650",["NIST P-521","P-521"]);var z=function(){var t=function d(e,t,n){return r(y.AES,e,t,n)},r=function k(e,t,r,n){var i=y.enc.Hex.parse(t),o=y.enc.Hex.parse(r),s=y.enc.Hex.parse(n),a={};a.key=o,a.iv=s,a.ciphertext=i;var u=e.decrypt(a,o,{iv:s});return y.enc.Hex.stringify(u)},n=function l(e,t,r){return i(y.AES,e,t,r)},i=function g(e,t,r,n){var i=y.enc.Hex.parse(t),o=y.enc.Hex.parse(r),s=y.enc.Hex.parse(n),a=e.encrypt(i,o,{iv:s}),u=y.enc.Hex.parse(a.toString());return y.enc.Base64.stringify(u)},s={"AES-256-CBC":{proc:t,eproc:n,keylen:32,ivlen:16},"AES-192-CBC":{proc:t,eproc:n,keylen:24,ivlen:16},"AES-128-CBC":{proc:t,eproc:n,keylen:16,ivlen:16},"DES-EDE3-CBC":{proc:function e(t,n,i){return r(y.TripleDES,t,n,i)},eproc:function o(e,t,r){return i(y.TripleDES,e,t,r)},keylen:24,ivlen:8},"DES-CBC":{proc:function a(e,t,n){return r(y.DES,e,t,n)},eproc:function f(e,t,r){return i(y.DES,e,t,r)},keylen:8,ivlen:8}},u=function n(e){var t={},r=e.match(new RegExp("DEK-Info: ([^,]+),([0-9A-Fa-f]+)","m"));r&&(t.cipher=r[1],t.ivsalt=r[2]);var i=e.match(new RegExp("-----BEGIN ([A-Z]+) PRIVATE KEY-----"));i&&(t.type=i[1]);var o=-1,s=0;-1!=e.indexOf("\r\n\r\n")&&(o=e.indexOf("\r\n\r\n"),s=2),-1!=e.indexOf("\n\n")&&(o=e.indexOf("\n\n"),s=1);var a=e.indexOf("-----END");if(-1!=o&&-1!=a){var u=e.substring(o+2*s,a-s);u=u.replace(/\s+/g,""),t.data=u}return t},c=function j(e,t,r){for(var n=r.substring(0,16),i=y.enc.Hex.parse(n),o=y.enc.Utf8.parse(t),a=s[e].keylen+s[e].ivlen,u="",c=null;;){var h=y.algo.MD5.create();if(null!=c&&h.update(c),h.update(o),h.update(i),c=h.finalize(),(u+=y.enc.Hex.stringify(c)).length>=2*a)break}var l={};return l.keyhex=u.substr(0,2*s[e].keylen),l.ivhex=u.substr(2*s[e].keylen,2*s[e].ivlen),l},g=function b(e,t,r,n){var i=y.enc.Base64.parse(e),o=y.enc.Hex.stringify(i);return(0,s[t].proc)(o,r,n)};return{version:"1.0.0",parsePKCS5PEM:function parsePKCS5PEM(e){return u(e)},getKeyAndUnusedIvByPasscodeAndIvsalt:function getKeyAndUnusedIvByPasscodeAndIvsalt(e,t,r){return c(e,t,r)},decryptKeyB64:function decryptKeyB64(e,t,r,n){return g(e,t,r,n)},getDecryptedKeyHex:function getDecryptedKeyHex(e,t){var r=u(e),n=(r.type,r.cipher),i=r.ivsalt,o=r.data,s=c(n,t,i).keyhex;return g(o,n,s,i)},getEncryptedPKCS5PEMFromPrvKeyHex:function getEncryptedPKCS5PEMFromPrvKeyHex(e,t,r,n,i){var o="";if(void 0!==n&&null!=n||(n="AES-256-CBC"),void 0===s[n])throw"KEYUTIL unsupported algorithm: "+n;void 0!==i&&null!=i||(i=function m(e){var t=y.lib.WordArray.random(e);return y.enc.Hex.stringify(t)}(s[n].ivlen).toUpperCase());var a=function h(e,t,r,n){return(0,s[t].eproc)(e,r,n)}(t,n,c(n,r,i).keyhex,i);o="-----BEGIN "+e+" PRIVATE KEY-----\r\n";return o+="Proc-Type: 4,ENCRYPTED\r\n",o+="DEK-Info: "+n+","+i+"\r\n",o+="\r\n",o+=a.replace(/(.{64})/g,"$1\r\n"),o+="\r\n-----END "+e+" PRIVATE KEY-----\r\n"},parseHexOfEncryptedPKCS8:function parseHexOfEncryptedPKCS8(e){var t=J,r=t.getChildIdx,n=t.getV,i={},o=r(e,0);if(2!=o.length)throw"malformed format: SEQUENCE(0).items != 2: "+o.length;i.ciphertext=n(e,o[1]);var s=r(e,o[0]);if(2!=s.length)throw"malformed format: SEQUENCE(0.0).items != 2: "+s.length;if("2a864886f70d01050d"!=n(e,s[0]))throw"this only supports pkcs5PBES2";var a=r(e,s[1]);if(2!=s.length)throw"malformed format: SEQUENCE(0.0.1).items != 2: "+a.length;var u=r(e,a[1]);if(2!=u.length)throw"malformed format: SEQUENCE(0.0.1.1).items != 2: "+u.length;if("2a864886f70d0307"!=n(e,u[0]))throw"this only supports TripleDES";i.encryptionSchemeAlg="TripleDES",i.encryptionSchemeIV=n(e,u[1]);var c=r(e,a[0]);if(2!=c.length)throw"malformed format: SEQUENCE(0.0.1.0).items != 2: "+c.length;if("2a864886f70d01050c"!=n(e,c[0]))throw"this only supports pkcs5PBKDF2";var h=r(e,c[1]);if(h.length<2)throw"malformed format: SEQUENCE(0.0.1.0.1).items < 2: "+h.length;i.pbkdf2Salt=n(e,h[0]);var l=n(e,h[1]);try{i.pbkdf2Iter=parseInt(l,16)}catch(e){throw"malformed format pbkdf2Iter: "+l}return i},getPBKDF2KeyHexFromParam:function getPBKDF2KeyHexFromParam(e,t){var r=y.enc.Hex.parse(e.pbkdf2Salt),n=e.pbkdf2Iter,i=y.PBKDF2(t,r,{keySize:6,iterations:n});return y.enc.Hex.stringify(i)},_getPlainPKCS8HexFromEncryptedPKCS8PEM:function _getPlainPKCS8HexFromEncryptedPKCS8PEM(e,t){var r=pemtohex(e,"ENCRYPTED PRIVATE KEY"),n=this.parseHexOfEncryptedPKCS8(r),i=z.getPBKDF2KeyHexFromParam(n,t),o={};o.ciphertext=y.enc.Hex.parse(n.ciphertext);var s=y.enc.Hex.parse(i),a=y.enc.Hex.parse(n.encryptionSchemeIV),u=y.TripleDES.decrypt(o,s,{iv:a});return y.enc.Hex.stringify(u)},getKeyFromEncryptedPKCS8PEM:function getKeyFromEncryptedPKCS8PEM(e,t){var r=this._getPlainPKCS8HexFromEncryptedPKCS8PEM(e,t);return this.getKeyFromPlainPrivatePKCS8Hex(r)},parsePlainPrivatePKCS8Hex:function parsePlainPrivatePKCS8Hex(e){var t=J,r=t.getChildIdx,n=t.getV,i={algparam:null};if("30"!=e.substr(0,2))throw"malformed plain PKCS8 private key(code:001)";var o=r(e,0);if(3!=o.length)throw"malformed plain PKCS8 private key(code:002)";if("30"!=e.substr(o[1],2))throw"malformed PKCS8 private key(code:003)";var s=r(e,o[1]);if(2!=s.length)throw"malformed PKCS8 private key(code:004)";if("06"!=e.substr(s[0],2))throw"malformed PKCS8 private key(code:005)";if(i.algoid=n(e,s[0]),"06"==e.substr(s[1],2)&&(i.algparam=n(e,s[1])),"04"!=e.substr(o[2],2))throw"malformed PKCS8 private key(code:006)";return i.keyidx=t.getVidx(e,o[2]),i},getKeyFromPlainPrivatePKCS8PEM:function getKeyFromPlainPrivatePKCS8PEM(e){var t=pemtohex(e,"PRIVATE KEY");return this.getKeyFromPlainPrivatePKCS8Hex(t)},getKeyFromPlainPrivatePKCS8Hex:function getKeyFromPlainPrivatePKCS8Hex(e){var t,r=this.parsePlainPrivatePKCS8Hex(e);if("2a864886f70d010101"==r.algoid)t=new RSAKey;else if("2a8648ce380401"==r.algoid)t=new V.crypto.DSA;else{if("2a8648ce3d0201"!=r.algoid)throw"unsupported private key algorithm";t=new V.crypto.ECDSA}return t.readPKCS8PrvKeyHex(e),t},_getKeyFromPublicPKCS8Hex:function _getKeyFromPublicPKCS8Hex(e){var t,r=J.getVbyList(e,0,[0,0],"06");if("2a864886f70d010101"===r)t=new RSAKey;else if("2a8648ce380401"===r)t=new V.crypto.DSA;else{if("2a8648ce3d0201"!==r)throw"unsupported PKCS#8 public key hex";t=new V.crypto.ECDSA}return t.readPKCS8PubKeyHex(e),t},parsePublicRawRSAKeyHex:function parsePublicRawRSAKeyHex(e){var t=J,r=t.getChildIdx,n=t.getV,i={};if("30"!=e.substr(0,2))throw"malformed RSA key(code:001)";var o=r(e,0);if(2!=o.length)throw"malformed RSA key(code:002)";if("02"!=e.substr(o[0],2))throw"malformed RSA key(code:003)";if(i.n=n(e,o[0]),"02"!=e.substr(o[1],2))throw"malformed RSA key(code:004)";return i.e=n(e,o[1]),i},parsePublicPKCS8Hex:function parsePublicPKCS8Hex(e){var t=J,r=t.getChildIdx,n=t.getV,i={algparam:null},o=r(e,0);if(2!=o.length)throw"outer DERSequence shall have 2 elements: "+o.length;var s=o[0];if("30"!=e.substr(s,2))throw"malformed PKCS8 public key(code:001)";var a=r(e,s);if(2!=a.length)throw"malformed PKCS8 public key(code:002)";if("06"!=e.substr(a[0],2))throw"malformed PKCS8 public key(code:003)";if(i.algoid=n(e,a[0]),"06"==e.substr(a[1],2)?i.algparam=n(e,a[1]):"30"==e.substr(a[1],2)&&(i.algparam={},i.algparam.p=t.getVbyList(e,a[1],[0],"02"),i.algparam.q=t.getVbyList(e,a[1],[1],"02"),i.algparam.g=t.getVbyList(e,a[1],[2],"02")),"03"!=e.substr(o[1],2))throw"malformed PKCS8 public key(code:004)";return i.key=n(e,o[1]).substr(2),i}}}();z.getKey=function(e,t,r){var n=(v=J).getChildIdx,i=(v.getV,v.getVbyList),o=V.crypto,s=o.ECDSA,a=o.DSA,u=RSAKey,c=pemtohex,h=z;if(void 0!==u&&e instanceof u)return e;if(void 0!==s&&e instanceof s)return e;if(void 0!==a&&e instanceof a)return e;if(void 0!==e.curve&&void 0!==e.xy&&void 0===e.d)return new s({pub:e.xy,curve:e.curve});if(void 0!==e.curve&&void 0!==e.d)return new s({prv:e.d,curve:e.curve});if(void 0===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0===e.d)return(k=new u).setPublic(e.n,e.e),k;if(void 0===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0!==e.d&&void 0!==e.p&&void 0!==e.q&&void 0!==e.dp&&void 0!==e.dq&&void 0!==e.co&&void 0===e.qi)return(k=new u).setPrivateEx(e.n,e.e,e.d,e.p,e.q,e.dp,e.dq,e.co),k;if(void 0===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0!==e.d&&void 0===e.p)return(k=new u).setPrivate(e.n,e.e,e.d),k;if(void 0!==e.p&&void 0!==e.q&&void 0!==e.g&&void 0!==e.y&&void 0===e.x)return(k=new a).setPublic(e.p,e.q,e.g,e.y),k;if(void 0!==e.p&&void 0!==e.q&&void 0!==e.g&&void 0!==e.y&&void 0!==e.x)return(k=new a).setPrivate(e.p,e.q,e.g,e.y,e.x),k;if("RSA"===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0===e.d)return(k=new u).setPublic(b64utohex(e.n),b64utohex(e.e)),k;if("RSA"===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0!==e.d&&void 0!==e.p&&void 0!==e.q&&void 0!==e.dp&&void 0!==e.dq&&void 0!==e.qi)return(k=new u).setPrivateEx(b64utohex(e.n),b64utohex(e.e),b64utohex(e.d),b64utohex(e.p),b64utohex(e.q),b64utohex(e.dp),b64utohex(e.dq),b64utohex(e.qi)),k;if("RSA"===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0!==e.d)return(k=new u).setPrivate(b64utohex(e.n),b64utohex(e.e),b64utohex(e.d)),k;if("EC"===e.kty&&void 0!==e.crv&&void 0!==e.x&&void 0!==e.y&&void 0===e.d){var l=(C=new s({curve:e.crv})).ecparams.keylen/4,f="04"+("0000000000"+b64utohex(e.x)).slice(-l)+("0000000000"+b64utohex(e.y)).slice(-l);return C.setPublicKeyHex(f),C}if("EC"===e.kty&&void 0!==e.crv&&void 0!==e.x&&void 0!==e.y&&void 0!==e.d){l=(C=new s({curve:e.crv})).ecparams.keylen/4,f="04"+("0000000000"+b64utohex(e.x)).slice(-l)+("0000000000"+b64utohex(e.y)).slice(-l);var g=("0000000000"+b64utohex(e.d)).slice(-l);return C.setPublicKeyHex(f),C.setPrivateKeyHex(g),C}if("pkcs5prv"===r){var p,d=e,v=J;if(9===(p=n(d,0)).length)(k=new u).readPKCS5PrvKeyHex(d);else if(6===p.length)(k=new a).readPKCS5PrvKeyHex(d);else{if(!(p.length>2&&"04"===d.substr(p[1],2)))throw"unsupported PKCS#1/5 hexadecimal key";(k=new s).readPKCS5PrvKeyHex(d)}return k}if("pkcs8prv"===r)return k=h.getKeyFromPlainPrivatePKCS8Hex(e);if("pkcs8pub"===r)return h._getKeyFromPublicPKCS8Hex(e);if("x509pub"===r)return X509.getPublicKeyFromCertHex(e);if(-1!=e.indexOf("-END CERTIFICATE-",0)||-1!=e.indexOf("-END X509 CERTIFICATE-",0)||-1!=e.indexOf("-END TRUSTED CERTIFICATE-",0))return X509.getPublicKeyFromCertPEM(e);if(-1!=e.indexOf("-END PUBLIC KEY-")){var y=pemtohex(e,"PUBLIC KEY");return h._getKeyFromPublicPKCS8Hex(y)}if(-1!=e.indexOf("-END RSA PRIVATE KEY-")&&-1==e.indexOf("4,ENCRYPTED")){var m=c(e,"RSA PRIVATE KEY");return h.getKey(m,null,"pkcs5prv")}if(-1!=e.indexOf("-END DSA PRIVATE KEY-")&&-1==e.indexOf("4,ENCRYPTED")){var _=i(I=c(e,"DSA PRIVATE KEY"),0,[1],"02"),S=i(I,0,[2],"02"),b=i(I,0,[3],"02"),F=i(I,0,[4],"02"),w=i(I,0,[5],"02");return(k=new a).setPrivate(new BigInteger(_,16),new BigInteger(S,16),new BigInteger(b,16),new BigInteger(F,16),new BigInteger(w,16)),k}if(-1!=e.indexOf("-END PRIVATE KEY-"))return h.getKeyFromPlainPrivatePKCS8PEM(e);if(-1!=e.indexOf("-END RSA PRIVATE KEY-")&&-1!=e.indexOf("4,ENCRYPTED")){var E=h.getDecryptedKeyHex(e,t),x=new RSAKey;return x.readPKCS5PrvKeyHex(E),x}if(-1!=e.indexOf("-END EC PRIVATE KEY-")&&-1!=e.indexOf("4,ENCRYPTED")){var C,k=i(I=h.getDecryptedKeyHex(e,t),0,[1],"04"),A=i(I,0,[2,0],"06"),P=i(I,0,[3,0],"03").substr(2);if(void 0===V.crypto.OID.oidhex2name[A])throw"undefined OID(hex) in KJUR.crypto.OID: "+A;return(C=new s({curve:V.crypto.OID.oidhex2name[A]})).setPublicKeyHex(P),C.setPrivateKeyHex(k),C.isPublic=!1,C}if(-1!=e.indexOf("-END DSA PRIVATE KEY-")&&-1!=e.indexOf("4,ENCRYPTED")){var I;_=i(I=h.getDecryptedKeyHex(e,t),0,[1],"02"),S=i(I,0,[2],"02"),b=i(I,0,[3],"02"),F=i(I,0,[4],"02"),w=i(I,0,[5],"02");return(k=new a).setPrivate(new BigInteger(_,16),new BigInteger(S,16),new BigInteger(b,16),new BigInteger(F,16),new BigInteger(w,16)),k}if(-1!=e.indexOf("-END ENCRYPTED PRIVATE KEY-"))return h.getKeyFromEncryptedPKCS8PEM(e,t);throw"not supported argument"},z.generateKeypair=function(e,t){if("RSA"==e){var r=t;(s=new RSAKey).generate(r,"10001"),s.isPrivate=!0,s.isPublic=!0;var n=new RSAKey,i=s.n.toString(16),o=s.e.toString(16);return n.setPublic(i,o),n.isPrivate=!1,n.isPublic=!0,(a={}).prvKeyObj=s,a.pubKeyObj=n,a}if("EC"==e){var s,a,u=t,c=new V.crypto.ECDSA({curve:u}).generateKeyPairHex();return(s=new V.crypto.ECDSA({curve:u})).setPublicKeyHex(c.ecpubhex),s.setPrivateKeyHex(c.ecprvhex),s.isPrivate=!0,s.isPublic=!1,(n=new V.crypto.ECDSA({curve:u})).setPublicKeyHex(c.ecpubhex),n.isPrivate=!1,n.isPublic=!0,(a={}).prvKeyObj=s,a.pubKeyObj=n,a}throw"unknown algorithm: "+e},z.getPEM=function(e,t,r,n,i,s){var a=V,u=a.asn1,c=u.DERObjectIdentifier,h=u.DERInteger,l=u.ASN1Util.newObject,f=u.x509.SubjectPublicKeyInfo,g=a.crypto,p=g.DSA,d=g.ECDSA,v=RSAKey;function A(e){return l({seq:[{int:0},{int:{bigint:e.n}},{int:e.e},{int:{bigint:e.d}},{int:{bigint:e.p}},{int:{bigint:e.q}},{int:{bigint:e.dmp1}},{int:{bigint:e.dmq1}},{int:{bigint:e.coeff}}]})}function B(e){return l({seq:[{int:1},{octstr:{hex:e.prvKeyHex}},{tag:["a0",!0,{oid:{name:e.curveName}}]},{tag:["a1",!0,{bitstr:{hex:"00"+e.pubKeyHex}}]}]})}function x(e){return l({seq:[{int:0},{int:{bigint:e.p}},{int:{bigint:e.q}},{int:{bigint:e.g}},{int:{bigint:e.y}},{int:{bigint:e.x}}]})}if((void 0!==v&&e instanceof v||void 0!==p&&e instanceof p||void 0!==d&&e instanceof d)&&1==e.isPublic&&(void 0===t||"PKCS8PUB"==t))return hextopem(b=new f(e).getEncodedHex(),"PUBLIC KEY");if("PKCS1PRV"==t&&void 0!==v&&e instanceof v&&(void 0===r||null==r)&&1==e.isPrivate)return hextopem(b=A(e).getEncodedHex(),"RSA PRIVATE KEY");if("PKCS1PRV"==t&&void 0!==d&&e instanceof d&&(void 0===r||null==r)&&1==e.isPrivate){var m=new c({name:e.curveName}).getEncodedHex(),_=B(e).getEncodedHex(),S="";return S+=hextopem(m,"EC PARAMETERS"),S+=hextopem(_,"EC PRIVATE KEY")}if("PKCS1PRV"==t&&void 0!==p&&e instanceof p&&(void 0===r||null==r)&&1==e.isPrivate)return hextopem(b=x(e).getEncodedHex(),"DSA PRIVATE KEY");if("PKCS5PRV"==t&&void 0!==v&&e instanceof v&&void 0!==r&&null!=r&&1==e.isPrivate){var b=A(e).getEncodedHex();return void 0===n&&(n="DES-EDE3-CBC"),this.getEncryptedPKCS5PEMFromPrvKeyHex("RSA",b,r,n,s)}if("PKCS5PRV"==t&&void 0!==d&&e instanceof d&&void 0!==r&&null!=r&&1==e.isPrivate){b=B(e).getEncodedHex();return void 0===n&&(n="DES-EDE3-CBC"),this.getEncryptedPKCS5PEMFromPrvKeyHex("EC",b,r,n,s)}if("PKCS5PRV"==t&&void 0!==p&&e instanceof p&&void 0!==r&&null!=r&&1==e.isPrivate){b=x(e).getEncodedHex();return void 0===n&&(n="DES-EDE3-CBC"),this.getEncryptedPKCS5PEMFromPrvKeyHex("DSA",b,r,n,s)}var F=function o(e,t){var r=w(e,t);return new l({seq:[{seq:[{oid:{name:"pkcs5PBES2"}},{seq:[{seq:[{oid:{name:"pkcs5PBKDF2"}},{seq:[{octstr:{hex:r.pbkdf2Salt}},{int:r.pbkdf2Iter}]}]},{seq:[{oid:{name:"des-EDE3-CBC"}},{octstr:{hex:r.encryptionSchemeIV}}]}]}]},{octstr:{hex:r.ciphertext}}]}).getEncodedHex()},w=function c(e,t){var r=y.lib.WordArray.random(8),n=y.lib.WordArray.random(8),i=y.PBKDF2(t,r,{keySize:6,iterations:100}),o=y.enc.Hex.parse(e),s=y.TripleDES.encrypt(o,i,{iv:n})+"",a={};return a.ciphertext=s,a.pbkdf2Salt=y.enc.Hex.stringify(r),a.pbkdf2Iter=100,a.encryptionSchemeAlg="DES-EDE3-CBC",a.encryptionSchemeIV=y.enc.Hex.stringify(n),a};if("PKCS8PRV"==t&&void 0!=v&&e instanceof v&&1==e.isPrivate){var E=A(e).getEncodedHex();b=l({seq:[{int:0},{seq:[{oid:{name:"rsaEncryption"}},{null:!0}]},{octstr:{hex:E}}]}).getEncodedHex();return void 0===r||null==r?hextopem(b,"PRIVATE KEY"):hextopem(_=F(b,r),"ENCRYPTED PRIVATE KEY")}if("PKCS8PRV"==t&&void 0!==d&&e instanceof d&&1==e.isPrivate){E=new l({seq:[{int:1},{octstr:{hex:e.prvKeyHex}},{tag:["a1",!0,{bitstr:{hex:"00"+e.pubKeyHex}}]}]}).getEncodedHex(),b=l({seq:[{int:0},{seq:[{oid:{name:"ecPublicKey"}},{oid:{name:e.curveName}}]},{octstr:{hex:E}}]}).getEncodedHex();return void 0===r||null==r?hextopem(b,"PRIVATE KEY"):hextopem(_=F(b,r),"ENCRYPTED PRIVATE KEY")}if("PKCS8PRV"==t&&void 0!==p&&e instanceof p&&1==e.isPrivate){E=new h({bigint:e.x}).getEncodedHex(),b=l({seq:[{int:0},{seq:[{oid:{name:"dsa"}},{seq:[{int:{bigint:e.p}},{int:{bigint:e.q}},{int:{bigint:e.g}}]}]},{octstr:{hex:E}}]}).getEncodedHex();return void 0===r||null==r?hextopem(b,"PRIVATE KEY"):hextopem(_=F(b,r),"ENCRYPTED PRIVATE KEY")}throw"unsupported object nor format"},z.getKeyFromCSRPEM=function(e){var t=pemtohex(e,"CERTIFICATE REQUEST");return z.getKeyFromCSRHex(t)},z.getKeyFromCSRHex=function(e){var t=z.parseCSRHex(e);return z.getKey(t.p8pubkeyhex,null,"pkcs8pub")},z.parseCSRHex=function(e){var t=J,r=t.getChildIdx,n=t.getTLV,i={},o=e;if("30"!=o.substr(0,2))throw"malformed CSR(code:001)";var s=r(o,0);if(s.length<1)throw"malformed CSR(code:002)";if("30"!=o.substr(s[0],2))throw"malformed CSR(code:003)";var a=r(o,s[0]);if(a.length<3)throw"malformed CSR(code:004)";return i.p8pubkeyhex=n(o,a[2]),i},z.getJWKFromKey=function(e){var t={};if(e instanceof RSAKey&&e.isPrivate)return t.kty="RSA",t.n=hextob64u(e.n.toString(16)),t.e=hextob64u(e.e.toString(16)),t.d=hextob64u(e.d.toString(16)),t.p=hextob64u(e.p.toString(16)),t.q=hextob64u(e.q.toString(16)),t.dp=hextob64u(e.dmp1.toString(16)),t.dq=hextob64u(e.dmq1.toString(16)),t.qi=hextob64u(e.coeff.toString(16)),t;if(e instanceof RSAKey&&e.isPublic)return t.kty="RSA",t.n=hextob64u(e.n.toString(16)),t.e=hextob64u(e.e.toString(16)),t;if(e instanceof V.crypto.ECDSA&&e.isPrivate){if("P-256"!==(n=e.getShortNISTPCurveName())&&"P-384"!==n)throw"unsupported curve name for JWT: "+n;var r=e.getPublicKeyXYHex();return t.kty="EC",t.crv=n,t.x=hextob64u(r.x),t.y=hextob64u(r.y),t.d=hextob64u(e.prvKeyHex),t}if(e instanceof V.crypto.ECDSA&&e.isPublic){var n;if("P-256"!==(n=e.getShortNISTPCurveName())&&"P-384"!==n)throw"unsupported curve name for JWT: "+n;r=e.getPublicKeyXYHex();return t.kty="EC",t.crv=n,t.x=hextob64u(r.x),t.y=hextob64u(r.y),t}throw"not supported key object"},RSAKey.getPosArrayOfChildrenFromHex=function(e){return J.getChildIdx(e,0)},RSAKey.getHexValueArrayOfChildrenFromHex=function(e){var t,r=J.getV,n=r(e,(t=RSAKey.getPosArrayOfChildrenFromHex(e))[0]),i=r(e,t[1]),o=r(e,t[2]),s=r(e,t[3]),a=r(e,t[4]),u=r(e,t[5]),c=r(e,t[6]),h=r(e,t[7]),l=r(e,t[8]);return(t=new Array).push(n,i,o,s,a,u,c,h,l),t},RSAKey.prototype.readPrivateKeyFromPEMString=function(e){var t=pemtohex(e),r=RSAKey.getHexValueArrayOfChildrenFromHex(t);this.setPrivateEx(r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8])},RSAKey.prototype.readPKCS5PrvKeyHex=function(e){var t=RSAKey.getHexValueArrayOfChildrenFromHex(e);this.setPrivateEx(t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])},RSAKey.prototype.readPKCS8PrvKeyHex=function(e){var t,r,n,i,o,s,a,u,c=J,h=c.getVbyList;if(!1===c.isASN1HEX(e))throw"not ASN.1 hex string";try{t=h(e,0,[2,0,1],"02"),r=h(e,0,[2,0,2],"02"),n=h(e,0,[2,0,3],"02"),i=h(e,0,[2,0,4],"02"),o=h(e,0,[2,0,5],"02"),s=h(e,0,[2,0,6],"02"),a=h(e,0,[2,0,7],"02"),u=h(e,0,[2,0,8],"02")}catch(e){throw"malformed PKCS#8 plain RSA private key"}this.setPrivateEx(t,r,n,i,o,s,a,u)},RSAKey.prototype.readPKCS5PubKeyHex=function(e){var t=J,r=t.getV;if(!1===t.isASN1HEX(e))throw"keyHex is not ASN.1 hex string";var n=t.getChildIdx(e,0);if(2!==n.length||"02"!==e.substr(n[0],2)||"02"!==e.substr(n[1],2))throw"wrong hex for PKCS#5 public key";var i=r(e,n[0]),o=r(e,n[1]);this.setPublic(i,o)},RSAKey.prototype.readPKCS8PubKeyHex=function(e){var t=J;if(!1===t.isASN1HEX(e))throw"not ASN.1 hex string";if("06092a864886f70d010101"!==t.getTLVbyList(e,0,[0,0]))throw"not PKCS8 RSA public key";var r=t.getTLVbyList(e,0,[1,0]);this.readPKCS5PubKeyHex(r)},RSAKey.prototype.readCertPubKeyHex=function(e,t){var r,n;(r=new X509).readCertHex(e),n=r.getPublicKeyHex(),this.readPKCS8PubKeyHex(n)};var Y=new RegExp("");function _zeroPaddingOfSignature(e,t){for(var r="",n=t/4-e.length,i=0;i<n;i++)r+="0";return r+e}function pss_mgf1_str(e,t,r){for(var n="",i=0;n.length<t;)n+=hextorstr(r(rstrtohex(e+String.fromCharCode.apply(String,[(4278190080&i)>>24,(16711680&i)>>16,(65280&i)>>8,255&i])))),i+=1;return n}function _rsasign_getAlgNameAndHashFromHexDisgestInfo(e){for(var t in V.crypto.Util.DIGESTINFOHEAD){var r=V.crypto.Util.DIGESTINFOHEAD[t],n=r.length;if(e.substring(0,n)==r)return[t,e.substring(n)]}return[]}function X509(){var e=J,t=e.getChildIdx,r=e.getV,n=e.getTLV,i=e.getVbyList,o=e.getTLVbyList,s=e.getIdxbyList,a=e.getVidx,u=e.oidname,c=X509,h=pemtohex;this.hex=null,this.version=0,this.foffset=0,this.aExtInfo=null,this.getVersion=function(){return null===this.hex||0!==this.version?this.version:"a003020102"!==o(this.hex,0,[0,0])?(this.version=1,this.foffset=-1,1):(this.version=3,3)},this.getSerialNumberHex=function(){return i(this.hex,0,[0,1+this.foffset],"02")},this.getSignatureAlgorithmField=function(){return u(i(this.hex,0,[0,2+this.foffset,0],"06"))},this.getIssuerHex=function(){return o(this.hex,0,[0,3+this.foffset],"30")},this.getIssuerString=function(){return c.hex2dn(this.getIssuerHex())},this.getSubjectHex=function(){return o(this.hex,0,[0,5+this.foffset],"30")},this.getSubjectString=function(){return c.hex2dn(this.getSubjectHex())},this.getNotBefore=function(){var e=i(this.hex,0,[0,4+this.foffset,0]);return e=e.replace(/(..)/g,"%$1"),e=decodeURIComponent(e)},this.getNotAfter=function(){var e=i(this.hex,0,[0,4+this.foffset,1]);return e=e.replace(/(..)/g,"%$1"),e=decodeURIComponent(e)},this.getPublicKeyHex=function(){return e.getTLVbyList(this.hex,0,[0,6+this.foffset],"30")},this.getPublicKeyIdx=function(){return s(this.hex,0,[0,6+this.foffset],"30")},this.getPublicKeyContentIdx=function(){var e=this.getPublicKeyIdx();return s(this.hex,e,[1,0],"30")},this.getPublicKey=function(){return z.getKey(this.getPublicKeyHex(),null,"pkcs8pub")},this.getSignatureAlgorithmName=function(){return u(i(this.hex,0,[1,0],"06"))},this.getSignatureValueHex=function(){return i(this.hex,0,[2],"03",!0)},this.verifySignature=function(e){var t=this.getSignatureAlgorithmName(),r=this.getSignatureValueHex(),n=o(this.hex,0,[0],"30"),i=new V.crypto.Signature({alg:t});return i.init(e),i.updateHex(n),i.verify(r)},this.parseExt=function(){if(3!==this.version)return-1;var r=s(this.hex,0,[0,7,0],"30"),n=t(this.hex,r);this.aExtInfo=new Array;for(var o=0;o<n.length;o++){var u={critical:!1},c=0;3===t(this.hex,n[o]).length&&(u.critical=!0,c=1),u.oid=e.hextooidstr(i(this.hex,n[o],[0],"06"));var h=s(this.hex,n[o],[1+c]);u.vidx=a(this.hex,h),this.aExtInfo.push(u)}},this.getExtInfo=function(e){var t=this.aExtInfo,r=e;if(e.match(/^[0-9.]+$/)||(r=V.asn1.x509.OID.name2oid(e)),""!==r)for(var n=0;n<t.length;n++)if(t[n].oid===r)return t[n]},this.getExtBasicConstraints=function(){var e=this.getExtInfo("basicConstraints");if(void 0===e)return e;var t=r(this.hex,e.vidx);if(""===t)return{};if("0101ff"===t)return{cA:!0};if("0101ff02"===t.substr(0,8)){var n=r(t,6);return{cA:!0,pathLen:parseInt(n,16)}}throw"basicConstraints parse error"},this.getExtKeyUsageBin=function(){var e=this.getExtInfo("keyUsage");if(void 0===e)return"";var t=r(this.hex,e.vidx);if(t.length%2!=0||t.length<=2)throw"malformed key usage value";var n=parseInt(t.substr(0,2)),i=parseInt(t.substr(2),16).toString(2);return i.substr(0,i.length-n)},this.getExtKeyUsageString=function(){for(var e=this.getExtKeyUsageBin(),t=new Array,r=0;r<e.length;r++)"1"==e.substr(r,1)&&t.push(X509.KEYUSAGE_NAME[r]);return t.join(",")},this.getExtSubjectKeyIdentifier=function(){var e=this.getExtInfo("subjectKeyIdentifier");return void 0===e?e:r(this.hex,e.vidx)},this.getExtAuthorityKeyIdentifier=function(){var e=this.getExtInfo("authorityKeyIdentifier");if(void 0===e)return e;for(var i={},o=n(this.hex,e.vidx),s=t(o,0),a=0;a<s.length;a++)"80"===o.substr(s[a],2)&&(i.kid=r(o,s[a]));return i},this.getExtExtKeyUsageName=function(){var e=this.getExtInfo("extKeyUsage");if(void 0===e)return e;var i=new Array,o=n(this.hex,e.vidx);if(""===o)return i;for(var s=t(o,0),a=0;a<s.length;a++)i.push(u(r(o,s[a])));return i},this.getExtSubjectAltName=function(){for(var e=this.getExtSubjectAltName2(),t=new Array,r=0;r<e.length;r++)"DNS"===e[r][0]&&t.push(e[r][1]);return t},this.getExtSubjectAltName2=function(){var e,i,o,s=this.getExtInfo("subjectAltName");if(void 0===s)return s;for(var a=new Array,u=n(this.hex,s.vidx),c=t(u,0),h=0;h<c.length;h++)o=u.substr(c[h],2),e=r(u,c[h]),"81"===o&&(i=hextoutf8(e),a.push(["MAIL",i])),"82"===o&&(i=hextoutf8(e),a.push(["DNS",i])),"84"===o&&(i=X509.hex2dn(e,0),a.push(["DN",i])),"86"===o&&(i=hextoutf8(e),a.push(["URI",i])),"87"===o&&(i=hextoip(e),a.push(["IP",i]));return a},this.getExtCRLDistributionPointsURI=function(){var e=this.getExtInfo("cRLDistributionPoints");if(void 0===e)return e;for(var r=new Array,n=t(this.hex,e.vidx),o=0;o<n.length;o++)try{var s=hextoutf8(i(this.hex,n[o],[0,0,0],"86"));r.push(s)}catch(e){}return r},this.getExtAIAInfo=function(){var e=this.getExtInfo("authorityInfoAccess");if(void 0===e)return e;for(var r={ocsp:[],caissuer:[]},n=t(this.hex,e.vidx),o=0;o<n.length;o++){var s=i(this.hex,n[o],[0],"06"),a=i(this.hex,n[o],[1],"86");"2b06010505073001"===s&&r.ocsp.push(hextoutf8(a)),"2b06010505073002"===s&&r.caissuer.push(hextoutf8(a))}return r},this.getExtCertificatePolicies=function(){var e=this.getExtInfo("certificatePolicies");if(void 0===e)return e;for(var o=n(this.hex,e.vidx),s=[],a=t(o,0),c=0;c<a.length;c++){var h={},l=t(o,a[c]);if(h.id=u(r(o,l[0])),2===l.length)for(var f=t(o,l[1]),g=0;g<f.length;g++){var p=i(o,f[g],[0],"06");"2b06010505070201"===p?h.cps=hextoutf8(i(o,f[g],[1])):"2b06010505070202"===p&&(h.unotice=hextoutf8(i(o,f[g],[1,0])))}s.push(h)}return s},this.readCertPEM=function(e){this.readCertHex(h(e))},this.readCertHex=function(e){this.hex=e,this.getVersion();try{s(this.hex,0,[0,7],"a3"),this.parseExt()}catch(e){}},this.getInfo=function(){var e,t,r;if(e="Basic Fields\n",e+="  serial number: "+this.getSerialNumberHex()+"\n",e+="  signature algorithm: "+this.getSignatureAlgorithmField()+"\n",e+="  issuer: "+this.getIssuerString()+"\n",e+="  notBefore: "+this.getNotBefore()+"\n",e+="  notAfter: "+this.getNotAfter()+"\n",e+="  subject: "+this.getSubjectString()+"\n",e+="  subject public key info: \n",e+="    key algorithm: "+(t=this.getPublicKey()).type+"\n","RSA"===t.type&&(e+="    n="+hextoposhex(t.n.toString(16)).substr(0,16)+"...\n",e+="    e="+hextoposhex(t.e.toString(16))+"\n"),void 0!==(r=this.aExtInfo)&&null!==r){e+="X509v3 Extensions:\n";for(var n=0;n<r.length;n++){var i=r[n],o=V.asn1.x509.OID.oid2name(i.oid);""===o&&(o=i.oid);var s="";if(!0===i.critical&&(s="CRITICAL"),e+="  "+o+" "+s+":\n","basicConstraints"===o){var a=this.getExtBasicConstraints();void 0===a.cA?e+="    {}\n":(e+="    cA=true",void 0!==a.pathLen&&(e+=", pathLen="+a.pathLen),e+="\n")}else if("keyUsage"===o)e+="    "+this.getExtKeyUsageString()+"\n";else if("subjectKeyIdentifier"===o)e+="    "+this.getExtSubjectKeyIdentifier()+"\n";else if("authorityKeyIdentifier"===o){var u=this.getExtAuthorityKeyIdentifier();void 0!==u.kid&&(e+="    kid="+u.kid+"\n")}else{if("extKeyUsage"===o)e+="    "+this.getExtExtKeyUsageName().join(", ")+"\n";else if("subjectAltName"===o)e+="    "+this.getExtSubjectAltName2()+"\n";else if("cRLDistributionPoints"===o)e+="    "+this.getExtCRLDistributionPointsURI()+"\n";else if("authorityInfoAccess"===o){var c=this.getExtAIAInfo();void 0!==c.ocsp&&(e+="    ocsp: "+c.ocsp.join(",")+"\n"),void 0!==c.caissuer&&(e+="    caissuer: "+c.caissuer.join(",")+"\n")}else if("certificatePolicies"===o)for(var h=this.getExtCertificatePolicies(),l=0;l<h.length;l++)void 0!==h[l].id&&(e+="    policy oid: "+h[l].id+"\n"),void 0!==h[l].cps&&(e+="    cps: "+h[l].cps+"\n")}}}return e+="signature algorithm: "+this.getSignatureAlgorithmName()+"\n",e+="signature: "+this.getSignatureValueHex().substr(0,16)+"...\n"}}Y.compile("[^0-9a-f]","gi"),RSAKey.prototype.sign=function(e,t){var r=function b(e){return V.crypto.Util.hashString(e,t)}(e);return this.signWithMessageHash(r,t)},RSAKey.prototype.signWithMessageHash=function(e,t){var r=parseBigInt(V.crypto.Util.getPaddedDigestInfoHex(e,t,this.n.bitLength()),16);return _zeroPaddingOfSignature(this.doPrivate(r).toString(16),this.n.bitLength())},RSAKey.prototype.signPSS=function(e,t,r){var n=function c(e){return V.crypto.Util.hashHex(e,t)}(rstrtohex(e));return void 0===r&&(r=-1),this.signWithMessageHashPSS(n,t,r)},RSAKey.prototype.signWithMessageHashPSS=function(e,t,r){var n,i=hextorstr(e),s=i.length,a=this.n.bitLength()-1,u=Math.ceil(a/8),c=function o(e){return V.crypto.Util.hashHex(e,t)};if(-1===r||void 0===r)r=s;else if(-2===r)r=u-s-2;else if(r<-2)throw"invalid salt length";if(u<s+r+2)throw"data too long";var h="";r>0&&(h=new Array(r),(new SecureRandom).nextBytes(h),h=String.fromCharCode.apply(String,h));var l=hextorstr(c(rstrtohex("\0\0\0\0\0\0\0\0"+i+h))),f=[];for(n=0;n<u-r-s-2;n+=1)f[n]=0;var g=String.fromCharCode.apply(String,f)+""+h,p=pss_mgf1_str(l,g.length,c),d=[];for(n=0;n<g.length;n+=1)d[n]=g.charCodeAt(n)^p.charCodeAt(n);var v=65280>>8*u-a&255;for(d[0]&=~v,n=0;n<s;n++)d.push(l.charCodeAt(n));return d.push(188),_zeroPaddingOfSignature(this.doPrivate(new BigInteger(d)).toString(16),this.n.bitLength())},RSAKey.prototype.verify=function(e,t){var r=parseBigInt(t=(t=t.replace(Y,"")).replace(/[ \n]+/g,""),16);if(r.bitLength()>this.n.bitLength())return 0;var n=_rsasign_getAlgNameAndHashFromHexDisgestInfo(this.doPublic(r).toString(16).replace(/^1f+00/,""));if(0==n.length)return!1;var i=n[0];return n[1]==function a(e){return V.crypto.Util.hashString(e,i)}(e)},RSAKey.prototype.verifyWithMessageHash=function(e,t){var r=parseBigInt(t=(t=t.replace(Y,"")).replace(/[ \n]+/g,""),16);if(r.bitLength()>this.n.bitLength())return 0;var n=_rsasign_getAlgNameAndHashFromHexDisgestInfo(this.doPublic(r).toString(16).replace(/^1f+00/,""));if(0==n.length)return!1;n[0];return n[1]==e},RSAKey.prototype.verifyPSS=function(t,r,n,i){var o=function e(t){return V.crypto.Util.hashHex(t,n)}(rstrtohex(t));return void 0===i&&(i=-1),this.verifyWithMessageHashPSS(o,r,n,i)},RSAKey.prototype.verifyWithMessageHashPSS=function(e,t,n,i){var o=new BigInteger(t,16);if(o.bitLength()>this.n.bitLength())return!1;var s,a=function r(e){return V.crypto.Util.hashHex(e,n)},u=hextorstr(e),c=u.length,h=this.n.bitLength()-1,l=Math.ceil(h/8);if(-1===i||void 0===i)i=c;else if(-2===i)i=l-c-2;else if(i<-2)throw"invalid salt length";if(l<c+i+2)throw"data too long";var f=this.doPublic(o).toByteArray();for(s=0;s<f.length;s+=1)f[s]&=255;for(;f.length<l;)f.unshift(0);if(188!==f[l-1])throw"encoded message does not end in 0xbc";var g=(f=String.fromCharCode.apply(String,f)).substr(0,l-c-1),p=f.substr(g.length,c),d=65280>>8*l-h&255;if(0!=(g.charCodeAt(0)&d))throw"bits beyond keysize not zero";var v=pss_mgf1_str(p,g.length,a),y=[];for(s=0;s<g.length;s+=1)y[s]=g.charCodeAt(s)^v.charCodeAt(s);y[0]&=~d;var m=l-c-i-2;for(s=0;s<m;s+=1)if(0!==y[s])throw"leftmost octets not zero";if(1!==y[m])throw"0x01 marker not found";return p===hextorstr(a(rstrtohex("\0\0\0\0\0\0\0\0"+u+String.fromCharCode.apply(String,y.slice(-i)))))},RSAKey.SALT_LEN_HLEN=-1,RSAKey.SALT_LEN_MAX=-2,RSAKey.SALT_LEN_RECOVER=-2,X509.hex2dn=function(e,t){if(void 0===t&&(t=0),"30"!==e.substr(t,2))throw"malformed DN";for(var r=new Array,n=J.getChildIdx(e,t),i=0;i<n.length;i++)r.push(X509.hex2rdn(e,n[i]));return"/"+(r=r.map(function(e){return e.replace("/","\\/")})).join("/")},X509.hex2rdn=function(e,t){if(void 0===t&&(t=0),"31"!==e.substr(t,2))throw"malformed RDN";for(var r=new Array,n=J.getChildIdx(e,t),i=0;i<n.length;i++)r.push(X509.hex2attrTypeValue(e,n[i]));return(r=r.map(function(e){return e.replace("+","\\+")})).join("+")},X509.hex2attrTypeValue=function(e,t){var r=J,n=r.getV;if(void 0===t&&(t=0),"30"!==e.substr(t,2))throw"malformed attribute type and value";var i=r.getChildIdx(e,t);2!==i.length||e.substr(i[0],2);var o=n(e,i[0]),s=V.asn1.ASN1Util.oidHexToInt(o);return V.asn1.x509.OID.oid2atype(s)+"="+hextorstr(n(e,i[1]))},X509.getPublicKeyFromCertHex=function(e){var t=new X509;return t.readCertHex(e),t.getPublicKey()},X509.getPublicKeyFromCertPEM=function(e){var t=new X509;return t.readCertPEM(e),t.getPublicKey()},X509.getPublicKeyInfoPropOfCertPEM=function(e){var t,r,n=J.getVbyList,i={};return i.algparam=null,(t=new X509).readCertPEM(e),r=t.getPublicKeyHex(),i.keyhex=n(r,0,[1],"03").substr(2),i.algoid=n(r,0,[0,0],"06"),"2a8648ce3d0201"===i.algoid&&(i.algparam=n(r,0,[0,1],"06")),i},X509.KEYUSAGE_NAME=["digitalSignature","nonRepudiation","keyEncipherment","dataEncipherment","keyAgreement","keyCertSign","cRLSign","encipherOnly","decipherOnly"],void 0!==V&&V||(t.KJUR=V={}),void 0!==V.jws&&V.jws||(V.jws={}),V.jws.JWS=function(){var e=V.jws.JWS.isSafeJSONString;this.parseJWS=function(t,r){if(void 0===this.parsedJWS||!r&&void 0===this.parsedJWS.sigvalH){var n=t.match(/^([^.]+)\.([^.]+)\.([^.]+)$/);if(null==n)throw"JWS signature is not a form of 'Head.Payload.SigValue'.";var i=n[1],o=n[2],s=n[3],a=i+"."+o;if(this.parsedJWS={},this.parsedJWS.headB64U=i,this.parsedJWS.payloadB64U=o,this.parsedJWS.sigvalB64U=s,this.parsedJWS.si=a,!r){var u=b64utohex(s),c=parseBigInt(u,16);this.parsedJWS.sigvalH=u,this.parsedJWS.sigvalBI=c}var h=W(i),l=W(o);if(this.parsedJWS.headS=h,this.parsedJWS.payloadS=l,!e(h,this.parsedJWS,"headP"))throw"malformed JSON string for JWS Head: "+h}}},V.jws.JWS.sign=function(e,t,r,n,o){var s,a,u,c=V,h=c.jws.JWS,l=h.readSafeJSONString,f=h.isSafeJSONString,g=c.crypto,p=(g.ECDSA,g.Mac),d=g.Signature,v=JSON;if("string"!=typeof t&&"object"!=(void 0===t?"undefined":i(t)))throw"spHeader must be JSON string or object: "+t;if("object"==(void 0===t?"undefined":i(t))&&(a=t,s=v.stringify(a)),"string"==typeof t){if(!f(s=t))throw"JWS Head is not safe JSON string: "+s;a=l(s)}if(u=r,"object"==(void 0===r?"undefined":i(r))&&(u=v.stringify(r)),""!=e&&null!=e||void 0===a.alg||(e=a.alg),""!=e&&null!=e&&void 0===a.alg&&(a.alg=e,s=v.stringify(a)),e!==a.alg)throw"alg and sHeader.alg doesn't match: "+e+"!="+a.alg;var y=null;if(void 0===h.jwsalg2sigalg[e])throw"unsupported alg name: "+e;y=h.jwsalg2sigalg[e];var m=q(s)+"."+q(u),_="";if("Hmac"==y.substr(0,4)){if(void 0===n)throw"mac key shall be specified for HS* alg";var S=new p({alg:y,prov:"cryptojs",pass:n});S.updateString(m),_=S.doFinal()}else{var b;if(-1!=y.indexOf("withECDSA"))(b=new d({alg:y})).init(n,o),b.updateString(m),hASN1Sig=b.sign(),_=V.crypto.ECDSA.asn1SigToConcatSig(hASN1Sig);else if("none"!=y)(b=new d({alg:y})).init(n,o),b.updateString(m),_=b.sign()}return m+"."+hextob64u(_)},V.jws.JWS.verify=function(e,t,r){var n,o=V,s=o.jws.JWS,a=s.readSafeJSONString,u=o.crypto,c=u.ECDSA,h=u.Mac,l=u.Signature;void 0!==i(RSAKey)&&(n=RSAKey);var f=e.split(".");if(3!==f.length)return!1;var g=f[0]+"."+f[1],p=b64utohex(f[2]),d=a(W(f[0])),v=null,y=null;if(void 0===d.alg)throw"algorithm not specified in header";if((y=(v=d.alg).substr(0,2),null!=r&&"[object Array]"===Object.prototype.toString.call(r)&&r.length>0)&&-1==(":"+r.join(":")+":").indexOf(":"+v+":"))throw"algorithm '"+v+"' not accepted in the list";if("none"!=v&&null===t)throw"key shall be specified to verify.";if("string"==typeof t&&-1!=t.indexOf("-----BEGIN ")&&(t=z.getKey(t)),!("RS"!=y&&"PS"!=y||t instanceof n))throw"key shall be a RSAKey obj for RS* and PS* algs";if("ES"==y&&!(t instanceof c))throw"key shall be a ECDSA obj for ES* algs";var m=null;if(void 0===s.jwsalg2sigalg[d.alg])throw"unsupported alg name: "+v;if("none"==(m=s.jwsalg2sigalg[v]))throw"not supported";if("Hmac"==m.substr(0,4)){if(void 0===t)throw"hexadecimal key shall be specified for HMAC";var _=new h({alg:m,pass:t});return _.updateString(g),p==_.doFinal()}if(-1!=m.indexOf("withECDSA")){var S,b=null;try{b=c.concatSigToASN1Sig(p)}catch(e){return!1}return(S=new l({alg:m})).init(t),S.updateString(g),S.verify(b)}return(S=new l({alg:m})).init(t),S.updateString(g),S.verify(p)},V.jws.JWS.parse=function(e){var t,r,n,i=e.split("."),o={};if(2!=i.length&&3!=i.length)throw"malformed sJWS: wrong number of '.' splitted elements";return t=i[0],r=i[1],3==i.length&&(n=i[2]),o.headerObj=V.jws.JWS.readSafeJSONString(W(t)),o.payloadObj=V.jws.JWS.readSafeJSONString(W(r)),o.headerPP=JSON.stringify(o.headerObj,null,"  "),null==o.payloadObj?o.payloadPP=W(r):o.payloadPP=JSON.stringify(o.payloadObj,null,"  "),void 0!==n&&(o.sigHex=b64utohex(n)),o},V.jws.JWS.verifyJWT=function(e,t,r){var n=V.jws,o=n.JWS,s=o.readSafeJSONString,a=o.inArray,u=o.includedArray,c=e.split("."),h=c[0],l=c[1],f=(b64utohex(c[2]),s(W(h))),g=s(W(l));if(void 0===f.alg)return!1;if(void 0===r.alg)throw"acceptField.alg shall be specified";if(!a(f.alg,r.alg))return!1;if(void 0!==g.iss&&"object"===i(r.iss)&&!a(g.iss,r.iss))return!1;if(void 0!==g.sub&&"object"===i(r.sub)&&!a(g.sub,r.sub))return!1;if(void 0!==g.aud&&"object"===i(r.aud))if("string"==typeof g.aud){if(!a(g.aud,r.aud))return!1}else if("object"==i(g.aud)&&!u(g.aud,r.aud))return!1;var p=n.IntDate.getNow();return void 0!==r.verifyAt&&"number"==typeof r.verifyAt&&(p=r.verifyAt),void 0!==r.gracePeriod&&"number"==typeof r.gracePeriod||(r.gracePeriod=0),!(void 0!==g.exp&&"number"==typeof g.exp&&g.exp+r.gracePeriod<p)&&(!(void 0!==g.nbf&&"number"==typeof g.nbf&&p<g.nbf-r.gracePeriod)&&(!(void 0!==g.iat&&"number"==typeof g.iat&&p<g.iat-r.gracePeriod)&&((void 0===g.jti||void 0===r.jti||g.jti===r.jti)&&!!o.verify(e,t,r.alg))))},V.jws.JWS.includedArray=function(e,t){var r=V.jws.JWS.inArray;if(null===e)return!1;if("object"!==(void 0===e?"undefined":i(e)))return!1;if("number"!=typeof e.length)return!1;for(var n=0;n<e.length;n++)if(!r(e[n],t))return!1;return!0},V.jws.JWS.inArray=function(e,t){if(null===t)return!1;if("object"!==(void 0===t?"undefined":i(t)))return!1;if("number"!=typeof t.length)return!1;for(var r=0;r<t.length;r++)if(t[r]==e)return!0;return!1},V.jws.JWS.jwsalg2sigalg={HS256:"HmacSHA256",HS384:"HmacSHA384",HS512:"HmacSHA512",RS256:"SHA256withRSA",RS384:"SHA384withRSA",RS512:"SHA512withRSA",ES256:"SHA256withECDSA",ES384:"SHA384withECDSA",PS256:"SHA256withRSAandMGF1",PS384:"SHA384withRSAandMGF1",PS512:"SHA512withRSAandMGF1",none:"none"},V.jws.JWS.isSafeJSONString=function(e,t,r){var n=null;try{return"object"!=(void 0===(n=K(e))?"undefined":i(n))?0:n.constructor===Array?0:(t&&(t[r]=n),1)}catch(e){return 0}},V.jws.JWS.readSafeJSONString=function(e){var t=null;try{return"object"!=(void 0===(t=K(e))?"undefined":i(t))?null:t.constructor===Array?null:t}catch(e){return null}},V.jws.JWS.getEncodedSignatureValueFromJWS=function(e){var t=e.match(/^[^.]+\.[^.]+\.([^.]+)$/);if(null==t)throw"JWS signature is not a form of 'Head.Payload.SigValue'.";return t[1]},V.jws.JWS.getJWKthumbprint=function(e){if("RSA"!==e.kty&&"EC"!==e.kty&&"oct"!==e.kty)throw"unsupported algorithm for JWK Thumprint";var t="{";if("RSA"===e.kty){if("string"!=typeof e.n||"string"!=typeof e.e)throw"wrong n and e value for RSA key";t+='"e":"'+e.e+'",',t+='"kty":"'+e.kty+'",',t+='"n":"'+e.n+'"}'}else if("EC"===e.kty){if("string"!=typeof e.crv||"string"!=typeof e.x||"string"!=typeof e.y)throw"wrong crv, x and y value for EC key";t+='"crv":"'+e.crv+'",',t+='"kty":"'+e.kty+'",',t+='"x":"'+e.x+'",',t+='"y":"'+e.y+'"}'}else if("oct"===e.kty){if("string"!=typeof e.k)throw"wrong k value for oct(symmetric) key";t+='"kty":"'+e.kty+'",',t+='"k":"'+e.k+'"}'}var r=rstrtohex(t);return hextob64u(V.crypto.Util.hashHex(r,"sha256"))},V.jws.IntDate={},V.jws.IntDate.get=function(e){var t=V.jws.IntDate,r=t.getNow,n=t.getZulu;if("now"==e)return r();if("now + 1hour"==e)return r()+3600;if("now + 1day"==e)return r()+86400;if("now + 1month"==e)return r()+2592e3;if("now + 1year"==e)return r()+31536e3;if(e.match(/Z$/))return n(e);if(e.match(/^[0-9]+$/))return parseInt(e);throw"unsupported format: "+e},V.jws.IntDate.getZulu=function(e){return zulutosec(e)},V.jws.IntDate.getNow=function(){return~~(new Date/1e3)},V.jws.IntDate.intDate2UTCString=function(e){return new Date(1e3*e).toUTCString()},V.jws.IntDate.intDate2Zulu=function(e){var t=new Date(1e3*e);return("0000"+t.getUTCFullYear()).slice(-4)+("00"+(t.getUTCMonth()+1)).slice(-2)+("00"+t.getUTCDate()).slice(-2)+("00"+t.getUTCHours()).slice(-2)+("00"+t.getUTCMinutes()).slice(-2)+("00"+t.getUTCSeconds()).slice(-2)+"Z"},t.SecureRandom=SecureRandom,t.rng_seed_time=rng_seed_time,t.BigInteger=BigInteger,t.RSAKey=RSAKey;var G=V.crypto.EDSA;t.EDSA=G;var X=V.crypto.DSA;t.DSA=X;var Q=V.crypto.Signature;t.Signature=Q;var $=V.crypto.MessageDigest;t.MessageDigest=$;var Z=V.crypto.Mac;t.Mac=Z;var ee=V.crypto.Cipher;t.Cipher=ee,t.KEYUTIL=z,t.ASN1HEX=J,t.X509=X509,t.CryptoJS=y,t.b64tohex=b64tohex,t.b64toBA=b64toBA,t.stoBA=stoBA,t.BAtos=BAtos,t.BAtohex=BAtohex,t.stohex=stohex,t.stob64=function stob64(e){return hex2b64(stohex(e))},t.stob64u=function stob64u(e){return b64tob64u(hex2b64(stohex(e)))},t.b64utos=function b64utos(e){return BAtos(b64toBA(b64utob64(e)))},t.b64tob64u=b64tob64u,t.b64utob64=b64utob64,t.hex2b64=hex2b64,t.hextob64u=hextob64u,t.b64utohex=b64utohex,t.utf8tob64u=q,t.b64utoutf8=W,t.utf8tob64=function utf8tob64(e){return hex2b64(uricmptohex(encodeURIComponentAll(e)))},t.b64toutf8=function b64toutf8(e){return decodeURIComponent(hextouricmp(b64tohex(e)))},t.utf8tohex=utf8tohex,t.hextoutf8=hextoutf8,t.hextorstr=hextorstr,t.rstrtohex=rstrtohex,t.hextob64=hextob64,t.hextob64nl=hextob64nl,t.b64nltohex=b64nltohex,t.hextopem=hextopem,t.pemtohex=pemtohex,t.hextoArrayBuffer=function hextoArrayBuffer(e){if(e.length%2!=0)throw"input is not even length";if(null==e.match(/^[0-9A-Fa-f]+$/))throw"input is not hexadecimal";for(var t=new ArrayBuffer(e.length/2),r=new DataView(t),n=0;n<e.length/2;n++)r.setUint8(n,parseInt(e.substr(2*n,2),16));return t},t.ArrayBuffertohex=function ArrayBuffertohex(e){for(var t="",r=new DataView(e),n=0;n<e.byteLength;n++)t+=("00"+r.getUint8(n).toString(16)).slice(-2);return t},t.zulutomsec=zulutomsec,t.zulutosec=zulutosec,t.zulutodate=function zulutodate(e){return new Date(zulutomsec(e))},t.datetozulu=function datetozulu(e,t,r){var n,i=e.getUTCFullYear();if(t){if(i<1950||2049<i)throw"not proper year for UTCTime: "+i;n=(""+i).slice(-2)}else n=("000"+i).slice(-4);if(n+=("0"+(e.getUTCMonth()+1)).slice(-2),n+=("0"+e.getUTCDate()).slice(-2),n+=("0"+e.getUTCHours()).slice(-2),n+=("0"+e.getUTCMinutes()).slice(-2),n+=("0"+e.getUTCSeconds()).slice(-2),r){var o=e.getUTCMilliseconds();0!==o&&(n+="."+(o=(o=("00"+o).slice(-3)).replace(/0+$/g,"")))}return n+="Z"},t.uricmptohex=uricmptohex,t.hextouricmp=hextouricmp,t.ipv6tohex=ipv6tohex,t.hextoipv6=hextoipv6,t.hextoip=hextoip,t.iptohex=function iptohex(e){var t="malformed IP address";if(!(e=e.toLowerCase(e)).match(/^[0-9.]+$/)){if(e.match(/^[0-9a-f:]+$/)&&-1!==e.indexOf(":"))return ipv6tohex(e);throw t}var r=e.split(".");if(4!==r.length)throw t;var n="";try{for(var i=0;i<4;i++)n+=("0"+parseInt(r[i]).toString(16)).slice(-2);return n}catch(e){throw t}},t.encodeURIComponentAll=encodeURIComponentAll,t.newline_toUnix=function newline_toUnix(e){return e=e.replace(/\r\n/gm,"\n")},t.newline_toDos=function newline_toDos(e){return e=(e=e.replace(/\r\n/gm,"\n")).replace(/\n/gm,"\r\n")},t.hextoposhex=hextoposhex,t.intarystrtohex=function intarystrtohex(e){e=(e=(e=e.replace(/^\s*\[\s*/,"")).replace(/\s*\]\s*$/,"")).replace(/\s*/g,"");try{return e.split(/,/).map(function(e,t,r){var n=parseInt(e);if(n<0||255<n)throw"integer not in range 0-255";return("00"+n.toString(16)).slice(-2)}).join("")}catch(e){throw"malformed integer array string: "+e}},t.strdiffidx=function strdiffidx(e,t){var r=e.length;e.length>t.length&&(r=t.length);for(var n=0;n<r;n++)if(e.charCodeAt(n)!=t.charCodeAt(n))return n;return e.length!=t.length?r:-1},t.KJUR=V;var te=V.crypto;t.crypto=te;var re=V.asn1;t.asn1=re;var ne=V.jws;t.jws=ne;var ie=V.lang;t.lang=ie}).call(this,r(26).Buffer)},function(e,t,r){"use strict";(function(e){
/*!
 * The buffer module from node.js, for the browser.
 *
 * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>
 * @license  MIT
 */
var n=r(28),i=r(29),o=r(30);function kMaxLength(){return Buffer.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function createBuffer(e,t){if(kMaxLength()<t)throw new RangeError("Invalid typed array length");return Buffer.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=Buffer.prototype:(null===e&&(e=new Buffer(t)),e.length=t),e}function Buffer(e,t,r){if(!(Buffer.TYPED_ARRAY_SUPPORT||this instanceof Buffer))return new Buffer(e,t,r);if("number"==typeof e){if("string"==typeof t)throw new Error("If encoding is specified then the first argument must be a string");return allocUnsafe(this,e)}return from(this,e,t,r)}function from(e,t,r,n){if("number"==typeof t)throw new TypeError('"value" argument must not be a number');return"undefined"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function fromArrayBuffer(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError("'offset' is out of bounds");if(t.byteLength<r+(n||0))throw new RangeError("'length' is out of bounds");t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n);Buffer.TYPED_ARRAY_SUPPORT?(e=t).__proto__=Buffer.prototype:e=fromArrayLike(e,t);return e}(e,t,r,n):"string"==typeof t?function fromString(e,t,r){"string"==typeof r&&""!==r||(r="utf8");if(!Buffer.isEncoding(r))throw new TypeError('"encoding" must be a valid string encoding');var n=0|byteLength(t,r),i=(e=createBuffer(e,n)).write(t,r);i!==n&&(e=e.slice(0,i));return e}(e,t,r):function fromObject(e,t){if(Buffer.isBuffer(t)){var r=0|checked(t.length);return 0===(e=createBuffer(e,r)).length?e:(t.copy(e,0,0,r),e)}if(t){if("undefined"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||"length"in t)return"number"!=typeof t.length||function isnan(e){return e!=e}(t.length)?createBuffer(e,0):fromArrayLike(e,t);if("Buffer"===t.type&&o(t.data))return fromArrayLike(e,t.data)}throw new TypeError("First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.")}(e,t)}function assertSize(e){if("number"!=typeof e)throw new TypeError('"size" argument must be a number');if(e<0)throw new RangeError('"size" argument must not be negative')}function allocUnsafe(e,t){if(assertSize(t),e=createBuffer(e,t<0?0:0|checked(t)),!Buffer.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function fromArrayLike(e,t){var r=t.length<0?0:0|checked(t.length);e=createBuffer(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function checked(e){if(e>=kMaxLength())throw new RangeError("Attempt to allocate Buffer larger than maximum size: 0x"+kMaxLength().toString(16)+" bytes");return 0|e}function byteLength(e,t){if(Buffer.isBuffer(e))return e.length;if("undefined"!=typeof ArrayBuffer&&"function"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;"string"!=typeof e&&(e=""+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case"ascii":case"latin1":case"binary":return r;case"utf8":case"utf-8":case void 0:return utf8ToBytes(e).length;case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return 2*r;case"hex":return r>>>1;case"base64":return base64ToBytes(e).length;default:if(n)return utf8ToBytes(e).length;t=(""+t).toLowerCase(),n=!0}}function swap(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function bidirectionalIndexOf(e,t,r,n,i){if(0===e.length)return-1;if("string"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if("string"==typeof t&&(t=Buffer.from(t,n)),Buffer.isBuffer(t))return 0===t.length?-1:arrayIndexOf(e,t,r,n,i);if("number"==typeof t)return t&=255,Buffer.TYPED_ARRAY_SUPPORT&&"function"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):arrayIndexOf(e,[t],r,n,i);throw new TypeError("val must be string, number or Buffer")}function arrayIndexOf(e,t,r,n,i){var o,s=1,a=e.length,u=t.length;if(void 0!==n&&("ucs2"===(n=String(n).toLowerCase())||"ucs-2"===n||"utf16le"===n||"utf-16le"===n)){if(e.length<2||t.length<2)return-1;s=2,a/=2,u/=2,r/=2}function read(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){var c=-1;for(o=r;o<a;o++)if(read(e,o)===read(t,-1===c?0:o-c)){if(-1===c&&(c=o),o-c+1===u)return c*s}else-1!==c&&(o-=o-c),c=-1}else for(r+u>a&&(r=a-u),o=r;o>=0;o--){for(var h=!0,l=0;l<u;l++)if(read(e,o+l)!==read(t,l)){h=!1;break}if(h)return o}return-1}function hexWrite(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=t.length;if(o%2!=0)throw new TypeError("Invalid hex string");n>o/2&&(n=o/2);for(var s=0;s<n;++s){var a=parseInt(t.substr(2*s,2),16);if(isNaN(a))return s;e[r+s]=a}return s}function utf8Write(e,t,r,n){return blitBuffer(utf8ToBytes(t,e.length-r),e,r,n)}function asciiWrite(e,t,r,n){return blitBuffer(function asciiToBytes(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function latin1Write(e,t,r,n){return asciiWrite(e,t,r,n)}function base64Write(e,t,r,n){return blitBuffer(base64ToBytes(t),e,r,n)}function ucs2Write(e,t,r,n){return blitBuffer(function utf16leToBytes(e,t){for(var r,n,i,o=[],s=0;s<e.length&&!((t-=2)<0);++s)r=e.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(t,e.length-r),e,r,n)}function base64Slice(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function utf8Slice(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var o,a,u,c,h=e[i],l=null,f=h>239?4:h>223?3:h>191?2:1;if(i+f<=r)switch(f){case 1:h<128&&(l=h);break;case 2:128==(192&(o=e[i+1]))&&(c=(31&h)<<6|63&o)>127&&(l=c);break;case 3:o=e[i+1],a=e[i+2],128==(192&o)&&128==(192&a)&&(c=(15&h)<<12|(63&o)<<6|63&a)>2047&&(c<55296||c>57343)&&(l=c);break;case 4:o=e[i+1],a=e[i+2],u=e[i+3],128==(192&o)&&128==(192&a)&&128==(192&u)&&(c=(15&h)<<18|(63&o)<<12|(63&a)<<6|63&u)>65535&&c<1114112&&(l=c)}null===l?(l=65533,f=1):l>65535&&(l-=65536,n.push(l>>>10&1023|55296),l=56320|1023&l),n.push(l),i+=f}return function decodeCodePointsArray(e){var t=e.length;if(t<=s)return String.fromCharCode.apply(String,e);var r="",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=s));return r}(n)}t.Buffer=Buffer,t.SlowBuffer=function SlowBuffer(e){+e!=e&&(e=0);return Buffer.alloc(+e)},t.INSPECT_MAX_BYTES=50,Buffer.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function typedArraySupport(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&"function"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=kMaxLength(),Buffer.poolSize=8192,Buffer._augment=function(e){return e.__proto__=Buffer.prototype,e},Buffer.from=function(e,t,r){return from(null,e,t,r)},Buffer.TYPED_ARRAY_SUPPORT&&(Buffer.prototype.__proto__=Uint8Array.prototype,Buffer.__proto__=Uint8Array,"undefined"!=typeof Symbol&&Symbol.species&&Buffer[Symbol.species]===Buffer&&Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:!0})),Buffer.alloc=function(e,t,r){return function alloc(e,t,r,n){return assertSize(t),t<=0?createBuffer(e,t):void 0!==r?"string"==typeof n?createBuffer(e,t).fill(r,n):createBuffer(e,t).fill(r):createBuffer(e,t)}(null,e,t,r)},Buffer.allocUnsafe=function(e){return allocUnsafe(null,e)},Buffer.allocUnsafeSlow=function(e){return allocUnsafe(null,e)},Buffer.isBuffer=function isBuffer(e){return!(null==e||!e._isBuffer)},Buffer.compare=function compare(e,t){if(!Buffer.isBuffer(e)||!Buffer.isBuffer(t))throw new TypeError("Arguments must be Buffers");if(e===t)return 0;for(var r=e.length,n=t.length,i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case"hex":case"utf8":case"utf-8":case"ascii":case"latin1":case"binary":case"base64":case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return!0;default:return!1}},Buffer.concat=function concat(e,t){if(!o(e))throw new TypeError('"list" argument must be an Array of Buffers');if(0===e.length)return Buffer.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=Buffer.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var s=e[r];if(!Buffer.isBuffer(s))throw new TypeError('"list" argument must be an Array of Buffers');s.copy(n,i),i+=s.length}return n},Buffer.byteLength=byteLength,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!=0)throw new RangeError("Buffer size must be a multiple of 16-bits");for(var t=0;t<e;t+=2)swap(this,t,t+1);return this},Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!=0)throw new RangeError("Buffer size must be a multiple of 32-bits");for(var t=0;t<e;t+=4)swap(this,t,t+3),swap(this,t+1,t+2);return this},Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!=0)throw new RangeError("Buffer size must be a multiple of 64-bits");for(var t=0;t<e;t+=8)swap(this,t,t+7),swap(this,t+1,t+6),swap(this,t+2,t+5),swap(this,t+3,t+4);return this},Buffer.prototype.toString=function toString(){var e=0|this.length;return 0===e?"":0===arguments.length?utf8Slice(this,0,e):function slowToString(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return"";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return"";if((r>>>=0)<=(t>>>=0))return"";for(e||(e="utf8");;)switch(e){case"hex":return hexSlice(this,t,r);case"utf8":case"utf-8":return utf8Slice(this,t,r);case"ascii":return asciiSlice(this,t,r);case"latin1":case"binary":return latin1Slice(this,t,r);case"base64":return base64Slice(this,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return utf16leSlice(this,t,r);default:if(n)throw new TypeError("Unknown encoding: "+e);e=(e+"").toLowerCase(),n=!0}}.apply(this,arguments)},Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError("Argument must be a Buffer");return this===e||0===Buffer.compare(this,e)},Buffer.prototype.inspect=function inspect(){var e="",r=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString("hex",0,r).match(/.{2}/g).join(" "),this.length>r&&(e+=" ... ")),"<Buffer "+e+">"},Buffer.prototype.compare=function compare(e,t,r,n,i){if(!Buffer.isBuffer(e))throw new TypeError("Argument must be a Buffer");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError("out of range index");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,i>>>=0,this===e)return 0;for(var o=i-n,s=r-t,a=Math.min(o,s),u=this.slice(n,i),c=e.slice(t,r),h=0;h<a;++h)if(u[h]!==c[h]){o=u[h],s=c[h];break}return o<s?-1:s<o?1:0},Buffer.prototype.includes=function includes(e,t,r){return-1!==this.indexOf(e,t,r)},Buffer.prototype.indexOf=function indexOf(e,t,r){return bidirectionalIndexOf(this,e,t,r,!0)},Buffer.prototype.lastIndexOf=function lastIndexOf(e,t,r){return bidirectionalIndexOf(this,e,t,r,!1)},Buffer.prototype.write=function write(e,t,r,n){if(void 0===t)n="utf8",r=this.length,t=0;else if(void 0===r&&"string"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error("Buffer.write(string, encoding, offset[, length]) is no longer supported");t|=0,isFinite(r)?(r|=0,void 0===n&&(n="utf8")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError("Attempt to write outside buffer bounds");n||(n="utf8");for(var o=!1;;)switch(n){case"hex":return hexWrite(this,e,t,r);case"utf8":case"utf-8":return utf8Write(this,e,t,r);case"ascii":return asciiWrite(this,e,t,r);case"latin1":case"binary":return latin1Write(this,e,t,r);case"base64":return base64Write(this,e,t,r);case"ucs2":case"ucs-2":case"utf16le":case"utf-16le":return ucs2Write(this,e,t,r);default:if(o)throw new TypeError("Unknown encoding: "+n);n=(""+n).toLowerCase(),o=!0}},Buffer.prototype.toJSON=function toJSON(){return{type:"Buffer",data:Array.prototype.slice.call(this._arr||this,0)}};var s=4096;function asciiSlice(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function latin1Slice(e,t,r){var n="";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function hexSlice(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i="",o=t;o<r;++o)i+=toHex(e[o]);return i}function utf16leSlice(e,t,r){for(var n=e.slice(t,r),i="",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function checkOffset(e,t,r){if(e%1!=0||e<0)throw new RangeError("offset is not uint");if(e+t>r)throw new RangeError("Trying to access beyond buffer length")}function checkInt(e,t,r,n,i,o){if(!Buffer.isBuffer(e))throw new TypeError('"buffer" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('"value" argument is out of bounds');if(r+n>e.length)throw new RangeError("Index out of range")}function objectWriteUInt16(e,t,r,n){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-r,2);i<o;++i)e[r+i]=(t&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function objectWriteUInt32(e,t,r,n){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-r,4);i<o;++i)e[r+i]=t>>>8*(n?i:3-i)&255}function checkIEEE754(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError("Index out of range");if(r<0)throw new RangeError("Index out of range")}function writeFloat(e,t,r,n,o){return o||checkIEEE754(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function writeDouble(e,t,r,n,o){return o||checkIEEE754(e,0,r,8),i.write(e,t,r,n,52,8),r+8}Buffer.prototype.slice=function slice(e,t){var r,n=this.length;if(e=~~e,t=void 0===t?n:~~t,e<0?(e+=n)<0&&(e=0):e>n&&(e=n),t<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),Buffer.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=Buffer.prototype;else{var i=t-e;r=new Buffer(i,void 0);for(var o=0;o<i;++o)r[o]=this[o+e]}return r},Buffer.prototype.readUIntLE=function readUIntLE(e,t,r){e|=0,t|=0,r||checkOffset(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n},Buffer.prototype.readUIntBE=function readUIntBE(e,t,r){e|=0,t|=0,r||checkOffset(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},Buffer.prototype.readUInt8=function readUInt8(e,t){return t||checkOffset(e,1,this.length),this[e]},Buffer.prototype.readUInt16LE=function readUInt16LE(e,t){return t||checkOffset(e,2,this.length),this[e]|this[e+1]<<8},Buffer.prototype.readUInt16BE=function readUInt16BE(e,t){return t||checkOffset(e,2,this.length),this[e]<<8|this[e+1]},Buffer.prototype.readUInt32LE=function readUInt32LE(e,t){return t||checkOffset(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},Buffer.prototype.readUInt32BE=function readUInt32BE(e,t){return t||checkOffset(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},Buffer.prototype.readIntLE=function readIntLE(e,t,r){e|=0,t|=0,r||checkOffset(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*t)),n},Buffer.prototype.readIntBE=function readIntBE(e,t,r){e|=0,t|=0,r||checkOffset(e,t,this.length);for(var n=t,i=1,o=this[e+--n];n>0&&(i*=256);)o+=this[e+--n]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*t)),o},Buffer.prototype.readInt8=function readInt8(e,t){return t||checkOffset(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},Buffer.prototype.readInt16LE=function readInt16LE(e,t){t||checkOffset(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},Buffer.prototype.readInt16BE=function readInt16BE(e,t){t||checkOffset(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},Buffer.prototype.readInt32LE=function readInt32LE(e,t){return t||checkOffset(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},Buffer.prototype.readInt32BE=function readInt32BE(e,t){return t||checkOffset(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},Buffer.prototype.readFloatLE=function readFloatLE(e,t){return t||checkOffset(e,4,this.length),i.read(this,e,!0,23,4)},Buffer.prototype.readFloatBE=function readFloatBE(e,t){return t||checkOffset(e,4,this.length),i.read(this,e,!1,23,4)},Buffer.prototype.readDoubleLE=function readDoubleLE(e,t){return t||checkOffset(e,8,this.length),i.read(this,e,!0,52,8)},Buffer.prototype.readDoubleBE=function readDoubleBE(e,t){return t||checkOffset(e,8,this.length),i.read(this,e,!1,52,8)},Buffer.prototype.writeUIntLE=function writeUIntLE(e,t,r,n){(e=+e,t|=0,r|=0,n)||checkInt(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,o=0;for(this[t]=255&e;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r},Buffer.prototype.writeUIntBE=function writeUIntBE(e,t,r,n){(e=+e,t|=0,r|=0,n)||checkInt(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r},Buffer.prototype.writeUInt8=function writeUInt8(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,1,255,0),Buffer.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,2,65535,0),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):objectWriteUInt16(this,e,t,!0),t+2},Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,2,65535,0),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):objectWriteUInt16(this,e,t,!1),t+2},Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,4,4294967295,0),Buffer.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):objectWriteUInt32(this,e,t,!0),t+4},Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,4,4294967295,0),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):objectWriteUInt32(this,e,t,!1),t+4},Buffer.prototype.writeIntLE=function writeIntLE(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);checkInt(this,e,t,r,i-1,-i)}var o=0,s=1,a=0;for(this[t]=255&e;++o<r&&(s*=256);)e<0&&0===a&&0!==this[t+o-1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+r},Buffer.prototype.writeIntBE=function writeIntBE(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);checkInt(this,e,t,r,i-1,-i)}var o=r-1,s=1,a=0;for(this[t+o]=255&e;--o>=0&&(s*=256);)e<0&&0===a&&0!==this[t+o+1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+r},Buffer.prototype.writeInt8=function writeInt8(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,1,127,-128),Buffer.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},Buffer.prototype.writeInt16LE=function writeInt16LE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,2,32767,-32768),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):objectWriteUInt16(this,e,t,!0),t+2},Buffer.prototype.writeInt16BE=function writeInt16BE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,2,32767,-32768),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):objectWriteUInt16(this,e,t,!1),t+2},Buffer.prototype.writeInt32LE=function writeInt32LE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,4,2147483647,-2147483648),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):objectWriteUInt32(this,e,t,!0),t+4},Buffer.prototype.writeInt32BE=function writeInt32BE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):objectWriteUInt32(this,e,t,!1),t+4},Buffer.prototype.writeFloatLE=function writeFloatLE(e,t,r){return writeFloat(this,e,t,!0,r)},Buffer.prototype.writeFloatBE=function writeFloatBE(e,t,r){return writeFloat(this,e,t,!1,r)},Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,t,r){return writeDouble(this,e,t,!0,r)},Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,t,r){return writeDouble(this,e,t,!1,r)},Buffer.prototype.copy=function copy(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError("targetStart out of bounds");if(r<0||r>=this.length)throw new RangeError("sourceStart out of bounds");if(n<0)throw new RangeError("sourceEnd out of bounds");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,o=n-r;if(this===e&&r<t&&t<n)for(i=o-1;i>=0;--i)e[i+t]=this[i+r];else if(o<1e3||!Buffer.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+o),t);return o},Buffer.prototype.fill=function fill(e,t,r,n){if("string"==typeof e){if("string"==typeof t?(n=t,t=0,r=this.length):"string"==typeof r&&(n=r,r=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==n&&"string"!=typeof n)throw new TypeError("encoding must be a string");if("string"==typeof n&&!Buffer.isEncoding(n))throw new TypeError("Unknown encoding: "+n)}else"number"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError("Out of range index");if(r<=t)return this;var o;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),"number"==typeof e)for(o=t;o<r;++o)this[o]=e;else{var s=Buffer.isBuffer(e)?e:utf8ToBytes(new Buffer(e,n).toString()),a=s.length;for(o=0;o<r-t;++o)this[o+t]=s[o%a]}return this};var a=/[^+\/0-9A-Za-z-_]/g;function toHex(e){return e<16?"0"+e.toString(16):e.toString(16)}function utf8ToBytes(e,t){var r;t=t||1/0;for(var n=e.length,i=null,o=[],s=0;s<n;++s){if((r=e.charCodeAt(s))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error("Invalid code point");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function base64ToBytes(e){return n.toByteArray(function base64clean(e){if((e=function stringtrim(e){return e.trim?e.trim():e.replace(/^\s+|\s+$/g,"")}(e).replace(a,"")).length<2)return"";for(;e.length%4!=0;)e+="=";return e}(e))}function blitBuffer(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}}).call(this,r(27))},function(e,t){var r;r=function(){return this}();try{r=r||new Function("return this")()}catch(e){"object"==typeof window&&(r=window)}e.exports=r},function(e,t,r){"use strict";t.byteLength=function byteLength(e){var t=getLens(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function toByteArray(e){for(var t,r=getLens(e),n=r[0],s=r[1],a=new o(function _byteLength(e,t,r){return 3*(t+r)/4-r}(0,n,s)),u=0,c=s>0?n-4:n,h=0;h<c;h+=4)t=i[e.charCodeAt(h)]<<18|i[e.charCodeAt(h+1)]<<12|i[e.charCodeAt(h+2)]<<6|i[e.charCodeAt(h+3)],a[u++]=t>>16&255,a[u++]=t>>8&255,a[u++]=255&t;2===s&&(t=i[e.charCodeAt(h)]<<2|i[e.charCodeAt(h+1)]>>4,a[u++]=255&t);1===s&&(t=i[e.charCodeAt(h)]<<10|i[e.charCodeAt(h+1)]<<4|i[e.charCodeAt(h+2)]>>2,a[u++]=t>>8&255,a[u++]=255&t);return a},t.fromByteArray=function fromByteArray(e){for(var t,r=e.length,i=r%3,o=[],s=0,a=r-i;s<a;s+=16383)o.push(encodeChunk(e,s,s+16383>a?a:s+16383));1===i?(t=e[r-1],o.push(n[t>>2]+n[t<<4&63]+"==")):2===i&&(t=(e[r-2]<<8)+e[r-1],o.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+"="));return o.join("")};for(var n=[],i=[],o="undefined"!=typeof Uint8Array?Uint8Array:Array,s="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/",a=0,u=s.length;a<u;++a)n[a]=s[a],i[s.charCodeAt(a)]=a;function getLens(e){var t=e.length;if(t%4>0)throw new Error("Invalid string. Length must be a multiple of 4");var r=e.indexOf("=");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function tripletToBase64(e){return n[e>>18&63]+n[e>>12&63]+n[e>>6&63]+n[63&e]}function encodeChunk(e,t,r){for(var n,i=[],o=t;o<r;o+=3)n=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),i.push(tripletToBase64(n));return i.join("")}i["-".charCodeAt(0)]=62,i["_".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,r,n,i){var o,s,a=8*i-n-1,u=(1<<a)-1,c=u>>1,h=-7,l=r?i-1:0,f=r?-1:1,g=e[t+l];for(l+=f,o=g&(1<<-h)-1,g>>=-h,h+=a;h>0;o=256*o+e[t+l],l+=f,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=n;h>0;s=256*s+e[t+l],l+=f,h-=8);if(0===o)o=1-c;else{if(o===u)return s?NaN:1/0*(g?-1:1);s+=Math.pow(2,n),o-=c}return(g?-1:1)*s*Math.pow(2,o-n)},t.write=function(e,t,r,n,i,o){var s,a,u,c=8*o-i-1,h=(1<<c)-1,l=h>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,g=n?0:o-1,p=n?1:-1,d=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,s=h):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),(t+=s+l>=1?f/u:f*Math.pow(2,1-l))*u>=2&&(s++,u/=2),s+l>=h?(a=0,s=h):s+l>=1?(a=(t*u-1)*Math.pow(2,i),s+=l):(a=t*Math.pow(2,l-1)*Math.pow(2,i),s=0));i>=8;e[r+g]=255&a,g+=p,a/=256,i-=8);for(s=s<<i|a,c+=i;c>0;e[r+g]=255&s,g+=p,s/=256,c-=8);e[r+g-p]|=128*d}},function(e,t){var r={}.toString;e.exports=Array.isArray||function(e){return"[object Array]"==r.call(e)}},function(e,t,r){var n=r(32),i=r(33);e.exports=function v4(e,t,r){var o=t&&r||0;"string"==typeof e&&(t="binary"===e?new Array(16):null,e=null);var s=(e=e||{}).random||(e.rng||n)();if(s[6]=15&s[6]|64,s[8]=63&s[8]|128,t)for(var a=0;a<16;++a)t[o+a]=s[a];return t||i(s)}},function(e,t){var r="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(r){var n=new Uint8Array(16);e.exports=function whatwgRNG(){return r(n),n}}else{var i=new Array(16);e.exports=function mathRNG(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),i[t]=e>>>((3&t)<<3)&255;return i}}},function(e,t){for(var r=[],n=0;n<256;++n)r[n]=(n+256).toString(16).substr(1);e.exports=function bytesToUuid(e,t){var n=t||0,i=r;return[i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],"-",i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]]].join("")}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SigninResponse=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(3);t.SigninResponse=function(){function SigninResponse(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"#";!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,SigninResponse);var r=i.UrlUtility.parseUrlFragment(e,t);this.error=r.error,this.error_description=r.error_description,this.error_uri=r.error_uri,this.code=r.code,this.state=r.state,this.id_token=r.id_token,this.session_state=r.session_state,this.access_token=r.access_token,this.token_type=r.token_type,this.scope=r.scope,this.profile=void 0,this.expires_in=r.expires_in}return n(SigninResponse,[{key:"expires_in",get:function get(){if(this.expires_at){var e=parseInt(Date.now()/1e3);return this.expires_at-e}},set:function set(e){var t=parseInt(e);if("number"==typeof t&&t>0){var r=parseInt(Date.now()/1e3);this.expires_at=r+t}}},{key:"expired",get:function get(){var e=this.expires_in;if(void 0!==e)return e<=0}},{key:"scopes",get:function get(){return(this.scope||"").split(" ")}},{key:"isOpenIdConnect",get:function get(){return this.scopes.indexOf("openid")>=0||!!this.id_token}}]),SigninResponse}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SignoutRequest=void 0;var n=r(0),i=r(3),o=r(8);t.SignoutRequest=function SignoutRequest(e){var t=e.url,r=e.id_token_hint,s=e.post_logout_redirect_uri,a=e.data,u=e.extraQueryParams;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,SignoutRequest),!t)throw n.Log.error("SignoutRequest.ctor: No url passed"),new Error("url");for(var c in r&&(t=i.UrlUtility.addQueryParam(t,"id_token_hint",r)),s&&(t=i.UrlUtility.addQueryParam(t,"post_logout_redirect_uri",s),a&&(this.state=new o.State({data:a}),t=i.UrlUtility.addQueryParam(t,"state",this.state.id))),u)t=i.UrlUtility.addQueryParam(t,c,u[c]);this.url=t}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SignoutResponse=void 0;var n=r(3);t.SignoutResponse=function SignoutResponse(e){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,SignoutResponse);var t=n.UrlUtility.parseUrlFragment(e,"?");this.error=t.error,this.error_description=t.error_description,this.error_uri=t.error_uri,this.state=t.state}},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.InMemoryWebStorage=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);t.InMemoryWebStorage=function(){function InMemoryWebStorage(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,InMemoryWebStorage),this._data={}}return InMemoryWebStorage.prototype.getItem=function getItem(e){return i.Log.debug("InMemoryWebStorage.getItem",e),this._data[e]},InMemoryWebStorage.prototype.setItem=function setItem(e,t){i.Log.debug("InMemoryWebStorage.setItem",e),this._data[e]=t},InMemoryWebStorage.prototype.removeItem=function removeItem(e){i.Log.debug("InMemoryWebStorage.removeItem",e),delete this._data[e]},InMemoryWebStorage.prototype.key=function key(e){return Object.getOwnPropertyNames(this._data)[e]},n(InMemoryWebStorage,[{key:"length",get:function get(){return Object.getOwnPropertyNames(this._data).length}}]),InMemoryWebStorage}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.UserManager=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(9),s=r(39),a=r(15),u=r(45),c=r(47),h=r(18),l=r(20),f=r(10),g=r(4);t.UserManager=function(e){function UserManager(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.SilentRenewService,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:h.SessionMonitor,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l.TokenRevocationClient,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:f.TokenClient,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:g.JoseUtil;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,UserManager),t instanceof s.UserManagerSettings||(t=new s.UserManagerSettings(t));var d=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,e.call(this,t));return d._events=new u.UserManagerEvents(t),d._silentRenewService=new r(d),d.settings.automaticSilentRenew&&(i.Log.debug("UserManager.ctor: automaticSilentRenew is configured, setting up silent renew"),d.startSilentRenew()),d.settings.monitorSession&&(i.Log.debug("UserManager.ctor: monitorSession is configured, setting up session monitor"),d._sessionMonitor=new n(d)),d._tokenRevocationClient=new o(d._settings),d._tokenClient=new a(d._settings),d._joseUtil=p,d}return function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(UserManager,e),UserManager.prototype.getUser=function getUser(){var e=this;return this._loadUser().then(function(t){return t?(i.Log.info("UserManager.getUser: user loaded"),e._events.load(t,!1),t):(i.Log.info("UserManager.getUser: user not found in storage"),null)})},UserManager.prototype.removeUser=function removeUser(){var e=this;return this.storeUser(null).then(function(){i.Log.info("UserManager.removeUser: user removed from storage"),e._events.unload()})},UserManager.prototype.signinRedirect=function signinRedirect(e){return this._signinStart(e,this._redirectNavigator).then(function(){i.Log.info("UserManager.signinRedirect: successful")})},UserManager.prototype.signinRedirectCallback=function signinRedirectCallback(e){return this._signinEnd(e||this._redirectNavigator.url).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info("UserManager.signinRedirectCallback: successful, signed in sub: ",e.profile.sub):i.Log.info("UserManager.signinRedirectCallback: no sub")),e})},UserManager.prototype.signinPopup=function signinPopup(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.redirect_uri||this.settings.popup_redirect_uri||this.settings.redirect_uri;return t?(e.redirect_uri=t,e.display="popup",this._signin(e,this._popupNavigator,{startUrl:t,popupWindowFeatures:e.popupWindowFeatures||this.settings.popupWindowFeatures,popupWindowTarget:e.popupWindowTarget||this.settings.popupWindowTarget}).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info("UserManager.signinPopup: signinPopup successful, signed in sub: ",e.profile.sub):i.Log.info("UserManager.signinPopup: no sub")),e})):(i.Log.error("UserManager.signinPopup: No popup_redirect_uri or redirect_uri configured"),Promise.reject(new Error("No popup_redirect_uri or redirect_uri configured")))},UserManager.prototype.signinPopupCallback=function signinPopupCallback(e){return this._signinCallback(e,this._popupNavigator).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info("UserManager.signinPopupCallback: successful, signed in sub: ",e.profile.sub):i.Log.info("UserManager.signinPopupCallback: no sub")),e}).catch(function(e){i.Log.error(e.message)})},UserManager.prototype.signinSilent=function signinSilent(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this._loadUser().then(function(r){return r&&r.refresh_token?(t.refresh_token=r.refresh_token,e._useRefreshToken(t)):(t.id_token_hint=t.id_token_hint||e.settings.includeIdTokenInSilentRenew&&r&&r.id_token,e._signinSilentIframe(t))})},UserManager.prototype._useRefreshToken=function _useRefreshToken(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this._tokenClient.exchangeRefreshToken(t).then(function(t){return t?t.access_token?e._loadUser().then(function(r){if(r){var n=Promise.resolve();return t.id_token&&(n=e._validateIdTokenFromTokenRefreshToken(r.profile,t.id_token)),n.then(function(){return i.Log.debug("UserManager._useRefreshToken: refresh token response success"),r.access_token=t.access_token,r.refresh_token=t.refresh_token||r.refresh_token,r.expires_in=t.expires_in,e.storeUser(r).then(function(){return e._events.load(r),r})})}return null}):(i.Log.error("UserManager._useRefreshToken: No access token returned from token endpoint"),Promise.reject("No access token returned from token endpoint")):(i.Log.error("UserManager._useRefreshToken: No response returned from token endpoint"),Promise.reject("No response returned from token endpoint"))})},UserManager.prototype._validateIdTokenFromTokenRefreshToken=function _validateIdTokenFromTokenRefreshToken(e,t){var r=this;return this._metadataService.getIssuer().then(function(n){return r._joseUtil.validateJwtAttributes(t,n,r._settings.client_id,r._settings.clockSkew).then(function(t){return t?t.sub!==e.sub?(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: sub in id_token does not match current sub"),Promise.reject(new Error("sub in id_token does not match current sub"))):t.auth_time&&t.auth_time!==e.auth_time?(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: auth_time in id_token does not match original auth_time"),Promise.reject(new Error("auth_time in id_token does not match original auth_time"))):t.azp&&t.azp!==e.azp?(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: azp in id_token does not match original azp"),Promise.reject(new Error("azp in id_token does not match original azp"))):!t.azp&&e.azp?(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: azp not in id_token, but present in original id_token"),Promise.reject(new Error("azp not in id_token, but present in original id_token"))):void 0:(i.Log.error("UserManager._validateIdTokenFromTokenRefreshToken: Failed to validate id_token"),Promise.reject(new Error("Failed to validate id_token")))})})},UserManager.prototype._signinSilentIframe=function _signinSilentIframe(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.redirect_uri||this.settings.silent_redirect_uri;return t?(e.redirect_uri=t,e.prompt=e.prompt||"none",this._signin(e,this._iframeNavigator,{startUrl:t,silentRequestTimeout:e.silentRequestTimeout||this.settings.silentRequestTimeout}).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info("UserManager.signinSilent: successful, signed in sub: ",e.profile.sub):i.Log.info("UserManager.signinSilent: no sub")),e})):(i.Log.error("UserManager.signinSilent: No silent_redirect_uri configured"),Promise.reject(new Error("No silent_redirect_uri configured")))},UserManager.prototype.signinSilentCallback=function signinSilentCallback(e){return this._signinCallback(e,this._iframeNavigator).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info("UserManager.signinSilentCallback: successful, signed in sub: ",e.profile.sub):i.Log.info("UserManager.signinSilentCallback: no sub")),e})},UserManager.prototype.querySessionStatus=function querySessionStatus(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.redirect_uri||this.settings.silent_redirect_uri;return r?(t.redirect_uri=r,t.prompt="none",t.response_type=t.response_type||this.settings.query_status_response_type,t.scope="openid",this._signinStart(t,this._iframeNavigator,{startUrl:r,silentRequestTimeout:t.silentRequestTimeout||this.settings.silentRequestTimeout}).then(function(t){return e.processSigninResponse(t.url).then(function(e){if(i.Log.debug("UserManager.querySessionStatus: got signin response"),e.session_state&&e.profile.sub)return i.Log.info("UserManager.querySessionStatus: querySessionStatus success for sub: ",e.profile.sub),{session_state:e.session_state,sub:e.profile.sub,sid:e.profile.sid};i.Log.info("querySessionStatus successful, user not authenticated")})})):(i.Log.error("UserManager.querySessionStatus: No silent_redirect_uri configured"),Promise.reject(new Error("No silent_redirect_uri configured")))},UserManager.prototype._signin=function _signin(e,t){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._signinStart(e,t,n).then(function(e){return r._signinEnd(e.url)})},UserManager.prototype._signinStart=function _signinStart(e,t){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return t.prepare(n).then(function(t){return i.Log.debug("UserManager._signinStart: got navigator window handle"),r.createSigninRequest(e).then(function(e){return i.Log.debug("UserManager._signinStart: got signin request"),n.url=e.url,n.id=e.state.id,t.navigate(n)}).catch(function(e){throw t.close&&(i.Log.debug("UserManager._signinStart: Error after preparing navigator, closing navigator window"),t.close()),e})})},UserManager.prototype._signinEnd=function _signinEnd(e){var t=this;return this.processSigninResponse(e).then(function(e){i.Log.debug("UserManager._signinEnd: got signin response");var r=new a.User(e);return t.storeUser(r).then(function(){return i.Log.debug("UserManager._signinEnd: user stored"),t._events.load(r),r})})},UserManager.prototype._signinCallback=function _signinCallback(e,t){return i.Log.debug("UserManager._signinCallback"),t.callback(e)},UserManager.prototype.signoutRedirect=function signoutRedirect(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.post_logout_redirect_uri||this.settings.post_logout_redirect_uri;return t&&(e.post_logout_redirect_uri=t),this._signoutStart(e,this._redirectNavigator).then(function(){i.Log.info("UserManager.signoutRedirect: successful")})},UserManager.prototype.signoutRedirectCallback=function signoutRedirectCallback(e){return this._signoutEnd(e||this._redirectNavigator.url).then(function(e){return i.Log.info("UserManager.signoutRedirectCallback: successful"),e})},UserManager.prototype.signoutPopup=function signoutPopup(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.post_logout_redirect_uri||this.settings.popup_post_logout_redirect_uri||this.settings.post_logout_redirect_uri;return e.post_logout_redirect_uri=t,e.display="popup",e.post_logout_redirect_uri&&(e.state=e.state||{}),this._signout(e,this._popupNavigator,{startUrl:t,popupWindowFeatures:e.popupWindowFeatures||this.settings.popupWindowFeatures,popupWindowTarget:e.popupWindowTarget||this.settings.popupWindowTarget}).then(function(){i.Log.info("UserManager.signoutPopup: successful")})},UserManager.prototype.signoutPopupCallback=function signoutPopupCallback(e,t){void 0===t&&"boolean"==typeof e&&(t=e,e=null);return this._popupNavigator.callback(e,t,"?").then(function(){i.Log.info("UserManager.signoutPopupCallback: successful")})},UserManager.prototype._signout=function _signout(e,t){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._signoutStart(e,t,n).then(function(e){return r._signoutEnd(e.url)})},UserManager.prototype._signoutStart=function _signoutStart(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=this,r=arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.prepare(n).then(function(r){return i.Log.debug("UserManager._signoutStart: got navigator window handle"),t._loadUser().then(function(o){return i.Log.debug("UserManager._signoutStart: loaded current user from storage"),(t._settings.revokeAccessTokenOnSignout?t._revokeInternal(o):Promise.resolve()).then(function(){var s=e.id_token_hint||o&&o.id_token;return s&&(i.Log.debug("UserManager._signoutStart: Setting id_token into signout request"),e.id_token_hint=s),t.removeUser().then(function(){return i.Log.debug("UserManager._signoutStart: user removed, creating signout request"),t.createSignoutRequest(e).then(function(e){return i.Log.debug("UserManager._signoutStart: got signout request"),n.url=e.url,e.state&&(n.id=e.state.id),r.navigate(n)})})})}).catch(function(e){throw r.close&&(i.Log.debug("UserManager._signoutStart: Error after preparing navigator, closing navigator window"),r.close()),e})})},UserManager.prototype._signoutEnd=function _signoutEnd(e){return this.processSignoutResponse(e).then(function(e){return i.Log.debug("UserManager._signoutEnd: got signout response"),e})},UserManager.prototype.revokeAccessToken=function revokeAccessToken(){var e=this;return this._loadUser().then(function(t){return e._revokeInternal(t,!0).then(function(r){if(r)return i.Log.debug("UserManager.revokeAccessToken: removing token properties from user and re-storing"),t.access_token=null,t.refresh_token=null,t.expires_at=null,t.token_type=null,e.storeUser(t).then(function(){i.Log.debug("UserManager.revokeAccessToken: user stored"),e._events.load(t)})})}).then(function(){i.Log.info("UserManager.revokeAccessToken: access token revoked successfully")})},UserManager.prototype._revokeInternal=function _revokeInternal(e,t){var r=this;if(e){var n=e.access_token,o=e.refresh_token;return this._revokeAccessTokenInternal(n,t).then(function(e){return r._revokeRefreshTokenInternal(o,t).then(function(t){return e||t||i.Log.debug("UserManager.revokeAccessToken: no need to revoke due to no token(s), or JWT format"),e||t})})}return Promise.resolve(!1)},UserManager.prototype._revokeAccessTokenInternal=function _revokeAccessTokenInternal(e,t){return!e||e.indexOf(".")>=0?Promise.resolve(!1):this._tokenRevocationClient.revoke(e,t).then(function(){return!0})},UserManager.prototype._revokeRefreshTokenInternal=function _revokeRefreshTokenInternal(e,t){return e?this._tokenRevocationClient.revoke(e,t,"refresh_token").then(function(){return!0}):Promise.resolve(!1)},UserManager.prototype.startSilentRenew=function startSilentRenew(){this._silentRenewService.start()},UserManager.prototype.stopSilentRenew=function stopSilentRenew(){this._silentRenewService.stop()},UserManager.prototype._loadUser=function _loadUser(){return this._userStore.get(this._userStoreKey).then(function(e){return e?(i.Log.debug("UserManager._loadUser: user storageString loaded"),a.User.fromStorageString(e)):(i.Log.debug("UserManager._loadUser: no user storageString"),null)})},UserManager.prototype.storeUser=function storeUser(e){if(e){i.Log.debug("UserManager.storeUser: storing user");var t=e.toStorageString();return this._userStore.set(this._userStoreKey,t)}return i.Log.debug("storeUser.storeUser: removing user"),this._userStore.remove(this._userStoreKey)},n(UserManager,[{key:"_redirectNavigator",get:function get(){return this.settings.redirectNavigator}},{key:"_popupNavigator",get:function get(){return this.settings.popupNavigator}},{key:"_iframeNavigator",get:function get(){return this.settings.iframeNavigator}},{key:"_userStore",get:function get(){return this.settings.userStore}},{key:"events",get:function get(){return this._events}},{key:"_userStoreKey",get:function get(){return"user:"+this.settings.authority+":"+this.settings.client_id}}]),UserManager}(o.OidcClient)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.UserManagerSettings=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=(r(0),r(5)),o=r(40),s=r(41),a=r(43),u=r(6),c=r(1),h=r(12);var l=60,f=2e3;t.UserManagerSettings=function(e){function UserManagerSettings(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.popup_redirect_uri,n=t.popup_post_logout_redirect_uri,i=t.popupWindowFeatures,g=t.popupWindowTarget,p=t.silent_redirect_uri,d=t.silentRequestTimeout,v=t.automaticSilentRenew,y=void 0!==v&&v,m=t.includeIdTokenInSilentRenew,_=void 0===m||m,S=t.monitorSession,b=void 0===S||S,F=t.checkSessionInterval,w=void 0===F?f:F,E=t.stopCheckSessionOnError,x=void 0===E||E,C=t.query_status_response_type,k=t.revokeAccessTokenOnSignout,A=void 0!==k&&k,P=t.accessTokenExpiringNotificationTime,I=void 0===P?l:P,B=t.redirectNavigator,R=void 0===B?new o.RedirectNavigator:B,T=t.popupNavigator,U=void 0===T?new s.PopupNavigator:T,D=t.iframeNavigator,L=void 0===D?new a.IFrameNavigator:D,M=t.userStore,N=void 0===M?new u.WebStorageStateStore({store:c.Global.sessionStorage}):M;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,UserManagerSettings);var O=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,e.call(this,arguments[0]));return O._popup_redirect_uri=r,O._popup_post_logout_redirect_uri=n,O._popupWindowFeatures=i,O._popupWindowTarget=g,O._silent_redirect_uri=p,O._silentRequestTimeout=d,O._automaticSilentRenew=y,O._includeIdTokenInSilentRenew=_,O._accessTokenExpiringNotificationTime=I,O._monitorSession=b,O._checkSessionInterval=w,O._stopCheckSessionOnError=x,C?O._query_status_response_type=C:arguments[0]&&arguments[0].response_type?O._query_status_response_type=h.SigninRequest.isOidc(arguments[0].response_type)?"id_token":"code":O._query_status_response_type="id_token",O._revokeAccessTokenOnSignout=A,O._redirectNavigator=R,O._popupNavigator=U,O._iframeNavigator=L,O._userStore=N,O}return function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(UserManagerSettings,e),n(UserManagerSettings,[{key:"popup_redirect_uri",get:function get(){return this._popup_redirect_uri}},{key:"popup_post_logout_redirect_uri",get:function get(){return this._popup_post_logout_redirect_uri}},{key:"popupWindowFeatures",get:function get(){return this._popupWindowFeatures}},{key:"popupWindowTarget",get:function get(){return this._popupWindowTarget}},{key:"silent_redirect_uri",get:function get(){return this._silent_redirect_uri}},{key:"silentRequestTimeout",get:function get(){return this._silentRequestTimeout}},{key:"automaticSilentRenew",get:function get(){return this._automaticSilentRenew}},{key:"includeIdTokenInSilentRenew",get:function get(){return this._includeIdTokenInSilentRenew}},{key:"accessTokenExpiringNotificationTime",get:function get(){return this._accessTokenExpiringNotificationTime}},{key:"monitorSession",get:function get(){return this._monitorSession}},{key:"checkSessionInterval",get:function get(){return this._checkSessionInterval}},{key:"stopCheckSessionOnError",get:function get(){return this._stopCheckSessionOnError}},{key:"query_status_response_type",get:function get(){return this._query_status_response_type}},{key:"revokeAccessTokenOnSignout",get:function get(){return this._revokeAccessTokenOnSignout}},{key:"redirectNavigator",get:function get(){return this._redirectNavigator}},{key:"popupNavigator",get:function get(){return this._popupNavigator}},{key:"iframeNavigator",get:function get(){return this._iframeNavigator}},{key:"userStore",get:function get(){return this._userStore}}]),UserManagerSettings}(i.OidcClientSettings)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.RedirectNavigator=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);t.RedirectNavigator=function(){function RedirectNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,RedirectNavigator)}return RedirectNavigator.prototype.prepare=function prepare(){return Promise.resolve(this)},RedirectNavigator.prototype.navigate=function navigate(e){return e&&e.url?(window.location=e.url,Promise.resolve()):(i.Log.error("RedirectNavigator.navigate: No url provided"),Promise.reject(new Error("No url provided")))},n(RedirectNavigator,[{key:"url",get:function get(){return window.location.href}}]),RedirectNavigator}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PopupNavigator=void 0;var n=r(0),i=r(42);t.PopupNavigator=function(){function PopupNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,PopupNavigator)}return PopupNavigator.prototype.prepare=function prepare(e){var t=new i.PopupWindow(e);return Promise.resolve(t)},PopupNavigator.prototype.callback=function callback(e,t,r){n.Log.debug("PopupNavigator.callback");try{return i.PopupWindow.notifyOpener(e,t,r),Promise.resolve()}catch(e){return Promise.reject(e)}},PopupNavigator}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.PopupWindow=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(3);var s=500,a="location=no,toolbar=no,width=500,height=500,left=100,top=100;",u="_blank";t.PopupWindow=function(){function PopupWindow(e){var t=this;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,PopupWindow),this._promise=new Promise(function(e,r){t._resolve=e,t._reject=r});var r=e.popupWindowTarget||u,n=e.popupWindowFeatures||a;this._popup=window.open("",r,n),this._popup&&(i.Log.debug("PopupWindow.ctor: popup successfully created"),this._checkForPopupClosedTimer=window.setInterval(this._checkForPopupClosed.bind(this),s))}return PopupWindow.prototype.navigate=function navigate(e){return this._popup?e&&e.url?(i.Log.debug("PopupWindow.navigate: Setting URL in popup"),this._id=e.id,this._id&&(window["popupCallback_"+e.id]=this._callback.bind(this)),this._popup.focus(),this._popup.window.location=e.url):(this._error("PopupWindow.navigate: no url provided"),this._error("No url provided")):this._error("PopupWindow.navigate: Error opening popup window"),this.promise},PopupWindow.prototype._success=function _success(e){i.Log.debug("PopupWindow.callback: Successful response from popup window"),this._cleanup(),this._resolve(e)},PopupWindow.prototype._error=function _error(e){i.Log.error("PopupWindow.error: ",e),this._cleanup(),this._reject(new Error(e))},PopupWindow.prototype.close=function close(){this._cleanup(!1)},PopupWindow.prototype._cleanup=function _cleanup(e){i.Log.debug("PopupWindow.cleanup"),window.clearInterval(this._checkForPopupClosedTimer),this._checkForPopupClosedTimer=null,delete window["popupCallback_"+this._id],this._popup&&!e&&this._popup.close(),this._popup=null},PopupWindow.prototype._checkForPopupClosed=function _checkForPopupClosed(){this._popup&&!this._popup.closed||this._error("Popup window closed")},PopupWindow.prototype._callback=function _callback(e,t){this._cleanup(t),e?(i.Log.debug("PopupWindow.callback success"),this._success({url:e})):(i.Log.debug("PopupWindow.callback: Invalid response from popup"),this._error("Invalid response from popup"))},PopupWindow.notifyOpener=function notifyOpener(e,t,r){if(window.opener){if(e=e||window.location.href){var n=o.UrlUtility.parseUrlFragment(e,r);if(n.state){var s="popupCallback_"+n.state,a=window.opener[s];a?(i.Log.debug("PopupWindow.notifyOpener: passing url message to opener"),a(e,t)):i.Log.warn("PopupWindow.notifyOpener: no matching callback found on opener")}else i.Log.warn("PopupWindow.notifyOpener: no state found in response url")}}else i.Log.warn("PopupWindow.notifyOpener: no window.opener. Can't complete notification.")},n(PopupWindow,[{key:"promise",get:function get(){return this._promise}}]),PopupWindow}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.IFrameNavigator=void 0;var n=r(0),i=r(44);t.IFrameNavigator=function(){function IFrameNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,IFrameNavigator)}return IFrameNavigator.prototype.prepare=function prepare(e){var t=new i.IFrameWindow(e);return Promise.resolve(t)},IFrameNavigator.prototype.callback=function callback(e){n.Log.debug("IFrameNavigator.callback");try{return i.IFrameWindow.notifyParent(e),Promise.resolve()}catch(e){return Promise.reject(e)}},IFrameNavigator}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.IFrameWindow=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);t.IFrameWindow=function(){function IFrameWindow(e){var t=this;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,IFrameWindow),this._promise=new Promise(function(e,r){t._resolve=e,t._reject=r}),this._boundMessageEvent=this._message.bind(this),window.addEventListener("message",this._boundMessageEvent,!1),this._frame=window.document.createElement("iframe"),this._frame.style.visibility="hidden",this._frame.style.position="absolute",this._frame.style.display="none",this._frame.style.width=0,this._frame.style.height=0,window.document.body.appendChild(this._frame)}return IFrameWindow.prototype.navigate=function navigate(e){if(e&&e.url){var t=e.silentRequestTimeout||1e4;i.Log.debug("IFrameWindow.navigate: Using timeout of:",t),this._timer=window.setTimeout(this._timeout.bind(this),t),this._frame.src=e.url}else this._error("No url provided");return this.promise},IFrameWindow.prototype._success=function _success(e){this._cleanup(),i.Log.debug("IFrameWindow: Successful response from frame window"),this._resolve(e)},IFrameWindow.prototype._error=function _error(e){this._cleanup(),i.Log.error(e),this._reject(new Error(e))},IFrameWindow.prototype.close=function close(){this._cleanup()},IFrameWindow.prototype._cleanup=function _cleanup(){this._frame&&(i.Log.debug("IFrameWindow: cleanup"),window.removeEventListener("message",this._boundMessageEvent,!1),window.clearTimeout(this._timer),window.document.body.removeChild(this._frame),this._timer=null,this._frame=null,this._boundMessageEvent=null)},IFrameWindow.prototype._timeout=function _timeout(){i.Log.debug("IFrameWindow.timeout"),this._error("Frame window timed out")},IFrameWindow.prototype._message=function _message(e){if(i.Log.debug("IFrameWindow.message"),this._timer&&e.origin===this._origin&&e.source===this._frame.contentWindow){var t=e.data;t?this._success({url:t}):this._error("Invalid response from frame")}},IFrameWindow.notifyParent=function notifyParent(e){i.Log.debug("IFrameWindow.notifyParent"),window.frameElement&&(e=e||window.location.href)&&(i.Log.debug("IFrameWindow.notifyParent: posting url message to parent"),window.parent.postMessage(e,location.protocol+"//"+location.host))},n(IFrameWindow,[{key:"promise",get:function get(){return this._promise}},{key:"_origin",get:function get(){return location.protocol+"//"+location.host}}]),IFrameWindow}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.UserManagerEvents=void 0;var n=r(0),i=r(16),o=r(17);t.UserManagerEvents=function(e){function UserManagerEvents(t){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,UserManagerEvents);var r=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,e.call(this,t));return r._userLoaded=new o.Event("User loaded"),r._userUnloaded=new o.Event("User unloaded"),r._silentRenewError=new o.Event("Silent renew error"),r._userSignedOut=new o.Event("User signed out"),r._userSessionChanged=new o.Event("User session changed"),r}return function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(UserManagerEvents,e),UserManagerEvents.prototype.load=function load(t){var r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];n.Log.debug("UserManagerEvents.load"),e.prototype.load.call(this,t),r&&this._userLoaded.raise(t)},UserManagerEvents.prototype.unload=function unload(){n.Log.debug("UserManagerEvents.unload"),e.prototype.unload.call(this),this._userUnloaded.raise()},UserManagerEvents.prototype.addUserLoaded=function addUserLoaded(e){this._userLoaded.addHandler(e)},UserManagerEvents.prototype.removeUserLoaded=function removeUserLoaded(e){this._userLoaded.removeHandler(e)},UserManagerEvents.prototype.addUserUnloaded=function addUserUnloaded(e){this._userUnloaded.addHandler(e)},UserManagerEvents.prototype.removeUserUnloaded=function removeUserUnloaded(e){this._userUnloaded.removeHandler(e)},UserManagerEvents.prototype.addSilentRenewError=function addSilentRenewError(e){this._silentRenewError.addHandler(e)},UserManagerEvents.prototype.removeSilentRenewError=function removeSilentRenewError(e){this._silentRenewError.removeHandler(e)},UserManagerEvents.prototype._raiseSilentRenewError=function _raiseSilentRenewError(e){n.Log.debug("UserManagerEvents._raiseSilentRenewError",e.message),this._silentRenewError.raise(e)},UserManagerEvents.prototype.addUserSignedOut=function addUserSignedOut(e){this._userSignedOut.addHandler(e)},UserManagerEvents.prototype.removeUserSignedOut=function removeUserSignedOut(e){this._userSignedOut.removeHandler(e)},UserManagerEvents.prototype._raiseUserSignedOut=function _raiseUserSignedOut(e){n.Log.debug("UserManagerEvents._raiseUserSignedOut"),this._userSignedOut.raise(e)},UserManagerEvents.prototype.addUserSessionChanged=function addUserSessionChanged(e){this._userSessionChanged.addHandler(e)},UserManagerEvents.prototype.removeUserSessionChanged=function removeUserSessionChanged(e){this._userSessionChanged.removeHandler(e)},UserManagerEvents.prototype._raiseUserSessionChanged=function _raiseUserSessionChanged(e){n.Log.debug("UserManagerEvents._raiseUserSessionChanged"),this._userSessionChanged.raise(e)},UserManagerEvents}(i.AccessTokenEvents)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.Timer=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(1),s=r(17);t.Timer=function(e){function Timer(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.Global.timer,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,Timer);var i=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return!t||"object"!=typeof t&&"function"!=typeof t?e:t}(this,e.call(this,t));return i._timer=r,i._nowFunc=n||function(){return Date.now()/1e3},i}return function _inherits(e,t){if("function"!=typeof t&&null!==t)throw new TypeError("Super expression must either be null or a function, not "+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(Timer,e),Timer.prototype.init=function init(e){e<=0&&(e=1),e=parseInt(e);var t=this.now+e;if(this.expiration===t&&this._timerHandle)i.Log.debug("Timer.init timer "+this._name+" skipping initialization since already initialized for expiration:",this.expiration);else{this.cancel(),i.Log.debug("Timer.init timer "+this._name+" for duration:",e),this._expiration=t;var r=5;e<r&&(r=e),this._timerHandle=this._timer.setInterval(this._callback.bind(this),1e3*r)}},Timer.prototype.cancel=function cancel(){this._timerHandle&&(i.Log.debug("Timer.cancel: ",this._name),this._timer.clearInterval(this._timerHandle),this._timerHandle=null)},Timer.prototype._callback=function _callback(){var t=this._expiration-this.now;i.Log.debug("Timer.callback; "+this._name+" timer expires in:",t),this._expiration<=this.now&&(this.cancel(),e.prototype.raise.call(this))},n(Timer,[{key:"now",get:function get(){return parseInt(this._nowFunc())}},{key:"expiration",get:function get(){return this._expiration}}]),Timer}(s.Event)},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.SilentRenewService=void 0;var n=r(0);t.SilentRenewService=function(){function SilentRenewService(e){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,SilentRenewService),this._userManager=e}return SilentRenewService.prototype.start=function start(){this._callback||(this._callback=this._tokenExpiring.bind(this),this._userManager.events.addAccessTokenExpiring(this._callback),this._userManager.getUser().then(function(e){}).catch(function(e){n.Log.error("SilentRenewService.start: Error from getUser:",e.message)}))},SilentRenewService.prototype.stop=function stop(){this._callback&&(this._userManager.events.removeAccessTokenExpiring(this._callback),delete this._callback)},SilentRenewService.prototype._tokenExpiring=function _tokenExpiring(){var e=this;this._userManager.signinSilent().then(function(e){n.Log.debug("SilentRenewService._tokenExpiring: Silent token renewal successful")},function(t){n.Log.error("SilentRenewService._tokenExpiring: Error from signinSilent:",t.message),e._userManager.events._raiseSilentRenewError(t)})},SilentRenewService}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CordovaPopupNavigator=void 0;var n=r(21);t.CordovaPopupNavigator=function(){function CordovaPopupNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,CordovaPopupNavigator)}return CordovaPopupNavigator.prototype.prepare=function prepare(e){var t=new n.CordovaPopupWindow(e);return Promise.resolve(t)},CordovaPopupNavigator}()},function(e,t,r){"use strict";Object.defineProperty(t,"__esModule",{value:!0}),t.CordovaIFrameNavigator=void 0;var n=r(21);t.CordovaIFrameNavigator=function(){function CordovaIFrameNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError("Cannot call a class as a function")}(this,CordovaIFrameNavigator)}return CordovaIFrameNavigator.prototype.prepare=function prepare(e){e.popupWindowFeatures="hidden=yes";var t=new n.CordovaPopupWindow(e);return Promise.resolve(t)},CordovaIFrameNavigator}()}])});

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js":
/*!******************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js ***!
  \******************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/semver/5.7.0/node_modules/semver/semver.js":
/*!*************************************************************************************************************!*\
  !*** D:/vsts_b/5/s/common/temp/node_modules/.registry.npmjs.org/semver/5.7.0/node_modules/semver/semver.js ***!
  \*************************************************************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {exports = module.exports = SemVer

var debug
/* istanbul ignore next */
if (typeof process === 'object' &&
    process.env &&
    process.env.NODE_DEBUG &&
    /\bsemver\b/i.test(process.env.NODE_DEBUG)) {
  debug = function () {
    var args = Array.prototype.slice.call(arguments, 0)
    args.unshift('SEMVER')
    console.log.apply(console, args)
  }
} else {
  debug = function () {}
}

// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.
exports.SEMVER_SPEC_VERSION = '2.0.0'

var MAX_LENGTH = 256
var MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||
  /* istanbul ignore next */ 9007199254740991

// Max safe segment length for coercion.
var MAX_SAFE_COMPONENT_LENGTH = 16

// The actual regexps go on exports.re
var re = exports.re = []
var src = exports.src = []
var R = 0

// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.

// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.

var NUMERICIDENTIFIER = R++
src[NUMERICIDENTIFIER] = '0|[1-9]\\d*'
var NUMERICIDENTIFIERLOOSE = R++
src[NUMERICIDENTIFIERLOOSE] = '[0-9]+'

// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.

var NONNUMERICIDENTIFIER = R++
src[NONNUMERICIDENTIFIER] = '\\d*[a-zA-Z-][a-zA-Z0-9-]*'

// ## Main Version
// Three dot-separated numeric identifiers.

var MAINVERSION = R++
src[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')\\.' +
                   '(' + src[NUMERICIDENTIFIER] + ')'

var MAINVERSIONLOOSE = R++
src[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\.' +
                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'

// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.

var PRERELEASEIDENTIFIER = R++
src[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +
                            '|' + src[NONNUMERICIDENTIFIER] + ')'

var PRERELEASEIDENTIFIERLOOSE = R++
src[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +
                                 '|' + src[NONNUMERICIDENTIFIER] + ')'

// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.

var PRERELEASE = R++
src[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +
                  '(?:\\.' + src[PRERELEASEIDENTIFIER] + ')*))'

var PRERELEASELOOSE = R++
src[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +
                       '(?:\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'

// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.

var BUILDIDENTIFIER = R++
src[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'

// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.

var BUILD = R++
src[BUILD] = '(?:\\+(' + src[BUILDIDENTIFIER] +
             '(?:\\.' + src[BUILDIDENTIFIER] + ')*))'

// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.

// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.

var FULL = R++
var FULLPLAIN = 'v?' + src[MAINVERSION] +
                src[PRERELEASE] + '?' +
                src[BUILD] + '?'

src[FULL] = '^' + FULLPLAIN + '$'

// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
var LOOSEPLAIN = '[v=\\s]*' + src[MAINVERSIONLOOSE] +
                 src[PRERELEASELOOSE] + '?' +
                 src[BUILD] + '?'

var LOOSE = R++
src[LOOSE] = '^' + LOOSEPLAIN + '$'

var GTLT = R++
src[GTLT] = '((?:<|>)?=?)'

// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
var XRANGEIDENTIFIERLOOSE = R++
src[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\*'
var XRANGEIDENTIFIER = R++
src[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\*'

var XRANGEPLAIN = R++
src[XRANGEPLAIN] = '[v=\\s]*(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:\\.(' + src[XRANGEIDENTIFIER] + ')' +
                   '(?:' + src[PRERELEASE] + ')?' +
                   src[BUILD] + '?' +
                   ')?)?'

var XRANGEPLAINLOOSE = R++
src[XRANGEPLAINLOOSE] = '[v=\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +
                        '(?:' + src[PRERELEASELOOSE] + ')?' +
                        src[BUILD] + '?' +
                        ')?)?'

var XRANGE = R++
src[XRANGE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAIN] + '$'
var XRANGELOOSE = R++
src[XRANGELOOSE] = '^' + src[GTLT] + '\\s*' + src[XRANGEPLAINLOOSE] + '$'

// Coercion.
// Extract anything that could conceivably be a part of a valid semver
var COERCE = R++
src[COERCE] = '(?:^|[^\\d])' +
              '(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:\\.(\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +
              '(?:$|[^\\d])'

// Tilde ranges.
// Meaning is "reasonably at or greater than"
var LONETILDE = R++
src[LONETILDE] = '(?:~>?)'

var TILDETRIM = R++
src[TILDETRIM] = '(\\s*)' + src[LONETILDE] + '\\s+'
re[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')
var tildeTrimReplace = '$1~'

var TILDE = R++
src[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'
var TILDELOOSE = R++
src[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'

// Caret ranges.
// Meaning is "at least and backwards compatible with"
var LONECARET = R++
src[LONECARET] = '(?:\\^)'

var CARETTRIM = R++
src[CARETTRIM] = '(\\s*)' + src[LONECARET] + '\\s+'
re[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')
var caretTrimReplace = '$1^'

var CARET = R++
src[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'
var CARETLOOSE = R++
src[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'

// A simple gt/lt/eq thing, or just "" to indicate "any version"
var COMPARATORLOOSE = R++
src[COMPARATORLOOSE] = '^' + src[GTLT] + '\\s*(' + LOOSEPLAIN + ')$|^$'
var COMPARATOR = R++
src[COMPARATOR] = '^' + src[GTLT] + '\\s*(' + FULLPLAIN + ')$|^$'

// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
var COMPARATORTRIM = R++
src[COMPARATORTRIM] = '(\\s*)' + src[GTLT] +
                      '\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'

// this one has to use the /g flag
re[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')
var comparatorTrimReplace = '$1$2$3'

// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
var HYPHENRANGE = R++
src[HYPHENRANGE] = '^\\s*(' + src[XRANGEPLAIN] + ')' +
                   '\\s+-\\s+' +
                   '(' + src[XRANGEPLAIN] + ')' +
                   '\\s*$'

var HYPHENRANGELOOSE = R++
src[HYPHENRANGELOOSE] = '^\\s*(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s+-\\s+' +
                        '(' + src[XRANGEPLAINLOOSE] + ')' +
                        '\\s*$'

// Star ranges basically just allow anything at all.
var STAR = R++
src[STAR] = '(<|>)?=?\\s*\\*'

// Compile to actual regexp objects.
// All are flag-free, unless they were created above with a flag.
for (var i = 0; i < R; i++) {
  debug(i, src[i])
  if (!re[i]) {
    re[i] = new RegExp(src[i])
  }
}

exports.parse = parse
function parse (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  if (version.length > MAX_LENGTH) {
    return null
  }

  var r = options.loose ? re[LOOSE] : re[FULL]
  if (!r.test(version)) {
    return null
  }

  try {
    return new SemVer(version, options)
  } catch (er) {
    return null
  }
}

exports.valid = valid
function valid (version, options) {
  var v = parse(version, options)
  return v ? v.version : null
}

exports.clean = clean
function clean (version, options) {
  var s = parse(version.trim().replace(/^[=v]+/, ''), options)
  return s ? s.version : null
}

exports.SemVer = SemVer

function SemVer (version, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }
  if (version instanceof SemVer) {
    if (version.loose === options.loose) {
      return version
    } else {
      version = version.version
    }
  } else if (typeof version !== 'string') {
    throw new TypeError('Invalid Version: ' + version)
  }

  if (version.length > MAX_LENGTH) {
    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')
  }

  if (!(this instanceof SemVer)) {
    return new SemVer(version, options)
  }

  debug('SemVer', version, options)
  this.options = options
  this.loose = !!options.loose

  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])

  if (!m) {
    throw new TypeError('Invalid Version: ' + version)
  }

  this.raw = version

  // these are actually numbers
  this.major = +m[1]
  this.minor = +m[2]
  this.patch = +m[3]

  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
    throw new TypeError('Invalid major version')
  }

  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
    throw new TypeError('Invalid minor version')
  }

  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
    throw new TypeError('Invalid patch version')
  }

  // numberify any prerelease numeric ids
  if (!m[4]) {
    this.prerelease = []
  } else {
    this.prerelease = m[4].split('.').map(function (id) {
      if (/^[0-9]+$/.test(id)) {
        var num = +id
        if (num >= 0 && num < MAX_SAFE_INTEGER) {
          return num
        }
      }
      return id
    })
  }

  this.build = m[5] ? m[5].split('.') : []
  this.format()
}

SemVer.prototype.format = function () {
  this.version = this.major + '.' + this.minor + '.' + this.patch
  if (this.prerelease.length) {
    this.version += '-' + this.prerelease.join('.')
  }
  return this.version
}

SemVer.prototype.toString = function () {
  return this.version
}

SemVer.prototype.compare = function (other) {
  debug('SemVer.compare', this.version, this.options, other)
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return this.compareMain(other) || this.comparePre(other)
}

SemVer.prototype.compareMain = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  return compareIdentifiers(this.major, other.major) ||
         compareIdentifiers(this.minor, other.minor) ||
         compareIdentifiers(this.patch, other.patch)
}

SemVer.prototype.comparePre = function (other) {
  if (!(other instanceof SemVer)) {
    other = new SemVer(other, this.options)
  }

  // NOT having a prerelease is > having one
  if (this.prerelease.length && !other.prerelease.length) {
    return -1
  } else if (!this.prerelease.length && other.prerelease.length) {
    return 1
  } else if (!this.prerelease.length && !other.prerelease.length) {
    return 0
  }

  var i = 0
  do {
    var a = this.prerelease[i]
    var b = other.prerelease[i]
    debug('prerelease compare', i, a, b)
    if (a === undefined && b === undefined) {
      return 0
    } else if (b === undefined) {
      return 1
    } else if (a === undefined) {
      return -1
    } else if (a === b) {
      continue
    } else {
      return compareIdentifiers(a, b)
    }
  } while (++i)
}

// preminor will bump the version up to the next minor release, and immediately
// down to pre-release. premajor and prepatch work the same way.
SemVer.prototype.inc = function (release, identifier) {
  switch (release) {
    case 'premajor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor = 0
      this.major++
      this.inc('pre', identifier)
      break
    case 'preminor':
      this.prerelease.length = 0
      this.patch = 0
      this.minor++
      this.inc('pre', identifier)
      break
    case 'prepatch':
      // If this is already a prerelease, it will bump to the next version
      // drop any prereleases that might already exist, since they are not
      // relevant at this point.
      this.prerelease.length = 0
      this.inc('patch', identifier)
      this.inc('pre', identifier)
      break
    // If the input is a non-prerelease version, this acts the same as
    // prepatch.
    case 'prerelease':
      if (this.prerelease.length === 0) {
        this.inc('patch', identifier)
      }
      this.inc('pre', identifier)
      break

    case 'major':
      // If this is a pre-major version, bump up to the same major version.
      // Otherwise increment major.
      // 1.0.0-5 bumps to 1.0.0
      // 1.1.0 bumps to 2.0.0
      if (this.minor !== 0 ||
          this.patch !== 0 ||
          this.prerelease.length === 0) {
        this.major++
      }
      this.minor = 0
      this.patch = 0
      this.prerelease = []
      break
    case 'minor':
      // If this is a pre-minor version, bump up to the same minor version.
      // Otherwise increment minor.
      // 1.2.0-5 bumps to 1.2.0
      // 1.2.1 bumps to 1.3.0
      if (this.patch !== 0 || this.prerelease.length === 0) {
        this.minor++
      }
      this.patch = 0
      this.prerelease = []
      break
    case 'patch':
      // If this is not a pre-release version, it will increment the patch.
      // If it is a pre-release it will bump up to the same patch version.
      // 1.2.0-5 patches to 1.2.0
      // 1.2.0 patches to 1.2.1
      if (this.prerelease.length === 0) {
        this.patch++
      }
      this.prerelease = []
      break
    // This probably shouldn't be used publicly.
    // 1.0.0 "pre" would become 1.0.0-0 which is the wrong direction.
    case 'pre':
      if (this.prerelease.length === 0) {
        this.prerelease = [0]
      } else {
        var i = this.prerelease.length
        while (--i >= 0) {
          if (typeof this.prerelease[i] === 'number') {
            this.prerelease[i]++
            i = -2
          }
        }
        if (i === -1) {
          // didn't increment anything
          this.prerelease.push(0)
        }
      }
      if (identifier) {
        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
        if (this.prerelease[0] === identifier) {
          if (isNaN(this.prerelease[1])) {
            this.prerelease = [identifier, 0]
          }
        } else {
          this.prerelease = [identifier, 0]
        }
      }
      break

    default:
      throw new Error('invalid increment argument: ' + release)
  }
  this.format()
  this.raw = this.version
  return this
}

exports.inc = inc
function inc (version, release, loose, identifier) {
  if (typeof (loose) === 'string') {
    identifier = loose
    loose = undefined
  }

  try {
    return new SemVer(version, loose).inc(release, identifier).version
  } catch (er) {
    return null
  }
}

exports.diff = diff
function diff (version1, version2) {
  if (eq(version1, version2)) {
    return null
  } else {
    var v1 = parse(version1)
    var v2 = parse(version2)
    var prefix = ''
    if (v1.prerelease.length || v2.prerelease.length) {
      prefix = 'pre'
      var defaultResult = 'prerelease'
    }
    for (var key in v1) {
      if (key === 'major' || key === 'minor' || key === 'patch') {
        if (v1[key] !== v2[key]) {
          return prefix + key
        }
      }
    }
    return defaultResult // may be undefined
  }
}

exports.compareIdentifiers = compareIdentifiers

var numeric = /^[0-9]+$/
function compareIdentifiers (a, b) {
  var anum = numeric.test(a)
  var bnum = numeric.test(b)

  if (anum && bnum) {
    a = +a
    b = +b
  }

  return a === b ? 0
    : (anum && !bnum) ? -1
    : (bnum && !anum) ? 1
    : a < b ? -1
    : 1
}

exports.rcompareIdentifiers = rcompareIdentifiers
function rcompareIdentifiers (a, b) {
  return compareIdentifiers(b, a)
}

exports.major = major
function major (a, loose) {
  return new SemVer(a, loose).major
}

exports.minor = minor
function minor (a, loose) {
  return new SemVer(a, loose).minor
}

exports.patch = patch
function patch (a, loose) {
  return new SemVer(a, loose).patch
}

exports.compare = compare
function compare (a, b, loose) {
  return new SemVer(a, loose).compare(new SemVer(b, loose))
}

exports.compareLoose = compareLoose
function compareLoose (a, b) {
  return compare(a, b, true)
}

exports.rcompare = rcompare
function rcompare (a, b, loose) {
  return compare(b, a, loose)
}

exports.sort = sort
function sort (list, loose) {
  return list.sort(function (a, b) {
    return exports.compare(a, b, loose)
  })
}

exports.rsort = rsort
function rsort (list, loose) {
  return list.sort(function (a, b) {
    return exports.rcompare(a, b, loose)
  })
}

exports.gt = gt
function gt (a, b, loose) {
  return compare(a, b, loose) > 0
}

exports.lt = lt
function lt (a, b, loose) {
  return compare(a, b, loose) < 0
}

exports.eq = eq
function eq (a, b, loose) {
  return compare(a, b, loose) === 0
}

exports.neq = neq
function neq (a, b, loose) {
  return compare(a, b, loose) !== 0
}

exports.gte = gte
function gte (a, b, loose) {
  return compare(a, b, loose) >= 0
}

exports.lte = lte
function lte (a, b, loose) {
  return compare(a, b, loose) <= 0
}

exports.cmp = cmp
function cmp (a, op, b, loose) {
  switch (op) {
    case '===':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a === b

    case '!==':
      if (typeof a === 'object')
        a = a.version
      if (typeof b === 'object')
        b = b.version
      return a !== b

    case '':
    case '=':
    case '==':
      return eq(a, b, loose)

    case '!=':
      return neq(a, b, loose)

    case '>':
      return gt(a, b, loose)

    case '>=':
      return gte(a, b, loose)

    case '<':
      return lt(a, b, loose)

    case '<=':
      return lte(a, b, loose)

    default:
      throw new TypeError('Invalid operator: ' + op)
  }
}

exports.Comparator = Comparator
function Comparator (comp, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (comp instanceof Comparator) {
    if (comp.loose === !!options.loose) {
      return comp
    } else {
      comp = comp.value
    }
  }

  if (!(this instanceof Comparator)) {
    return new Comparator(comp, options)
  }

  debug('comparator', comp, options)
  this.options = options
  this.loose = !!options.loose
  this.parse(comp)

  if (this.semver === ANY) {
    this.value = ''
  } else {
    this.value = this.operator + this.semver.version
  }

  debug('comp', this)
}

var ANY = {}
Comparator.prototype.parse = function (comp) {
  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var m = comp.match(r)

  if (!m) {
    throw new TypeError('Invalid comparator: ' + comp)
  }

  this.operator = m[1]
  if (this.operator === '=') {
    this.operator = ''
  }

  // if it literally is just '>' or '' then allow anything.
  if (!m[2]) {
    this.semver = ANY
  } else {
    this.semver = new SemVer(m[2], this.options.loose)
  }
}

Comparator.prototype.toString = function () {
  return this.value
}

Comparator.prototype.test = function (version) {
  debug('Comparator.test', version, this.options.loose)

  if (this.semver === ANY) {
    return true
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  return cmp(version, this.operator, this.semver, this.options)
}

Comparator.prototype.intersects = function (comp, options) {
  if (!(comp instanceof Comparator)) {
    throw new TypeError('a Comparator is required')
  }

  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  var rangeTmp

  if (this.operator === '') {
    rangeTmp = new Range(comp.value, options)
    return satisfies(this.value, rangeTmp, options)
  } else if (comp.operator === '') {
    rangeTmp = new Range(this.value, options)
    return satisfies(comp.semver, rangeTmp, options)
  }

  var sameDirectionIncreasing =
    (this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '>=' || comp.operator === '>')
  var sameDirectionDecreasing =
    (this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '<=' || comp.operator === '<')
  var sameSemVer = this.semver.version === comp.semver.version
  var differentDirectionsInclusive =
    (this.operator === '>=' || this.operator === '<=') &&
    (comp.operator === '>=' || comp.operator === '<=')
  var oppositeDirectionsLessThan =
    cmp(this.semver, '<', comp.semver, options) &&
    ((this.operator === '>=' || this.operator === '>') &&
    (comp.operator === '<=' || comp.operator === '<'))
  var oppositeDirectionsGreaterThan =
    cmp(this.semver, '>', comp.semver, options) &&
    ((this.operator === '<=' || this.operator === '<') &&
    (comp.operator === '>=' || comp.operator === '>'))

  return sameDirectionIncreasing || sameDirectionDecreasing ||
    (sameSemVer && differentDirectionsInclusive) ||
    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan
}

exports.Range = Range
function Range (range, options) {
  if (!options || typeof options !== 'object') {
    options = {
      loose: !!options,
      includePrerelease: false
    }
  }

  if (range instanceof Range) {
    if (range.loose === !!options.loose &&
        range.includePrerelease === !!options.includePrerelease) {
      return range
    } else {
      return new Range(range.raw, options)
    }
  }

  if (range instanceof Comparator) {
    return new Range(range.value, options)
  }

  if (!(this instanceof Range)) {
    return new Range(range, options)
  }

  this.options = options
  this.loose = !!options.loose
  this.includePrerelease = !!options.includePrerelease

  // First, split based on boolean or ||
  this.raw = range
  this.set = range.split(/\s*\|\|\s*/).map(function (range) {
    return this.parseRange(range.trim())
  }, this).filter(function (c) {
    // throw out any that are not relevant for whatever reason
    return c.length
  })

  if (!this.set.length) {
    throw new TypeError('Invalid SemVer Range: ' + range)
  }

  this.format()
}

Range.prototype.format = function () {
  this.range = this.set.map(function (comps) {
    return comps.join(' ').trim()
  }).join('||').trim()
  return this.range
}

Range.prototype.toString = function () {
  return this.range
}

Range.prototype.parseRange = function (range) {
  var loose = this.options.loose
  range = range.trim()
  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]
  range = range.replace(hr, hyphenReplace)
  debug('hyphen replace', range)
  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)
  debug('comparator trim', range, re[COMPARATORTRIM])

  // `~ 1.2.3` => `~1.2.3`
  range = range.replace(re[TILDETRIM], tildeTrimReplace)

  // `^ 1.2.3` => `^1.2.3`
  range = range.replace(re[CARETTRIM], caretTrimReplace)

  // normalize spaces
  range = range.split(/\s+/).join(' ')

  // At this point, the range is completely trimmed and
  // ready to be split into comparators.

  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]
  var set = range.split(' ').map(function (comp) {
    return parseComparator(comp, this.options)
  }, this).join(' ').split(/\s+/)
  if (this.options.loose) {
    // in loose mode, throw out any that are not valid comparators
    set = set.filter(function (comp) {
      return !!comp.match(compRe)
    })
  }
  set = set.map(function (comp) {
    return new Comparator(comp, this.options)
  }, this)

  return set
}

Range.prototype.intersects = function (range, options) {
  if (!(range instanceof Range)) {
    throw new TypeError('a Range is required')
  }

  return this.set.some(function (thisComparators) {
    return thisComparators.every(function (thisComparator) {
      return range.set.some(function (rangeComparators) {
        return rangeComparators.every(function (rangeComparator) {
          return thisComparator.intersects(rangeComparator, options)
        })
      })
    })
  })
}

// Mostly just for testing and legacy API reasons
exports.toComparators = toComparators
function toComparators (range, options) {
  return new Range(range, options).set.map(function (comp) {
    return comp.map(function (c) {
      return c.value
    }).join(' ').trim().split(' ')
  })
}

// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
function parseComparator (comp, options) {
  debug('comp', comp, options)
  comp = replaceCarets(comp, options)
  debug('caret', comp)
  comp = replaceTildes(comp, options)
  debug('tildes', comp)
  comp = replaceXRanges(comp, options)
  debug('xrange', comp)
  comp = replaceStars(comp, options)
  debug('stars', comp)
  return comp
}

function isX (id) {
  return !id || id.toLowerCase() === 'x' || id === '*'
}

// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0
function replaceTildes (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceTilde(comp, options)
  }).join(' ')
}

function replaceTilde (comp, options) {
  var r = options.loose ? re[TILDELOOSE] : re[TILDE]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('tilde', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      // ~1.2 == >=1.2.0 <1.3.0
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    } else if (pr) {
      debug('replaceTilde pr', pr)
      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
            ' <' + M + '.' + (+m + 1) + '.0'
    } else {
      // ~1.2.3 == >=1.2.3 <1.3.0
      ret = '>=' + M + '.' + m + '.' + p +
            ' <' + M + '.' + (+m + 1) + '.0'
    }

    debug('tilde return', ret)
    return ret
  })
}

// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0
// ^1.2.3 --> >=1.2.3 <2.0.0
// ^1.2.0 --> >=1.2.0 <2.0.0
function replaceCarets (comp, options) {
  return comp.trim().split(/\s+/).map(function (comp) {
    return replaceCaret(comp, options)
  }).join(' ')
}

function replaceCaret (comp, options) {
  debug('caret', comp, options)
  var r = options.loose ? re[CARETLOOSE] : re[CARET]
  return comp.replace(r, function (_, M, m, p, pr) {
    debug('caret', comp, _, M, m, p, pr)
    var ret

    if (isX(M)) {
      ret = ''
    } else if (isX(m)) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (isX(p)) {
      if (M === '0') {
        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
      } else {
        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'
      }
    } else if (pr) {
      debug('replaceCaret pr', pr)
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +
              ' <' + (+M + 1) + '.0.0'
      }
    } else {
      debug('no pr')
      if (M === '0') {
        if (m === '0') {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + m + '.' + (+p + 1)
        } else {
          ret = '>=' + M + '.' + m + '.' + p +
                ' <' + M + '.' + (+m + 1) + '.0'
        }
      } else {
        ret = '>=' + M + '.' + m + '.' + p +
              ' <' + (+M + 1) + '.0.0'
      }
    }

    debug('caret return', ret)
    return ret
  })
}

function replaceXRanges (comp, options) {
  debug('replaceXRanges', comp, options)
  return comp.split(/\s+/).map(function (comp) {
    return replaceXRange(comp, options)
  }).join(' ')
}

function replaceXRange (comp, options) {
  comp = comp.trim()
  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]
  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {
    debug('xRange', comp, ret, gtlt, M, m, p, pr)
    var xM = isX(M)
    var xm = xM || isX(m)
    var xp = xm || isX(p)
    var anyX = xp

    if (gtlt === '=' && anyX) {
      gtlt = ''
    }

    if (xM) {
      if (gtlt === '>' || gtlt === '<') {
        // nothing is allowed
        ret = '<0.0.0'
      } else {
        // nothing is forbidden
        ret = '*'
      }
    } else if (gtlt && anyX) {
      // we know patch is an x, because we have any x at all.
      // replace X with 0
      if (xm) {
        m = 0
      }
      p = 0

      if (gtlt === '>') {
        // >1 => >=2.0.0
        // >1.2 => >=1.3.0
        // >1.2.3 => >= 1.2.4
        gtlt = '>='
        if (xm) {
          M = +M + 1
          m = 0
          p = 0
        } else {
          m = +m + 1
          p = 0
        }
      } else if (gtlt === '<=') {
        // <=0.7.x is actually <0.8.0, since any 0.7.x should
        // pass.  Similarly, <=7.x is actually <8.0.0, etc.
        gtlt = '<'
        if (xm) {
          M = +M + 1
        } else {
          m = +m + 1
        }
      }

      ret = gtlt + M + '.' + m + '.' + p
    } else if (xm) {
      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'
    } else if (xp) {
      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'
    }

    debug('xRange return', ret)

    return ret
  })
}

// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
function replaceStars (comp, options) {
  debug('replaceStars', comp, options)
  // Looseness is ignored here.  star is always as loose as it gets!
  return comp.trim().replace(re[STAR], '')
}

// This function is passed to string.replace(re[HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0
function hyphenReplace ($0,
  from, fM, fm, fp, fpr, fb,
  to, tM, tm, tp, tpr, tb) {
  if (isX(fM)) {
    from = ''
  } else if (isX(fm)) {
    from = '>=' + fM + '.0.0'
  } else if (isX(fp)) {
    from = '>=' + fM + '.' + fm + '.0'
  } else {
    from = '>=' + from
  }

  if (isX(tM)) {
    to = ''
  } else if (isX(tm)) {
    to = '<' + (+tM + 1) + '.0.0'
  } else if (isX(tp)) {
    to = '<' + tM + '.' + (+tm + 1) + '.0'
  } else if (tpr) {
    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr
  } else {
    to = '<=' + to
  }

  return (from + ' ' + to).trim()
}

// if ANY of the sets match ALL of its comparators, then pass
Range.prototype.test = function (version) {
  if (!version) {
    return false
  }

  if (typeof version === 'string') {
    version = new SemVer(version, this.options)
  }

  for (var i = 0; i < this.set.length; i++) {
    if (testSet(this.set[i], version, this.options)) {
      return true
    }
  }
  return false
}

function testSet (set, version, options) {
  for (var i = 0; i < set.length; i++) {
    if (!set[i].test(version)) {
      return false
    }
  }

  if (version.prerelease.length && !options.includePrerelease) {
    // Find the set of versions that are allowed to have prereleases
    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
    // That should allow `1.2.3-pr.2` to pass.
    // However, `1.2.4-alpha.notready` should NOT be allowed,
    // even though it's within the range set by the comparators.
    for (i = 0; i < set.length; i++) {
      debug(set[i].semver)
      if (set[i].semver === ANY) {
        continue
      }

      if (set[i].semver.prerelease.length > 0) {
        var allowed = set[i].semver
        if (allowed.major === version.major &&
            allowed.minor === version.minor &&
            allowed.patch === version.patch) {
          return true
        }
      }
    }

    // Version has a -pre, but it's not one of the ones we like.
    return false
  }

  return true
}

exports.satisfies = satisfies
function satisfies (version, range, options) {
  try {
    range = new Range(range, options)
  } catch (er) {
    return false
  }
  return range.test(version)
}

exports.maxSatisfying = maxSatisfying
function maxSatisfying (versions, range, options) {
  var max = null
  var maxSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!max || maxSV.compare(v) === -1) {
        // compare(max, v, true)
        max = v
        maxSV = new SemVer(max, options)
      }
    }
  })
  return max
}

exports.minSatisfying = minSatisfying
function minSatisfying (versions, range, options) {
  var min = null
  var minSV = null
  try {
    var rangeObj = new Range(range, options)
  } catch (er) {
    return null
  }
  versions.forEach(function (v) {
    if (rangeObj.test(v)) {
      // satisfies(v, range, options)
      if (!min || minSV.compare(v) === 1) {
        // compare(min, v, true)
        min = v
        minSV = new SemVer(min, options)
      }
    }
  })
  return min
}

exports.minVersion = minVersion
function minVersion (range, loose) {
  range = new Range(range, loose)

  var minver = new SemVer('0.0.0')
  if (range.test(minver)) {
    return minver
  }

  minver = new SemVer('0.0.0-0')
  if (range.test(minver)) {
    return minver
  }

  minver = null
  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    comparators.forEach(function (comparator) {
      // Clone to avoid manipulating the comparator's semver object.
      var compver = new SemVer(comparator.semver.version)
      switch (comparator.operator) {
        case '>':
          if (compver.prerelease.length === 0) {
            compver.patch++
          } else {
            compver.prerelease.push(0)
          }
          compver.raw = compver.format()
          /* fallthrough */
        case '':
        case '>=':
          if (!minver || gt(minver, compver)) {
            minver = compver
          }
          break
        case '<':
        case '<=':
          /* Ignore maximum versions */
          break
        /* istanbul ignore next */
        default:
          throw new Error('Unexpected operation: ' + comparator.operator)
      }
    })
  }

  if (minver && range.test(minver)) {
    return minver
  }

  return null
}

exports.validRange = validRange
function validRange (range, options) {
  try {
    // Return '*' instead of '' so that truthiness works.
    // This will throw if it's invalid anyway
    return new Range(range, options).range || '*'
  } catch (er) {
    return null
  }
}

// Determine if version is less than all the versions possible in the range
exports.ltr = ltr
function ltr (version, range, options) {
  return outside(version, range, '<', options)
}

// Determine if version is greater than all the versions possible in the range.
exports.gtr = gtr
function gtr (version, range, options) {
  return outside(version, range, '>', options)
}

exports.outside = outside
function outside (version, range, hilo, options) {
  version = new SemVer(version, options)
  range = new Range(range, options)

  var gtfn, ltefn, ltfn, comp, ecomp
  switch (hilo) {
    case '>':
      gtfn = gt
      ltefn = lte
      ltfn = lt
      comp = '>'
      ecomp = '>='
      break
    case '<':
      gtfn = lt
      ltefn = gte
      ltfn = gt
      comp = '<'
      ecomp = '<='
      break
    default:
      throw new TypeError('Must provide a hilo val of "<" or ">"')
  }

  // If it satisifes the range it is not outside
  if (satisfies(version, range, options)) {
    return false
  }

  // From now on, variable terms are as if we're in "gtr" mode.
  // but note that everything is flipped for the "ltr" function.

  for (var i = 0; i < range.set.length; ++i) {
    var comparators = range.set[i]

    var high = null
    var low = null

    comparators.forEach(function (comparator) {
      if (comparator.semver === ANY) {
        comparator = new Comparator('>=0.0.0')
      }
      high = high || comparator
      low = low || comparator
      if (gtfn(comparator.semver, high.semver, options)) {
        high = comparator
      } else if (ltfn(comparator.semver, low.semver, options)) {
        low = comparator
      }
    })

    // If the edge version comparator has a operator then our version
    // isn't outside it
    if (high.operator === comp || high.operator === ecomp) {
      return false
    }

    // If the lowest version comparator has an operator and our version
    // is less than it then it isn't higher than the range
    if ((!low.operator || low.operator === comp) &&
        ltefn(version, low.semver)) {
      return false
    } else if (low.operator === ecomp && ltfn(version, low.semver)) {
      return false
    }
  }
  return true
}

exports.prerelease = prerelease
function prerelease (version, options) {
  var parsed = parse(version, options)
  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null
}

exports.intersects = intersects
function intersects (r1, r2, options) {
  r1 = new Range(r1, options)
  r2 = new Range(r2, options)
  return r1.intersects(r2)
}

exports.coerce = coerce
function coerce (version) {
  if (version instanceof SemVer) {
    return version
  }

  if (typeof version !== 'string') {
    return null
  }

  var match = version.match(re[COERCE])

  if (match == null) {
    return null
  }

  return parse(match[1] +
    '.' + (match[2] || '0') +
    '.' + (match[3] || '0'))
}

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../process/0.11.10/node_modules/process/browser.js */ "../../common/temp/node_modules/.registry.npmjs.org/process/0.11.10/node_modules/process/browser.js")))

/***/ }),

/***/ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js":
/*!***********************************!*\
  !*** (webpack)/buildin/global.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || new Function("return this")();
} catch (e) {
	// This works if the window reference is available
	if (typeof window === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),

/***/ "./lib/AccuDraw.js":
/*!*************************!*\
  !*** ./lib/AccuDraw.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module AccuDraw */
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/Viewport.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const StandardView_1 = __webpack_require__(/*! ./StandardView */ "./lib/StandardView.js");
const ViewState_1 = __webpack_require__(/*! ./ViewState */ "./lib/ViewState.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const Tool_1 = __webpack_require__(/*! ./tools/Tool */ "./lib/tools/Tool.js");
const HitDetail_1 = __webpack_require__(/*! ./HitDetail */ "./lib/HitDetail.js");
const AccuSnap_1 = __webpack_require__(/*! ./AccuSnap */ "./lib/AccuSnap.js");
const AuxCoordSys_1 = __webpack_require__(/*! ./AuxCoordSys */ "./lib/AuxCoordSys.js");
const GraphicBuilder_1 = __webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js");
const ViewTool_1 = __webpack_require__(/*! ./tools/ViewTool */ "./lib/tools/ViewTool.js");
/** @internal */
var AccuDrawFlags;
(function (AccuDrawFlags) {
    AccuDrawFlags[AccuDrawFlags["SetModePolar"] = 1] = "SetModePolar";
    AccuDrawFlags[AccuDrawFlags["SetModeRect"] = 2] = "SetModeRect";
    AccuDrawFlags[AccuDrawFlags["SetOrigin"] = 4] = "SetOrigin";
    AccuDrawFlags[AccuDrawFlags["FixedOrigin"] = 8] = "FixedOrigin";
    AccuDrawFlags[AccuDrawFlags["SetRMatrix"] = 16] = "SetRMatrix";
    AccuDrawFlags[AccuDrawFlags["SetXAxis"] = 32] = "SetXAxis";
    AccuDrawFlags[AccuDrawFlags["SetNormal"] = 64] = "SetNormal";
    AccuDrawFlags[AccuDrawFlags["SetDistance"] = 128] = "SetDistance";
    AccuDrawFlags[AccuDrawFlags["LockDistance"] = 256] = "LockDistance";
    AccuDrawFlags[AccuDrawFlags["Lock_X"] = 512] = "Lock_X";
    AccuDrawFlags[AccuDrawFlags["Lock_Y"] = 1024] = "Lock_Y";
    AccuDrawFlags[AccuDrawFlags["Lock_Z"] = 2048] = "Lock_Z";
    AccuDrawFlags[AccuDrawFlags["Disable"] = 4096] = "Disable";
    AccuDrawFlags[AccuDrawFlags["OrientDefault"] = 16384] = "OrientDefault";
    AccuDrawFlags[AccuDrawFlags["SetFocus"] = 32768] = "SetFocus";
    AccuDrawFlags[AccuDrawFlags["OrientACS"] = 131072] = "OrientACS";
    AccuDrawFlags[AccuDrawFlags["SetXAxis2"] = 262144] = "SetXAxis2";
    AccuDrawFlags[AccuDrawFlags["LockAngle"] = 524288] = "LockAngle";
    AccuDrawFlags[AccuDrawFlags["AlwaysSetOrigin"] = 2097156] = "AlwaysSetOrigin";
    AccuDrawFlags[AccuDrawFlags["RedrawCompass"] = 4194304] = "RedrawCompass";
    AccuDrawFlags[AccuDrawFlags["UpdateRotation"] = 8388608] = "UpdateRotation";
    AccuDrawFlags[AccuDrawFlags["SmartRotation"] = 16777216] = "SmartRotation";
})(AccuDrawFlags = exports.AccuDrawFlags || (exports.AccuDrawFlags = {}));
/** @internal */
var CompassMode;
(function (CompassMode) {
    CompassMode[CompassMode["Polar"] = 0] = "Polar";
    CompassMode[CompassMode["Rectangular"] = 1] = "Rectangular";
})(CompassMode = exports.CompassMode || (exports.CompassMode = {}));
/** @alpha */
var RotationMode;
(function (RotationMode) {
    RotationMode[RotationMode["Top"] = 1] = "Top";
    RotationMode[RotationMode["Front"] = 2] = "Front";
    RotationMode[RotationMode["Side"] = 3] = "Side";
    RotationMode[RotationMode["View"] = 4] = "View";
    RotationMode[RotationMode["ACS"] = 5] = "ACS";
    RotationMode[RotationMode["Context"] = 6] = "Context";
})(RotationMode = exports.RotationMode || (exports.RotationMode = {}));
/** @internal */
var LockedStates;
(function (LockedStates) {
    LockedStates[LockedStates["NONE_LOCKED"] = 0] = "NONE_LOCKED";
    LockedStates[LockedStates["X_BM"] = 1] = "X_BM";
    LockedStates[LockedStates["Y_BM"] = 2] = "Y_BM";
    LockedStates[LockedStates["VEC_BM"] = 4] = "VEC_BM";
    LockedStates[LockedStates["DIST_BM"] = 8] = "DIST_BM";
    LockedStates[LockedStates["XY_BM"] = 3] = "XY_BM";
    LockedStates[LockedStates["ANGLE_BM"] = 7] = "ANGLE_BM";
})(LockedStates = exports.LockedStates || (exports.LockedStates = {}));
/** @internal */
var CurrentState;
(function (CurrentState) {
    CurrentState[CurrentState["NotEnabled"] = 0] = "NotEnabled";
    CurrentState[CurrentState["Deactivated"] = 1] = "Deactivated";
    CurrentState[CurrentState["Inactive"] = 2] = "Inactive";
    CurrentState[CurrentState["Active"] = 3] = "Active";
})(CurrentState = exports.CurrentState || (exports.CurrentState = {}));
/** @internal */
var ContextMode;
(function (ContextMode) {
    ContextMode[ContextMode["Locked"] = 0] = "Locked";
    ContextMode[ContextMode["XAxis"] = 1] = "XAxis";
    ContextMode[ContextMode["YAxis"] = 2] = "YAxis";
    ContextMode[ContextMode["ZAxis"] = 3] = "ZAxis";
    ContextMode[ContextMode["XAxis2"] = 4] = "XAxis2";
    ContextMode[ContextMode["None"] = 15] = "None";
})(ContextMode = exports.ContextMode || (exports.ContextMode = {}));
/** @internal */
var ItemField;
(function (ItemField) {
    ItemField[ItemField["DIST_Item"] = 0] = "DIST_Item";
    ItemField[ItemField["ANGLE_Item"] = 1] = "ANGLE_Item";
    ItemField[ItemField["X_Item"] = 2] = "X_Item";
    ItemField[ItemField["Y_Item"] = 3] = "Y_Item";
    ItemField[ItemField["Z_Item"] = 4] = "Z_Item";
})(ItemField = exports.ItemField || (exports.ItemField = {}));
/** @internal */
var KeyinStatus;
(function (KeyinStatus) {
    KeyinStatus[KeyinStatus["Dynamic"] = 0] = "Dynamic";
    KeyinStatus[KeyinStatus["Partial"] = 1] = "Partial";
    KeyinStatus[KeyinStatus["DontUpdate"] = 2] = "DontUpdate";
})(KeyinStatus = exports.KeyinStatus || (exports.KeyinStatus = {}));
/** @internal */
class AccudrawData {
    constructor() {
        this.flags = 0; // AccuDrawFlags
        this.origin = new geometry_core_1.Point3d(); // used if ACCUDRAW_SetOrigin
        this.delta = new geometry_core_1.Point3d(); // if ACCUDRAW_Lock_X, etc.
        this.rMatrix = new geometry_core_1.Matrix3d(); // if ACCUDRAW_SetRMatrix/ACCUDRAW_Set3dMatrix
        this.vector = new geometry_core_1.Vector3d(); // if ACCUDRAW_SetXAxis, etc.
        this.distance = 0; // if ACCUDRAW_SetDistance
        this.angle = 0; // if ACCUDRAW_SetAngle
    }
    zero() { this.flags = this.distance = this.angle = 0; this.origin.setZero(); this.delta.setZero(); this.vector.setZero(); this.rMatrix.setIdentity(); }
}
exports.AccudrawData = AccudrawData;
/** @internal */
class Flags {
    constructor() {
        this.redrawCompass = false;
        this.dialogNeedsUpdate = false;
        this.rotationNeedsUpdate = true;
        this.lockedRotation = false;
        this.indexLocked = false;
        this.haveValidOrigin = false;
        this.fixedOrg = false;
        this.auxRotationPlane = RotationMode.Top;
        this.contextRotMode = 0;
        this.baseRotation = RotationMode.View;
        this.baseMode = 0;
        this.pointIsOnPlane = false; // whether rawPointOnPlane is on compass plane
        this.softAngleLock = false;
        this.bearingFixToPlane2D = false;
        this.inDataPoint = false;
        this.ignoreDataButton = false;
        this.animateRotation = false;
    }
}
exports.Flags = Flags;
/** @internal */
class RoundOff {
    constructor() {
        this.active = false;
        this.units = new Set();
    }
}
exports.RoundOff = RoundOff;
/** @internal */
class SavedState {
    constructor() {
        this.state = CurrentState.NotEnabled;
        this.mode = CompassMode.Polar;
        this.rotationMode = RotationMode.View;
        this.axes = new ThreeAxes();
        this.origin = new geometry_core_1.Point3d();
        this.auxRotationPlane = 0;
        this.contextRotMode = 0;
        this.fixedOrg = false;
        this.ignoreDataButton = true; // By default the data point that terminates a view tool or input collector should be ignored...
        this.ignoreFlags = 0;
    }
}
exports.SavedState = SavedState;
/** @internal */
class SavedCoords {
    constructor() {
        this.nSaveValues = 0;
        this.savedValues = [];
        this.savedValIsAngle = [];
    }
}
/** @internal */
class ThreeAxes {
    constructor() {
        this.x = geometry_core_1.Vector3d.unitX();
        this.y = geometry_core_1.Vector3d.unitY();
        this.z = geometry_core_1.Vector3d.unitZ();
    }
    setFrom(other) {
        this.x.setFrom(other.x);
        this.y.setFrom(other.y);
        this.z.setFrom(other.z);
    }
    fromMatrix3d(rMatrix) {
        rMatrix.getRow(0, this.x);
        rMatrix.getRow(1, this.y);
        rMatrix.getRow(2, this.z);
    }
    static createFromMatrix3d(rMatrix, result) {
        result = result ? result : new ThreeAxes();
        result.fromMatrix3d(rMatrix);
        return result;
    }
    toMatrix3d(out) { return geometry_core_1.Matrix3d.createRows(this.x, this.y, this.z, out); }
    clone() { const out = new ThreeAxes(); out.setFrom(this); return out; }
    equals(other) { return this.x.isExactEqual(other.x) && this.y.isExactEqual(other.y) && this.z.isExactEqual(other.z); }
}
exports.ThreeAxes = ThreeAxes;
/** Accudraw is an aide for entering coordinate data.
 * @internal
 */
class AccuDraw {
    constructor() {
        /** @internal */
        this.currentState = CurrentState.NotEnabled; // Compass state
        /** @internal */
        this.compassMode = CompassMode.Rectangular; // Compass mode
        /** @internal */
        this.rotationMode = RotationMode.View; // Compass rotation
        /** @internal */
        this.published = new AccudrawData(); // Staging area for hints
        /** @internal */
        this.origin = new geometry_core_1.Point3d(); // origin point...not on compass plane when z != 0.0
        /** @internal */
        this.axes = new ThreeAxes(); // X, Y and Z vectors (3d rotation matrix)
        /** @internal */
        this.delta = geometry_core_1.Vector3d.unitZ(); // dialog items (x, y & z)
        this._distance = 0; // current distance
        this._angle = 0; // current angle
        /** @internal */
        this.locked = LockedStates.NONE_LOCKED; // axis/distance locked bit mask
        /** @internal */
        this.indexed = LockedStates.NONE_LOCKED; // axis/distance indexed bit mask
        this._distanceRoundOff = new RoundOff(); // distance round off enabled and unit
        this._angleRoundOff = new RoundOff(); // angle round off enabled and unit
        /** @internal */
        this.flags = new Flags(); // current state flags
        this._fieldLocked = []; // locked state of fields
        this._keyinStatus = []; // state of input field
        /** @internal */
        this.savedStateViewTool = new SavedState(); // Restore point for shortcuts/tools...
        /** @internal */
        this.savedStateInputCollector = new SavedState(); // Restore point for shortcuts/tools...
        this._savedCoords = new SavedCoords(); // History of previous angles/distances...
        /** @internal */
        this.baseAxes = new ThreeAxes(); // Used for "context" base rotation to hold arbitrary rotation w/o needing to change ACS...
        /** @internal */
        this.lastAxes = new ThreeAxes(); // Last result from UpdateRotation, replaces cM.rMatrix...
        this._lastDistance = 0; // previous saved distance or distance indexing tick
        this._tolerance = 0; // computed view based indexing tolerance
        this._percentChanged = 0; // Compass animation state
        this._threshold = 0; // Threshold for automatic x/y field focus change.
        /** @internal */
        this.planePt = new geometry_core_1.Point3d(); // same as origin unless non-zero locked z value
        this._rawDelta = new geometry_core_1.Point2d(); // used by rect fix point
        this._rawPoint = new geometry_core_1.Point3d(); // raw uor point passed to fix point
        this._rawPointOnPlane = new geometry_core_1.Point3d(); // adjusted rawPoint by applying hard/soft construction plane
        /** @internal */
        this.point = new geometry_core_1.Point3d(); // current cursor point
        /** @internal */
        this.vector = geometry_core_1.Vector3d.unitZ(); // current/last good locked direction
        this._xIsNegative = false; // Last delta.x was negative
        this._yIsNegative = false; // Last delta.y was negative
        this._xIsExplicit = false; // Sign of delta.x established from user input input, don't allow +/- side flip.
        this._yIsExplicit = false; // Sign of delta.y established from user input input, don't allow +/- side flip.
        this.dontMoveFocus = false; // Disable automatic focus change when user is entering input.
        /** @internal */
        this.newFocus = ItemField.X_Item; // Item to move focus to (X_Item or Y_Item) for automatic focus change.
        this._rMatrix = new geometry_core_1.Matrix3d();
        // Compass Display Preferences...
        /** @internal */
        this._compassSizeInches = 0.44;
        /** @internal */
        this._animationFrames = 12;
        /** @internal */
        this._indexToleranceInches = 0.11;
        /** @internal */
        this._frameColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.lightGrey);
        /** @internal */
        this._fillColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.blue);
        /** @internal */
        this._xColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.red);
        /** @internal */
        this._yColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.green);
        /** @internal */
        this._indexColor = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.white);
        /** @internal */
        this._frameColorNoFocus = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.darkGrey);
        /** @internal */
        this._fillColorNoFocus = new imodeljs_common_1.ColorDef(imodeljs_common_1.ColorByName.lightGrey);
        // User Preference Settings...
        this.smartKeyin = true;
        this.floatingOrigin = true;
        this.stickyZLock = false;
        this.alwaysShowCompass = false;
        this.contextSensitive = true;
        this.axisIndexing = true;
        this.distanceIndexing = true;
        this.autoFocusFields = true;
        this.autoPointPlacement = false;
    }
    /** @internal */
    onInitialized() { this.enableForSession(); }
    /** @internal */
    getRotation(rMatrix) { if (!rMatrix)
        rMatrix = this._rMatrix; geometry_core_1.Matrix3d.createRows(this.axes.x, this.axes.y, this.axes.z, rMatrix); return rMatrix; }
    get isActive() { return CurrentState.Active === this.currentState; }
    get isEnabled() { return (this.currentState > CurrentState.NotEnabled); }
    get isInactive() { return (CurrentState.Inactive === this.currentState); }
    get isDeactivated() { return (CurrentState.Deactivated === this.currentState); }
    /** @internal */
    setNewFocus(index) { this.newFocus = index; }
    /** @internal */
    getFieldLock(index) { return this._fieldLocked[index]; }
    /** @internal */
    getKeyinStatus(index) { return this._keyinStatus[index]; }
    /** Implement this method to set focus to the AccuDraw UI.
     * @internal
     */
    grabInputFocus() { }
    /** @internal */
    activate() {
        // Upgrade state to inactive so upgradeToActiveState knows it is ok to move to active...
        if (CurrentState.Deactivated === this.currentState)
            this.currentState = CurrentState.Inactive;
        this.upgradeToActiveState();
    }
    /** @internal */
    deactivate() {
        this.downgradeInactiveState();
        // Don't allow compass to come back until user re-enables it...
        if (CurrentState.Inactive === this.currentState)
            this.currentState = CurrentState.Deactivated;
    }
    /** @internal */
    setCompassMode(mode) {
        if (mode === this.compassMode)
            return;
        this.compassMode = mode;
        this.onCompassModeChange();
    }
    /** @internal */
    setRotationMode(mode) {
        if (mode === this.rotationMode)
            return;
        this.rotationMode = mode;
        this.onRotationModeChange();
    }
    /** @internal */
    setFieldLock(index, locked) {
        if (locked === this._fieldLocked[index])
            return;
        this._fieldLocked[index] = locked;
        this.onFieldLockChange(index);
    }
    /** @internal */
    setKeyinStatus(index, status) {
        this._keyinStatus[index] = status;
        if (KeyinStatus.Dynamic !== status)
            this.dontMoveFocus = true;
        if (KeyinStatus.Partial === status)
            this._threshold = Math.abs(ItemField.X_Item === index ? this._rawDelta.y : this._rawDelta.x) + this._tolerance;
    }
    needsRefresh(vp) {
        if (!this.isEnabled || this.isDeactivated)
            return false;
        // Get snap point from AccuSnap/Tentative or use raw point...
        let distance = 0.0;
        let snapPt = this._rawPoint;
        const ptP = this.point;
        const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap();
        if (snap) {
            snapPt = snap.snapPoint;
            distance = ptP.distance(snapPt);
        }
        const isRectMode = (CompassMode.Rectangular === this.compassMode);
        const offsetSnap = ((AccuSnap_1.TentativeOrAccuSnap.isHot || IModelApp_1.IModelApp.tentativePoint.isActive) && ((this.locked) || (distance > 0.0)));
        // XY Offset:
        if (offsetSnap) {
            if (isRectMode) {
                let xIsOffset = false, yIsOffset = false;
                const vec = ptP.vectorTo(this._rawPointOnPlane);
                const xOffset = vec.dotProduct(this.axes.x);
                const yOffset = vec.dotProduct(this.axes.y);
                xIsOffset = (Math.abs(xOffset) > 1.0);
                yIsOffset = (Math.abs(yOffset) > 1.0);
                if (xIsOffset || yIsOffset)
                    return true;
            }
        }
        const isOnCompassPlane = (!vp.view.is3d() || this.flags.pointIsOnPlane || this.isZLocked(vp));
        // Z Offset:
        if (offsetSnap) {
            if (isOnCompassPlane) {
                const zOffset = snapPt.distance(this._rawPointOnPlane);
                if (zOffset > 1e-12 /* SMALL_ANGLE */ || zOffset < -1e-12 /* SMALL_ANGLE */)
                    return true;
            }
        }
        // Fat Point:
        if (offsetSnap)
            return true;
        let axisIsIndexed = false;
        // Axis Indexing:
        if (isRectMode) {
            if ((this.indexed & LockedStates.XY_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))
                axisIsIndexed = true;
        }
        else {
            if ((this.indexed & LockedStates.ANGLE_BM || this.locked & LockedStates.ANGLE_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))
                axisIsIndexed = true;
        }
        if (axisIsIndexed)
            return true;
        // Distance Indexing:
        if (this.indexed & LockedStates.DIST_BM)
            return true;
        // XY Lock:
        if (isRectMode && !axisIsIndexed) {
            const locked = this.locked & LockedStates.XY_BM;
            if ((0 !== locked) && isOnCompassPlane) {
                switch (locked) {
                    case LockedStates.X_BM:
                    case LockedStates.Y_BM:
                    case LockedStates.XY_BM:
                        return true;
                }
            }
        }
        return false;
    }
    /** @internal */
    adjustPoint(pointActive, vp, fromSnap) {
        if (!this.isEnabled)
            return false;
        const lastWasIndexed = (0 !== this.indexed);
        let pointChanged = false, handled = false;
        if (0.0 !== pointActive.z && !vp.isPointAdjustmentRequired)
            pointActive.z = 0.0;
        if (this.isInactive) {
            this.point.setFrom(pointActive);
            this.currentView = vp;
            this.fixPoint(pointActive, vp);
            if (!fromSnap && IModelApp_1.IModelApp.accuSnap.currHit)
                this.flags.redrawCompass = true;
        }
        else if (this.isActive) {
            const lastPt = this.point.clone();
            this.fixPoint(pointActive, vp);
            pointChanged = !lastPt.isExactEqual(this.point);
            this.processHints();
            handled = true;
        }
        else {
            this.currentView = vp; // Keep view up to date...
        }
        // If redraw of compass isn't required (yet!) check if needed...
        if (!this.flags.redrawCompass && this.isActive) {
            // Redraw required to erase/draw old/new indexing geometry...
            if (pointChanged && (lastWasIndexed || this.needsRefresh(vp)))
                this.flags.redrawCompass = true;
        }
        // Redraw is necessary, force decorators to be called...
        if (this.flags.redrawCompass)
            vp.invalidateDecorations();
        return handled;
    }
    setDefaultOrigin(vp) {
        if (!vp || this.locked || this._fieldLocked[ItemField.Z_Item])
            return;
        const view = vp.view;
        const rMatrix = view.getRotation();
        const acsOrigin = vp.getAuxCoordOrigin();
        rMatrix.multiplyVectorInPlace(acsOrigin);
        const origin = view.getCenter();
        view.getRotation().multiplyVectorInPlace(origin);
        origin.z = acsOrigin.z;
        view.getRotation().multiplyTransposeVectorInPlace(origin);
        this.origin.setFrom(origin); // View center at acs z...
        this.planePt.setFrom(origin);
    }
    /** @internal */
    isZLocked(vp) {
        if (this._fieldLocked[ItemField.Z_Item])
            return true;
        if (vp.isSnapAdjustmentRequired) //  && TentativeOrAccuSnap.isHot())
            return true;
        return false;
    }
    /** @internal */
    accountForAuxRotationPlane(rot, plane) {
        // ACS mode now can have "front" and "side" variations...
        switch (plane) {
            case RotationMode.Top:
                return;
            case RotationMode.Front:
                const temp = rot.y.clone();
                rot.y.setFrom(rot.z);
                temp.scale(-1.0, rot.z);
                return;
            case RotationMode.Side:
                const temp0 = rot.x.clone();
                rot.x.setFrom(rot.y);
                rot.y.setFrom(rot.z);
                rot.z.setFrom(temp0);
        }
    }
    accountForACSContextLock(vec) {
        // Base rotation is relative to ACS when ACS context lock is enabled...
        if (!this.currentView || !this.currentView.isContextRotationRequired)
            return;
        const rMatrix = AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Top, this.currentView, true);
        rMatrix.multiplyTransposeVectorInPlace(vec);
    }
    static useACSContextRotation(vp, isSnap) {
        if (isSnap) {
            if (!vp.isSnapAdjustmentRequired)
                return false;
        }
        else {
            if (!vp.isContextRotationRequired)
                return false;
        }
        return true;
    }
    /** Gets X, Y or Z vector from top, front, (right) side, ACS, or View. */
    getStandardVector(whichVec) {
        const vp = this.currentView;
        let rMatrix;
        let myAxes;
        const vecP = geometry_core_1.Vector3d.createZero();
        switch (this.flags.baseRotation) {
            case RotationMode.Top:
                switch (whichVec) {
                    case 0:
                        vecP.x = 1.0;
                        break;
                    case 1:
                        vecP.y = 1.0;
                        break;
                    case 2:
                        vecP.z = 1.0;
                        break;
                }
                this.accountForACSContextLock(vecP);
                break;
            case RotationMode.Front:
                switch (whichVec) {
                    case 0:
                        vecP.x = 1.0;
                        break;
                    case 1:
                        vecP.z = 1.0;
                        break;
                    case 2:
                        vecP.y = -1.0;
                        break;
                }
                this.accountForACSContextLock(vecP);
                break;
            case RotationMode.Side:
                switch (whichVec) {
                    case 0:
                        vecP.y = 1.0;
                        break;
                    case 1:
                        vecP.z = 1.0;
                        break;
                    case 2:
                        vecP.x = 1.0;
                        break;
                }
                this.accountForACSContextLock(vecP);
                break;
            case RotationMode.ACS:
                rMatrix = vp ? vp.getAuxCoordRotation() : geometry_core_1.Matrix3d.createIdentity();
                myAxes = ThreeAxes.createFromMatrix3d(rMatrix);
                this.accountForAuxRotationPlane(myAxes, this.flags.auxRotationPlane);
                switch (whichVec) {
                    case 0:
                        vecP.setFrom(myAxes.x);
                        break;
                    case 1:
                        vecP.setFrom(myAxes.y);
                        break;
                    case 2:
                        vecP.setFrom(myAxes.z);
                        break;
                }
                break;
            case RotationMode.View:
                rMatrix = vp ? vp.rotation : geometry_core_1.Matrix3d.createIdentity();
                rMatrix.getRow(whichVec, vecP);
                break;
            case RotationMode.Context:
                myAxes = this.baseAxes.clone();
                this.accountForAuxRotationPlane(myAxes, this.flags.auxRotationPlane);
                switch (whichVec) {
                    case 0:
                        vecP.setFrom(myAxes.x);
                        break;
                    case 1:
                        vecP.setFrom(myAxes.y);
                        break;
                    case 2:
                        vecP.setFrom(myAxes.z);
                        break;
                }
                break;
        }
        return vecP;
    }
    getBestViewedRotationFromXVector(rotation, vp) {
        const viewZ = vp.rotation.getRow(2);
        const vec1 = this.getStandardVector(2);
        const vec2 = this.getStandardVector(1);
        const vec3 = this.getStandardVector(0);
        const rot1 = vec1.crossProduct(rotation.x);
        const rot2 = vec2.crossProduct(rotation.x);
        const rot3 = vec3.crossProduct(rotation.x);
        const useRot1 = (rot1.normalizeWithLength(rot1).mag > 0.00001);
        const useRot2 = (rot2.normalizeWithLength(rot2).mag > 0.00001);
        const useRot3 = (rot3.normalizeWithLength(rot3).mag > 0.00001);
        const dot1 = (useRot1 ? Math.abs(rotation.x.crossProduct(rot1).dotProduct(viewZ)) : -1.0);
        const dot2 = (useRot2 ? Math.abs(rotation.x.crossProduct(rot2).dotProduct(viewZ)) : -1.0);
        const dot3 = (useRot3 ? Math.abs(rotation.x.crossProduct(rot3).dotProduct(viewZ)) : -1.0);
        const max = Math.max(dot1, dot2, dot3);
        if (geometry_core_1.Geometry.isDistanceWithinTol(dot1 - dot2, 0.1) && (max !== dot3))
            rotation.y.setFrom(rot1);
        else if (max === dot1)
            rotation.y.setFrom(rot1);
        else if (max === dot2)
            rotation.y.setFrom(rot2);
        else
            rotation.y.setFrom(rot3);
        rotation.z.setFrom(rotation.x.crossProduct(rotation.y));
    }
    getRotationFromVector(rotation, whichVec) {
        let vec;
        switch (whichVec) {
            case 0:
                vec = this.getStandardVector(2);
                vec.crossProduct(rotation.x, rotation.y);
                if (rotation.y.normalizeWithLength(rotation.y).mag < .00001) {
                    vec = this.getStandardVector(1);
                    vec.crossProduct(rotation.x, rotation.y);
                    rotation.y.normalizeInPlace();
                }
                rotation.x.crossProduct(rotation.y, rotation.z);
                break;
            case 1:
                vec = this.getStandardVector(2);
                vec.crossProduct(rotation.y, rotation.x);
                if (rotation.x.normalizeWithLength(rotation.x).mag < .00001) {
                    vec = this.getStandardVector(0);
                    vec.crossProduct(rotation.y, rotation.x);
                    rotation.x.normalizeInPlace();
                }
                rotation.x.crossProduct(rotation.y, rotation.z);
                break;
            case 2:
                vec = this.getStandardVector(0);
                rotation.z.crossProduct(vec, rotation.y);
                if (rotation.y.normalizeWithLength(rotation.y).mag < .00001) {
                    vec = this.getStandardVector(1);
                    vec.crossProduct(rotation.z, rotation.x);
                    rotation.x.normalizeInPlace();
                    rotation.z.crossProduct(rotation.x, rotation.y);
                }
                else {
                    rotation.y.crossProduct(rotation.z, rotation.x);
                }
                break;
        }
    }
    /** @internal */
    updateRotation(animate = false, newRotationIn) {
        let clearLocks = true;
        const oldRotation = this.axes.clone();
        let rMatrix;
        let newRotation;
        if (!newRotationIn)
            newRotation = this.axes.clone(); // for axis based
        else
            newRotation = ThreeAxes.createFromMatrix3d(newRotationIn); // for animating context rotation change...
        const vp = this.currentView;
        const useACS = vp ? vp.isContextRotationRequired : false;
        switch (this.rotationMode) {
            case RotationMode.Top:
                // Get standard rotation relative to ACS when ACS context lock is enabled...
                newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Top, vp, useACS));
                this.flags.lockedRotation = true;
                break;
            case RotationMode.Front:
                // Get standard rotation relative to ACS when ACS context lock is enabled...
                newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Front, vp, useACS));
                this.flags.lockedRotation = true;
                break;
            case RotationMode.Side:
                // Get standard rotation relative to ACS when ACS context lock is enabled...
                newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Right, vp, useACS));
                this.flags.lockedRotation = true;
                break;
            case RotationMode.ACS:
                rMatrix = vp ? vp.getAuxCoordRotation() : geometry_core_1.Matrix3d.createIdentity();
                newRotation.fromMatrix3d(rMatrix);
                this.accountForAuxRotationPlane(newRotation, this.flags.auxRotationPlane);
                this.flags.lockedRotation = true;
                break;
            case RotationMode.View:
                rMatrix = vp ? vp.rotation : geometry_core_1.Matrix3d.createIdentity();
                newRotation.fromMatrix3d(rMatrix);
                this.flags.lockedRotation = false;
                break;
            case RotationMode.Context:
                switch (this.flags.contextRotMode) {
                    case ContextMode.XAxis:
                        this.getRotationFromVector(newRotation, 0);
                        clearLocks = (LockedStates.Y_BM !== this.locked || !oldRotation.x.isExactEqual(newRotation.x)); // Try to keep locked axis when tool being unsuspended...
                        break;
                    case ContextMode.XAxis2:
                        if (vp)
                            this.getBestViewedRotationFromXVector(newRotation, vp); // Use base rotation axis that results in compass being most closely aligned to view direction....
                        else
                            this.getRotationFromVector(newRotation, 0);
                        clearLocks = (LockedStates.Y_BM !== this.locked || !oldRotation.x.isExactEqual(newRotation.x)); // Try to keep locked axis when tool being unsuspended...
                        break;
                    case ContextMode.YAxis:
                        this.getRotationFromVector(newRotation, 1);
                        clearLocks = (LockedStates.X_BM !== this.locked || !oldRotation.y.isExactEqual(newRotation.y)); // Try to keep locked axis when tool being unsuspended...
                        break;
                    case ContextMode.ZAxis:
                        this.getRotationFromVector(newRotation, 2);
                        break;
                    case ContextMode.Locked:
                        break;
                }
                break;
        }
        const isChanged = !oldRotation.equals(newRotation);
        // unlock stuff if rotation has changed
        if (isChanged && clearLocks && (CompassMode.Rectangular === this.compassMode || !this._fieldLocked[ItemField.DIST_Item] || animate)) {
            this.locked = this.indexed = LockedStates.NONE_LOCKED;
            this.unlockAllFields();
        }
        this.axes.setFrom(newRotation);
        this.lastAxes.setFrom(newRotation);
        this.flags.redrawCompass = true;
        // If animate frame preference is set...
        if (!animate || !vp)
            return;
        // AccuDrawAnimatorPtr animator = AccuDrawAnimator:: Create();
        // viewport -> SetAnimator(* animator);
        // animator -> ChangeOfRotation(Matrix3d:: FromColumnVectors(oldRotation[0], oldRotation[1], oldRotation[2]));
    }
    /** @internal */
    enableForSession() { if (CurrentState.NotEnabled === this.currentState)
        this.currentState = CurrentState.Inactive; }
    /** @internal */
    disableForSession() {
        this.currentState = CurrentState.NotEnabled;
        this.flags.redrawCompass = true; // Make sure decorators are called so we don't draw (i.e. erase AccuDraw compass)
    }
    /** @internal */
    setLastPoint(pt) {
        const viewport = this.currentView;
        if (!viewport)
            return;
        const ev = new Tool_1.BeButtonEvent({ point: pt, rawPoint: pt, viewPoint: viewport.worldToView(pt), viewport, coordsFrom: Tool_1.CoordSource.User });
        IModelApp_1.IModelApp.toolAdmin.setAdjustedDataPoint(ev);
    }
    /** @internal */
    async sendDataPoint(pt, viewport) {
        const ev = new Tool_1.BeButtonEvent({ point: pt, rawPoint: pt, viewPoint: viewport.worldToView(pt), viewport, coordsFrom: Tool_1.CoordSource.User });
        // Send both down and up events...
        await IModelApp_1.IModelApp.toolAdmin.sendButtonEvent(ev);
        ev.isDown = false;
        return IModelApp_1.IModelApp.toolAdmin.sendButtonEvent(ev);
    }
    /** @internal */
    clearTentative() {
        if (!IModelApp_1.IModelApp.tentativePoint.isActive)
            return false;
        const wasSnapped = IModelApp_1.IModelApp.tentativePoint.isSnapped;
        IModelApp_1.IModelApp.tentativePoint.clear(true);
        return wasSnapped;
    }
    /** @internal */
    async doAutoPoint(index, mode) {
        const vp = this.currentView;
        if (!vp)
            return;
        if (CompassMode.Polar === mode) {
            if (!this.autoPointPlacement)
                return;
            if (this._fieldLocked[ItemField.DIST_Item] && (this._fieldLocked[ItemField.ANGLE_Item] || this.indexed & LockedStates.ANGLE_BM) && KeyinStatus.Dynamic === this._keyinStatus[index]) {
                this.fixPointPolar(vp);
                return this.sendDataPoint(this.point, vp);
            }
            return;
        }
        if (this._fieldLocked[ItemField.X_Item] && this._fieldLocked[ItemField.Y_Item]) {
            if (!this.isActive) {
                if (!vp.view.is3d() || this._fieldLocked[ItemField.Z_Item]) {
                    const globalOrigin = new geometry_core_1.Point3d();
                    if (vp.view.isSpatialView())
                        globalOrigin.setFrom(vp.view.iModel.globalOrigin);
                    return this.sendDataPoint(globalOrigin.plus(this.delta), vp);
                }
                return;
            }
            if (!this.autoPointPlacement || KeyinStatus.Dynamic !== this._keyinStatus[index])
                return;
            this.origin.plus3Scaled(this.axes.x, this.delta.x, this.axes.y, this.delta.y, this.axes.z, this.delta.z, this.point);
            return this.sendDataPoint(this.point, vp);
        }
        if (!this.autoPointPlacement || KeyinStatus.Dynamic !== this._keyinStatus[index])
            return;
        if ((ItemField.X_Item === index && this._fieldLocked[ItemField.X_Item] && (this.indexed & LockedStates.Y_BM)) || (ItemField.Y_Item === index && this._fieldLocked[ItemField.Y_Item] && (this.indexed & LockedStates.X_BM))) {
            this.origin.plus3Scaled(this.axes.x, this.delta.x, this.axes.y, this.delta.y, this.axes.z, this.delta.z, this.point);
            return this.sendDataPoint(this.point, vp);
        }
    }
    /** @internal */
    getValueByIndex(index) {
        switch (index) {
            case ItemField.X_Item: return this.delta.x;
            case ItemField.Y_Item: return this.delta.y;
            case ItemField.Z_Item: return this.delta.z;
            case ItemField.DIST_Item: return this._distance;
            case ItemField.ANGLE_Item: return this._angle;
            default:
                return 0.0;
        }
    }
    /** @internal */
    setValueByIndex(index, value) {
        switch (index) {
            case ItemField.X_Item:
                this.delta.x = value;
                break;
            case ItemField.Y_Item:
                this.delta.y = value;
                break;
            case ItemField.Z_Item:
                this.delta.z = value;
                break;
            case ItemField.DIST_Item:
                this._distance = value;
                break;
            case ItemField.ANGLE_Item:
                this._angle = value;
                break;
        }
    }
    updateVector(angle) {
        this.vector.set(Math.cos(angle), Math.sin(angle), 0.0);
        const rMatrix = this.getRotation();
        rMatrix.multiplyTransposeVector(this.vector);
    }
    stringToUORs(_uors, _str) {
        // DistanceParserPtr parser = DistanceParser:: Create();
        // DgnViewportP   vp = GetCompassViewport();
        // if (NULL == vp)
        //   parser = DistanceParser:: Create();
        //   else
        // parser = DistanceParser:: Create(* vp);
        // if (SUCCESS != parser.ToValue(uors, str))
        //   return ERROR;
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    stringToAngle(_angle, _out, _inString, _restrict) {
        // WString     buffer(inString, BentleyCharEncoding:: Utf8);
        // WChar * p1, * p2, * string;
        // int         north = 0, east = 0;
        // bool        bearing = false;
        // if (isBearing)
        //       * isBearing = false;
        // string = buffer.begin();
        // if ((p1 = wcspbrk(string, L"NnSs")) != NULL) {
        //   string = p1 + 1;
        //   if ((p2 = wcspbrk(string, L"EeWw")) == NULL)
        //     return ERROR;
        //   north = (towupper(* p1) == L'N');
        //   east = (towupper(* p2) == L'E');
        //       * p2 = 0; // terminate string
        //   bearing = true;
        // }
        // else if (string[1] == L' ')
        // {
        //   bearing = true;
        //   switch (string[0]) {
        //     case L'1':
        //       north = true;
        //       east = true;
        //       break;
        //     case L'2':
        //       north = false;
        //       east = true;
        //       break;
        //     case L'3':
        //       north = false;
        //       east = false;
        //       break;
        //     case L'4':
        //       north = true;
        //       east = false;
        //       break;
        //     default:
        //       bearing = false;
        //       break;
        //   }
        //   if (bearing)
        //     string += 2;
        // }
        //   else
        // {
        //   bearing = false;
        // }
        // while (* string == L' ')
        // string++;
        // AngleParserPtr parser = AngleParser:: Create();
        // _SetupAngleParser(* parser);
        // if (SUCCESS != parser -> ToValue(angle, Utf8String(string).c_str()))
        //   return ERROR;
        // if (bearing) {
        //   if (north) {
        //     if (east)
        //       angle = 90.0 - angle;
        //     else
        //       angle = 90.0 + angle;
        //   }
        //   else {
        //     if (east)
        //       angle = 270.0 + angle;
        //     else
        //       angle = 270.0 - angle;
        //   }
        // }
        // else {
        //   DirectionFormatterPtr  formatter;
        //   DgnViewportP vp = GetCompassViewport();
        //   if (vp)
        //     formatter = DirectionFormatter:: Create(* vp -> GetViewController().GetTargetModel());
        //       else
        //   formatter = DirectionFormatter:: Create();
        //   if (DirectionMode:: Azimuth == formatter -> GetDirectionMode())
        //   {
        //     if (formatter -> GetClockwise())
        //       angle = formatter -> GetBaseDirection() - angle;
        //     else
        //       angle = angle - formatter -> GetBaseDirection();
        //   }
        // }
        // if (restrict == true) {
        //   while (angle >= 360.0)
        //     angle -= 360.0;
        //   while (angle < 0.0)
        //     angle += 360.0;
        // }
        // angle *= (msGeomConst_pi / 180.0);
        // if (isBearing)
        //       * isBearing = bearing;
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    updateFieldValue(index, input, out) {
        if (input.length === 0)
            return bentleyjs_core_1.BentleyStatus.ERROR;
        if (input.length === 1)
            switch (input) {
                case ":":
                case "-":
                case "+":
                case ".":
                    return bentleyjs_core_1.BentleyStatus.ERROR;
            }
        switch (index) {
            case ItemField.DIST_Item:
                if (bentleyjs_core_1.BentleyStatus.SUCCESS !== this.stringToUORs([this._distance], input))
                    return bentleyjs_core_1.BentleyStatus.ERROR;
                break;
            case ItemField.ANGLE_Item:
                if (bentleyjs_core_1.BentleyStatus.SUCCESS !== this.stringToAngle([this._angle], out, input, true))
                    return bentleyjs_core_1.BentleyStatus.ERROR;
                break;
            case ItemField.X_Item:
                if (bentleyjs_core_1.BentleyStatus.SUCCESS !== this.stringToUORs([this.delta.x], input))
                    return bentleyjs_core_1.BentleyStatus.ERROR;
                this._xIsExplicit = (input[0] === "+" || input[0] === "-");
                if (!this._xIsExplicit) {
                    if (this.smartKeyin && this.isActive && this._xIsNegative === (this.delta.x >= 0.0))
                        this.delta.x = -this.delta.x;
                }
                break;
            case ItemField.Y_Item:
                if (bentleyjs_core_1.BentleyStatus.SUCCESS !== this.stringToUORs([this.delta.y], input))
                    return bentleyjs_core_1.BentleyStatus.ERROR;
                this._yIsExplicit = (input[0] === "+" || input[0] === "-");
                if (!this._yIsExplicit) {
                    if (this.smartKeyin && this.isActive && this._yIsNegative === (this.delta.y >= 0.0))
                        this.delta.y = -this.delta.y;
                }
                break;
            case ItemField.Z_Item:
                if (bentleyjs_core_1.BentleyStatus.SUCCESS !== this.stringToUORs([this.delta.z], input))
                    return bentleyjs_core_1.BentleyStatus.ERROR;
                break;
        }
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    /** @internal */
    unlockAllFields() {
        this.locked = 0;
        if (CompassMode.Polar === this.compassMode) {
            if (this._fieldLocked[ItemField.DIST_Item])
                this.setFieldLock(ItemField.DIST_Item, false);
            if (this._fieldLocked[ItemField.ANGLE_Item])
                this.setFieldLock(ItemField.ANGLE_Item, false);
        }
        else {
            if (this._fieldLocked[ItemField.X_Item])
                this.setFieldLock(ItemField.X_Item, false);
            if (this._fieldLocked[ItemField.Y_Item])
                this.setFieldLock(ItemField.Y_Item, false);
        }
        if (this._fieldLocked[ItemField.Z_Item]) {
            if (this.stickyZLock)
                this.delta.z = 0.0;
            else
                this.setFieldLock(ItemField.Z_Item, false);
        }
        this.setKeyinStatus(ItemField.DIST_Item, KeyinStatus.Dynamic);
        this.setKeyinStatus(ItemField.ANGLE_Item, KeyinStatus.Dynamic);
        this.setKeyinStatus(ItemField.X_Item, KeyinStatus.Dynamic);
        this.setKeyinStatus(ItemField.Y_Item, KeyinStatus.Dynamic);
        this.setKeyinStatus(ItemField.Z_Item, KeyinStatus.Dynamic);
        if (!this.smartKeyin)
            this.setFocusItem(CompassMode.Polar === this.compassMode ? ItemField.DIST_Item : ItemField.X_Item);
        this.dontMoveFocus = false;
    }
    /** produces the normal vector of the closest plane to the view which
     * contains inVec (uses true view rotation, never auxiliary)
     */
    planeByVectorAndView(normalVec, inVec, vp) {
        if (!vp.view.is3d()) {
            normalVec.setFrom(geometry_core_1.Vector3d.unitZ());
            return true;
        }
        const viewNormal = vp.rotation.getRow(2);
        const yVec = viewNormal.crossProduct(inVec);
        if (!yVec.normalizeInPlace()) {
            normalVec = viewNormal;
            return false;
        }
        inVec.crossProduct(yVec, normalVec);
        return true;
    }
    handleDegeneratePolarCase() {
        if (!(this.locked & LockedStates.DIST_BM))
            this._distance = 0.0;
        if (this.locked & LockedStates.VEC_BM) {
            this._angle = Math.acos(this.vector.dotProduct(this.axes.x));
        }
        else if (this.locked & LockedStates.Y_BM) {
            this.vector.setFrom(this.axes.y);
            this._angle = Math.PI / 2.0;
            this.indexed = this.locked;
        }
        else if (this.locked & LockedStates.X_BM) {
            this.vector.setFrom(this.axes.x);
            this._angle = 0.0;
            this.indexed = this.locked;
        }
        else {
            // use last good vector
            this._angle = Math.acos(this.vector.dotProduct(this.axes.x));
        }
        this.origin.plusScaled(this.vector, this._distance, this.point);
    }
    rawDeltaIsValid(rawDelta) {
        /* Cursor Distance (*(+/-)) sense testing is not valid when raw delta is
           meaningless (0.0)...to make this change safer only reject the
           raw delta if unit or grid lock is also on. */
        if (0.0 !== rawDelta)
            return true;
        // The "I don't want grid lock" flag can be set by tools to override the default behavior...
        if (0 === (IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr & Tool_1.CoordinateLockOverrides.Grid))
            return true;
        return (!IModelApp_1.IModelApp.toolAdmin.gridLock);
    }
    /** @internal */
    async processFieldInput(index, input, synchText) {
        const isBearing = false;
        if (bentleyjs_core_1.BentleyStatus.SUCCESS !== this.updateFieldValue(index, input, { isBearing })) {
            const saveKeyinStatus = this._keyinStatus[index]; // Don't want this to change when entering '.', etc.
            this.updateFieldLock(index, false);
            this._keyinStatus[index] = saveKeyinStatus;
            return;
        }
        switch (index) {
            case ItemField.DIST_Item:
                this.distanceLock(synchText, true);
                await this.doAutoPoint(index, CompassMode.Polar);
                break;
            case ItemField.ANGLE_Item:
                this.setFieldLock(index, true);
                if (synchText) {
                    this.onFieldValueChange(index);
                    this.setKeyinStatus(index, KeyinStatus.Dynamic);
                }
                if (!isBearing || !this.flags.bearingFixToPlane2D)
                    this.updateVector(this._angle);
                else
                    this.vector.set(Math.cos(this._angle), Math.sin(this._angle), 0.0);
                this.locked |= LockedStates.VEC_BM;
                await this.doAutoPoint(index, CompassMode.Polar);
                break;
            case ItemField.X_Item:
            case ItemField.Y_Item:
                this.locked |= (ItemField.X_Item === index) ? LockedStates.X_BM : LockedStates.Y_BM;
            /* falls through */
            case ItemField.Z_Item:
                this.setFieldLock(index, true);
                if (synchText) {
                    this.onFieldValueChange(index);
                    this.setKeyinStatus(index, KeyinStatus.Dynamic);
                }
                await this.doAutoPoint(index, this.compassMode);
                break;
        }
        this.refreshDecorationsAndDynamics();
    }
    /** @internal */
    updateFieldLock(index, locked) {
        if (locked) {
            if (!this._fieldLocked[index]) {
                this.setFieldLock(index, true);
                switch (index) {
                    case ItemField.DIST_Item:
                        this.distanceLock(true, false);
                        break;
                    case ItemField.ANGLE_Item:
                        this.angleLock();
                        break;
                    case ItemField.X_Item:
                        this.locked |= LockedStates.X_BM;
                        break;
                    case ItemField.Y_Item:
                        this.locked |= LockedStates.Y_BM;
                        break;
                    case ItemField.Z_Item:
                        break;
                }
            }
            return;
        }
        switch (index) {
            case ItemField.DIST_Item:
                this.locked &= ~LockedStates.DIST_BM;
                break;
            case ItemField.ANGLE_Item:
                this.locked &= ~LockedStates.VEC_BM;
                break;
            case ItemField.X_Item:
                this.locked &= ~LockedStates.X_BM;
                break;
            case ItemField.Y_Item:
                this.locked &= ~LockedStates.Y_BM;
                break;
        }
        if (index !== ItemField.Z_Item || !this.stickyZLock)
            this.setFieldLock(index, false);
        this.setKeyinStatus(index, KeyinStatus.Dynamic);
    }
    /** @internal */
    static getSnapRotation(snap, currentVp, out) {
        const vp = (undefined !== currentVp) ? currentVp : snap.viewport;
        const rotation = out ? out : new geometry_core_1.Matrix3d();
        const viewZ = vp.rotation.rowZ();
        const snapLoc = (undefined !== snap.primitive ? snap.primitive.closestPoint(snap.snapPoint, false) : undefined);
        if (undefined !== snapLoc) {
            const frame = snap.primitive.fractionToFrenetFrame(snapLoc.fraction);
            const frameZ = (undefined !== frame ? frame.matrix.columnZ() : geometry_core_1.Vector3d.unitZ());
            let xVec = (undefined !== frame ? frame.matrix.columnX() : geometry_core_1.Vector3d.unitX());
            const zVec = (vp.view.allow3dManipulations() ? (undefined !== snap.normal ? snap.normal.clone() : frameZ.clone()) : geometry_core_1.Vector3d.unitZ());
            if (!vp.isCameraOn && viewZ.isPerpendicularTo(zVec))
                zVec.setFrom(viewZ);
            xVec.normalizeInPlace();
            zVec.normalizeInPlace();
            let yVec = xVec.unitCrossProduct(zVec);
            if (undefined !== yVec) {
                const viewX = vp.rotation.rowX();
                if (snap.primitive instanceof geometry_core_1.LineString3d) {
                    if (Math.abs(xVec.dotProduct(viewX)) < Math.abs(yVec.dotProduct(viewX))) {
                        const tVec = xVec;
                        xVec = yVec;
                        yVec = tVec;
                    }
                    if (xVec.dotProduct(viewX) < 0.0)
                        xVec.negate(xVec);
                }
                else {
                    const ray = snap.primitive.fractionToPointAndUnitTangent(0.0);
                    if (ray.direction.dotProduct(viewX) < 0.0 && ray.direction.dotProduct(xVec) > 0.0)
                        xVec.negate(xVec);
                }
                if (zVec.dotProduct(viewZ) < 0.0)
                    zVec.negate(zVec);
                yVec = xVec.unitCrossProduct(zVec);
                if (undefined !== yVec) {
                    rotation.setColumns(xVec, yVec, zVec);
                    geometry_core_1.Matrix3d.createRigidFromMatrix3d(rotation, geometry_core_1.AxisOrder.XZY, rotation);
                    rotation.transposeInPlace();
                    return rotation;
                }
            }
        }
        if (undefined !== snap.normal) {
            const zVec = (vp.view.allow3dManipulations() ? snap.normal.clone() : geometry_core_1.Vector3d.unitZ());
            if (!vp.isCameraOn && viewZ.isPerpendicularTo(zVec))
                zVec.setFrom(viewZ);
            zVec.normalizeInPlace();
            geometry_core_1.Matrix3d.createRigidHeadsUp(zVec, undefined, rotation);
            rotation.transposeInPlace();
            return rotation;
        }
        return undefined;
    }
    /** @internal */
    static getStandardRotation(nStandard, vp, useACS, out) {
        const rMatrix = out ? out : new geometry_core_1.Matrix3d();
        rMatrix.setFrom(ViewState_1.ViewState.getStandardViewMatrix(nStandard));
        const useVp = vp ? vp : IModelApp_1.IModelApp.viewManager.selectedView;
        if (!useACS || !useVp)
            return rMatrix;
        rMatrix.multiplyMatrixMatrix(useVp.getAuxCoordRotation(AccuDraw._tempRot), rMatrix);
        return rMatrix;
    }
    /** @internal */
    static getCurrentOrientation(vp, checkAccuDraw, checkACS, rMatrix) {
        if (checkAccuDraw && IModelApp_1.IModelApp.accuDraw.isActive)
            return IModelApp_1.IModelApp.accuDraw.getRotation(rMatrix);
        const useVp = vp ? vp : IModelApp_1.IModelApp.viewManager.selectedView;
        if (!useVp)
            return geometry_core_1.Matrix3d.createIdentity(rMatrix);
        if (checkACS && useVp.isContextRotationRequired)
            return useVp.getAuxCoordRotation(rMatrix);
        return useVp.rotation;
    }
    /** @internal */
    static updateAuxCoordinateSystem(acs, vp, allViews = true) {
        // When modeling with multiple spatial views open, you'd typically want the same ACS in all views...
        if (allViews && vp.view.isSpatialView()) {
            IModelApp_1.IModelApp.viewManager.forEachViewport((otherVp) => {
                if (otherVp !== vp && otherVp.view.isSpatialView())
                    otherVp.view.setAuxiliaryCoordinateSystem(acs);
            });
        }
        vp.view.setAuxiliaryCoordinateSystem(acs);
        // NOTE: Change AccuDraw's base rotation to ACS.
        IModelApp_1.IModelApp.accuDraw.setContext(AccuDrawFlags.OrientACS);
    }
    /** @internal */
    distanceLock(synchText, saveInHistory) {
        this.locked |= LockedStates.DIST_BM;
        if (!this._fieldLocked[ItemField.DIST_Item])
            this.setFieldLock(ItemField.DIST_Item, true);
        if (saveInHistory)
            this.saveCoordinate(ItemField.DIST_Item, this._distance);
        if (synchText) {
            this.onFieldValueChange(ItemField.DIST_Item);
            this.setKeyinStatus(ItemField.DIST_Item, KeyinStatus.Dynamic);
        }
    }
    /** @internal */
    angleLock() {
        if (this.indexed & LockedStates.Y_BM)
            this.locked |= LockedStates.Y_BM;
        else if (this.indexed & LockedStates.X_BM)
            this.locked |= LockedStates.X_BM;
        else
            this.locked |= LockedStates.VEC_BM;
        this.clearTentative();
        if (!this._fieldLocked[ItemField.ANGLE_Item]) {
            this.setFieldLock(ItemField.ANGLE_Item, true);
            this.setKeyinStatus(ItemField.ANGLE_Item, KeyinStatus.Dynamic);
        }
        this.flags.lockedRotation = true;
        this.flags.softAngleLock = false;
    }
    /** @internal */
    doLockAngle(isSnapped) {
        if (CompassMode.Polar !== this.compassMode) {
            this.locked = LockedStates.NONE_LOCKED;
            this._rawPoint.setFrom(this.point);
            const vp = this.currentView;
            if (vp)
                this.fixPointPolar(vp);
            this.changeCompassMode(true);
        }
        this.setFieldLock(ItemField.ANGLE_Item, !this._fieldLocked[ItemField.ANGLE_Item]);
        if (this._fieldLocked[ItemField.ANGLE_Item]) {
            // Move focus to angle field...
            if (!isSnapped && this.autoFocusFields)
                this.setFocusItem(ItemField.ANGLE_Item);
            this.angleLock();
            if (!isSnapped)
                this.flags.softAngleLock = true;
        }
        else {
            this.locked &= ~LockedStates.ANGLE_BM;
            this.saveCoordinate(ItemField.ANGLE_Item, this._angle);
        }
    }
    /** @internal */
    saveCoordinate(index, value) {
        const isAngle = (ItemField.ANGLE_Item === index);
        let currIndex = this._savedCoords.nSaveValues + 1;
        if (currIndex >= 20 /* MAX_SAVED_VALUES */)
            currIndex = 0;
        if (this._savedCoords.savedValues[this._savedCoords.nSaveValues] === value && this._savedCoords.savedValIsAngle[this._savedCoords.nSaveValues] === isAngle)
            return;
        if (isAngle) {
            // don't accept 0, 90, -90, and 180 degrees
            if (value === 0.0 || value === Math.PI || value === (Math.PI / 2.0) || value === -Math.PI)
                return;
        }
        else {
            // don't accept zero
            value = Math.abs(value);
            if (value < 1e-12 /* SMALL_ANGLE */)
                return;
        }
        this._savedCoords.savedValues[currIndex] = value;
        this._savedCoords.savedValIsAngle[currIndex] = isAngle;
        this._savedCoords.nSaveValues = currIndex;
        if (!isAngle)
            this._lastDistance = value;
    }
    /** @internal */
    changeCompassMode(animate = false) {
        this.setCompassMode(CompassMode.Polar === this.compassMode ? CompassMode.Rectangular : CompassMode.Polar);
        const viewport = this.currentView;
        if (!animate || !viewport)
            return;
        // AccuDrawAnimatorPtr animator = AccuDrawAnimator:: Create();
        // viewport.setAnimator(* animator);
        // animator -> ChangeOfMode();
    }
    /** @internal */
    changeBaseRotationMode(mode) {
        if (mode > RotationMode.Context)
            return;
        if (RotationMode.Context === mode) {
            // See if it is better to stay with the current base rotation (only care about z)...
            if (RotationMode.Context !== this.flags.baseRotation) {
                const baseRMatrix = this.getBaseRotation();
                const baseZ = baseRMatrix.getRow(2);
                if (baseZ.isParallelTo(this.axes.z, true))
                    return;
            }
            this.baseAxes.setFrom(this.axes);
            this.flags.auxRotationPlane = RotationMode.Top;
        }
        this.flags.baseRotation = mode;
    }
    getBaseRotation() {
        const vp = this.currentView;
        let baseRMatrix;
        const useAcs = vp ? vp.isContextRotationRequired : false;
        switch (this.flags.baseRotation) {
            case RotationMode.Top: {
                baseRMatrix = AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Top, vp, useAcs);
                break;
            }
            case RotationMode.Front: {
                baseRMatrix = AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Front, vp, useAcs);
                break;
            }
            case RotationMode.Side: {
                baseRMatrix = AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Right, vp, useAcs);
                break;
            }
            case RotationMode.ACS: {
                baseRMatrix = vp ? vp.getAuxCoordRotation() : geometry_core_1.Matrix3d.createIdentity();
                const axes = ThreeAxes.createFromMatrix3d(baseRMatrix);
                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);
                axes.toMatrix3d(baseRMatrix);
                break;
            }
            case RotationMode.View: {
                baseRMatrix = vp ? vp.rotation : geometry_core_1.Matrix3d.createIdentity();
                break;
            }
            case RotationMode.Context: {
                const axes = new ThreeAxes();
                axes.setFrom(this.baseAxes);
                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);
                baseRMatrix = axes.toMatrix3d();
                break;
            }
            default: {
                baseRMatrix = geometry_core_1.Matrix3d.createIdentity();
                break;
            }
        }
        return baseRMatrix;
    }
    /** @internal */
    setContextRotation(rMatrix, locked, animate) {
        this.flags.lockedRotation = locked;
        this.flags.contextRotMode = locked ? ContextMode.Locked : ContextMode.None;
        this.setRotationMode(RotationMode.Context);
        this.updateRotation(animate, rMatrix);
    }
    clearContext() {
        this.published.flags = 0;
        this.flags.rotationNeedsUpdate = true;
        this.flags.fixedOrg = false;
        this.setNewFocus(ItemField.X_Item);
        this.unlockAllFields();
        if (this.rotationMode !== this.flags.baseRotation)
            this.setRotationMode(this.flags.baseRotation);
        if (this.compassMode !== this.flags.baseMode)
            this.setCompassMode(this.flags.baseMode);
    }
    /** @internal */
    setContext(flags, originP, orientationP, deltaP, distanceP, angleP, transP) {
        this.published.flags |= flags;
        if (flags & AccuDrawFlags.SetOrigin && originP) {
            this.published.origin.setFrom(originP);
            if (transP)
                transP.multiplyPoint3d(this.published.origin, this.published.origin);
        }
        if (deltaP) {
            this.published.delta.setFrom(deltaP);
            if (transP)
                this.published.delta.scaleInPlace(transP.matrix.columnX().magnitude());
        }
        if (typeof distanceP === "number") {
            this.published.distance = distanceP;
            if (transP)
                this.published.distance *= transP.matrix.columnX().magnitude();
        }
        if (typeof angleP === "number")
            this.published.angle = angleP;
        if (orientationP) {
            if (flags & AccuDrawFlags.SetXAxis || flags & AccuDrawFlags.SetNormal || flags & AccuDrawFlags.SetXAxis2) {
                this.published.vector.setFrom(orientationP);
                if (transP)
                    transP.matrix.multiplyVectorInPlace(this.published.vector);
                this.published.vector.normalizeInPlace();
            }
            else if (flags & AccuDrawFlags.SetRMatrix) {
                this.published.rMatrix.setFrom(orientationP);
                if (transP) {
                    this.published.rMatrix.multiplyMatrixMatrix(transP.matrix, this.published.rMatrix);
                    this.published.rMatrix.normalizeColumnsInPlace();
                }
            }
        }
        if (flags) {
            this.onEventCommon();
            if (!this.flags.haveValidOrigin)
                this.setDefaultOrigin(this.currentView);
        }
        return this.isEnabled ? bentleyjs_core_1.BentleyStatus.SUCCESS : bentleyjs_core_1.BentleyStatus.ERROR;
    }
    onEventCommon() {
        if (this.published.flags & AccuDrawFlags.RedrawCompass) {
            this.flags.indexLocked = true;
            this.flags.redrawCompass = true;
        }
        if (this.published.flags & AccuDrawFlags.UpdateRotation) {
            this.flags.indexLocked = true;
            this.flags.contextRotMode = ContextMode.XAxis;
            this.setRotationMode(RotationMode.Context);
            this.updateRotation();
            this.flags.indexLocked = true;
        }
    }
    /** @internal */
    onPrimitiveToolInstall() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        this.saveLockedCoords();
        // Setup default starting tool state...
        this.currentState = CurrentState.Inactive;
        this.clearContext();
        if (this.alwaysShowCompass)
            this.activate();
        return false;
    }
    /** @internal */
    onViewToolInstall() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        const tool = IModelApp_1.IModelApp.toolAdmin.activeTool;
        if (tool && !(tool instanceof ViewTool_1.ViewTool))
            this.saveState(this.savedStateViewTool); // Save AccuDraw state of tool being suspended...
        this.currentState = CurrentState.Deactivated; // Default to disabled for view tools.
        return false;
    }
    /** @internal */
    onViewToolExit() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        this.restoreState(this.savedStateViewTool); // Restore AccuDraw state of suspended tool...
        return false;
    }
    /** @internal */
    onInputCollectorInstall() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        const tool = IModelApp_1.IModelApp.toolAdmin.activeTool;
        if (tool && !(tool instanceof Tool_1.InputCollector))
            this.saveState(this.savedStateInputCollector); // Save AccuDraw state of tool being suspended...
        this.currentState = CurrentState.Inactive; // Default to inactive for input collectors.
        return false;
    }
    /** @internal */
    onInputCollectorExit() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        this.restoreState(this.savedStateInputCollector); // Restore AccuDraw state of suspended tool...
        return false;
    }
    /** @internal */
    saveState(stateBuffer) {
        stateBuffer.state = this.currentState;
        stateBuffer.mode = this.compassMode;
        stateBuffer.rotationMode = this.rotationMode;
        stateBuffer.axes.setFrom(this.axes);
        stateBuffer.origin.setFrom(this.origin);
        stateBuffer.auxRotationPlane = this.flags.auxRotationPlane;
        stateBuffer.contextRotMode = this.flags.contextRotMode;
        stateBuffer.fixedOrg = this.flags.fixedOrg;
        stateBuffer.ignoreDataButton = true;
        stateBuffer.ignoreFlags = 0;
    }
    /** @internal */
    restoreState(stateBuffer) {
        if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.Disable)) {
            this.currentState = stateBuffer.state;
        }
        if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.SetOrigin)) {
            this.origin.setFrom(stateBuffer.origin);
            this.planePt.setFrom(stateBuffer.origin);
        }
        if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.SetRMatrix)) {
            this.axes.setFrom(stateBuffer.axes);
            this.setRotationMode(stateBuffer.rotationMode);
            this.flags.auxRotationPlane = stateBuffer.auxRotationPlane;
            this.flags.contextRotMode = stateBuffer.contextRotMode;
        }
        this.flags.fixedOrg = stateBuffer.fixedOrg;
        this.setCompassMode(stateBuffer.mode);
        this.updateRotation();
        if (stateBuffer.ignoreDataButton)
            this.flags.ignoreDataButton = (this.flags.inDataPoint ? true : false);
    }
    getCompassPlanePoint(point, vp) {
        point.setFrom(this.origin); // Isn't this just planePt?!? Maybe at display time it is not setup yet?!?
        if (this._fieldLocked[ItemField.Z_Item] && vp.view.is3d()) {
            if (0.0 !== this.delta.z && !(this.delta.z < 1e-12 /* SMALL_ANGLE */ && this.delta.z > -1e-12 /* SMALL_ANGLE */)) {
                point.addScaledInPlace(this.axes.z, this.delta.z);
                return true;
            }
        }
        return false;
    }
    getDisplayTransform(vp) {
        const rMatrix = (!this.flags.animateRotation || 0.0 === this._percentChanged) ? this.axes.toMatrix3d() : this.lastAxes.toMatrix3d();
        const origin = new geometry_core_1.Point3d(); // Compass origin is adjusted by active z-lock...
        this.getCompassPlanePoint(origin, vp);
        const scale = vp.pixelsFromInches(this._compassSizeInches) * vp.getPixelSizeAtPoint(origin);
        rMatrix.transposeInPlace();
        rMatrix.scaleColumns(scale, scale, scale, rMatrix);
        return geometry_core_1.Transform.createRefs(origin, rMatrix);
    }
    setIndexingTolerance(vp) {
        const origin = new geometry_core_1.Point3d(); // Compass origin is adjusted by active z-lock...
        this.getCompassPlanePoint(origin, vp);
        this._tolerance = vp.pixelsFromInches(this._indexToleranceInches) * vp.getPixelSizeAtPoint(origin);
        if (1e-12 /* SMALL_ANGLE */ > this._tolerance)
            this._tolerance = 1e-12 /* SMALL_ANGLE */;
    }
    displayAlignments(graphic, vp) {
        const bgColor = vp.view.backgroundColor;
        const colorIndex = this._indexColor.adjustForContrast(bgColor, 130);
        const origin = new geometry_core_1.Point3d(); // Compass origin is adjusted by active z-lock...
        // For non-zero Z value draw indicator line from plane point to compass origin...
        if (this.getCompassPlanePoint(origin, vp)) {
            const colorZ = this._frameColor.adjustForContrast(bgColor, 155);
            graphic.setSymbology(colorZ, colorZ, 2);
            graphic.addLineString([origin, this.origin]);
            graphic.setSymbology(colorZ, colorZ, 4);
            graphic.addPointString([this.origin]);
        }
        // Get snap point from AccuSnap/Tentative or use raw point...
        let distance = 0.0;
        let snapPt = this._rawPoint;
        const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap();
        if (snap) {
            snapPt = snap.snapPoint;
            distance = this.point.distance(snapPt);
        }
        const isRectMode = (CompassMode.Rectangular === this.compassMode);
        const offsetSnap = ((AccuSnap_1.TentativeOrAccuSnap.isHot || IModelApp_1.IModelApp.tentativePoint.isActive) && ((this.locked) || (distance > 0.0)));
        // XY Offset:
        if (offsetSnap) {
            if (isRectMode) {
                const vec = this.point.vectorTo(this._rawPointOnPlane);
                const xOffset = vec.dotProduct(this.axes.x);
                const yOffset = vec.dotProduct(this.axes.y);
                const xIsOffset = (Math.abs(xOffset) > 1.0);
                const yIsOffset = (Math.abs(yOffset) > 1.0);
                if (xIsOffset) {
                    if (yIsOffset) { /* both */
                        const pts = [
                            this.point,
                            this.point.plusScaled(this.axes.y, yOffset),
                            this._rawPointOnPlane,
                            this.point.plusScaled(this.axes.x, xOffset)
                        ];
                        pts[4] = pts[0];
                        graphic.setSymbology(colorIndex, colorIndex, 2, imodeljs_common_1.LinePixels.Code5);
                        graphic.addLineString(pts);
                    }
                    else { /* just X */
                        graphic.setSymbology(colorIndex, colorIndex, 2, imodeljs_common_1.LinePixels.Code5);
                        graphic.addLineString([this.point, this._rawPointOnPlane]);
                    }
                }
                else if (yIsOffset) { /* just Y */
                    graphic.setSymbology(colorIndex, colorIndex, 2, imodeljs_common_1.LinePixels.Code5);
                    graphic.addLineString([this.point, this._rawPointOnPlane]);
                }
            }
        }
        const isOnCompassPlane = (!vp.view.is3d() || this.flags.pointIsOnPlane || this.isZLocked(vp));
        // Z Offset:
        if (offsetSnap) {
            if (isOnCompassPlane) {
                if (isRectMode) {
                    const zOffset = snapPt.distance(this._rawPointOnPlane);
                    if (zOffset > 1e-12 /* SMALL_ANGLE */ || zOffset < -1e-12 /* SMALL_ANGLE */) {
                        graphic.setSymbology(colorIndex, colorIndex, 2, imodeljs_common_1.LinePixels.Code5);
                        graphic.addLineString([this._rawPointOnPlane, this._rawPoint]);
                    }
                }
                else {
                    graphic.setSymbology(colorIndex, colorIndex, 2, imodeljs_common_1.LinePixels.Code5);
                    graphic.addLineString([this.point, this._rawPoint]);
                }
            }
        }
        // Fat Point:
        if (offsetSnap) {
            graphic.setSymbology(colorIndex, colorIndex, 8);
            graphic.addPointString([this.point]);
        }
        let axisIsIndexed = false;
        // Axis Indexing:
        if (isRectMode) {
            if ((this.indexed & LockedStates.XY_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))
                axisIsIndexed = true;
        }
        else {
            if ((this.indexed & LockedStates.ANGLE_BM || this.locked & LockedStates.ANGLE_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))
                axisIsIndexed = true;
        }
        if (axisIsIndexed) {
            graphic.setSymbology(colorIndex, colorIndex, 4);
            graphic.addLineString([this.point, this.planePt]);
        }
        // Distance Indexing:
        if (this.indexed & LockedStates.DIST_BM) {
            const len = this._tolerance; // Show tick mark based on _GetIndexToleranceInches for length...
            let vec;
            if (isRectMode) {
                let index = this.indexed & LockedStates.XY_BM;
                if (!index)
                    index = this.locked & LockedStates.XY_BM;
                vec = (index === LockedStates.X_BM) ? this.axes.x : this.axes.y;
            }
            else {
                const deltaVec = this.origin.vectorTo(this.point);
                vec = this.axes.z.crossProduct(deltaVec);
                vec.normalizeInPlace();
            }
            graphic.setSymbology(colorIndex, colorIndex, 3);
            graphic.addLineString([this.point.plusScaled(vec, len), this.point.plusScaled(vec, -len)]);
        }
        // XY Lock:
        if (isRectMode && !axisIsIndexed) {
            const locked = this.locked & LockedStates.XY_BM;
            if ((0 !== locked) && isOnCompassPlane) {
                const pts = [this.point, this.point, this.point];
                if (locked & LockedStates.X_BM)
                    pts[2].setFrom(this.planePt.plusScaled(this.axes.x, this.delta.x));
                if (locked & LockedStates.Y_BM)
                    pts[0].setFrom(this.planePt.plusScaled(this.axes.y, this.delta.y));
                switch (locked) {
                    case LockedStates.X_BM:
                        graphic.setSymbology(colorIndex, colorIndex, 2, imodeljs_common_1.LinePixels.Code5);
                        graphic.addLineString([pts[1], pts[2]]);
                        break;
                    case LockedStates.Y_BM:
                        graphic.setSymbology(colorIndex, colorIndex, 2, imodeljs_common_1.LinePixels.Code5);
                        graphic.addLineString([pts[0], pts[1]]);
                        break;
                    case LockedStates.XY_BM:
                        graphic.setSymbology(colorIndex, colorIndex, 2, imodeljs_common_1.LinePixels.Code5);
                        graphic.addLineString(pts);
                        break;
                }
            }
        }
    }
    /** @internal */
    testDecorationHit(id) { return id === this._acsPickId; }
    /** @internal */
    getDecorationGeometry(hit) {
        if (!hit.viewport.viewFlags.acsTriad)
            return undefined;
        const geomData = geometry_core_1.IModelJson.Writer.toIModelJson(geometry_core_1.PointString3d.create(hit.viewport.view.auxiliaryCoordinateSystem.getOrigin()));
        if (undefined === geomData)
            return undefined;
        const acsGeom = [geomData];
        return acsGeom;
    }
    /** @internal */
    decorate(context) {
        if (context.viewport.viewFlags.acsTriad) {
            context.viewport.view.auxiliaryCoordinateSystem.display(context, (AuxCoordSys_1.ACSDisplayOptions.CheckVisible | AuxCoordSys_1.ACSDisplayOptions.Active));
            if (undefined === this._acsPickId)
                this._acsPickId = context.viewport.iModel.transientIds.next;
            const acsPickBuilder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldDecoration, undefined, this._acsPickId);
            const color = imodeljs_common_1.ColorDef.blue.adjustForContrast(context.viewport.view.backgroundColor, 50);
            acsPickBuilder.setSymbology(color, color, 6);
            acsPickBuilder.addPointString([context.viewport.view.auxiliaryCoordinateSystem.getOrigin()]);
            context.addDecorationFromBuilder(acsPickBuilder);
        }
        // Make sure this is cleared even if we do nothing...redraw might have been to make compass go away...
        this.flags.redrawCompass = false;
        // Check that AccuDraw is enabled...
        if (!this.isActive)
            return;
        const vp = context.viewport;
        if (this.currentView !== vp) // Do nothing if AccuDraw is not enabled for this view...
            return;
        this.setIndexingTolerance(vp);
        // Display indexing lines, distance locks, etc. without compass transform...
        let builder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldOverlay);
        this.displayAlignments(builder, vp);
        context.addDecorationFromBuilder(builder);
        // Create a new graphics with the compass transform and scale so that compass size is 1.0...
        builder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldOverlay, this.getDisplayTransform(vp));
        const hasFocus = this.hasInputFocus;
        const bgColor = vp.view.backgroundColor;
        const frameColor = (hasFocus ? this._frameColor : this._frameColorNoFocus).adjustForContrast(bgColor, 155);
        const fillColor = (hasFocus ? this._fillColor : this._fillColorNoFocus).adjustForContrast(bgColor, 75);
        const xColor = (hasFocus ? this._xColor : this._frameColorNoFocus).adjustForContrast(bgColor, 155);
        const yColor = (hasFocus ? this._yColor : this._frameColorNoFocus).adjustForContrast(bgColor, 155);
        const shadowColor = frameColor;
        // Display compass frame...
        builder.setSymbology(shadowColor, fillColor, 1);
        const center = geometry_core_1.Point3d.createZero();
        if (this.flags.animateRotation || 0.0 === this._percentChanged) {
            if (CompassMode.Polar === this.compassMode) {
                const ellipse = geometry_core_1.Arc3d.createXYEllipse(center, 1, 1);
                builder.addArc(ellipse, true, true);
                builder.addArc(ellipse, false, false);
            }
            else {
                const pts = [
                    new geometry_core_1.Point3d(-1.0, 1.0, 0.0),
                    new geometry_core_1.Point3d(1.0, 1.0, 0.0),
                    new geometry_core_1.Point3d(1.0, -1.0, 0.0),
                    new geometry_core_1.Point3d(-1.0, -1.0, 0.0)
                ];
                pts[4] = pts[0].clone();
                builder.addShape(pts);
                builder.addLineString(pts);
            }
        }
        else {
            let nSides, radius;
            const minSides = 7, maxSides = 24, factor = 1.0 / 5.0;
            // if currently animating change to polar need to get larger radius...go between 1.0 && 1.0 * sqrt (2.0)
            if (CompassMode.Polar === this.compassMode) {
                nSides = minSides + Math.floor(maxSides * this._percentChanged);
                radius = 1.0 + factor - (factor * this._percentChanged);
            }
            else {
                nSides = (maxSides - Math.floor(maxSides * this._percentChanged)) + minSides;
                radius = 1.0 + (factor * this._percentChanged);
            }
            let angle = 0.0;
            const delta = (Math.PI * 2) / nSides;
            const pts = [];
            for (let iSide = 0; iSide < nSides; iSide++, angle += delta)
                pts[iSide] = new geometry_core_1.Point3d(radius * Math.cos(angle), radius * Math.sin(angle), 0.0);
            pts[nSides] = pts[0].clone();
            builder.addShape(pts);
            builder.addLineString(pts);
        }
        // Display sticky z-lock indicator as frame inset...
        if (this._fieldLocked[ItemField.Z_Item] && this.stickyZLock && vp.view.is3d()) {
            builder.setSymbology(frameColor, fillColor, 1);
            if (CompassMode.Polar === this.compassMode) {
                const ellipse = geometry_core_1.Arc3d.createXYEllipse(center, .5, .5);
                builder.addArc(ellipse, false, false);
            }
            else {
                const pts = [
                    new geometry_core_1.Point3d(-0.5, 0.5, 0.0),
                    new geometry_core_1.Point3d(0.5, 0.5, 0.0),
                    new geometry_core_1.Point3d(0.5, -0.5, 0.0),
                    new geometry_core_1.Point3d(-0.5, -0.5, 0.0)
                ];
                pts[4] = pts[0].clone();
                builder.addLineString(pts);
            }
        }
        // Display compass center mark...
        builder.setSymbology(frameColor, frameColor, 8);
        builder.addPointString([center]);
        // Display positive "X" tick...
        builder.setSymbology(xColor, xColor, 4);
        builder.addLineString([new geometry_core_1.Point3d(1.2, 0.0, 0.0), new geometry_core_1.Point3d(0.8, 0.0, 0.0)]);
        // Display negative "X" tick...
        builder.setSymbology(frameColor, frameColor, 1);
        builder.addLineString([new geometry_core_1.Point3d(-1.2, 0.0, 0.0), new geometry_core_1.Point3d(-0.8, 0.0, 0.0)]);
        // Display positive "Y" tick...
        builder.setSymbology(yColor, yColor, 4);
        builder.addLineString([new geometry_core_1.Point3d(0.0, 1.2, 0.0), new geometry_core_1.Point3d(0.0, 0.8, 0.0)]);
        // Display negative "Y" tick...
        builder.setSymbology(frameColor, frameColor, 1);
        builder.addLineString([new geometry_core_1.Point3d(0.0, -1.2, 0.0), new geometry_core_1.Point3d(0.0, -0.8, 0.0)]);
        context.addDecorationFromBuilder(builder); // add compass as world overlay decorator
    }
    checkRotation() {
        this.updateRotation();
        if (RotationMode.View === this.rotationMode || !this.flags.lockedRotation)
            return;
        const vp = this.currentView;
        if (!vp || vp.isCameraOn)
            return;
        const viewZRoot = vp.rotation.getRow(2);
        if (!this.axes.z.isPerpendicularTo(viewZRoot))
            return;
        const preferY = (Math.abs(this.axes.x.dotProduct(viewZRoot)) < Math.abs(this.axes.y.dotProduct(viewZRoot)));
        // NOTE: Cycle rotation to get one that isn't edge-on...
        switch (this.rotationMode) {
            case RotationMode.Top:
                this.setRotationMode(preferY ? RotationMode.Front : RotationMode.Side);
                break;
            case RotationMode.Front:
                this.setRotationMode(preferY ? RotationMode.Top : RotationMode.Side);
                break;
            case RotationMode.Side:
                this.setRotationMode(preferY ? RotationMode.Top : RotationMode.Front);
                break;
            case RotationMode.ACS:
                switch (this.flags.auxRotationPlane) {
                    case RotationMode.Top:
                        this.flags.auxRotationPlane = preferY ? RotationMode.Front : RotationMode.Side;
                        break;
                    case RotationMode.Front:
                        this.flags.auxRotationPlane = preferY ? RotationMode.Top : RotationMode.Side;
                        break;
                    case RotationMode.Side:
                        this.flags.auxRotationPlane = preferY ? RotationMode.Top : RotationMode.Front;
                        break;
                    default:
                        return;
                }
                break;
            default:
                return;
        }
        this.updateRotation();
        this.flags.baseRotation = this.rotationMode;
    }
    saveLockedCoords() {
        if (CompassMode.Polar === this.compassMode) {
            if (this._fieldLocked[ItemField.DIST_Item])
                this.saveCoordinate(ItemField.DIST_Item, this._distance);
            if (this._fieldLocked[ItemField.ANGLE_Item])
                this.saveCoordinate(ItemField.ANGLE_Item, this._angle);
        }
        else {
            if (this._fieldLocked[ItemField.X_Item])
                this.saveCoordinate(ItemField.X_Item, this.delta.x);
            if (this._fieldLocked[ItemField.Y_Item])
                this.saveCoordinate(ItemField.Y_Item, this.delta.y);
        }
        const vp = this.currentView;
        if (vp && vp.view.is3d()) {
            if (this._fieldLocked[ItemField.Z_Item])
                this.saveCoordinate(ItemField.Z_Item, this.delta.z);
        }
    }
    /** @internal */
    onCompassModeChange() { }
    /** @internal */
    onRotationModeChange() { }
    /** @internal */
    onFieldLockChange(_index) { }
    /** @internal */
    onFieldValueChange(_index) { }
    /** @internal */
    get hasInputFocus() { return true; }
    /** @internal */
    setFocusItem(_index) { }
    static getMinPolarMag(origin) {
        return (1.0e-12 * (1.0 + origin.magnitude()));
    }
    /** projects cursor onto plane in view, or returns an error */
    constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, perpendicular) {
        let fromPtP;
        let dotProduct;
        let distance;
        let projectionVector = new geometry_core_1.Vector3d();
        if (perpendicular) {
            if (AccuDraw.useACSContextRotation(vp, true)) { // Project along ACS axis to AccuDraw plane...
                const rMatrix = vp.getAuxCoordRotation(AccuDraw._tempRot);
                const axes = ThreeAxes.createFromMatrix3d(rMatrix);
                this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);
                Viewport_1.linePlaneIntersect(outPtP, inPtP, axes.z, pointOnPlaneP, normalVectorP, false);
            }
            else {
                projectionVector = inPtP.vectorTo(pointOnPlaneP);
                distance = projectionVector.dotProduct(normalVectorP);
                inPtP.plusScaled(normalVectorP, distance, outPtP);
            }
        }
        else {
            const isCamera = vp.isCameraOn;
            if (vp.view.is3d() && isCamera) {
                const cameraPos = vp.view.getEyePoint();
                fromPtP = cameraPos;
                fromPtP.vectorTo(inPtP, projectionVector).normalizeInPlace();
            }
            else {
                const rMatrix = vp.rotation;
                fromPtP = inPtP;
                rMatrix.getRow(2, projectionVector);
            }
            dotProduct = projectionVector.dotProduct(normalVectorP);
            if (Math.abs(dotProduct) < 0.00001 /* SMALL_DELTA */)
                return bentleyjs_core_1.BentleyStatus.ERROR; // PARALLEL;
            distance = (normalVectorP.dotProduct(pointOnPlaneP) - normalVectorP.dotProduct(fromPtP)) / dotProduct;
            if (isCamera && distance < 0.00001 /* SMALL_DELTA */)
                return bentleyjs_core_1.BentleyStatus.ERROR; // BEHIND_EYE_POINT;
            fromPtP.plusScaled(projectionVector, distance, outPtP);
        }
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    /** @internal */
    softConstructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap) {
        if (!vp.isPointAdjustmentRequired) {
            outPtP.setFrom(inPtP);
            return true;
        }
        if (isSnap) {
            outPtP.setFrom(inPtP);
            const delta = pointOnPlaneP.vectorTo(outPtP);
            return (Math.abs(normalVectorP.dotProduct(delta)) < 0.00001 /* SMALL_DELTA */);
        }
        if (bentleyjs_core_1.BentleyStatus.SUCCESS !== this.constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, false)) {
            const viewNormal = vp.rotation.getRow(2);
            this.constructionPlane(outPtP, inPtP, pointOnPlaneP, viewNormal, vp, false);
            this.constructionPlane(outPtP, outPtP, pointOnPlaneP, normalVectorP, vp, true);
            return false;
        }
        return true;
    }
    /** @internal */
    hardConstructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap) {
        if (!vp.isPointAdjustmentRequired) {
            outPtP.setFrom(inPtP);
            return true;
        }
        if (bentleyjs_core_1.BentleyStatus.SUCCESS !== this.constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap)) {
            const viewNormal = vp.rotation.getRow(2);
            this.constructionPlane(outPtP, inPtP, pointOnPlaneP, viewNormal, vp, false);
            this.constructionPlane(outPtP, outPtP, pointOnPlaneP, normalVectorP, vp, true);
        }
        return true;
    }
    static allowAxisIndexing(pointIsOnPlane) {
        // NOTE: Normally we don't want indexing overriding a hot snap location. The
        //       exception to this is nearest snap. If the nearest snap is in the plane
        //       of the AccuDraw compass, it is confusing not having axis indexing.
        if (!AccuSnap_1.TentativeOrAccuSnap.isHot)
            return true;
        if (!pointIsOnPlane)
            return false;
        const snapDetail = IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
        return (undefined !== snapDetail && (HitDetail_1.SnapMode.Nearest === snapDetail.snapMode));
    }
    applyDistanceRoundOff(distance, vp) {
        if (!this._distanceRoundOff.active || !this._distanceRoundOff.units.size)
            return undefined;
        let roundValue = this._distanceRoundOff.units.values().next().value;
        if (this._distanceRoundOff.units.size > 1) {
            // NOTE: Set isn't ordered, find smallest entry...
            this._distanceRoundOff.units.forEach((thisRoundValue) => {
                if (thisRoundValue < roundValue)
                    roundValue = thisRoundValue;
            });
            if (vp.viewDelta.magnitudeXY() < roundValue)
                return undefined; // Smallest rounding value is larger than view...don't use...
            const smallScreenDist = 0.0787402; // ~2 mm...
            const pixelSize = vp.getPixelSizeAtPoint(this.origin);
            const screenDist = vp.pixelsFromInches(smallScreenDist) * pixelSize;
            this._distanceRoundOff.units.forEach((thisRoundValue) => {
                if (thisRoundValue > roundValue && thisRoundValue < screenDist)
                    roundValue = thisRoundValue;
            });
        }
        if (roundValue <= 0.0)
            return undefined;
        return roundValue * Math.floor((distance / roundValue) + 0.5);
    }
    applyAngleRoundOff(angle, distance, vp) {
        if (!this._angleRoundOff.active || !this._angleRoundOff.units.size)
            return undefined;
        let roundValue = this._angleRoundOff.units.values().next().value;
        if (this._angleRoundOff.units.size > 1) {
            // NOTE: Set isn't ordered, find smallest entry...
            this._angleRoundOff.units.forEach((thisRoundValue) => {
                if (thisRoundValue < roundValue)
                    roundValue = thisRoundValue;
            });
            const circumference = 2.0 * Math.PI * distance;
            const roundDist = circumference / ((2.0 * Math.PI) / roundValue);
            if (vp.viewDelta.magnitudeXY() < roundDist)
                return undefined; // Smallest rounding value is larger than view...don't use...
            const smallScreenDist = 0.0787402; // ~2 mm...
            const pixelSize = vp.getPixelSizeAtPoint(this.origin);
            const screenDist = vp.pixelsFromInches(smallScreenDist) * pixelSize;
            this._angleRoundOff.units.forEach((thisRoundValue) => {
                const thisRoundDist = circumference / ((2.0 * Math.PI) / thisRoundValue);
                if (thisRoundValue > roundValue && thisRoundDist < screenDist)
                    roundValue = thisRoundValue;
            });
        }
        if (roundValue <= 0.0)
            return undefined;
        return roundValue * Math.floor((angle / roundValue) + 0.5);
    }
    /** @internal */
    fixPointPolar(vp) {
        let angleChanged = false;
        let distChanged = false;
        const zLocked = this.isZLocked(vp);
        const xyCorrection = new geometry_core_1.Point3d();
        this.planePt.setFrom(this.origin);
        if (zLocked && !(this.delta.z < 1e-12 /* SMALL_ANGLE */ && this.delta.z > -1e-12 /* SMALL_ANGLE */))
            this.planePt.addScaledInPlace(this.axes.z, this.delta.z);
        if (this.locked & LockedStates.VEC_BM) {
            if (!AccuSnap_1.TentativeOrAccuSnap.isHot) {
                const normVec = new geometry_core_1.Vector3d();
                this.planeByVectorAndView(normVec, this.vector, vp);
                this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, normVec, vp, false);
            }
            else {
                this._rawPointOnPlane.setFrom(this._rawPoint);
                this.flags.pointIsOnPlane = false;
            }
        }
        else {
            if (zLocked) {
                this.hardConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot);
                this.flags.pointIsOnPlane = true;
            }
            else {
                this.flags.pointIsOnPlane = (this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot) || !!(this.locked & LockedStates.XY_BM));
            }
        }
        let delta;
        if (zLocked)
            delta = this.planePt.vectorTo(this._rawPointOnPlane);
        else
            delta = this.origin.vectorTo(this._rawPointOnPlane);
        const minPolarMag = AccuDraw.getMinPolarMag(this.origin);
        let mag;
        if (this.locked & LockedStates.VEC_BM) {
            mag = delta.dotProduct(this.vector);
            xyCorrection.x -= delta.x - mag * this.vector.x;
            xyCorrection.y -= delta.y - mag * this.vector.y;
            xyCorrection.z -= delta.z - mag * this.vector.z;
            this.vector.scale(mag, delta);
            if (mag < 0.0)
                mag = -mag;
            if (mag < minPolarMag) {
                this.handleDegeneratePolarCase();
                return;
            }
            this.flags.pointIsOnPlane = (Math.abs(this.axes.z.dotProduct(delta)) < 0.00001 /* SMALL_DELTA */);
        }
        else {
            mag = delta.magnitude();
            if (mag < minPolarMag) {
                this.handleDegeneratePolarCase();
                return;
            }
        }
        const newPt = this._rawPointOnPlane.plus(xyCorrection);
        xyCorrection.setZero();
        // measure angle
        const rotVec = new geometry_core_1.Point3d();
        rotVec.x = this.axes.x.dotProduct(delta);
        // NOTE: Always return angle relative to compass plane...used to return "angle out of plane" for points off plane.
        rotVec.y = this.axes.y.dotProduct(delta);
        this._angle = Math.atan2(rotVec.y, rotVec.x);
        // constrain angle
        if (this.flags.pointIsOnPlane && !(this.locked & LockedStates.VEC_BM)) {
            if (!AccuSnap_1.TentativeOrAccuSnap.isHot) {
                const newAngle = this.applyAngleRoundOff(this._angle, mag, vp);
                if (undefined !== newAngle) {
                    angleChanged = true;
                    this._angle = newAngle;
                    xyCorrection.x += Math.cos(this._angle) * mag - rotVec.x;
                    xyCorrection.y += Math.sin(this._angle) * mag - rotVec.y;
                    rotVec.x = Math.cos(this._angle) * mag;
                    rotVec.y = Math.sin(this._angle) * mag;
                }
            }
            if (this.locked & LockedStates.X_BM || (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane) && (rotVec.x < this._tolerance && rotVec.x > -this._tolerance) && !this.flags.indexLocked && this.axisIndexing)) {
                this.indexed |= LockedStates.X_BM; // indexed in X
                xyCorrection.x -= rotVec.x;
                rotVec.x = 0.0;
                if (AccuSnap_1.TentativeOrAccuSnap.isHot)
                    xyCorrection.z -= delta.dotProduct(this.axes.z);
                this._angle = (rotVec.y < 0.0) ? -Math.PI / 2.0 : Math.PI / 2.0;
                angleChanged = true;
            }
            if (this.locked & LockedStates.Y_BM || (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane) && (rotVec.y < this._tolerance && rotVec.y > -this._tolerance) && !this.flags.indexLocked && this.axisIndexing)) {
                if (this.indexed & LockedStates.X_BM) { // both indexed
                    this.handleDegeneratePolarCase();
                    return;
                }
                this.indexed |= LockedStates.Y_BM; // indexed in Y
                xyCorrection.y -= rotVec.y;
                if (AccuSnap_1.TentativeOrAccuSnap.isHot)
                    xyCorrection.z -= delta.dotProduct(this.axes.z);
                rotVec.y = 0.0;
                this._angle = (rotVec.x < 0.0) ? Math.PI : 0.0;
                angleChanged = true;
            }
            if (angleChanged) {
                this.axes.x.scale(rotVec.x, delta);
                delta.addScaledInPlace(this.axes.y, rotVec.y);
                mag = delta.magnitude();
                if (mag < minPolarMag) {
                    this.handleDegeneratePolarCase();
                    return;
                }
            }
        }
        // constrain distance
        const oldMag = mag;
        if (this.locked & LockedStates.DIST_BM) { // distance locked
            mag = this._distance;
            distChanged = true;
            this.indexed &= ~LockedStates.DIST_BM;
        }
        else if (!AccuSnap_1.TentativeOrAccuSnap.isHot) { // if non-snap, try rounding and aligning
            const newDist = this.applyDistanceRoundOff(mag, vp);
            if (undefined !== newDist) {
                distChanged = true;
                mag = newDist;
            }
            if (geometry_core_1.Geometry.isDistanceWithinTol(mag - this._lastDistance, this._tolerance) && !this.flags.indexLocked && this.distanceIndexing) {
                this.indexed |= LockedStates.DIST_BM; // distance indexed
                mag = this._lastDistance;
                distChanged = true;
            }
        }
        // project to corrected point
        newPt.plus3Scaled(this.axes.x, xyCorrection.x, this.axes.y, xyCorrection.y, this.axes.z, xyCorrection.z, newPt);
        // display index highlight even if snapped
        if (AccuSnap_1.TentativeOrAccuSnap.isHot && this.flags.pointIsOnPlane) {
            if (Math.abs(rotVec.x) < 1e-12 /* SMALL_ANGLE */)
                this.indexed |= LockedStates.X_BM;
            else if (Math.abs(rotVec.y) < 1e-12 /* SMALL_ANGLE */)
                this.indexed |= LockedStates.Y_BM;
        }
        if (distChanged) {
            if (mag < minPolarMag && mag > -minPolarMag) {
                this.handleDegeneratePolarCase();
                return;
            }
            // adjust corrected point for distance indexing
            newPt.addScaledInPlace(delta, mag / oldMag - 1.0);
            delta.scaleInPlace(mag / oldMag);
        }
        // save corrected point
        this.point.setFrom(newPt);
        // finish up
        this._distance = mag;
        if (!(this.locked & LockedStates.VEC_BM))
            delta.scale(1.0 / mag, this.vector);
        if (this.locked & LockedStates.XY_BM)
            this.indexed |= this.locked;
        if (!zLocked)
            this.delta.z = (this.flags.pointIsOnPlane) ? 0.0 : delta.dotProduct(this.axes.z);
    }
    /** @internal */
    fixPointRectangular(vp) {
        const zLocked = this.isZLocked(vp);
        const xyCorrection = new geometry_core_1.Vector3d();
        this.planePt.setFrom(this.origin);
        this.indexed = 0;
        if (zLocked) {
            this.flags.pointIsOnPlane = (this.delta.z < 1e-12 /* SMALL_ANGLE */ && this.delta.z > -1e-12 /* SMALL_ANGLE */);
            if (!this.flags.pointIsOnPlane)
                this.planePt.addScaledInPlace(this.axes.z, this.delta.z);
            this.hardConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot);
        }
        else {
            this.flags.pointIsOnPlane = this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.origin, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot);
        }
        const trueDelta = this.origin.vectorTo(this._rawPointOnPlane);
        this._rawDelta.x = trueDelta.dotProduct(this.axes.x);
        this._xIsNegative = (this._rawDelta.x < -1e-12 /* SMALL_ANGLE */);
        this._rawDelta.y = trueDelta.dotProduct(this.axes.y);
        this._yIsNegative = (this._rawDelta.y < -1e-12 /* SMALL_ANGLE */);
        if (!zLocked)
            this.delta.z = (this.flags.pointIsOnPlane) ? 0.0 : trueDelta.dotProduct(this.axes.z);
        if (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane)) {
            if (!(this.locked & LockedStates.X_BM)) { // not locked in x
                const roundedDeltaX = this.applyDistanceRoundOff(this._rawDelta.x, vp); // round x
                if (undefined !== roundedDeltaX) {
                    xyCorrection.x = roundedDeltaX - this._rawDelta.x;
                    this._rawDelta.x = roundedDeltaX;
                }
                if (this._rawDelta.x < this._tolerance && this._rawDelta.x > -this._tolerance &&
                    !this.flags.indexLocked && this.axisIndexing) { // index x
                    this.indexed |= LockedStates.X_BM; // indexed in X
                    xyCorrection.x -= this._rawDelta.x;
                    this._rawDelta.x = 0.0;
                }
            }
            if (!(this.locked & LockedStates.Y_BM)) {
                const roundedDeltaY = this.applyDistanceRoundOff(this._rawDelta.y, vp); // round y
                if (undefined !== roundedDeltaY) {
                    xyCorrection.y = roundedDeltaY - this._rawDelta.y;
                    this._rawDelta.y = roundedDeltaY;
                }
                if (this._rawDelta.y < this._tolerance && this._rawDelta.y > -this._tolerance &&
                    !this.flags.indexLocked && this.axisIndexing) { // index y
                    this.indexed |= LockedStates.Y_BM; // indexed in Y
                    xyCorrection.y -= this._rawDelta.y;
                    this._rawDelta.y = 0.0;
                }
            }
        }
        if (this.locked & LockedStates.X_BM) {
            if (this.rawDeltaIsValid(this._rawDelta.x)) {
                // cursor changed sides, reverse value
                if ((this.delta.x < -1e-12 /* SMALL_ANGLE */) !== this._xIsNegative &&
                    this.smartKeyin && this._keyinStatus[ItemField.X_Item] === KeyinStatus.Partial &&
                    !this._xIsExplicit)
                    this.delta.x = -this.delta.x;
            }
            xyCorrection.x = this.delta.x - this._rawDelta.x;
        }
        else {
            const lastDist = (this._rawDelta.x < 0.0) ? (-this._lastDistance) : this._lastDistance;
            if (!AccuSnap_1.TentativeOrAccuSnap.isHot && ((this.locked & LockedStates.Y_BM) || (this.indexed & LockedStates.Y_BM)) && !(this.indexed & LockedStates.X_BM) &&
                geometry_core_1.Geometry.isDistanceWithinTol(this._rawDelta.x - lastDist, this._tolerance) &&
                !this.flags.indexLocked && this.distanceIndexing) {
                xyCorrection.x += lastDist - this._rawDelta.x;
                this.delta.x = lastDist;
                this.indexed |= LockedStates.DIST_BM;
            }
            else {
                this.delta.x = this._rawDelta.x;
            }
        }
        if (this.locked & LockedStates.Y_BM) {
            if (this.rawDeltaIsValid(this._rawDelta.y)) {
                // cursor changed sides, reverse value
                if ((this.delta.y < -1e-12 /* SMALL_ANGLE */) !== this._yIsNegative &&
                    this.smartKeyin && this._keyinStatus[ItemField.Y_Item] === KeyinStatus.Partial &&
                    !this._yIsExplicit)
                    this.delta.y = -this.delta.y;
            }
            xyCorrection.y = this.delta.y - this._rawDelta.y;
        }
        else {
            const lastDist = (this._rawDelta.y < 1e-12 /* SMALL_ANGLE */) ? -this._lastDistance : this._lastDistance;
            if (!AccuSnap_1.TentativeOrAccuSnap.isHot && ((this.locked & LockedStates.X_BM) || (this.indexed & LockedStates.X_BM)) && !(this.indexed & LockedStates.Y_BM) &&
                geometry_core_1.Geometry.isDistanceWithinTol(this._rawDelta.y - lastDist, this._tolerance) &&
                !this.flags.indexLocked && this.distanceIndexing) {
                xyCorrection.y += lastDist - this._rawDelta.y;
                this.delta.y = lastDist;
                this.indexed |= LockedStates.DIST_BM;
            }
            else {
                this.delta.y = this._rawDelta.y;
            }
        }
        this._rawPointOnPlane.plus2Scaled(this.axes.x, xyCorrection.x, this.axes.y, xyCorrection.y, this.point);
        if (zLocked && !this.flags.pointIsOnPlane)
            this.hardConstructionPlane(this.point, this.point, this.planePt, this.axes.z, vp, AccuSnap_1.TentativeOrAccuSnap.isHot);
        if ((this.locked & LockedStates.X_BM && this.delta.x === 0.0) || (this.locked & LockedStates.Y_BM && this.delta.y === 0.0)) {
            this.indexed |= this.locked; // to display index highlight
        }
        else if (AccuSnap_1.TentativeOrAccuSnap.isHot) {
            if (Math.abs(this.delta.x) < 1e-12 /* SMALL_ANGLE */)
                this.indexed |= LockedStates.X_BM;
            else if (Math.abs(this.delta.y) < 1e-12 /* SMALL_ANGLE */)
                this.indexed |= LockedStates.Y_BM;
        }
        const lock = this.locked & LockedStates.XY_BM;
        const index = this.indexed & LockedStates.XY_BM;
        if (lock === LockedStates.Y_BM && index !== LockedStates.X_BM) {
            if (this._keyinStatus[ItemField.Y_Item] !== KeyinStatus.Dynamic) {
                if (Math.abs(this._rawDelta.x) < this._threshold)
                    return;
            }
            this.newFocus = ItemField.X_Item;
            this.dontMoveFocus = false;
        }
        else if (lock === LockedStates.X_BM && index !== LockedStates.Y_BM) {
            if (this._keyinStatus[ItemField.X_Item] !== KeyinStatus.Dynamic) {
                if (Math.abs(this._rawDelta.y) < this._threshold)
                    return;
            }
            this.newFocus = ItemField.Y_Item;
            this.dontMoveFocus = false;
        }
        else {
            this.newFocus = ((Math.abs(this._rawDelta.x) > Math.abs(this._rawDelta.y)) ? ItemField.X_Item : ItemField.Y_Item);
        }
    }
    fixPoint(pointActive, vp) {
        if (this.isActive && ((vp !== this.currentView) || this.flags.rotationNeedsUpdate)) {
            this.currentView = vp;
            if (!(this.locked & LockedStates.ANGLE_BM || this._fieldLocked[ItemField.Z_Item])) {
                // origin not locked down...may change when vie changes...
                if (!this.flags.haveValidOrigin)
                    this.setDefaultOrigin(vp);
                // in a view based rotation, and the view has changed, so update the rotation...
                if (!this.flags.lockedRotation) {
                    this.updateRotation();
                    this.flags.rotationNeedsUpdate = false;
                }
            }
        }
        if (this.isInactive || this.isDeactivated) {
            this.point.setFrom(pointActive);
            this.currentView = vp;
            this.processHints();
            return;
        }
        if (this.isActive) {
            this._rawPoint.setFrom(pointActive);
            this.currentView = vp;
            this.flags.dialogNeedsUpdate = true;
            if (AccuSnap_1.TentativeOrAccuSnap.isHot && CompassMode.Polar === this.compassMode)
                this.indexed = this.locked;
            else
                this.indexed = LockedStates.NONE_LOCKED;
            if (CompassMode.Polar === this.compassMode)
                this.fixPointPolar(vp);
            else
                this.fixPointRectangular(vp);
            pointActive.setFrom(this.point);
        }
        else if (CompassMode.Rectangular === this.compassMode) {
            if (this._fieldLocked[ItemField.X_Item])
                pointActive.x = this.delta.x;
            if (this._fieldLocked[ItemField.Y_Item])
                pointActive.y = this.delta.y;
            if (this._fieldLocked[ItemField.Z_Item])
                pointActive.z = this.delta.z;
        }
    }
    /** @internal */
    refreshDecorationsAndDynamics() {
        // Immediately process hints and show dynamics using adjusted point when not called from button down...
        if (!this.flags.inDataPoint)
            this.processHints();
        // Make sure AccuDraw updates its decorations...
        if (undefined !== this.currentView)
            this.currentView.invalidateDecorations();
        // Make sure active tool updates its dynamics. NOTE: Need point adjusted for new locks, etc.
        IModelApp_1.IModelApp.toolAdmin.updateDynamics(undefined, undefined, true);
    }
    /** @internal */
    upgradeToActiveState() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        if (!this.isInactive)
            return false;
        const vp = this.currentView;
        if (!vp)
            return false;
        // NOTE: If ACS Plane lock setup initial and base rotation to ACS...
        if (vp && AccuDraw.useACSContextRotation(vp, false)) {
            this.setRotationMode(RotationMode.ACS);
            this.flags.baseRotation = RotationMode.ACS;
            this.flags.auxRotationPlane = RotationMode.Top;
        }
        if (this.published.flags & AccuDrawFlags.SmartRotation) {
            const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
            if (undefined !== snap) {
                const rotation = AccuDraw.getSnapRotation(snap, vp);
                if (undefined !== rotation) {
                    this.setContextRotation(rotation, true, false);
                    this.changeBaseRotationMode(RotationMode.Context);
                }
            }
        }
        this.checkRotation();
        // Compass will jump to correct location when fixPoint is called...but we don't want to see the jump...
        if (!this.flags.haveValidOrigin)
            this.setDefaultOrigin(vp);
        // Initialize rawPoint data...invalid for alignments until next fixPoint...
        this._rawPoint.setFrom(this.point);
        this._rawPointOnPlane.setFrom(this.point);
        // Upgrade state to enabled...want compass to display...
        this.currentState = CurrentState.Active;
        return false;
    }
    /** @internal */
    downgradeInactiveState() {
        if (!this.isEnabled)
            return false;
        this.onEventCommon();
        if (!this.isActive)
            return false;
        // Downgrade state back to inactive...
        this.currentState = CurrentState.Inactive;
        return false;
    }
    /** @internal */
    onBeginDynamics() { return this.upgradeToActiveState(); }
    /** @internal */
    onEndDynamics() { return this.downgradeInactiveState(); }
    /** Implemented by sub-classes to update ui fields to show current deltas or coordinates when inactive.
     * Should also choose active x or y input field in rectangular mode based on cursor position when
     * axis isn't locked to support "smart lock".
     * @internal
     */
    onMotion(_ev) { }
    /** @internal */
    onPreButtonEvent(ev) {
        if (Tool_1.BeButton.Reset === ev.button && !ev.isDown && !ev.isDragging) {
            if (IModelApp_1.IModelApp.tentativePoint.isActive && this.isActive) {
                IModelApp_1.IModelApp.tentativePoint.clear(true);
                this.refreshDecorationsAndDynamics();
                return true;
            }
            if (this.isEnabled)
                this.onEventCommon();
            return false;
        }
        if (Tool_1.BeButton.Data !== ev.button || !ev.isDown || !this.isEnabled)
            return false;
        this.onEventCommon();
        this.flags.inDataPoint = true;
        if (this.currentState < CurrentState.Inactive)
            return false;
        if (!this.currentView)
            this.currentView = ev.viewport;
        this.updateRotation();
        return false;
    }
    /** @internal */
    onPostButtonEvent(ev) {
        if (Tool_1.BeButton.Data !== ev.button || !ev.isDown || !this.isEnabled)
            return false;
        this.onEventCommon();
        if (this.flags.ignoreDataButton) {
            // NOTE: Ignore this data point, was used to terminate a viewing command or input collector...
            this.flags.ignoreDataButton = false;
        }
        else if (!this.flags.fixedOrg && this.currentState >= CurrentState.Inactive) {
            /* set origin to last point placed unless its being set elsewhere */
            if (((!this.contextSensitive &&
                !(this.published.flags & (AccuDrawFlags.AlwaysSetOrigin ^ AccuDrawFlags.SetOrigin))) ||
                !(this.published.flags & AccuDrawFlags.SetOrigin))) {
                this.published.flags |= AccuDrawFlags.SetOrigin;
                if (this.currentState >= CurrentState.Inactive)
                    this.published.origin.setFrom(ev.point);
                else
                    this.published.origin.setFrom(this.point);
            }
            this.saveLockedCoords();
            this.processHints();
            if (this.currentState >= CurrentState.Inactive)
                this.updateRotation();
        }
        this.flags.inDataPoint = false;
        this.flags.indexLocked = false;
        return false;
    }
    /** @internal */
    onTentative() {
        if (this.isActive || this.isInactive)
            this.grabInputFocus(); // AccuDraw gets input focus on a tentative
        return false;
    }
    intersectXYCurve(snap, curve, usePointOnSnap) {
        if (undefined === this.currentView)
            return;
        const curveSegment = snap.getCurvePrimitive(); // Get single segment of linestring/shape...
        if (undefined === curveSegment)
            return;
        const worldToView = this.currentView.worldToViewMap.transform0;
        const detail = geometry_core_1.CurveCurve.intersectionProjectedXY(worldToView, usePointOnSnap ? curveSegment : curve, true, usePointOnSnap ? curve : curveSegment, true);
        if (0 === detail.dataA.length)
            return;
        let closeIndex = 0;
        if (detail.dataA.length > 1) {
            const snapPt = worldToView.multiplyPoint3d(snap.getPoint(), 1);
            let lastDist;
            for (let i = 0; i < detail.dataA.length; i++) {
                const testPt = worldToView.multiplyPoint3d(detail.dataA[i].point, 1);
                const testDist = snapPt.realDistanceXY(testPt);
                if (undefined !== testDist && (undefined === lastDist || testDist < lastDist)) {
                    lastDist = testDist;
                    closeIndex = i;
                }
            }
        }
        snap.setSnapPoint(detail.dataA[closeIndex].point, HitDetail_1.SnapHeat.NotInRange);
    }
    intersectLine(snap, linePt, unitVec) {
        const vec = geometry_core_1.Vector3d.createStartEnd(linePt, snap.getPoint());
        const endPt = linePt.plusScaled(unitVec, vec.dotProduct(unitVec));
        const cpLine = geometry_core_1.LineSegment3d.create(linePt, endPt);
        this.intersectXYCurve(snap, cpLine, true); // Get point on snapped curve, not AccuDraw axis. Snap point isn't required to be in AccuDraw plane when Z isn't locked.
    }
    intersectCircle(snap, center, normal, radius) {
        const matrix = geometry_core_1.Matrix3d.createRigidHeadsUp(normal);
        const vector0 = matrix.columnX();
        const vector90 = matrix.columnY();
        vector0.scaleToLength(radius, vector0);
        vector90.scaleToLength(radius, vector90);
        const cpArc = geometry_core_1.Arc3d.create(center, vector0, vector90);
        this.intersectXYCurve(snap, cpArc, false); // Get point on AccuDraw distance circle, not snapped curve. Want to preserve distance constraint with apparent intersection in XY.
    }
    /** @internal */
    onSnap(snap) {
        // If accudraw is locked, adjust near snap point to be the nearest point on this element, CONSTRAINED by the accudraw lock.
        if (!this.isActive || !this.locked)
            return false;
        if (HitDetail_1.SnapMode.Nearest !== snap.snapMode)
            return false;
        if (!snap.primitive)
            return false;
        switch (this.locked) {
            case LockedStates.VEC_BM: {
                this.intersectLine(snap, this.origin, this.vector);
                break;
            }
            case LockedStates.X_BM: {
                const refPt = (CompassMode.Rectangular === this.compassMode) ? this.planePt.plusScaled(this.axes.x, this.delta.x) : this.origin;
                this.intersectLine(snap, refPt, this.axes.y);
                break;
            }
            case LockedStates.Y_BM: {
                const refPt = (CompassMode.Rectangular === this.compassMode) ? this.planePt.plusScaled(this.axes.y, this.delta.y) : this.origin;
                this.intersectLine(snap, refPt, this.axes.x);
                break;
            }
            case LockedStates.DIST_BM: {
                this.intersectCircle(snap, this.origin, this.axes.z, this._distance);
                break;
            }
        }
        return false;
    }
    /** @internal */
    onSelectedViewportChanged(previous, current) {
        // In case previous is closing, always update AccuDraw to current view...
        if (undefined !== this.currentView && this.currentView === previous)
            this.currentView = current;
        // Reset AccuDraw when iModel or view type changes...
        if (undefined !== current && undefined !== previous &&
            (current.view.classFullName === previous.view.classFullName) &&
            (current.view.iModel === previous.view.iModel))
            return;
        this.currentView = undefined;
        this.flags.redrawCompass = false;
        this.flags.baseRotation = RotationMode.View;
        this.flags.auxRotationPlane = RotationMode.Top;
        this.flags.rotationNeedsUpdate = true;
        this.flags.haveValidOrigin = false;
        this.flags.indexLocked = false;
        this.flags.bearingFixToPlane2D = false;
        this.setRotationMode(RotationMode.View);
        this.updateRotation();
        this.saveState(this.savedStateViewTool);
        this.saveState(this.savedStateInputCollector);
    }
    doProcessHints() {
        if (!this.floatingOrigin) {
            if (this.published.flags & AccuDrawFlags.SetOrigin)
                this.unlockAllFields();
            return;
        }
        // Set Context Origin
        if (this.published.flags & AccuDrawFlags.SetOrigin) {
            if (this.floatingOrigin) {
                this.origin.setFrom(this.published.origin);
                this.point.setFrom(this.origin);
                this.planePt.setFrom(this.origin);
            }
            this.flags.haveValidOrigin = true;
            this.setLastPoint(this.origin);
            this.unlockAllFields();
            this.updateRotation();
        }
        if (!this.contextSensitive)
            return;
        // Mode -- Polar or Rectangular
        if (this.published.flags & (AccuDrawFlags.SetModePolar | AccuDrawFlags.SetModeRect)) {
            if (this.compassMode !== ((this.published.flags & AccuDrawFlags.SetModePolar) ? CompassMode.Polar : CompassMode.Rectangular))
                this.changeCompassMode();
        }
        // Fixed Origin
        if (this.published.flags & AccuDrawFlags.FixedOrigin)
            this.flags.fixedOrg = true;
        // Save Distance
        if (this.published.flags & (AccuDrawFlags.SetDistance | AccuDrawFlags.LockDistance))
            this.saveCoordinate(ItemField.DIST_Item, this.published.distance);
        const vp = this.currentView;
        // Do Context Rotation
        if (this.published.flags & AccuDrawFlags.SetRMatrix) {
            this.axes.fromMatrix3d(this.published.rMatrix);
            this.flags.lockedRotation = true;
            this.flags.contextRotMode = ContextMode.Locked;
            this.setRotationMode(RotationMode.Context);
            this.updateRotation();
        }
        else if (this.published.flags & AccuDrawFlags.SetXAxis) {
            this.axes.x.setFrom(this.published.vector);
            this.flags.contextRotMode = ContextMode.XAxis;
            this.setRotationMode(RotationMode.Context);
            this.updateRotation();
        }
        else if (this.published.flags & AccuDrawFlags.SetXAxis2) {
            this.axes.x.setFrom(this.published.vector);
            this.flags.contextRotMode = ContextMode.XAxis2;
            this.setRotationMode(RotationMode.Context);
            this.updateRotation();
        }
        else if (this.published.flags & AccuDrawFlags.SetNormal) {
            if (vp && vp.view.is3d()) {
                this.axes.z.setFrom(this.published.vector);
                this.flags.contextRotMode = ContextMode.ZAxis;
                this.setRotationMode(RotationMode.Context);
                this.updateRotation();
            }
        }
        else if (this.published.flags & AccuDrawFlags.OrientACS) {
            this.flags.lockedRotation = true;
            this.flags.baseRotation = RotationMode.ACS;
            this.setRotationMode(RotationMode.ACS);
            this.updateRotation();
        }
        else if (this.isInactive || (this.published.flags & AccuDrawFlags.OrientDefault)) {
            this.setRotationMode(this.flags.baseRotation);
            this.updateRotation();
        }
        // Lock Items
        switch (this.compassMode) {
            case CompassMode.Polar:
                if (this.published.flags & AccuDrawFlags.LockDistance) {
                    this._distance = this.published.distance;
                    this.distanceLock(true, true);
                }
                if (this.published.flags & AccuDrawFlags.LockAngle) {
                    this.updateVector(this.published.angle);
                    this.indexed = LockedStates.NONE_LOCKED;
                    this.angleLock();
                    this.saveCoordinate(ItemField.ANGLE_Item, this.published.angle);
                }
                break;
            case CompassMode.Rectangular:
                if ((this.published.flags & AccuDrawFlags.Lock_X)) {
                    this.locked |= LockedStates.X_BM;
                    this.delta.x = this.published.delta.x;
                    this.setFieldLock(ItemField.X_Item, true);
                    this.saveCoordinate(ItemField.X_Item, this.published.delta.x);
                }
                if ((this.published.flags & AccuDrawFlags.Lock_Y)) {
                    this.locked |= LockedStates.Y_BM;
                    this.delta.y = this.published.delta.y;
                    this.setFieldLock(ItemField.Y_Item, true);
                    this.saveCoordinate(ItemField.Y_Item, this.published.delta.y);
                }
                if ((this.published.flags & AccuDrawFlags.Lock_Z)) {
                    if (vp && vp.view.is3d()) {
                        this.delta.z = this.published.delta.z;
                        this.setFieldLock(ItemField.Z_Item, true);
                        this.saveCoordinate(ItemField.Z_Item, this.published.delta.z);
                    }
                }
                break;
        }
    }
    /** @internal */
    processHints() {
        if (!this.published.flags || !this.isEnabled)
            return;
        if (this.published.flags & AccuDrawFlags.Disable) {
            this.published.flags = 0;
            this.currentState = CurrentState.Deactivated;
            return;
        }
        const setFocus = !!(this.published.flags & AccuDrawFlags.SetFocus);
        const smartRotation = !!(this.published.flags & AccuDrawFlags.SmartRotation);
        this.doProcessHints();
        this.published.zero();
        if (smartRotation && this.isInactive) // Preserve smart rotation hint until when/if AccuDraw is enabled for the current tool...
            this.published.flags = AccuDrawFlags.SmartRotation;
        if (this.isEnabled || setFocus)
            this.grabInputFocus();
    }
}
AccuDraw._tempRot = new geometry_core_1.Matrix3d();
exports.AccuDraw = AccuDraw;
/** AccuDrawHintBuilder is a Tool helper class that facilitates AccuDraw interaction.
 * Accudraw is an aide for entering coordinate data.
 * The tool does not directly change the current AccuDraw state; the tool's job is merely
 * to supply "hints" to AccuDraw regarding its preferred AccuDraw configuration for the
 * current tool state. User settings such as "Context Sensitivity" and "Floating Origin"
 * affect how/which hints get applied.
 * @see [Using AccuDraw]($docs/learning/frontend/primitivetools.md#AccuDraw)*
 * @beta
 */
class AccuDrawHintBuilder {
    constructor() {
        this._flagOrigin = false;
        this._flagNormal = false;
        this._flagRotation = false;
        this._flagXAxis = false;
        this._flagXAxis2 = false;
        this._flagDistance = false;
        this._flagAngle = false;
        this._flagModePolar = false;
        this._flagModeRectangular = false;
        this._distance = 0;
        this._angle = 0;
        this.setOriginFixed = false;
        this.setOriginAlways = false;
        this.setLockDistance = false;
        this.setLockAngle = false;
        this.setLockX = false;
        this.setLockY = false;
        this.setLockZ = false;
        this.enableSmartRotation = false;
    }
    setOrigin(origin) { this._origin = origin.clone(); this._flagOrigin = true; }
    setRotation(rMatrix) { this._rMatrix = rMatrix.clone(); this._flagRotation = true; this._flagXAxis = this._flagNormal = false; }
    setXAxis(xAxis) { this._axis = xAxis.clone(); this._flagXAxis = true; this._flagRotation = this._flagNormal = this._flagXAxis2 = false; }
    setXAxis2(xAxis) { this._axis = xAxis.clone(); this._flagXAxis2 = true; this._flagRotation = this._flagNormal = this._flagXAxis = false; }
    setNormal(normal) { this._axis = normal.clone(); this._flagNormal = true; this._flagRotation = this._flagXAxis = this._flagXAxis2 = false; }
    setModePolar() { this._flagModePolar = true; this._flagModeRectangular = false; }
    setModeRectangular() { this._flagModeRectangular = true; this._flagModePolar = false; }
    setDistance(distance) { this._distance = distance; this._flagDistance = true; }
    setAngle(angle) { this._angle = angle; this._flagAngle = true; }
    /* Enable AccuDraw for the current tool without sending any hints */
    static activate() { IModelApp_1.IModelApp.accuDraw.activate; }
    /* Disable AccuDraw for the current tool */
    static deactivate() { IModelApp_1.IModelApp.accuDraw.deactivate; }
    /**
     * Calls AccuDraw.setContext using the current builder state.
     * @return true if hints were successfully sent.
     */
    sendHints(activate = true) {
        let flags = 0;
        if (this._flagOrigin)
            flags |= AccuDrawFlags.SetOrigin;
        if (this.setOriginFixed)
            flags |= AccuDrawFlags.FixedOrigin;
        if (this.setOriginAlways)
            flags |= AccuDrawFlags.AlwaysSetOrigin;
        if (this._flagRotation)
            flags |= AccuDrawFlags.SetRMatrix;
        if (this._flagXAxis)
            flags |= AccuDrawFlags.SetXAxis;
        if (this._flagXAxis2)
            flags |= AccuDrawFlags.SetXAxis2;
        if (this._flagNormal)
            flags |= AccuDrawFlags.SetNormal;
        if (this._flagModePolar)
            flags |= AccuDrawFlags.SetModePolar;
        if (this._flagModeRectangular)
            flags |= AccuDrawFlags.SetModeRect;
        if (this.setLockDistance)
            flags |= AccuDrawFlags.LockDistance;
        if (this.setLockAngle)
            flags |= AccuDrawFlags.LockAngle;
        if (this.setLockX)
            flags |= AccuDrawFlags.Lock_X;
        if (this.setLockY)
            flags |= AccuDrawFlags.Lock_Y;
        if (this.setLockZ)
            flags |= AccuDrawFlags.Lock_Z;
        if (this.enableSmartRotation)
            flags |= AccuDrawFlags.SmartRotation;
        const accuDraw = IModelApp_1.IModelApp.accuDraw;
        if (bentleyjs_core_1.BentleyStatus.SUCCESS !== accuDraw.setContext(flags, this._origin, this._flagRotation ? this._rMatrix : this._axis, undefined, this._flagDistance ? this._distance : undefined, this._flagAngle ? this._angle : undefined))
            return false; // Not enabled for this session...
        if (activate)
            accuDraw.activate(); // If not already enabled (ex. dynamics not started) most/all callers would want to enable it now (optional activate arg provided just in case)...
        return true;
    }
}
exports.AccuDrawHintBuilder = AccuDrawHintBuilder;


/***/ }),

/***/ "./lib/AccuSnap.js":
/*!*************************!*\
  !*** ./lib/AccuSnap.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module LocatingElements */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const Tool_1 = __webpack_require__(/*! ./tools/Tool */ "./lib/tools/Tool.js");
const ElementLocateManager_1 = __webpack_require__(/*! ./ElementLocateManager */ "./lib/ElementLocateManager.js");
const Sprites_1 = __webpack_require__(/*! ./Sprites */ "./lib/Sprites.js");
const HitDetail_1 = __webpack_require__(/*! ./HitDetail */ "./lib/HitDetail.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** Virtual cursor for using AccuSnap with touch input.
 * @internal
 */
class TouchCursor {
    constructor(vp) {
        this.position = new geometry_core_1.Point3d();
        this._offsetPosition = new geometry_core_1.Point3d();
        this._isSelected = false;
        this._isDragging = false;
        this._inTouchTap = false;
        this._size = vp.pixelsFromInches(0.3);
        this._yOffset = this._size * 1.75;
    }
    setPosition(vp, worldLocation) {
        const pt4 = vp.worldToView4d(worldLocation);
        if (pt4.w > 1.0 || pt4.w < 0) // outside of frustum.
            return false;
        const viewLocation = pt4.realPoint();
        if (undefined === viewLocation || !vp.viewRect.containsPoint(viewLocation))
            return false; // outside this viewport rect
        viewLocation.x = Math.floor(viewLocation.x) + 0.5;
        viewLocation.y = Math.floor(viewLocation.y) + 0.5;
        viewLocation.z = 0.0;
        const offsetLocation = new geometry_core_1.Point3d(viewLocation.x, viewLocation.y - this._yOffset, viewLocation.z);
        if (!vp.viewRect.containsPoint(offsetLocation))
            return false; // outside this viewport rect
        this.position.setFrom(viewLocation);
        this._offsetPosition.setFrom(offsetLocation);
        vp.invalidateDecorations();
        return true;
    }
    drawHandle(ctx, filled) {
        ctx.beginPath();
        ctx.moveTo(-this._size, 0);
        ctx.bezierCurveTo(-this._size, -this._size * 0.85, -this._size * 0.6, -this._yOffset * 0.6, 0, -this._yOffset * 0.8);
        ctx.bezierCurveTo(this._size * 0.6, -this._yOffset * 0.6, this._size, -this._size * 0.85, this._size, 0);
        ctx.arc(0, 0, this._size, 0, Math.PI);
        if (filled)
            ctx.fill();
        ctx.stroke();
        ctx.beginPath();
        ctx.arc(0, 0, this._size * 0.75, 0, 2 * Math.PI);
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(-this._size * 0.4, 0);
        ctx.lineTo(this._size * 0.4, 0);
        ctx.moveTo(-this._size * 0.4, this._size * 0.25);
        ctx.lineTo(this._size * 0.4, this._size * 0.25);
        ctx.stroke();
    }
    drawDecoration(ctx) {
        ctx.lineWidth = 1;
        ctx.strokeStyle = "rgba(0,0,0,.75)";
        ctx.fillStyle = "white";
        ctx.strokeRect(-2, -(this._yOffset + 2), 5, 5);
        ctx.fillRect(-1, -(this._yOffset + 1), 3, 3);
        ctx.lineWidth = 3.5;
        ctx.lineCap = "round";
        ctx.fillStyle = this._isSelected ? "rgba(35,187,252,.25)" : "rgba(255,215,0,.25)";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 10;
        this.drawHandle(ctx, true);
        ctx.lineWidth = 1.5;
        ctx.strokeStyle = this._isSelected ? "rgba(35,187,252,.75)" : "rgba(255,215,0,.75)";
        ctx.shadowBlur = 0;
        this.drawHandle(ctx, false);
    }
    isSelected(pt) { return this.position.distance(geometry_core_1.Point3d.create(pt.x, pt.y)) < this._size; }
    isButtonHandled(ev) { return (Tool_1.BeButton.Data === ev.button && Tool_1.InputSource.Touch === ev.inputSource && !this._inTouchTap); }
    doTouchMove(ev) {
        if (undefined === ev.viewport || !ev.isSingleTouch)
            return false;
        if (!this._isDragging || !this.setPosition(ev.viewport, ev.point))
            return false;
        ev.viewPoint = this._offsetPosition;
        IModelApp_1.IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // tslint:disable-line:no-floating-promises
        return true;
    }
    doTouchMoveStart(ev, startEv) {
        if (undefined === ev.viewport || !ev.isSingleTouch)
            return false;
        return (this._isDragging = this.isSelected(startEv.viewPoint));
    }
    doTouchStart(ev) {
        this._isSelected = ev.isSingleTouch && this.isSelected(ev.viewPoint);
        if (undefined !== ev.viewport)
            ev.viewport.invalidateDecorations();
    }
    doTouchEnd(ev) {
        this._isSelected = this._isDragging = false;
        if (undefined !== ev.viewport)
            ev.viewport.invalidateDecorations();
    }
    async doTouchTap(ev) {
        if (undefined === ev.viewport || !ev.isSingleTouch || 1 !== ev.tapCount)
            return false;
        if (!this.isSelected(ev.viewPoint)) {
            if (!this.setPosition(ev.viewport, ev.point))
                return false;
            ev.viewPoint = this._offsetPosition;
            IModelApp_1.IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // tslint:disable-line:no-floating-promises
            return false;
        }
        ev.viewPoint = this._offsetPosition;
        this._inTouchTap = true;
        await IModelApp_1.IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev);
        this._inTouchTap = false;
        return true;
    }
    static createFromTouchTap(ev) {
        if (undefined === ev.viewport || !ev.isSingleTouch || 1 !== ev.tapCount)
            return undefined;
        const touchCursor = new TouchCursor(ev.viewport);
        if (!touchCursor.setPosition(ev.viewport, ev.point) && !touchCursor.setPosition(ev.viewport, ev.viewport.view.getCenter()))
            return undefined;
        ev.viewPoint = touchCursor._offsetPosition;
        IModelApp_1.IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // tslint:disable-line:no-floating-promises
        return touchCursor;
    }
}
exports.TouchCursor = TouchCursor;
/** AccuSnap is an aide for snapping to interesting points on elements or decorations as the cursor moves over them.
 * @see [Using AccuSnap]($docs/learning/frontend/primitivetools.md#AccuSnap)
 * @public
 */
class AccuSnap {
    constructor() {
        /** Views that need to be flashed */
        this.needFlash = new Set();
        /** Views that are already flashed */
        this.areFlashed = new Set();
        /** The "+" that indicates where the snap point is */
        this.cross = new Sprites_1.SpriteLocation();
        /** The icon that indicates what type of snap is active */
        this.icon = new Sprites_1.SpriteLocation();
        /** The icon that indicates an error */
        this.errorIcon = new Sprites_1.SpriteLocation();
        /** Number of times "suppress" has been called -- unlike suspend this is not automatically cleared by tools */
        this._suppressed = 0;
        /** Time motion stopped. */
        this._motionStopTime = 0;
        /** Location of cursor when we last checked for motion */
        this._lastCursorPos = new geometry_core_1.Point2d();
        /** @internal */
        this.toolState = new AccuSnap.ToolState();
        /** @internal */
        this._settings = new AccuSnap.Settings();
    }
    /** @internal */
    onInitialized() { }
    get _searchDistance() { return this.isLocateEnabled ? 1.0 : this._settings.searchDistance; }
    get _hotDistanceInches() { return IModelApp_1.IModelApp.locateManager.apertureInches * this._settings.hotDistanceFactor; }
    /** Whether locate of elements under the cursor is enabled by the current InteractiveTool.
     * @public
     */
    get isLocateEnabled() { return this.toolState.locate; }
    /** Whether snapping to elements under the cursor is enabled by the current InteractiveTool.
     * @public
     */
    get isSnapEnabled() { return this.toolState.enabled; }
    /** Whether the user setting for snapping is enabled. Snapping is done only when both the user and current InteractiveTool have enabled it.
     * @public
     */
    get isSnapEnabledByUser() { return this._settings.enableFlag; }
    isFlashed(view) { return (this.areFlashed.has(view)); }
    needsFlash(view) { return (this.needFlash.has(view)); }
    setNeedsFlash(view) { this.needFlash.add(view); this.clearIsFlashed(view); view.invalidateDecorations(); }
    setIsFlashed(view) { this.areFlashed.add(view); }
    clearIsFlashed(view) { this.areFlashed.delete(view); }
    static toSnapDetail(hit) { return (hit && hit instanceof HitDetail_1.SnapDetail) ? hit : undefined; }
    /** @internal */
    getCurrSnapDetail() { return AccuSnap.toSnapDetail(this.currHit); }
    /** Determine whether there is a current hit that is *hot*. */
    get isHot() { const currSnap = this.getCurrSnapDetail(); return !currSnap ? false : currSnap.isHot; }
    /** @internal */
    destroy() { this.currHit = undefined; this.aSnapHits = undefined; }
    get _doSnapping() { return this.isSnapEnabled && this.isSnapEnabledByUser && !this._isSnapSuspended; }
    get _isSnapSuspended() { return (0 !== this._suppressed || 0 !== this.toolState.suspended); }
    /** Get the current snap divisor to use to use for SnapMode.NearestKeypoint.
     * @public
     */
    get keypointDivisor() { return 2; }
    /** Get the current active SnapModes. SnapMode position determines priority, with the first entry being the highest. The SnapDetail will be returned for the first SnapMode that produces a hot snap.
     * @public
     */
    getActiveSnapModes() {
        const snaps = [];
        snaps.push(HitDetail_1.SnapMode.NearestKeypoint);
        return snaps;
    }
    /** Can be implemented by a subclass of AccuSnap to implement a SnapMode override that applies only to the next point.
     * This method will be called whenever a new tool is installed and on button events.
     * @internal
     */
    synchSnapMode() { }
    /** Check whether current tentative snap has valid curve geometry for finding extended intersections. */
    get _searchForExtendedIntersections() {
        const snap = IModelApp_1.IModelApp.tentativePoint.getCurrSnap();
        return (undefined !== snap && undefined !== snap.primitive);
    }
    /**
     * Check to see whether its appropriate to generate an AccuSnap point, given the current user
     * and command settings, and whether a tentative point is currently active.
     */
    get isActive() {
        // Unless we're snapping in intersect mode (to find extended intersections), skip if tentative point active...
        if (IModelApp_1.IModelApp.tentativePoint.isActive) {
            if (!this._doSnapping || !this._searchForExtendedIntersections)
                return false;
            const snaps = this.getActiveSnapModes();
            for (const snap of snaps) {
                if (snap === HitDetail_1.SnapMode.Intersection)
                    return true;
            }
            return false;
        }
        return this._doSnapping || this.isLocateEnabled;
    }
    initializeForCheckMotion() {
        this._lastCursorPos.setFrom(IModelApp_1.IModelApp.toolAdmin.currentInputState.lastMotion);
    }
    /** Clear the current AccuSnap info. */
    clear() { this.setCurrHit(undefined); }
    /** @internal */
    setCurrHit(newHit) {
        const newSnap = AccuSnap.toSnapDetail(newHit);
        const currSnap = this.getCurrSnapDetail();
        const sameElem = (undefined !== newHit && newHit.isSameHit(this.currHit));
        const sameHit = (sameElem && !newSnap);
        const sameSnap = (sameElem && undefined !== newSnap && undefined !== currSnap);
        const samePt = (sameHit || (sameSnap && newSnap.snapPoint.isAlmostEqual(currSnap.snapPoint)));
        const sameHot = (sameHit || (sameSnap && (this.isHot === newSnap.isHot)));
        const sameBaseSnapMode = (!newSnap || !currSnap || newSnap.snapMode === currSnap.snapMode);
        const sameType = (sameHot && (!currSnap || (currSnap.getHitType() === newHit.getHitType())));
        // see if it is the same point on the same element, the hot flags are the same multiple snaps, and the snap modes are the same
        if (samePt && sameType && sameBaseSnapMode) {
            // we know that nothing about the screen could change, just save the new hit and return to avoid screen flash
            this.currHit = newHit;
            return;
        }
        this.erase();
        // if we hit the same element with the same "hotness" as last time, we don't need to erase it
        //  multiple snaps: but only if the old and new snap modes are the same
        if (!sameHot || !sameBaseSnapMode) {
            this.unFlashViews();
            this.setFlashHit(newHit);
        }
        // if we didn't get a new hit, we're done
        if (undefined === (this.currHit = newHit))
            return;
        // draw sprites for this hit
        this.showSnapSprite();
    }
    /** flash a hit in a single view. */
    flashHitInView(hit, context) {
        const viewport = context.viewport;
        if (!viewport || !this.hitShouldBeHilited(hit) || !this.needsFlash(viewport))
            return;
        hit.draw(context);
        this.setIsFlashed(viewport);
    }
    setNeedsFlashView(view) {
        if (!this.isFlashed(view) && !this.needsFlash(view))
            this.setNeedsFlash(view);
    }
    /** flash a hit in its view. */
    setFlashHit(hit) {
        if (hit !== undefined && this.hitShouldBeHilited(hit))
            this.setNeedsFlashView(hit.viewport);
    }
    /** @internal */
    erase() {
        this.clearToolTip(undefined); // make sure there's no tooltip up.
        this.clearSprites(); // remove all sprites from the screen
    }
    /** @internal */
    showElemInfo(viewPt, vp, hit) {
        if (IModelApp_1.IModelApp.viewManager.doesHostHaveFocus && undefined === this._toolTipPromise) {
            const promise = IModelApp_1.IModelApp.toolAdmin.getToolTip(hit);
            this._toolTipPromise = promise;
            promise.then((msg) => {
                // Ignore response if we're no longer interested in this tooltip.
                if (this._toolTipPromise === promise)
                    this.showLocateMessage(viewPt, vp, msg);
            });
        }
    }
    showLocateMessage(viewPt, vp, msg) {
        if (IModelApp_1.IModelApp.viewManager.doesHostHaveFocus)
            vp.openToolTip(msg, viewPt);
    }
    /** @internal */
    displayToolTip(viewPt, vp, uorPt) {
        // if the tooltip is already displayed, or if user doesn't want it, quit.
        if (0 === this._motionStopTime || !this._settings.toolTip || !IModelApp_1.IModelApp.notifications.isToolTipSupported || IModelApp_1.IModelApp.notifications.isToolTipOpen)
            return;
        const accuSnapHit = this.currHit;
        const tpHit = IModelApp_1.IModelApp.tentativePoint.getCurrSnap();
        // if we don't have either an AccuSnap or a tentative point hit, quit.
        if (!accuSnapHit && !tpHit && !this.errorIcon.isActive)
            return;
        // when the tentative button is first pressed, we pass nullptr for uorPt so that we can know to show the tooltip more quickly.
        const timeout = (undefined === tpHit || undefined !== uorPt ? this._settings.toolTipDelay : bentleyjs_core_1.BeDuration.fromSeconds(.1));
        // have we waited long enough to show the balloon?
        if ((this._motionStopTime + timeout.milliseconds) > Date.now())
            return;
        this._motionStopTime = 0; // If application chooses to not display tool tip, make sure we don't ask again until we see another motion/motion stopped...
        let theHit;
        // determine which type of hit
        if (tpHit) {
            if (uorPt) {
                // see if he came back somewhere near the currently snapped element
                const aperture = (this._settings.stickyFactor * vp.pixelsFromInches(IModelApp_1.IModelApp.locateManager.apertureInches) / 2.0) + 1.5;
                if (!IModelApp_1.IModelApp.locateManager.picker.testHit(tpHit, vp, uorPt, aperture, IModelApp_1.IModelApp.locateManager.options))
                    return;
            }
            theHit = tpHit;
        }
        else {
            theHit = accuSnapHit;
        }
        // if we're currently showing an error, get the error message...otherwise display hit info...
        if (!this.errorIcon.isActive && theHit) {
            this.showElemInfo(viewPt, vp, theHit);
            return;
        }
        // If we have an error explanation...use it as is!
        if (this.explanation) {
            this.showLocateMessage(viewPt, vp, this.explanation);
            return;
        }
        // if we don't have an explanation yet, translate the error code.
        if (!this.errorKey)
            return;
        this.explanation = IModelApp_1.IModelApp.i18n.translate(this.errorKey);
        if (!this.explanation)
            return;
        // Get the "best" rejected hit to augment the error explanation with the hit info...
        if (!theHit)
            theHit = this.aSnapHits ? this.aSnapHits.hits[0] : undefined;
        this.showLocateMessage(viewPt, vp, this.explanation);
    }
    /** @internal */
    clearToolTip(ev) {
        // Throw away any stale request for a tooltip message
        this._toolTipPromise = undefined;
        if (!IModelApp_1.IModelApp.notifications.isToolTipOpen)
            return;
        if (ev && (5 > ev.viewPoint.distanceXY(IModelApp_1.IModelApp.notifications.toolTipLocation)))
            return;
        IModelApp_1.IModelApp.notifications.clearToolTip();
    }
    /** Display the sprites for the current snap to indicate its position on the screen and what snap mode it represents. */
    showSnapSprite() {
        const snap = this.getCurrSnapDetail();
        if (!snap)
            return;
        const crossPt = snap.snapPoint;
        const viewport = snap.viewport;
        const crossSprite = Sprites_1.IconSprites.getSpriteFromUrl(snap.isHot ? "sprites/SnapCross.png" : "sprites/SnapUnfocused.png");
        this.cross.activate(crossSprite, viewport, crossPt);
        const snapSprite = snap.sprite;
        if (snapSprite)
            this.icon.activate(snapSprite, viewport, AccuSnap.adjustIconLocation(viewport, crossPt, snapSprite.size));
    }
    static adjustIconLocation(vp, input, iconSize) {
        const out = vp.worldToView(input);
        out.x += (iconSize.x / 3.0);
        out.y -= (iconSize.y * 1.3);
        return vp.viewToWorld(out, out);
    }
    /** try to indicate what's wrong with the current point (why we're not snapping). */
    showSnapError(out, ev) {
        this.explanation = out.explanation;
        this.errorKey = out.reason;
        this.errorIcon.deactivate();
        const vp = ev.viewport;
        let errorSprite;
        switch (out.snapStatus) {
            case ElementLocateManager_1.SnapStatus.FilteredByApp:
                errorSprite = Sprites_1.IconSprites.getSpriteFromUrl("sprites/SnapAppFiltered.png");
                break;
            case ElementLocateManager_1.SnapStatus.FilteredByAppQuietly:
                this.errorKey = undefined;
                break;
            case ElementLocateManager_1.SnapStatus.NotSnappable:
                errorSprite = Sprites_1.IconSprites.getSpriteFromUrl("sprites/SnapNotSnappable.png");
                this.errorKey = ElementLocateManager_1.ElementLocateManager.getFailureMessageKey("NotSnappable");
                break;
        }
        if (!errorSprite)
            return;
        const spriteSize = errorSprite.size;
        const pt = AccuSnap.adjustIconLocation(vp, ev.rawPoint, spriteSize);
        this.errorIcon.activate(errorSprite, vp, pt);
    }
    clearSprites() {
        this.errorIcon.deactivate();
        this.cross.deactivate();
        this.icon.deactivate();
    }
    /** determine whether a hit should be hilited or not. */
    hitShouldBeHilited(hit) {
        if (!hit)
            return false;
        if (hit.isModelHit)
            return false; // Avoid annoying flashing of reality models.
        const snap = AccuSnap.toSnapDetail(hit);
        return !snap || snap.isHot || this._settings.hiliteColdHits;
    }
    unFlashViews() {
        this.needFlash.clear();
        this.areFlashed.forEach((vp) => {
            vp.setFlashed(undefined, 0.0);
        });
        this.areFlashed.clear();
    }
    /** @internal */
    adjustPointIfHot(pt, view) {
        const currSnap = this.getCurrSnapDetail();
        if (!currSnap || !currSnap.isHot || view !== currSnap.viewport)
            return;
        pt.setFrom(currSnap.adjustedPoint);
    }
    /** Implemented by sub-classes to update ui to show current enabled state.
     * @internal
     */
    onEnabledStateChange(_isEnabled, _wasEnabled) { }
    /** @internal */
    getHitAndList(holder) {
        const hit = this.currHit;
        if (hit) {
            holder.setHitList(this.aSnapHits);
            this.aSnapHits = undefined;
        }
        return hit;
    }
    initCmdState() { this.toolState.suspended = 0; }
    /** @internal */
    suspend(doSuspend) {
        const previousDoSnapping = this._doSnapping;
        if (doSuspend)
            this.toolState.suspended++;
        else if (this.toolState.suspended > 0)
            this.toolState.suspended--;
        this.onEnabledStateChange(this._doSnapping, previousDoSnapping);
    }
    /** @internal */
    suppress(doSuppress) {
        const previousDoSnapping = this._doSnapping;
        if (doSuppress)
            this._suppressed++;
        else if (this._suppressed > 0)
            this._suppressed--;
        this.onEnabledStateChange(this._doSnapping, previousDoSnapping);
        return this._suppressed;
    }
    /** Turn AccuSnap on or off */
    enableSnap(yesNo) {
        const previousDoSnapping = this._doSnapping;
        this.toolState.enabled = yesNo;
        if (!yesNo) {
            this.clear();
            if (undefined !== this.touchCursor) {
                this.touchCursor = undefined;
                IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            }
        }
        this.onEnabledStateChange(this._doSnapping, previousDoSnapping);
    }
    /** @internal */
    intersectXY(tpSnap, second) {
        // Get single segment curve from each snap to intersect...
        const tpSegment = tpSnap.getCurvePrimitive();
        if (undefined === tpSegment)
            return undefined;
        const segment = second.getCurvePrimitive();
        if (undefined === segment)
            return undefined;
        const worldToView = second.viewport.worldToViewMap.transform0;
        const detail = geometry_core_1.CurveCurve.intersectionProjectedXY(worldToView, tpSegment, true, segment, true);
        if (0 === detail.dataA.length)
            return undefined;
        let closeIndex = 0;
        if (detail.dataA.length > 1) {
            const snapPt = worldToView.multiplyPoint3d(HitDetail_1.HitGeomType.Point === tpSnap.geomType && HitDetail_1.HitGeomType.Point !== second.geomType ? second.getPoint() : tpSnap.getPoint(), 1); // Don't check distance from arc centers...
            let lastDist;
            for (let i = 0; i < detail.dataA.length; i++) {
                const testPt = worldToView.multiplyPoint3d(detail.dataA[i].point, 1);
                const testDist = snapPt.realDistanceXY(testPt);
                if (undefined !== testDist && (undefined === lastDist || testDist < lastDist)) {
                    lastDist = testDist;
                    closeIndex = i;
                }
            }
        }
        const intersect = new HitDetail_1.IntersectDetail(tpSnap, HitDetail_1.SnapHeat.InRange, detail.dataA[closeIndex].point, segment, second.sourceId); // Should be ok to share hit detail with tentative...
        intersect.primitive = tpSegment; // Just save single segment that was intersected for line strings/shapes...
        return intersect;
    }
    /** @internal */
    static async requestSnap(thisHit, snapModes, hotDistanceInches, keypointDivisor, hitList, out) {
        if (undefined !== thisHit.subCategoryId) {
            const appearance = thisHit.viewport.getSubCategoryAppearance(thisHit.subCategoryId);
            if (appearance.dontSnap) {
                if (out)
                    out.snapStatus = ElementLocateManager_1.SnapStatus.NotSnappable;
                return undefined;
            }
        }
        const requestProps = {
            id: thisHit.sourceId,
            testPoint: thisHit.testPoint,
            closePoint: thisHit.hitPoint,
            worldToView: thisHit.viewport.worldToViewMap.transform0.toJSON(),
            viewFlags: thisHit.viewport.viewFlags,
            snapModes,
            snapAperture: thisHit.viewport.pixelsFromInches(hotDistanceInches),
            snapDivisor: keypointDivisor,
            subCategoryId: thisHit.subCategoryId,
            geometryClass: thisHit.geometryClass,
        };
        if (!thisHit.isElementHit) {
            const thisGeom = IModelApp_1.IModelApp.viewManager.getDecorationGeometry(thisHit);
            if (undefined === thisGeom) {
                if (out)
                    out.snapStatus = ElementLocateManager_1.SnapStatus.NoSnapPossible;
                return undefined;
            }
            requestProps.decorationGeometry = [{ id: thisHit.sourceId, geometryStream: thisGeom }];
        }
        if (snapModes.includes(HitDetail_1.SnapMode.Intersection)) {
            if (undefined !== hitList) {
                for (const hit of hitList.hits) {
                    if (thisHit.sourceId === hit.sourceId)
                        continue;
                    if (!hit.isElementHit) {
                        const geom = IModelApp_1.IModelApp.viewManager.getDecorationGeometry(hit);
                        if (undefined === geom)
                            continue;
                        if (undefined === requestProps.decorationGeometry)
                            requestProps.decorationGeometry = [{ id: thisHit.sourceId, geometryStream: geom }];
                        else
                            requestProps.decorationGeometry.push({ id: thisHit.sourceId, geometryStream: geom });
                    }
                    if (undefined === requestProps.intersectCandidates)
                        requestProps.intersectCandidates = [hit.sourceId];
                    else
                        requestProps.intersectCandidates.push(hit.sourceId);
                    if (5 === requestProps.intersectCandidates.length)
                        break; // Search for intersection with a few of the next best hits...
                }
            }
            if (1 === snapModes.length && undefined === requestProps.intersectCandidates) {
                if (out)
                    out.snapStatus = ElementLocateManager_1.SnapStatus.NoSnapPossible;
                return undefined; // Don't make back end request when only doing intersection snap when we don't have another hit to intersect with...
            }
        }
        const result = await thisHit.viewport.iModel.requestSnap(requestProps);
        if (out)
            out.snapStatus = result.status;
        if (result.status !== ElementLocateManager_1.SnapStatus.Success)
            return undefined;
        const snap = new HitDetail_1.SnapDetail(thisHit, result.snapMode, result.heat, result.snapPoint);
        snap.setCurvePrimitive(undefined !== result.curve ? geometry_core_1.IModelJson.Reader.parse(result.curve) : undefined, undefined, result.geomType);
        if (undefined !== result.parentGeomType)
            snap.parentGeomType = result.parentGeomType;
        if (undefined !== result.hitPoint)
            snap.hitPoint.setFromJSON(result.hitPoint); // Update hitPoint from readPixels with exact point location corrected to surface/edge geometry...
        if (undefined !== result.normal)
            snap.normal = geometry_core_1.Vector3d.fromJSON(result.normal);
        if (HitDetail_1.SnapMode.Intersection !== snap.snapMode)
            return snap;
        if (undefined === result.intersectId)
            return undefined;
        const otherPrimitive = (undefined !== result.intersectCurve ? geometry_core_1.IModelJson.Reader.parse(result.intersectCurve) : undefined);
        if (undefined === otherPrimitive)
            return undefined;
        const intersect = new HitDetail_1.IntersectDetail(snap, snap.heat, snap.snapPoint, otherPrimitive, result.intersectId);
        return intersect;
    }
    async getAccuSnapDetail(hitList, out) {
        const thisHit = hitList.getNextHit();
        if (undefined === thisHit)
            return undefined;
        const filterStatus = (this.isLocateEnabled ? IModelApp_1.IModelApp.locateManager.filterHit(thisHit, ElementLocateManager_1.LocateAction.AutoLocate, out) : ElementLocateManager_1.LocateFilterStatus.Accept);
        if (ElementLocateManager_1.LocateFilterStatus.Accept !== filterStatus) {
            out.snapStatus = ElementLocateManager_1.SnapStatus.FilteredByApp;
            return undefined;
        }
        let snapModes;
        if (IModelApp_1.IModelApp.tentativePoint.isActive) {
            snapModes = [];
            snapModes.push(HitDetail_1.SnapMode.Nearest); // Special case: isActive only allows snapping with tentative to find extended intersections...
        }
        else {
            snapModes = this.getActiveSnapModes(); // Get the list of point snap modes to consider
        }
        const thisSnap = await AccuSnap.requestSnap(thisHit, snapModes, this._hotDistanceInches, this.keypointDivisor, hitList, out);
        if (undefined === thisSnap)
            return undefined;
        if (IModelApp_1.IModelApp.tentativePoint.isActive) {
            const tpSnap = IModelApp_1.IModelApp.tentativePoint.getCurrSnap();
            if (undefined === tpSnap)
                return undefined;
            const intersectSnap = this.intersectXY(tpSnap, thisSnap);
            if (undefined === intersectSnap)
                return undefined;
            hitList.setCurrentHit(thisHit);
            return intersectSnap;
        }
        IModelApp_1.IModelApp.accuDraw.onSnap(thisSnap); // AccuDraw can adjust nearest snap to intersection of circle (polar distance lock) or line (axis lock) with snapped to curve...
        hitList.setCurrentHit(thisHit);
        return thisSnap;
    }
    findHits(ev, force = false) {
        // When using AccuSnap to locate elements, we have to start with the datapoint adjusted
        // for locks and not the raw point. Otherwise, when grid/unit lock are on, we locate elements by
        // points not on the grid. This causes them to be "pulled" off the grid when they are accepted. On
        // the other hand, when NOT locating, we need to use the raw point so we can snap to elements
        // away from the grid.
        const testPoint = this.isLocateEnabled ? ev.point : ev.rawPoint;
        const vp = ev.viewport;
        const picker = IModelApp_1.IModelApp.locateManager.picker;
        const options = IModelApp_1.IModelApp.locateManager.options.clone(); // Copy to avoid changing out from under active Tool...
        // NOTE: Since TestHit will use the same HitSource as the input hit we only need to sets this for DoPick...
        options.hitSource = this.isSnapEnabled ? HitDetail_1.HitSource.AccuSnap : HitDetail_1.HitSource.MotionLocate;
        let aperture = (vp.pixelsFromInches(IModelApp_1.IModelApp.locateManager.apertureInches) / 2.0) + 1.5;
        this.initializeForCheckMotion();
        aperture *= this._searchDistance;
        if (0 === picker.doPick(vp, testPoint, aperture, options)) {
            this.aSnapHits = undefined; // Clear any previous hit list so reset won't cycle through hits cursor is no longer over, etc.
            return ElementLocateManager_1.SnapStatus.NoElements;
        }
        this.aSnapHits = picker.getHitList(true); // take ownership of the pickElem hit list.
        // see if we should keep the current hit
        const canBeSticky = !force && this.aSnapHits.length > 1 && this.currHit && (HitDetail_1.HitDetailType.Intersection !== this.currHit.getHitType() && this.currHit.priority < HitDetail_1.HitPriority.PlanarSurface);
        if (canBeSticky) {
            for (let iHit = 1; iHit < this.aSnapHits.length; ++iHit) {
                const thisHit = this.aSnapHits.hits[iHit];
                if (!thisHit.isSameHit(this.currHit))
                    continue;
                this.aSnapHits.removeHit(iHit);
                this.aSnapHits.insertHit(0, thisHit);
                break;
            }
        }
        return ElementLocateManager_1.SnapStatus.Success;
    }
    async findLocatableHit(ev, newSearch, out) {
        out.snapStatus = ElementLocateManager_1.SnapStatus.NoElements;
        if (newSearch) {
            this.aSnapHits = undefined;
            // search for new hits, but if the cursor is still close to the current hit, don't throw away list.
            if (ElementLocateManager_1.SnapStatus.Success !== (out.snapStatus = this.findHits(ev)))
                return undefined;
        }
        else {
            if (!this.aSnapHits) {
                out.snapStatus = ElementLocateManager_1.SnapStatus.NoElements;
                return undefined;
            }
        }
        const thisList = this.aSnapHits;
        let thisHit;
        const ignore = new ElementLocateManager_1.LocateResponse();
        // keep looking through hits until we find one that is accu-snappable.
        while (undefined !== (thisHit = thisList.getNextHit())) {
            if (ElementLocateManager_1.LocateFilterStatus.Accept === await IModelApp_1.IModelApp.locateManager.filterHit(thisHit, ElementLocateManager_1.LocateAction.AutoLocate, out))
                return thisHit;
            // we only care about the status of the first hit.
            out.snapStatus = ElementLocateManager_1.SnapStatus.FilteredByApp;
            out = ignore;
        }
        // Reset current hit index to go back to first hit on next AccuSnap reset event...
        thisList.resetCurrentHit();
        return undefined;
    }
    /** When in auto-locate mode, advance to the next hit without searching again.
     * @internal
     */
    async resetButton() {
        let hit;
        const out = new ElementLocateManager_1.LocateResponse();
        out.snapStatus = ElementLocateManager_1.SnapStatus.Disabled;
        this.clearToolTip(undefined);
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        if (this._doSnapping) {
            // if we don't have any more candidate hits, get a new list at the current location
            if (!this.aSnapHits || (0 === this.aSnapHits.length)) {
                out.snapStatus = this.findHits(ev);
                hit = (ElementLocateManager_1.SnapStatus.Success !== out.snapStatus) ? undefined : await this.getAccuSnapDetail(this.aSnapHits, out);
            }
            else {
                // drop the current hit from the list and then retest the list (without the dropped hit) to find the new snap
                this.aSnapHits.removeCurrentHit();
                hit = await this.getAccuSnapDetail(this.aSnapHits, out);
            }
        }
        else if (this.isLocateEnabled) {
            hit = await this.findLocatableHit(ev, false, out); // get next AccuSnap path (or undefined)
        }
        // set the current hit
        if (hit || this.currHit)
            this.setCurrHit(hit);
        // indicate errors
        this.showSnapError(out, ev);
        return out.snapStatus;
    }
    /** Find the best snap point according to the current cursor location
     * @internal
     */
    async onMotion(ev) {
        this.clearToolTip(ev);
        const out = new ElementLocateManager_1.LocateResponse();
        out.snapStatus = ElementLocateManager_1.SnapStatus.Disabled;
        let hit;
        if (this.isActive) {
            if (this._doSnapping) {
                out.snapStatus = this.findHits(ev);
                hit = (ElementLocateManager_1.SnapStatus.Success !== out.snapStatus) ? undefined : await this.getAccuSnapDetail(this.aSnapHits, out);
            }
            else if (this.isLocateEnabled) {
                hit = await this.findLocatableHit(ev, true, out);
            }
        }
        // set the current hit and display the sprite (based on snap's KeypointType)
        if (hit || this.currHit)
            this.setCurrHit(hit);
        // indicate errors
        this.showSnapError(out, ev);
        if (undefined !== this.touchCursor && Tool_1.InputSource.Mouse === ev.inputSource) {
            this.touchCursor = undefined;
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        }
    }
    /** @internal */
    onMotionStopped(_ev) { this._motionStopTime = Date.now(); }
    /** @internal */
    async onNoMotion(ev) { this.displayToolTip(ev.viewPoint, ev.viewport, ev.rawPoint); return Promise.resolve(); }
    /** @internal */
    onPreButtonEvent(ev) { return (undefined !== this.touchCursor) ? this.touchCursor.isButtonHandled(ev) : false; }
    /** @internal */
    onTouchStart(ev) { if (undefined !== this.touchCursor)
        this.touchCursor.doTouchStart(ev); }
    /** @internal */
    onTouchEnd(ev) { if (undefined !== this.touchCursor && 0 === ev.touchCount)
        this.touchCursor.doTouchEnd(ev); }
    /** @internal */
    onTouchCancel(ev) { if (undefined !== this.touchCursor)
        this.touchCursor.doTouchEnd(ev); }
    /** @internal */
    onTouchMove(ev) { return (undefined !== this.touchCursor) ? this.touchCursor.doTouchMove(ev) : false; }
    /** @internal */
    onTouchMoveStart(ev, startEv) { return (undefined !== this.touchCursor) ? this.touchCursor.doTouchMoveStart(ev, startEv) : false; }
    /** @internal */
    async onTouchTap(ev) {
        if (undefined !== this.touchCursor)
            return this.touchCursor.doTouchTap(ev);
        if (!this._doSnapping)
            return false;
        return (undefined !== (this.touchCursor = TouchCursor.createFromTouchTap(ev)));
    }
    flashElements(context) {
        const viewport = context.viewport;
        if (this.currHit) {
            if (this.needsFlash(viewport))
                this.flashHitInView(this.currHit, context);
            return;
        }
        const hit = IModelApp_1.IModelApp.tentativePoint.getCurrSnap();
        if (hit)
            hit.draw(context);
    }
    /** @internal */
    decorate(context) {
        if (undefined !== this.touchCursor)
            context.addCanvasDecoration(this.touchCursor, true);
        this.flashElements(context);
        if (this.cross.isActive) {
            this.cross.decorate(context);
            this.icon.decorate(context);
        }
        this.errorIcon.decorate(context);
    }
    clearElemFromHitList(element) {
        if (this.aSnapHits)
            this.aSnapHits.removeHitsFrom(element);
    }
    /** @internal */
    clearIfElement(sourceId) {
        this.clearElemFromHitList(sourceId);
        const hit = this.currHit;
        if (hit && hit.sourceId === sourceId) {
            this.destroy();
        }
    }
    /** Enable locating elements.
     * @public
     */
    enableLocate(yesNo) { this.toolState.locate = yesNo; }
    /** Called whenever a new [[Tool]] is started.
     * @internal
     */
    onStartTool() {
        this.initCmdState();
        this.enableSnap(false);
        this.enableLocate(false);
        IModelApp_1.IModelApp.tentativePoint.clear(true);
    }
    /**
     * Force AccuSnap to reevaluate the snap at the current cursor location.
     * This is useful of an application changes the snap mode and wants AccuSnap to choose it immediately, without
     * requiring the user to move the mouse.
     * @internal
     */
    async reEvaluate() {
        if (this.getCurrSnapDetail()) {
            const ev = new Tool_1.BeButtonEvent();
            IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
            return this.onMotion(ev);
        }
    }
}
exports.AccuSnap = AccuSnap;
/** @internal */
class TentativeOrAccuSnap {
    static get isHot() { return IModelApp_1.IModelApp.accuSnap.isHot || IModelApp_1.IModelApp.tentativePoint.isSnapped; }
    static getCurrentSnap(checkIsHot = true) {
        // Checking for a hot AccuSnap hit before checking tentative is probably necessary for extended intersections?
        if (IModelApp_1.IModelApp.accuSnap.isHot)
            return IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
        if (IModelApp_1.IModelApp.tentativePoint.isSnapped)
            return IModelApp_1.IModelApp.tentativePoint.currSnap;
        return (checkIsHot ? undefined : IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail());
    }
    static getCurrentPoint() {
        if (IModelApp_1.IModelApp.accuSnap.isHot) {
            const snap = IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
            if (snap)
                return snap.adjustedPoint;
        }
        return IModelApp_1.IModelApp.tentativePoint.getPoint();
    }
    static getCurrentView() {
        const snap = IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
        return snap ? snap.viewport : IModelApp_1.IModelApp.tentativePoint.viewport;
    }
}
exports.TentativeOrAccuSnap = TentativeOrAccuSnap;
/** @public */
(function (AccuSnap) {
    class ToolState {
        constructor() {
            this.enabled = false;
            this.locate = false;
            this.suspended = 0;
        }
        setFrom(other) {
            this.enabled = other.enabled;
            this.locate = other.locate;
            this.suspended = other.suspended;
        }
        clone() { const val = new ToolState(); val.setFrom(this); return val; }
    }
    AccuSnap.ToolState = ToolState;
    class Settings {
        constructor() {
            this.hotDistanceFactor = 1.2;
            this.stickyFactor = 1.0;
            this.searchDistance = 2.0;
            this.hiliteColdHits = true;
            this.enableFlag = true;
            this.toolTip = true;
            this.toolTipDelay = bentleyjs_core_1.BeDuration.fromSeconds(.5); // delay before tooltip pops up
        }
    }
    AccuSnap.Settings = Settings;
})(AccuSnap = exports.AccuSnap || (exports.AccuSnap = {}));


/***/ }),

/***/ "./lib/AuxCoordSys.js":
/*!****************************!*\
  !*** ./lib/AuxCoordSys.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const EntityState_1 = __webpack_require__(/*! ./EntityState */ "./lib/EntityState.js");
const GraphicBuilder_1 = __webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/Viewport.js");
/** @public */
var ACSType;
(function (ACSType) {
    ACSType[ACSType["None"] = 0] = "None";
    ACSType[ACSType["Rectangular"] = 1] = "Rectangular";
    ACSType[ACSType["Cylindrical"] = 2] = "Cylindrical";
    ACSType[ACSType["Spherical"] = 3] = "Spherical";
})(ACSType = exports.ACSType || (exports.ACSType = {}));
/** @public */
var ACSDisplayOptions;
(function (ACSDisplayOptions) {
    ACSDisplayOptions[ACSDisplayOptions["None"] = 0] = "None";
    ACSDisplayOptions[ACSDisplayOptions["Active"] = 1] = "Active";
    ACSDisplayOptions[ACSDisplayOptions["Deemphasized"] = 2] = "Deemphasized";
    ACSDisplayOptions[ACSDisplayOptions["Hilite"] = 4] = "Hilite";
    ACSDisplayOptions[ACSDisplayOptions["CheckVisible"] = 8] = "CheckVisible";
    ACSDisplayOptions[ACSDisplayOptions["Dynamics"] = 16] = "Dynamics";
})(ACSDisplayOptions = exports.ACSDisplayOptions || (exports.ACSDisplayOptions = {}));
/** The state of an AuxCoordSystem element in the frontend
 * @public
 */
class AuxCoordSystemState extends EntityState_1.ElementState {
    /** @internal */
    static get className() { return "AuxCoordSystem"; }
    static fromProps(props, iModel) {
        const name = props.classFullName.toLowerCase();
        if (name.endsWith("system2d"))
            return new AuxCoordSystem2dState(props, iModel);
        if (name.endsWith("system3d"))
            return new AuxCoordSystem3dState(props, iModel);
        return new AuxCoordSystemSpatialState(props, iModel);
    }
    /** Create a new AuxCoordSystemState.
     * @param acsName the name for the new AuxCoordSystem
     * @param iModel the iModel for which the ACS applies.
     * @note call this method with the appropriate subclass (e.g. AuxCoordSystemSpatialState, AuxCoordSystem2dState, etc), not on AuxCoordSystemState directly
     */
    static createNew(acsName, iModel) {
        const myCode = new imodeljs_common_1.Code({ spec: imodeljs_common_1.BisCodeSpec.auxCoordSystemSpatial, scope: imodeljs_common_1.IModel.dictionaryId.toString(), value: acsName });
        return new AuxCoordSystemSpatialState({ model: imodeljs_common_1.IModel.dictionaryId, code: myCode, classFullName: this.classFullName }, iModel);
    }
    constructor(props, iModel) {
        super(props, iModel);
        this.type = bentleyjs_core_1.JsonUtils.asInt(props.type, ACSType.None);
        this.description = props.description;
    }
    toJSON() {
        const val = super.toJSON();
        val.type = this.type;
        val.description = this.description;
        return val;
    }
    isValidForView(view) {
        if (view.isSpatialView())
            return this instanceof AuxCoordSystemSpatialState;
        return (view.is3d() === this.is3d);
    }
    get is3d() { return this instanceof AuxCoordSystem3dState; }
    drawGrid(context) {
        // Called for active ACS when grid orientation is GridOrientationType::ACS.
        const view = context.viewport.view;
        const fixedRepsAuto = geometry_core_1.Point2d.create(); // limit grid to project extents
        context.drawStandardGrid(this.getOrigin(), this.getRotation(), view.getGridSpacing(), view.getGridsPerRef(), false, fixedRepsAuto);
    }
    /** Returns the value, clamped to the supplied range. */
    static limitRange(min, max, val) { return Math.max(min, Math.min(max, val)); }
    /**
     * Given an origin point, returns whether the point falls within the view or not. If adjustOrigin is set to true, a point outside
     * the view will be modified to fall within the appropriate range.
     */
    static isOriginInView(drawOrigin, viewport, adjustOrigin) {
        const testPtView = viewport.worldToView(drawOrigin);
        const frustum = viewport.getFrustum(Viewport_1.CoordSystem.View);
        const screenRange = geometry_core_1.Point3d.create();
        screenRange.x = frustum.points[imodeljs_common_1.Npc._000].distance(frustum.points[imodeljs_common_1.Npc._100]);
        screenRange.y = frustum.points[imodeljs_common_1.Npc._000].distance(frustum.points[imodeljs_common_1.Npc._010]);
        screenRange.z = frustum.points[imodeljs_common_1.Npc._000].distance(frustum.points[imodeljs_common_1.Npc._001]);
        // Check if current acs origin is outside view...
        const inView = (!((testPtView.x < 0 || testPtView.x > screenRange.x) || (testPtView.y < 0 || testPtView.y > screenRange.y)));
        if (!adjustOrigin)
            return inView;
        if (!inView) {
            const offset = viewport.pixelsFromInches(0.6 /* TriadSizeInches */);
            testPtView.x = AuxCoordSystemState.limitRange(offset, screenRange.x - offset, testPtView.x);
            testPtView.y = AuxCoordSystemState.limitRange(offset, screenRange.y - offset, testPtView.y);
        }
        // Limit point to NPC box to prevent triad from being clipped from display...
        const originPtNpc = viewport.viewToNpc(testPtView);
        originPtNpc.x = AuxCoordSystemState.limitRange(0, 1, originPtNpc.x);
        originPtNpc.y = AuxCoordSystemState.limitRange(0, 1, originPtNpc.y);
        originPtNpc.z = AuxCoordSystemState.limitRange(0, 1, originPtNpc.z);
        viewport.npcToView(originPtNpc, testPtView);
        viewport.viewToWorld(testPtView, drawOrigin);
        return inView;
    }
    getAdjustedColor(inColor, isFill, viewport, options) {
        const color = new imodeljs_common_1.ColorDef();
        if ((options & ACSDisplayOptions.Hilite) !== ACSDisplayOptions.None) {
            color.setFrom(viewport.hilite.color);
        }
        else if ((options & ACSDisplayOptions.Active) !== ACSDisplayOptions.None) {
            color.setFrom(inColor.equals(imodeljs_common_1.ColorDef.white) ? viewport.getContrastToBackgroundColor() : inColor);
        }
        else {
            color.colors.r = 150;
            color.colors.g = 150;
            color.colors.b = 150;
            color.colors.t = 0;
        }
        color.adjustForContrast(viewport.view.backgroundColor);
        if (isFill)
            color.setTransparency((options & (ACSDisplayOptions.Deemphasized | ACSDisplayOptions.Dynamics)) !== ACSDisplayOptions.None ? 225 : 200);
        else
            color.setTransparency((options & ACSDisplayOptions.Deemphasized) !== ACSDisplayOptions.None ? 150 : 75);
        return color;
    }
    addAxisLabel(builder, axis, options, vp) {
        const color = imodeljs_common_1.ColorDef.white;
        const lineColor = this.getAdjustedColor(color, false, vp, options);
        builder.setSymbology(lineColor, lineColor, 2);
        const linePts1 = [];
        if (0 === axis) {
            linePts1[0] = geometry_core_1.Point3d.create(0.4 /* LabelStart */, -0.15 /* LabelWidth */);
            linePts1[1] = geometry_core_1.Point3d.create(0.8 /* LabelEnd */, 0.15 /* LabelWidth */);
        }
        else {
            linePts1[0] = geometry_core_1.Point3d.create(0.0, 0.4 /* LabelStart */);
            linePts1[1] = geometry_core_1.Point3d.create(0.0, (0.4 /* LabelStart */ + 0.8 /* LabelEnd */) * 0.5);
        }
        builder.addLineString(linePts1);
        const linePts2 = []; // NOTE: Don't use same point array, addPointString/addLineString don't deep copy...
        if (0 === axis) {
            linePts2[0] = geometry_core_1.Point3d.create(0.4 /* LabelStart */, 0.15 /* LabelWidth */);
            linePts2[1] = geometry_core_1.Point3d.create(0.8 /* LabelEnd */, -0.15 /* LabelWidth */);
        }
        else {
            linePts2[0] = geometry_core_1.Point3d.create(0.15 /* LabelWidth */, 0.8 /* LabelEnd */);
            linePts2[1] = geometry_core_1.Point3d.create(0.0, (0.4 /* LabelStart */ + 0.8 /* LabelEnd */) * 0.5);
            linePts2[2] = geometry_core_1.Point3d.create(-0.15 /* LabelWidth */, 0.8 /* LabelEnd */);
        }
        builder.addLineString(linePts2);
    }
    addAxis(builder, axis, options, vp) {
        const color = (0 === axis ? imodeljs_common_1.ColorDef.red : (1 === axis ? imodeljs_common_1.ColorDef.green : imodeljs_common_1.ColorDef.blue));
        const lineColor = this.getAdjustedColor(color, false, vp, options);
        const fillColor = this.getAdjustedColor(color, true, vp, options);
        if (axis === 2) {
            builder.setSymbology(lineColor, lineColor, 6);
            builder.addPointString([geometry_core_1.Point3d.create(0.0, 0.0, 0.65 /* ZAxisLength */)]); // NOTE: ACS origin point will be drawn separately as a pickable world decoration...
            const linePts2 = [geometry_core_1.Point3d.create(), geometry_core_1.Point3d.create()]; // NOTE: Don't use same point array, addPointString/addLineString don't deep copy...
            linePts2[1].z = 0.65 /* ZAxisLength */;
            builder.setSymbology(lineColor, lineColor, 1, (options & ACSDisplayOptions.Dynamics) === ACSDisplayOptions.None ? imodeljs_common_1.LinePixels.Solid : imodeljs_common_1.LinePixels.Code2);
            builder.addLineString(linePts2);
            const scale = 0.4 /* ArrowTipWidth */ / 2;
            const center = geometry_core_1.Point3d.create();
            const viewRMatrix = vp.rotation;
            const xVec = viewRMatrix.getRow(0);
            const yVec = viewRMatrix.getRow(1);
            builder.placement.matrix.multiplyTransposeVectorInPlace(xVec);
            builder.placement.matrix.multiplyTransposeVectorInPlace(yVec);
            xVec.normalize(xVec);
            yVec.normalize(yVec);
            const ellipse = geometry_core_1.Arc3d.createScaledXYColumns(center, geometry_core_1.Matrix3d.createColumns(xVec, yVec, geometry_core_1.Vector3d.create()), scale, scale, geometry_core_1.AngleSweep.createStartEnd(geometry_core_1.Angle.createRadians(0), geometry_core_1.Angle.createRadians(Math.PI * 2)));
            builder.addArc(ellipse, false, false);
            builder.setBlankingFill(fillColor);
            builder.addArc(ellipse, true, true);
            return;
        }
        const shapePts = [];
        shapePts[0] = geometry_core_1.Point3d.create(1.25 /* ArrowTipEnd */, 0.0);
        shapePts[1] = geometry_core_1.Point3d.create(0.75 /* ArrowTipFlange */, 0.4 /* ArrowTipWidth */);
        shapePts[2] = geometry_core_1.Point3d.create(0.85 /* ArrowTipStart */, 0.2 /* ArrowBaseWidth */);
        shapePts[3] = geometry_core_1.Point3d.create(0.3 /* ArrowBaseStart */, 0.2 /* ArrowBaseWidth */);
        shapePts[4] = geometry_core_1.Point3d.create(0.3 /* ArrowBaseStart */, -0.2 /* ArrowBaseWidth */);
        shapePts[5] = geometry_core_1.Point3d.create(0.85 /* ArrowTipStart */, -0.2 /* ArrowBaseWidth */);
        shapePts[6] = geometry_core_1.Point3d.create(0.75 /* ArrowTipFlange */, -0.4 /* ArrowTipWidth */);
        shapePts[7] = shapePts[0].clone();
        if (1 === axis) {
            shapePts.forEach((tmpPt) => { tmpPt.set(tmpPt.y, tmpPt.x); });
        }
        builder.setSymbology(lineColor, lineColor, 1, (options & ACSDisplayOptions.Dynamics) === ACSDisplayOptions.None ? imodeljs_common_1.LinePixels.Solid : imodeljs_common_1.LinePixels.Code2);
        builder.addLineString(shapePts);
        this.addAxisLabel(builder, axis, options, vp);
        builder.setBlankingFill(fillColor);
        builder.addShape(shapePts);
    }
    /** Returns a GraphicBuilder for this AuxCoordSystemState. */
    createGraphicBuilder(context, options) {
        const checkOutOfView = (options & ACSDisplayOptions.CheckVisible) !== ACSDisplayOptions.None;
        const drawOrigin = this.getOrigin();
        if (checkOutOfView && !AuxCoordSystemState.isOriginInView(drawOrigin, context.viewport, true))
            options = options | ACSDisplayOptions.Deemphasized;
        let pixelSize = context.viewport.pixelsFromInches(0.6 /* TriadSizeInches */);
        if ((options & ACSDisplayOptions.Deemphasized) !== ACSDisplayOptions.None)
            pixelSize *= 0.8;
        else if ((options & ACSDisplayOptions.Active) !== ACSDisplayOptions.None)
            pixelSize *= 0.9;
        const exagg = context.viewport.view.getAspectRatioSkew();
        const scale = context.getPixelSizeAtPoint(drawOrigin) * pixelSize;
        const rMatrix = this.getRotation();
        rMatrix.inverse(rMatrix);
        rMatrix.scaleRows(scale, scale / exagg, scale, rMatrix);
        const transform = geometry_core_1.Transform.createOriginAndMatrix(drawOrigin, rMatrix);
        const builder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldOverlay, transform);
        const vp = context.viewport;
        this.addAxis(builder, 0, options, vp);
        this.addAxis(builder, 1, options, vp);
        this.addAxis(builder, 2, options, vp);
        return builder;
    }
    display(context, options) {
        const builder = this.createGraphicBuilder(context, options);
        if (undefined !== builder)
            context.addDecorationFromBuilder(builder);
    }
}
exports.AuxCoordSystemState = AuxCoordSystemState;
/** The state of an AuxCoordSystem2d element in the frontend
 * @public
 */
class AuxCoordSystem2dState extends AuxCoordSystemState {
    /** @internal */
    static get className() { return "AuxCoordSystem2d"; }
    constructor(props, iModel) {
        super(props, iModel);
        this.origin = geometry_core_1.Point2d.fromJSON(props.origin);
        this.angle = bentleyjs_core_1.JsonUtils.asDouble(props.angle);
        this._rMatrix = geometry_core_1.Matrix3d.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), geometry_core_1.Angle.createDegrees(this.angle));
    }
    toJSON() {
        const val = super.toJSON();
        val.origin = this.origin;
        val.angle = this.angle;
        return val;
    }
    getOrigin(result) { return geometry_core_1.Point3d.createFrom(this.origin, result); }
    setOrigin(val) { this.origin.setFrom(val); }
    getRotation(result) { return this._rMatrix.clone(result); }
    setRotation(val) {
        this._rMatrix.setFrom(val);
        this.angle = geometry_core_1.YawPitchRollAngles.createFromMatrix3d(val).yaw.degrees;
    }
}
exports.AuxCoordSystem2dState = AuxCoordSystem2dState;
/** The state of an AuxCoordSystem3d element in the frontend
 * @public
 */
class AuxCoordSystem3dState extends AuxCoordSystemState {
    /** @internal */
    static get className() { return "AuxCoordSystem3d"; }
    constructor(props, iModel) {
        super(props, iModel);
        this.origin = geometry_core_1.Point3d.fromJSON(props.origin);
        this.yaw = bentleyjs_core_1.JsonUtils.asDouble(props.yaw);
        this.pitch = bentleyjs_core_1.JsonUtils.asDouble(props.pitch);
        this.roll = bentleyjs_core_1.JsonUtils.asDouble(props.roll);
        const angles = new geometry_core_1.YawPitchRollAngles(geometry_core_1.Angle.createDegrees(this.yaw), geometry_core_1.Angle.createDegrees(this.pitch), geometry_core_1.Angle.createDegrees(this.roll));
        this._rMatrix = angles.toMatrix3d();
    }
    toJSON() {
        const val = super.toJSON();
        val.origin = this.origin;
        val.yaw = this.yaw;
        val.pitch = this.pitch;
        val.roll = this.roll;
        return val;
    }
    getOrigin(result) { return geometry_core_1.Point3d.createFrom(this.origin, result); }
    setOrigin(val) { this.origin.setFrom(val); }
    getRotation(result) { return this._rMatrix.clone(result); }
    setRotation(rMatrix) {
        this._rMatrix.setFrom(rMatrix);
        const angles = geometry_core_1.YawPitchRollAngles.createFromMatrix3d(rMatrix);
        this.yaw = angles.yaw.degrees;
        this.pitch = angles.pitch.degrees;
        this.roll = angles.roll.degrees;
    }
}
exports.AuxCoordSystem3dState = AuxCoordSystem3dState;
/** The state of an AuxCoordSystemSpatial element in the frontend
 * @public
 */
class AuxCoordSystemSpatialState extends AuxCoordSystem3dState {
    /** @internal */
    static get className() { return "AuxCoordSystemSpatial"; }
}
exports.AuxCoordSystemSpatialState = AuxCoordSystemSpatialState;


/***/ }),

/***/ "./lib/CategorySelectorState.js":
/*!**************************************!*\
  !*** ./lib/CategorySelectorState.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const EntityState_1 = __webpack_require__(/*! ./EntityState */ "./lib/EntityState.js");
/** A set of Categories to be displayed in a [[ViewState]].
 * Elements belonging to categories not specified in the category selector will not be drawn in the view.
 * By default, geometry belonging to any [[SubCategory]] of a visible Category is also visible in the view,
 * unless the [[SubCategoryAppearance]] or [[SubCategoryOverride]] specifies that it should be invisible.
 * @note To change the set of categories visible in a [[ViewState]] currently associated with a [[Viewport]],
 * use [[ViewState.changeCategoryDisplay]] to ensure the view updates appropriately on screen.
 * @see [[Category]]
 * @public
 */
class CategorySelectorState extends EntityState_1.ElementState {
    constructor(props, iModel) {
        super(props, iModel);
        this.categories = new Set();
        if (props.categories)
            props.categories.forEach((cat) => this.categories.add(cat));
    }
    /** @internal */
    static get className() { return "CategorySelector"; }
    toJSON() {
        const val = super.toJSON();
        val.categories = [];
        this.categories.forEach((cat) => val.categories.push(cat));
        return val;
    }
    /** Returns true if this category selector is logically equivalent to the specified category selector.
     * Two category selectors are logically equivalent if they have the same name and Id and contain the same set of category Ids.
     */
    equalState(other) {
        if (this.categories.size !== other.categories.size || this.name !== other.name || this.id !== other.id)
            return false;
        const otherIter = other.categories.keys();
        let otherRes = otherIter.next();
        for (let thisIter = this.categories.keys(), thisRes = thisIter.next(); !thisRes.done; thisRes = thisIter.next(), otherRes = otherIter.next()) {
            if (thisRes.value !== otherRes.value)
                return false;
        }
        return true;
    }
    /** The name of this CategorySelector */
    get name() { return this.code.getValue(); }
    /** Determine whether this CategorySelector includes the specified categoryId string */
    has(id) { return this.categories.has(id.toString()); }
    /** Determine whether this CategorySelector includes the specified category */
    isCategoryViewed(categoryId) { return this.has(categoryId); }
    /** Add one or more categories to this CategorySelector */
    addCategories(arg) {
        bentleyjs_core_1.Id64.forEach(arg, (id) => this.categories.add(id));
    }
    /** Remove one or more categories from this CategorySelector */
    dropCategories(arg) {
        bentleyjs_core_1.Id64.forEach(arg, (id) => this.categories.delete(id));
    }
    /** Add or remove categories from this CategorySelector.
     * @param arg The categories to add or remove
     * @param add If true, categories will be added; otherwise they will be removed.
     */
    changeCategoryDisplay(arg, add) { if (add)
        this.addCategories(arg);
    else
        this.dropCategories(arg); }
}
exports.CategorySelectorState = CategorySelectorState;


/***/ }),

/***/ "./lib/ContextRealityModelState.js":
/*!*****************************************!*\
  !*** ./lib/ContextRealityModelState.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const FrontendRequestContext_1 = __webpack_require__(/*! ./FrontendRequestContext */ "./lib/FrontendRequestContext.js");
const ModelState_1 = __webpack_require__(/*! ./ModelState */ "./lib/ModelState.js");
const TileTree_1 = __webpack_require__(/*! ./tile/TileTree */ "./lib/tile/TileTree.js");
const RealityModelTileTree_1 = __webpack_require__(/*! ./tile/RealityModelTileTree */ "./lib/tile/RealityModelTileTree.js");
const imodeljs_clients_1 = __webpack_require__(/*! @bentley/imodeljs-clients */ "@bentley/imodeljs-clients");
/** @internal */
class ContextRealityModelState {
    constructor(props, iModel) {
        this._name = props.name ? props.name : "";
        this._tilesetUrl = props.tilesetUrl;
        this._tileTreeState = iModel.getContextRealityModelTileTree(this._tilesetUrl);
        this._modelId = this._tileTreeState.modelId;
        this._iModel = iModel;
        this._jsonProperties = { classifiers: props.classifiers };
    }
    get name() { return this._name; }
    get url() { return this._tilesetUrl; }
    get tileTree() { return this._tileTreeState.tileTree; }
    get loadStatus() { return this._tileTreeState.loadStatus; }
    get treeModelId() { return this._modelId; }
    get jsonProperties() { return this._jsonProperties; }
    get iModel() { return this._iModel; }
    loadTree(_edgesRequired, _animationId) {
        const tileTreeState = this._tileTreeState;
        if (TileTree_1.TileTree.LoadStatus.NotLoaded !== tileTreeState.loadStatus)
            return tileTreeState.loadStatus;
        tileTreeState.loadStatus = TileTree_1.TileTree.LoadStatus.Loading;
        RealityModelTileTree_1.RealityModelTileTree.loadRealityModelTileTree(this._tilesetUrl, undefined, tileTreeState);
        return tileTreeState.loadStatus;
    }
    static async getAccessToken() {
        if (!IModelApp_1.IModelApp.authorizationClient || !IModelApp_1.IModelApp.authorizationClient.hasSignedIn)
            return undefined; // Not signed in
        let accessToken;
        try {
            accessToken = await IModelApp_1.IModelApp.authorizationClient.getAccessToken();
        }
        catch (error) {
            return undefined;
        }
        return accessToken;
    }
    /**
     * Indicates if the reality model overlaps the project extent
     * @returns a bool that indicates if the model and the reality data overlap
     */
    async intersectsProjectExtents() {
        if (undefined === this._iModel.ecefLocation)
            return false;
        const accessToken = await ContextRealityModelState.getAccessToken();
        if (!accessToken)
            return false;
        const client = new RealityModelTileTree_1.RealityModelTileClient(this._tilesetUrl, accessToken);
        const json = await client.getRootDocument(this._tilesetUrl);
        let tileTreeRange, tileTreeTransform;
        if (json === undefined ||
            undefined === json.root ||
            undefined === (tileTreeRange = RealityModelTileTree_1.RealityModelTileUtils.rangeFromBoundingVolume(json.root.boundingVolume)) ||
            undefined === (tileTreeTransform = RealityModelTileTree_1.RealityModelTileUtils.transformFromJson(json.root.transform)))
            return false;
        const treeCartographicRange = new imodeljs_common_1.CartographicRange(tileTreeRange, tileTreeTransform);
        const projectCartographicRange = new imodeljs_common_1.CartographicRange(this._iModel.projectExtents, this._iModel.ecefLocation.getTransform());
        return treeCartographicRange.intersectsRange(projectCartographicRange);
    }
    /**
     * Gets a tileset's tile data blob key url
     * @param other Another ContextRealityModelState object to compare with self.
     * @returns a bool that indicates if the two match
     */
    matches(other) {
        return other.name === this.name && other.url === this.url;
    }
    /**
     * Returns a list of reality data associated to the given CONNECT project
     * @param projectId id of associated connect project
     * @param modelCartographicRange optional cartographic range of the model that can limit the spatial range for the search
     * @returns a list of reality model properties associated with the project
     */
    static async findAvailableRealityModels(projectid, modelCartographicRange) { return ContextRealityModelState.findAvailableUnattachedRealityModels(projectid, undefined, modelCartographicRange); }
    /**
     * Returns a list of reality data associated to the given CONNECT project - but filters out any reality sets that are directly attached to the iModel.
     * @param projectId id of associated connect project
     * @param iModel the iModel -- reality data sets attached to this model will be excluded from the returned list.
     * @param modelCartographicRange optional cartographic range of the model that can limit the spatial range for the search
     * @returns a list of reality model properties associated with the project
     */
    static async findAvailableUnattachedRealityModels(projectid, iModel, modelCartographicRange) {
        const availableRealityModels = [];
        const accessToken = await ContextRealityModelState.getAccessToken();
        if (!accessToken)
            return availableRealityModels;
        const requestContext = await FrontendRequestContext_1.AuthorizedFrontendRequestContext.create();
        requestContext.enter();
        const client = new imodeljs_clients_1.RealityDataServicesClient();
        let realityData;
        if (modelCartographicRange) {
            const iModelRange = modelCartographicRange.getLongitudeLatitudeBoundingBox();
            realityData = await client.getRealityDataInProjectOverlapping(requestContext, projectid, iModelRange);
        }
        else {
            realityData = await client.getRealityDataInProject(requestContext, projectid);
        }
        requestContext.enter();
        // Get set of URLs that are directly attached to the model.
        const modelRealityDataIds = new Set();
        if (iModel) {
            const query = { from: ModelState_1.SpatialModelState.classFullName, wantPrivate: false };
            const props = await iModel.models.queryProps(query);
            for (const prop of props)
                if (prop.jsonProperties !== undefined && prop.jsonProperties.tilesetUrl) {
                    const realityDataId = client.getRealityDataIdFromUrl(prop.jsonProperties.tilesetUrl);
                    if (realityDataId)
                        modelRealityDataIds.add(realityDataId);
                }
        }
        // We obtain the reality data name, and RDS URL for each RD returned.
        for (const currentRealityData of realityData) {
            let realityDataName = "";
            let validRd = true;
            if (currentRealityData.name && currentRealityData.name !== "") {
                realityDataName = currentRealityData.name;
            }
            else if (currentRealityData.rootDocument) {
                // In case root document contains a relative path we only keep the filename
                const rootDocParts = currentRealityData.rootDocumentb.split("/");
                realityDataName = rootDocParts[rootDocParts.length - 1];
            }
            else {
                // This case would not occur normally but if it does the RD is considered invalid
                validRd = false;
            }
            // If the RealityData is valid then we add it to the list.
            if (currentRealityData.id && validRd === true) {
                const url = await client.getRealityDataUrl(requestContext, projectid, currentRealityData.id);
                requestContext.enter();
                if (!modelRealityDataIds.has(currentRealityData.id))
                    availableRealityModels.push({ tilesetUrl: url, name: realityDataName, description: (currentRealityData.description ? currentRealityData.description : "") });
            }
        }
        return availableRealityModels;
    }
}
exports.ContextRealityModelState = ContextRealityModelState;


/***/ }),

/***/ "./lib/DevTools.js":
/*!*************************!*\
  !*** ./lib/DevTools.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/**
 * Internal diagnostic utility for backends
 * @internal
 */
class DevTools {
    /** Constructor */
    constructor(_iModelToken) {
        this._iModelToken = _iModelToken;
    }
    /** Create a new connection with a specific backend instance.
     * @param iModelToken The iModelToken that identifies that backend instance.
     * Supply a dummy token if contacting the backend without the Orchestrator.
     */
    static connectToBackendInstance(iModelToken) {
        return new DevTools(iModelToken);
    }
    /** Measures the round trip times for one or more pings to the backend
     * @param count Number of pings to send to the backend
     * @return Result of ping test.
     */
    async ping(count) {
        const pings = new Array(count);
        const pingFn = async () => {
            const start = Date.now();
            await imodeljs_common_1.DevToolsRpcInterface.getClient().ping(this._iModelToken.toJSON());
            return Promise.resolve(Date.now() - start);
        };
        for (let ii = 0; ii < count; ii++)
            pings[ii] = pingFn().catch(() => Promise.resolve(undefined));
        const pingTimes = await Promise.all(pings);
        const min = pingTimes.reduce((acc, curr) => {
            if (!acc)
                return curr;
            if (!curr)
                return acc;
            return Math.min(acc, curr);
        }, undefined);
        const max = pingTimes.reduce((acc, curr) => {
            if (typeof acc === "undefined")
                return undefined;
            if (!curr)
                return curr;
            return Math.max(acc, curr);
        }, 0);
        const total = pingTimes.reduce((acc, curr) => {
            if (typeof acc === "undefined")
                return undefined;
            if (!curr)
                return undefined;
            return acc + curr;
        }, 0);
        const avg = total ? total / count : undefined;
        return { min, max, avg };
    }
    /** Returns JSON object with backend statistics */
    async stats(options = imodeljs_common_1.DevToolsStatsOptions.FormatUnits) {
        return imodeljs_common_1.DevToolsRpcInterface.getClient().stats(this._iModelToken.toJSON(), options);
    }
    // Returns JSON object with backend versions (application and iModelJs)
    async versions() {
        return imodeljs_common_1.DevToolsRpcInterface.getClient().versions(this._iModelToken.toJSON());
    }
    /** Sets up a log level at the backend and returns the old log level */
    async setLogLevel(inLoggerCategory, newLevel) {
        return imodeljs_common_1.DevToolsRpcInterface.getClient().setLogLevel(this._iModelToken.toJSON(), inLoggerCategory, newLevel);
    }
}
exports.DevTools = DevTools;


/***/ }),

/***/ "./lib/DisplayStyleState.js":
/*!**********************************!*\
  !*** ./lib/DisplayStyleState.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const EntityState_1 = __webpack_require__(/*! ./EntityState */ "./lib/EntityState.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const WebMapTileTree_1 = __webpack_require__(/*! ./tile/WebMapTileTree */ "./lib/tile/WebMapTileTree.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const ContextRealityModelState_1 = __webpack_require__(/*! ./ContextRealityModelState */ "./lib/ContextRealityModelState.js");
const RenderScheduleState_1 = __webpack_require__(/*! ./RenderScheduleState */ "./lib/RenderScheduleState.js");
const SpatialClassification_1 = __webpack_require__(/*! ./SpatialClassification */ "./lib/SpatialClassification.js");
const SolarCalculate_1 = __webpack_require__(/*! ./SolarCalculate */ "./lib/SolarCalculate.js");
/** A DisplayStyle defines the parameters for 'styling' the contents of a [[ViewState]]
 * @note If the DisplayStyle is associated with a [[ViewState]] which is being rendered inside a [[Viewport]], modifying
 * the DisplayStyle directly will generally not result in immediately visible changes on the screen.
 * [[ViewState]] provides APIs which forward to the DisplayStyle API and also ensure the screen is updated promptly.
 * @public
 */
class DisplayStyleState extends EntityState_1.ElementState {
    /** @internal */
    static get className() { return "DisplayStyle"; }
    /** Construct a new DisplayStyleState from its JSON representation.
     * @param props JSON representation of the display style.
     * @param iModel IModelConnection containing the display style.
     */
    constructor(props, iModel) {
        super(props, iModel);
        const styles = this.jsonProperties.styles;
        const backgroundMap = undefined !== styles ? styles.backgroundMap : undefined;
        const mapProps = undefined !== backgroundMap ? backgroundMap : {};
        this._backgroundMap = new WebMapTileTree_1.BackgroundMapProvider(mapProps, iModel);
        this._contextRealityModels = [];
        if (styles) {
            if (styles.contextRealityModels)
                for (const contextRealityModel of styles.contextRealityModels)
                    this._contextRealityModels.push(new ContextRealityModelState_1.ContextRealityModelState(contextRealityModel, this.iModel));
            if (styles.analysisStyle)
                this._analysisStyle = imodeljs_common_1.AnalysisStyle.fromJSON(styles.analysisStyle);
            if (styles.scheduleScript)
                this._scheduleScript = RenderScheduleState_1.RenderScheduleState.Script.fromJSON(this.id, this.iModel, styles.scheduleScript);
        }
    }
    /** Modify the background map display settings.
     * @param mapProps JSON representation of the new settings.
     * @see [[ViewFlags.backgroundMap]] for toggling display of the map.
     * @note Currently the behavior of this method is not ideal.
     *  - If this display style is associated with a Viewport, you must call Viewport.invalidateScene for the view to display the new map.
     *  - Any properties omitted from `mapProps` will be reset to their defaults.
     *  - All loaded tiles will be discarded and new ones will be requested, even if only changing the groundBias.
     * @alpha
     */
    setBackgroundMap(mapProps) {
        if (!this.backgroundMap.equalsProps(mapProps)) {
            this._backgroundMap = new WebMapTileTree_1.BackgroundMapProvider(mapProps, this.iModel);
            this.settings.backgroundMap = mapProps;
        }
    }
    /** @internal */
    forEachContextRealityModel(func) {
        for (const contextRealityModel of this._contextRealityModels) {
            func(contextRealityModel);
        }
    }
    /** @internal */
    async loadContextRealityModels() {
        const classifierIds = new Set();
        for (const contextRealityModel of this._contextRealityModels) {
            const classifier = SpatialClassification_1.SpatialClassification.getClassifierProps(contextRealityModel);
            if (undefined !== classifier)
                classifierIds.add(classifier.modelId);
        }
        return SpatialClassification_1.SpatialClassification.loadClassifiers(classifierIds, this.iModel);
    }
    /** Performs logical comparison against another display style. Two display styles are logically equivalent if they have the same name, Id, and settings.
     * @param other The display style to which to compare.
     * @returns true if the specified display style is logically equivalent to this display style - i.e., both styles have the same values for all of their settings.
     */
    equalState(other) {
        if (this.name !== other.name || this.id !== other.id)
            return false;
        else
            return JSON.stringify(this.settings) === JSON.stringify(other.settings);
    }
    /** @internal */
    get backgroundMap() { return this._backgroundMap; }
    /** The name of this DisplayStyle */
    get name() { return this.code.getValue(); }
    /** Settings controlling display of analytical models.
     * @note Do not modify the style in place. Clone it and pass the clone to the setter.
     */
    get analysisStyle() { return this._analysisStyle; }
    set analysisStyle(style) {
        if (undefined === style) {
            this._analysisStyle = undefined;
        }
        else {
            if (undefined === this._analysisStyle)
                this._analysisStyle = imodeljs_common_1.AnalysisStyle.fromJSON(style);
            else
                this._analysisStyle.copyFrom(style);
        }
        this.jsonProperties.analysisStyle = this._analysisStyle;
    }
    /** @internal */
    get scheduleScript() { return this._scheduleScript; }
    /** @internal */
    getAnimationBranches(scheduleTime) { return this._scheduleScript === undefined ? undefined : this._scheduleScript.getAnimationBranches(scheduleTime); }
    /** Note - do not push or remove members from contextRealityModelsProperty - use add/remove so that the json properties are kept in synch properly.
     * @internal
     */
    get contextRealityModels() { return this._contextRealityModels; }
    /** @internal */
    set contextRealityModels(contextRealityModels) { this._contextRealityModels = contextRealityModels; }
    /** @internal */
    addContextRealityModel(contextRealityModel, iModel) {
        this._contextRealityModels.push(new ContextRealityModelState_1.ContextRealityModelState(contextRealityModel, iModel));
        if (undefined === this.jsonProperties.contextRealityModels)
            this.jsonProperties.contextRealityModels = [];
        this.jsonProperties.contextRealityModels.push(contextRealityModel);
    }
    /** @internal */
    removeContextRealityModel(index) {
        if (index >= this._contextRealityModels.length || !Array.isArray(this.jsonProperties.contextRealityModels) || index >= this.jsonProperties.contextRealityModels.length) {
            bentleyjs_core_1.assert(false);
            return;
        }
        this._contextRealityModels.splice(index, 1);
        this.jsonProperties.contextRealityModels.splice(index, 1);
    }
    /** @internal */
    containsContextRealityModel(contextRealityModel) {
        for (const curr of this._contextRealityModels)
            if (curr.matches(contextRealityModel))
                return true;
        return false;
    }
    /** The ViewFlags associated with this style.
     * @note If this style is associated with a [[ViewState]] attached to a [[Viewport]], use [[ViewState.viewFlags]] to modify the ViewFlags to ensure
     * the changes are promptly visible on the screen.
     */
    get viewFlags() { return this.settings.viewFlags; }
    set viewFlags(flags) { this.settings.viewFlags = flags; }
    /** The background color for this DisplayStyle */
    get backgroundColor() { return this.settings.backgroundColor; }
    set backgroundColor(val) { this.settings.backgroundColor = val; }
    /** The color used to draw geometry in monochrome mode.
     * @see [[ViewFlags.monochrome]] for enabling monochrome mode.
     */
    get monochromeColor() { return this.settings.monochromeColor; }
    set monochromeColor(val) { this.settings.monochromeColor = val; }
    /** @internal */
    get backgroundMapPlane() { return this.viewFlags.backgroundMap ? this.backgroundMap.getPlane() : undefined; }
    /** Returns true if this is a 3d display style. */
    is3d() { return this instanceof DisplayStyle3dState; }
    /** Customize the way geometry belonging to a [[SubCategory]] is drawn by this display style.
     * @param id The ID of the SubCategory whose appearance is to be overridden.
     * @param ovr The overrides to apply to the [[SubCategoryAppearance]].
     * @note If this style is associated with a [[ViewState]] attached to a [[Viewport]], use [[ViewState.overrideSubCategory]] to ensure
     * the changes are promptly visible on the screen.
     * @see [[dropSubCategoryOverride]]
     */
    overrideSubCategory(id, ovr) { this.settings.overrideSubCategory(id, ovr); }
    /** Remove any [[SubCategoryOverride]] applied to a [[SubCategoryAppearance]] by this style.
     * @param id The ID of the [[SubCategory]].
     * @note If this style is associated with a [[ViewState]] attached to a [[Viewport]], use [[ViewState.dropSubCategoryOverride]] to ensure
     * the changes are promptly visible on the screen.
     * @see [[overrideSubCategory]]
     */
    dropSubCategoryOverride(id) { this.settings.dropSubCategoryOverride(id); }
    /** Returns true if an [[SubCategoryOverride]s are defined by this style. */
    get hasSubCategoryOverride() { return this.settings.hasSubCategoryOverride; }
    /** Obtain the overrides applied to a [[SubCategoryAppearance]] by this style.
     * @param id The ID of the [[SubCategory]].
     * @returns The corresponding SubCategoryOverride, or undefined if the SubCategory's appearance is not overridden.
     * @see [[overrideSubCategory]]
     */
    getSubCategoryOverride(id) { return this.settings.getSubCategoryOverride(id); }
}
exports.DisplayStyleState = DisplayStyleState;
/** A display style that can be applied to 2d views.
 * @public
 */
class DisplayStyle2dState extends DisplayStyleState {
    /** @internal */
    static get className() { return "DisplayStyle2d"; }
    get settings() { return this._settings; }
    constructor(props, iModel) {
        super(props, iModel);
        this._settings = new imodeljs_common_1.DisplayStyleSettings(this.jsonProperties);
    }
}
exports.DisplayStyle2dState = DisplayStyle2dState;
/** The SkyBox is part of an [[Environment]] drawn in the background of spatial views to provide context.
 * Several types of skybox are supported:
 *  - A cube with a texture image mapped to each face;
 *  - A sphere with a single texture image mapped to its surface;
 *  - A sphere with a [[Gradient]] mapped to its surface.
 * @public
 */
class SkyBox {
    constructor(sky) {
        /** Whether or not the skybox should be displayed. */
        this.display = false;
        this.display = undefined !== sky && bentleyjs_core_1.JsonUtils.asBool(sky.display, false);
    }
    toJSON() {
        return { display: this.display };
    }
    /** Instantiate a [[SkyBox]] from its JSON representation. */
    static createFromJSON(json) {
        let imageType = imodeljs_common_1.SkyBoxImageType.None;
        if (undefined !== json && undefined !== json.image && undefined !== json.image.type)
            imageType = json.image.type;
        let skybox;
        switch (imageType) {
            case imodeljs_common_1.SkyBoxImageType.Spherical:
                skybox = SkySphere.fromJSON(json);
                break;
            case imodeljs_common_1.SkyBoxImageType.Cube:
                skybox = SkyCube.fromJSON(json);
                break;
            case imodeljs_common_1.SkyBoxImageType.Cylindrical: // ###TODO...
                break;
        }
        return undefined !== skybox ? skybox : new SkyGradient(json);
    }
}
exports.SkyBox = SkyBox;
/** The SkyBox is part of an [[Environment]] drawn in the background of spatial views to provide context.
 * Several types of skybox are supported:
 *  - A cube with a texture image mapped to each face;
 *  - A sphere with a single texture image mapped to its surface;
 *  - A sphere with a [[Gradient]] mapped to its surface.
 * @public
 */
(function (SkyBox) {
    /** Parameters defining a spherical [[SkyBox]].
     * @public
     */
    class SphereParams {
        constructor(texture, rotation) {
            this.texture = texture;
            this.rotation = rotation;
        }
    }
    SkyBox.SphereParams = SphereParams;
    /** Parameters used by the [[RenderSystem]] to instantiate a [[SkyBox]].
     * @public
     */
    class CreateParams {
        constructor(zOffset, gradient, sphere, cube) {
            this.gradient = gradient;
            this.sphere = sphere;
            this.cube = cube;
            this.zOffset = zOffset;
        }
        static createForGradient(gradient, zOffset) { return new CreateParams(zOffset, gradient); }
        static createForSphere(sphere, zOffset) { return new CreateParams(zOffset, undefined, sphere); }
        static createForCube(cube) { return new CreateParams(0.0, undefined, undefined, cube); }
    }
    SkyBox.CreateParams = CreateParams;
})(SkyBox = exports.SkyBox || (exports.SkyBox = {}));
/** A [[SkyBox]] drawn as a sphere with a gradient mapped to its interior surface.
 * @see [[SkyBox.createFromJSON]]
 * @public
 */
class SkyGradient extends SkyBox {
    /** Construct a SkyGradient from its JSON representation. */
    constructor(sky) {
        super(sky);
        /** If true, a 2-color gradient is used (ground & sky colors only), if false a 4-color gradient is used, defaults to false. */
        this.twoColor = false;
        /** Controls speed of gradient change from skyColor to zenithColor (4-color SkyGradient only), defaults to 4.0. */
        this.skyExponent = 4.0;
        /** Controls speed of gradient change from groundColor to nadirColor (4-color SkyGradient only), defaults to 4.0. */
        this.groundExponent = 4.0;
        sky = sky ? sky : {};
        this.twoColor = bentleyjs_core_1.JsonUtils.asBool(sky.twoColor, false);
        this.groundExponent = bentleyjs_core_1.JsonUtils.asDouble(sky.groundExponent, 4.0);
        this.skyExponent = bentleyjs_core_1.JsonUtils.asDouble(sky.skyExponent, 4.0);
        this.groundColor = (undefined !== sky.groundColor) ? imodeljs_common_1.ColorDef.fromJSON(sky.groundColor) : imodeljs_common_1.ColorDef.from(120, 143, 125);
        this.zenithColor = (undefined !== sky.zenithColor) ? imodeljs_common_1.ColorDef.fromJSON(sky.zenithColor) : imodeljs_common_1.ColorDef.from(54, 117, 255);
        this.nadirColor = (undefined !== sky.nadirColor) ? imodeljs_common_1.ColorDef.fromJSON(sky.nadirColor) : imodeljs_common_1.ColorDef.from(40, 15, 0);
        this.skyColor = (undefined !== sky.skyColor) ? imodeljs_common_1.ColorDef.fromJSON(sky.skyColor) : imodeljs_common_1.ColorDef.from(143, 205, 255);
    }
    toJSON() {
        const val = super.toJSON();
        val.twoColor = this.twoColor ? true : undefined;
        val.groundExponent = this.groundExponent !== 4.0 ? this.groundExponent : undefined;
        val.skyExponent = this.skyExponent !== 4.0 ? this.skyExponent : undefined;
        val.groundColor = this.groundColor.toJSON();
        val.zenithColor = this.zenithColor.toJSON();
        val.nadirColor = this.nadirColor.toJSON();
        val.skyColor = this.skyColor.toJSON();
        return val;
    }
    /** @internal */
    loadParams(_system, iModel) {
        return SkyBox.CreateParams.createForGradient(this, iModel.globalOrigin.z);
    }
}
exports.SkyGradient = SkyGradient;
/** A [[SkyBox]] drawn as a sphere with an image mapped to its interior surface.
 * @see [[SkyBox.createFromJSON]]
 * @public
 */
class SkySphere extends SkyBox {
    constructor(textureId, display) {
        super({ display });
        this.textureId = textureId;
    }
    /** Create a [[SkySphere]] from its JSON representation.
     * @param json: The JSON representation
     * @returns A SkySphere, or undefined if the JSON lacks a valid texture Id.
     */
    static fromJSON(json) {
        const textureId = bentleyjs_core_1.Id64.fromJSON(undefined !== json.image ? json.image.texture : undefined);
        return undefined !== textureId && bentleyjs_core_1.Id64.isValid(textureId) ? new SkySphere(textureId, json.display) : undefined;
    }
    toJSON() {
        const val = super.toJSON();
        val.image = {
            type: imodeljs_common_1.SkyBoxImageType.Spherical,
            texture: this.textureId,
        };
        return val;
    }
    /** @internal */
    loadParams(system, iModel) {
        const rotation = 0.0; // ###TODO: from where do we obtain rotation?
        const createParams = (tex) => undefined !== tex ? SkyBox.CreateParams.createForSphere(new SkyBox.SphereParams(tex, rotation), iModel.globalOrigin.z) : undefined;
        const texture = system.findTexture(this.textureId, iModel);
        if (undefined !== texture)
            return createParams(texture);
        else
            return system.loadTexture(this.textureId, iModel).then((tex) => createParams(tex));
    }
}
exports.SkySphere = SkySphere;
/** A [[SkyBox]] drawn as a cube with an image mapped to each of its interior faces.
 * Each member specifies the Id of a persistent texture element stored in the iModel
 * from which the image mapped to the corresponding face is obtained.
 * @see [[SkyBox.createFromJSON]].
 * @public
 */
class SkyCube extends SkyBox {
    constructor(front, back, top, bottom, right, left, display) {
        super({ display });
        this.front = front;
        this.back = back;
        this.top = top;
        this.bottom = bottom;
        this.right = right;
        this.left = left;
    }
    /** Use [[SkyCube.create]].
     * @internal
     */
    static fromJSON(skyboxJson) {
        const image = skyboxJson.image;
        const json = (undefined !== image && image.type === imodeljs_common_1.SkyBoxImageType.Cube ? image.textures : undefined);
        if (undefined === json)
            return undefined;
        return this.create(bentleyjs_core_1.Id64.fromJSON(json.front), bentleyjs_core_1.Id64.fromJSON(json.back), bentleyjs_core_1.Id64.fromJSON(json.top), bentleyjs_core_1.Id64.fromJSON(json.bottom), bentleyjs_core_1.Id64.fromJSON(json.right), bentleyjs_core_1.Id64.fromJSON(json.left), skyboxJson.display);
    }
    toJSON() {
        const val = super.toJSON();
        val.image = {
            type: imodeljs_common_1.SkyBoxImageType.Cube,
            textures: {
                front: this.front,
                back: this.back,
                top: this.top,
                bottom: this.bottom,
                right: this.right,
                left: this.left,
            },
        };
        return val;
    }
    /** Create and return a SkyCube. (Calls the SkyCube constructor after validating the Ids passed in for the images.)
     * @param front The Id of the image to use for the front side of the sky cube.
     * @param back The Id of the image to use for the back side of the sky cube.
     * @param top The Id of the image to use for the top side of the sky cube.
     * @param bottom The Id of the image to use for the bottom side of the sky cube.
     * @param right The Id of the image to use for the right side of the sky cube.
     * @param left The Id of the image to use for the left side of the sky cube.
     * @returns A SkyCube, or undefined if any of the supplied texture Ids are invalid.
     * @note All Ids must refer to a persistent texture element stored in the iModel.
     */
    static create(front, back, top, bottom, right, left, display) {
        if (!bentleyjs_core_1.Id64.isValid(front) || !bentleyjs_core_1.Id64.isValid(back) || !bentleyjs_core_1.Id64.isValid(top) || !bentleyjs_core_1.Id64.isValid(bottom) || !bentleyjs_core_1.Id64.isValid(right) || !bentleyjs_core_1.Id64.isValid(left))
            return undefined;
        else
            return new SkyCube(front, back, top, bottom, right, left, display);
    }
    /** @internal */
    loadParams(system, iModel) {
        // ###TODO: We never cache the actual texture *images* used here to create a single cubemap texture...
        const textureIds = new Set([this.front, this.back, this.top, this.bottom, this.right, this.left]);
        const promises = new Array();
        for (const textureId of textureIds)
            promises.push(system.loadTextureImage(textureId, iModel));
        return Promise.all(promises).then((images) => {
            // ###TODO there's gotta be a simpler way to map the unique images back to their texture Ids...
            const idToImage = new Map();
            let index = 0;
            for (const textureId of textureIds) {
                const image = images[index++];
                if (undefined === image || undefined === image.image)
                    return undefined;
                else
                    idToImage.set(textureId, image.image);
            }
            const params = new imodeljs_common_1.RenderTexture.Params(undefined, 3 /* SkyBox */);
            const textureImages = [
                idToImage.get(this.front), idToImage.get(this.back), idToImage.get(this.top),
                idToImage.get(this.bottom), idToImage.get(this.right), idToImage.get(this.left),
            ];
            const texture = system.createTextureFromCubeImages(textureImages[0], textureImages[1], textureImages[2], textureImages[3], textureImages[4], textureImages[5], iModel, params);
            return undefined !== texture ? SkyBox.CreateParams.createForCube(texture) : undefined;
        }).catch((_err) => {
            return undefined;
        });
    }
}
exports.SkyCube = SkyCube;
/** Describes the [[SkyBox]] and [[GroundPlane]] associated with a [[DisplayStyle3dState]].
 * @public
 */
class Environment {
    /** Construct from JSON representation. */
    constructor(json) {
        this.sky = SkyBox.createFromJSON(undefined !== json ? json.sky : undefined);
        this.ground = new imodeljs_common_1.GroundPlane(undefined !== json ? json.ground : undefined);
    }
    toJSON() {
        return {
            sky: this.sky.toJSON(),
            ground: this.ground.toJSON(),
        };
    }
}
exports.Environment = Environment;
function isSameSkyBox(a, b) {
    if (undefined === a || undefined === b)
        return undefined === a && undefined === b;
    return JSON.stringify(a) === JSON.stringify(b);
}
/** A [[DisplayStyleState]] that can be applied to spatial views.
 * @public
 */
class DisplayStyle3dState extends DisplayStyleState {
    /** @internal */
    static get className() { return "DisplayStyle3d"; }
    /** @internal */
    clone(iModel) {
        const clone = super.clone(iModel);
        if (undefined === iModel || this.iModel === iModel) {
            clone._skyBoxParams = this._skyBoxParams;
            clone._skyBoxParamsLoaded = this._skyBoxParamsLoaded;
        }
        return clone;
    }
    get settings() { return this._settings; }
    constructor(props, iModel) {
        super(props, iModel);
        this._settings = new imodeljs_common_1.DisplayStyle3dSettings(this.jsonProperties);
        const styles = this.jsonProperties.styles;
        if (styles.sceneLights && styles.sceneLights.sunDir)
            this._sunDirection = geometry_core_1.Vector3d.fromJSON(styles.sceneLights.sunDir);
    }
    /** The [[SkyBox]] and [[GroundPlane]] settings for this style. */
    get environment() {
        if (undefined === this._environment)
            this._environment = new Environment(this.settings.environment);
        return this._environment;
    }
    set environment(env) {
        const prevEnv = this.settings.environment;
        this.settings.environment = env.toJSON();
        this._environment = undefined;
        // Regenerate the skybox if the sky settings have changed
        if (undefined !== this._skyBoxParamsLoaded && !isSameSkyBox(env.sky, prevEnv.sky)) {
            // NB: We only reset _skyBoxParamsLoaded - keep the previous skybox (if any) to continue drawing until the new one (if any) is ready
            this._skyBoxParamsLoaded = undefined;
        }
    }
    onLoadSkyBoxParams(params, vp) {
        this._skyBoxParams = params;
        this._skyBoxParamsLoaded = true;
        if (undefined !== vp)
            vp.invalidateDecorations();
    }
    /** Attempts to create textures for the sky of the environment, and load it into the sky. Returns true on success, and false otherwise.
     * @internal
     */
    loadSkyBoxParams(system, vp) {
        if (undefined === this._skyBoxParamsLoaded) {
            const params = this.environment.sky.loadParams(system, this.iModel);
            if (undefined === params || params instanceof SkyBox.CreateParams) {
                this.onLoadSkyBoxParams(params, vp);
            }
            else {
                this._skyBoxParamsLoaded = false; // indicates we're currently loading them.
                params.then((result) => this.onLoadSkyBoxParams(result, vp)).catch((_err) => this.onLoadSkyBoxParams(undefined));
            }
        }
        return this._skyBoxParams;
    }
    /** @beta */
    get sunDirection() { return this._sunDirection; }
    /** set the solar direction based on time value
     * @param time The time in unix time milliseconds.
     * @beta
     */
    setSunTime(time) {
        let cartoCenter;
        if (this.iModel.isGeoLocated) {
            const projectExtents = this.iModel.projectExtents;
            const projectCenter = geometry_core_1.Point3d.createAdd2Scaled(projectExtents.low, .5, projectExtents.high, .5);
            cartoCenter = this.iModel.spatialToCartographicFromEcef(projectCenter);
        }
        else {
            cartoCenter = imodeljs_common_1.Cartographic.fromDegrees(-75.17035, 39.954927, 0.0);
        }
        this._sunDirection = SolarCalculate_1.calculateSolarDirection(new Date(time), cartoCenter);
    }
}
exports.DisplayStyle3dState = DisplayStyle3dState;


/***/ }),

/***/ "./lib/ElementLocateManager.js":
/*!*************************************!*\
  !*** ./lib/ElementLocateManager.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module LocatingElements */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const HitDetail_1 = __webpack_require__(/*! ./HitDetail */ "./lib/HitDetail.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const Tool_1 = __webpack_require__(/*! ./tools/Tool */ "./lib/tools/Tool.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/Viewport.js");
/** The possible actions for which a locate filter can be called.
 * @public
 */
var LocateAction;
(function (LocateAction) {
    LocateAction[LocateAction["Identify"] = 0] = "Identify";
    LocateAction[LocateAction["AutoLocate"] = 1] = "AutoLocate";
})(LocateAction = exports.LocateAction || (exports.LocateAction = {}));
/** Values to return from a locate filter.
 * Return `Reject` to indicate the element is unacceptable.
 * @public
 */
var LocateFilterStatus;
(function (LocateFilterStatus) {
    LocateFilterStatus[LocateFilterStatus["Accept"] = 0] = "Accept";
    LocateFilterStatus[LocateFilterStatus["Reject"] = 1] = "Reject";
})(LocateFilterStatus = exports.LocateFilterStatus || (exports.LocateFilterStatus = {}));
/** @public */
var SnapStatus;
(function (SnapStatus) {
    SnapStatus[SnapStatus["Success"] = 0] = "Success";
    SnapStatus[SnapStatus["Aborted"] = 1] = "Aborted";
    SnapStatus[SnapStatus["NoElements"] = 2] = "NoElements";
    SnapStatus[SnapStatus["Disabled"] = 100] = "Disabled";
    SnapStatus[SnapStatus["NoSnapPossible"] = 200] = "NoSnapPossible";
    SnapStatus[SnapStatus["NotSnappable"] = 300] = "NotSnappable";
    SnapStatus[SnapStatus["FilteredByApp"] = 600] = "FilteredByApp";
    SnapStatus[SnapStatus["FilteredByAppQuietly"] = 700] = "FilteredByAppQuietly";
})(SnapStatus = exports.SnapStatus || (exports.SnapStatus = {}));
/** Options that customize the way element location (i.e. *picking*) works.
 * @public
 */
class LocateOptions {
    constructor() {
        /** If true, also test graphics from view decorations. */
        this.allowDecorations = false;
        /** If true, also test graphics with non-locatable flag set. */
        this.allowNonLocatable = false;
        /** Maximum number of hits to return. */
        this.maxHits = 20;
        /** The [[HitSource]] identifying the caller. */
        this.hitSource = HitDetail_1.HitSource.DataPoint;
    }
    /** Make a copy of this LocateOptions. */
    clone() {
        const other = new LocateOptions();
        other.allowDecorations = this.allowDecorations;
        other.allowNonLocatable = this.allowNonLocatable;
        other.maxHits = this.maxHits;
        other.hitSource = this.hitSource;
        return other;
    }
    setFrom(other) {
        this.allowDecorations = other.allowDecorations;
        this.allowNonLocatable = other.allowNonLocatable;
        this.maxHits = other.maxHits;
        this.hitSource = other.hitSource;
    }
    init() { this.allowDecorations = this.allowNonLocatable = false; this.maxHits = 20; this.hitSource = HitDetail_1.HitSource.DataPoint; }
}
exports.LocateOptions = LocateOptions;
/** @public */
class LocateResponse {
    constructor() {
        this.snapStatus = SnapStatus.Success;
        this.explanation = "";
    }
}
exports.LocateResponse = LocateResponse;
/** @public */
class ElementPicker {
    constructor() {
        this.pickPointWorld = new geometry_core_1.Point3d();
    }
    empty() {
        this.pickPointWorld.setZero();
        this.viewport = undefined;
        if (this.hitList)
            this.hitList.empty();
        else
            this.hitList = new HitDetail_1.HitList();
    }
    /** return the HitList for the last Pick performed. Optionally allows the caller to take ownership of the list. */
    getHitList(takeOwnership) {
        const list = this.hitList;
        if (takeOwnership)
            this.hitList = undefined;
        return list;
    }
    getNextHit() { return this.hitList ? this.hitList.getNextHit() : undefined; }
    /** Return a hit from the list of hits created the last time pickElements was called. */
    getHit(i) { return this.hitList ? this.hitList.getHit(i) : undefined; }
    resetCurrentHit() { if (this.hitList)
        this.hitList.resetCurrentHit(); }
    getPixelPriority(pixel) {
        switch (pixel.type) {
            case 2 /* Surface */:
                return 2 /* Planar */ === pixel.planarity ? HitDetail_1.HitPriority.PlanarSurface : HitDetail_1.HitPriority.NonPlanarSurface;
            case 3 /* Linear */:
                return HitDetail_1.HitPriority.WireEdge;
            case 4 /* Edge */:
                return 2 /* Planar */ === pixel.planarity ? HitDetail_1.HitPriority.PlanarEdge : HitDetail_1.HitPriority.NonPlanarEdge;
            case 5 /* Silhouette */:
                return HitDetail_1.HitPriority.SilhouetteEdge;
            default:
                return HitDetail_1.HitPriority.Unknown;
        }
    }
    comparePixel(pixel1, pixel2, distXY1, distXY2) {
        const priority1 = this.getPixelPriority(pixel1);
        const priority2 = this.getPixelPriority(pixel2);
        if (priority1 < priority2)
            return -1;
        if (priority1 > priority2)
            return 1;
        if (distXY1 < distXY2)
            return -1;
        if (distXY1 > distXY2)
            return 1;
        if (pixel1.distanceFraction > pixel2.distanceFraction)
            return -1;
        if (pixel1.distanceFraction < pixel2.distanceFraction)
            return 1;
        return 0;
    }
    /** Generate a list of elements that are close to a given point.
     * @returns The number of hits in the hitList of this object.
     */
    doPick(vp, pickPointWorld, pickRadiusView, options) {
        if (this.hitList && this.hitList.length > 0 && vp === this.viewport && pickPointWorld.isAlmostEqual(this.pickPointWorld)) {
            this.hitList.resetCurrentHit();
            return this.hitList.length;
        }
        this.empty(); // empty the hit list
        this.viewport = vp;
        this.pickPointWorld.setFrom(pickPointWorld);
        const pickPointView = vp.worldToView(pickPointWorld);
        const testPointView = new geometry_core_1.Point2d(Math.floor(pickPointView.x + 0.5), Math.floor(pickPointView.y + 0.5));
        const pixelRadius = Math.floor(pickRadiusView + 0.5);
        const rect = new Viewport_1.ViewRect(testPointView.x - pixelRadius, testPointView.y - pixelRadius, testPointView.x + pixelRadius, testPointView.y + pixelRadius);
        let result = 0;
        vp.readPixels(rect, 5 /* All */, (pixels) => {
            if (undefined === pixels)
                return;
            const elmHits = new Map();
            const testPoint = geometry_core_1.Point2d.createZero();
            for (testPoint.x = testPointView.x - pixelRadius; testPoint.x <= testPointView.x + pixelRadius; ++testPoint.x) {
                for (testPoint.y = testPointView.y - pixelRadius; testPoint.y <= testPointView.y + pixelRadius; ++testPoint.y) {
                    const pixel = pixels.getPixel(testPoint.x, testPoint.y);
                    if (undefined === pixel || undefined === pixel.elementId || bentleyjs_core_1.Id64.isInvalid(pixel.elementId))
                        continue; // no geometry at this location...
                    const distXY = testPointView.distance(testPoint);
                    if (distXY > pixelRadius)
                        continue; // ignore corners. it's a locate circle not square...
                    const oldPoint = elmHits.get(pixel.elementId);
                    if (undefined !== oldPoint) {
                        if (this.comparePixel(pixel, pixels.getPixel(oldPoint.x, oldPoint.y), distXY, testPointView.distance(oldPoint)) < 0)
                            oldPoint.setFrom(testPoint); // new hit is better, update location...
                    }
                    else {
                        elmHits.set(pixel.elementId, testPoint.clone());
                    }
                }
            }
            if (0 === elmHits.size)
                return;
            for (const elmPoint of elmHits.values()) {
                const pixel = pixels.getPixel(elmPoint.x, elmPoint.y);
                if (undefined === pixel || undefined === pixel.elementId)
                    continue;
                const hitPointWorld = vp.getPixelDataWorldPoint(pixels, elmPoint.x, elmPoint.y);
                if (undefined === hitPointWorld)
                    continue;
                const hit = new HitDetail_1.HitDetail(pickPointWorld, vp, options.hitSource, hitPointWorld, pixel.elementId, this.getPixelPriority(pixel), testPointView.distance(elmPoint), pixel.distanceFraction, pixel.subCategoryId, pixel.geometryClass);
                this.hitList.addHit(hit);
                if (this.hitList.hits.length > options.maxHits)
                    this.hitList.hits.length = options.maxHits; // truncate array...
            }
            result = this.hitList.length;
        }, !options.allowNonLocatable);
        return result;
    }
    testHit(hit, vp, pickPointWorld, pickRadiusView, options) {
        if (0 === this.doPick(vp, pickPointWorld, pickRadiusView, options))
            return false;
        return this.hitList.hits.some((thisHit) => hit.isSameHit(thisHit));
    }
}
exports.ElementPicker = ElementPicker;
/** @public */
class ElementLocateManager {
    constructor() {
        this.options = new LocateOptions();
        this.picker = new ElementPicker();
    }
    /** get the full message key for a locate failure  */
    static getFailureMessageKey(key) { return "LocateFailure." + key; }
    onInitialized() { }
    get apertureInches() { return 0.11; }
    get touchApertureInches() { return 0.22; }
    clear() { this.setCurrHit(undefined); }
    setHitList(list) { this.hitList = list; }
    setCurrHit(hit) { this.currHit = hit; }
    getNextHit() { return this.hitList ? this.hitList.getNextHit() : undefined; }
    /** return the current path from either the snapping logic or the pre-locating systems. */
    getPreLocatedHit() {
        // NOTE: Check AccuSnap first as Tentative is used to build intersect snap. For normal snaps when a Tentative is active there should be no AccuSnap.
        let preLocated = IModelApp_1.IModelApp.accuSnap.getHitAndList(this);
        if (!preLocated && !!(preLocated = IModelApp_1.IModelApp.tentativePoint.getHitAndList(this))) {
            const vp = preLocated.viewport;
            this.picker.empty(); // Get new hit list at hit point; want reset to cycle hits using adjusted point location...
            this.picker.doPick(vp, preLocated.getPoint(), (vp.pixelsFromInches(this.apertureInches) / 2.0) + 1.5, this.options);
            this.setHitList(this.picker.getHitList(true));
        }
        if (this.hitList)
            this.hitList.resetCurrentHit();
        return preLocated;
    }
    async filterHit(hit, _action, out) {
        // Tools must opt-in to locate of transient geometry as it requires special treatment.
        if (!this.options.allowDecorations && !hit.isElementHit) {
            out.reason = ElementLocateManager.getFailureMessageKey("Transient");
            return LocateFilterStatus.Reject;
        }
        if (undefined !== hit.subCategoryId) {
            const appearance = hit.viewport.getSubCategoryAppearance(hit.subCategoryId);
            if (appearance.dontLocate) {
                out.reason = ElementLocateManager.getFailureMessageKey("NotLocatable");
                return LocateFilterStatus.Reject;
            }
        }
        const tool = IModelApp_1.IModelApp.toolAdmin.activeTool;
        if (!(tool && tool instanceof Tool_1.InteractiveTool))
            return LocateFilterStatus.Accept;
        const status = await tool.filterHit(hit, out);
        if (LocateFilterStatus.Reject === status)
            out.reason = ElementLocateManager.getFailureMessageKey("ByApp");
        return status;
    }
    initLocateOptions() { this.options.init(); }
    initToolLocate() {
        this.initLocateOptions();
        this.clear();
        this.picker.empty();
        IModelApp_1.IModelApp.tentativePoint.clear(true);
    }
    async _doLocate(response, newSearch, testPoint, vp, source, filterHits) {
        if (!vp)
            return;
        // the "newSearch" flag indicates whether the caller wants us to conduct a new search at the testPoint, or just continue returning paths from the previous search.
        if (newSearch) {
            const hit = this.getPreLocatedHit();
            // if we're snapped to something, that path has the highest priority and becomes the active hit.
            if (hit) {
                if (!filterHits || LocateFilterStatus.Accept === await this.filterHit(hit, LocateAction.Identify, response))
                    return hit;
                response = new LocateResponse(); // we have the reason and explanation we want.
            }
            this.picker.empty();
            this.picker.doPick(vp, testPoint, (vp.pixelsFromInches(Tool_1.InputSource.Touch === source ? this.touchApertureInches : this.apertureInches) / 2.0) + 1.5, this.options);
            const hitList = this.picker.getHitList(true);
            this.setHitList(hitList);
        }
        let newHit;
        while (undefined !== (newHit = this.getNextHit())) {
            if (!filterHits || LocateFilterStatus.Accept === await this.filterHit(newHit, LocateAction.Identify, response))
                return newHit;
            response = new LocateResponse(); // we have the reason and explanation we want.
        }
        return undefined;
    }
    async doLocate(response, newSearch, testPoint, view, source, filterHits = true) {
        response.reason = ElementLocateManager.getFailureMessageKey("NoElements");
        response.explanation = "";
        const hit = await this._doLocate(response, newSearch, testPoint, view, source, filterHits);
        this.setCurrHit(hit);
        // if we found a hit, remove it from the list of remaining hits near the current search point.
        if (hit && this.hitList)
            this.hitList.removeHitsFrom(hit.sourceId);
        return hit;
    }
}
exports.ElementLocateManager = ElementLocateManager;


/***/ }),

/***/ "./lib/EmphasizeElements.js":
/*!**********************************!*\
  !*** ./lib/EmphasizeElements.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const rendering_1 = __webpack_require__(/*! ./rendering */ "./lib/rendering.js");
/** Whether override includes both color and alpha, only color, or only alpha.
 * @internal
 */
var FeatureOverrideType;
(function (FeatureOverrideType) {
    FeatureOverrideType[FeatureOverrideType["ColorOnly"] = 0] = "ColorOnly";
    FeatureOverrideType[FeatureOverrideType["AlphaOnly"] = 1] = "AlphaOnly";
    FeatureOverrideType[FeatureOverrideType["ColorAndAlpha"] = 2] = "ColorAndAlpha";
})(FeatureOverrideType = exports.FeatureOverrideType || (exports.FeatureOverrideType = {}));
/** An implementation of [[FeatureOverrideProvider]] for emphasizing selected elements through simple color/transparency appearance overrides.
 * @internal
 */
class EmphasizeElements {
    /** Establish active feature overrides to emphasize elements and apply color/transparency overrides.
     * @see [[Viewport.featureOverrideProvider]]
     */
    addFeatureOverrides(overrides, vp) {
        const emphasizedElements = this.getEmphasizedElements(vp);
        if (undefined !== emphasizedElements) {
            overrides.setDefaultOverrides(this._defaultAppearance);
            const app = rendering_1.FeatureSymbology.Appearance.defaults;
            emphasizedElements.forEach((id) => { overrides.overrideElement(id, app); });
        }
        const overriddenElements = this.getOverriddenElements();
        if (undefined !== overriddenElements) {
            if (undefined !== this._defaultAppearance)
                overrides.setDefaultOverrides(this._defaultAppearance);
            for (const [key, ids] of overriddenElements) {
                const ovrApp = this.createAppearanceFromKey(key);
                ids.forEach((id) => { overrides.overrideElement(id, ovrApp); });
            }
        }
    }
    /** @internal */
    createAppearanceFromKey(key) {
        if (key < 0)
            return rendering_1.FeatureSymbology.Appearance.fromTransparency(Math.abs(key));
        const color = imodeljs_common_1.ColorDef.fromJSON(key);
        if (0 === color.getAlpha())
            return rendering_1.FeatureSymbology.Appearance.fromRgb(color); // Fully transparent signifies to use color only...
        return rendering_1.FeatureSymbology.Appearance.fromRgba(color);
    }
    /** Get override key from color and override type */
    createOverrideKey(color, override) {
        const colorValues = color.colors;
        switch (override) {
            case FeatureOverrideType.ColorAndAlpha:
                return 255 === colorValues.t ? undefined : color.tbgr; // Hiding elements should be done using neverDrawn, not transparency...
            case FeatureOverrideType.ColorOnly:
                return imodeljs_common_1.ColorDef.from(colorValues.r, colorValues.g, colorValues.b, 255).tbgr;
            case FeatureOverrideType.AlphaOnly:
                return -(colorValues.t / 255);
        }
    }
    /** Get color and override type for the given key. */
    getOverrideFromKey(key, color) {
        if (key < 0) {
            color.setFrom(imodeljs_common_1.ColorDef.from(0, 0, 0, 255 * Math.abs(key)));
            return FeatureOverrideType.AlphaOnly;
        }
        color.setFrom(imodeljs_common_1.ColorDef.fromJSON(key));
        if (0 === color.getAlpha()) {
            color.setAlpha(255);
            return FeatureOverrideType.ColorOnly;
        }
        return FeatureOverrideType.ColorAndAlpha;
    }
    /** Get the current default appearance such as used by emphasizeElements. */
    get defaultAppearance() { return this._defaultAppearance; }
    /** Set the current default appearance for use with overrideElements when not using emphasizeElements. */
    set defaultAppearance(appearance) { this._defaultAppearance = appearance; }
    /** Create default appearance to use for emphasizeElements when not supplied by caller. */
    createDefaultAppearance() {
        return rendering_1.FeatureSymbology.Appearance.fromJSON({
            rgb: new imodeljs_common_1.RgbColor(0xe4, 0xe4, 0xe4),
            transparency: 0.8,
            nonLocatable: true,
        });
    }
    /** Get the IDs of the currently never drawn elements. */
    getNeverDrawnElements(vp) { return (undefined !== vp.neverDrawn && 0 !== vp.neverDrawn.size ? vp.neverDrawn : undefined); }
    /** Get the IDs of the currently always drawn elements. */
    getAlwaysDrawnElements(vp) { return (undefined !== vp.alwaysDrawn && 0 !== vp.alwaysDrawn.size ? vp.alwaysDrawn : undefined); }
    /** Get the IDs of the currently hidden elements. */
    getHiddenElements(vp) { return this.getNeverDrawnElements(vp); }
    /** Get the IDs of the currently isolated elements. */
    getIsolatedElements(vp) { return (vp.isAlwaysDrawnExclusive ? this.getAlwaysDrawnElements(vp) : undefined); }
    /** Get the IDs of the currently emphasized isolated elements. */
    getEmphasizedIsolatedElements() { return (undefined !== this._defaultAppearance && undefined !== this._emphasizeIsolated && 0 !== this._emphasizeIsolated.size ? this._emphasizeIsolated : undefined); }
    /** Get the IDs of the currently emphasized elements. */
    getEmphasizedElements(vp) { return (undefined !== this.getEmphasizedIsolatedElements() ? this._emphasizeIsolated : (undefined !== this._defaultAppearance && !vp.isAlwaysDrawnExclusive ? this.getAlwaysDrawnElements(vp) : undefined)); }
    /** Get the map of current elements with color/transparency overrides. */
    getOverriddenElements() { return (undefined !== this._overrideAppearance && 0 !== this._overrideAppearance.size ? this._overrideAppearance : undefined); }
    /** Get the IDs of current elements with the specified color/transparency override. */
    getOverriddenElementsByKey(key) { return (undefined !== this._overrideAppearance ? this._overrideAppearance.get(key) : undefined); }
    /** Clear never drawn elements.
     * @return false if nothing to clear.
     */
    clearNeverDrawnElements(vp) {
        if (undefined === this.getNeverDrawnElements(vp))
            return false;
        vp.clearNeverDrawn();
        return true;
    }
    /** Clear always drawn elements.
     * @return false if nothing to clear.
     */
    clearAlwaysDrawnElements(vp) {
        if (undefined === this.getAlwaysDrawnElements(vp))
            return false;
        vp.clearAlwaysDrawn();
        return true;
    }
    /** Clear hidden elements.
     * @return false if nothing to clear.
     */
    clearHiddenElements(vp) {
        return this.clearNeverDrawnElements(vp);
    }
    /** Clear isolated elements.
     * @return false if nothing to clear.
     */
    clearIsolatedElements(vp) {
        if (undefined === this.getIsolatedElements(vp))
            return false;
        if (this.clearEmphasizedIsolatedElements(vp, true))
            return true;
        return this.clearAlwaysDrawnElements(vp);
    }
    /** Clear emphasized elements.
     * @return false if nothing to clear.
     */
    clearEmphasizedElements(vp) {
        if (undefined === this.getEmphasizedElements(vp))
            return false;
        if (this.clearEmphasizedIsolatedElements(vp, false))
            return true;
        if (!this.clearAlwaysDrawnElements(vp))
            return false;
        this._defaultAppearance = undefined;
        return true;
    }
    /** Clear emphasized isolated elements.
     * @return false if nothing to clear.
     */
    clearEmphasizedIsolatedElements(vp, setToAlwaysDrawn) {
        const emphasizedIsolated = this.getEmphasizedIsolatedElements();
        this._emphasizeIsolated = undefined; // Always clear in case default appearance was unset...
        if (undefined === emphasizedIsolated)
            return false;
        if (setToAlwaysDrawn && this.setAlwaysDrawnElements(emphasizedIsolated, vp, false))
            return true;
        this._defaultAppearance = undefined;
        vp.setFeatureOverrideProviderChanged();
        return true;
    }
    /** Clear elements with color/transparency overrides. Specify key to clear only a single override.
     * @return false if nothing to clear.
     */
    clearOverriddenElements(vp, key) {
        if (undefined === this._overrideAppearance)
            return false;
        if (undefined !== key) {
            if (!this._overrideAppearance.delete(key))
                return false;
        }
        else {
            this._overrideAppearance = undefined;
        }
        vp.setFeatureOverrideProviderChanged();
        return true;
    }
    /** @internal */
    updateIdSet(ids, replace, existingIds) {
        const newIds = new Set();
        bentleyjs_core_1.Id64.toIdSet(ids).forEach((id) => { newIds.add(id); });
        if (0 === newIds.size)
            return undefined;
        const oldSize = (!replace && undefined !== existingIds ? existingIds.size : 0);
        if (0 !== oldSize && undefined !== existingIds)
            for (const id of existingIds)
                newIds.add(id);
        if (oldSize === newIds.size)
            return undefined;
        return newIds;
    }
    /** Set the element IDs to be never drawn.
     * @param ids The IDs of the elements to never draw.
     * @param vp The viewport.
     * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.
     * @return true if overrides were changed.
     * @see [[Viewport.neverDrawn]]
     * @internal
     */
    setNeverDrawnElements(ids, vp, replace = true) {
        const hiddenIds = this.updateIdSet(ids, replace, vp.neverDrawn);
        if (undefined === hiddenIds)
            return false;
        vp.setNeverDrawn(hiddenIds);
        return true;
    }
    /** Set the element IDs to be always drawn.
     * @param ids The IDs of the elements to always draw.
     * @param vp The viewport.
     * @param exclusive If true, *only* the specified elements will be drawn.
     * @param replace true to replace currently always drawn elements (if any) or false to add to the existing set.
     * @return true if overrides were changed.
     * @see [[Viewport.alwaysDrawn]]
     * @see [[Viewport.isAlwaysDrawnExclusive]]
     * @internal
     */
    setAlwaysDrawnElements(ids, vp, exclusive = true, replace = true) {
        const visibleIds = this.updateIdSet(ids, replace, vp.alwaysDrawn);
        if (undefined === visibleIds)
            return false;
        vp.setAlwaysDrawn(visibleIds, exclusive);
        return true;
    }
    /** Set the element IDs to be never drawn.
     * @param ids The IDs of the elements to never draw.
     * @param vp The viewport.
     * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.
     * @return true if overrides were changed.
     * @see [[Viewport.neverDrawn]]
     */
    hideElements(ids, vp, replace = false) {
        return this.setNeverDrawnElements(ids, vp, replace);
    }
    /** Set the currently selected elements to be never drawn.
     * @param vp The viewport.
     * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.
     * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.
     * @return true if overrides were changed.
     * @see [[Viewport.neverDrawn]]
     */
    hideSelectedElements(vp, replace = false, clearSelection = true) {
        const selection = vp.view.iModel.selectionSet;
        if (!selection.isActive || !this.hideElements(selection.elements, vp, replace))
            return false;
        if (clearSelection)
            selection.emptyAll();
        return true;
    }
    /** Set the element IDs to be always drawn exclusively.
     * @param ids The IDs of the elements to always draw.
     * @param vp The viewport.
     * @param replace true to replace currently isolated elements (if any) or false to add to the existing set.
     * @return true if overrides were changed.
     * @see [[Viewport.alwaysDrawn]]
     * @see [[Viewport.isAlwaysDrawnExclusive]]
     */
    isolateElements(ids, vp, replace = true) {
        const wasEmphasized = (undefined !== this.getEmphasizedElements(vp));
        if (!this.setAlwaysDrawnElements(ids, vp, true, replace))
            return false;
        if (wasEmphasized)
            this._defaultAppearance = this._emphasizeIsolated = undefined; // Don't clear defaultAppearance unless it was established by emphasize...
        return true;
    }
    /** Set the currently selected elements to be always drawn exclusively.
     * @param vp The viewport.
     * @param replace true to replace currently isolated elements (if any) or false to add to the existing set.
     * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.
     * @return true if overrides were changed.
     * @see [[Viewport.alwaysDrawn]]
     * @see [[Viewport.isAlwaysDrawnExclusive]]
     */
    isolateSelectedElements(vp, replace = true, clearSelection = true) {
        const selection = vp.view.iModel.selectionSet;
        if (!selection.isActive || !this.isolateElements(selection.elements, vp, replace))
            return false;
        if (clearSelection)
            selection.emptyAll();
        return true;
    }
    /** Set the element IDs to be always drawn normally with all other elements in the view overridden to draw using a default appearance..
     * @param ids The IDs of the elements to always draw.
     * @param vp The viewport.
     * @param defaultAppearance Optional default appearance, uses non-locatable transparent grey if not specified.
     * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.
     * @return true if overrides were changed.
     * @see [[Viewport.alwaysDrawn]]
     * @see [[Viewport.isAlwaysDrawnExclusive]]
     */
    emphasizeElements(ids, vp, defaultAppearance, replace = true) {
        if (undefined !== this.getIsolatedElements(vp)) {
            const emphasizeIds = this.updateIdSet(ids, replace, this._emphasizeIsolated);
            if (undefined === emphasizeIds)
                return false;
            this._emphasizeIsolated = emphasizeIds;
            vp.setFeatureOverrideProviderChanged();
        }
        else {
            if (!this.setAlwaysDrawnElements(ids, vp, false, replace))
                return false;
            this._emphasizeIsolated = undefined;
        }
        this._defaultAppearance = (undefined === defaultAppearance ? this.createDefaultAppearance() : defaultAppearance);
        return true;
    }
    /** Set the currently selected elements to be always drawn normally with all other elements in the view overridden to draw using a default appearance.
     * @param vp The viewport.
     * @param defaultAppearance Optional default appearance, uses transparent grey if not specified.
     * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.
     * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.
     * @return true if overrides were changed.
     * @see [[Viewport.alwaysDrawn]]
     * @see [[Viewport.isAlwaysDrawnExclusive]]
     */
    emphasizeSelectedElements(vp, defaultAppearance, replace = true, clearSelection = true) {
        const selection = vp.view.iModel.selectionSet;
        if (!selection.isActive || !this.emphasizeElements(selection.elements, vp, defaultAppearance, replace))
            return false;
        if (clearSelection)
            selection.emptyAll();
        return true;
    }
    /** Set the element IDs to display with a color/transparency override.
     * @param ids The IDs of the elements.
     * @param vp The viewport.
     * @param color ColorDef to specify override rgb and alpha.
     * @param override Whether to use color and alpha, only color, or only alpha from the supplied ColorDef.
     * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.
     * @return true if overrides were changed.
     * @see [[Viewport.featureOverrideProvider]]
     */
    overrideElements(ids, vp, color, override = FeatureOverrideType.ColorOnly, replace = false) {
        const ovrKey = this.createOverrideKey(color, override);
        if (undefined === ovrKey)
            return false;
        const overrideIds = new Set();
        bentleyjs_core_1.Id64.toIdSet(ids).forEach((id) => { overrideIds.add(id); });
        if (0 === overrideIds.size)
            return false;
        const existingIds = (!replace ? this.getOverriddenElementsByKey(ovrKey) : undefined);
        const oldSize = (undefined !== existingIds ? existingIds.size : 0);
        if (0 !== oldSize && undefined !== existingIds)
            for (const id of existingIds)
                overrideIds.add(id);
        if (oldSize === overrideIds.size)
            return false;
        if (undefined === this._overrideAppearance) {
            this._overrideAppearance = new Map();
        }
        else {
            for (const [key, otherIds] of this._overrideAppearance) {
                if (key === ovrKey) // Make sure these ids are unique to this color/transparency key...
                    continue;
                bentleyjs_core_1.Id64.toIdSet(ids).forEach((id) => { otherIds.delete(id); });
                if (0 !== otherIds.size)
                    continue;
                this._overrideAppearance.delete(key);
            }
        }
        this._overrideAppearance.set(ovrKey, overrideIds);
        vp.setFeatureOverrideProviderChanged();
        return true;
    }
    /** Set the currently selected elements to display with a color/transparency override.
     * @param vp The viewport.
     * @param color ColorDef to specify override rgb and alpha.
     * @param override Whether to use color and alpha, only color, or only alpha from the supplied ColorDef.
     * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.
     * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.
     * @return true if overrides were changed.
     * @see [[Viewport.featureOverrideProvider]]
     */
    overrideSelectedElements(vp, color, override = FeatureOverrideType.ColorOnly, replace = false, clearSelection = true) {
        const selection = vp.view.iModel.selectionSet;
        if (!selection.isActive || !this.overrideElements(selection.elements, vp, color, override, replace))
            return false;
        if (clearSelection)
            selection.emptyAll();
        return true;
    }
    /** @return true if provider is currently overriding the display of any elements. */
    isActive(vp) { return (undefined !== this.getNeverDrawnElements(vp) || undefined !== this.getAlwaysDrawnElements(vp) || undefined !== this.getOverriddenElements()); }
    toJSON(vp) {
        const props = {};
        const neverDrawn = this.getNeverDrawnElements(vp);
        if (undefined !== neverDrawn)
            props.neverDrawn = new Set(neverDrawn);
        const alwaysDrawn = this.getAlwaysDrawnElements(vp);
        if (undefined !== alwaysDrawn)
            props.alwaysDrawn = new Set(alwaysDrawn);
        if (vp.isAlwaysDrawnExclusive)
            props.isAlwaysDrawnExclusive = true; // isolate
        const alwaysDrawnExclusiveEmphasized = this.getEmphasizedIsolatedElements();
        if (undefined !== alwaysDrawnExclusiveEmphasized)
            props.alwaysDrawnExclusiveEmphasized = new Set(alwaysDrawnExclusiveEmphasized);
        if (undefined !== this.defaultAppearance)
            props.defaultAppearance = this.defaultAppearance; // emphasize (or specifically set for override)
        const overriddenElements = this.getOverriddenElements();
        if (undefined !== overriddenElements) {
            const appearanceOverride = [];
            const color = new imodeljs_common_1.ColorDef();
            for (const [key, ovrIds] of overriddenElements) {
                const overrideType = this.getOverrideFromKey(key, color);
                const ids = new Set(ovrIds);
                appearanceOverride.push({ overrideType, color, ids });
            }
            props.appearanceOverride = appearanceOverride;
        }
        return props;
    }
    fromJSON(props, vp) {
        let changed = false;
        if (undefined !== props.neverDrawn && this.setNeverDrawnElements(props.neverDrawn, vp, true))
            changed = true;
        if (undefined !== props.alwaysDrawn && this.setAlwaysDrawnElements(props.alwaysDrawn, vp, undefined !== props.isAlwaysDrawnExclusive && props.isAlwaysDrawnExclusive))
            changed = true;
        if (undefined !== props.alwaysDrawnExclusiveEmphasized)
            this._emphasizeIsolated = props.alwaysDrawnExclusiveEmphasized; // changed status determined by setAlwaysDrawnElements...
        if (undefined !== props.defaultAppearance)
            this.defaultAppearance = rendering_1.FeatureSymbology.Appearance.fromJSON(props.defaultAppearance); // changed status determined by setAlwaysDrawnElements or overrideElements...
        if (undefined !== props.appearanceOverride) {
            for (const ovrApp of props.appearanceOverride) {
                if (undefined === ovrApp.ids)
                    continue;
                if (this.overrideElements(ovrApp.ids, vp, imodeljs_common_1.ColorDef.fromJSON(ovrApp.color), ovrApp.overrideType, true))
                    changed = true;
            }
        }
        return changed;
    }
    /** Get current [[Viewport.featureOverrideProvider]] if it's an instance of EmphasizeElements. */
    static get(vp) {
        return (vp.featureOverrideProvider instanceof EmphasizeElements ? vp.featureOverrideProvider : undefined);
    }
    /** Get or replace current [[Viewport.featureOverrideProvider]] with an instance of EmphasizeElements. */
    static getOrCreate(vp) {
        let provider = vp.featureOverrideProvider instanceof EmphasizeElements ? vp.featureOverrideProvider : undefined;
        if (undefined === provider) {
            provider = new EmphasizeElements();
            vp.featureOverrideProvider = provider;
        }
        return provider;
    }
    /** Clear current [[Viewport.featureOverrideProvider]] if it's an instance of EmphasizeElements. */
    static clear(vp, inactiveOnly = false) {
        const provider = vp.featureOverrideProvider instanceof EmphasizeElements ? vp.featureOverrideProvider : undefined;
        if (undefined === provider || (inactiveOnly && provider.isActive))
            return;
        vp.clearNeverDrawn();
        vp.clearAlwaysDrawn();
        vp.featureOverrideProvider = undefined;
    }
}
exports.EmphasizeElements = EmphasizeElements;


/***/ }),

/***/ "./lib/EntityState.js":
/*!****************************!*\
  !*** ./lib/EntityState.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module ElementState */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/** The "state" of an Entity as represented in a web browser. Every subclass of EntityState handles one BIS class.
 * @public
 */
class EntityState {
    /** The name of the BIS schema for this class.
     * @note Subclasses from other than the BisCore domain must override the static member "schemaName" with their schema name.
     */
    static get schemaName() { return "BisCore"; }
    get _ctor() { return this.constructor; }
    /** The name of the BIS class associated with this class.
     * @note Every subclass of EntityState **MUST** override this method to identify its BIS class.
     * Failure to do so will ordinarily result in an error when the class is registered, since there may only
     * be one JavaScript class for a given BIS class (usually the errant class will collide with its superclass.)
     */
    static get className() { return "Entity"; }
    /** The name of the BIS class associated with this class. */
    get className() { return this._ctor.className; }
    /** Constructor for EntityState
     * @param props the properties of the Entity for this EntityState
     * @param iModel the iModel from which this EntityState is to be constructed
     * @param _state source EntityState for clone
     */
    constructor(props, iModel, _state) {
        this.classFullName = props.classFullName;
        this.iModel = iModel;
        this.id = bentleyjs_core_1.Id64.fromJSON(props.id);
        this.jsonProperties = props.jsonProperties ? JSON.parse(JSON.stringify(props.jsonProperties)) : {}; // make sure we have our own copy
    }
    /** @internal */
    toJSON() {
        const val = {};
        val.classFullName = this.classFullName;
        if (bentleyjs_core_1.Id64.isValid(this.id))
            val.id = this.id;
        if (this.jsonProperties && Object.keys(this.jsonProperties).length > 0)
            val.jsonProperties = this.jsonProperties;
        return val;
    }
    /** Return true if this EntityState is equal to another one. */
    equals(other) { return JSON.stringify(this.toJSON()) === JSON.stringify(other.toJSON()); }
    /** Make an independent copy of this EntityState */
    clone(iModel) { return new this._ctor(this.toJSON(), iModel ? iModel : this.iModel, this); }
    /** Get full BIS class name of this Entity in the form "SchemaName:ClassName".  */
    static get classFullName() { return this.schemaName + ":" + this.className; }
}
exports.EntityState = EntityState;
/** The "state" of an Element as represented in a web browser.
 * @public
 */
class ElementState extends EntityState {
    /** @internal */
    static get className() { return "Element"; }
    constructor(props, iModel) {
        super(props, iModel);
        this.code = imodeljs_common_1.Code.fromJSON(props.code);
        this.model = imodeljs_common_1.RelatedElement.idFromJson(props.model);
        this.parent = imodeljs_common_1.RelatedElement.fromJSON(props.parent);
        this.federationGuid = props.federationGuid;
        this.userLabel = props.userLabel;
    }
    /** @internal */
    toJSON() {
        const val = super.toJSON();
        if (bentleyjs_core_1.Id64.isValid(this.code.spec))
            val.code = this.code;
        val.model = this.model;
        val.parent = this.parent;
        val.federationGuid = this.federationGuid;
        val.userLabel = this.userLabel;
        return val;
    }
}
exports.ElementState = ElementState;


/***/ }),

/***/ "./lib/FrontendLoggerCategory.js":
/*!***************************************!*\
  !*** ./lib/FrontendLoggerCategory.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Logging */
Object.defineProperty(exports, "__esModule", { value: true });
/** Logger categories used by this package
 * @note All logger categories in this package start with the `imodeljs-frontend` prefix.
 * @see [Logger]($bentley)
 * @public
 */
var FrontendLoggerCategory;
(function (FrontendLoggerCategory) {
    FrontendLoggerCategory["Package"] = "imodeljs-frontend";
    /** The logger category used by the [[FrontendRequestContext]] class and other related classes. */
    FrontendLoggerCategory["FrontendRequestContext"] = "imodeljs-frontend.FrontendRequestContext";
    /** The logger category used by the [[IModelConnection]] class and other related classes. */
    FrontendLoggerCategory["IModelConnection"] = "imodeljs-frontend.IModelConnection";
    /** The logger category used by OIDC-related functions in the browser. */
    FrontendLoggerCategory["OidcBrowserClient"] = "imodeljs-frontend.OidcBrowserClient";
    /** The logger category used by OIDC-related functions on iOS. */
    FrontendLoggerCategory["OidcIOSClient"] = "imodeljs-frontend.OidcIOSClient";
})(FrontendLoggerCategory = exports.FrontendLoggerCategory || (exports.FrontendLoggerCategory = {}));


/***/ }),

/***/ "./lib/FrontendRequestContext.js":
/*!***************************************!*\
  !*** ./lib/FrontendRequestContext.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Utils */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_clients_1 = __webpack_require__(/*! @bentley/imodeljs-clients */ "@bentley/imodeljs-clients");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const FrontendLoggerCategory_1 = __webpack_require__(/*! ./FrontendLoggerCategory */ "./lib/FrontendLoggerCategory.js");
const loggerCategory = FrontendLoggerCategory_1.FrontendLoggerCategory.FrontendRequestContext;
/**
 * Provides some generic context for downstream server applications to get details of a request that
 * originated at the frontend. The context is meant for use in applications that require authorization.
 * @see FrontendRequestContext
 * @public
 */
class AuthorizedFrontendRequestContext extends imodeljs_clients_1.AuthorizedClientRequestContext {
    /**
     * Create a new context for agent applications or long running frontend operations to pass to various services
     * @see [[AuthorizedFrontendRequestContext.create]] to create the request based on the authorization information supplied to IModelHost.
     */
    constructor(accessToken, activityId = bentleyjs_core_1.Guid.createValue()) {
        super(accessToken, activityId, IModelApp_1.IModelApp.applicationId, IModelApp_1.IModelApp.applicationVersion, IModelApp_1.IModelApp.sessionId);
    }
    /**
     * Create a new context for agent applications or long running frontend operations to pass to various services that require
     * authorization. Uses the authorization information supplied to IModelHost to setup an accessToken within the context.
     * @throws [[BentleyError]] if the application cannot be authorized.
     * @see [[IModelApp.authorizationClient]] to setup authorization for the frontend application.
     */
    static async create(activityId = bentleyjs_core_1.Guid.createValue()) {
        if (!IModelApp_1.IModelApp.authorizationClient)
            throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.AuthStatus.Error, "IModelApp.authorizationClient not initialized", bentleyjs_core_1.Logger.logError, loggerCategory);
        if (!IModelApp_1.IModelApp.authorizationClient.hasSignedIn)
            throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.AuthStatus.Error, "Not signed in", bentleyjs_core_1.Logger.logError, loggerCategory);
        const accessToken = await IModelApp_1.IModelApp.authorizationClient.getAccessToken();
        return new AuthorizedFrontendRequestContext(accessToken, activityId);
    }
}
exports.AuthorizedFrontendRequestContext = AuthorizedFrontendRequestContext;
/**
 * Provides generic context for downstream server applications to get details of a request that
 * originated at the frontend. The context is meant for use in applications that do NOT require authorization.
 * @see AuthorizedFrontendRequestContext
 * @public
 */
class FrontendRequestContext extends bentleyjs_core_1.ClientRequestContext {
    /** Create a new context for agent applications or long running frontend operations to pass to various services */
    constructor(activityId = bentleyjs_core_1.Guid.createValue()) {
        super(activityId, IModelApp_1.IModelApp.applicationId, IModelApp_1.IModelApp.applicationVersion, IModelApp_1.IModelApp.sessionId);
    }
}
exports.FrontendRequestContext = FrontendRequestContext;


/***/ }),

/***/ "./lib/FuzzySearch.js":
/*!****************************!*\
  !*** ./lib/FuzzySearch.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Fuse = __webpack_require__(/*! fuse.js */ "../../common/temp/node_modules/.registry.npmjs.org/fuse.js/3.4.5/node_modules/fuse.js/dist/fuse.js");
/** @public */
class FuzzySearch {
    /** Override to provide non-standard FuseOptions for searches where the a single word pattern is used */
    onGetSingleWordSearchOptions() {
        return {
            shouldSort: true,
            threshold: 0.40,
            location: 0,
            distance: 100,
            maxPatternLength: 32,
            minMatchCharLength: 2,
            includeMatches: true,
            includeScore: true,
        };
    }
    /** Override to provide non-standard FuseOptions for searches where the a multiple word pattern is used */
    onGetMultiWordSearchOptions() {
        return {
            shouldSort: true,
            threshold: 0.40,
            tokenize: true,
            matchAllTokens: true,
            maxPatternLength: 32,
            minMatchCharLength: 2,
            includeMatches: true,
            includeScore: true,
        };
    }
    /** Call to conduct a fuzzy search of searchedObjects, looking at the 'key' member of each such object
     * @param searchedObjects An array of objects to search.
     * @param keys The name of the members to search in the searchedObjects.
     * @param pattern The pattern for which each searchedObject is searched.
     * @return FuzzySearchResults.
     */
    search(searchedObjects, keys, pattern) {
        if (!pattern || pattern.length < 2)
            return new FuzzySearchResults(undefined);
        // it is a multi-word pattern if there's a space other than at the end of the pattern.
        const spaceIndex = pattern.indexOf(" ");
        const multiWord = (-1 !== spaceIndex) && (spaceIndex !== (pattern.length - 1));
        const options = multiWord ? this.onGetMultiWordSearchOptions() : this.onGetSingleWordSearchOptions();
        options.keys = keys;
        const fuse = new Fuse(searchedObjects, options);
        let results = fuse.search(pattern);
        // We need to set the threshold fairly high to get results when the user misspells words (otherwise they are not returned),
        // but doing that results in matches that don't make sense when there are "good" matches. So we discard matches where the match
        // score increases by a large amount between results.
        let checkScoreDelta = false;
        let averageScoreDeltaThreshold = 1;
        if (results.length > 30) {
            averageScoreDeltaThreshold = ((results[results.length - 1].score - results[0].score) / results.length) * 10;
            if (averageScoreDeltaThreshold > 0.01)
                checkScoreDelta = true;
        }
        // Sometimes fuse returns results in the array where the matches array is empty. That seems like a bug to me, but it happens when
        // the input  is something like "fjt" and the string it matches is "fit". If we have more than three actual matches, we just truncate the set when we see one.
        // The other use for this loop is to truncate when we see a dramatic increase in the score. The ones after are unlikely
        // to be useful, so we truncate the results when we hit that point also.
        for (let resultIndex = 0; resultIndex < results.length; resultIndex++) {
            const thisResult = results[resultIndex];
            if (0 === thisResult.matches.length) {
                // here we have a result with no matches. If we have other matches, just discard this and the rest.
                if (resultIndex > 2) {
                    results = results.slice(0, resultIndex);
                    break;
                }
                // otherwise we want to keep this result, but we have to add the matched value to the object because we can't get it from the matches array.
                // we assume it came from the first key (usually there's only one anyway).
                thisResult.matchedValue = thisResult.item[keys[0]];
                thisResult.matchedKey = keys[0];
            }
            if (checkScoreDelta && (resultIndex > 0)) {
                const resultScore = results[resultIndex].score;
                if (resultScore < 0.101)
                    continue;
                if ((resultScore - results[resultIndex - 1].score) > averageScoreDeltaThreshold) {
                    results = results.slice(0, resultIndex);
                    break;
                }
            }
        }
        // put the functions on each result so it fulfils the FuzzySearchResult interface.
        for (const thisResult of results) {
            thisResult.getResult = getResult.bind(thisResult);
            thisResult.getBoldMask = getBoldMask.bind(thisResult);
            thisResult.getMatchedKey = getMatchedKey.bind(thisResult);
            thisResult.getMatchedValue = getMatchedValue.bind(thisResult);
        }
        return new FuzzySearchResults(results);
    }
}
exports.FuzzySearch = FuzzySearch;
/** Added to each result to support the FuzzySearchResult interface. */
function getResult() { return this.item; }
/** Added to each result to support the FuzzySearchResult interface. */
function getMatchedKey() { return (this.matches.length > 0) ? this.matches[0].key : this.matchedKey; }
/** Added to each result to support the FuzzySearchResult interface. */
function getMatchedValue() { return (this.matches.length > 0) ? this.matches[0].value : this.matchedValue; }
/** this function is added to each result to support the FuzzySearchResult interface. */
function getBoldMask() {
    if (this.boldMask)
        return this.boldMask;
    // if we had no matches, we return a bold mask with all false.
    if (0 === this.matches.length) {
        const noBoldMask = new Array(this.matchedValue.length);
        noBoldMask.fill(false);
        return this.boldMask = noBoldMask;
    }
    // we have some matched portions.
    const thisMatchedString = this.matches[0].value;
    const valueLength = thisMatchedString.length;
    const boldMask = new Array(valueLength);
    boldMask.fill(false);
    const indicesArray = this.matches[0].indices;
    indicesArray.forEach((set) => {
        for (let start = set[0], end = set[1]; start <= end; start++) {
            boldMask[start] = true;
        }
    });
    // cache it so if someone asks again we don't have to recalculate it.
    return this.boldMask = boldMask;
}
/**
 * This class is used to return the results of FuzzySearch.search. It is iterable, with each iteration
 * returning an object implementing the FuzzySearchResult interface.
 * @public
 */
class FuzzySearchResults {
    constructor(results) {
        this.results = [];
        if (results)
            this.results = results;
    }
    [Symbol.iterator]() { return new FuzzySearchResultsIterator(this); }
    get length() { return this.results.length; }
    getResult(resultIndex) {
        if ((resultIndex < 0) || (resultIndex > this.results.length))
            return undefined;
        return this.results[resultIndex];
    }
}
exports.FuzzySearchResults = FuzzySearchResults;
class FuzzySearchResultsIterator {
    constructor(fsr) {
        this.next = () => {
            return {
                done: this.counter === this.fsr.results.length,
                value: this.fsr.results[this.counter++],
            };
        };
        this.fsr = fsr;
        this.counter = 0;
    }
}


/***/ }),

/***/ "./lib/GeoServices.js":
/*!****************************!*\
  !*** ./lib/GeoServices.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
// this class is used to cache results from conversion of geoCoordinates to IModelCoordinates.
class GCtoIMCResultCache {
    constructor(iModel, sourceDatum) {
        this._iModel = iModel;
        this._cache = {};
        this._sourceDatum = sourceDatum;
    }
    /** @internal */
    findInCache(geoPoints) {
        const result = [];
        let missing;
        for (const geoPoint of geoPoints) {
            const key = JSON.stringify(geoPoint);
            const imodelCoord = this._cache[key];
            result.push(imodelCoord);
            if (undefined === imodelCoord) {
                if (undefined === missing)
                    missing = [];
                missing.push(geoPoint);
            }
        }
        return { result, missing };
    }
    async findInCacheOrRequest(request) {
        const response = { iModelCoords: [], fromCache: 0 };
        let missing;
        // Index by cache key to obtain index in input array.
        const originalPositions = {};
        for (let iPoint = 0; iPoint < request.geoCoords.length; ++iPoint) {
            const thisGeoCoord = request.geoCoords[iPoint];
            // we use the JSON string as the key into our cache of previously returned results.
            const thisCacheKey = JSON.stringify(thisGeoCoord);
            // put something in each output that corresponds to the input.
            if (this._cache[thisCacheKey]) {
                response.iModelCoords.push(this._cache[thisCacheKey]);
            }
            else {
                if (undefined === missing)
                    missing = [];
                // add this geoCoord to the request we are going to send.
                missing.push(thisGeoCoord);
                // keep track of the original position of this point.
                originalPositions[thisCacheKey] = iPoint;
                // mark the response as pending.
                response.iModelCoords.push({ p: [0, 0, 0], s: imodeljs_common_1.GeoCoordStatus.Pending });
            }
        }
        // if none are missing from the cache, resolve the promise immediately
        if (undefined === missing) {
            response.fromCache = request.geoCoords.length;
        }
        else {
            // keep track of how many came from the cache (mostly for tests).
            response.fromCache = request.geoCoords.length - missing.length;
            // Avoiding requesting too many points at once, exceeding max request length (this definition of "too many" should be safely conservative)
            const maxPointsPerRequest = 200;
            const promises = [];
            for (let i = 0; i < missing.length; i += maxPointsPerRequest) {
                const remainingRequest = { sourceDatum: this._sourceDatum, geoCoords: missing.slice(i, i + maxPointsPerRequest) };
                const promise = imodeljs_common_1.IModelReadRpcInterface.getClient().getIModelCoordinatesFromGeoCoordinates(this._iModel.iModelToken.toJSON(), JSON.stringify(remainingRequest)).then((remainingResponse) => {
                    // put the responses into the cache, and fill in the output response for each
                    for (let iResponse = 0; iResponse < remainingResponse.iModelCoords.length; ++iResponse) {
                        const thisPoint = remainingResponse.iModelCoords[iResponse];
                        // put the answer in the cache.
                        const thisGeoCoord = remainingRequest.geoCoords[iResponse];
                        const thisCacheKey = JSON.stringify(thisGeoCoord);
                        this._cache[thisCacheKey] = thisPoint;
                        // transfer the answer stored in remainingResponse to the correct position in the overall response.
                        const responseIndex = originalPositions[thisCacheKey];
                        response.iModelCoords[responseIndex] = thisPoint;
                    }
                });
                promises.push(promise);
            }
            await Promise.all(promises);
        }
        return Promise.resolve(response);
    }
}
// this class is used to cache results from conversion of IModelCoordinates to GeoCoordinates.
class IMCtoGCResultCache {
    constructor(iModel, targetDatum) {
        this._iModel = iModel;
        this._cache = {};
        this._targetDatum = targetDatum;
    }
    async findInCacheOrRequest(request) {
        let missing = false;
        const response = { geoCoords: [], fromCache: 0 };
        let remainingRequest;
        const originalPositions = [];
        for (let iPoint = 0; iPoint < request.iModelCoords.length; ++iPoint) {
            const thisIModelCoord = request.iModelCoords[iPoint];
            // we use the JSON string as the key into our cache of previously returned results.
            const thisCacheKey = JSON.stringify(thisIModelCoord);
            // put something in each output that corresponds to the input.
            if (this._cache[thisCacheKey]) {
                response.geoCoords.push(this._cache[thisCacheKey]);
            }
            else {
                if (!remainingRequest)
                    remainingRequest = { targetDatum: this._targetDatum, iModelCoords: [] };
                // add this geoCoord to the request we are going to send.
                remainingRequest.iModelCoords.push(thisIModelCoord);
                // keep track of the original position of this point.
                originalPositions.push(iPoint);
                // mark the response as pending.
                response.geoCoords.push({ p: [0, 0, 0], s: imodeljs_common_1.GeoCoordStatus.Pending });
                missing = true;
            }
        }
        // if none are missing from the cache, resolve the promise immediately
        if (!missing) {
            response.fromCache = request.iModelCoords.length;
            return Promise.resolve(response);
        }
        else {
            // keep track of how many came from the cache (mostly for tests).
            response.fromCache = request.iModelCoords.length - originalPositions.length;
            const remainingResponse = await imodeljs_common_1.IModelReadRpcInterface.getClient().getGeoCoordinatesFromIModelCoordinates(this._iModel.iModelToken.toJSON(), JSON.stringify(remainingRequest));
            // put the responses into the cache, and fill in the output response for each
            for (let iResponse = 0; iResponse < remainingResponse.geoCoords.length; ++iResponse) {
                const thisPoint = remainingResponse.geoCoords[iResponse];
                // transfer the answer stored in remainingResponse to the correct position in the overall response.
                const responseIndex = originalPositions[iResponse];
                response.geoCoords[responseIndex] = thisPoint;
                // put the answer in the cache.
                const thisIModelCoord = remainingRequest.iModelCoords[iResponse];
                const thisCacheKey = JSON.stringify(thisIModelCoord);
                this._cache[thisCacheKey] = thisPoint;
            }
            return Promise.resolve(response);
        }
    }
}
/** The GeoConverter class communicates with the backend to convert longitude/latitude coordinates to iModel coordinates and vice-versa
 * @internal
 */
class GeoConverter {
    constructor(iModel, datum) {
        this._datum = datum;
        this._gCtoIMCResultCache = new GCtoIMCResultCache(iModel, datum);
        this._iMCtoGCResultCache = new IMCtoGCResultCache(iModel, datum);
    }
    async getIModelCoordinatesFromGeoCoordinates(geoPoints) {
        const requestProps = { sourceDatum: this._datum, geoCoords: geoPoints };
        return this._gCtoIMCResultCache.findInCacheOrRequest(requestProps);
    }
    getCachedIModelCoordinatesFromGeoCoordinates(geoPoints) {
        return this._gCtoIMCResultCache.findInCache(geoPoints);
    }
    async getGeoCoordinatesFromIModelCoordinates(iModelPoints) {
        const requestProps = { targetDatum: this._datum, iModelCoords: iModelPoints };
        return this._iMCtoGCResultCache.findInCacheOrRequest(requestProps);
    }
}
exports.GeoConverter = GeoConverter;
/** The Geographic Services available for an [[IModelConnection]].
 * @internal
 */
class GeoServices {
    constructor(iModel) {
        this._iModel = iModel;
    }
    getConverter(datum) {
        return new GeoConverter(this._iModel, datum ? datum : "");
    }
}
exports.GeoServices = GeoServices;


/***/ }),

/***/ "./lib/HitDetail.js":
/*!**************************!*\
  !*** ./lib/HitDetail.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module LocatingElements */
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const Sprites_1 = __webpack_require__(/*! ./Sprites */ "./lib/Sprites.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const GraphicBuilder_1 = __webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/** @public */
var SnapMode;
(function (SnapMode) {
    SnapMode[SnapMode["Nearest"] = 1] = "Nearest";
    SnapMode[SnapMode["NearestKeypoint"] = 2] = "NearestKeypoint";
    SnapMode[SnapMode["MidPoint"] = 4] = "MidPoint";
    SnapMode[SnapMode["Center"] = 8] = "Center";
    SnapMode[SnapMode["Origin"] = 16] = "Origin";
    SnapMode[SnapMode["Bisector"] = 32] = "Bisector";
    SnapMode[SnapMode["Intersection"] = 64] = "Intersection";
})(SnapMode = exports.SnapMode || (exports.SnapMode = {}));
/** @public */
var SnapHeat;
(function (SnapHeat) {
    SnapHeat[SnapHeat["None"] = 0] = "None";
    SnapHeat[SnapHeat["NotInRange"] = 1] = "NotInRange";
    SnapHeat[SnapHeat["InRange"] = 2] = "InRange";
})(SnapHeat = exports.SnapHeat || (exports.SnapHeat = {}));
/** The procedure that generated this Hit.
 * @public
 */
var HitSource;
(function (HitSource) {
    HitSource[HitSource["None"] = 0] = "None";
    HitSource[HitSource["FromUser"] = 1] = "FromUser";
    HitSource[HitSource["MotionLocate"] = 2] = "MotionLocate";
    HitSource[HitSource["AccuSnap"] = 3] = "AccuSnap";
    HitSource[HitSource["TentativeSnap"] = 4] = "TentativeSnap";
    HitSource[HitSource["DataPoint"] = 5] = "DataPoint";
    HitSource[HitSource["Application"] = 6] = "Application";
    HitSource[HitSource["EditAction"] = 7] = "EditAction";
    HitSource[HitSource["EditActionSS"] = 8] = "EditActionSS";
})(HitSource = exports.HitSource || (exports.HitSource = {}));
/** What was being tested to generate this hit. This is not the element or
 * GeometricPrimitive that generated the Hit, it is an indication of whether it is an edge or interior hit.
 * @public
 */
var HitGeomType;
(function (HitGeomType) {
    HitGeomType[HitGeomType["None"] = 0] = "None";
    HitGeomType[HitGeomType["Point"] = 1] = "Point";
    HitGeomType[HitGeomType["Segment"] = 2] = "Segment";
    HitGeomType[HitGeomType["Curve"] = 3] = "Curve";
    HitGeomType[HitGeomType["Arc"] = 4] = "Arc";
    HitGeomType[HitGeomType["Surface"] = 5] = "Surface";
})(HitGeomType = exports.HitGeomType || (exports.HitGeomType = {}));
/** Classification of GeometricPrimitive that generated the Hit.
 * @public
 */
var HitParentGeomType;
(function (HitParentGeomType) {
    HitParentGeomType[HitParentGeomType["None"] = 0] = "None";
    HitParentGeomType[HitParentGeomType["Wire"] = 1] = "Wire";
    HitParentGeomType[HitParentGeomType["Sheet"] = 2] = "Sheet";
    HitParentGeomType[HitParentGeomType["Solid"] = 3] = "Solid";
    HitParentGeomType[HitParentGeomType["Mesh"] = 4] = "Mesh";
    HitParentGeomType[HitParentGeomType["Text"] = 5] = "Text";
})(HitParentGeomType = exports.HitParentGeomType || (exports.HitParentGeomType = {}));
/** @public */
var HitPriority;
(function (HitPriority) {
    HitPriority[HitPriority["WireEdge"] = 0] = "WireEdge";
    HitPriority[HitPriority["PlanarEdge"] = 1] = "PlanarEdge";
    HitPriority[HitPriority["NonPlanarEdge"] = 2] = "NonPlanarEdge";
    HitPriority[HitPriority["SilhouetteEdge"] = 3] = "SilhouetteEdge";
    HitPriority[HitPriority["PlanarSurface"] = 4] = "PlanarSurface";
    HitPriority[HitPriority["NonPlanarSurface"] = 5] = "NonPlanarSurface";
    HitPriority[HitPriority["Unknown"] = 6] = "Unknown";
})(HitPriority = exports.HitPriority || (exports.HitPriority = {}));
/** @public */
var HitDetailType;
(function (HitDetailType) {
    HitDetailType[HitDetailType["Hit"] = 1] = "Hit";
    HitDetailType[HitDetailType["Snap"] = 2] = "Snap";
    HitDetailType[HitDetailType["Intersection"] = 3] = "Intersection";
})(HitDetailType = exports.HitDetailType || (exports.HitDetailType = {}));
/** A HitDetail stores the result when locating geometry displayed in a view.
 * It holds an approximate location on an element (or decoration) from a *pick*.
 * @public
 */
class HitDetail {
    /** Create a new HitDetail from the inputs to and results of a locate operation.
     * @param testPoint The world coordinate space point that was used as the locate point.
     * @param viewport The view the locate operation was performed in.
     * @param hitSource The procedure that requested the locate operation.
     * @param hitPoint The approximate world coordinate location on the geometry identified by this HitDetail.
     * @param sourceId The source of the geometry, either a persistent element id or pickable decoration id.
     * @param priority The hit geometry priority/classification.
     * @param distXY The xy distance to hit in view coordinates.
     * @param distFraction The near plane distance fraction to hit.
     * @param subCategoryId The SubCategory for a persistent element hit.
     * @param geometryClass The GeometryClass for a persistent element hit.
     */
    constructor(testPoint, viewport, hitSource, hitPoint, sourceId, priority, distXY, distFraction, subCategoryId, geometryClass) {
        this.testPoint = testPoint;
        this.viewport = viewport;
        this.hitSource = hitSource;
        this.hitPoint = hitPoint;
        this.sourceId = sourceId;
        this.priority = priority;
        this.distXY = distXY;
        this.distFraction = distFraction;
        this.subCategoryId = subCategoryId;
        this.geometryClass = geometryClass;
    }
    /** Get the type of HitDetail.
     * @returns HitDetailType.Hit if this is a HitDetail, HitDetailType.Snap if it is a SnapDetail
     */
    getHitType() { return HitDetailType.Hit; }
    /** Get the *hit point* for this HitDetail. Returns the approximate point on the element that caused the hit when not a SnapDetail or IntersectDetail.
     * For a snap that is *hot*, the *exact* point on the Element for the snap mode is returned, otherwise the close point on the hit geometry is returned.
     */
    getPoint() { return this.hitPoint; }
    /** Determine if this HitPoint is from the same source as another HitDetail. */
    isSameHit(otherHit) { return (undefined !== otherHit && this.sourceId === otherHit.sourceId); }
    /** Return whether sourceId is for a persistent element and not a pickable decoration. */
    get isElementHit() { return !bentleyjs_core_1.Id64.isInvalid(this.sourceId) && !bentleyjs_core_1.Id64.isTransient(this.sourceId); }
    // return whether the sourceId is for a model (reality models etc.)
    get isModelHit() { return this.viewport.iModel.models.getLoaded(this.sourceId) !== undefined; }
    /** Create a deep copy of this HitDetail */
    clone() { const val = new HitDetail(this.testPoint, this.viewport, this.hitSource, this.hitPoint, this.sourceId, this.priority, this.distXY, this.distFraction, this.subCategoryId, this.geometryClass); return val; }
    /** Draw this HitDetail as a Decoration. Causes the picked element to *flash* */
    draw(_context) { this.viewport.setFlashed(this.sourceId, 0.25); }
    /** Get the tooltip content for this HitDetail.
     * Calls the backend method [Element.getToolTipMessage]($backend), and replaces all instances of `${localizeTag}` with localized string from IModelApp.i18n.
     */
    async getToolTip() {
        if (!this.isElementHit)
            return IModelApp_1.IModelApp.viewManager.getDecorationToolTip(this);
        const msg = await this.viewport.iModel.getToolTipMessage(this.sourceId); // wait for the locate message(s) from the backend
        // now combine all the lines into one string, replacing any instances of ${tag} with the translated versions.
        // Add "<br>" at the end of each line to cause them to come out on separate lines in the tooltip.
        let out = "";
        msg.forEach((line) => out += IModelApp_1.IModelApp.i18n.translateKeys(line) + "<br>");
        const div = document.createElement("div");
        div.innerHTML = out;
        return div;
    }
}
exports.HitDetail = HitDetail;
/** A SnapDetail is generated from the result of [IModelDb.requestSnap]($backend) call. In addition to the HitDetail about the reason the element was *picked*,
 * it holds the *exact* point on the element from the snapping logic, plus additional information that varies with the type of element and snap mode.
 * @public
 */
class SnapDetail extends HitDetail {
    /** Constructor for SnapDetail.
     * @param from The HitDetail that created this snap
     * @param snapMode The SnapMode used to create this SnapDetail
     * @param heat The SnapHeat of this SnapDetail
     * @param snapPoint The snapped point in the element
     */
    constructor(from, snapMode = SnapMode.Nearest, heat = SnapHeat.None, snapPoint) {
        super(from.testPoint, from.viewport, from.hitSource, from.hitPoint, from.sourceId, from.priority, from.distXY, from.distFraction, from.subCategoryId, from.geometryClass);
        this.snapMode = snapMode;
        this.heat = heat;
        this.snapPoint = geometry_core_1.Point3d.fromJSON(snapPoint ? snapPoint : from.hitPoint);
        this.adjustedPoint = this.snapPoint.clone();
        this.sprite = Sprites_1.IconSprites.getSpriteFromUrl(SnapDetail.getSnapSpriteUrl(snapMode));
    }
    /** Returns `HitDetailType.Snap` */
    getHitType() { return HitDetailType.Snap; }
    /** Get the snap point if this SnapDetail is *hot*, the pick point otherwise. */
    getPoint() { return this.isHot ? this.snapPoint : super.getPoint(); }
    /** Return true if the pick point was closer than [SnapRequestProps.snapAperture]($common) from the generated snap point. */
    get isHot() { return this.heat !== SnapHeat.None; }
    /** Determine whether the [[adjustedPoint]] is different than the [[snapPoint]]. This happens, for example, when points are adjusted for grids, acs plane snap, and AccuDraw. */
    get isPointAdjusted() { return !this.adjustedPoint.isExactEqual(this.snapPoint); }
    /** Change the snap point. */
    setSnapPoint(point, heat) { this.snapPoint.setFrom(point); this.adjustedPoint.setFrom(point); this.heat = heat; }
    /** Set curve primitive and HitGeometryType for this SnapDetail. */
    setCurvePrimitive(primitive, localToWorld, geomType) {
        this.primitive = primitive;
        this.geomType = undefined;
        // Only HitGeomType.Point and HitGeomType.Surface are valid without a curve primitive.
        if (undefined === this.primitive) {
            if (HitGeomType.Point === geomType || HitGeomType.Surface === geomType)
                this.geomType = geomType;
            return;
        }
        if (undefined !== localToWorld)
            this.primitive.tryTransformInPlace(localToWorld);
        if (this.primitive instanceof geometry_core_1.Arc3d)
            this.geomType = HitGeomType.Arc;
        else if (this.primitive instanceof geometry_core_1.LineSegment3d)
            this.geomType = HitGeomType.Segment;
        else if (this.primitive instanceof geometry_core_1.LineString3d)
            this.geomType = HitGeomType.Segment;
        else
            this.geomType = HitGeomType.Curve;
        // Set curve primitive geometry type override...
        //  - HitGeomType.Point with arc/ellipse denotes center.
        //  - HitGeomType.Surface with any curve primitive denotes an interior hit.
        if (undefined !== geomType && HitGeomType.None !== geomType)
            this.geomType = geomType;
    }
    /** Make a copy of this SnapDetail. */
    clone() {
        const val = new SnapDetail(this, this.snapMode, this.heat, this.snapPoint);
        val.sprite = this.sprite;
        val.geomType = this.geomType;
        val.parentGeomType = this.parentGeomType;
        val.adjustedPoint.setFrom(this.adjustedPoint);
        if (undefined !== this.primitive)
            val.primitive = this.primitive.clone();
        if (undefined !== this.normal)
            val.normal = this.normal.clone();
        return val;
    }
    getCurvePrimitive(singleSegment = true) {
        if (!singleSegment || undefined === this.primitive)
            return this.primitive;
        if (this.primitive instanceof geometry_core_1.LineString3d) {
            const ls = this.primitive;
            if (ls.points.length > 2) {
                const loc = ls.closestPoint(this.snapPoint, false);
                const nSegments = ls.points.length - 1;
                const uSegRange = (1.0 / nSegments);
                let segmentNo = Math.floor(loc.fraction / uSegRange);
                if (segmentNo >= nSegments)
                    segmentNo = nSegments - 1;
                return geometry_core_1.LineSegment3d.create(ls.points[segmentNo], ls.points[segmentNo + 1]);
            }
        }
        return this.primitive;
    }
    draw(context) {
        if (undefined !== this.primitive) {
            let singleSegment = false;
            switch (this.snapMode) {
                case SnapMode.Center:
                case SnapMode.Origin:
                case SnapMode.Bisector:
                    break; // Snap point for these is computed using entire linestring, not just the hit segment...
                default: {
                    singleSegment = true;
                    break;
                }
            }
            const builder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldOverlay);
            const outline = context.viewport.hilite.color.adjustForContrast(context.viewport.view.backgroundColor, 50);
            const centerLine = context.viewport.hilite.color.adjustForContrast(outline, 175);
            const path = geometry_core_1.Path.create(this.getCurvePrimitive(singleSegment));
            builder.setSymbology(outline, outline, 6);
            builder.addPath(path);
            builder.setSymbology(centerLine, centerLine, 2);
            builder.addPath(path);
            context.addDecorationFromBuilder(builder);
            return;
        }
        super.draw(context);
    }
    static getSnapSpriteUrl(snapType) {
        switch (snapType) {
            case SnapMode.Nearest: return "sprites/SnapPointOn.png";
            case SnapMode.NearestKeypoint: return "sprites/SnapKeypoint.png";
            case SnapMode.MidPoint: return "sprites/SnapMidpoint.png";
            case SnapMode.Center: return "sprites/SnapCenter.png";
            case SnapMode.Origin: return "sprites/SnapOrigin.png";
            case SnapMode.Bisector: return "sprites/SnapBisector.png";
            case SnapMode.Intersection: return "sprites/SnapIntersection.png";
        }
        return "";
    }
}
exports.SnapDetail = SnapDetail;
/** @public */
class IntersectDetail extends SnapDetail {
    constructor(from, heat = SnapHeat.None, snapPoint, otherPrimitive, otherId) {
        super(from, SnapMode.Intersection, heat, snapPoint);
        this.otherPrimitive = otherPrimitive;
        this.otherId = otherId;
        this.primitive = from.primitive;
        this.normal = from.normal; // Preserve normal from primary snap location for AccuDraw smart rotation...
    }
    draw(context) {
        if (undefined !== this.primitive && undefined !== this.otherPrimitive) {
            const builder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldOverlay);
            const outline = context.viewport.hilite.color.adjustForContrast(context.viewport.view.backgroundColor, 50);
            const centerLine = context.viewport.hilite.color.adjustForContrast(outline, 175);
            const path1 = geometry_core_1.Path.create(this.primitive);
            const path2 = geometry_core_1.Path.create(this.otherPrimitive);
            builder.setSymbology(outline, outline, 6);
            builder.addPath(path1);
            builder.addPath(path2);
            builder.setSymbology(centerLine, centerLine, 2);
            builder.addPath(path1);
            builder.setSymbology(centerLine, centerLine, 2, imodeljs_common_1.LinePixels.Code2);
            builder.addPath(path2);
            context.addDecorationFromBuilder(builder);
            return;
        }
        super.draw(context);
    }
}
exports.IntersectDetail = IntersectDetail;
/** The result of a "locate" is a sorted list of objects that satisfied the search criteria (a HitList). Earlier hits in the list
 * are somehow *better* than those later on.
 * @public
 */
class HitList {
    constructor() {
        this.hits = [];
        this.currHit = -1;
    }
    get length() { return this.hits.length; }
    empty() { this.hits.length = 0; this.currHit = -1; }
    resetCurrentHit() { this.currHit = -1; }
    /** Get a hit from a particular index into a HitList
     * return the requested hit from the HitList or undefined
     */
    getHit(hitNum) {
        if (hitNum < 0)
            hitNum = this.length - 1;
        return (hitNum >= this.length) ? undefined : this.hits[hitNum];
    }
    /** When setting one or more indices to undefined you must call dropNulls afterwards */
    setHit(i, p) {
        if (i < 0 || i >= this.length)
            return;
        this.hits[i] = p;
    }
    dropNulls() {
        const hits = this.hits;
        this.hits = [];
        for (const hit of hits)
            this.hits.push(hit);
    }
    getNextHit() { this.currHit++; return this.getCurrentHit(); }
    getCurrentHit() { return -1 === this.currHit ? undefined : this.getHit(this.currHit); }
    setCurrentHit(hit) {
        this.resetCurrentHit();
        for (let thisHit; undefined !== (thisHit = this.getNextHit());) {
            if (thisHit === hit)
                return;
        }
    }
    /** remove the current hit from the list. */
    removeCurrentHit() { this.removeHit(this.currHit); }
    /** remove a hit in the list. */
    removeHit(hitNum) {
        if (hitNum < 0) // Support -1 == END
            hitNum = this.length - 1;
        if (hitNum <= this.currHit)
            this.currHit = -1;
        if (hitNum >= this.length) // Locate calls GetNextHit, which increments currHit, until it goes beyond the end of size of the array.
            return; // Then Reset call RemoteCurrentHit, which passes in currHit. When it is out of range, we do nothing.
        this.hits.splice(hitNum, 1);
    }
    /** search through list and remove any hits that contain a specified element id. */
    removeHitsFrom(sourceId) {
        let removedOne = false;
        // walk backwards through list so we don't have to worry about what happens on remove
        for (let i = this.length - 1; i >= 0; i--) {
            const thisHit = this.hits[i];
            if (thisHit && sourceId === thisHit.sourceId) {
                removedOne = true;
                this.removeHit(i);
            }
        }
        return removedOne;
    }
    getPriorityZOverride(priority) {
        switch (priority) {
            case HitPriority.WireEdge:
            case HitPriority.PlanarEdge:
            case HitPriority.NonPlanarEdge:
                return 0;
            case HitPriority.SilhouetteEdge:
                return 1;
            case HitPriority.PlanarSurface:
            case HitPriority.NonPlanarSurface:
                return 2;
            default:
                return 3;
        }
    }
    /** compare two hits for insertion into list. */
    compare(hit1, hit2) {
        if (!hit1 || !hit2)
            return 0;
        const zOverride1 = this.getPriorityZOverride(hit1.priority);
        const zOverride2 = this.getPriorityZOverride(hit2.priority);
        // Prefer edges over surfaces, this is more important than z because we know the edge isn't obscured...
        if (zOverride1 < zOverride2)
            return -1;
        if (zOverride1 > zOverride2)
            return 1;
        // Compare xy distance from pick point, prefer hits closer to center...
        if (hit1.distXY < hit2.distXY)
            return -1;
        if (hit1.distXY > hit2.distXY)
            return 1;
        // Compare distance fraction, prefer hits closer to eye...
        if (hit1.distFraction > hit2.distFraction)
            return -1;
        if (hit1.distFraction < hit2.distFraction)
            return 1;
        // Compare geometry class, prefer path/region hits over surface hits when all else is equal...
        if (hit1.priority < hit2.priority)
            return -1;
        if (hit1.priority > hit2.priority)
            return 1;
        return 0;
    }
    /** Add a new hit to the list. Hits are sorted according to their priority and distance. */
    addHit(newHit) {
        if (0 === this.hits.length) {
            this.hits.push(newHit);
            return 0;
        }
        let index = 0;
        for (; index < this.hits.length; ++index) {
            const oldHit = this.hits[index];
            const comparison = this.compare(newHit, oldHit);
            if (comparison < 0)
                break;
        }
        this.hits.splice(index, 0, newHit);
        return index;
    }
    /** Insert a new hit into the list at the supplied index. */
    insertHit(i, hit) {
        if (i < 0 || i >= this.length)
            this.hits.push(hit);
        else
            this.hits.splice(i, 0, hit);
    }
}
exports.HitList = HitList;


/***/ }),

/***/ "./lib/IModelApp.js":
/*!**************************!*\
  !*** ./lib/IModelApp.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module IModelApp */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_clients_1 = __webpack_require__(/*! @bentley/imodeljs-clients */ "@bentley/imodeljs-clients");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const imodeljs_i18n_1 = __webpack_require__(/*! @bentley/imodeljs-i18n */ "@bentley/imodeljs-i18n");
const AccuSnap_1 = __webpack_require__(/*! ./AccuSnap */ "./lib/AccuSnap.js");
const AccuDraw_1 = __webpack_require__(/*! ./AccuDraw */ "./lib/AccuDraw.js");
const ElementLocateManager_1 = __webpack_require__(/*! ./ElementLocateManager */ "./lib/ElementLocateManager.js");
const NotificationManager_1 = __webpack_require__(/*! ./NotificationManager */ "./lib/NotificationManager.js");
const QuantityFormatter_1 = __webpack_require__(/*! ./QuantityFormatter */ "./lib/QuantityFormatter.js");
const FrontendRequestContext_1 = __webpack_require__(/*! ./FrontendRequestContext */ "./lib/FrontendRequestContext.js");
const System_1 = __webpack_require__(/*! ./render/System */ "./lib/render/System.js");
const System_2 = __webpack_require__(/*! ./render/webgl/System */ "./lib/render/webgl/System.js");
const TentativePoint_1 = __webpack_require__(/*! ./TentativePoint */ "./lib/TentativePoint.js");
const Tool_1 = __webpack_require__(/*! ./tools/Tool */ "./lib/tools/Tool.js");
const ToolAdmin_1 = __webpack_require__(/*! ./tools/ToolAdmin */ "./lib/tools/ToolAdmin.js");
const ViewManager_1 = __webpack_require__(/*! ./ViewManager */ "./lib/ViewManager.js");
const TileAdmin_1 = __webpack_require__(/*! ./tile/TileAdmin */ "./lib/tile/TileAdmin.js");
const EntityState_1 = __webpack_require__(/*! ./EntityState */ "./lib/EntityState.js");
const idleTool = __webpack_require__(/*! ./tools/IdleTool */ "./lib/tools/IdleTool.js");
const selectTool = __webpack_require__(/*! ./tools/SelectTool */ "./lib/tools/SelectTool.js");
const pluginTool = __webpack_require__(/*! ./tools/PluginTool */ "./lib/tools/PluginTool.js");
const viewTool = __webpack_require__(/*! ./tools/ViewTool */ "./lib/tools/ViewTool.js");
const clipViewTool = __webpack_require__(/*! ./tools/ClipViewTool */ "./lib/tools/ClipViewTool.js");
const measureTool = __webpack_require__(/*! ./tools/MeasureTool */ "./lib/tools/MeasureTool.js");
const modelState = __webpack_require__(/*! ./ModelState */ "./lib/ModelState.js");
const sheetState = __webpack_require__(/*! ./Sheet */ "./lib/Sheet.js");
const viewState = __webpack_require__(/*! ./ViewState */ "./lib/ViewState.js");
const displayStyleState = __webpack_require__(/*! ./DisplayStyleState */ "./lib/DisplayStyleState.js");
const modelselector = __webpack_require__(/*! ./ModelSelectorState */ "./lib/ModelSelectorState.js");
const categorySelectorState = __webpack_require__(/*! ./CategorySelectorState */ "./lib/CategorySelectorState.js");
const auxCoordState = __webpack_require__(/*! ./AuxCoordSys */ "./lib/AuxCoordSys.js");
const FrontendLoggerCategory_1 = __webpack_require__(/*! ./FrontendLoggerCategory */ "./lib/FrontendLoggerCategory.js");
/**
 * Global singleton that connects the user interface with the iModel.js services. There can be only one IModelApp active in a session. All
 * members of IModelApp are static, and it serves as a singleton object for gaining access to session information.
 *
 * Before any interactive operations may be performed by the `@bentley/imodeljs-frontend package`, [[IModelApp.startup]] must be called.
 * Applications may customize the frontend behavior of iModel.js by supplying options to [[IModelApp.startup]].
 *
 * @public
 */
class IModelApp {
    // No instances or subclasses of IModelApp may be created. All members are static and must be on the singleton object IModelApp.
    constructor() { }
    /** The [[RenderSystem]] for this session. */
    static get renderSystem() { return this._renderSystem; }
    /** The [[ViewManager]] for this session. */
    static get viewManager() { return this._viewManager; }
    /** The [[NotificationManager]] for this session. */
    static get notifications() { return this._notifications; }
    /** The [[TileAdmin]] for this session.
     * @alpha
     */
    static get tileAdmin() { return this._tileAdmin; }
    /** The [[QuantityFormatter]] for this session.
     * @alpha
     */
    static get quantityFormatter() { return this._quantityFormatter; }
    /** The [[ToolAdmin]] for this session. */
    static get toolAdmin() { return this._toolAdmin; }
    /** The [[AccuDraw]] for this session.
     * @internal
     */
    static get accuDraw() { return this._accuDraw; }
    /** The [[AccuSnap]] for this session. */
    static get accuSnap() { return this._accuSnap; }
    /** @internal */
    static get locateManager() { return this._locateManager; }
    /** @internal */
    static get tentativePoint() { return this._tentativePoint; }
    /** The [[I18N]] for this session. */
    static get i18n() { return this._i18n; }
    /** The [[SettingsAdmin]] for this session. */
    static get settings() { return this._settings; }
    /** The Id of this application. Applications must set this to the Global Product Registry ID (GPRID) for usage logging. */
    static get applicationId() { return this._applicationId; }
    /** The version of this application. Must be set for usage logging. */
    static get applicationVersion() { return this._applicationVersion; }
    /** @internal */
    static get initialized() { return this._initialized; }
    /** The [[IModelClient]] for this session. */
    static get iModelClient() { return this._imodelClient; }
    /** @internal */
    static get hasRenderSystem() { return this._renderSystem !== undefined && this._renderSystem.isValid; }
    /** @internal */
    static get terrainProvider() { return this._terrainProvider; }
    /** Register all of the subclasses of EntityState from a module.
     * @internal
     */
    static registerModuleEntities(moduleObj) {
        for (const thisMember in moduleObj) {
            if (!thisMember)
                continue;
            const thisEntityState = moduleObj[thisMember];
            if (thisEntityState.prototype instanceof EntityState_1.EntityState) {
                this.registerEntityState(thisEntityState.classFullName, thisEntityState);
            }
        }
    }
    /** Register an EntityState class by its classFullName
     * @internal
     */
    static registerEntityState(classFullName, classType) {
        const lowerName = classFullName.toLowerCase();
        if (this._entityClasses.has(lowerName)) {
            const errMsg = "Class " + classFullName + " is already registered. Make sure static schemaName and className members are correct on class " + classType.name;
            bentleyjs_core_1.Logger.logError(FrontendLoggerCategory_1.FrontendLoggerCategory.IModelConnection, errMsg);
            throw new Error(errMsg);
        }
        this._entityClasses.set(lowerName, classType);
    }
    /** @internal */
    static lookupEntityClass(classFullName) { return this._entityClasses.get(classFullName.toLowerCase()); }
    /**
     * Obtain WebGL rendering compatibility information for the client system.  This information describes whether the client meets the
     * minimum rendering capabilities.  It also describes whether the system lacks any optional capabilities that could improve quality
     * and/or performance.
     * @beta
     */
    static queryRenderCompatibility() { return System_2.System.queryRenderCompatibility(); }
    /**
     * This method must be called before any iModel.js frontend services are used.
     * In your code, somewhere before you use any iModel.js services, call [[IModelApp.startup]]. E.g.:
     * ``` ts
     * IModelApp.startup( {applicationId: myAppId, i18n: myi18Opts} );
     * ```
     * @param opts The options for configuring IModelApp
     */
    static startup(opts) {
        opts = opts ? opts : {};
        if (this._initialized)
            throw new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.AlreadyLoaded, "startup may only be called once");
        // Setup a current context for all requests that originate from this frontend
        const requestContext = new FrontendRequestContext_1.FrontendRequestContext();
        requestContext.enter();
        this._initialized = true;
        // Initialize basic application details before log messages are sent out
        this.sessionId = (opts.sessionId !== undefined) ? opts.sessionId : bentleyjs_core_1.Guid.createValue();
        this._applicationId = (opts.applicationId !== undefined) ? opts.applicationId : "2686"; // Default to product id of iModel.js
        this._applicationVersion = (opts.applicationVersion !== undefined) ? opts.applicationVersion : ( true ? "1.0.0" : undefined);
        this.authorizationClient = opts.authorizationClient;
        this._imodelClient = (opts.imodelClient !== undefined) ? opts.imodelClient : new imodeljs_clients_1.IModelHubClient();
        this._setupRpcRequestContext();
        // get the localization system set up so registering tools works. At startup, the only namespace is the system namespace.
        this._i18n = (opts.i18n instanceof imodeljs_i18n_1.I18N) ? opts.i18n : new imodeljs_i18n_1.I18N("iModelJs", opts.i18n);
        const tools = this.tools; // first register all the core tools. Subclasses may choose to override them.
        const coreNamespace = this.i18n.registerNamespace("CoreTools");
        tools.registerModule(selectTool, coreNamespace);
        tools.registerModule(idleTool, coreNamespace);
        tools.registerModule(viewTool, coreNamespace);
        tools.registerModule(clipViewTool, coreNamespace);
        tools.registerModule(measureTool, coreNamespace);
        tools.registerModule(pluginTool, coreNamespace);
        this.registerEntityState(EntityState_1.EntityState.classFullName, EntityState_1.EntityState);
        this.registerModuleEntities(modelState);
        this.registerModuleEntities(sheetState);
        this.registerModuleEntities(viewState);
        this.registerModuleEntities(displayStyleState);
        this.registerModuleEntities(modelselector);
        this.registerModuleEntities(categorySelectorState);
        this.registerModuleEntities(auxCoordState);
        this._renderSystem = (opts.renderSys instanceof System_1.RenderSystem) ? opts.renderSys : this.createRenderSys(opts.renderSys);
        // the startup function may have already allocated any of these members, so first test whether they're present
        this._settings = (opts.settings !== undefined) ? opts.settings : new imodeljs_clients_1.ConnectSettingsClient(this.applicationId);
        this._viewManager = (opts.viewManager !== undefined) ? opts.viewManager : new ViewManager_1.ViewManager();
        this._tileAdmin = (opts.tileAdmin !== undefined) ? opts.tileAdmin : TileAdmin_1.TileAdmin.create();
        this._notifications = (opts.notifications !== undefined) ? opts.notifications : new NotificationManager_1.NotificationManager();
        this._toolAdmin = (opts.toolAdmin !== undefined) ? opts.toolAdmin : new ToolAdmin_1.ToolAdmin();
        this._accuDraw = (opts.accuDraw !== undefined) ? opts.accuDraw : new AccuDraw_1.AccuDraw();
        this._accuSnap = (opts.accuSnap !== undefined) ? opts.accuSnap : new AccuSnap_1.AccuSnap();
        this._locateManager = (opts.locateManager !== undefined) ? opts.locateManager : new ElementLocateManager_1.ElementLocateManager();
        this._tentativePoint = (opts.tentativePoint !== undefined) ? opts.tentativePoint : new TentativePoint_1.TentativePoint();
        this._quantityFormatter = (opts.quantityFormatter !== undefined) ? opts.quantityFormatter : new QuantityFormatter_1.QuantityFormatter();
        this._terrainProvider = opts.terrainProvider; // TBD... (opts.terrainProvider !== undefined) ? opts.terrainProvider : new WorldTerrainProvider();
        this.renderSystem.onInitialized();
        this.viewManager.onInitialized();
        this.toolAdmin.onInitialized();
        this.accuDraw.onInitialized();
        this.accuSnap.onInitialized();
        this.locateManager.onInitialized();
        this.tentativePoint.onInitialized();
        if (this._terrainProvider)
            this._terrainProvider.onInitialized();
    }
    /** Must be called before the application exits to release any held resources. */
    static shutdown() {
        if (this._initialized) {
            this.toolAdmin.onShutDown();
            this.viewManager.onShutDown();
            this.tileAdmin.onShutDown();
            this._renderSystem = bentleyjs_core_1.dispose(this._renderSystem);
            this._entityClasses.clear();
            this._initialized = false;
        }
    }
    /** @internal */
    static createRenderSys(opts) { return System_2.System.create(opts); }
    static _setupRpcRequestContext() {
        imodeljs_common_1.RpcConfiguration.requestContext.getId = (_request) => {
            const id = bentleyjs_core_1.ClientRequestContext.current.useContextForRpc ? bentleyjs_core_1.ClientRequestContext.current.activityId : bentleyjs_core_1.Guid.createValue(); // Use any context explicitly set for an RPC call if possible
            bentleyjs_core_1.ClientRequestContext.current.useContextForRpc = false; // Reset flag so it doesn't get used inadvertently for next RPC call
            return id;
        };
        imodeljs_common_1.RpcConfiguration.requestContext.serialize = async (_request) => {
            const id = _request.id;
            let authorization;
            let userId;
            if (IModelApp.authorizationClient) {
                // todo: need to subscribe to token change events to avoid getting the string equivalent and compute length
                const accessToken = await IModelApp.authorizationClient.getAccessToken();
                authorization = accessToken.toTokenString(imodeljs_clients_1.IncludePrefix.Yes);
                userId = accessToken.getUserInfo().id;
            }
            return {
                id,
                applicationId: this.applicationId,
                applicationVersion: this.applicationVersion,
                sessionId: this.sessionId,
                authorization,
                userId,
            };
        };
    }
}
IModelApp._initialized = false;
/** The [[ToolRegistry]] for this session. */
IModelApp.tools = new Tool_1.ToolRegistry();
/** Map of classFullName to EntityState class */
IModelApp._entityClasses = new Map();
exports.IModelApp = IModelApp;


/***/ }),

/***/ "./lib/IModelConnection.js":
/*!*********************************!*\
  !*** ./lib/IModelConnection.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module IModelConnection */
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
var __await = (this && this.__await) || function (v) { return this instanceof __await ? (this.v = v, this) : new __await(v); }
var __asyncGenerator = (this && this.__asyncGenerator) || function (thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), i, q = [];
    return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const GeoServices_1 = __webpack_require__(/*! ./GeoServices */ "./lib/GeoServices.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const FrontendLoggerCategory_1 = __webpack_require__(/*! ./FrontendLoggerCategory */ "./lib/FrontendLoggerCategory.js");
const ModelState_1 = __webpack_require__(/*! ./ModelState */ "./lib/ModelState.js");
const SelectionSet_1 = __webpack_require__(/*! ./SelectionSet */ "./lib/SelectionSet.js");
const ViewState_1 = __webpack_require__(/*! ./ViewState */ "./lib/ViewState.js");
const FrontendRequestContext_1 = __webpack_require__(/*! ./FrontendRequestContext */ "./lib/FrontendRequestContext.js");
const SubCategoriesCache_1 = __webpack_require__(/*! ./SubCategoriesCache */ "./lib/SubCategoriesCache.js");
const TileTree_1 = __webpack_require__(/*! ./tile/TileTree */ "./lib/tile/TileTree.js");
const loggerCategory = FrontendLoggerCategory_1.FrontendLoggerCategory.IModelConnection;
/** A connection to an iModel database hosted on the backend.
 * @public
 */
class IModelConnection extends imodeljs_common_1.IModel {
    constructor(iModel, openMode) {
        super(imodeljs_common_1.IModelToken.fromJSON(iModel.iModelToken));
        /** Generator for unique Ids of transient graphics for this IModelConnection. */
        this.transientIds = new bentleyjs_core_1.TransientIdSequence();
        /** The set of Context Reality Model tile trees for this IModelConnection.
         * @internal
         */
        this._contextRealityModelTileTrees = new Map();
        this._reopenConnectionHandler = async (request, response, resubmit, reject) => {
            if (!(response instanceof imodeljs_common_1.IModelNotFoundResponse))
                return;
            const iModelToken = request.parameters[0];
            if (this._token.key !== iModelToken.key)
                return; // The handler is called for a different connection than this
            const requestContext = await FrontendRequestContext_1.AuthorizedFrontendRequestContext.create(request.id); // Reuse activityId
            requestContext.enter();
            bentleyjs_core_1.Logger.logTrace(loggerCategory, "Attempting to reopen connection", () => iModelToken);
            try {
                const openResponse = await IModelConnection.callOpen(requestContext, iModelToken, this.openMode);
                this._token = imodeljs_common_1.IModelToken.fromJSON(openResponse.iModelToken);
            }
            catch (error) {
                reject(error.message);
            }
            finally {
                requestContext.enter();
            }
            bentleyjs_core_1.Logger.logTrace(loggerCategory, "Resubmitting original request after reopening connection", () => iModelToken);
            request.parameters[0] = this._token; // Modify the token of the original request before resubmitting it.
            resubmit();
        };
        super.initialize(iModel.name, iModel);
        this.openMode = openMode;
        this.models = new IModelConnection.Models(this);
        this.elements = new IModelConnection.Elements(this);
        this.codeSpecs = new IModelConnection.CodeSpecs(this);
        this.views = new IModelConnection.Views(this);
        this.selectionSet = new SelectionSet_1.SelectionSet(this);
        this.hilited = new SelectionSet_1.HiliteSet(this);
        this.tiles = new IModelConnection.Tiles(this);
        this.subcategories = new SubCategoriesCache_1.SubCategoriesCache(this);
        this.geoServices = new GeoServices_1.GeoServices(this);
    }
    /** Check the [[openMode]] of this IModelConnection to see if it was opened read-only. */
    get isReadonly() { return this.openMode === bentleyjs_core_1.OpenMode.Readonly; }
    /** Check if the IModelConnection is still open. Returns false after [[IModelConnection.close]] has been called.
     * @alpha
     */
    get isOpen() { return undefined !== this._token; }
    /** Check if the IModelConnection has been closed. Returns true after [[IModelConnection.close]] has been called.
     * @alpha
     */
    get isClosed() { return !this.isOpen; }
    /** Load the FontMap for this IModelConnection.
     * @returns Returns a Promise<FontMap> that is fulfilled when the FontMap member of this IModelConnection is valid.
     */
    async loadFontMap() {
        return this.fontMap || (this.fontMap = new imodeljs_common_1.FontMap(JSON.parse(await imodeljs_common_1.IModelReadRpcInterface.getClient().readFontJson(this.iModelToken.toJSON()))));
    }
    /** Get the context reality model tile tree for a URL.
     * @internal
     */
    getContextRealityModelTileTree(url) {
        const found = this._contextRealityModelTileTrees.get(url);
        if (found !== undefined)
            return found;
        const tileTree = new TileTree_1.TileTreeState(this, true, this.transientIds.next);
        this._contextRealityModelTileTrees.set(url, tileTree);
        return tileTree;
    }
    /** Find the first registered base class of the given EntityState className. This class will "handle" the State for the supplied className.
     * @param className The full name of the class of interest.
     * @param defaultClass If no base class of the className is registered, return this value.
     * @note this method is async since it may have to query the server to get the class hierarchy.
     */
    async findClassFor(className, defaultClass) {
        let ctor = IModelApp_1.IModelApp.lookupEntityClass(className);
        if (undefined !== ctor)
            return ctor;
        // it's not registered, we need to query its class hierarchy.
        ctor = defaultClass; // in case we cant find a registered class that handles this class
        // wait until we get the full list of base classes from backend
        const baseClasses = await imodeljs_common_1.IModelReadRpcInterface.getClient().getClassHierarchy(this.iModelToken.toJSON(), className);
        // walk through the list until we find a registered base class
        baseClasses.some((baseClass) => {
            const test = IModelApp_1.IModelApp.lookupEntityClass(baseClass);
            if (test === undefined)
                return false; // nope, not registered
            ctor = test; // found it, save it
            IModelApp_1.IModelApp.registerEntityState(className, ctor); // and register the fact that our starting class is handled by this subclass.
            return true; // stop
        });
        return ctor; // either the baseClass handler or defaultClass if we didn't find a registered baseClass
    }
    /** Open an IModelConnection to an iModel. It's recommended that every open call be matched with a corresponding call to close. */
    static async open(contextId, iModelId, openMode = bentleyjs_core_1.OpenMode.Readonly, version = imodeljs_common_1.IModelVersion.latest()) {
        if (!IModelApp_1.IModelApp.initialized)
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "Call IModelApp.startup() before calling open");
        const requestContext = await FrontendRequestContext_1.AuthorizedFrontendRequestContext.create();
        requestContext.enter();
        const changeSetId = await version.evaluateChangeSet(requestContext, iModelId, IModelApp_1.IModelApp.iModelClient);
        requestContext.enter();
        const iModelToken = new imodeljs_common_1.IModelToken(undefined, contextId, iModelId, changeSetId, openMode);
        const openResponse = await IModelConnection.callOpen(requestContext, iModelToken, openMode);
        requestContext.enter();
        const connection = new IModelConnection(openResponse, openMode);
        imodeljs_common_1.RpcRequest.notFoundHandlers.addListener(connection._reopenConnectionHandler);
        return connection;
    }
    static async callOpen(requestContext, iModelToken, openMode) {
        requestContext.enter();
        // Try opening the iModel repeatedly accommodating any pending responses from the backend.
        // Waits for an increasing amount of time (but within a range) before checking on the pending request again.
        const connectionRetryIntervalRange = { min: 100, max: 5000 }; // in milliseconds
        let connectionRetryInterval = Math.min(connectionRetryIntervalRange.min, IModelConnection.connectionTimeout);
        let openForReadOperation;
        let openForWriteOperation;
        if (openMode === bentleyjs_core_1.OpenMode.Readonly) {
            openForReadOperation = imodeljs_common_1.RpcOperation.lookup(imodeljs_common_1.IModelReadRpcInterface, "openForRead");
            if (!openForReadOperation)
                throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "IModelReadRpcInterface.openForRead() is not available");
            openForReadOperation.policy.retryInterval = () => connectionRetryInterval;
        }
        else {
            openForWriteOperation = imodeljs_common_1.RpcOperation.lookup(imodeljs_common_1.IModelWriteRpcInterface, "openForWrite");
            if (!openForWriteOperation)
                throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "IModelWriteRpcInterface.openForWrite() is not available");
            openForWriteOperation.policy.retryInterval = () => connectionRetryInterval;
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Received open request in IModelConnection.open`, () => iModelToken);
        bentleyjs_core_1.Logger.logTrace(loggerCategory, `Setting retry interval in IModelConnection.open`, () => (Object.assign({}, iModelToken, { connectionRetryInterval })));
        const startTime = Date.now();
        const removeListener = imodeljs_common_1.RpcRequest.events.addListener((type, request) => {
            if (type !== imodeljs_common_1.RpcRequestEvent.PendingUpdateReceived)
                return;
            if (!(openForReadOperation && request.operation === openForReadOperation) && !(openForWriteOperation && request.operation === openForWriteOperation))
                return;
            requestContext.enter();
            bentleyjs_core_1.Logger.logTrace(loggerCategory, "Received pending open notification in IModelConnection.open", () => iModelToken);
            const connectionTimeElapsed = Date.now() - startTime;
            if (connectionTimeElapsed > IModelConnection.connectionTimeout) {
                bentleyjs_core_1.Logger.logError(loggerCategory, `Timed out opening connection in IModelConnection.open (took longer than ${IModelConnection.connectionTimeout} milliseconds)`, () => iModelToken);
                throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "Opening a connection was timed out"); // NEEDS_WORK: More specific error status
            }
            connectionRetryInterval = Math.min(connectionRetryIntervalRange.max, connectionRetryInterval * 2, IModelConnection.connectionTimeout - connectionTimeElapsed);
            if (request.retryInterval !== connectionRetryInterval) {
                request.retryInterval = connectionRetryInterval;
                bentleyjs_core_1.Logger.logTrace(loggerCategory, `Adjusted open connection retry interval to ${request.retryInterval} milliseconds in IModelConnection.open`, () => iModelToken);
            }
        });
        let openPromise;
        requestContext.useContextForRpc = true;
        if (openMode === bentleyjs_core_1.OpenMode.ReadWrite)
            openPromise = imodeljs_common_1.IModelWriteRpcInterface.getClient().openForWrite(iModelToken.toJSON());
        else
            openPromise = imodeljs_common_1.IModelReadRpcInterface.getClient().openForRead(iModelToken.toJSON());
        let openResponse;
        try {
            openResponse = await openPromise;
        }
        finally {
            requestContext.enter();
            bentleyjs_core_1.Logger.logTrace(loggerCategory, "Completed open request in IModelConnection.open", () => iModelToken);
            removeListener();
        }
        return openResponse;
    }
    /** Close this IModelConnection
     * In the case of ReadWrite connections ensure all changes are pushed to the iModelHub before making this call -
     * any un-pushed changes are lost after the close.
     */
    async close() {
        if (!this.iModelToken)
            return;
        const requestContext = await FrontendRequestContext_1.AuthorizedFrontendRequestContext.create();
        requestContext.enter();
        imodeljs_common_1.RpcRequest.notFoundHandlers.removeListener(this._reopenConnectionHandler);
        IModelConnection.onClose.raiseEvent(this);
        this.models.onIModelConnectionClose(); // free WebGL resources if rendering
        requestContext.useContextForRpc = true;
        const closePromise = imodeljs_common_1.IModelReadRpcInterface.getClient().close(this.iModelToken.toJSON()); // Ensure the method isn't await-ed right away.
        try {
            await closePromise;
        }
        finally {
            this._token = undefined; // prevent closed connection from being reused
            this.subcategories.onIModelConnectionClose();
        }
    }
    /** Open an IModelConnection to a read-only iModel *snapshot* (not managed by iModelHub) from a file name that is resolved by the backend.
     * This method is intended for desktop or mobile applications and should not be used for web applications.
     * @beta
     */
    static async openSnapshot(fileName) {
        const openResponse = await imodeljs_common_1.SnapshotIModelRpcInterface.getClient().openSnapshot(fileName);
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "IModelConnection.openSnapshot", () => ({ fileName }));
        return new IModelConnection(openResponse, bentleyjs_core_1.OpenMode.Readonly);
    }
    /** Close this IModelConnection to a read-only iModel *snapshot*.
     * @beta
     */
    async closeSnapshot() {
        if (!this.iModelToken)
            return;
        IModelConnection.onClose.raiseEvent(this);
        this.models.onIModelConnectionClose(); // free WebGL resources if rendering
        try {
            await imodeljs_common_1.SnapshotIModelRpcInterface.getClient().closeSnapshot(this.iModelToken.toJSON());
        }
        finally {
            this._token = undefined; // prevent closed connection from being reused
            this.subcategories.onIModelConnectionClose();
        }
    }
    /** Compute number of rows that would be returned by the ECSQL.
     *
     * See also:
     * - [ECSQL Overview]($docs/learning/backend/ExecutingECSQL)
     * - [Code Examples]($docs/learning/backend/ECSQLCodeExamples)
     *
     * @param ecsql The ECSQL statement to execute
     * @param bindings The values to bind to the parameters (if the ECSQL has any).
     * Pass an *array* of values if the parameters are *positional*.
     * Pass an *object of the values keyed on the parameter name* for *named parameters*.
     * The values in either the array or object must match the respective types of the parameters.
     * See "[iModel.js Types used in ECSQL Parameter Bindings]($docs/learning/ECSQLParameterTypes)" for details.
     * @returns Return row count.
     * @throws [IModelError]($common) If the statement is invalid
     */
    async queryRowCount(ecsql, bindings) {
        var e_1, _a;
        try {
            for (var _b = __asyncValues(this.query(`select count(*) nRows from (${ecsql})`, bindings)), _c; _c = await _b.next(), !_c.done;) {
                const row = _c.value;
                return row.nRows;
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
            }
            finally { if (e_1) throw e_1.error; }
        }
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "IModelConnection.queryRowCount", () => (Object.assign({}, this.iModelToken, { ecsql, bindings })));
        throw new imodeljs_common_1.IModelError(bentleyjs_core_1.DbResult.BE_SQLITE_ERROR, "Failed to get row count");
    }
    /** Execute a query against this ECDb but restricted by quota and limit settings. This is intended to be used internally
     * The result of the query is returned as an array of JavaScript objects where every array element represents an
     * [ECSQL row]($docs/learning/ECSQLRowFormat).
     *
     * See also:
     * - [ECSQL Overview]($docs/learning/backend/ExecutingECSQL)
     * - [Code Examples]($docs/learning/backend/ECSQLCodeExamples)
     *
     * @param ecsql The ECSQL statement to execute
     * @param bindings The values to bind to the parameters (if the ECSQL has any).
     * Pass an *array* of values if the parameters are *positional*.
     * Pass an *object of the values keyed on the parameter name* for *named parameters*.
     * The values in either the array or object must match the respective types of the parameters.
     * See "[iModel.js Types used in ECSQL Parameter Bindings]($docs/learning/ECSQLParameterTypes)" for details.
     * @param limitRows Specify upper limit for rows that can be returned by the query.
     * @param quota Specify non binding quota. These values are constrained by global setting
     * but never the less can be specified to narrow down the quota constraint for the query but staying under global settings.
     * @param priority Specify non binding priority for the query. It can help user to adjust
     * priority of query in queue so that small and quicker queries can be prioritized over others.
     * @returns Returns structure containing rows and status.
     * See [ECSQL row format]($docs/learning/ECSQLRowFormat) for details about the format of the returned rows.
     * @internal
     */
    async queryRows(ecsql, bindings, limit, quota, priority) {
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "IModelConnection.queryRows", () => (Object.assign({}, this.iModelToken, { ecsql, bindings, limit, quota, priority })));
        return imodeljs_common_1.IModelReadRpcInterface.getClient().queryRows(this.iModelToken.toJSON(), ecsql, bindings, limit, quota, priority);
    }
    /** Execute a query and stream its results
     * The result of the query is async iterator over the rows. The iterator will get next page automatically once rows in current page has been read.
     * [ECSQL row]($docs/learning/ECSQLRowFormat).
     *
     * See also:
     * - [ECSQL Overview]($docs/learning/backend/ExecutingECSQL)
     * - [Code Examples]($docs/learning/backend/ECSQLCodeExamples)
     *
     * @param ecsql The ECSQL statement to execute
     * @param bindings The values to bind to the parameters (if the ECSQL has any).
     * Pass an *array* of values if the parameters are *positional*.
     * Pass an *object of the values keyed on the parameter name* for *named parameters*.
     * The values in either the array or object must match the respective types of the parameters.
     * See "[iModel.js Types used in ECSQL Parameter Bindings]($docs/learning/ECSQLParameterTypes)" for details.
     * @param limitRows Specify upper limit for rows that can be returned by the query.
     * @param quota Specify non binding quota. These values are constrained by global setting
     * but never the less can be specified to narrow down the quota constraint for the query but staying under global settings.
     * @param priority Specify non binding priority for the query. It can help user to adjust
     * priority of query in queue so that small and quicker queries can be prioritized over others.
     * @returns Returns the query result as an *AsyncIterableIterator<any>*  which lazy load result as needed
     * See [ECSQL row format]($docs/learning/ECSQLRowFormat) for details about the format of the returned rows.
     * @throws [IModelError]($common) If there was any error while submitting, preparing or stepping into query
     * @alpha
     */
    query(ecsql, bindings, limitRows, quota, priority) {
        return __asyncGenerator(this, arguments, function* query_1() {
            let result;
            let offset = 0;
            let rowsToGet = limitRows ? limitRows : -1;
            do {
                result = yield __await(this.queryRows(ecsql, bindings, { maxRowAllowed: rowsToGet, startRowOffset: offset }, quota, priority));
                while (result.status === imodeljs_common_1.QueryResponseStatus.Timeout) {
                    result = yield __await(this.queryRows(ecsql, bindings, { maxRowAllowed: rowsToGet, startRowOffset: offset }, quota, priority));
                }
                if (result.status === imodeljs_common_1.QueryResponseStatus.Error)
                    throw new imodeljs_common_1.IModelError(imodeljs_common_1.QueryResponseStatus.Error, "Failed to execute ECSQL");
                if (rowsToGet > 0) {
                    rowsToGet -= result.rows.length;
                }
                offset += result.rows.length;
                for (const row of result.rows)
                    yield yield __await(row);
            } while (result.status !== imodeljs_common_1.QueryResponseStatus.Done);
        });
    }
    /** Query for a set of element ids that satisfy the supplied query params
     * @param params The query parameters. The `limit` and `offset` members should be used to page results.
     * @throws [IModelError]($common) If the generated statement is invalid or would return too many rows.
     */
    async queryEntityIds(params) { return new Set(await imodeljs_common_1.IModelReadRpcInterface.getClient().queryEntityIds(this.iModelToken.toJSON(), params)); }
    /** Update the project extents of this iModel.
     * @param newExtents The new project extents as an AxisAlignedBox3d
     * @throws [[IModelError]] if the IModelConnection is read-only or there is a problem updating the extents.
     */
    async updateProjectExtents(newExtents) {
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "IModelConnection.updateProjectExtents", () => (Object.assign({}, this.iModelToken, { newExtents })));
        if (bentleyjs_core_1.OpenMode.ReadWrite !== this.openMode)
            return Promise.reject(new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.ReadOnly, "IModelConnection was opened read-only", bentleyjs_core_1.Logger.logError));
        return imodeljs_common_1.IModelWriteRpcInterface.getClient().updateProjectExtents(this.iModelToken.toJSON(), newExtents.toJSON());
    }
    /** Commit pending changes to this iModel
     * @param description Optional description of the changes
     * @throws [[IModelError]] if the IModelConnection is read-only or there is a problem saving changes.
     */
    async saveChanges(description) {
        bentleyjs_core_1.Logger.logTrace(loggerCategory, "IModelConnection.saveChanges", () => (Object.assign({}, this.iModelToken, { description })));
        if (bentleyjs_core_1.OpenMode.ReadWrite !== this.openMode)
            return Promise.reject(new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.ReadOnly, "IModelConnection was opened read-only", bentleyjs_core_1.Logger.logError));
        return imodeljs_common_1.IModelWriteRpcInterface.getClient().saveChanges(this.iModelToken.toJSON(), description);
    }
    /** WIP - Determines whether the *Change Cache file* is attached to this iModel or not.
     * See also [Change Summary Overview]($docs/learning/ChangeSummaries)
     * @returns Returns true if the *Change Cache file* is attached to the iModel. false otherwise
     * @internal
     */
    async changeCacheAttached() { return imodeljs_common_1.WipRpcInterface.getClient().isChangeCacheAttached(this.iModelToken.toJSON()); }
    /** WIP - Attaches the *Change Cache file* to this iModel if it hasn't been attached yet.
     * A new *Change Cache file* will be created for the iModel if it hasn't existed before.
     * See also [Change Summary Overview]($docs/learning/ChangeSummaries)
     * @throws [IModelError]($common) if a Change Cache file has already been attached before.
     * @internal
     */
    async attachChangeCache() { return imodeljs_common_1.WipRpcInterface.getClient().attachChangeCache(this.iModelToken.toJSON()); }
    /** WIP - Detaches the *Change Cache file* to this iModel if it had been attached before.
     * > You do not have to check whether a Change Cache file had been attached before. The
     * > method does not do anything, if no Change Cache is attached.
     * See also [Change Summary Overview]($docs/learning/ChangeSummaries)
     * @internal
     */
    async detachChangeCache() { return imodeljs_common_1.WipRpcInterface.getClient().detachChangeCache(this.iModelToken.toJSON()); }
    /** Request a snap from the backend. */
    async requestSnap(props) { return imodeljs_common_1.IModelReadRpcInterface.getClient().requestSnap(this.iModelToken.toJSON(), IModelApp_1.IModelApp.sessionId, props); }
    /** Request a tooltip from the backend.  */
    async getToolTipMessage(id) { return imodeljs_common_1.IModelReadRpcInterface.getClient().getToolTipMessage(this.iModelToken.toJSON(), id); }
    /** Convert a point in this iModel's Spatial coordinates to a [[Cartographic]] using the Geographic location services for this IModelConnection.
     * @param spatial A point in the iModel's spatial coordinates
     * @param result If defined, use this for output
     * @returns A Cartographic location
     * @throws IModelError if [[isGeoLocated]] is false or point could not be converted.
     */
    async spatialToCartographicFromGcs(spatial, result) {
        if (undefined === this._noGcsDefined && !this.isGeoLocated)
            this._noGcsDefined = true;
        if (this._noGcsDefined)
            throw new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.NoGeoLocation, "iModel does not have a Geographic Coordinate system. It may be Geolocated with an EcefTransform");
        const geoConverter = this.geoServices.getConverter();
        const coordResponse = await geoConverter.getGeoCoordinatesFromIModelCoordinates([spatial]);
        if (this._noGcsDefined = (1 !== coordResponse.geoCoords.length || imodeljs_common_1.GeoCoordStatus.NoGCSDefined === coordResponse.geoCoords[0].s))
            throw new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.NoGeoLocation, "iModel does not have a Geographic Coordinate system. It may be Geolocated with an EcefTransform");
        if (imodeljs_common_1.GeoCoordStatus.Success !== coordResponse.geoCoords[0].s)
            throw new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.BadRequest, "Error converting spatial to cartographic");
        const longLatHeight = geometry_core_1.Point3d.fromJSON(coordResponse.geoCoords[0].p); // x is longitude in degrees, y is latitude in degrees, z is height in meters...
        return imodeljs_common_1.Cartographic.fromDegrees(longLatHeight.x, longLatHeight.y, longLatHeight.z, result);
    }
    /** Convert a point in this iModel's Spatial coordinates to a [[Cartographic]] using the Geographic location services for this IModelConnection or [[IModel.ecefLocation]].
     * @param spatial A point in the iModel's spatial coordinates
     * @param result If defined, use this for output
     * @returns A Cartographic location
     * @throws IModelError if [[isGeoLocated]] is false or point could not be converted.
     * @see [[spatialToCartographicFromGcs]]
     * @see [[spatialToCartographicFromEcef]]
     */
    async spatialToCartographic(spatial, result) {
        if (undefined === this._noGcsDefined) {
            try {
                return await this.spatialToCartographicFromGcs(spatial, result);
            }
            catch (error) {
                if (!this._noGcsDefined)
                    throw error;
            }
        }
        return (this._noGcsDefined ? this.spatialToCartographicFromEcef(spatial, result) : this.spatialToCartographicFromGcs(spatial, result));
    }
    /** Convert a [[Cartographic]] to a point in this iModel's Spatial coordinates using the Geographic location services for this IModelConnection.
     * @param cartographic A cartographic location
     * @param result If defined, use this for output
     * @returns A point in this iModel's spatial coordinates
     * @throws IModelError if [[isGeoLocated]] is false or cartographic location could not be converted.
     */
    async cartographicToSpatialFromGcs(cartographic, result) {
        if (undefined === this._noGcsDefined && !this.isGeoLocated)
            this._noGcsDefined = true;
        if (this._noGcsDefined)
            throw new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.NoGeoLocation, "iModel does not have a Geographic Coordinate system. It may be Geolocated with an EcefTransform");
        const geoConverter = this.geoServices.getConverter();
        const geoCoord = geometry_core_1.Point3d.create(geometry_core_1.Angle.radiansToDegrees(cartographic.longitude), geometry_core_1.Angle.radiansToDegrees(cartographic.latitude), cartographic.height); // x is longitude in degrees, y is latitude in degrees, z is height in meters...
        const coordResponse = await geoConverter.getIModelCoordinatesFromGeoCoordinates([geoCoord]);
        if (this._noGcsDefined = (1 !== coordResponse.iModelCoords.length || imodeljs_common_1.GeoCoordStatus.NoGCSDefined === coordResponse.iModelCoords[0].s))
            throw new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.NoGeoLocation, "iModel does not have a Geographic Coordinate system. It may be Geolocated with an EcefTransform");
        if (imodeljs_common_1.GeoCoordStatus.Success !== coordResponse.iModelCoords[0].s)
            throw new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.BadRequest, "Error converting cartographic to spatial");
        result = result ? result : geometry_core_1.Point3d.createZero();
        result.setFromJSON(coordResponse.iModelCoords[0].p);
        return result;
    }
    /** Convert a [[Cartographic]] to a point in this iModel's Spatial coordinates using the Geographic location services for this IModelConnection or [[IModel.ecefLocation]].
     * @param cartographic A cartographic location
     * @param result If defined, use this for output
     * @returns A point in this iModel's spatial coordinates
     * @throws IModelError if [[isGeoLocated]] is false or cartographic location could not be converted.
     * @see [[cartographicToSpatialFromGcs]]
     * @see [[cartographicToSpatialFromEcef]]
     */
    async cartographicToSpatial(cartographic, result) {
        if (undefined === this._noGcsDefined) {
            try {
                return await this.cartographicToSpatialFromGcs(cartographic, result);
            }
            catch (error) {
                if (!this._noGcsDefined)
                    throw error;
            }
        }
        return (this._noGcsDefined ? this.cartographicToSpatialFromEcef(cartographic, result) : this.cartographicToSpatialFromGcs(cartographic, result));
    }
}
/** The maximum time (in milliseconds) to wait before timing out the request to open a connection to a new iModel */
IModelConnection.connectionTimeout = 10 * 60 * 1000;
/** Event called immediately before an IModelConnection is closed.
 * @note Be careful not to perform any asynchronous operations on the IModelConnection because it will close before they are processed.
 */
IModelConnection.onClose = new bentleyjs_core_1.BeEvent();
exports.IModelConnection = IModelConnection;
/** @public */
(function (IModelConnection) {
    /** The collection of loaded ModelState objects for an [[IModelConnection]]. */
    class Models {
        /** @internal */
        constructor(_iModel) {
            this._iModel = _iModel;
            /** The set of loaded models for this IModelConnection, indexed by Id. */
            this.loaded = new Map();
        }
        /** The Id of the [RepositoryModel]($backend). */
        get repositoryModelId() { return "0x1"; }
        /** Get a batch of [[ModelProps]] given a list of Model ids. */
        async getProps(modelIds) {
            return imodeljs_common_1.IModelReadRpcInterface.getClient().getModelProps(this._iModel.iModelToken.toJSON(), [...bentleyjs_core_1.Id64.toIdSet(modelIds)]);
        }
        /** Find a ModelState in the set of loaded Models by ModelId. */
        getLoaded(id) { return this.loaded.get(id); }
        /** load a set of Models by Ids. After calling this method, you may get the ModelState objects by calling getLoadedModel. */
        async load(modelIds) {
            const notLoaded = new Set();
            bentleyjs_core_1.Id64.forEach(modelIds, (id) => {
                if (undefined === this.getLoaded(id))
                    notLoaded.add(id);
            });
            if (notLoaded.size === 0)
                return; // all requested models are already loaded
            try {
                const propArray = await this.getProps(notLoaded);
                for (const props of propArray) {
                    const ctor = await this._iModel.findClassFor(props.classFullName, ModelState_1.ModelState);
                    const modelState = new ctor(props, this._iModel); // create a new instance of the appropriate ModelState subclass
                    this.loaded.set(modelState.id, modelState); // save it in loaded set
                }
            }
            catch (err) { } // ignore error, we had nothing to do.
        }
        /** Query for a set of model ranges by ModelIds. */
        async queryModelRanges(modelIds) {
            return imodeljs_common_1.IModelReadRpcInterface.getClient().queryModelRanges(this._iModel.iModelToken.toJSON(), [...bentleyjs_core_1.Id64.toIdSet(modelIds)]);
        }
        /** Query for a set of ModelProps of the specified ModelQueryParams.
         * @param queryParams The query parameters. The `limit` and `offset` members should be used to page results.
         * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.
         */
        async queryProps(queryParams) {
            const params = Object.assign({}, queryParams); // make a copy
            params.from = queryParams.from || ModelState_1.ModelState.classFullName; // use "BisCore:Model" as default class name
            params.where = queryParams.where || "";
            if (!queryParams.wantPrivate) {
                if (params.where.length > 0)
                    params.where += " AND ";
                params.where += "IsPrivate=FALSE ";
            }
            if (!queryParams.wantTemplate) {
                if (params.where.length > 0)
                    params.where += " AND ";
                params.where += "IsTemplate=FALSE ";
            }
            return imodeljs_common_1.IModelReadRpcInterface.getClient().queryModelProps(this._iModel.iModelToken.toJSON(), params);
        }
        /** Asynchronously stream ModelProps using the specified ModelQueryParams.
         * @alpha This method will replace IModelConnection.Models.queryProps as soon as auto-paging support is added
         */
        query(queryParams) {
            return __asyncGenerator(this, arguments, function* query_2() {
                // NOTE: this implementation has the desired API signature, but its implementation must be improved to actually page results
                const modelPropsArray = yield __await(this.queryProps(queryParams));
                for (const modelProps of modelPropsArray) {
                    yield yield __await(modelProps);
                }
            });
        }
        /** Code to run when the IModelConnection has closed. */
        onIModelConnectionClose() {
            this.loaded.forEach((value) => {
                value.onIModelConnectionClose();
            });
        }
    }
    IModelConnection.Models = Models;
    /** The collection of Elements for an [[IModelConnection]]. */
    class Elements {
        /** @internal */
        constructor(_iModel) {
            this._iModel = _iModel;
        }
        /** The Id of the [root subject element]($docs/bis/intro/glossary.md#subject-root) for this iModel. */
        get rootSubjectId() { return "0x1"; }
        /** Get a set of element ids that satisfy a query */
        async queryIds(params) { return this._iModel.queryEntityIds(params); }
        /** Get an array of [[ElementProps]] given one or more element ids. */
        async getProps(arg) {
            return imodeljs_common_1.IModelReadRpcInterface.getClient().getElementProps(this._iModel.iModelToken.toJSON(), [...bentleyjs_core_1.Id64.toIdSet(arg)]);
        }
        /** Get an array  of [[ElementProps]] that satisfy a query
         * @param params The query parameters. The `limit` and `offset` members should be used to page results.
         * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.
         */
        async queryProps(params) {
            return imodeljs_common_1.IModelReadRpcInterface.getClient().queryElementProps(this._iModel.iModelToken.toJSON(), params);
        }
    }
    IModelConnection.Elements = Elements;
    /** The collection of [[CodeSpec]] entities for an [[IModelConnection]]. */
    class CodeSpecs {
        /** @internal */
        constructor(_iModel) {
            this._iModel = _iModel;
        }
        /** Loads all CodeSpec from the remote IModelDb. */
        async _loadAllCodeSpecs() {
            if (this._loaded)
                return;
            this._loaded = [];
            const codeSpecArray = await imodeljs_common_1.IModelReadRpcInterface.getClient().getAllCodeSpecs(this._iModel.iModelToken.toJSON());
            for (const codeSpec of codeSpecArray) {
                this._loaded.push(new imodeljs_common_1.CodeSpec(this._iModel, bentleyjs_core_1.Id64.fromString(codeSpec.id), codeSpec.name, codeSpec.jsonProperties));
            }
        }
        /** Look up a CodeSpec by Id.
         * @param codeSpecId The Id of the CodeSpec to load
         * @returns The CodeSpec with the specified Id
         * @throws [[IModelError]] if the Id is invalid or if no CodeSpec with that Id could be found.
         */
        async getById(codeSpecId) {
            if (!bentleyjs_core_1.Id64.isValid(codeSpecId))
                return Promise.reject(new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.InvalidId, "Invalid codeSpecId", bentleyjs_core_1.Logger.logWarning, loggerCategory, () => ({ codeSpecId })));
            await this._loadAllCodeSpecs(); // ensure all codeSpecs have been downloaded
            const found = this._loaded.find((codeSpec) => codeSpec.id === codeSpecId);
            if (!found)
                return Promise.reject(new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.NotFound, "CodeSpec not found", bentleyjs_core_1.Logger.logWarning, loggerCategory));
            return found;
        }
        /** Look up a CodeSpec by name.
         * @param name The name of the CodeSpec to load
         * @returns The CodeSpec with the specified name
         * @throws [[IModelError]] if no CodeSpec with the specified name could be found.
         */
        async getByName(name) {
            await this._loadAllCodeSpecs(); // ensure all codeSpecs have been downloaded
            const found = this._loaded.find((codeSpec) => codeSpec.name === name);
            if (!found)
                return Promise.reject(new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.NotFound, "CodeSpec not found", bentleyjs_core_1.Logger.logWarning, loggerCategory));
            return found;
        }
    }
    IModelConnection.CodeSpecs = CodeSpecs;
    /** The collection of views for an [[IModelConnection]]. */
    class Views {
        /** @internal */
        constructor(_iModel) {
            this._iModel = _iModel;
        }
        /** Query for an array of ViewDefinitionProps
         * @param queryParams Query parameters specifying the views to return. The `limit` and `offset` members should be used to page results.
         * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.
         */
        async queryProps(queryParams) {
            const params = Object.assign({}, queryParams); // make a copy
            params.from = queryParams.from || ViewState_1.ViewState.classFullName; // use "BisCore:ViewDefinition" as default class name
            params.where = queryParams.where || "";
            if (queryParams.wantPrivate === undefined || !queryParams.wantPrivate) {
                if (params.where.length > 0)
                    params.where += " AND ";
                params.where += "IsPrivate=FALSE ";
            }
            const viewProps = await imodeljs_common_1.IModelReadRpcInterface.getClient().queryElementProps(this._iModel.iModelToken.toJSON(), params);
            bentleyjs_core_1.assert((viewProps.length === 0) || ("categorySelectorId" in viewProps[0]), "invalid view definition"); // spot check that the first returned element is-a ViewDefinitionProps
            return viewProps;
        }
        /** Get an array of the ViewSpecs for all views in this IModel that satisfy a ViewQueryParams.
         *
         * This is typically used to create a list for UI.
         *
         * For example:
         * ```ts
         * [[include:IModelConnection.Views.getViewList]]
         * ```
         * @param queryParams The parameters for the views to find. The `limit` and `offset` members should be used to page results.
         * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.
         */
        async getViewList(queryParams) {
            const views = [];
            const viewProps = await this.queryProps(queryParams);
            viewProps.forEach((viewProp) => { views.push({ id: viewProp.id, name: viewProp.code.value, class: viewProp.classFullName }); });
            return views;
        }
        /** Query the ID of the default view associated with this iModel. Applications can choose to use this as the default view to which to open a viewport upon startup, or the initial selection
         * within a view selection dialog, or similar purposes.
         * @returns the ID of the default view, or an invalid ID if no default view is defined.
         */
        async queryDefaultViewId() {
            return imodeljs_common_1.IModelReadRpcInterface.getClient().getDefaultViewId(this._iModel.iModelToken.toJSON());
        }
        /** Load a [[ViewState]] object from the specified [[ViewDefinition]] id. */
        async load(viewDefinitionId) {
            const viewProps = await imodeljs_common_1.IModelReadRpcInterface.getClient().getViewStateData(this._iModel.iModelToken.toJSON(), viewDefinitionId);
            const className = viewProps.viewDefinitionProps.classFullName;
            const ctor = await this._iModel.findClassFor(className, undefined);
            if (undefined === ctor)
                return Promise.reject(new imodeljs_common_1.IModelError(imodeljs_common_1.IModelStatus.WrongClass, "Invalid ViewState class", bentleyjs_core_1.Logger.logError, loggerCategory, () => viewProps));
            const viewState = ctor.createFromProps(viewProps, this._iModel);
            await viewState.load(); // loads models for ModelSelector
            return viewState;
        }
        /** Get a thumbnail for a view.
         * @param viewId The id of the view of the thumbnail.
         * @returns A Promise of the ThumbnailProps.
         * @throws `Error` exception if no thumbnail exists.
         */
        async getThumbnail(viewId) {
            const val = await imodeljs_common_1.IModelReadRpcInterface.getClient().getViewThumbnail(this._iModel.iModelToken.toJSON(), viewId.toString());
            const intVals = new Uint16Array(val.buffer);
            return { format: intVals[1] === imodeljs_common_1.ImageSourceFormat.Jpeg ? "jpeg" : "png", width: intVals[2], height: intVals[3], image: new Uint8Array(val.buffer, 8, intVals[0]) };
        }
        /** Save a thumbnail for a view.
         * @param viewId The id of the view for the thumbnail.
         * @param thumbnail The thumbnail data to save.
         * @returns A void Promise
         * @throws `Error` exception if the thumbnail wasn't successfully saved.
         */
        async saveThumbnail(viewId, thumbnail) {
            const id = bentleyjs_core_1.Id64.fromString(viewId.toString());
            const val = new Uint8Array(thumbnail.image.length + 16); // include the viewId and metadata in the binary transfer by allocating a new buffer 16 bytes larger than the image size
            new Uint16Array(val.buffer).set([thumbnail.image.length, thumbnail.format === "jpeg" ? imodeljs_common_1.ImageSourceFormat.Jpeg : imodeljs_common_1.ImageSourceFormat.Png, thumbnail.width, thumbnail.height]); // metadata at offset 0
            const low32 = bentleyjs_core_1.Id64.getLowerUint32(id);
            const high32 = bentleyjs_core_1.Id64.getUpperUint32(id);
            new Uint32Array(val.buffer, 8).set([low32, high32]); // viewId is 8 bytes starting at offset 8
            new Uint8Array(val.buffer, 16).set(thumbnail.image); // image data at offset 16
            return imodeljs_common_1.IModelWriteRpcInterface.getClient().saveThumbnail(this._iModel.iModelToken.toJSON(), val);
        }
    }
    IModelConnection.Views = Views;
    /** Provides access to tiles associated with an IModelConnection
     * @internal
     */
    class Tiles {
        constructor(iModel) { this._iModel = iModel; }
        async getTileTreeProps(id) { return IModelApp_1.IModelApp.tileAdmin.requestTileTreeProps(this._iModel, id); }
        async getTileContent(treeId, contentId) { return IModelApp_1.IModelApp.tileAdmin.requestTileContent(this._iModel, treeId, contentId); }
    }
    IModelConnection.Tiles = Tiles;
})(IModelConnection = exports.IModelConnection || (exports.IModelConnection = {}));


/***/ }),

/***/ "./lib/ImageUtil.js":
/*!**************************!*\
  !*** ./lib/ImageUtil.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const scratchRgba = { r: 0, g: 0, b: 0, a: 0 };
function rgbaFromAlpha(rgba, src, idx) {
    rgba.r = rgba.g = rgba.b = rgba.a = src[idx];
    return idx + 1;
}
function rgbaFromRgb(rgba, src, idx) {
    rgba.r = src[idx + 0];
    rgba.g = src[idx + 1];
    rgba.b = src[idx + 2];
    rgba.a = 255;
    return idx + 3;
}
function rgbaFromRgba(rgba, src, idx) {
    rgbaFromRgb(rgba, src, idx);
    rgba.a = src[idx + 3];
    return idx + 4;
}
/** Creates a canvas element with the same dimensions and contents as the ImageBuffer. */
function imageBufferToCanvas(buffer) {
    const canvas = document.createElement("canvas");
    if (null === canvas)
        return undefined;
    canvas.width = buffer.width;
    canvas.height = buffer.height;
    const context = canvas.getContext("2d");
    if (null === context)
        return undefined;
    const imageData = context.createImageData(buffer.width, buffer.height);
    const extractRgba = imodeljs_common_1.ImageBufferFormat.Alpha === buffer.format ? rgbaFromAlpha : (imodeljs_common_1.ImageBufferFormat.Rgb === buffer.format ? rgbaFromRgb : rgbaFromRgba);
    const bufferData = buffer.data;
    let i = 0;
    let j = 0;
    const rgba = scratchRgba;
    while (i < bufferData.length) {
        i = extractRgba(rgba, bufferData, i);
        imageData.data[j + 0] = rgba.r;
        imageData.data[j + 1] = rgba.g;
        imageData.data[j + 2] = rgba.b;
        imageData.data[j + 3] = rgba.a;
        j += 4;
    }
    context.putImageData(imageData, 0, 0);
    return canvas;
}
/** Get a string describing the mime type associated with an ImageSource format.
 * @public
 */
function getImageSourceMimeType(format) {
    switch (format) {
        case imodeljs_common_1.ImageSourceFormat.Jpeg:
            return "image/jpeg";
        case imodeljs_common_1.ImageSourceFormat.Png:
            return "image/png";
        case imodeljs_common_1.ImageSourceFormat.Svg:
            return "image/svg+xml;charset=utf-8";
    }
    return "";
}
exports.getImageSourceMimeType = getImageSourceMimeType;
/** Get the ImageSourceFormat corresponding to the mime type string, or undefined if the string does not identify a supported ImageSourceFormat.
 * @public
 */
function getImageSourceFormatForMimeType(mimeType) {
    switch (mimeType) {
        case "image/jpeg": return imodeljs_common_1.ImageSourceFormat.Jpeg;
        case "image/png": return imodeljs_common_1.ImageSourceFormat.Png;
        case "image/svg+xml;charset=utf-8": return imodeljs_common_1.ImageSourceFormat.Svg;
        default: return undefined;
    }
}
exports.getImageSourceFormatForMimeType = getImageSourceFormatForMimeType;
/** Extract an html Image element from a binary jpeg or png.
 * @param source The ImageSource containing the binary jpeg or png data.
 * @returns a Promise which resolves to an HTMLImageElement containing the uncompressed bitmap image in RGBA format.
 * @public
 */
async function imageElementFromImageSource(source) {
    const blob = new Blob([source.data], { type: getImageSourceMimeType(source.format) });
    return imageElementFromUrl(URL.createObjectURL(blob));
}
exports.imageElementFromImageSource = imageElementFromImageSource;
/** Create an html Image element from a URL.
 * @param url The URL pointing to the image data.
 * @returns A Promise resolving to an HTMLImageElement when the image data has been loaded from the URL.
 * @public
 */
async function imageElementFromUrl(url) {
    return new Promise((resolve, reject) => {
        const image = new Image();
        image.onload = () => resolve(image);
        image.onerror = reject;
        image.src = url;
    });
}
exports.imageElementFromUrl = imageElementFromUrl;
/**
 * Extract the dimensions of the jpeg or png data encoded in an ImageSource.
 * @param source The ImageSource containing the binary jpeg or png data.
 * @returns a Promise resolving to a Point2d of which x corresponds to the integer width of the uncompressed bitmap and y to the height.
 * @public
 */
async function extractImageSourceDimensions(source) {
    return imageElementFromImageSource(source).then((image) => new geometry_core_1.Point2d(image.naturalWidth, image.naturalHeight));
}
exports.extractImageSourceDimensions = extractImageSourceDimensions;
/**
 * Produces a data url in "image/png" format from the contents of an ImageBuffer.
 * @param buffer The ImageBuffer, of any format.
 * @returns a data url as a string suitable for setting as the `src` property of an HTMLImageElement, or undefined if the url could not be created.
 * @public
 */
function imageBufferToPngDataUrl(buffer) {
    // The default format (and the only format required to be supported) for toDataUrl() is "image/png".
    const canvas = imageBufferToCanvas(buffer);
    return undefined !== canvas ? canvas.toDataURL() : undefined;
}
exports.imageBufferToPngDataUrl = imageBufferToPngDataUrl;
/**
 * Converts the contents of an ImageBuffer to PNG format.
 * @param buffer The ImageBuffer, of any format.
 * @returns a base64-encoded string representing the image as a PNG, or undefined if the conversion failed.
 * @public
 */
function imageBufferToBase64EncodedPng(buffer) {
    const urlPrefix = "data:image/png;base64,";
    const url = imageBufferToPngDataUrl(buffer);
    if (undefined === url || !url.startsWith(urlPrefix))
        return undefined;
    return url.substring(urlPrefix.length);
}
exports.imageBufferToBase64EncodedPng = imageBufferToBase64EncodedPng;


/***/ }),

/***/ "./lib/Marker.js":
/*!***********************!*\
  !*** ./lib/Marker.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const ImageUtil_1 = __webpack_require__(/*! ./ImageUtil */ "./lib/ImageUtil.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/Viewport.js");
/** A Marker is a [[CanvasDecoration]], whose position follows a fixed location in world space.
 * Markers draw on top of all scene graphics, and show visual cues about locations of interest.
 * @see [Markers]($docs/learning/frontend/Markers)
 * @public
 */
class Marker {
    /** Constructor for Marker
     * @param worldLocation The location of this Marker in world coordinates.
     * @param size The size of this Marker in pixels.
     */
    constructor(worldLocation, size) {
        /** Whether this marker is currently enabled. If false, this Marker is not displayed. */
        this.visible = true;
        /** Whether this marker is currently hilited or not. */
        this._isHilited = false;
        /** The current rectangle for the marker, in view coordinates (pixels). This value will be updated by calls to [[setPosition]]. */
        this.rect = new Viewport_1.ViewRect();
        this.worldLocation = geometry_core_1.Point3d.createFrom(worldLocation);
        this.size = geometry_core_1.Point2d.createFrom(size);
        this.position = new geometry_core_1.Point3d();
    }
    /** Return true to display [[image]], if present. */
    get wantImage() { return true; }
    /** Called when the mouse pointer enters this Marker. */
    onMouseEnter(ev) { this._isHilited = true; this._hiliteColor = ev.viewport.hilite.color; }
    /** Called when the mouse pointer leaves this Marker. */
    onMouseLeave() { this._isHilited = false; }
    /** Called when the mouse pointer moves over this Marker */
    onMouseMove(ev) {
        if (this.title)
            ev.viewport.openToolTip(this.title, ev.viewPoint, this.tooltipOptions);
    }
    /** Determine whether the point is within this Marker.  */
    pick(pt) { return this.rect.containsPoint(pt); }
    /** Establish a range of scale factors to increases and decrease the size of this Marker based on its distance from the camera.
     * @param range The minimum and maximum scale factors to be applied to the size of this Marker based on its distance from the camera. `range.Low` is the scale factor
     * for Markers at the back of the view frustum and `range.high` is the scale factor at the front of the view frustum.
     * @note Marker size scaling is only applied in views with the camera enabled. It has no effect on orthographic views.
     */
    setScaleFactor(range) {
        this._scaleFactorRange = geometry_core_1.Range1d.fromJSON(range);
        this._scaleFactor = geometry_core_1.Point2d.create(1, 1);
    }
    /** Make a new Marker at the same position and size as this Marker.
     * Thew new Marker will share the world location and size objects, but will be otherwise blank.
     */
    static makeFrom(other, ...args) {
        const out = new this(other.worldLocation, other.size, ...args);
        out.rect.setFrom(other.rect);
        out.position.setFrom(other.position);
        if (other._scaleFactor)
            out._scaleFactor = geometry_core_1.Point2d.createFrom(other._scaleFactor);
        out._scaleFactorRange = other._scaleFactorRange;
        return out;
    }
    /** When a Marker is displayed in its hilited state, this method is called first. If it returns true, no further action is taken.
     * Otherwise the Marker's normal drawing operations are also called. By default, this method adds a shadowBlur effect and increases
     * the size of the Marker by 25%.
     * @return true to stop drawing this Marker
     */
    drawHilited(ctx) {
        ctx.shadowBlur = 30;
        ctx.shadowColor = this._hiliteColor ? this._hiliteColor.toHexString() : "white";
        ctx.scale(1.25, 1.25);
        return false;
    }
    /** Called during frame rendering to display this Marker onto the supplied context. */
    drawDecoration(ctx) {
        if (this._isHilited && this.drawHilited(ctx))
            return;
        if (this._scaleFactor !== undefined)
            ctx.scale(this._scaleFactor.x, this._scaleFactor.y);
        // first call the "drawFunc" if defined. This means it will be below the image and label if they overlap
        if (undefined !== this.drawFunc)
            this.drawFunc(ctx);
        // next draw the image, if defined and desired
        if (this.wantImage && this.image !== undefined) {
            const size = this.imageSize ? this.imageSize : this.size;
            const offset = new geometry_core_1.Point2d(size.x / 2, size.y / 2);
            if (this.imageOffset)
                offset.plus(this.imageOffset, offset);
            ctx.drawImage(this.image, -offset.x, -offset.y, size.x, size.y);
        }
        // lastly, draw the label, if defined. This puts it on top of all other graphics for this Marker.
        if (this.label !== undefined) {
            ctx.textAlign = this.labelAlign ? this.labelAlign : "center";
            ctx.textBaseline = this.labelBaseline ? this.labelBaseline : "middle";
            ctx.font = this.labelFont ? this.labelFont : "14px san-serif";
            ctx.fillStyle = this.labelColor ? this.labelColor : "white";
            ctx.fillText(this.label, this.labelOffset ? -this.labelOffset.x : 0, this.labelOffset ? -this.labelOffset.y : 0);
        }
    }
    /** Set the [[image]] for this marker.
     * @param image Either a [[MarkerImage]] or a Promise for a [[MarkerImage]]. If a Promise is supplied, the [[image]] member is set
     * when the Promise resolves.
     */
    setImage(image) {
        if (image instanceof Promise)
            image.then((resolvedImage) => this.image = resolvedImage); // tslint:disable-line:no-floating-promises
        else
            this.image = image;
    }
    /** Set the image for this Marker from a URL. */
    setImageUrl(url) { this.setImage(ImageUtil_1.imageElementFromUrl(url)); }
    /** Set the position (in pixels) for this Marker in the supplied Viewport, based on its worldLocation.
     * @return true if the Marker is visible and its new position is inside the Viewport.
     */
    setPosition(vp) {
        if (!this.visible) // if we're turned off, skip
            return false;
        const pt4 = vp.worldToView4d(this.worldLocation);
        if (pt4.w > 1.0 || pt4.w < 0) // outside of frustum.
            return false;
        pt4.realPoint(this.position);
        if (!vp.viewRect.containsPoint(this.position))
            return false; // outside this viewport rect
        const origin = this.position;
        const sizeX = this.size.x / 2;
        const sizeY = this.size.y / 2;
        this.rect.init(origin.x - sizeX, origin.y - sizeY, origin.x + sizeX, origin.y + sizeY);
        // if there's a scale factor active, calculate it now.
        if (this._scaleFactor && this._scaleFactorRange) {
            let scale = 1.0;
            if (vp.isCameraOn) {
                const range = this._scaleFactorRange;
                scale = geometry_core_1.Geometry.clamp(range.low + ((1 - pt4.w) * range.length()), .4, 2.0);
                this.rect.scaleAboutCenter(scale, scale);
            }
            this._scaleFactor.set(scale, scale);
        }
        return true;
    }
    /** Add this Marker to the supplied Decorate context. */
    addMarker(context) { context.addCanvasDecoration(this); }
    /** Set the position and ddd this Marker to the supplied DecorateContext, if it's visible.
     * This method should be called from your implementation of [[Decorator.decorate]]. It will set this Marker's position based the
     * Viewport from the context, and add this this Marker to the supplied DecorateContext.
     * @param context The DecorateContext for the Marker
     */
    addDecoration(context) {
        if (this.setPosition(context.viewport))
            this.addMarker(context);
    }
}
exports.Marker = Marker;
/** A cluster of one or more Markers that overlap one another in the view. The cluster's screen position is taken from its first entry.
 * Clusters also have a Marker themselves, that represents the whole group. The cluster marker isn't created until all entries have been added.
 * @public
 */
class Cluster {
    constructor(markers) {
        this.markers = markers;
        this.rect = markers[0].rect;
        this.markers = markers;
    }
}
exports.Cluster = Cluster;
/** A *set* of Markers that are logically related, such that they *cluster* when they overlap one another in screen space.
 * In that case, a *cluster marker* is drawn instead of the overlapping Markers.
 * @public
 */
class MarkerSet {
    constructor() {
        /** @internal */
        this._entries = []; // this is an array that holds either Markers or a cluster of markers.
        /** @internal */
        this._worldToViewMap = geometry_core_1.Matrix4d.createZero();
        /** The minimum number of Markers that must overlap before they are clustered. Otherwise they are each drawn individually. Default is 1 (always create a cluster.) */
        this.minimumClusterSize = 1;
        /** The set of Markers in this MarkerSet. Add your [[Marker]]s into this. */
        this.markers = new Set();
    }
    /** This method should be called from [[Decorator.decorate]]. It will add this this MarkerSet to the supplied DecorateContext.
     * This method implements the logic that turns overlapping Markers into a Cluster.
     * @param context The DecorateContext for the Markers
     */
    addDecoration(context) {
        const vp = context.viewport;
        const entries = this._entries;
        // Don't recreate the entries array if the view hasn't changed. This is important for performance, but also necessary for hilite of
        // clusters (otherwise they're recreated continually and never hilited.) */
        if (!this._worldToViewMap.isAlmostEqual(vp.worldToViewMap.transform0)) {
            this._worldToViewMap.setFrom(vp.worldToViewMap.transform0);
            entries.length = 0; // start over.
            // loop through all of the Markers in the MarkerSet.
            for (const marker of this.markers) {
                // establish the screen position for this marker. If it's not in view, setPosition returns false
                if (!marker.setPosition(vp))
                    continue;
                let added = false;
                for (let i = 0; i < entries.length; ++i) { // loop through all of the currently visible markers/clusters
                    const entry = entries[i];
                    if (marker.rect.overlaps(entry.rect)) { // does new Marker overlap with this entry?
                        added = true; // yes, we're going to save it as a Cluster
                        if (entry instanceof Cluster) { // is the entry already a Cluster?
                            entry.markers.push(marker); // yes, just add this to the existing cluster
                        }
                        else {
                            entries[i] = new Cluster([entry, marker]); // no, make a new Cluster holding both
                        }
                        break; // this Marker has been handled, we can stop looking for overlaps
                    }
                }
                if (!added)
                    entries.push(marker); // there was no overlap, save this Marker to be drawn
            }
        }
        // we now have an array of Markers and Clusters, add them to context
        for (const entry of entries) {
            if (entry instanceof Cluster) { // is this entry a Cluster?
                if (entry.markers.length <= this.minimumClusterSize) { // yes, does it have more than the minimum number of entries?
                    entry.markers.forEach((marker) => marker.addMarker(context)); // no, just draw all of its Markers
                }
                else {
                    // yes, get and draw the Marker for this Cluster
                    if (undefined === entry.clusterMarker) // have we already created this cluster marker?
                        entry.clusterMarker = this.getClusterMarker(entry); // no, get it now.
                    entry.clusterMarker.addMarker(context);
                }
            }
            else {
                entry.addMarker(context); // entry is a non-overlapping Marker, draw it.
            }
        }
    }
}
exports.MarkerSet = MarkerSet;


/***/ }),

/***/ "./lib/ModelSelectorState.js":
/*!***********************************!*\
  !*** ./lib/ModelSelectorState.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const EntityState_1 = __webpack_require__(/*! ./EntityState */ "./lib/EntityState.js");
const SpatialClassification_1 = __webpack_require__(/*! ./SpatialClassification */ "./lib/SpatialClassification.js");
/** The state of a [ModelSelector]($backend). It holds a set of ids of GeometricModels for a [[SpatialViewState]].
 * It defines the set of [[ModelState]]s drawn within the view as a set of IDs.
 * @public
 */
class ModelSelectorState extends EntityState_1.ElementState {
    constructor(props, iModel) {
        super(props, iModel);
        /** The set of ModelIds of this ModelSelectorState */
        this.models = new Set();
        if (props.models)
            props.models.forEach((model) => this.models.add(model));
    }
    /** @internal */
    static get className() { return "ModelSelector"; }
    /** The name of this ModelSelector */
    get name() { return this.code.getValue(); }
    toJSON() {
        const val = super.toJSON();
        val.models = [];
        this.models.forEach((model) => val.models.push(model));
        return val;
    }
    /** Determine if this model selector is logically equivalent to the specified model selector. Two model selectors are logically equivalent is
     * they have the same name and Id and contain the same set of models.
     * @param other The model selector to which to compare.
     * @returns true if the model selectors are logically equivalent.
     * @public
     */
    equalState(other) {
        if (this.models.size !== other.models.size || this.id !== other.id || this.name !== other.name)
            return false;
        const otherIter = other.models.keys();
        let otherRes = otherIter.next();
        for (let thisIter = this.models.keys(), thisRes = thisIter.next(); !thisRes.done; thisRes = thisIter.next(), otherRes = otherIter.next()) {
            if (thisRes.value !== otherRes.value)
                return false;
        }
        return true;
    }
    /** Add one or more models to this ModelSelectorState */
    addModels(arg) {
        bentleyjs_core_1.Id64.forEach(arg, (id) => this.models.add(id));
    }
    /** Drop one or more models from this ModelSelectorState */
    dropModels(arg) {
        bentleyjs_core_1.Id64.forEach(arg, (id) => this.models.delete(id));
    }
    /** Determine whether this ModelSelectorState includes the specified modelId value */
    has(id) { return this.models.has(id); }
    /** Determine whether this ModelSelectorState includes the specified modelId */
    containsModel(modelId) { return this.has(modelId.toString()); }
    /** Make sure all models referenced by this ModelSelectorState are loaded. */
    async load() {
        return this.iModel.models.load(this.models).then(async (_) => SpatialClassification_1.SpatialClassification.loadModelClassifiers(this.models, this.iModel));
    }
}
exports.ModelSelectorState = ModelSelectorState;


/***/ }),

/***/ "./lib/ModelState.js":
/*!***************************!*\
  !*** ./lib/ModelState.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module ModelState */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const EntityState_1 = __webpack_require__(/*! ./EntityState */ "./lib/EntityState.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const IModelTile_1 = __webpack_require__(/*! ./tile/IModelTile */ "./lib/tile/IModelTile.js");
const RealityModelTileTree_1 = __webpack_require__(/*! ./tile/RealityModelTileTree */ "./lib/tile/RealityModelTileTree.js");
const TileTree_1 = __webpack_require__(/*! ./tile/TileTree */ "./lib/tile/TileTree.js");
/** Represents the front-end state of a [Model]($backend).
 * @public
 */
class ModelState extends EntityState_1.EntityState {
    /** @internal */
    static get className() { return "Model"; }
    constructor(props, iModel) {
        super(props, iModel);
        this.modeledElement = imodeljs_common_1.RelatedElement.fromJSON(props.modeledElement);
        this.name = props.name ? props.name : "";
        this.parentModel = bentleyjs_core_1.Id64.fromJSON(props.parentModel); // NB! Must always match the model of the modeledElement!
        this.isPrivate = bentleyjs_core_1.JsonUtils.asBool(props.isPrivate);
        this.isTemplate = bentleyjs_core_1.JsonUtils.asBool(props.isTemplate);
    }
    /** Add all custom-handled properties of a Model to a json object. */
    toJSON() {
        const val = super.toJSON();
        val.modeledElement = this.modeledElement;
        val.parentModel = this.parentModel;
        val.name = this.name;
        if (this.isPrivate)
            val.isPrivate = this.isPrivate;
        if (this.isTemplate)
            val.isTemplate = this.isTemplate;
        return val;
    }
    /** Determine whether this is a GeometricModel */
    get isGeometricModel() { return false; }
    /** Attempts to cast this model to a geometric model. */
    get asGeometricModel() { return undefined; }
    /** Attempts to cast this model to a 3d geometric model. */
    get asGeometricModel3d() { return undefined; }
    /** Attempts to cast this model to a 2d geometric model. */
    get asGeometricModel2d() { return undefined; }
    /** Executes just before the containing IModelConnection is closed to perform any necessary cleanup.
     * @internal
     */
    onIModelConnectionClose() { }
}
exports.ModelState = ModelState;
/** Represents the front-end state of a [GeometricModel]($backend).
 * The contents of a GeometricModelState can be rendered inside a [[Viewport]].
 * @public
 */
class GeometricModelState extends ModelState /* implements TileTreeModelState */ {
    constructor() {
        super(...arguments);
        /** @internal */
        this._tileTreeState = new TileTree_1.TileTreeState(this.iModel, !this.is2d, this.id);
        /** @internal */
        this._classifierTileTreeState = new TileTree_1.TileTreeState(this.iModel, !this.is2d, this.id);
    }
    /** @internal */
    static get className() { return "GeometricModel"; }
    /** @internal */
    get asGeometricModel() { return this; }
    /** Returns true if this is a 2d model (a [[GeometricModel2dState]]). */
    get is2d() { return !this.is3d; }
    /** @internal */
    get tileTree() { return this._tileTreeState.tileTree; }
    /** @internal */
    get classifierTileTree() { return this._classifierTileTreeState.tileTree; }
    /** @internal */
    get loadStatus() { return this._tileTreeState.loadStatus; }
    set loadStatus(status) { this._tileTreeState.loadStatus = status; }
    /** @internal */
    get isGeometricModel() { return true; }
    /** @internal */
    get treeModelId() { return this.id; }
    /** @internal */
    loadTree(edgesRequired, animationId) {
        // If this is a reality model, its tile tree is obtained from reality data service URL.
        if (undefined !== this.jsonProperties.tilesetUrl) {
            if (TileTree_1.TileTree.LoadStatus.NotLoaded === this.loadStatus) {
                this.loadStatus = TileTree_1.TileTree.LoadStatus.Loading;
                RealityModelTileTree_1.RealityModelTileTree.loadRealityModelTileTree(this.jsonProperties.tilesetUrl, this.jsonProperties.tilesetToDbTransform, this._tileTreeState);
            }
            return this.loadStatus;
        }
        return this.loadTileTree({ type: imodeljs_common_1.BatchType.Primary, edgesRequired, animationId });
    }
    /** @internal */
    loadClassifierTileTree(type, expansion) {
        return this.loadTileTree({ type, expansion });
    }
    /** @internal */
    loadTileTree(treeId) {
        // Determine which tree we want, and invalidate if incompatible with supplied options.
        let state;
        let allowInstancing = false;
        let batchType;
        let edgesRequired = false;
        let animationId;
        if (treeId.type === imodeljs_common_1.BatchType.Primary) {
            batchType = imodeljs_common_1.BatchType.Primary;
            edgesRequired = treeId.edgesRequired;
            animationId = treeId.animationId;
            state = this._tileTreeState;
            if ((edgesRequired && state.edgesOmitted) || animationId !== state.animationId)
                state.clearTileTree();
            if (undefined === treeId.animationId)
                allowInstancing = true;
        }
        else {
            state = this._classifierTileTreeState;
            batchType = treeId.type;
            if (state.classifierExpansion !== treeId.expansion) {
                state.clearTileTree();
                state.classifierExpansion = treeId.expansion;
            }
        }
        // If we've already tried to load, return current status.
        if (TileTree_1.TileTree.LoadStatus.NotLoaded !== state.loadStatus)
            return state.loadStatus;
        // Enqueue the tree for loading.
        state.loadStatus = TileTree_1.TileTree.LoadStatus.Loading;
        const id = IModelTile_1.IModelTile.treeIdToString(this.id, treeId);
        this.iModel.tiles.getTileTreeProps(id).then((result) => {
            const loader = new IModelTile_1.IModelTile.Loader(this.iModel, result.formatVersion, batchType, edgesRequired, allowInstancing);
            result.rootTile.contentId = loader.rootContentId;
            state.setTileTree(result, loader);
            state.edgesOmitted = !edgesRequired;
            state.animationId = animationId;
            IModelApp_1.IModelApp.viewManager.onNewTilesReady();
        }).catch((err) => {
            // Retry in case of timeout; otherwise fail.
            if (err.errorNumber && err.errorNumber === bentleyjs_core_1.IModelStatus.ServerTimeout)
                state.loadStatus = TileTree_1.TileTree.LoadStatus.NotLoaded;
            else
                state.loadStatus = TileTree_1.TileTree.LoadStatus.NotFound;
            IModelApp_1.IModelApp.viewManager.onNewTilesReady();
        });
        return state.loadStatus;
    }
    /** @internal */
    onIModelConnectionClose() {
        bentleyjs_core_1.dispose(this._tileTreeState.tileTree); // we do not track if we are disposed...catch this at the tileTree level
        super.onIModelConnectionClose();
    }
    /** Query for the union of the ranges of all the elements in this GeometricModel. */
    async queryModelRange() {
        if (undefined === this._modelRange) {
            const ranges = await this.iModel.models.queryModelRanges(this.id);
            this._modelRange = geometry_core_1.Range3d.fromJSON(ranges[0]);
        }
        return this._modelRange;
    }
}
exports.GeometricModelState = GeometricModelState;
/** Represents the front-end state of a [GeometricModel2d]($backend).
 * @public
 */
class GeometricModel2dState extends GeometricModelState {
    /** @internal */
    static get className() { return "GeometricModel2d"; }
    constructor(props, iModel) {
        super(props, iModel);
        this.globalOrigin = geometry_core_1.Point2d.fromJSON(props.globalOrigin);
    }
    /** @internal */
    get is3d() { return false; }
    /** @internal */
    get asGeometricModel2d() { return this; }
    toJSON() {
        const val = super.toJSON();
        val.globalOrigin = this.globalOrigin;
        return val;
    }
}
exports.GeometricModel2dState = GeometricModel2dState;
/** Represents the front-end state of a [GeometricModel3d]($backend).
 * @public
 */
class GeometricModel3dState extends GeometricModelState {
    /** @internal */
    static get className() { return "GeometricModel3d"; }
    /** @internal */
    get is3d() { return true; }
    /** @internal */
    get asGeometricModel3d() { return this; }
}
exports.GeometricModel3dState = GeometricModel3dState;
/** Represents the front-end state of a [SheetModel]($backend).
 * @public
 */
class SheetModelState extends GeometricModel2dState {
    /** @internal */
    static get className() { return "SheetModel"; }
}
exports.SheetModelState = SheetModelState;
/** Represents the front-end state of a [SpatialModel]($backend).
 * @public
 */
class SpatialModelState extends GeometricModel3dState {
    /** @internal */
    static get className() { return "SpatialModel"; }
}
exports.SpatialModelState = SpatialModelState;
/** Represents the front-end state of a [PhysicalModel]($backend).
 * @public
 */
class PhysicalModelState extends SpatialModelState {
    /** @internal */
    static get className() { return "PhysicalModel"; }
}
exports.PhysicalModelState = PhysicalModelState;
/** Represents the front-end state of a [SpatialLocationModel]($backend).
 * @public
 */
class SpatialLocationModelState extends SpatialModelState {
    /** @internal */
    static get className() { return "SpatialLocationModel"; }
}
exports.SpatialLocationModelState = SpatialLocationModelState;
/** Represents the front-end state of a [DrawingModel]($backend).
 * @public
 */
class DrawingModelState extends GeometricModel2dState {
    /** @internal */
    static get className() { return "DrawingModel"; }
}
exports.DrawingModelState = DrawingModelState;
/** Represents the front-end state of a [SectionDrawingModel]($backend).
 * @public
 */
class SectionDrawingModelState extends DrawingModelState {
    /** @internal */
    static get className() { return "SectionDrawingModel"; }
}
exports.SectionDrawingModelState = SectionDrawingModelState;


/***/ }),

/***/ "./lib/NoRenderApp.js":
/*!****************************!*\
  !*** ./lib/NoRenderApp.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const rendering_1 = __webpack_require__(/*! ./rendering */ "./lib/rendering.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/Viewport.js");
/**
 * A RenderTarget for applications that must run in environments where WebGL is not present.
 * This is typically used in tests.
 * @internal
 */
class NullTarget extends rendering_1.RenderTarget {
    get animationFraction() { return 0; }
    set animationFraction(_fraction) { }
    get renderSystem() { return undefined; }
    get cameraFrustumNearScaleLimit() { return 0; }
    get viewRect() { return new Viewport_1.ViewRect(); }
    get wantInvertBlackBackground() { return false; }
    get animationBranches() { return undefined; }
    set animationBranches(_branches) { }
    onDestroy() { }
    reset() { }
    changeScene() { }
    changeBackgroundMap() { }
    changeDynamics() { }
    changeDecorations() { }
    changeRenderPlan() { }
    drawFrame(_sceneMilSecElapsed) { }
    overrideFeatureSymbology() { }
    setHiliteSet() { }
    setFlashed() { }
    setViewRect() { }
    onResized() { }
    dispose() { }
    updateViewRect() { return false; }
    readPixels() { }
    readImage() { return undefined; }
}
exports.NullTarget = NullTarget;
/**
 * A RenderSystem for applications that must run in environments where WebGL is not present.
 * This is typically used in tests.
 * @internal
 */
class NullRenderSystem extends rendering_1.RenderSystem {
    get isValid() { return false; }
    createTarget() { return new NullTarget(); }
    createOffscreenTarget() { return new NullTarget(); }
    createGraphicBuilder() { return undefined; }
    createGraphicList() { return undefined; }
    createGraphicBranch() { return undefined; }
    createBatch() { return undefined; }
    dispose() { }
    constructor() { super(); }
}
exports.NullRenderSystem = NullRenderSystem;
/**
 * A class for applications that must run in environments where WebGL is not present.
 * This is typically used in tests.
 * @internal
 */
class NoRenderApp {
    static startup(opts) {
        opts = opts ? opts : {};
        opts.renderSys = new NullRenderSystem();
        IModelApp_1.IModelApp.startup(opts);
    }
}
exports.NoRenderApp = NoRenderApp;


/***/ }),

/***/ "./lib/NotificationManager.js":
/*!************************************!*\
  !*** ./lib/NotificationManager.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Notifications */
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** Describes the type and behavior of a [[NotifyMessageDetails]].
 * @public
 */
var OutputMessageType;
(function (OutputMessageType) {
    /** Temporary message box that displays at the bottom of the screen. */
    OutputMessageType[OutputMessageType["Toast"] = 0] = "Toast";
    OutputMessageType[OutputMessageType["Pointer"] = 1] = "Pointer";
    OutputMessageType[OutputMessageType["Sticky"] = 2] = "Sticky";
    OutputMessageType[OutputMessageType["InputField"] = 3] = "InputField";
    /** Modal message box. */
    OutputMessageType[OutputMessageType["Alert"] = 4] = "Alert";
})(OutputMessageType = exports.OutputMessageType || (exports.OutputMessageType = {}));
/** Classifies a [[NotifyMessageDetails]] by its level of importance.
 * @public
 */
var OutputMessagePriority;
(function (OutputMessagePriority) {
    OutputMessagePriority[OutputMessagePriority["None"] = 0] = "None";
    OutputMessagePriority[OutputMessagePriority["Error"] = 10] = "Error";
    OutputMessagePriority[OutputMessagePriority["Warning"] = 11] = "Warning";
    OutputMessagePriority[OutputMessagePriority["Info"] = 12] = "Info";
    OutputMessagePriority[OutputMessagePriority["Debug"] = 13] = "Debug";
    OutputMessagePriority[OutputMessagePriority["Fatal"] = 17] = "Fatal";
})(OutputMessagePriority = exports.OutputMessagePriority || (exports.OutputMessagePriority = {}));
/** Describes the alert behavior of a [[NotifyMessageDetails]].
 * @public
 */
var OutputMessageAlert;
(function (OutputMessageAlert) {
    OutputMessageAlert[OutputMessageAlert["None"] = 0] = "None";
    OutputMessageAlert[OutputMessageAlert["Dialog"] = 1] = "Dialog";
    OutputMessageAlert[OutputMessageAlert["Balloon"] = 2] = "Balloon";
})(OutputMessageAlert = exports.OutputMessageAlert || (exports.OutputMessageAlert = {}));
/** Relative Position for setPointerTypeDetails
 * @public
 */
var RelativePosition;
(function (RelativePosition) {
    RelativePosition[RelativePosition["Left"] = 0] = "Left";
    RelativePosition[RelativePosition["Top"] = 1] = "Top";
    RelativePosition[RelativePosition["Right"] = 2] = "Right";
    RelativePosition[RelativePosition["Bottom"] = 3] = "Bottom";
    RelativePosition[RelativePosition["TopLeft"] = 4] = "TopLeft";
    RelativePosition[RelativePosition["TopRight"] = 5] = "TopRight";
    RelativePosition[RelativePosition["BottomLeft"] = 6] = "BottomLeft";
    RelativePosition[RelativePosition["BottomRight"] = 7] = "BottomRight";
})(RelativePosition = exports.RelativePosition || (exports.RelativePosition = {}));
/** Reason for ending the activity message via endActivityMessage
 * @public
 */
var ActivityMessageEndReason;
(function (ActivityMessageEndReason) {
    ActivityMessageEndReason[ActivityMessageEndReason["Completed"] = 0] = "Completed";
    ActivityMessageEndReason[ActivityMessageEndReason["Cancelled"] = 1] = "Cancelled";
})(ActivityMessageEndReason = exports.ActivityMessageEndReason || (exports.ActivityMessageEndReason = {}));
/** Describes the set of buttons displayed in a message box opened using [[NotificationManager.openMessageBox]].
 * @public
 */
var MessageBoxType;
(function (MessageBoxType) {
    MessageBoxType[MessageBoxType["OkCancel"] = 0] = "OkCancel";
    MessageBoxType[MessageBoxType["Ok"] = 1] = "Ok";
    MessageBoxType[MessageBoxType["LargeOk"] = 2] = "LargeOk";
    MessageBoxType[MessageBoxType["MediumAlert"] = 3] = "MediumAlert";
    MessageBoxType[MessageBoxType["YesNoCancel"] = 4] = "YesNoCancel";
    MessageBoxType[MessageBoxType["YesNo"] = 5] = "YesNo";
})(MessageBoxType = exports.MessageBoxType || (exports.MessageBoxType = {}));
/** Describes the icon displayed in a messagebox opened using [[NotificationManager.openMessageBox]].
 * @public
 */
var MessageBoxIconType;
(function (MessageBoxIconType) {
    MessageBoxIconType[MessageBoxIconType["NoSymbol"] = 0] = "NoSymbol";
    MessageBoxIconType[MessageBoxIconType["Information"] = 1] = "Information";
    MessageBoxIconType[MessageBoxIconType["Question"] = 2] = "Question";
    MessageBoxIconType[MessageBoxIconType["Warning"] = 3] = "Warning";
    MessageBoxIconType[MessageBoxIconType["Critical"] = 4] = "Critical";
})(MessageBoxIconType = exports.MessageBoxIconType || (exports.MessageBoxIconType = {}));
/** Describes the possible return values produced when the user clicks a button in a messagebox opened using [[NotificationManager.openMessageBox]].
 * @public
 */
var MessageBoxValue;
(function (MessageBoxValue) {
    MessageBoxValue[MessageBoxValue["Apply"] = 1] = "Apply";
    MessageBoxValue[MessageBoxValue["Reset"] = 2] = "Reset";
    MessageBoxValue[MessageBoxValue["Ok"] = 3] = "Ok";
    MessageBoxValue[MessageBoxValue["Cancel"] = 4] = "Cancel";
    MessageBoxValue[MessageBoxValue["Default"] = 5] = "Default";
    MessageBoxValue[MessageBoxValue["Yes"] = 6] = "Yes";
    MessageBoxValue[MessageBoxValue["No"] = 7] = "No";
    MessageBoxValue[MessageBoxValue["Retry"] = 8] = "Retry";
    MessageBoxValue[MessageBoxValue["Stop"] = 9] = "Stop";
    MessageBoxValue[MessageBoxValue["Help"] = 10] = "Help";
    MessageBoxValue[MessageBoxValue["YesToAll"] = 11] = "YesToAll";
    MessageBoxValue[MessageBoxValue["NoToAll"] = 12] = "NoToAll";
})(MessageBoxValue = exports.MessageBoxValue || (exports.MessageBoxValue = {}));
/** Describes a message to be displayed to the user.
 * @beta
 */
class NotifyMessageDetails {
    /** Constructor
     *  @param priority        The priority this message should be accorded by the NotificationManager.
     *  @param briefMsg        A short message that conveys the simplest explanation of the issue.
     *  @param detailedMsg     A comprehensive message that explains the issue in detail and potentially offers a solution.
     *  @param msgType         The type of message.
     *  @param openAlert       Whether an alert box should be displayed or not, and if so what kind.
     */
    constructor(priority, briefMessage, detailedMessage, msgType = OutputMessageType.Toast, openAlert = OutputMessageAlert.None) {
        this.priority = priority;
        this.briefMessage = briefMessage;
        this.detailedMessage = detailedMessage;
        this.msgType = msgType;
        this.openAlert = openAlert;
        this.displayTime = bentleyjs_core_1.BeDuration.fromSeconds(3.5);
        this.relativePosition = RelativePosition.TopRight;
    }
    /** Set OutputMessageType.Pointer message details.
     * @param viewport            Viewport over which to display the Pointer type message.
     * @param displayPoint        Point at which to display the Pointer type message.
     * @param relativePosition    Position relative to displayPoint at which to display the Pointer type message.
     */
    setPointerTypeDetails(viewport, displayPoint, relativePosition = RelativePosition.TopRight) {
        this.viewport = viewport;
        this.displayPoint = geometry_core_1.Point2d.fromJSON(displayPoint);
        this.relativePosition = relativePosition;
        this.msgType = OutputMessageType.Pointer;
    }
    /** Set OutputMessageType.InputField message details.
     * @param inputField            Input field that message pertains. The message will be shown just below this input field element.
     */
    setInputFieldTypeDetails(inputField) {
        this.inputField = inputField;
        this.msgType = OutputMessageType.InputField;
    }
}
exports.NotifyMessageDetails = NotifyMessageDetails;
/** Specifies the details of an activity message to be displayed to the user.
 * @public
 */
class ActivityMessageDetails {
    /**
     * @param showProgressBar         Indicates whether to show the progress bar in the activity message dialog.
     * @param showPercentInMessage    Indicates whether to show the percentage complete in the activity message text.
     * @param supportsCancellation    Indicates whether to show the Cancel button, giving the user the ability to cancel the operation.
     * @param showDialogInitially     Indicates whether to show the activity message dialog initially. User can click status bar to open it.
     */
    constructor(showProgressBar, showPercentInMessage, supportsCancellation, showDialogInitially = true) {
        this.showProgressBar = showProgressBar;
        this.showPercentInMessage = showPercentInMessage;
        this.supportsCancellation = supportsCancellation;
        this.showDialogInitially = showDialogInitially;
        this.wasCancelled = false;
    }
    /** Called from NotificationAdmin when the user cancels the activity. */
    onActivityCancelled() { this.wasCancelled = true; }
    /** Called from NotificationAdmin when the activity completes successfully. */
    onActivityCompleted() { this.wasCancelled = false; }
}
exports.ActivityMessageDetails = ActivityMessageDetails;
/** The NotificationManager controls the interaction with the user for prompts, error messages, and alert dialogs.
 * Implementations of the NotificationManager may present the information in different ways. For example, in
 * non-interactive sessions, these messages may be saved to a log file or simply discarded.
 * @public
 */
class NotificationManager {
    constructor() {
        this.toolTipLocation = new geometry_core_1.Point2d();
    }
    /** Output a prompt, given an i18n key. */
    outputPromptByKey(key) { this.outputPrompt(IModelApp_1.IModelApp.i18n.translate(key)); }
    /** Output a localized prompt to the user. A 'prompt' indicates an action the user should take to proceed.
     * @param _prompt The localized string with the prompt message.
     */
    outputPrompt(_prompt) { }
    /** Output a message and/or alert to the user.
     * @beta
     */
    outputMessage(_message) { }
    /** Output a MessageBox and wait for response from the user.
     * @param _mbType       The MessageBox type.
     * @param _message      The message to display.
     * @param _icon         The MessageBox icon type.
     * @return the response from the user.
     */
    async openMessageBox(_mbType, _message, _icon) { return Promise.resolve(MessageBoxValue.Ok); }
    /**
     * Set up for activity messages.
     * @param _details  The activity message details.
     * @return true if the message was displayed, false if an invalid priority is specified.
     */
    setupActivityMessage(_details) { return true; }
    /**
     * Output an activity message to the user.
     * @param _messageText The message text.
     * @param _percentComplete The percentage of completion.
     * @return true if the message was displayed, false if the message could not be displayed.
     */
    outputActivityMessage(_messageText, _percentComplete) { return true; }
    /**
     * End an activity message.
     * @param _reason The reason for the end of the Activity Message.
     * @return true if the message was ended successfully, false if the activityMessage could not be ended.
     */
    endActivityMessage(_reason) { return true; }
    /** Return true if _showTooltip has an implementation and will display a tooltip. */
    get isToolTipSupported() { return false; }
    /** Return true if the tooltip is currently open. */
    get isToolTipOpen() { return false; }
    /** Implement to display a tooltip message at the specified location.
     * @beta
     */
    _showToolTip(_htmlElement, _message, _location, _options) { }
    /** Show a tooltip window. Saves tooltip location for AccuSnap to test if cursor has moved far enough away to close tooltip.
     * @param htmlElement The HTMLElement that that anchors the toolTip.
     * @param message What to display inside the ToolTip. May be a string or an HTMLElement.
     * @param location An optional location, relative to the origin of _htmlElement, for the ToolTip. If undefined, center of _htmlElement
     * @param options Options that supply additional information about how the ToolTip should function.
     * @note If message is an HTMLElement, the notification manager will display the HTMLElement verbatim. This can represent a security
     * risk if any part the element is created from user input. Applications should be careful to *sanitize* any such input before
     * creating an HTMLElement to pass to this method.
     * @beta
     */
    openToolTip(_htmlElement, message, location, options) {
        this.toolTipLocation.setFrom(location);
        this._showToolTip(_htmlElement, message, location, options);
    }
    /** Clear the tooltip if it is currently open. */
    clearToolTip() { }
    /** Close message created with [[OutputMessageType.Pointer]]. */
    closePointerMessage() { }
    /** Close message created with [[OutputMessageType.InputField]]. */
    closeInputFieldMessage() { }
}
exports.NotificationManager = NotificationManager;


/***/ }),

/***/ "./lib/Plugin.js":
/*!***********************!*\
  !*** ./lib/Plugin.js ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Plugins */
const semver = __webpack_require__(/*! semver */ "../../common/temp/node_modules/.registry.npmjs.org/semver/5.7.0/node_modules/semver/semver.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const NotificationManager_1 = __webpack_require__(/*! ./NotificationManager */ "./lib/NotificationManager.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const loggerCategory = "imodeljs-frontend.Plugin";
/**
 * Base Plugin class for writing a demand-loaded module.
 * @see [[PluginAdmin]] for a description of how Plugins are loaded.
 * @see [Plugins]($docs/learning/frontend/plugins.md)
 * @public
 */
class Plugin {
    /**
     * Constructor for base Plugin class
     * @param name - the name of the plugin. When you use the buildIModelJsModule build script, this argument is filled in as the PLUGIN_NAME constant by webpack
     * @param versionsRequired - the versions of iModel.js system modules that this Plugin requires. When you use the buildIModelJsModule build script, this argument
     * is filled in as the IMODELJS_VERSIONS_REQUIRED constant by webpack.
     * @note Typically, a Plugin subclass is instantiated and registered with top-level JavaScript statements like these:
     * ```ts
     *  const myPlugin = new MyPlugin(PLUGIN_NAME, IMODELJS_VERSIONS_REQUIRED);
     *  PluginAdmin.register(myPlugin);
     * ```
     */
    constructor(name, versionsRequired) {
        this.name = name;
        this.versionsRequired = versionsRequired;
    }
    /**
     * Method called when the Plugin is first loaded.
     * @param _args arguments that were passed to PluginAdmin.loadPlugin. The first argument is the plugin name.
     */
    onLoad(_args) {
    }
}
exports.Plugin = Plugin;
// this private class represents a Plugin that we are attempting to load.
class PendingPlugin {
    constructor(_packageName, args) {
        this._packageName = _packageName;
        this.args = args;
        this.resolve = undefined;
        this.reject = undefined;
        this.promise = new Promise(this.executor.bind(this));
    }
    executor(resolve, reject) {
        this.resolve = resolve;
        this.reject = reject;
        const head = document.getElementsByTagName("head")[0];
        if (!head)
            reject(new Error("no head element found"));
        // create the script element. handle onload and onerror.
        const scriptElement = document.createElement("script");
        scriptElement.onerror = (ev) => {
            scriptElement.onload = null;
            reject(new Error("can't load " + this._packageName + " : " + ev));
        };
        scriptElement.async = true;
        scriptElement.src = this._packageName;
        head.insertBefore(scriptElement, head.lastChild);
    }
}
/**
 * Controls loading of Plugins and calls methods on newly loaded or reloaded Plugins
 * @public
 */
class PluginAdmin {
    /**
     * Retrieves a previously loaded Plugin.
     * @param pluginName
     */
    static getPlugin(pluginName) {
        // strip off .js if necessary
        pluginName = PluginAdmin.getPluginName(pluginName);
        const plugin = PluginAdmin._registeredPlugins.get(pluginName);
        if (plugin)
            return Promise.resolve(plugin);
        const pluginPromise = PluginAdmin._pendingPlugins.get(pluginName);
        if (pluginPromise) {
            return pluginPromise.promise;
        }
        return undefined;
    }
    // returns an array of strings with version mismatch errors, or undefined if the versions of all modules are usable.
    static checkIModelJsVersions(versionsRequired) {
        // make sure we're in a browser-like environment
        if ((typeof window === "undefined") || !window) {
            return [IModelApp_1.IModelApp.i18n.translate("iModelJs:PluginErrors.FrontEndOnly")];
        }
        const versionsLoaded = window.iModelJsVersions;
        if (!versionsLoaded) {
            return [IModelApp_1.IModelApp.i18n.translate("iModelJs:PluginErrors.NoVersionsLoaded")];
        }
        // make sure the versionsRequired string isn't empty.
        if (!versionsRequired || (0 === versionsRequired.length)) {
            return [IModelApp_1.IModelApp.i18n.translate("iModelJs:PluginErrors.WebpackedIncorrectly")];
        }
        // make sure versionsRequired is a JSON string.
        const errorMessages = [];
        try {
            const versionsRequiredObject = JSON.parse(versionsRequired);
            for (const moduleName of Object.getOwnPropertyNames(versionsRequiredObject)) {
                // bwc doesn't set its version, so we have to ignore it for now.
                if (moduleName === "bwc") {
                    continue;
                }
                const versionRequired = versionsRequiredObject[moduleName];
                if (!versionRequired || "string" !== typeof (versionRequired)) {
                    errorMessages.push(IModelApp_1.IModelApp.i18n.translate("iModelJs:PluginErrors.NoVersionSpecified", { moduleName }));
                }
                else {
                    const versionLoaded = versionsLoaded.get(moduleName);
                    if (!versionLoaded) {
                        errorMessages.push(IModelApp_1.IModelApp.i18n.translate("iModelJs:PluginErrors.ModuleNotLoaded", { moduleName }));
                    }
                    else {
                        // check version required vs. version loaded.
                        if (!semver.satisfies(versionLoaded, versionRequired)) {
                            errorMessages.push(IModelApp_1.IModelApp.i18n.translate("iModelJs:PluginErrors.VersionMismatch", { versionLoaded, moduleName, versionRequired }));
                        }
                    }
                }
            }
        }
        catch (err) {
            return [IModelApp_1.IModelApp.i18n.translate("iModelJs:PluginErrors.WebpackedIncorrectly")];
        }
        return (errorMessages.length > 0) ? errorMessages : undefined;
    }
    static getPluginName(packageName) {
        if (packageName.endsWith(".js"))
            return packageName.substr(0, packageName.length - 3);
        return packageName;
    }
    /**
     * Loads a Plugin
     * @param packageName the name of the JavaScript file to be loaded from the web server.
     * @param args arguments that will be passed to the Plugin.onLoaded and Plugin.onExecute methods. If the first argument is not the plugin name, the plugin name will be prepended to the args array.
     */
    static async loadPlugin(packageName, args) {
        // see if it is already loaded.
        const pluginName = PluginAdmin.getPluginName(packageName);
        // make sure there's an args and make sure the first element is the plugin name.
        if (!args) {
            args = [pluginName];
        }
        else {
            if ((args.length < 1) || (args[0] !== pluginName)) {
                const newArray = [pluginName];
                args = newArray.concat(args);
            }
        }
        const pendingPlugin = PluginAdmin._pendingPlugins.get(pluginName);
        if (undefined !== pendingPlugin) {
            // it has been loaded (or at least we have started to load it) already. If it is registered, call its reload method. (Otherwise reload called when we're done the initial load)
            const registeredPlugin = PluginAdmin._registeredPlugins.get(pluginName);
            if (registeredPlugin) {
                registeredPlugin.onExecute(args);
            }
            return pendingPlugin.promise;
        }
        // set it up to load.
        const newPendingPlugin = new PendingPlugin(packageName, args);
        // Javascript-ish saving of the arguments in the promise, so we can call reload with them.
        PluginAdmin._pendingPlugins.set(pluginName, newPendingPlugin);
        return newPendingPlugin.promise;
    }
    /**
     * Registers a Plugin with the PluginAdmin. This method is called by the Plugin when it is first loaded.
     * This method verifies that the required versions of the iModel.js system modules are loaded. If those
     * requirements are met, then the onLoad and onExecute methods of the Plugin will be called (@see [[Plugin]]).
     * If not, no further action is taken and the Plugin is not active.
     * @param plugin a newly instantiated subclass of Plugin.
     * @returns an array of error messages. The array will be empty if the load is successful, otherwise it is a list of one or more problems.
     */
    static register(plugin) {
        const errorMessages = PluginAdmin.checkIModelJsVersions(plugin.versionsRequired);
        if (errorMessages) {
            // report load errors to the user.
            let allDetails = "";
            for (const thisMessage of errorMessages) {
                allDetails = allDetails.concat(thisMessage, "\n");
            }
            const briefMessage = IModelApp_1.IModelApp.i18n.translate("iModelJs:PluginErrors.VersionErrors", { pluginName: plugin.name });
            const errorDetails = new NotificationManager_1.NotifyMessageDetails(NotificationManager_1.OutputMessagePriority.Info, briefMessage, allDetails, NotificationManager_1.OutputMessageType.Alert, NotificationManager_1.OutputMessageAlert.Balloon);
            IModelApp_1.IModelApp.notifications.outputMessage(errorDetails);
            bentleyjs_core_1.Logger.logError(loggerCategory, plugin.name + " failed to load. Error=" + allDetails);
            return errorMessages;
        }
        PluginAdmin._registeredPlugins.set(plugin.name, plugin);
        // log successful load after plugin is registered.
        bentleyjs_core_1.Logger.logInfo(loggerCategory, plugin.name + " loaded");
        // retrieve the args we saved in the pendingPlugin.
        let args;
        const pendingPlugin = PluginAdmin._pendingPlugins.get(plugin.name);
        if (pendingPlugin) {
            pendingPlugin.resolve(plugin);
            args = pendingPlugin.args;
        }
        if (!args)
            args = [plugin.name];
        plugin.onLoad(args);
        plugin.onExecute(args);
        return undefined;
    }
}
PluginAdmin._pendingPlugins = new Map();
PluginAdmin._registeredPlugins = new Map();
exports.PluginAdmin = PluginAdmin;


/***/ }),

/***/ "./lib/QuantityFormatter.js":
/*!**********************************!*\
  !*** ./lib/QuantityFormatter.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_quantity_1 = __webpack_require__(/*! @bentley/imodeljs-quantity */ "@bentley/imodeljs-quantity");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
/** Class that implements the minimum UnitConversion interface to provide information needed to convert unit values.
 * @alpha
 */
class ConversionData {
    constructor() {
        this.factor = 1.0;
        this.offset = 0.0;
    }
}
exports.ConversionData = ConversionData;
// cSpell:ignore MILLIINCH, MICROINCH, MILLIFOOT
// Set of supported units - this information will come from Schema-based units once the EC package is ready to provide this information.
const unitData = [
    // Angles ( base unit radian )
    { name: "Units.RAD", unitFamily: "Units.ANGLE", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: "rad", altDisplayLabels: ["radian"] },
    // 1 rad = 180.0/PI 
    { name: "Units.ARC_DEG", unitFamily: "Units.ANGLE", conversion: { numerator: 180.0, denominator: 3.1415926535897932384626433832795, offset: 0.0 }, displayLabel: "", altDisplayLabels: ["deg", "^"] },
    { name: "Units.ARC_MINUTE", unitFamily: "Units.ANGLE", conversion: { numerator: 10800.0, denominator: 3.14159265358979323846264338327950, offset: 0.0 }, displayLabel: "'", altDisplayLabels: ["min"] },
    { name: "Units.ARC_SECOND", unitFamily: "Units.ANGLE", conversion: { numerator: 648000.0, denominator: 3.1415926535897932384626433832795, offset: 0.0 }, displayLabel: '"', altDisplayLabels: ["sec"] },
    { name: "Units.GRAD", unitFamily: "Units.ANGLE", conversion: { numerator: 200, denominator: 3.1415926535897932384626433832795, offset: 0.0 }, displayLabel: "grad", altDisplayLabels: ["gd"] },
    // Time ( base unit second )
    { name: "Units.S", unitFamily: "Units.TIME", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: "s", altDisplayLabels: ["sec"] },
    { name: "Units.MIN", unitFamily: "Units.TIME", conversion: { numerator: 1.0, denominator: 60.0, offset: 0.0 }, displayLabel: "min", altDisplayLabels: [] },
    { name: "Units.HR", unitFamily: "Units.TIME", conversion: { numerator: 1.0, denominator: 3600.0, offset: 0.0 }, displayLabel: "h", altDisplayLabels: ["hr"] },
    { name: "Units.DAY", unitFamily: "Units.TIME", conversion: { numerator: 1.0, denominator: 86400.0, offset: 0.0 }, displayLabel: "days", altDisplayLabels: ["day"] },
    { name: "Units.WEEK", unitFamily: "Units.TIME", conversion: { numerator: 1.0, denominator: 604800.0, offset: 0.0 }, displayLabel: "weeks", altDisplayLabels: ["week"] },
    // 1 sec = 1/31536000.0 yr
    { name: "Units.YR", unitFamily: "Units.TIME", conversion: { numerator: 1.0, denominator: 31536000.0, offset: 0.0 }, displayLabel: "years", altDisplayLabels: ["year"] },
    // Length( base unit length )
    { name: "Units.M", unitFamily: "Units.LENGTH", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: "m", altDisplayLabels: ["meter"] },
    { name: "Units.MM", unitFamily: "Units.LENGTH", conversion: { numerator: 1000.0, denominator: 1.0, offset: 0.0 }, displayLabel: "mm", altDisplayLabels: ["MM"] },
    { name: "Units.CM", unitFamily: "Units.LENGTH", conversion: { numerator: 100.0, denominator: 1.0, offset: 0.0 }, displayLabel: "cm", altDisplayLabels: ["CM"] },
    { name: "Units.DM", unitFamily: "Units.LENGTH", conversion: { numerator: 10.0, denominator: 1.0, offset: 0.0 }, displayLabel: "dm", altDisplayLabels: ["DM"] },
    { name: "Units.KM", unitFamily: "Units.LENGTH", conversion: { numerator: 1.0, denominator: 1000.0, offset: 0.0 }, displayLabel: "km", altDisplayLabels: ["KM"] },
    { name: "Units.UM", unitFamily: "Units.LENGTH", conversion: { numerator: 1000000.0, denominator: 1.0, offset: 0.0 }, displayLabel: "m", altDisplayLabels: [] },
    { name: "Units.MILLIINCH", unitFamily: "Units.LENGTH", conversion: { numerator: 1000.0, denominator: 0.0254, offset: 0.0 }, displayLabel: "mil", altDisplayLabels: [] },
    { name: "Units.MICROINCH", unitFamily: "Units.LENGTH", conversion: { numerator: 1000000.0, denominator: 0.0254, offset: 0.0 }, displayLabel: "in", altDisplayLabels: [] },
    { name: "Units.MILLIFOOT", unitFamily: "Units.LENGTH", conversion: { numerator: 1000.0, denominator: 0.3048, offset: 0.0 }, displayLabel: "mft", altDisplayLabels: [] },
    // 1 m = 1/0.0254 "
    { name: "Units.IN", unitFamily: "Units.LENGTH", conversion: { numerator: 1.0, denominator: 0.0254, offset: 0.0 }, displayLabel: "in", altDisplayLabels: ["IN", "\""] },
    { name: "Units.FT", unitFamily: "Units.LENGTH", conversion: { numerator: 1.0, denominator: 0.3048, offset: 0.0 }, displayLabel: "ft", altDisplayLabels: ["F", "FT", "'"] },
    { name: "Units.YRD", unitFamily: "Units.LENGTH", conversion: { numerator: 1.0, denominator: 0.9144, offset: 0.0 }, displayLabel: "yd", altDisplayLabels: ["YRD", "yrd"] },
    { name: "Units.MILE", unitFamily: "Units.LENGTH", conversion: { numerator: 1.0, denominator: 1609.344, offset: 0.0 }, displayLabel: "mi", altDisplayLabels: ["mile", "Miles", "Mile"] },
    { name: "Units.SQ_FT", unitFamily: "Units.AREA", conversion: { numerator: 1.0, denominator: .09290304, offset: 0.0 }, displayLabel: "ft", altDisplayLabels: ["sf"] },
    { name: "Units.SQ_M", unitFamily: "Units.AREA", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: "m", altDisplayLabels: [] },
    { name: "Units.CUB_FT", unitFamily: "Units.AREA", conversion: { numerator: 1.0, denominator: 0.028316847, offset: 0.0 }, displayLabel: "ft", altDisplayLabels: ["cf"] },
    { name: "Units.CUB_M", unitFamily: "Units.AREA", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: "m", altDisplayLabels: [] },
];
/** Defines standard format types for tools that need to display measurements to user.
 * @alpha
 */
var QuantityType;
(function (QuantityType) {
    QuantityType[QuantityType["Length"] = 1] = "Length";
    QuantityType[QuantityType["Angle"] = 2] = "Angle";
    QuantityType[QuantityType["Area"] = 3] = "Area";
    QuantityType[QuantityType["Volume"] = 4] = "Volume";
    QuantityType[QuantityType["LatLong"] = 5] = "LatLong";
    QuantityType[QuantityType["Coordinate"] = 6] = "Coordinate";
})(QuantityType = exports.QuantityType || (exports.QuantityType = {}));
// The following provide default formats for different the QuantityTypes. It is important to note that these default should reference
// units that are available from the registered units provider.
const defaultsFormats = {
    metric: [{
            type: 1 /*Length*/, format: {
                composite: {
                    includeZero: true,
                    spacer: " ",
                    units: [
                        {
                            label: "m",
                            name: "Units.M",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 4,
                type: "Decimal",
            },
        }, {
            type: 2 /*Angle*/, format: {
                composite: {
                    includeZero: true,
                    spacer: "",
                    units: [
                        {
                            label: "",
                            name: "Units.ARC_DEG",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 2,
                type: "Decimal",
                uomSeparator: "",
            },
        }, {
            type: 3 /*Area*/, format: {
                composite: {
                    includeZero: true,
                    spacer: " ",
                    units: [
                        {
                            label: "m",
                            name: "Units.SQ_M",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 4,
                type: "Decimal",
            },
        }, {
            type: 4 /*Volume*/, format: {
                composite: {
                    includeZero: true,
                    spacer: " ",
                    units: [
                        {
                            label: "m",
                            name: "Units.CUB_M",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 4,
                type: "Decimal",
            },
        }, {
            type: 5 /*LatLong*/, format: {
                composite: {
                    includeZero: true,
                    spacer: "",
                    units: [
                        {
                            label: "",
                            name: "Units.ARC_DEG",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 6,
                type: "Decimal",
                uomSeparator: "",
            },
        }, {
            type: 6 /*Coordinate*/, format: {
                composite: {
                    includeZero: true,
                    spacer: " ",
                    units: [
                        {
                            label: "m",
                            name: "Units.M",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 2,
                type: "Decimal",
            },
        },
    ],
    imperial: [{
            type: 1 /*Length*/, format: {
                composite: {
                    includeZero: true,
                    spacer: "-",
                    units: [{ label: "'", name: "Units.FT" }, { label: "\"", name: "Units.IN" }],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 8,
                type: "Fractional",
                uomSeparator: "",
            },
        }, {
            type: 2 /*Angle*/, format: {
                composite: {
                    includeZero: true,
                    spacer: "",
                    units: [
                        {
                            label: "",
                            name: "Units.ARC_DEG",
                        },
                        {
                            label: "'",
                            name: "Units.ARC_MINUTE",
                        },
                        {
                            label: "\"",
                            name: "Units.ARC_SECOND",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 2,
                type: "Decimal",
                uomSeparator: "",
            },
        }, {
            type: 3 /*Area*/, format: {
                composite: {
                    includeZero: true,
                    spacer: " ",
                    units: [
                        {
                            label: "ft",
                            name: "Units.SQ_FT",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 4,
                type: "Decimal",
            },
        }, {
            type: 4 /*Volume*/, format: {
                composite: {
                    includeZero: true,
                    spacer: " ",
                    units: [
                        {
                            label: "ft",
                            name: "Units.CUB_FT",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 4,
                type: "Decimal",
            },
        }, {
            type: 5 /*LatLong*/, format: {
                composite: {
                    includeZero: true,
                    spacer: "",
                    units: [
                        {
                            label: "",
                            name: "Units.ARC_DEG",
                        },
                        {
                            label: "'",
                            name: "Units.ARC_MINUTE",
                        },
                        {
                            label: "\"",
                            name: "Units.ARC_SECOND",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 0,
                type: "Decimal",
                uomSeparator: "",
            },
        }, {
            type: 6 /*Coordinate*/, format: {
                composite: {
                    includeZero: true,
                    spacer: " ",
                    units: [
                        {
                            label: "ft",
                            name: "Units.FT",
                        },
                    ],
                },
                formatTraits: ["keepSingleZero", "showUnitLabel"],
                precision: 2,
                type: "Decimal",
            },
        },
    ],
};
/** Formats quantity values into strings.
 * @alpha
 */
class QuantityFormatter {
    constructor() {
        this._activeSystemIsImperial = true;
        this._formatSpecsByKoq = new Map();
        this._imperialFormatsByType = new Map();
        this._metricFormatsByType = new Map();
        this._imperialFormatSpecsByType = new Map();
        this._metricFormatSpecsByType = new Map();
        this._imperialParserSpecsByType = new Map();
        this._metricUnitParserSpecsByType = new Map();
    }
    /** Find a unit given the unitLabel. */
    async findUnit(unitLabel, unitFamily) {
        for (const entry of unitData) {
            if (unitFamily) {
                if (entry.unitFamily !== unitFamily)
                    continue;
            }
            if (entry.displayLabel === unitLabel || entry.name === unitLabel) {
                const unitProps = new imodeljs_quantity_1.BasicUnit(entry.name, entry.displayLabel, entry.unitFamily, entry.altDisplayLabels);
                return Promise.resolve(unitProps);
            }
            if (entry.altDisplayLabels && entry.altDisplayLabels.length > 0) {
                if (entry.altDisplayLabels.findIndex((ref) => ref === unitLabel) !== -1) {
                    const unitProps = new imodeljs_quantity_1.BasicUnit(entry.name, entry.displayLabel, entry.unitFamily, entry.altDisplayLabels);
                    return Promise.resolve(unitProps);
                }
            }
        }
        return Promise.resolve(new imodeljs_quantity_1.BadUnit());
    }
    /** find all units given unitFamily */
    async getUnitsByFamily(unitFamily) {
        const units = [];
        for (const entry of unitData) {
            if (entry.unitFamily !== unitFamily)
                continue;
            units.push(new imodeljs_quantity_1.BasicUnit(entry.name, entry.displayLabel, entry.unitFamily, entry.altDisplayLabels));
        }
        return Promise.resolve(units);
    }
    findUnitDefinition(name) {
        for (const entry of unitData) {
            if (entry.name === name)
                return entry;
        }
        return undefined;
    }
    /** Find a unit given the unit's unique name. */
    async findUnitByName(unitName) {
        const unitDataEntry = this.findUnitDefinition(unitName);
        if (unitDataEntry) {
            return Promise.resolve(new imodeljs_quantity_1.BasicUnit(unitDataEntry.name, unitDataEntry.displayLabel, unitDataEntry.unitFamily, unitDataEntry.altDisplayLabels));
        }
        return Promise.resolve(new imodeljs_quantity_1.BadUnit());
    }
    /** Return the information needed to convert a value between two different units.  The units should be from the same unitFamily. */
    async getConversion(fromUnit, toUnit) {
        const fromUnitData = this.findUnitDefinition(fromUnit.name);
        const toUnitData = this.findUnitDefinition(toUnit.name);
        if (fromUnitData && toUnitData) {
            const deltaOffset = toUnitData.conversion.offset - fromUnitData.conversion.offset;
            const deltaNumerator = toUnitData.conversion.numerator * fromUnitData.conversion.denominator;
            const deltaDenominator = toUnitData.conversion.denominator * fromUnitData.conversion.numerator;
            const conversion = new ConversionData();
            conversion.factor = deltaNumerator / deltaDenominator;
            conversion.offset = deltaOffset;
            return Promise.resolve(conversion);
        }
        return Promise.resolve(new ConversionData());
    }
    /** method used to load format for KOQ into cache */
    async loadKoqFormatSpecs(koq) {
        if (koq.length === 0)
            return Promise.reject(new Error("bad koq specification"));
        if (!this._formatSpecsByKoq.has(koq)) {
            // get koq and get formats from it
        }
        return Promise.reject(new Error("not yet implemented"));
    }
    /** Async method to return the array of presentation formats for the specified KOQ */
    async getKoqFormatterSpecsAsync(koq, useImperial) {
        if (koq.length === 0 && useImperial)
            return Promise.reject(new Error("bad koq specification"));
        return Promise.resolve(this._formatSpecsByKoq.get(koq));
    }
    /** Async method to return the 'active' FormatSpec for the specified KOQ */
    async getKoqFormatterSpec(koq, useImperial) {
        if (koq.length === 0 && useImperial)
            return Promise.reject(new Error("bad koq specification"));
        const formatterSpecArray = await Promise.resolve(this._formatSpecsByKoq.get(koq));
        if (formatterSpecArray && formatterSpecArray.length > 0) {
            const activeFormatIndex = 0; // TODO - get active format based on user selected format or default format
            return Promise.resolve(formatterSpecArray[activeFormatIndex]);
        }
        return Promise.reject(new Error("not yet implemented"));
    }
    /** Method used to get cached FormatterSpec or undefined if FormatterSpec is unavailable */
    findKoqFormatterSpec(koq, useImperial) {
        if (koq.length === 0 && useImperial)
            return undefined;
        throw new Error("not yet implemented");
    }
    async loadStdFormat(type, imperial) {
        let formatData;
        const formatArray = imperial ? defaultsFormats.imperial : defaultsFormats.metric;
        for (const entry of formatArray) {
            if (entry.type === type) {
                formatData = entry.format;
                const format = new imodeljs_quantity_1.Format("stdFormat");
                await format.fromJson(this, formatData);
                return Promise.resolve(format);
            }
        }
        throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "IModelApp must define a formatsProvider class to provide formats for tools");
    }
    async getFormatByQuantityType(type, imperial) {
        const activeMap = imperial ? this._imperialFormatsByType : this._metricFormatsByType;
        let format = activeMap.get(type);
        if (format)
            return Promise.resolve(format);
        format = await this.loadStdFormat(type, imperial);
        if (format) {
            activeMap.set(type, format);
            return Promise.resolve(format);
        }
        throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "IModelApp must define a formatsProvider class to provide formats for tools");
    }
    /** Async request to get the 'persistence' unit from the UnitsProvider. For a tool this 'persistence' unit is the unit being used by the tool internally. */
    async getUnitByQuantityType(type) {
        switch (type) {
            case QuantityType.Angle:
            case QuantityType.LatLong:
                return this.findUnitByName("Units.RAD");
            case QuantityType.Area:
                return this.findUnitByName("Units.SQ_M");
            case QuantityType.Volume:
                return this.findUnitByName("Units.M");
            case QuantityType.Coordinate:
            case QuantityType.Length:
            default:
                return this.findUnitByName("Units.M");
        }
    }
    /** Asynchronous call to loadParsingSpecsForQuantityTypes. This method caches all the ParserSpecs so they can be quickly accessed. */
    async loadParsingSpecsForQuantityTypes(useImperial) {
        const typeArray = [QuantityType.Length, QuantityType.Angle, QuantityType.Area, QuantityType.Volume, QuantityType.LatLong, QuantityType.Coordinate];
        const activeMap = useImperial ? this._imperialParserSpecsByType : this._metricUnitParserSpecsByType;
        activeMap.clear();
        for (const quantityType of typeArray) {
            const formatPromise = this.getFormatByQuantityType(quantityType, useImperial);
            const unitPromise = this.getUnitByQuantityType(quantityType);
            const [format, outUnit] = await Promise.all([formatPromise, unitPromise]);
            const parserSpec = await imodeljs_quantity_1.ParserSpec.create(format, this, outUnit);
            activeMap.set(quantityType, parserSpec);
        }
        return Promise.resolve();
    }
    /** Asynchronous call to loadFormatSpecsForQuantityTypes. This method caches all the FormatSpec so they can be quickly accessed. */
    async loadFormatSpecsForQuantityTypes(useImperial) {
        const typeArray = [QuantityType.Length, QuantityType.Angle, QuantityType.Area, QuantityType.Volume, QuantityType.LatLong, QuantityType.Coordinate];
        const activeMap = useImperial ? this._imperialFormatSpecsByType : this._metricFormatSpecsByType;
        activeMap.clear();
        for (const quantityType of typeArray) {
            const formatPromise = this.getFormatByQuantityType(quantityType, useImperial);
            const unitPromise = this.getUnitByQuantityType(quantityType);
            const [format, unit] = await Promise.all([formatPromise, unitPromise]);
            const spec = await imodeljs_quantity_1.FormatterSpec.create(format.name, format, this, unit);
            activeMap.set(quantityType, spec);
        }
        return Promise.resolve();
    }
    /** Synchronous call to get a FormatterSpec of a QuantityType. If the FormatterSpec is not yet cached an undefined object is returned. The
     * cache is populated by the async call loadFormatSpecsForQuantityTypes.
     */
    findFormatterSpecByQuantityType(type, imperial) {
        const useImperial = undefined !== imperial ? imperial : this._activeSystemIsImperial;
        const activeMap = useImperial ? this._imperialFormatSpecsByType : this._metricFormatSpecsByType;
        if (activeMap.size === 0) {
            // trigger a load so it will become available
            this.loadFormatSpecsForQuantityTypes(useImperial); // tslint:disable-line:no-floating-promises
            return undefined;
        }
        return activeMap.get(type);
    }
    /** Asynchronous Call to get a FormatterSpec of a QuantityType.
     * @param type        One of the built-in quantity types supported.
     * @param imperial    Optional parameter to determine if the imperial or metric format should be returned. If undefined then the setting is taken from the formatter.
     * @return A promise to return a FormatterSpec.
     */
    async getFormatterSpecByQuantityType(type, imperial) {
        const useImperial = undefined !== imperial ? imperial : this._activeSystemIsImperial;
        const activeMap = useImperial ? this._imperialFormatSpecsByType : this._metricFormatSpecsByType;
        if (activeMap.size > 0)
            return Promise.resolve(activeMap.get(type));
        return this.loadFormatSpecsForQuantityTypes(useImperial)
            .then(async () => {
            if (activeMap.size > 0) {
                const spec = activeMap.get(type);
                if (spec)
                    return Promise.resolve(spec);
            }
            return Promise.reject(new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Unable to load FormatSpecs"));
        });
    }
    /** Synchronous call to get a ParserSpec for a QuantityType. If the ParserSpec is not yet cached an undefined object is returned. The
     * cache is populated by the async call loadFormatSpecsForQuantityTypes.
     */
    findParserSpecByQuantityType(type, imperial) {
        const useImperial = undefined !== imperial ? imperial : this._activeSystemIsImperial;
        const activeMap = useImperial ? this._imperialParserSpecsByType : this._metricUnitParserSpecsByType;
        if (activeMap.size === 0) {
            // trigger a load so it will become available
            this.loadParsingSpecsForQuantityTypes(useImperial); // tslint:disable-line:no-floating-promises
            return undefined;
        }
        return activeMap.get(type);
    }
    /** Asynchronous Call to get a ParserSpec for a QuantityType.
     * @param type        One of the built-in quantity types supported.
     * @param imperial    Optional parameter to determine if the imperial or metric format should be returned. If undefined then the setting is taken from the formatter.
     * @return A promise to return a ParserSpec.
     */
    async getParserSpecByQuantityType(type, imperial) {
        const useImperial = undefined !== imperial ? imperial : this._activeSystemIsImperial;
        const activeMap = useImperial ? this._imperialParserSpecsByType : this._metricUnitParserSpecsByType;
        if (activeMap.size > 0)
            return Promise.resolve(activeMap.get(type));
        return this.loadParsingSpecsForQuantityTypes(useImperial)
            .then(async () => {
            if (activeMap.size > 0) {
                const spec = activeMap.get(type);
                if (spec)
                    return Promise.resolve(spec);
            }
            return Promise.reject(new bentleyjs_core_1.BentleyError(bentleyjs_core_1.BentleyStatus.ERROR, "Unable to load ParserSpec"));
        });
    }
    /** Generates a formatted string for a quantity given its format spec.
     * @param magnitude       The magnitude of the quantity.
     * @param formatSpec      The format specification. See methods getFormatterSpecByQuantityType and findFormatterSpecByQuantityType.
     * @return the formatted string.
     */
    formatQuantity(magnitude, formatSpec) {
        return imodeljs_quantity_1.Formatter.formatQuantity(magnitude, formatSpec);
    }
    /** Parse input string into quantity given the ParserSpec
     * @param inString       The magnitude of the quantity.
     * @param parserSpec     The parse specification the defines the expected format of the string and the conversion to the output unit.
     * @return ParseResult object containing either the parsed value or an error value if unsuccessful.
     */
    parseIntoQuantityValue(inString, parserSpec) {
        return imodeljs_quantity_1.Parser.parseQuantityString(inString, parserSpec);
    }
    /** Set the flag to return either metric or imperial formats. This call also makes an async request to refresh the cached formats. */
    async loadFormatAndParsingMaps(useImperial) {
        const formatPromise = this.loadFormatSpecsForQuantityTypes(useImperial);
        const parsePromise = this.loadParsingSpecsForQuantityTypes(useImperial);
        await Promise.all([formatPromise, parsePromise]); // tslint:disable-line:no-floating-promises
    }
    /** Set the flag to return either metric or imperial formats. This call also makes an async request to refresh the cached formats. */
    set useImperialFormats(useImperial) {
        IModelApp_1.IModelApp.toolAdmin.startDefaultTool();
        this._activeSystemIsImperial = useImperial;
        this.loadFormatAndParsingMaps(useImperial); // tslint:disable-line:no-floating-promises
    }
    /** Return true if Tool Quantities are to be displayed in Imperial units. If false Metric units are to used. */
    get useImperialFormats() { return this._activeSystemIsImperial; }
}
exports.QuantityFormatter = QuantityFormatter;


/***/ }),

/***/ "./lib/RenderCompatibility.js":
/*!************************************!*\
  !*** ./lib/RenderCompatibility.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module IModelApp */
Object.defineProperty(exports, "__esModule", { value: true });
/** A specific WebGL rendering feature.
 * @beta
 */
var WebGLFeature;
(function (WebGLFeature) {
    /**
     * This feature allows transparency to occur more efficiently.  The renderer will require less passes to achieve
     * transparency due to the presence of enough renderable attachments.
     */
    WebGLFeature["MrtTransparency"] = "mrt transparency";
    /**
     * This feature allows picking to occur more efficiently.  The renderer will require less passes to achieve picking
     * due to the presence of enough renderable attachments.
     */
    WebGLFeature["MrtPick"] = "mrt pick";
    /**
     * This feature provides the renderer a large enough range of element indices for drawing to happen properly.
     */
    WebGLFeature["UintElementIndex"] = "uint element index";
    /**
     * This feature allows transparency to achieve the optimal quality.  Without this feature, transparency will "wash out"
     * more easily.
     */
    WebGLFeature["FloatRendering"] = "float rendering";
    /**
     * This feature allows for the display of non-3D classification data and solar shadows.
     */
    WebGLFeature["DepthTexture"] = "depth texture";
    /**
     * This feature allows instancing of geometry in order to optimize rendering speed.
     */
    WebGLFeature["Instancing"] = "instancing";
    /**
     * This feature indicates that the system has enough texture units available for the shaders to run properly.
     */
    WebGLFeature["MinimalTextureUnits"] = "minimal texture units";
})(WebGLFeature = exports.WebGLFeature || (exports.WebGLFeature = {}));
/** Describes the state of render compatibility.
 * @beta
 */
var WebGLRenderCompatibilityStatus;
(function (WebGLRenderCompatibilityStatus) {
    /**
     * Signifies that everything is ideal: context created successfully, all required and optional features are available,
     * and browser did not signal a major performance caveat.
     */
    WebGLRenderCompatibilityStatus[WebGLRenderCompatibilityStatus["AllOkay"] = 0] = "AllOkay";
    /**
     * Signifies that the base requirements of compatibility are met but at least some optional features are missing.
     * Consult the contents of [[WebGLRenderCompatibilityInfo.missingOptionalFeatures]].
     */
    WebGLRenderCompatibilityStatus[WebGLRenderCompatibilityStatus["MissingOptionalFeatures"] = 1] = "MissingOptionalFeatures";
    /**
     * Signifies that the base requirements of compatibility are met but WebGL reported a major performance caveat.  The browser
     * has likely fallen back to software rendering due to lack of a usable GPU.
     * Consult [[WebGLRenderCompatibilityInfo.contextErrorMessage]] for a possible description of what went wrong.
     * There could also be some missing optional features; consult the contents of [[WebGLRenderCompatibilityInfo.missingOptionalFeatures]].
     */
    WebGLRenderCompatibilityStatus[WebGLRenderCompatibilityStatus["MajorPerformanceCaveat"] = 2] = "MajorPerformanceCaveat";
    /**
     * Signifies that the base requirements of compatibility are not met; rendering cannot occur.
     * Consult the contents of [[WebGLRenderCompatibilityInfo.missingRequiredFeatures]].
     */
    WebGLRenderCompatibilityStatus[WebGLRenderCompatibilityStatus["MissingRequiredFeatures"] = 3] = "MissingRequiredFeatures";
    /**
     * Signifies an inability to create either a canvas or a WebGL rendering context; rendering cannot occur.  Consult
     * [[WebGLRenderCompatibilityInfo.contextErrorMessage]] for a possible description of what went wrong.
     */
    WebGLRenderCompatibilityStatus[WebGLRenderCompatibilityStatus["CannotCreateContext"] = 4] = "CannotCreateContext";
})(WebGLRenderCompatibilityStatus = exports.WebGLRenderCompatibilityStatus || (exports.WebGLRenderCompatibilityStatus = {}));


/***/ }),

/***/ "./lib/RenderScheduleState.js":
/*!************************************!*\
  !*** ./lib/RenderScheduleState.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const FeatureSymbology_1 = __webpack_require__(/*! ./render/FeatureSymbology */ "./lib/render/FeatureSymbology.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const System_1 = __webpack_require__(/*! ./render/System */ "./lib/render/System.js");
/** @internal */
var RenderScheduleState;
(function (RenderScheduleState) {
    class Interval {
        constructor(index0 = 0, index1 = 0, fraction = 0.0) {
            this.index0 = index0;
            this.index1 = index1;
            this.fraction = fraction;
        }
        init(index0, index1, fraction) { this.index0 = index0; this.index1 = index1; this.fraction = fraction; }
    }
    function interpolate(value0, value1, fraction) {
        return value0 + fraction * (value1 - value0);
    }
    class TimelineEntry {
        constructor(props) {
            this.time = props.time;
            this.interpolation = props.interpolation;
        }
    }
    RenderScheduleState.TimelineEntry = TimelineEntry;
    class VisibilityEntry extends TimelineEntry {
        constructor(props) {
            super(props);
            this.value = 100.0;
            this.value = props.value;
        }
    }
    RenderScheduleState.VisibilityEntry = VisibilityEntry;
    class ColorEntry extends TimelineEntry {
        constructor(props) {
            super(props);
            this.value = props.value;
        }
    }
    RenderScheduleState.ColorEntry = ColorEntry;
    class TransformEntry extends TimelineEntry {
        constructor(props) {
            super(props);
            this.value = props.value;
        }
    }
    RenderScheduleState.TransformEntry = TransformEntry;
    class CuttingPlaneEntry extends TimelineEntry {
        constructor(props) {
            super(props);
            this.value = props.value;
        }
    }
    RenderScheduleState.CuttingPlaneEntry = CuttingPlaneEntry;
    class ElementTimeline {
        constructor(elementIds, batchId) { this.elementIds = elementIds; this.batchId = batchId; }
        get isValid() { return this.elementIds.length > 0 && (Array.isArray(this.visibilityTimeline) && this.visibilityTimeline.length > 0) || (Array.isArray(this.colorTimeline) && this.colorTimeline.length > 0); }
        static fromJSON(json) {
            if (!json)
                return new ElementTimeline([], 0);
            const val = new ElementTimeline(json.elementIds, json.batchId);
            if (json.visibilityTimeline) {
                val.visibilityTimeline = [];
                json.visibilityTimeline.forEach((entry) => val.visibilityTimeline.push(new VisibilityEntry(entry)));
            }
            if (json.colorTimeline) {
                val.colorTimeline = [];
                json.colorTimeline.forEach((entry) => val.colorTimeline.push(new ColorEntry(entry)));
            }
            if (json.transformTimeline) {
                val.transformTimeline = [];
                json.transformTimeline.forEach((entry) => val.transformTimeline.push(new TransformEntry(entry)));
            }
            if (json.cuttingPlaneTimeline) {
                val.cuttingPlaneTimeline = [];
                json.cuttingPlaneTimeline.forEach((entry) => val.cuttingPlaneTimeline.push(new CuttingPlaneEntry(entry)));
            }
            return val;
        }
        get duration() {
            const duration = geometry_core_1.Range1d.createNull();
            if (this.visibilityTimeline)
                this.visibilityTimeline.forEach((entry) => duration.extendX(entry.time));
            if (this.colorTimeline)
                this.colorTimeline.forEach((entry) => duration.extendX(entry.time));
            if (this.transformTimeline)
                this.transformTimeline.forEach((entry) => duration.extendX(entry.time));
            if (this.cuttingPlaneTimeline)
                this.cuttingPlaneTimeline.forEach((entry) => duration.extendX(entry.time));
            return duration;
        }
        get containsFeatureOverrides() { return undefined !== this.visibilityTimeline || undefined !== this.colorTimeline; }
        get containsAnimation() { return undefined !== this.transformTimeline || undefined !== this.cuttingPlaneTimeline; }
        static findTimelineInterval(interval, time, timeline) {
            if (!timeline || timeline.length === 0)
                return false;
            if (time < timeline[0].time) {
                interval.init(0, 0, 0);
                return true;
            }
            const last = timeline.length - 1;
            if (time >= timeline[last].time) {
                interval.init(last, last, 0.0);
                return true;
            }
            let i;
            for (i = 0; i < last; i++)
                if (timeline[i].time <= time && timeline[i + 1].time >= time) {
                    interval.init(i, i + 1, timeline[i].interpolation === 2 ? ((time - timeline[i].time) / (timeline[i + 1].time - timeline[i].time)) : 0.0);
                    break;
                }
            return true;
        }
        getVisibilityOverride(time, interval) {
            if (!ElementTimeline.findTimelineInterval(interval, time, this.visibilityTimeline) && this.visibilityTimeline[interval.index0].value !== null)
                return 100.0;
            const timeline = this.visibilityTimeline;
            let visibility = timeline[interval.index0].value;
            if (visibility === undefined || visibility === null)
                return 100.0;
            if (interval.fraction > 0)
                visibility = interpolate(visibility, timeline[interval.index1].value, interval.fraction);
            return visibility;
        }
        getSymbologyOverrides(overrides, time, interval, batchId) {
            let colorOverride, transparencyOverride;
            const visibility = this.getVisibilityOverride(time, interval);
            if (visibility <= 0) {
                overrides.setAnimationNodeNeverDrawn(batchId);
                return;
            }
            if (visibility <= 100)
                transparencyOverride = 1.0 - visibility / 100.0;
            if (ElementTimeline.findTimelineInterval(interval, time, this.colorTimeline) && this.colorTimeline[interval.index0].value !== null) {
                const entry0 = this.colorTimeline[interval.index0].value;
                if (interval.fraction > 0) {
                    const entry1 = this.colorTimeline[interval.index1].value;
                    colorOverride = new imodeljs_common_1.RgbColor(interpolate(entry0.red, entry1.red, interval.fraction), interpolate(entry0.green, entry1.green, interval.fraction), interpolate(entry0.blue, entry1.blue, interval.fraction));
                }
                else
                    colorOverride = new imodeljs_common_1.RgbColor(entry0.red, entry0.green, entry0.blue);
            }
            if (colorOverride || transparencyOverride)
                overrides.overrideAnimationNode(batchId, FeatureSymbology_1.FeatureSymbology.Appearance.fromJSON({ rgb: colorOverride, transparency: transparencyOverride }));
        }
        getAnimationTransform(time, interval) {
            if (!ElementTimeline.findTimelineInterval(interval, time, this.transformTimeline) || this.transformTimeline[interval.index0].value === null)
                return undefined;
            if (interval.index0 < 0)
                return geometry_core_1.Transform.createIdentity();
            const timeline = this.transformTimeline;
            const value = timeline[interval.index0].value;
            const transform = geometry_core_1.Transform.fromJSON(value.transform);
            if (interval.fraction > 0.0) {
                const value1 = timeline[interval.index1].value;
                if (value1.pivot !== null && value1.orientation !== null && value1.position !== null) {
                    const q0 = geometry_core_1.Point4d.fromJSON(value.orientation), q1 = geometry_core_1.Point4d.fromJSON(value1.orientation);
                    const sum = geometry_core_1.Point4d.interpolateQuaternions(q0, interval.fraction, q1);
                    const interpolatedMatrix = geometry_core_1.Matrix3d.createFromQuaternion(sum);
                    const position0 = geometry_core_1.Vector3d.fromJSON(value.position), position1 = geometry_core_1.Vector3d.fromJSON(value1.position);
                    const pivot = geometry_core_1.Vector3d.fromJSON(value.pivot);
                    const pre = geometry_core_1.Transform.createTranslation(pivot);
                    const post = geometry_core_1.Transform.createTranslation(position0.interpolate(interval.fraction, position1));
                    const product = post.multiplyTransformMatrix3d(interpolatedMatrix);
                    transform.setFromJSON(product.multiplyTransformTransform(pre));
                }
                else {
                    const transform1 = geometry_core_1.Transform.fromJSON(value1.transform);
                    const q0 = transform.matrix.inverse().toQuaternion(), q1 = transform1.matrix.inverse().toQuaternion();
                    const sum = geometry_core_1.Point4d.interpolateQuaternions(q0, interval.fraction, q1);
                    const interpolatedMatrix = geometry_core_1.Matrix3d.createFromQuaternion(sum);
                    const origin = geometry_core_1.Vector3d.createFrom(transform.origin), origin1 = geometry_core_1.Vector3d.createFrom(transform1.origin);
                    transform.setFromJSON({ origin: origin.interpolate(interval.fraction, origin1), matrix: interpolatedMatrix });
                }
            }
            return transform;
        }
        getAnimationClip(time, interval) {
            if (this.currentClip) {
                this.currentClip.dispose();
                this.currentClip = undefined;
            }
            if (!ElementTimeline.findTimelineInterval(interval, time, this.cuttingPlaneTimeline) || this.cuttingPlaneTimeline[interval.index0].value === null)
                return undefined;
            const timeline = this.cuttingPlaneTimeline;
            const value = timeline[interval.index0].value;
            if (!value)
                return undefined;
            const position = geometry_core_1.Point3d.fromJSON(value.position);
            const direction = geometry_core_1.Vector3d.fromJSON(value.direction);
            if (interval.fraction > 0.0) {
                const value1 = timeline[interval.index1].value;
                position.interpolate(interval.fraction, geometry_core_1.Point3d.fromJSON(value1.position), position);
                direction.interpolate(interval.fraction, geometry_core_1.Vector3d.fromJSON(value1.direction), direction);
            }
            else {
                if (value.hidden || value.visible)
                    return undefined;
            }
            direction.normalizeInPlace();
            const plane = geometry_core_1.Plane3dByOriginAndUnitNormal.create(position, direction);
            const clipPlane = geometry_core_1.ClipPlane.createPlane(plane);
            const clipPlaneSet = geometry_core_1.UnionOfConvexClipPlaneSets.createConvexSets([geometry_core_1.ConvexClipPlaneSet.createPlanes([clipPlane])]);
            const clipPrimitive = geometry_core_1.ClipPrimitive.createCapture(clipPlaneSet);
            const clipVector = geometry_core_1.ClipVector.createCapture([clipPrimitive]);
            this.currentClip = IModelApp_1.IModelApp.renderSystem.createClipVolume(clipVector);
            return this.currentClip;
        }
    }
    RenderScheduleState.ElementTimeline = ElementTimeline;
    class ModelTimeline {
        constructor(modelId) {
            this.elementTimelines = [];
            this.containsFeatureOverrides = false;
            this.containsAnimation = false;
            this.modelId = modelId;
        }
        get duration() {
            const duration = geometry_core_1.Range1d.createNull();
            this.elementTimelines.forEach((element) => duration.extendRange(element.duration));
            return duration;
        }
        static fromJSON(json) {
            if (!json)
                return new ModelTimeline("");
            const value = new ModelTimeline(json.modelId);
            if (json.elementTimelines)
                json.elementTimelines.forEach((element) => {
                    const elementTimeline = ElementTimeline.fromJSON(element);
                    value.elementTimelines.push(elementTimeline);
                    if (elementTimeline.containsFeatureOverrides)
                        value.containsFeatureOverrides = true;
                    if (elementTimeline.containsAnimation)
                        value.containsAnimation = true;
                });
            return value;
        }
        getSymbologyOverrides(overrides, time) { const interval = new Interval(); this.elementTimelines.forEach((entry) => entry.getSymbologyOverrides(overrides, time, interval, entry.batchId)); }
        forEachAnimatedId(idFunction) {
            if (this.containsAnimation) {
                for (const timeline of this.elementTimelines)
                    if (timeline.containsAnimation)
                        for (const id of timeline.elementIds)
                            idFunction(id);
            }
        }
        getAnimationBranches(branches, scheduleTime) {
            const interval = new Interval();
            for (let i = 0; i < this.elementTimelines.length; i++) {
                const elementTimeline = this.elementTimelines[i];
                if (elementTimeline.getVisibilityOverride(scheduleTime, interval) <= 0.0) {
                    branches.set(this.modelId + "_Node_" + (i + 1).toString(), new System_1.AnimationBranchState(undefined, undefined, true));
                }
                else {
                    const transform = elementTimeline.getAnimationTransform(scheduleTime, interval);
                    const clip = elementTimeline.getAnimationClip(scheduleTime, interval);
                    if (transform || clip)
                        branches.set(this.modelId + "_Node_" + (i + 1).toString(), new System_1.AnimationBranchState(transform, clip));
                }
            }
        }
    }
    RenderScheduleState.ModelTimeline = ModelTimeline;
    class Script {
        constructor(displayStyleId, iModel) {
            this.modelTimelines = [];
            this.displayStyleId = displayStyleId;
            this.iModel = iModel;
        }
        static fromJSON(displayStyleId, iModel, modelTimelines) {
            const value = new Script(displayStyleId, iModel);
            modelTimelines.forEach((entry) => value.modelTimelines.push(ModelTimeline.fromJSON(entry)));
            return value;
        }
        get containsAnimation() {
            for (const modelTimeline of this.modelTimelines)
                if (modelTimeline.containsAnimation)
                    return true;
            return false;
        }
        getAnimationBranches(scheduleTime) {
            if (!this.containsAnimation)
                return undefined;
            const animationBranches = new Map();
            this.modelTimelines.forEach((modelTimeline) => modelTimeline.getAnimationBranches(animationBranches, scheduleTime));
            return animationBranches;
        }
        get duration() {
            const duration = geometry_core_1.Range1d.createNull();
            this.modelTimelines.forEach((model) => duration.extendRange(model.duration));
            return duration;
        }
        get containsFeatureOverrides() {
            let containsFeatureOverrides = false;
            this.modelTimelines.forEach((entry) => { if (entry.containsFeatureOverrides)
                containsFeatureOverrides = true; });
            return containsFeatureOverrides;
        }
        getSymbologyOverrides(overrides, time) {
            this.modelTimelines.forEach((entry) => entry.getSymbologyOverrides(overrides, time));
        }
        getModelAnimationId(modelId) {
            if (bentleyjs_core_1.Id64.isTransient(modelId))
                return undefined;
            for (const modelTimeline of this.modelTimelines)
                if (modelTimeline.modelId === modelId && modelTimeline.containsAnimation)
                    return this.displayStyleId;
            return undefined;
        }
    }
    RenderScheduleState.Script = Script;
})(RenderScheduleState = exports.RenderScheduleState || (exports.RenderScheduleState = {}));


/***/ }),

/***/ "./lib/SelectionSet.js":
/*!*****************************!*\
  !*** ./lib/SelectionSet.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module SelectionSet */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
/** Identifies the type of changes made to the [[SelectionSet]] to produce a [[SelectionSetEvent]].
 * @public
 */
var SelectionSetEventType;
(function (SelectionSetEventType) {
    /** Elements have been added to the set. */
    SelectionSetEventType[SelectionSetEventType["Add"] = 0] = "Add";
    /** Elements have been removed from the set. */
    SelectionSetEventType[SelectionSetEventType["Remove"] = 1] = "Remove";
    /** Some elements have been added to the set and others have been removed. */
    SelectionSetEventType[SelectionSetEventType["Replace"] = 2] = "Replace";
    /** All elements are about to be removed from the set. */
    SelectionSetEventType[SelectionSetEventType["Clear"] = 3] = "Clear";
})(SelectionSetEventType = exports.SelectionSetEventType || (exports.SelectionSetEventType = {}));
/** Tracks a set of hilited entities. When the set changes, notifies ViewManager so that symbology overrides can be updated in active Viewports.
 * @internal
 */
class HilitedIds extends bentleyjs_core_1.Id64.Uint32Set {
    constructor(iModel) {
        super();
        this._changing = false;
        this._iModel = iModel;
    }
    add(low, high) {
        super.add(low, high);
        this.onChanged();
    }
    delete(low, high) {
        super.delete(low, high);
        this.onChanged();
    }
    clear() {
        super.clear();
        this.onChanged();
    }
    addIds(ids) {
        this.change(() => super.addIds(ids));
    }
    deleteIds(ids) {
        this.change(() => super.deleteIds(ids));
    }
    onChanged() {
        if (!this._changing)
            IModelApp_1.IModelApp.viewManager.onSelectionSetChanged(this._iModel);
    }
    change(func) {
        const changing = this._changing;
        this._changing = false;
        func();
        this._changing = changing;
        this.onChanged();
    }
}
/** Keeps the set of hilited elements in sync with the selection set.
 * @internal
 */
class HilitedElementIds extends HilitedIds {
    constructor(iModel, syncWithSelectionSet = true) {
        super(iModel);
        this.wantSyncWithSelectionSet = syncWithSelectionSet;
    }
    get wantSyncWithSelectionSet() { return undefined !== this._removeListener; }
    set wantSyncWithSelectionSet(want) {
        if (want === this.wantSyncWithSelectionSet)
            return;
        if (want) {
            const set = this._iModel.selectionSet;
            this._removeListener = set.onChanged.addListener((ev) => this.change(() => this.processSelectionSetEvent(ev)));
            this.processSelectionSetEvent({
                set,
                type: SelectionSetEventType.Add,
                added: set.elements,
            });
        }
        else {
            this._removeListener();
            this._removeListener = undefined;
        }
    }
    processSelectionSetEvent(ev) {
        if (SelectionSetEventType.Add !== ev.type)
            this.deleteIds(ev.removed);
        if (ev.type === SelectionSetEventType.Add || ev.type === SelectionSetEventType.Replace)
            this.addIds(ev.added);
    }
}
/** A set of *hilited* elements for an [[IModelConnection]], by element id.
 * Hilited elements are displayed with a customizable hilite effect within a [[Viewport]].
 * The set exposes 3 types of elements in 3 separate collections: geometric elements, subcategories, and geometric models.
 * @note Typically, elements are hilited by virtue of their presence in the IModelConnection's [[SelectionSet]]. The HiliteSet allows additional
 * elements to be displayed with the hilite effect without adding them to the [[SelectionSet]].
 * @see [Hilite.Settings]($common) for customization of the hilite effect.
 * @alpha
 */
class HiliteSet {
    /** Construct a HiliteSet
     * @param iModel The iModel containing the entities to be hilited.
     * @param syncWithSelectionSet If true, the contents of the `elements` set will be synchronized with those in the `iModel`'s [[SelectionSet]].
     */
    constructor(iModel, syncWithSelectionSet = true) {
        this.iModel = iModel;
        this._elements = new HilitedElementIds(iModel, syncWithSelectionSet);
        this.subcategories = new HilitedIds(iModel);
        this.models = new HilitedIds(iModel);
    }
    get elements() { return this._elements; }
    /** Control whether the hilited elements will be synchronized with the contents of the [[SelectionSet]].
     * By default they are synchronized. Applications that override this take responsibility for managing the set of hilited entities.
     * When turning synchronization off, the contents of the HiliteSet will remain unchanged.
     * When turning synchronization on, the current contents of the HiliteSet will be preserved, and the contents of the selection set will be added to them.
     */
    get wantSyncWithSelectionSet() { return this._elements.wantSyncWithSelectionSet; }
    set wantSyncWithSelectionSet(want) { this._elements.wantSyncWithSelectionSet = want; }
    /** Remove all elements from the hilited set. */
    clear() {
        this.elements.clear();
        this.subcategories.clear();
        this.models.clear();
    }
    get isEmpty() { return this.elements.isEmpty && this.subcategories.isEmpty && this.models.isEmpty; }
    /** Toggle the hilited state of one or more elements.
     * @param arg the ID(s) of the elements whose state is to be toggled.
     * @param onOff True to add the elements to the hilited set, false to remove them.
     */
    setHilite(arg, onOff) {
        if (onOff)
            bentleyjs_core_1.Id64.forEach(arg, (id) => this.elements.addId(id));
        else
            bentleyjs_core_1.Id64.forEach(arg, (id) => this.elements.deleteId(id));
        IModelApp_1.IModelApp.viewManager.onSelectionSetChanged(this.iModel);
    }
}
exports.HiliteSet = HiliteSet;
/** A set of *currently selected* elements for an IModelConnection.
 * Selected elements are displayed with a customizable hilite effect within a [[Viewport]].
 * @see [Hilite.Settings]($common) for customization of the hilite effect.
 * @public
 */
class SelectionSet {
    constructor(iModel) {
        this.iModel = iModel;
        this._elements = new Set();
        /** Called whenever elements are added or removed from this SelectionSet */
        this.onChanged = new bentleyjs_core_1.BeEvent();
    }
    /** The IDs of the selected elements.
     * @note Do not modify this set directly. Instead, use methods like [[SelectionSet.add]].
     */
    get elements() { return this._elements; }
    sendChangedEvent(ev) {
        IModelApp_1.IModelApp.viewManager.onSelectionSetChanged(this.iModel);
        this.onChanged.raiseEvent(ev);
    }
    /** Get the number of entries in this selection set. */
    get size() { return this.elements.size; }
    /** Check whether there are any selected elements. */
    get isActive() { return this.size !== 0; }
    /** Return true if elemId is in this SelectionSet.
     * @see [[isSelected]]
     */
    has(elemId) { return !!elemId && this.elements.has(elemId); }
    /** Query whether an Id is in the selection set.
     * @see [[has]]
     */
    isSelected(elemId) { return !!elemId && this.elements.has(elemId); }
    /** Clear current selection set.
     * @note raises the [[onChanged]] event with [[SelectionSetEventType.Clear]].
     */
    emptyAll() {
        if (!this.isActive)
            return;
        const removed = this._elements;
        this._elements = new Set();
        this.sendChangedEvent({ set: this, type: SelectionSetEventType.Clear, removed });
    }
    /**
     * Add one or more Ids to the current selection set.
     * @param elem The set of Ids to add.
     * @returns true if any elements were added.
     */
    add(elem) {
        return this._add(elem);
    }
    _add(elem, sendEvent = true) {
        const oldSize = this.elements.size;
        bentleyjs_core_1.Id64.forEach(elem, (id) => this.elements.add(id));
        const changed = oldSize !== this.elements.size;
        if (sendEvent && changed)
            this.sendChangedEvent({ type: SelectionSetEventType.Add, set: this, added: elem });
        return changed;
    }
    /**
     * Remove one or more Ids from the current selection set.
     * @param elem The set of Ids to remove.
     * @returns true if any elements were removed.
     */
    remove(elem) {
        return this._remove(elem);
    }
    _remove(elem, sendEvent = true) {
        const oldSize = this.elements.size;
        bentleyjs_core_1.Id64.forEach(elem, (id) => this.elements.delete(id));
        const changed = oldSize !== this.elements.size;
        if (sendEvent && changed)
            this.sendChangedEvent({ type: SelectionSetEventType.Remove, set: this, removed: elem });
        return changed;
    }
    /**
     * Add one set of Ids, and remove another set of Ids. Any Ids that are in both sets are removed.
     * @returns True if any Ids were either added or removed.
     */
    addAndRemove(adds, removes) {
        const added = this._add(adds, false);
        const removed = this._remove(removes, false);
        if (added && removed)
            this.sendChangedEvent({ type: SelectionSetEventType.Replace, set: this, added: adds, removed: removes });
        else if (added)
            this.sendChangedEvent({ type: SelectionSetEventType.Add, set: this, added: adds });
        else if (removed)
            this.sendChangedEvent({ type: SelectionSetEventType.Remove, set: this, removed: removes });
        return (added || removed);
    }
    /** Invert the state of a set of Ids in the SelectionSet */
    invert(elem) {
        const elementsToAdd = new Set();
        const elementsToRemove = new Set();
        bentleyjs_core_1.Id64.forEach(elem, (id) => {
            if (this.elements.has(id))
                elementsToRemove.add(id);
            else
                elementsToAdd.add(id);
        });
        return this.addAndRemove(elementsToAdd, elementsToRemove);
    }
    /** Change selection set to be the supplied set of Ids. */
    replace(elem) {
        if (areEqual(this.elements, elem))
            return;
        const removed = this._elements;
        this._elements = new Set();
        this._add(elem, false);
        if (0 < removed.size) {
            bentleyjs_core_1.Id64.forEach(elem, (id) => {
                if (removed.has(id))
                    removed.delete(id);
            });
        }
        this.sendChangedEvent({ type: SelectionSetEventType.Replace, set: this, added: elem, removed });
    }
}
exports.SelectionSet = SelectionSet;
function areEqual(lhs, rhs) {
    // Size is unreliable if input can contain duplicates...
    if (Array.isArray(rhs))
        rhs = bentleyjs_core_1.Id64.toIdSet(rhs);
    if (lhs.size !== bentleyjs_core_1.Id64.sizeOf(rhs))
        return false;
    return bentleyjs_core_1.Id64.iterate(rhs, (id) => lhs.has(id));
}


/***/ }),

/***/ "./lib/Sheet.js":
/*!**********************!*\
  !*** ./lib/Sheet.js ***!
  \**********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const CategorySelectorState_1 = __webpack_require__(/*! ./CategorySelectorState */ "./lib/CategorySelectorState.js");
const DisplayStyleState_1 = __webpack_require__(/*! ./DisplayStyleState */ "./lib/DisplayStyleState.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./render/FeatureSymbology */ "./lib/render/FeatureSymbology.js");
const GraphicBuilder_1 = __webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js");
const System_1 = __webpack_require__(/*! ./render/System */ "./lib/render/System.js");
const TileTree_1 = __webpack_require__(/*! ./tile/TileTree */ "./lib/tile/TileTree.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/Viewport.js");
const ViewState_1 = __webpack_require__(/*! ./ViewState */ "./lib/ViewState.js");
/** Describes the geometry and styling of a sheet border decoration.
 * The sheet border decoration mimics a sheet of paper with a drop shadow.
 * @internal
 */
class SheetBorder {
    constructor(rect, shadow, gradient) {
        this._rect = rect;
        this._shadow = shadow;
        this._gradient = gradient;
    }
    /** Create a new sheet border. If a context is supplied, points are transformed to view coordinates. */
    static create(width, height, context) {
        // Rect
        const rect = [
            geometry_core_1.Point3d.create(0, height),
            geometry_core_1.Point3d.create(0, 0),
            geometry_core_1.Point3d.create(width, 0),
            geometry_core_1.Point3d.create(width, height),
            geometry_core_1.Point3d.create(0, height)
        ];
        if (context) {
            context.viewport.worldToViewArray(rect);
        }
        // Shadow
        const shadowWidth = .01 * Math.sqrt(width * width + height * height);
        const shadow = [
            geometry_core_1.Point3d.create(shadowWidth, 0),
            geometry_core_1.Point3d.create(shadowWidth, -shadowWidth),
            geometry_core_1.Point3d.create(width + shadowWidth, -shadowWidth),
            geometry_core_1.Point3d.create(width + shadowWidth, height - shadowWidth),
            geometry_core_1.Point3d.create(width, height - shadowWidth),
            geometry_core_1.Point3d.create(width, 0),
            geometry_core_1.Point3d.create(shadowWidth, 0),
        ];
        if (context) {
            context.viewport.worldToViewArray(shadow);
        }
        // Gradient
        const gradient = new imodeljs_common_1.Gradient.Symb();
        gradient.mode = imodeljs_common_1.Gradient.Mode.Linear;
        gradient.angle = geometry_core_1.Angle.createDegrees(-45);
        gradient.keys = [{ value: 0, color: imodeljs_common_1.ColorDef.from(25, 25, 25) }, { value: 0.5, color: imodeljs_common_1.ColorDef.from(150, 150, 150) }];
        // Copy over points
        // ### TODO: Allow for conversion of 2d points array to view coordinates from world coordinates to avoid these copies?..
        const rect2d = [];
        for (const point of rect)
            rect2d.push(geometry_core_1.Point2d.createFrom(point));
        const shadow2d = [];
        for (const point of shadow)
            shadow2d.push(geometry_core_1.Point2d.createFrom(point));
        return new SheetBorder(rect2d, shadow2d, gradient);
    }
    getRange() {
        const range = geometry_core_1.Range2d.createArray(this._rect);
        const shadowRange = geometry_core_1.Range2d.createArray(this._shadow);
        range.extendRange(shadowRange);
        return range;
    }
    /** Add this border to the given GraphicBuilder. */
    addToBuilder(builder) {
        const lineColor = imodeljs_common_1.ColorDef.black;
        const fillColor = imodeljs_common_1.ColorDef.black;
        const params = new imodeljs_common_1.GraphicParams();
        params.setFillColor(fillColor);
        params.gradient = this._gradient;
        builder.activateGraphicParams(params);
        builder.addShape2d(this._shadow, System_1.RenderTarget.frustumDepth2d);
        builder.setSymbology(lineColor, fillColor, 2);
        builder.addLineString2d(this._rect, 0);
    }
}
exports.SheetBorder = SheetBorder;
/** @internal */
var Attachments;
(function (Attachments) {
    /** @internal */
    class AttachmentViewport extends Viewport_1.OffScreenViewport {
        constructor() {
            super(...arguments);
            this.rendering = false;
            this.toParent = geometry_core_1.Transform.createIdentity(); // attachment NPC to sheet world
            this._sceneDepth = 0xffffffff;
        }
        get texture() { return this._texture; }
        createScene(currentState) {
            if (currentState === 1 /* Empty */ || currentState === 3 /* Ready */) {
                bentleyjs_core_1.assert(false); // these are end states
                return currentState;
            }
            if (this._changeFlags.areFeatureOverridesDirty) {
                const ovrs = new FeatureSymbology_1.FeatureSymbology.Overrides(this.view);
                this.target.overrideFeatureSymbology(ovrs);
                this._changeFlags.clear();
            }
            if (!this.sync.isValidController)
                this.setupFromView();
            this._scene = [];
            const sceneContext = this.createSceneContext();
            this.view.createScene(sceneContext);
            sceneContext.requestMissingTiles();
            // The scene is ready when (1) all required TileTree roots have been created and (2) all required tiles have finished loading
            if (!this.view.areAllTileTreesLoaded || sceneContext.hasMissingTiles)
                return 2 /* Loading */;
            return 3 /* Ready */;
        }
        renderImage() {
            if (!this.sync.isValidRenderPlan) {
                this.target.changeRenderPlan(System_1.RenderPlan.createFromViewport(this));
                this.sync.setValidRenderPlan();
            }
            this.target.changeScene(this._scene /* TODO: Pass view state's active volume... */);
            this.renderFrame();
            this._texture = undefined;
            return this.readImage();
        }
        renderTexture() {
            const image = this.renderImage();
            if (image === undefined)
                return; // image most likely consisted entirely of background pixels... don't bother creating graphic
            const params = new imodeljs_common_1.RenderTexture.Params(undefined, 2 /* TileSection */);
            this._texture = this.target.renderSystem.createTextureFromImageBuffer(image, this.view.iModel, params);
            bentleyjs_core_1.assert(this._texture !== undefined);
        }
        setSceneDepth(depth, tree) {
            if (this._sceneDepth !== depth) {
                // Ensure that if we return to this depth and need to produce more tile graphics, we first recreate the scene at that depth...
                if (0xffffffff !== this._sceneDepth && tree.getState(this._sceneDepth) === 3 /* Ready */)
                    tree.setState(this._sceneDepth, 0 /* NotLoaded */);
                // Discard any tiles/graphics used for previous level-of-detail - we'll generate them at the new LOD
                this.sync.invalidateScene();
                // ###TODO this.view.cancelAllTileLoads();
                this._sceneDepth = depth;
                let dim = QUERY_SHEET_TILE_PIXELS;
                dim = dim * Math.pow(2, depth); // doubling the rect dimensions for every level of depth
                this.setRect(new Viewport_1.ViewRect(0, 0, dim, dim), true);
            }
        }
        // override
        get isAspectRatioLocked() { return true; }
    }
    Attachments.AttachmentViewport = AttachmentViewport;
    const QUERY_SHEET_TILE_PIXELS = 512;
    /** @internal */
    class AttachmentTileLoader extends TileTree_1.TileLoader {
        tileRequiresLoading(_params) { return true; }
        get priority() { return 0 /* Primary */; }
        async getChildrenProps(_parent) { bentleyjs_core_1.assert(false); return Promise.resolve([]); }
        async requestTileContent(_tile) {
            // ###TODO?
            return Promise.resolve(undefined);
        }
    }
    /** @internal */
    class TileLoader2d extends AttachmentTileLoader {
        constructor(view) {
            super();
            // ###TODO: Why do 2d views have camera lights enabled?
            this._viewFlagOverrides = new imodeljs_common_1.ViewFlag.Overrides(view.viewFlags);
            this._viewFlagOverrides.setShowCameraLights(false);
        }
        get maxDepth() { return 1; }
        get viewFlagOverrides() { return this._viewFlagOverrides; }
        get is3dAttachment() { return false; }
    }
    /** @internal */
    class TileLoader3d extends AttachmentTileLoader {
        get maxDepth() { return 32; }
        get viewFlagOverrides() { return TileLoader3d._viewFlagOverrides; }
        get is3dAttachment() { return true; }
    }
    /** DEBUG ONLY - Setting this to true will result in only sheet tile polys being drawn, and not the textures they contain. */
    TileLoader3d._DEBUG_NO_TEXTURES = false;
    // ----------------------------------------------------------------------------------
    TileLoader3d._viewFlagOverrides = new imodeljs_common_1.ViewFlag.Overrides(imodeljs_common_1.ViewFlags.fromJSON({
        renderMode: imodeljs_common_1.RenderMode.SmoothShade,
        noCameraLights: true,
        noSourceLights: true,
        noSolarLight: true,
        noTexture: TileLoader3d._DEBUG_NO_TEXTURES,
    }));
    /** @internal */
    class Tile2d extends TileTree_1.Tile {
        constructor(root, range) {
            const params = {
                root,
                contentId: "",
                range: new geometry_core_1.Range3d(0, 0, -System_1.RenderTarget.frustumDepth2d, range.high.x, range.high.y, System_1.RenderTarget.frustumDepth2d),
                maximumSize: 512,
                isLeaf: true,
            };
            super(params);
            this.setIsReady();
        }
        get hasChildren() { return false; }
        get hasGraphics() { return true; }
        drawGraphics(args) {
            const myRoot = this.root;
            const viewRoot = myRoot.viewRoot;
            const drawArgs = viewRoot.createDrawArgs(args.context);
            drawArgs.location.setFrom(myRoot.drawingToAttachment);
            drawArgs.clipVolume = myRoot.graphicsClip;
            drawArgs.graphics.setViewFlagOverrides(this.root.viewFlagOverrides);
            drawArgs.graphics.symbologyOverrides = myRoot.symbologyOverrides;
            viewRoot.draw(drawArgs);
        }
    }
    Attachments.Tile2d = Tile2d;
    /** @internal */
    class Tile3d extends TileTree_1.Tile {
        constructor(root, parent, tileRange) {
            super({
                root,
                contentId: "",
                range: tileRange,
                maximumSize: .5 * Math.sqrt(2 * QUERY_SHEET_TILE_PIXELS * QUERY_SHEET_TILE_PIXELS),
                isLeaf: true,
                parent,
            });
            // ------------------------------------------------------------------------------------------
            this._tilePolyfaces = [];
        }
        static create(root, parent, placement) {
            let fullRange;
            if (parent !== undefined)
                fullRange = parent.range.clone();
            else
                fullRange = root.getRootRange();
            const mid = fullRange.low.interpolate(0.5, fullRange.high);
            const range = new geometry_core_1.Range3d();
            switch (placement) {
                case 0 /* UpperLeft */:
                    range.extend(mid);
                    range.extend(geometry_core_1.Point3d.create(fullRange.low.x, fullRange.high.y, 0));
                    break;
                case 1 /* UpperRight */:
                    range.extend(mid);
                    range.extend(fullRange.high);
                    break;
                case 2 /* LowerLeft */:
                    range.extend(fullRange.low);
                    range.extend(mid);
                    break;
                case 3 /* LowerRight */:
                    range.extend(geometry_core_1.Point3d.create(fullRange.high.x, fullRange.low.y, 0));
                    range.extend(mid);
                    break;
                case 4 /* Root */:
                default:
                    range.extendRange(fullRange);
                    break;
            }
            range.low.z = 0;
            range.high.z = 1;
            return new Tile3d(root, parent, range);
        }
        /** Get the root tile tree cast to a Tree3d. */
        get _rootAsTree3d() { return this.root; }
        /** Get the load state from the owner attachment's array at this tile's depth. */
        getState() { return this._rootAsTree3d.getState(this.depth - 1); }
        /** Set the load state of the owner attachment's array at this tile's depth. */
        setState(state) { this._rootAsTree3d.setState(this.depth - 1, state); }
        // override
        get hasGraphics() { return this.isReady; }
        // override
        get hasChildren() { return true; } // << means that "there are children and creation may be necessary"... NOT "definitely have children in children list"
        // override
        selectTiles(selected, args, _numSkipped = 0) { return this.select(selected, args); }
        select(selected, args, _numSkipped = 0) {
            if (this.depth === 1)
                this._rootAsTree3d.viewport.rendering = false;
            if (this.isNotFound)
                return 0 /* No */; // indicates no elements in this tile's range (or some unexpected error occurred during scene creation)
            const vis = this.computeVisibility(args);
            if (vis === 0 /* OutsideFrustum */) {
                this.unloadChildren(args.purgeOlderThan);
                return 0 /* No */;
            }
            const tooCoarse = 1 /* TooCoarse */ === vis;
            const children = tooCoarse ? this.prepareChildren() : undefined;
            if (children !== undefined) {
                const initialSize = selected.length;
                this._childrenLastUsed = args.now;
                for (const child of children) {
                    if (child.selectTiles(selected, args) === 1 /* Yes */) {
                        // At lease one of the selected children is not ready to draw. If the parent (this) is drawable, draw in place of all the children.
                        selected.length = initialSize;
                        if (this.isReady) {
                            selected.push(this);
                            return 0 /* No */;
                        }
                        else {
                            // This tile isn't ready to draw either. Try drawing its own parent in its place.
                            return 1 /* Yes */;
                        }
                    }
                }
                return 0 /* No */;
            }
            // This tile is of appropriate resolution to draw. Enqueue it for loading if necessary.
            if (!this.isReady) {
                if (this._tilePolyfaces.length === 0) {
                    this.createPolyfaces(args.context); // graphicsClip on tree must be set before creating polys (the polys that represent the tile)
                    if (this._tilePolyfaces.length === 0) {
                        this.setNotFound();
                        return 0 /* No */;
                    }
                }
                this.createGraphics(args.context);
            }
            if (this.isReady) {
                selected.push(this);
                this.unloadChildren(args.purgeOlderThan);
                return 0 /* No */;
            }
            // Inform the sheet view state that it needs to recreate the scene next frame
            this._rootAsTree3d.sheetView.markAttachment3dSceneIncomplete();
            // Tell parent to render in this tile's place until it becomes ready to draw
            return 1 /* Yes */;
        }
        createPolyfaces(context) {
            const system = context.target.renderSystem;
            // ### TODO: an optimization could be to make the texture non-square to save on space (make match cropped tile aspect ratio)
            // set up initial corner values (before cropping to clip)
            const tree = this._rootAsTree3d;
            // Set up initial corner values (before cropping to clip). Range must already be set up (range = unclipped range)
            const east = this.range.low.x;
            const west = this.range.high.x;
            const north = this.range.low.y;
            const south = this.range.high.y;
            const corners = [
                geometry_core_1.Point3d.create(east, north, tree.biasDistance),
                geometry_core_1.Point3d.create(west, north, tree.biasDistance),
                geometry_core_1.Point3d.create(west, south, tree.biasDistance),
                geometry_core_1.Point3d.create(east, south, tree.biasDistance),
            ];
            // first create the polys for the tile so we can get the range (create graphics from polys later)
            const clip = undefined !== tree.graphicsClip ? tree.graphicsClip.clipVector : undefined;
            this._tilePolyfaces = system.createSheetTilePolyfaces(corners, clip);
        }
        createGraphics(context) {
            const tree = this._rootAsTree3d;
            let currentState = this.getState();
            // "Ready" state is a valid situation. It means another tile created the scene for this level of detail. We will use that scene.
            // However, this means we would be using the texture for that other tile, which is not what we want. We must recreate the texture.
            bentleyjs_core_1.assert(currentState !== 1 /* Empty */);
            if (currentState === 1 /* Empty */) {
                this.setNotFound();
                return;
            }
            const system = context.target.renderSystem;
            const viewport = tree.viewport;
            if (currentState !== 3 /* Ready */) {
                viewport.setSceneDepth(this.depth - 1, tree);
                viewport.setupFromView();
                // Create the scene and if the scene is complete, mark the state as ready
                currentState = viewport.createScene(currentState);
                this.setState(currentState);
            }
            switch (currentState) {
                case 0 /* NotLoaded */:
                case 2 /* Loading */:
                    return;
                case 1 /* Empty */:
                    this.setNotFound();
                    return;
                case 3 /* Ready */: {
                    // Only render one tile per frame - otherwise we swamp the renderer and introduce lag
                    if (!viewport.rendering) {
                        viewport.rendering = true;
                        // render the texture then create graphics from the polys and the rendered texture
                        const frustumToRestore = viewport.getFrustum();
                        // Scene rect does not match this. That rect increases with depth. This rect is constant, because it is the rect of the final texture
                        const dim = QUERY_SHEET_TILE_PIXELS;
                        viewport.setRect(new Viewport_1.ViewRect(0, 0, dim, dim));
                        // Change the frustum so it looks at only the visible (after clipping) portion of the scene.
                        // Also only look at the relevant corner of the scene
                        const frust = viewport.getFrustum(Viewport_1.CoordSystem.Npc);
                        frust.initFromRange(this.range); // use unclipped range of tile to change the frustum (this is what we're looking at)
                        const rootToNpc = viewport.viewFrustum.worldToNpcMap;
                        rootToNpc.transform1.multiplyPoint3dArrayQuietNormalize(frust.points);
                        viewport.setupViewFromFrustum(frust);
                        viewport.renderTexture();
                        if (viewport.texture === undefined) {
                            this.setNotFound();
                        }
                        else {
                            let graphic = system.createGraphicList(system.createSheetTile(viewport.texture, this._tilePolyfaces, this._rootAsTree3d.tileColor));
                            graphic = system.createBatch(graphic, this._rootAsTree3d.featureTable, this.contentRange);
                            this.setContent({ graphic, contentRange: this.contentRange });
                        }
                        // restore frustum
                        viewport.setupViewFromFrustum(frustumToRestore);
                    }
                    break;
                }
            }
        }
        prepareChildren() {
            if (this._children === undefined)
                this._children = [];
            if (this._children.length === 0) {
                const childTileUL = Tile3d.create(this._rootAsTree3d, this, 0 /* UpperLeft */);
                const childTileUR = Tile3d.create(this._rootAsTree3d, this, 1 /* UpperRight */);
                const childTileLL = Tile3d.create(this._rootAsTree3d, this, 2 /* LowerLeft */);
                const childTileLR = Tile3d.create(this._rootAsTree3d, this, 3 /* LowerRight */);
                this._children.push(childTileUL);
                this._children.push(childTileUR);
                this._children.push(childTileLL);
                this._children.push(childTileLR);
            }
            return this._children.length === 0 ? undefined : this._children;
        }
        drawGraphics(args) {
            super.drawGraphics(args);
            if (!Tile3d._DRAW_DEBUG_POLYFACE_GRAPHICS) {
                return;
            }
            const polys = this._tilePolyfaces;
            if (polys.length === 0)
                return;
            const lineColor = imodeljs_common_1.ColorDef.blue.clone();
            const fillColor = imodeljs_common_1.ColorDef.green.clone();
            fillColor.setAlpha(0x88);
            lineColor.setAlpha(0xff);
            const builder = args.context.createSceneGraphicBuilder();
            builder.setSymbology(lineColor, fillColor, 2);
            for (const poly of polys) {
                const polyVisitor = geometry_core_1.IndexedPolyfaceVisitor.create(poly, 0);
                while (polyVisitor.moveToNextFacet()) {
                    const lineString = [];
                    for (let i = 0; i < 3; i++)
                        lineString.push(polyVisitor.getPoint(i));
                    if (lineString.length > 0)
                        lineString.push(lineString[0].clone()); // close the loop
                    builder.addLineString(lineString);
                }
            }
            args.graphics.add(builder.finish());
        }
    }
    /** DEBUG ONLY - This member will cause the sheet tile polyfaces to draw along with the underlying textures. */
    Tile3d._DRAW_DEBUG_POLYFACE_GRAPHICS = false;
    Attachments.Tile3d = Tile3d;
    /** @internal */
    class Tree extends TileTree_1.TileTree {
        constructor(loader, iModel, modelId) {
            // The root tile set here does not matter, as it will be overwritten by the Tree2d and Tree3d constructors
            const isLeaf = loader.is3dAttachment;
            const is3d = false; // NB: The attachment is 3d. The attachment tiles are 2d.
            const props = {
                id: modelId,
                rootTile: {
                    contentId: "",
                    range: {
                        low: { x: 0, y: 0, z: 0 },
                        high: { x: 0, y: 0, z: 0 },
                    },
                    maximumSize: 512,
                    isLeaf,
                },
                location: geometry_core_1.Transform.identity.toJSON(),
            };
            const params = TileTree_1.TileTree.paramsFromJSON(props, iModel, is3d, loader, modelId);
            super(params);
        }
        dispose() {
            super.dispose();
            this.graphicsClip = bentleyjs_core_1.dispose(this.graphicsClip);
        }
    }
    Attachments.Tree = Tree;
    /** @internal */
    class Tree2d extends Tree {
        constructor(iModel, attachment, view, viewRoot) {
            super(new TileLoader2d(view), iModel, attachment.id);
            this.view = view;
            this.viewRoot = viewRoot;
            this.symbologyOverrides = new FeatureSymbology_1.FeatureSymbology.Overrides(view);
            const attachRange = attachment.placement.calculateRange();
            const attachWidth = attachRange.high.x - attachRange.low.x;
            const attachHeight = attachRange.high.y - attachRange.low.y;
            const viewExtents = view.getExtents();
            const scale = geometry_core_1.Point2d.create(attachWidth / viewExtents.x, attachHeight / viewExtents.y);
            const worldToAttachment = geometry_core_1.Point3d.createFrom(attachment.placement.origin);
            worldToAttachment.z = System_1.RenderTarget.depthFromDisplayPriority(attachment.displayPriority);
            const location = geometry_core_1.Transform.createOriginAndMatrix(worldToAttachment, geometry_core_1.Matrix3d.createIdentity());
            this.location.setFrom(location);
            const aspectRatioSkew = view.getAspectRatioSkew();
            this.drawingToAttachment = geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.create(), view.getRotation());
            this.drawingToAttachment.matrix.scaleColumns(scale.x, aspectRatioSkew * scale.y, 1, this.drawingToAttachment.matrix);
            const translation = viewRoot.location.origin.cloneAsPoint3d();
            const viewOrg = view.getOrigin().minus(translation);
            this.drawingToAttachment.multiplyPoint3d(viewOrg, viewOrg);
            translation.plus(viewOrg, viewOrg);
            viewOrg.z = 0;
            const viewOrgToAttachment = worldToAttachment.minus(viewOrg);
            translation.plus(viewOrgToAttachment, translation);
            this.drawingToAttachment.origin.setFrom(translation);
            this.expirationTime = bentleyjs_core_1.BeDuration.fromSeconds(15);
            // The renderer needs the unclipped range of the attachment to produce polys to be rendered as clip mask...
            // (Containment tests can also be more efficiently performed if boundary range is specified)
            const clipTf = location.inverse();
            if (clipTf !== undefined) {
                const clip = attachment.getOrCreateClip(clipTf);
                this.clipVolume = IModelApp_1.IModelApp.renderSystem.createClipVolume(clip);
                if (undefined !== this.clipVolume)
                    clipTf.multiplyRange(attachRange, this.clipVolume.clipVector.boundingRange);
            }
            const sheetToDrawing = this.drawingToAttachment.inverse();
            if (sheetToDrawing !== undefined) {
                const graphicsClip = attachment.getOrCreateClip(sheetToDrawing);
                sheetToDrawing.multiplyRange(attachRange, graphicsClip.boundingRange);
                this.graphicsClip = IModelApp_1.IModelApp.renderSystem.createClipVolume(graphicsClip);
            }
            this._rootTile = new Tile2d(this, attachment.placement.bbox);
        }
        /** Create a Tree2d tile tree for a 2d attachment. Returns a Tree2d if the model tile tree is ready. Otherwise, returns the status of the tiles. */
        static create(attachment) {
            const view = attachment.view;
            const viewedModel = view.getViewedModel();
            if (!viewedModel)
                return 1 /* Empty */;
            switch (viewedModel.loadTree(true)) {
                case TileTree_1.TileTree.LoadStatus.Loaded:
                    bentleyjs_core_1.assert(undefined !== viewedModel.tileTree);
                    attachment.tree = new Tree2d(viewedModel.iModel, attachment, view, viewedModel.tileTree);
                    return 3 /* Ready */;
                case TileTree_1.TileTree.LoadStatus.Loading:
                    return 2 /* Loading */;
                default:
                    return 1 /* Empty */;
            }
        }
    }
    Attachments.Tree2d = Tree2d;
    /** @internal */
    class TileColorSequence {
        constructor() {
            this._index = 0;
            this._colors = [
                0xff0000,
                0x00ff00,
                0x0000ff,
                0x7fff00,
                0x7f00ff,
                0x007fff,
                0xff7f00,
                0xff007f,
                0x00ff7f,
            ];
        }
        get next() {
            if (this._index >= this._colors.length)
                this._index = 0;
            const color = new imodeljs_common_1.ColorDef(this._colors[this._index]);
            color.setAlpha(0x7f);
            this._index++;
            return color;
        }
    }
    const tileColorSequence = new TileColorSequence();
    /** @internal */
    class Tree3d extends Tree {
        constructor(sheetView, attachment, sceneContext, viewport, view) {
            super(new TileLoader3d(), view.iModel, bentleyjs_core_1.Id64.invalid);
            this.tileColor = tileColorSequence.next;
            const featureTable = new imodeljs_common_1.FeatureTable(1);
            featureTable.insert(new imodeljs_common_1.Feature(attachment.id));
            this.featureTable = System_1.PackedFeatureTable.pack(featureTable);
            this.viewport = viewport;
            this.sheetView = sheetView;
            this.attachment = attachment;
            let scale;
            // We use square tiles.. if the view's aspect ratio isn't square, expand the short side in tile NPC space. We'll clip out the extra area below.
            const aspect = view.getAspectRatio();
            if (aspect < 1)
                scale = geometry_core_1.Point2d.create(1 / aspect, 1);
            else
                scale = geometry_core_1.Point2d.create(1, aspect);
            // now expand the frustum in one direction so that the view is square (so we can use square tiles)
            const dim = QUERY_SHEET_TILE_PIXELS;
            this.viewport.setRect(new Viewport_1.ViewRect(0, 0, dim, dim));
            this.viewport.setupFromView();
            const frust = this.viewport.getFrustum(Viewport_1.CoordSystem.Npc).transformBy(geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.create(), geometry_core_1.Matrix3d.createScale(scale.x, scale.y, 1)));
            this.viewport.npcToWorldArray(frust.points);
            this.viewport.setupViewFromFrustum(frust);
            const style = view.displayStyle;
            // Override the background color. This is to match v8, but there should probably be an option in the "Details" about whether to do this or not.
            const bgColor = sheetView.displayStyle.backgroundColor.clone();
            // Set fully-transparent so that we discard background pixels (probably no point to the above line any more...)
            bgColor.setAlpha(0);
            style.backgroundColor.setFrom(bgColor);
            // turn off skybox and groundplane
            if (view.isSpatialView()) {
                const spatial = view;
                const env = spatial.getDisplayStyle3d().environment;
                env.ground.display = false;
                env.sky.display = false;
            }
            const range = attachment.placement.calculateRange();
            this.biasDistance = System_1.RenderTarget.depthFromDisplayPriority(attachment.displayPriority);
            range.getNpcToWorldRangeTransform(this.viewport.toParent);
            this.viewport.toParent.matrix.scaleColumns(scale.x, scale.y, 1, this.viewport.toParent.matrix);
            const fromParent = this.viewport.toParent.inverse();
            if (fromParent !== undefined) {
                const graphicsClip = attachment.getOrCreateClip(fromParent);
                this.graphicsClip = IModelApp_1.IModelApp.renderSystem.createClipVolume(graphicsClip);
            }
            this._rootTile = Tile3d.create(this, undefined, 4 /* Root */);
            this._rootTile.createPolyfaces(sceneContext); // graphics clip must be set before creating polys (the polys that represent the tile)
            this.location.setFrom(this.viewport.toParent.clone());
            this.expirationTime = bentleyjs_core_1.BeDuration.fromSeconds(15);
        }
        static create(sheetView, attachment, sceneContext) {
            const view = attachment.view;
            const viewport = AttachmentViewport.create(view);
            return new Tree3d(sheetView, attachment, sceneContext, viewport, view);
        }
        /** Get the load state from the owner attachment's array at this tile's depth. */
        getState(depth) { return this.attachment.getState(depth); }
        /** Set the load state of the owner attachment's array at this tile's depth. */
        setState(depth, state) { this.attachment.setState(depth, state); }
        /** Get the range for the root tile of this tile tree. */
        getRootRange(result) {
            const tileSize = 1;
            const east = 0;
            const west = east + tileSize;
            const north = 0;
            const south = north + tileSize;
            const corners = [
                geometry_core_1.Point3d.create(east, north, this.biasDistance),
                geometry_core_1.Point3d.create(west, north, this.biasDistance),
                geometry_core_1.Point3d.create(east, south, this.biasDistance),
                geometry_core_1.Point3d.create(west, south, this.biasDistance),
            ];
            return geometry_core_1.Range3d.createArray(corners, result);
        }
    }
    Attachments.Tree3d = Tree3d;
    /** @internal */
    class Attachment {
        constructor(props, view) {
            this.id = bentleyjs_core_1.Id64.fromJSON(props.id);
            this.view = view;
            this.displayPriority = 0;
            let scale;
            let placement;
            const jsonProps = props.jsonProperties;
            if (props.placement)
                placement = imodeljs_common_1.Placement2d.fromJSON(props.placement);
            if (jsonProps !== undefined) {
                scale = jsonProps.scale !== undefined ? bentleyjs_core_1.JsonUtils.asDouble(jsonProps.scale) : undefined;
                this.clip = jsonProps.clip !== undefined ? geometry_core_1.ClipVector.fromJSON(jsonProps.clip) : geometry_core_1.ClipVector.createEmpty();
                this.displayPriority = bentleyjs_core_1.JsonUtils.asInt(props.jsonProperties.displayPriority);
            }
            else {
                this.clip = geometry_core_1.ClipVector.createEmpty();
            }
            this.clip.parseClipPlanes();
            // Compute placement from scale, or scale from placement if necessary
            if (scale === undefined && placement === undefined) {
                scale = 1;
                placement = Attachment.computePlacement(view, geometry_core_1.Point2d.create(), scale);
            }
            else if (scale === undefined) {
                scale = Attachment.computeScale(view, placement);
            }
            else if (placement === undefined) {
                placement = Attachment.computePlacement(view, geometry_core_1.Point2d.create(), scale);
            }
            this.scale = scale;
            this.placement = placement;
        }
        /** Returns true if this attachment has a defined tile tree and is ready to be drawn. */
        get isReady() { return this._tree !== undefined; }
        /** Returns the tile tree corresponding to this attachment, which may be 2d or 3d. Returns undefined if the tree has not been loaded. */
        get tree() { return this._tree; }
        /** Sets the reference to the tile tree corresponding to this attachment view's model. */
        set tree(tree) { this._tree = tree; }
        /** Given a view and placement, compute a scale for an attachment. */
        static computeScale(view, placement) {
            return view.getExtents().x / placement.bbox.xLength();
        }
        /** Given a view and an origin point, compute a placement for an attachment. */
        static computePlacement(view, origin, scale) {
            const viewExtents = view.getExtents();
            const box = new geometry_core_1.Range2d();
            box.low.setZero();
            box.high.x = viewExtents.x / scale;
            box.high.y = viewExtents.y / scale;
            return new imodeljs_common_1.Placement2d(origin, geometry_core_1.Angle.createDegrees(0), box);
        }
        /** Remove the clip vector from this view attachment. */
        clearClipping() { this.clip.clear(); }
        /** Create a boundary clip vector around this attachment. */
        createBoundaryClip() {
            const range = this.placement.calculateRange();
            const box = [
                geometry_core_1.Point3d.create(range.low.x, range.low.y),
                geometry_core_1.Point3d.create(range.high.x, range.low.y),
                geometry_core_1.Point3d.create(range.high.x, range.high.y),
                geometry_core_1.Point3d.create(range.low.x, range.high.y),
                geometry_core_1.Point3d.create(range.low.x, range.low.y),
            ];
            const clip = geometry_core_1.ClipVector.createEmpty();
            clip.appendShape(box);
            return clip;
        }
        /** Returns a clone of the current clipping if it is defined and not null. Otherwise, attempt to create a new stored boundary clipping. */
        getOrCreateClip(transform) {
            if (!this.clip.isValid)
                this.clip = this.createBoundaryClip();
            const clipReturn = this.clip.clone();
            if (transform !== undefined)
                clipReturn.transformInPlace(transform);
            return clipReturn;
        }
        /** DEBUG ONLY - Draw a border around this attachment using its placement. */
        debugDrawBorder(context) {
            const origin = this.placement.origin;
            const bbox = this.placement.bbox;
            const rect = [
                geometry_core_1.Point2d.create(origin.x, origin.y),
                geometry_core_1.Point2d.create(origin.x + bbox.high.x, origin.y),
                geometry_core_1.Point2d.create(origin.x + bbox.high.x, origin.y + bbox.high.y),
                geometry_core_1.Point2d.create(origin.x, origin.y + bbox.high.y),
                geometry_core_1.Point2d.create(origin.x, origin.y)
            ];
            const builder = context.createSceneGraphicBuilder();
            builder.setSymbology(Attachment.DEBUG_BOUNDING_BOX_COLOR, Attachment.DEBUG_BOUNDING_BOX_COLOR, 2);
            builder.addLineString2d(rect, 0);
            const attachmentBorder = builder.finish();
            context.outputGraphic(attachmentBorder);
        }
    }
    /** DEBUG ONLY - The color of the attachment bounding box if drawn. */
    Attachment.DEBUG_BOUNDING_BOX_COLOR = imodeljs_common_1.ColorDef.red;
    Attachments.Attachment = Attachment;
    /** @internal */
    class Attachment2d extends Attachment {
        constructor(props, view) {
            super(props, view);
        }
        get is2d() { return true; }
        load(_sheetView, _sceneContext) {
            if (this.tree === undefined)
                return Tree2d.create(this);
            else
                return 3 /* Ready */;
        }
    }
    Attachments.Attachment2d = Attachment2d;
    /** @internal */
    class Attachment3d extends Attachment {
        constructor(props, view) {
            super(props, view);
            this._states = [];
        }
        get is2d() { return false; }
        /** Returns the load state of this attachment's tile tree at a given depth. */
        getState(depth) { return depth < this._states.length ? this._states[depth] : 0 /* NotLoaded */; }
        /** Sets the state of this attachment's tile tree at a given depth. */
        setState(depth, state) {
            while (this._states.length < depth + 1)
                this._states.push(0 /* NotLoaded */); // Fill any gaps
            this._states[depth] = state;
        }
        load(sheetView, sceneContext) {
            if (this._tree === undefined)
                this._tree = Tree3d.create(sheetView, this, sceneContext);
            return 3 /* Ready */;
        }
    }
    Attachments.Attachment3d = Attachment3d;
    /** @internal */
    class AttachmentList {
        constructor() {
            this.list = [];
            this._allReady = true;
        }
        /** The number of attachments in this list. */
        get length() { return this.list.length; }
        /** Returns true if all attachments in this list have defined tile trees. */
        get allReady() { return this._allReady; }
        /** Clear this list of attachments. */
        clear() {
            this.list.length = 0;
            this._allReady = true;
        }
        /** Add an attachment to this list of attachments. */
        add(attachment) {
            this._allReady = this._allReady && attachment.isReady;
            this.list.push(attachment);
        }
        /** Drop an attachment from this list by reference. */
        drop(attachment) {
            const idx = this.list.indexOf(attachment);
            if (idx !== -1)
                this.list.splice(idx, 1);
            this.updateAllReady();
        }
        /** Update the flag on this attachments list recording whether or not all attachments are ready to be drawn. */
        updateAllReady() {
            this._allReady = true;
            for (const attachment of this.list) {
                if (!attachment.isReady) {
                    this._allReady = false;
                    break;
                }
            }
        }
        /**
         * Load the tile tree for the attachment at the given index. Returns the resulting load status. If the load reported
         * anything other than "Ready" or "Loading", the load failed and the attachment has been removed from the list.
         */
        load(idx, sheetView, sceneContext) {
            bentleyjs_core_1.assert(idx < this.length);
            const attachment = this.list[idx];
            // Load the attachment. On failure, remove it from the array
            const loadStatus = attachment.load(sheetView, sceneContext);
            if (loadStatus !== 3 /* Ready */ && loadStatus !== 2 /* Loading */)
                this.list.splice(idx, 1);
            this.updateAllReady();
            return loadStatus;
        }
    }
    Attachments.AttachmentList = AttachmentList;
})(Attachments = exports.Attachments || (exports.Attachments = {}));
/** A view of a [SheetModel](@backend).
 * @public
 */
class SheetViewState extends ViewState_1.ViewState2d {
    constructor(props, iModel, categories, displayStyle, sheetProps, attachments) {
        super(props, iModel, categories, displayStyle);
        this._all3dAttachmentTilesLoaded = true;
        if (categories instanceof SheetViewState) {
            // we are coming from clone...
            this.sheetSize = categories.sheetSize.clone();
            this._attachmentIds = categories._attachmentIds;
            this._attachments = categories._attachments;
        }
        else {
            this.sheetSize = geometry_core_1.Point2d.create(sheetProps.width, sheetProps.height);
            this._attachmentIds = [];
            attachments.forEach((idProp) => this._attachmentIds.push(idProp));
            this._attachments = new Attachments.AttachmentList();
        }
    }
    /** @internal */
    static get className() { return "SheetViewDefinition"; }
    static createFromProps(viewStateData, iModel) {
        const cat = new CategorySelectorState_1.CategorySelectorState(viewStateData.categorySelectorProps, iModel);
        const displayStyleState = new DisplayStyleState_1.DisplayStyle2dState(viewStateData.displayStyleProps, iModel);
        // use "new this" so subclasses are correct
        return new this(viewStateData.viewDefinitionProps, iModel, cat, displayStyleState, viewStateData.sheetProps, viewStateData.sheetAttachments);
    }
    /** @internal */
    get defaultExtentLimits() { return { min: geometry_core_1.Constant.oneMillimeter, max: this.sheetSize.magnitude() * 10 }; }
    /** Manually mark this SheetViewState as having to re-create its scene due to still-loading tiles for 3d attachments. This is called directly from the attachment tiles.
     * @internal
     */
    markAttachment3dSceneIncomplete() {
        // NB: 2d attachments will draw to completion once they have a tile tree... but 3d attachments create new tiles for each
        // depth, and therefore report directly to the ViewState whether or not new tiles are being loaded
        this._all3dAttachmentTilesLoaded = false;
    }
    /** Load the size and attachment for this sheet, as well as any other 2d view state characteristics.
     * @internal
     */
    async load() {
        await super.load();
        // Set the size of the sheet
        const model = this.getViewedModel();
        if (model === undefined)
            return;
        this._attachments.clear();
        // Query all of the attachment properties using their ids
        const attachmentPropList = await this.iModel.elements.getProps(this._attachmentIds);
        // For each ViewAttachmentProps, load the view that the attachment references. Once the view is loaded, officially construct the attachment & add it to the array.
        for (const attachmentProps of attachmentPropList) {
            this.iModel.views.load(attachmentProps.view.id).then((view) => {
                if (view.is3d())
                    this._attachments.add(new Attachments.Attachment3d(attachmentProps, view));
                else
                    this._attachments.add(new Attachments.Attachment2d(attachmentProps, view));
            });
        }
    }
    /** If any attachments have not yet been loaded or are waiting on tiles, invalidate the scene.
     * @internal
     */
    onRenderFrame(_viewport) {
        if (!this._attachments.allReady || !this._all3dAttachmentTilesLoaded)
            _viewport.sync.invalidateScene();
    }
    /** Adds the Sheet view to the scene, along with any of this sheet's attachments.
     * @internal
     */
    createScene(context) {
        // This will be set to false by the end of the function if any 3d attachments are waiting on tiles...
        this._all3dAttachmentTilesLoaded = true;
        super.createScene(context);
        if (!this._attachments.allReady) {
            let i = 0;
            while (i < this._attachments.length) {
                const loadStatus = this._attachments.load(i, this, context);
                // If load fails, attachment gets dropped from the list
                if (loadStatus === 3 /* Ready */ || loadStatus === 2 /* Loading */)
                    i++;
            }
        }
        // Draw all attachments that have a status of ready
        for (const attachment of this._attachments.list)
            if (attachment.isReady)
                attachment.tree.drawScene(context);
    }
    /** Create a sheet border decoration graphic. */
    createBorder(width, height, context) {
        const border = SheetBorder.create(width, height, context);
        const builder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.ViewBackground);
        border.addToBuilder(builder);
        return builder.finish();
    }
    /** @internal */
    decorate(context) {
        super.decorate(context);
        if (this.sheetSize !== undefined) {
            const border = this.createBorder(this.sheetSize.x, this.sheetSize.y, context);
            context.setViewBackground(border);
        }
    }
    /** @internal */
    computeFitRange() {
        const size = this.sheetSize;
        if (0 >= size.x || 0 >= size.y)
            return super.computeFitRange();
        return new geometry_core_1.Range3d(0, 0, -1, size.x, size.y, 1);
    }
}
exports.SheetViewState = SheetViewState;


/***/ }),

/***/ "./lib/SolarCalculate.js":
/*!*******************************!*\
  !*** ./lib/SolarCalculate.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
// Code below loosely translated from  https://www.esrl.noaa.gov/gmd/grad/solcalc/
function calcTimeJulianCent(jd) {
    const T = (jd - 2451545.0) / 36525.0;
    return T;
}
function radToDeg(angleRad) {
    return (180.0 * angleRad / Math.PI);
}
function degToRad(angleDeg) {
    return (Math.PI * angleDeg / 180.0);
}
function calcGeomMeanLongSun(t) {
    let L0 = 280.46646 + t * (36000.76983 + t * (0.0003032));
    while (L0 > 360.0) {
        L0 -= 360.0;
    }
    while (L0 < 0.0) {
        L0 += 360.0;
    }
    return L0; // in degrees
}
function calcGeomMeanAnomalySun(t) {
    const M = 357.52911 + t * (35999.05029 - 0.0001537 * t);
    return M; // in degrees
}
function calcEccentricityEarthOrbit(t) {
    const e = 0.016708634 - t * (0.000042037 + 0.0000001267 * t);
    return e; // unitless
}
function calcSunEqOfCenter(t) {
    const m = calcGeomMeanAnomalySun(t);
    const mrad = degToRad(m);
    const sinm = Math.sin(mrad);
    const sin2m = Math.sin(mrad + mrad);
    const sin3m = Math.sin(mrad + mrad + mrad);
    const C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289;
    return C; // in degrees
}
function calcSunTrueLong(t) {
    const l0 = calcGeomMeanLongSun(t);
    const c = calcSunEqOfCenter(t);
    const O = l0 + c;
    return O; // in degrees
}
function calcSunApparentLong(t) {
    const o = calcSunTrueLong(t);
    const omega = 125.04 - 1934.136 * t;
    const lambda = o - 0.00569 - 0.00478 * Math.sin(degToRad(omega));
    return lambda; // in degrees
}
function calcMeanObliquityOfEcliptic(t) {
    const seconds = 21.448 - t * (46.8150 + t * (0.00059 - t * (0.001813)));
    const e0 = 23.0 + (26.0 + (seconds / 60.0)) / 60.0;
    return e0; // in degrees
}
function calcObliquityCorrection(t) {
    const e0 = calcMeanObliquityOfEcliptic(t);
    const omega = 125.04 - 1934.136 * t;
    const e = e0 + 0.00256 * Math.cos(degToRad(omega));
    return e; // in degrees
}
function calcSunDeclination(t) {
    const e = calcObliquityCorrection(t);
    const lambda = calcSunApparentLong(t);
    const sint = Math.sin(degToRad(e)) * Math.sin(degToRad(lambda));
    const theta = radToDeg(Math.asin(sint));
    return theta; // in degrees
}
function calcEquationOfTime(t) {
    const epsilon = calcObliquityCorrection(t);
    const l0 = calcGeomMeanLongSun(t);
    const e = calcEccentricityEarthOrbit(t);
    const m = calcGeomMeanAnomalySun(t);
    let y = Math.tan(degToRad(epsilon) / 2.0);
    y *= y;
    const sin2l0 = Math.sin(2.0 * degToRad(l0));
    const sinm = Math.sin(degToRad(m));
    const cos2l0 = Math.cos(2.0 * degToRad(l0));
    const sin4l0 = Math.sin(4.0 * degToRad(l0));
    const sin2m = Math.sin(2.0 * degToRad(m));
    const eTime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m;
    return radToDeg(eTime) * 4.0; // in minutes of time
}
function calcAzEl(T, localTime, latitude, longitude, zone) {
    const eqTime = calcEquationOfTime(T);
    const theta = calcSunDeclination(T);
    const solarTimeFix = eqTime + 4.0 * longitude - 60.0 * zone;
    let trueSolarTime = localTime + solarTimeFix;
    while (trueSolarTime > 1440)
        trueSolarTime -= 1440;
    let hourAngle = trueSolarTime / 4.0 - 180.0;
    if (hourAngle < -180) {
        hourAngle += 360.0;
    }
    const haRad = degToRad(hourAngle);
    let csz = Math.sin(degToRad(latitude)) * Math.sin(degToRad(theta)) + Math.cos(degToRad(latitude)) * Math.cos(degToRad(theta)) * Math.cos(haRad);
    if (csz > 1.0) {
        csz = 1.0;
    }
    else if (csz < -1.0) {
        csz = -1.0;
    }
    const zenith = radToDeg(Math.acos(csz));
    const azDenom = (Math.cos(degToRad(latitude)) * Math.sin(degToRad(zenith)));
    let azimuth;
    if (Math.abs(azDenom) > 0.001) {
        let azRad = ((Math.sin(degToRad(latitude)) * Math.cos(degToRad(zenith))) - Math.sin(degToRad(theta))) / azDenom;
        if (Math.abs(azRad) > 1.0) {
            if (azRad < 0) {
                azRad = -1.0;
            }
            else {
                azRad = 1.0;
            }
        }
        azimuth = 180.0 - radToDeg(Math.acos(azRad));
        if (hourAngle > 0.0) {
            azimuth = -azimuth;
        }
    }
    else {
        if (latitude > 0.0) {
            azimuth = 180.0;
        }
        else {
            azimuth = 0.0;
        }
    }
    if (azimuth < 0.0) {
        azimuth += 360.0;
    }
    return { azimuth, elevation: 90 - zenith };
}
function calculateJulianDay(date) {
    return Math.floor(date.getTime() / 86400000) + 2440587.5; // https://stackoverflow.com/questions/11759992/calculating-jdayjulian-day-in-javascript
}
/** @beta
 * calculate solar angles (in radians) based at a given date/time and location.
 */
function calculateSolarAngles(date, location) {
    const jDay = calculateJulianDay(date);
    const latitude = geometry_core_1.Angle.radiansToDegrees(location.latitude);
    const longitude = geometry_core_1.Angle.radiansToDegrees(location.longitude);
    const utcMinutes = date.getUTCHours() * 60 + date.getUTCMinutes() + date.getUTCSeconds() / 60;
    const zone = Math.floor(.5 + longitude / 15.0); // date.getTimeZoneOffset mixes in DST.
    const localMinutes = utcMinutes + zone * 60;
    const jTotal = jDay + utcMinutes / 1440.0;
    const T = calcTimeJulianCent(jTotal);
    return calcAzEl(T, localMinutes, latitude, longitude, zone);
}
exports.calculateSolarAngles = calculateSolarAngles;
/** @beta
 * calculate solar direction based at a given date/time and location.
 */
function calculateSolarDirection(date, location) {
    const azimuthElevation = calculateSolarAngles(date, location);
    const azimuth = geometry_core_1.Angle.degreesToRadians(azimuthElevation.azimuth);
    const elevation = geometry_core_1.Angle.degreesToRadians(azimuthElevation.elevation);
    const cosElevation = Math.cos(elevation);
    const sinElevation = Math.sin(elevation);
    return geometry_core_1.Vector3d.create(-Math.sin(azimuth) * cosElevation, -Math.cos(azimuth) * cosElevation, -sinElevation);
}
exports.calculateSolarDirection = calculateSolarDirection;
function dateFromUtcMinutes(date, utcMinutes) {
    const utcHours = Math.floor(utcMinutes / 60.0);
    const output = new Date(date);
    output.setUTCHours(utcHours);
    output.setUTCMinutes(Math.floor(.5 + utcMinutes - 60.0 * utcHours));
    output.setUTCSeconds(0);
    return output;
}
function calcSunriseUtcMinutes(rise, lat, longitude, jDay) {
    const t = calcTimeJulianCent(jDay);
    const eqTime = calcEquationOfTime(t);
    const solarDec = calcSunDeclination(t);
    const latRad = degToRad(lat);
    const sdRad = degToRad(solarDec);
    const hAarg = (Math.cos(degToRad(90.833)) / (Math.cos(latRad) * Math.cos(sdRad)) - Math.tan(latRad) * Math.tan(sdRad));
    const hourAngle = Math.acos(hAarg);
    const delta = longitude + radToDeg(rise ? hourAngle : -hourAngle);
    return 720 - (4.0 * delta) - eqTime; // in UTC minutes
}
/** @beta
 * calculate solar sunrise or sunset for a given day and location.
 */
function calculateSunriseOrSunset(date, location, sunrise) {
    const jDay = calculateJulianDay(date);
    const longitude = geometry_core_1.Angle.radiansToDegrees(location.longitude);
    const latitude = geometry_core_1.Angle.radiansToDegrees(location.latitude);
    const utcMinutes = calcSunriseUtcMinutes(sunrise, latitude, longitude, jDay);
    return sunrise ? dateFromUtcMinutes(date, utcMinutes) : dateFromUtcMinutes(date, calcSunriseUtcMinutes(sunrise, latitude, longitude, jDay + utcMinutes / 1440));
}
exports.calculateSunriseOrSunset = calculateSunriseOrSunset;


/***/ }),

/***/ "./lib/SpatialClassification.js":
/*!**************************************!*\
  !*** ./lib/SpatialClassification.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module SpatialClassification */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const System_1 = __webpack_require__(/*! ./render/System */ "./lib/render/System.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
/** Geometry may be classified by its spatial location.  This is typically used to classify reality models.
 * A volume classifier classifies on all space within a closed mesh.  A planar classifier classifies within a
 * planar region swept perpendicular to its plane.
 * @beta
 */
var SpatialClassification;
(function (SpatialClassification) {
    /** @internal */
    async function usePlanar(model) {
        const range = await model.queryModelRange();
        const depthMax = 1.0E-2;
        return range.high.z - range.low.z < depthMax;
    }
    /** @internal */
    async function createClassifier(id, iModel) {
        const classifierModel = iModel.models.getLoaded(id);
        if (undefined === classifierModel) {
            bentleyjs_core_1.assert(false, "classifier not loaded");
            return undefined;
        }
        return new System_1.RenderClassifierModel(await usePlanar(classifierModel) ? 1 /* Planar */ : 0 /* Volume */);
    }
    SpatialClassification.createClassifier = createClassifier;
    /** @internal */
    function getClassifierProps(model) {
        if (model.jsonProperties.classifiers !== undefined) {
            for (const classifier of model.jsonProperties.classifiers) {
                if (classifier.isActive)
                    return new imodeljs_common_1.SpatialClassificationProps.Properties(classifier);
            }
        }
        return undefined;
    }
    SpatialClassification.getClassifierProps = getClassifierProps;
    /** @internal */
    async function loadModelClassifiers(modelIdArg, iModel) {
        const classifiersToLoad = new Set();
        bentleyjs_core_1.Id64.forEach(modelIdArg, (modelId) => {
            const model = iModel.models.getLoaded(modelId);
            if (undefined !== model) {
                const props = getClassifierProps(model);
                if (undefined !== props)
                    classifiersToLoad.add(props.modelId);
            }
        });
        return loadClassifiers(classifiersToLoad, iModel);
    }
    SpatialClassification.loadModelClassifiers = loadModelClassifiers;
    /** @internal */
    async function loadClassifiers(classifierIdArg, iModel) {
        const classifierIds = bentleyjs_core_1.Id64.toIdSet(classifierIdArg);
        await iModel.models.load(classifierIds).then(async (_) => {
            for (const classifierId of classifierIds)
                await SpatialClassification.createClassifier(classifierId, iModel).then((classifier) => { if (classifier)
                    IModelApp_1.IModelApp.renderSystem.addSpatialClassificationModel(classifierId, classifier, iModel); });
        });
    }
    SpatialClassification.loadClassifiers = loadClassifiers;
    /** @internal */
    function addModelClassifierToScene(classifiedModel, context) {
        const classifierProps = getClassifierProps(classifiedModel);
        if (undefined !== classifierProps) {
            const classifier = IModelApp_1.IModelApp.renderSystem.getSpatialClassificationModel(classifierProps.modelId, classifiedModel.iModel);
            if (undefined !== classifier) {
                const classifierModel = classifiedModel.iModel.models.getLoaded(classifierProps.modelId);
                if (undefined !== classifierModel) {
                    const isPlanar = 1 /* Planar */ === classifier.type;
                    const batchType = isPlanar ? imodeljs_common_1.BatchType.PlanarClassifier : imodeljs_common_1.BatchType.VolumeClassifier;
                    classifierModel.loadClassifierTileTree(batchType, classifierProps.expand);
                    if (undefined === classifierModel.classifierTileTree)
                        return;
                    context.modelClassifiers.set(classifiedModel.treeModelId, classifierProps.modelId);
                    if (isPlanar) {
                        if (!context.getPlanarClassifier(classifierProps.modelId))
                            context.setPlanarClassifier(classifierProps.modelId, IModelApp_1.IModelApp.renderSystem.createPlanarClassifier(classifierProps, classifierModel.classifierTileTree, classifiedModel, context));
                    }
                    else {
                        classifierModel.classifierTileTree.drawScene(context);
                    }
                }
            }
        }
    }
    SpatialClassification.addModelClassifierToScene = addModelClassifierToScene;
    /** Get active spatial classifier
     * @alpha
     */
    function getActiveSpatialClassifier(model) {
        if (model.jsonProperties !== undefined && model.jsonProperties.classifiers !== undefined) {
            for (let index = 0; index < model.jsonProperties.classifiers.length; index++) {
                if (model.jsonProperties.classifiers[index].isActive)
                    return index;
            }
        }
        return -1;
    }
    SpatialClassification.getActiveSpatialClassifier = getActiveSpatialClassifier;
    /** Get spatial classifier at  index
     * @alpha
     */
    function getSpatialClassifier(model, index) {
        if (index < 0 || undefined === model.jsonProperties.classifiers || index >= model.jsonProperties.classifiers.length)
            return undefined;
        return new imodeljs_common_1.SpatialClassificationProps.Properties(model.jsonProperties.classifiers[index]);
    }
    SpatialClassification.getSpatialClassifier = getSpatialClassifier;
    /** Set the spatial classifier at index
     * @alpha
     */
    function setSpatialClassifier(model, index, classifier) {
        if (index < 0 || undefined === model.jsonProperties.classifiers || index >= model.jsonProperties.classifiers.length)
            return;
        model.jsonProperties.classifiers[index] = classifier;
    }
    SpatialClassification.setSpatialClassifier = setSpatialClassifier;
    /** Set the active spatial classifier by index
     * @alpha
     */
    async function setActiveSpatialClassifier(model, classifierIndex, active) {
        const classifiers = model.jsonProperties.classifiers;
        if (classifiers !== undefined)
            for (let index = 0; index < classifiers.length; index++)
                if (false !== (classifiers[index].isActive = (classifierIndex === index && active)))
                    await SpatialClassification.loadModelClassifiers(model.treeModelId, model.iModel);
    }
    SpatialClassification.setActiveSpatialClassifier = setActiveSpatialClassifier;
    /** Add a spatial classifier
     * @alpha
     */
    function addSpatialClassifier(model, classifier) {
        if (undefined === model.jsonProperties.classifiers)
            model.jsonProperties.classifiers = [];
        model.jsonProperties.classifiers.push(classifier);
    }
    SpatialClassification.addSpatialClassifier = addSpatialClassifier;
})(SpatialClassification = exports.SpatialClassification || (exports.SpatialClassification = {}));


/***/ }),

/***/ "./lib/Sprites.js":
/*!************************!*\
  !*** ./lib/Sprites.js ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const ImageUtil_1 = __webpack_require__(/*! ./ImageUtil */ "./lib/ImageUtil.js");
/** Sprites are small raster images that are drawn *on top* of Viewports by a ViewDecoration.
 * Their purpose is to draw the user's attention to something of importance.
 *
 * There are two classes in the Sprites subsystem: Sprite (a Sprite image) and SpriteLocation.
 * Sprite are the images that define the way a type of sprite looks and are generally
 * loaded one time and saved for the rest of a session. A SpriteLocation defines the current
 * position of a single Sprite in a Viewport.
 *
 * A SpriteLocation can be either active or inactive. It becomes active by specifying a location
 * (an x,y point) and a Sprite to draw at that point. A Sprite
 * can be used many times by many SpriteLocations and a single SpriteLocation can
 * change both position and which Sprite is shown at that position over time.
 * @public
 */
class Sprite {
    /** construct a Sprite from an ImageSource or a Url
     * @param src The ImageSource holding an image to create the texture for this Sprite, or the url of the image
     */
    constructor(src) {
        /** The size of this Sprite. If not loaded, value is not meaningful. */
        this.size = new geometry_core_1.Point2d();
        this.loadPromise = (typeof src === "string") ? ImageUtil_1.imageElementFromUrl(src) : ImageUtil_1.imageElementFromImageSource(src);
        this.loadPromise.then((image) => {
            this.image = image;
            this.size.set(image.naturalWidth, image.naturalHeight);
        });
    }
    /** The offset to the middle of this Sprite. If not loaded, value is not meaningful. */
    get offset() { return new geometry_core_1.Point2d(Math.round(this.size.x) / 2, Math.round(this.size.y / 2)); }
    /** Whether this sprite has be successfully loaded. */
    get isLoaded() { return undefined !== this.image; }
}
exports.Sprite = Sprite;
/** Icon sprites are loaded from .png files in the assets directory of imodeljs-native.
 * They are cached by name, and the cache is cleared when the ToolAdmin is shut down.
 * @public
 */
class IconSprites {
    /** Look up an IconSprite by url. If not loaded, create and load it.
     * @param spriteUrl The url of an image to load for this Sprite.
     */
    static getSpriteFromUrl(spriteUrl) {
        let sprite = this._sprites.get(spriteUrl);
        if (!sprite) {
            sprite = new Sprite(spriteUrl);
            this._sprites.set(spriteUrl, sprite);
        }
        return sprite;
    }
    /** Empty the cache, disposing all existing Sprites. */
    static emptyAll() { this._sprites.clear(); }
}
IconSprites._sprites = new Map();
exports.IconSprites = IconSprites;
/** A Sprite location. Sprites generally move around on the screen and this object holds the current location
 * and current Sprite within a ScreenViewport. SpriteLocations can be either inactive (not visible) or active.
 *
 * A SpriteLocation can also specify that a Sprite should be drawn partially transparent.
 * @public
 */
class SpriteLocation {
    constructor() {
        /** The current position of this sprite in view coordinates.
         * @see [[CanvasDecoration.position]]
         */
        this.position = new geometry_core_1.Point3d();
    }
    get isActive() { return this._viewport !== undefined; }
    /** Activate this SpriteLocation to show a Sprite at a location in a single ScreenViewport.
     * This call does not display the Sprite. Rather, subsequent calls to [[decorate]] from  will show the Sprite.
     * This SpriteLocation remains active until [[deactivate]] is called.
     * @param sprite The Sprite to draw at this SpriteLocation
     * @param viewport The Viewport onto which the Sprite is drawn
     * @param locationWorld The position, in world coordinates
     * @param alpha Optional alpha for the Sprite. Must be a number between 0 (fully transparent) and 1 (fully opaque).
     */
    activate(sprite, viewport, locationWorld, alpha) {
        this._sprite = sprite;
        this._alpha = alpha;
        this._viewport = viewport;
        viewport.worldToView(locationWorld, this.position);
        sprite.loadPromise.then(() => {
            if (this._viewport === viewport) // was this deactivated while we were loading?
                viewport.invalidateDecorations();
        });
    }
    /** Turn this SpriteLocation off so it will no longer show. */
    deactivate() {
        if (!this.isActive)
            return;
        this._viewport.invalidateDecorations();
        this._viewport = undefined;
    }
    /** Draw this sprite onto the supplied canvas.
     * @see [[CanvasDecoration.drawDecoration]]
     */
    drawDecoration(ctx) {
        const sprite = this._sprite;
        if (undefined === sprite.image)
            return;
        if (undefined !== this._alpha)
            ctx.globalAlpha = this._alpha;
        ctx.drawImage(sprite.image, -sprite.offset.x, -sprite.offset.y);
    }
    /** If this SpriteLocation is active and the supplied DecorateContext is for its Viewport, add the Sprite to decorations. */
    decorate(context) {
        if (context.viewport === this._viewport)
            context.addCanvasDecoration(this);
    }
}
exports.SpriteLocation = SpriteLocation;


/***/ }),

/***/ "./lib/StandardView.js":
/*!*****************************!*\
  !*** ./lib/StandardView.js ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
/** Describes a set of commonly-used view rotations.
 * @public
 */
var StandardViewId;
(function (StandardViewId) {
    /** Any rotation which does not match one of the standard rotations.
     * Invalid as an argument to StandardView.getStandardRotation() - used as a return value only.
     */
    StandardViewId[StandardViewId["NotStandard"] = -1] = "NotStandard";
    StandardViewId[StandardViewId["Top"] = 0] = "Top";
    StandardViewId[StandardViewId["Bottom"] = 1] = "Bottom";
    StandardViewId[StandardViewId["Left"] = 2] = "Left";
    StandardViewId[StandardViewId["Right"] = 3] = "Right";
    StandardViewId[StandardViewId["Front"] = 4] = "Front";
    StandardViewId[StandardViewId["Back"] = 5] = "Back";
    StandardViewId[StandardViewId["Iso"] = 6] = "Iso";
    StandardViewId[StandardViewId["RightIso"] = 7] = "RightIso";
})(StandardViewId = exports.StandardViewId || (exports.StandardViewId = {}));
let standardViewMatrices;
function getMatrices() {
    if (undefined !== standardViewMatrices)
        return standardViewMatrices;
    standardViewMatrices = [];
    standardViewMatrices[StandardViewId.Top] = geometry_core_1.Matrix3d.identity;
    standardViewMatrices[StandardViewId.Bottom] = geometry_core_1.Matrix3d.createRowValues(1, 0, 0, 0, -1, 0, 0, 0, -1);
    standardViewMatrices[StandardViewId.Left] = geometry_core_1.Matrix3d.createRowValues(0, -1, 0, 0, 0, 1, -1, 0, 0);
    standardViewMatrices[StandardViewId.Right] = geometry_core_1.Matrix3d.createRowValues(0, 1, 0, 0, 0, 1, 1, 0, 0);
    standardViewMatrices[StandardViewId.Front] = geometry_core_1.Matrix3d.createRowValues(1, 0, 0, 0, 0, 1, 0, -1, 0);
    standardViewMatrices[StandardViewId.Back] = geometry_core_1.Matrix3d.createRowValues(-1, 0, 0, 0, 0, 1, 0, 1, 0);
    standardViewMatrices[StandardViewId.Iso] = geometry_core_1.Matrix3d.createRowValues(0.707106781186548, -0.70710678118654757, 0.00000000000000000, 0.408248290463863, 0.40824829046386302, 0.81649658092772603, -0.577350269189626, -0.57735026918962573, 0.57735026918962573);
    standardViewMatrices[StandardViewId.RightIso] = geometry_core_1.Matrix3d.createRowValues(0.707106781186548, 0.70710678118654757, 0.00000000000000000, -0.408248290463863, 0.40824829046386302, 0.81649658092772603, 0.577350269189626, -0.57735026918962573, 0.57735026918962573);
    standardViewMatrices.forEach((mat) => Object.freeze(mat));
    return standardViewMatrices;
}
/** Supplies access to a set of commonly-used view rotations.
 * @public
 */
class StandardView {
    static get top() { return this.getStandardRotation(StandardViewId.Top); }
    static get bottom() { return this.getStandardRotation(StandardViewId.Bottom); }
    static get left() { return this.getStandardRotation(StandardViewId.Left); }
    static get right() { return this.getStandardRotation(StandardViewId.Right); }
    static get front() { return this.getStandardRotation(StandardViewId.Front); }
    static get back() { return this.getStandardRotation(StandardViewId.Back); }
    static get iso() { return this.getStandardRotation(StandardViewId.Iso); }
    static get rightIso() { return this.getStandardRotation(StandardViewId.RightIso); }
    /** Obtain a [[Matrix3d]] corresponding to the specified [[StandardViewId]].
     * @param id The ID of the desired rotation.
     * @return A rotation matrix corresponding to the requested standard view ID, or a "top" view rotation if the input does not correspond to a standard rotation.
     */
    static getStandardRotation(id) {
        if (id < StandardViewId.Top || id > StandardViewId.RightIso)
            id = StandardViewId.Top;
        return getMatrices()[id];
    }
    /** Attempts to adjust the supplied rotation matrix to match the standard view rotation it most closely matches.
     * If a matching standard rotation exists, the input matrix will be modified in-place to precisely match it.
     * Otherwise, the input matrix will be unmodified.
     * @param matrix The rotation matrix to adjust.
     */
    static adjustToStandardRotation(matrix) {
        getMatrices().some((test) => {
            if (test.maxDiff(matrix) > 1.0e-7)
                return false;
            matrix.setFrom(test);
            return true;
        });
    }
}
exports.StandardView = StandardView;


/***/ }),

/***/ "./lib/SubCategoriesCache.js":
/*!***********************************!*\
  !*** ./lib/SubCategoriesCache.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
var __asyncValues = (this && this.__asyncValues) || function (o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator], i;
    return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);
    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }
    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }
};
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const invalidCategoryIdEntry = new Set();
/** A cache of information about the subcategories contained within an [[IModelConnection]]. It is populated on demand.
 * @internal
 */
class SubCategoriesCache {
    constructor(imodel) {
        this._byCategoryId = new Map();
        this._appearances = new Map();
        this._imodel = imodel;
    }
    /** Get the Ids of all subcategories belonging to the category with the specified Id, or undefined if no such information is present. */
    getSubCategories(categoryId) { return this._byCategoryId.get(categoryId); }
    /** Get the base appearance of the subcategory with the specified Id, or undefined if no such information is present. */
    getSubCategoryAppearance(subCategoryId) { return this._appearances.get(subCategoryId.toString()); }
    /** Request that the subcategory information for all of the specified categories is loaded.
     * If all such information has already been loaded, returns undefined.
     * Otherwise, dispatches an asynchronous request to load those categories which are not already loaded and returns a cancellable request object
     * containing the corresponding promise and the set of categories still to be loaded.
     */
    load(categoryIds) {
        let missing;
        bentleyjs_core_1.Id64.forEach(categoryIds, (catId) => {
            if (undefined === this._byCategoryId.get(catId)) {
                if (undefined === missing)
                    missing = new Set();
                missing.add(catId);
            }
        });
        if (undefined === missing)
            return undefined;
        const request = new SubCategoriesCache.Request(missing, this._imodel);
        const promise = request.dispatch().then((result) => {
            if (undefined !== result)
                this.processResults(result, missing);
            return !request.wasCanceled;
        });
        return {
            missingCategoryIds: missing,
            promise,
            cancel: () => request.cancel(),
        };
    }
    clear() {
        this._byCategoryId.clear();
        this._appearances.clear();
    }
    onIModelConnectionClose() {
        this.clear();
    }
    static createSubCategoryAppearance(json) {
        let props;
        if ("string" === typeof json && 0 < json.length)
            props = JSON.parse(json);
        return new imodeljs_common_1.SubCategoryAppearance(props);
    }
    processResults(result, missing) {
        for (const row of result)
            this.add(row.parentId, row.id, SubCategoriesCache.createSubCategoryAppearance(row.appearance));
        // Ensure that any category Ids which returned no results (e.g., non-existent category, invalid Id, etc) are still recorded so they are not repeatedly re-requested
        for (const id of missing)
            if (undefined === this._byCategoryId.get(id))
                this._byCategoryId.set(id, invalidCategoryIdEntry);
    }
    add(categoryId, subCategoryId, appearance) {
        let set = this._byCategoryId.get(categoryId);
        if (undefined === set)
            this._byCategoryId.set(categoryId, set = new Set());
        set.add(subCategoryId);
        this._appearances.set(subCategoryId, appearance);
    }
}
exports.SubCategoriesCache = SubCategoriesCache;
/** This namespace and the types within it are exported strictly for use in tests.
 * @internal
 */
(function (SubCategoriesCache) {
    class Request {
        constructor(categoryIds, imodel, maxCategoriesPerQuery = 200) {
            this._ecsql = [];
            this._result = [];
            this._canceled = false;
            this._curECSqlIndex = 0;
            this._imodel = imodel;
            const catIds = [...categoryIds];
            while (catIds.length !== 0) {
                const end = (catIds.length > maxCategoriesPerQuery) ? maxCategoriesPerQuery : catIds.length;
                const where = catIds.splice(0, end).join(",");
                this._ecsql.push("SELECT ECInstanceId as id, Parent.Id as parentId, Properties as appearance FROM BisCore.SubCategory WHERE Parent.Id IN (" + where + ")");
            }
        }
        get wasCanceled() { return this._canceled || this._imodel.isClosed; }
        cancel() { this._canceled = true; }
        async dispatch() {
            var e_1, _a;
            if (this.wasCanceled || this._curECSqlIndex >= this._ecsql.length) // handle case of empty category Id set...
                return undefined;
            try {
                const ecsql = this._ecsql[this._curECSqlIndex];
                try {
                    for (var _b = __asyncValues(this._imodel.query(ecsql)), _c; _c = await _b.next(), !_c.done;) {
                        const row = _c.value;
                        this._result.push(row);
                        if (this.wasCanceled)
                            return undefined;
                    }
                }
                catch (e_1_1) { e_1 = { error: e_1_1 }; }
                finally {
                    try {
                        if (_c && !_c.done && (_a = _b.return)) await _a.call(_b);
                    }
                    finally { if (e_1) throw e_1.error; }
                }
            }
            catch (_) {
                // ###TODO: detect cases in which retry is warranted
                // Note that currently, if we succeed in obtaining some pages of results and fail to retrieve another page, we will end up processing the
                // incomplete results. Since we're not retrying, that's the best we can do.
            }
            // Finished with current ECSql query. Dispatch the next if one exists.
            if (++this._curECSqlIndex < this._ecsql.length) {
                if (this.wasCanceled)
                    return undefined;
                else
                    return this.dispatch();
            }
            // Even if we were canceled, we've retrieved all the rows. Might as well process them to prevent another request for some of the same rows from being enqueued.
            return this._result;
        }
    }
    SubCategoriesCache.Request = Request;
    class QueueEntry {
        constructor(categoryIds, func) {
            this.categoryIds = categoryIds;
            this.funcs = [func];
        }
    }
    SubCategoriesCache.QueueEntry = QueueEntry;
    /** A "queue" of SubCategoriesRequests, which consists of between 0 and 2 entries. Each entry specifies the set of category IDs to be loaded and a list of functions to be executed
     * when loading is completed. This is used to enforce ordering of operations upon subcategories despite the need to asynchronously load them. It incidentally also provides an
     * opportunity to reduce the number of backend requests by batching consecutive requests.
     * Chiefly used by [[Viewport]].
     * @internal
     */
    class Queue {
        constructor() {
            this._disposed = false;
        }
        /** Push a request onto the queue. The requested categories will be loaded if necessary, and then
         * the supplied function will be invoked. Any previously-pushed requests are guaranteed to be processed before this one.
         */
        push(cache, categoryIds, func) {
            if (this._disposed)
                return;
            else if (undefined === this._current)
                this.pushCurrent(cache, categoryIds, func);
            else
                this.pushNext(categoryIds, func);
        }
        /** Cancel all requests and empty the queue. */
        dispose() {
            if (undefined !== this._request) {
                bentleyjs_core_1.assert(undefined !== this._current);
                this._request.cancel();
                this._request = undefined;
            }
            this._current = this._next = undefined;
            this._disposed = true;
        }
        get isEmpty() {
            return undefined === this._current && undefined === this._next;
        }
        pushCurrent(cache, categoryIds, func) {
            bentleyjs_core_1.assert(undefined === this._next);
            bentleyjs_core_1.assert(undefined === this._current);
            bentleyjs_core_1.assert(undefined === this._request);
            this._request = cache.load(categoryIds);
            if (undefined === this._request) {
                // All requested categories are already loaded.
                func();
                return;
            }
            else {
                // We need to load the requested categories before invoking the function.
                this.processCurrent(cache, new QueueEntry(bentleyjs_core_1.Id64.toIdSet(categoryIds, true), func));
            }
        }
        processCurrent(cache, entry) {
            bentleyjs_core_1.assert(undefined !== this._request);
            bentleyjs_core_1.assert(undefined === this._current);
            bentleyjs_core_1.assert(undefined === this._next);
            this._current = entry;
            this._request.promise.then((completed) => {
                if (this._disposed)
                    return;
                // Invoke all the functions which were awaiting this set of categories.
                bentleyjs_core_1.assert(undefined !== this._current);
                if (completed)
                    for (const func of this._current.funcs)
                        func();
                this._request = undefined;
                this._current = undefined;
                // If we have more requests, process them.
                const next = this._next;
                this._next = undefined;
                if (undefined !== next) {
                    this._request = cache.load(next.categoryIds);
                    if (undefined === this._request) {
                        // All categories loaded.
                        for (const func of next.funcs)
                            func();
                    }
                    else {
                        // We need to load the requested categories before invoking the pending functions.
                        this.processCurrent(cache, next);
                    }
                }
            });
        }
        pushNext(categoryIds, func) {
            bentleyjs_core_1.assert(undefined !== this._current);
            bentleyjs_core_1.assert(undefined !== this._request);
            if (undefined === this._next) {
                // We have a request currently in process and none pending.
                // We could potentially determine that this request doesn't require any categories that are not already loaded or being loaded by the current request.
                // But we will find that out (synchronously) when current request completes, unless more requests come in. Probably not worth it.
                this._next = new QueueEntry(bentleyjs_core_1.Id64.toIdSet(categoryIds, true), func);
            }
            else {
                // We have a request currently in process, and one or more pending. Append this one to the pending.
                this._next.funcs.push(func);
                bentleyjs_core_1.Id64.forEach(categoryIds, (categoryId) => {
                    this._next.categoryIds.add(categoryId);
                });
            }
        }
    }
    SubCategoriesCache.Queue = Queue;
})(SubCategoriesCache = exports.SubCategoriesCache || (exports.SubCategoriesCache = {}));


/***/ }),

/***/ "./lib/TentativePoint.js":
/*!*******************************!*\
  !*** ./lib/TentativePoint.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module LocatingElements */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const Tool_1 = __webpack_require__(/*! ./tools/Tool */ "./lib/tools/Tool.js");
const HitDetail_1 = __webpack_require__(/*! ./HitDetail */ "./lib/HitDetail.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const AccuSnap_1 = __webpack_require__(/*! ./AccuSnap */ "./lib/AccuSnap.js");
const ViewTool_1 = __webpack_require__(/*! ./tools/ViewTool */ "./lib/tools/ViewTool.js");
/** @public */
class TentativePoint {
    constructor() {
        this.isActive = false;
        this._point = new geometry_core_1.Point3d();
        this._rawPoint = new geometry_core_1.Point3d();
        this._viewPoint = new geometry_core_1.Point3d();
    }
    get _hotDistanceInches() { return 0.21; }
    onInitialized() { }
    setHitList(list) { this.tpHits = list; }
    /** @return true if the tentative point is currently active and snapped to an element. */
    get isSnapped() { return undefined !== this.currSnap; }
    /** @return The current snap path when TentativePoint.isSnapped or undefined. */
    getCurrSnap() { return this.currSnap; }
    getPoint() {
        const snap = this.currSnap;
        return !snap ? this._point : snap.adjustedPoint;
    }
    setPoint(point) {
        this.setCurrSnap(undefined);
        this.tpHits = undefined;
        this._point.setFrom(point);
    }
    clear(doErase) {
        if (doErase) {
            this.removeTentative();
            IModelApp_1.IModelApp.accuSnap.synchSnapMode();
        }
        IModelApp_1.IModelApp.accuSnap.destroy();
        this.isActive = false;
        this.setCurrSnap(undefined);
        this.tpHits = undefined;
    }
    removeTentative() {
        this._tentativePromise = undefined;
        if (!this.isActive)
            return;
        IModelApp_1.IModelApp.accuSnap.erase();
        if (this.getCurrSnap())
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        else
            this.viewport.invalidateDecorations();
        this.isActive = false;
    }
    setCurrSnap(newSnap) {
        if (newSnap)
            newSnap.setSnapPoint(newSnap.snapPoint, HitDetail_1.SnapHeat.InRange); // Reset adjustedPoint from pre-located snap and set SnapHeat...
        this.currSnap = newSnap;
    }
    showTentative() {
        if (this.isSnapped) {
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            IModelApp_1.IModelApp.accuSnap.displayToolTip(this._viewPoint, this.viewport, undefined); // tslint:disable-line:no-floating-promises
        }
        else {
            this.viewport.invalidateDecorations();
        }
        this.isActive = true;
    }
    getHitAndList(holder) {
        const hit = this.currSnap;
        if (hit) {
            holder.setHitList(this.tpHits);
            this.tpHits = undefined;
        }
        return hit;
    }
    onButtonEvent(ev) {
        switch (ev.button) {
            case Tool_1.BeButton.Data:
                if (!ev.isDown)
                    return; // cleared on down...
                break;
            case Tool_1.BeButton.Reset:
                if (ev.isDown)
                    return; // cleared on up...
                break;
            case Tool_1.BeButton.Middle:
                return;
        }
        this.removeTentative();
        IModelApp_1.IModelApp.accuSnap.synchSnapMode();
        this.setCurrSnap(undefined);
        this.tpHits = undefined;
    }
    decorate(context) {
        const viewport = context.viewport;
        if (!this.isActive || !viewport)
            return;
        const tpSize = Math.floor(viewport.pixelsPerInch * 0.4) + 0.5;
        const toSizeOutline = tpSize + 1;
        const position = context.viewport.worldToView(this._point);
        position.x = Math.floor(position.x) + 0.5;
        position.y = Math.floor(position.y) + 0.5;
        const drawDecoration = (ctx) => {
            ctx.beginPath();
            ctx.strokeStyle = "rgba(0,0,0,.5)";
            ctx.lineWidth = 3;
            ctx.moveTo(-toSizeOutline, 0);
            ctx.lineTo(toSizeOutline, 0);
            ctx.moveTo(0, -toSizeOutline);
            ctx.lineTo(0, toSizeOutline);
            ctx.stroke();
            ctx.beginPath();
            ctx.strokeStyle = "white";
            ctx.lineWidth = 1;
            if (!this.isSnapped)
                ctx.setLineDash([4, 1]);
            ctx.shadowColor = "black";
            ctx.shadowBlur = 5;
            ctx.moveTo(-tpSize, 0);
            ctx.lineTo(tpSize, 0);
            ctx.moveTo(0, -tpSize);
            ctx.lineTo(0, tpSize);
            ctx.stroke();
        };
        context.addCanvasDecoration({ position, drawDecoration });
    }
    async getSnap(newSearch) {
        // Use next hit from previous search when using tentative to cycle through hits...
        let thisHit = (!newSearch && undefined !== this.tpHits ? this.tpHits.getNextHit() : undefined);
        // Use existing AccuSnap hit list if one exists...
        if (undefined === thisHit) {
            this.tpHits = undefined;
            thisHit = IModelApp_1.IModelApp.accuSnap.getHitAndList(this);
        }
        if (undefined === thisHit) {
            // search for elements around the current raw point (search should not be affected by locks!)
            const aperture = (2.0 * this.viewport.pixelsFromInches(IModelApp_1.IModelApp.locateManager.apertureInches) / 2.0) + 1.5;
            const options = IModelApp_1.IModelApp.locateManager.options.clone(); // Copy to avoid changing out from under active Tool...
            const picker = IModelApp_1.IModelApp.locateManager.picker;
            options.hitSource = HitDetail_1.HitSource.TentativeSnap;
            if (0 === picker.doPick(this.viewport, this._rawPoint, aperture, options))
                return undefined;
            this.tpHits = picker.getHitList(true);
            thisHit = (undefined !== this.tpHits ? this.tpHits.getNextHit() : undefined);
        }
        else if (thisHit instanceof HitDetail_1.SnapDetail) {
            // Make the current AccuSnap the TentativePoint snap...
            return thisHit;
        }
        if (undefined === thisHit)
            return undefined;
        const snapModes = IModelApp_1.IModelApp.accuSnap.getActiveSnapModes(); // Get the list of point snap modes to consider
        if (1 === snapModes.length && HitDetail_1.SnapMode.Intersection === snapModes[0])
            snapModes.push(HitDetail_1.SnapMode.Nearest); // Add nearest when doing intersection by itself to support finding extended intersections...
        const thisSnap = await AccuSnap_1.AccuSnap.requestSnap(thisHit, snapModes, this._hotDistanceInches, IModelApp_1.IModelApp.accuSnap.keypointDivisor, this.tpHits);
        if (undefined !== thisSnap)
            IModelApp_1.IModelApp.accuDraw.onSnap(thisSnap); // AccuDraw can adjust nearest snap to intersection of circle (polar distance lock) or line (axis lock) with snapped to curve...
        return thisSnap;
    }
    static arePointsCloseEnough(pt1, pt2, pixelDistance) { return pt1.distance(pt2) < (pixelDistance + 1.5); }
    process(ev) {
        if (undefined !== this._tentativePromise)
            return;
        const currTool = IModelApp_1.IModelApp.toolAdmin.viewTool;
        if (currTool && currTool.inDynamicUpdate)
            return; // trying to tentative snap while view is changing isn't useful...
        const wasActive = this.isActive;
        this.removeTentative(); // remove the TP cross if it is already on the screen
        const lastPtView = this._viewPoint.clone();
        this.viewport = ev.viewport;
        this._point.setFrom(ev.point);
        this._rawPoint.setFrom(ev.rawPoint);
        this._viewPoint.setFrom(ev.viewPoint);
        const newSearch = (!this.isSnapped || !TentativePoint.arePointsCloseEnough(lastPtView, this._viewPoint, this.viewport.pixelsFromInches(IModelApp_1.IModelApp.locateManager.apertureInches)));
        const promise = this.getSnap(newSearch);
        this._tentativePromise = promise;
        promise.then((newSnap) => {
            // Ignore response if we're no longer interested in this tentative.
            if (this._tentativePromise === promise) {
                this._tentativePromise = undefined;
                this.setCurrSnap(newSnap); // Adopt the snap as current
                IModelApp_1.IModelApp.accuSnap.clear(); // make sure there's no AccuSnap active after a tentative point (otherwise we continually snap to it).
                if (this.isSnapped)
                    this._point.setFrom(this.currSnap.snapPoint);
                else if (wasActive && newSearch)
                    this._point.setFrom(ev.rawPoint);
                this.showTentative(); // show the TP cross
                if (this.isSnapped) {
                    IModelApp_1.IModelApp.toolAdmin.adjustSnapPoint();
                }
                else if (IModelApp_1.IModelApp.accuDraw.isActive) {
                    const point = this.getPoint().clone();
                    const vp = ev.viewport;
                    if (vp.isSnapAdjustmentRequired) {
                        IModelApp_1.IModelApp.toolAdmin.adjustPointToACS(point, vp, false);
                        const hit = new HitDetail_1.HitDetail(point, vp, HitDetail_1.HitSource.TentativeSnap, point, "", HitDetail_1.HitPriority.Unknown, 0, 0);
                        const snap = new HitDetail_1.SnapDetail(hit);
                        this.setCurrSnap(snap);
                        IModelApp_1.IModelApp.toolAdmin.adjustSnapPoint();
                        this.setPoint(this.getPoint());
                    }
                    else {
                        IModelApp_1.IModelApp.accuDraw.adjustPoint(point, vp, false);
                        const savePoint = point.clone();
                        IModelApp_1.IModelApp.toolAdmin.adjustPointToGrid(point, vp);
                        if (!point.isExactEqual(savePoint))
                            IModelApp_1.IModelApp.accuDraw.adjustPoint(point, vp, false);
                        this.setPoint(point);
                    }
                }
                else {
                    IModelApp_1.IModelApp.toolAdmin.adjustPoint(this.getPoint(), ev.viewport);
                }
                IModelApp_1.IModelApp.accuDraw.onTentative();
                if (currTool && currTool instanceof ViewTool_1.ViewManip && currTool.viewHandles.hasHandle(2 /* TargetCenter */))
                    currTool.updateTargetCenter(); // Change target center to tentative location...
                else
                    IModelApp_1.IModelApp.toolAdmin.updateDynamics(); // Don't wait for motion to update tool dynamics...
            }
        });
    }
}
exports.TentativePoint = TentativePoint;


/***/ }),

/***/ "./lib/TerrainProvider.js":
/*!********************************!*\
  !*** ./lib/TerrainProvider.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const TiledGraphicsProvider_1 = __webpack_require__(/*! ./TiledGraphicsProvider */ "./lib/TiledGraphicsProvider.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
/** Terrain provider that provides tile tree for display within a [[Viewport]].
 * @internal
 */
class TerrainProvider {
    onInitialized() {
        IModelApp_1.IModelApp.viewManager.onViewOpen.addListener((viewport) => { viewport.addTiledGraphicsProvider(TiledGraphicsProvider_1.TiledGraphicsProvider.Type.Geometry, this); });
    }
}
exports.TerrainProvider = TerrainProvider;


/***/ }),

/***/ "./lib/TiledGraphicsProvider.js":
/*!**************************************!*\
  !*** ./lib/TiledGraphicsProvider.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/** @internal */
var TiledGraphicsProvider;
(function (TiledGraphicsProvider) {
    /** Types of TiledGraphicsProviders.
     * @internal
     */
    let Type;
    (function (Type) {
        Type[Type["BackgroundMap"] = 0] = "BackgroundMap";
        Type[Type["Geometry"] = 1] = "Geometry";
        Type[Type["Overlay"] = 2] = "Overlay";
    })(Type = TiledGraphicsProvider.Type || (TiledGraphicsProvider.Type = {}));
})(TiledGraphicsProvider = exports.TiledGraphicsProvider || (exports.TiledGraphicsProvider = {}));


/***/ }),

/***/ "./lib/ViewContext.js":
/*!****************************!*\
  !*** ./lib/ViewContext.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const GraphicBuilder_1 = __webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/Viewport.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const TiledGraphicsProvider_1 = __webpack_require__(/*! ./TiledGraphicsProvider */ "./lib/TiledGraphicsProvider.js");
const gridConstants = { maxPoints: 50, maxRefs: 25, maxDotsInRow: 250, maxHorizon: 500, dotTransparency: 100, lineTransparency: 200, planeTransparency: 225 };
/** Provides context for producing [[RenderGraphic]]s for drawing within a [[Viewport]].
 * @public
 */
class RenderContext {
    constructor(vp, frustum) {
        this.viewport = vp;
        this.viewFlags = vp.viewFlags.clone(); // viewFlags can diverge from viewport after attachment
        this.frustum = frustum ? frustum : vp.getFrustum();
        this.frustumPlanes = new imodeljs_common_1.FrustumPlanes(this.frustum);
    }
    /** Given a point in world coordinates, determine approximately how many pixels it occupies on screen based on this context's frustum. */
    getPixelSizeAtPoint(inPoint) { return this.viewport.viewFrustum.getPixelSizeAtPoint(inPoint); }
    /** @internal */
    get target() { return this.viewport.target; }
    /** @internal */
    _createGraphicBuilder(type, transform, id) { return this.target.createGraphicBuilder(type, this.viewport, transform, id); }
    /** Create a builder for creating a [[GraphicType.Scene]] [[RenderGraphic]] for rendering within this context's [[Viewport]].
     * @param transform the local-to-world transform in which the builder's geometry is to be defined.
     * @returns A builder for creating a [[GraphicType.Scene]] [[RenderGraphic]] for rendering within this context's [[Viewport]].
     */
    createSceneGraphicBuilder(transform) { return this._createGraphicBuilder(GraphicBuilder_1.GraphicType.Scene, transform); }
    /** @internal */
    createGraphicBranch(branch, location, clip, planarClassifier) { return this.target.renderSystem.createGraphicBranch(branch, location, clip, planarClassifier); }
    /** Create a [[RenderGraphic]] which groups a set of graphics into a node in a scene graph, applying to each a transform and optional clip volume and symbology overrides.
     * @param branch Contains the group of graphics and the symbology overrides.
     * @param location the local-to-world transform applied to the grouped graphics.
     * @returns A RenderGraphic suitable for drawing the scene graph node within this context's [[Viewport]].
     * @see [[RenderSystem.createBranch]]
     */
    createBranch(branch, location) { return this.createGraphicBranch(branch, location); }
}
exports.RenderContext = RenderContext;
/** Provides context for an [[InteractiveTool]] to display decorations representing its current state.
 * @see [[InteractiveTool.onDynamicFrame]]
 * @public
 */
class DynamicsContext extends RenderContext {
    /** Add a graphic to the list of dynamic graphics to be drawn in this context's [[Viewport]]. */
    addGraphic(graphic) {
        if (undefined === this._dynamics)
            this._dynamics = [];
        this._dynamics.push(graphic);
    }
    /** @internal */
    changeDynamics() { this.viewport.changeDynamics(this._dynamics); }
}
exports.DynamicsContext = DynamicsContext;
/** Provides context for a [[Decorator]] to add [[Decorations]] to be rendered within a [[Viewport]].
 * @public
 */
class DecorateContext extends RenderContext {
    /** @internal */
    constructor(vp, _decorations) {
        super(vp);
        this._decorations = _decorations;
        this.decorationDiv = vp.decorationDiv;
    }
    /** The [[ScreenViewport]] in which this context's [[Decorations]] will be drawn. */
    get screenViewport() { return this.viewport; }
    /** @internal */
    static getGridDimension(props, gridSize, org, dir, points) {
        // initialized only to avoid warning.
        let distLow = 0.0;
        let distHigh = 0.0;
        for (let i = 0, n = points.length; i < n; ++i) {
            const distance = org.vectorTo(points[i]).dotProduct(dir);
            if (i) {
                if (distance < distLow)
                    distLow = distance;
                if (distance > distHigh)
                    distHigh = distance;
            }
            else {
                distLow = distHigh = distance;
            }
        }
        if (distHigh <= distLow)
            return false;
        props.min = Math.floor(distLow / gridSize); // NOTE: Should be ok to let grid extend outside project extents since view extends padded for ground plane...
        const max = Math.ceil(distHigh / gridSize);
        props.nRepetitions = max - props.min;
        props.min *= gridSize;
        return true;
    }
    /** @internal */
    static getGridPlaneViewIntersections(planePoint, planeNormal, vp, useProjectExtents) {
        const plane = geometry_core_1.Plane3dByOriginAndUnitNormal.create(planePoint, planeNormal);
        if (undefined === plane)
            return [];
        const frust = vp.getFrustum();
        const limitRange = useProjectExtents && vp.view.isSpatialView();
        // Limit non-view aligned grid to project extents in spatial views...
        if (limitRange) {
            const range = vp.view.iModel.projectExtents.clone();
            if (range.isNull)
                return [];
            range.intersect(frust.toRange(), range);
            if (range.isNull)
                return [];
            frust.initFromRange(range);
        }
        const index = new Array(
        // lines connecting front to back
        [imodeljs_common_1.Npc._000, imodeljs_common_1.Npc._001], [imodeljs_common_1.Npc._100, imodeljs_common_1.Npc._101], [imodeljs_common_1.Npc._010, imodeljs_common_1.Npc._011], [imodeljs_common_1.Npc._110, imodeljs_common_1.Npc._111], 
        // around front face
        [imodeljs_common_1.Npc._000, imodeljs_common_1.Npc._100], [imodeljs_common_1.Npc._100, imodeljs_common_1.Npc._110], [imodeljs_common_1.Npc._110, imodeljs_common_1.Npc._010], [imodeljs_common_1.Npc._010, imodeljs_common_1.Npc._000], 
        // around back face.
        [imodeljs_common_1.Npc._001, imodeljs_common_1.Npc._101], [imodeljs_common_1.Npc._101, imodeljs_common_1.Npc._111], [imodeljs_common_1.Npc._111, imodeljs_common_1.Npc._011], [imodeljs_common_1.Npc._011, imodeljs_common_1.Npc._001]);
        const intersections = [];
        for (let i = 0, n = index.length; i < n; ++i) {
            const corner1 = frust.getCorner(index[i][0]), corner2 = frust.getCorner(index[i][1]);
            const lineSegment = geometry_core_1.LineSegment3d.create(corner1, corner2);
            lineSegment.appendPlaneIntersectionPoints(plane, intersections);
        }
        return intersections.map((cld) => cld.point.clone());
    }
    /** Create a builder for creating a [[RenderGraphic]] of the specified type appropriate for rendering within this context's [[Viewport]].
     * @param type The type of builder to create.
     * @param transform the local-to-world transform in which the builder's geometry is to be defined.
     * @param id If the decoration is to be pickable, a unique identifier to associate with the resultant [[RenderGraphic]].
     * @returns A builder for creating a [[RenderGraphic]] of the specified type appropriate for rendering within this context's [[Viewport]].
     * @see [[IModelConnection.transientIds]] for obtaining an ID for a pickable decoration.
     */
    createGraphicBuilder(type, transform, id) { return this._createGraphicBuilder(type, transform, id); }
    /** Calls [[GraphicBuilder.finish]] on the supplied builder to obtain a [[RenderGraphic]], then adds the graphic to the appropriate list of
     * [[Decorations]].
     * @param builder The builder from which to extract the graphic.
     * @note The builder should not be used after calling this method.
     */
    addDecorationFromBuilder(builder) { this.addDecoration(builder.type, builder.finish()); }
    /** Adds a graphic to the set of [[Decorations]] to be drawn in this context's [[Viewport]].
     * @param The type of the graphic, which determines to which list of decorations it is added.
     * @param decoration The decoration graphic to add.
     * @note The type must match the type with which the [[RenderGraphic]]'s [[GraphicBuilder]] was constructed.
     * @see [[DecorateContext.addDecorationFromBuilder]] for a more convenient API.
     */
    addDecoration(type, decoration) {
        switch (type) {
            case GraphicBuilder_1.GraphicType.Scene:
                if (undefined === this._decorations.normal)
                    this._decorations.normal = [];
                this._decorations.normal.push(decoration);
                break;
            case GraphicBuilder_1.GraphicType.WorldDecoration:
                if (!this._decorations.world)
                    this._decorations.world = [];
                this._decorations.world.push(decoration);
                break;
            case GraphicBuilder_1.GraphicType.WorldOverlay:
                if (!this._decorations.worldOverlay)
                    this._decorations.worldOverlay = [];
                this._decorations.worldOverlay.push(decoration);
                break;
            case GraphicBuilder_1.GraphicType.ViewOverlay:
                if (!this._decorations.viewOverlay)
                    this._decorations.viewOverlay = [];
                this._decorations.viewOverlay.push(decoration);
                break;
        }
    }
    /** Add a [[CanvasDecoration]] to be drawn in this context's [[Viewport]]. */
    addCanvasDecoration(decoration, atFront = false) {
        if (undefined === this._decorations.canvasDecorations)
            this._decorations.canvasDecorations = [];
        const list = this._decorations.canvasDecorations;
        if (0 === list.length || true === atFront)
            list.push(decoration);
        else
            list.unshift(decoration);
    }
    /** Add an HTMLElement to be drawn as a decoration in this context's [[Viewport]]. */
    addHtmlDecoration(decoration) { this.decorationDiv.appendChild(decoration); }
    /** @internal */
    drawStandardGrid(gridOrigin, rMatrix, spacing, gridsPerRef, isoGrid = false, fixedRepetitions) {
        const vp = this.viewport;
        // rotMatrix returns new Vectors instead of references
        const xVec = rMatrix.rowX(), yVec = rMatrix.rowY(), zVec = rMatrix.rowZ(), viewZ = vp.rotation.getRow(2);
        if (!vp.isCameraOn && Math.abs(viewZ.dotProduct(zVec)) < 0.005)
            return;
        const refScale = (0 === gridsPerRef) ? 1.0 : gridsPerRef;
        const refSpacing = geometry_core_1.Vector2d.create(spacing.x, spacing.y).scale(refScale);
        let gridOrg = new geometry_core_1.Point3d();
        let repetitions = new geometry_core_1.Point2d();
        if (undefined === fixedRepetitions || 0 === fixedRepetitions.x || 0 === fixedRepetitions.y) {
            // expect gridOrigin and zVec to be modified from this call
            const intersections = DecorateContext.getGridPlaneViewIntersections(gridOrigin, zVec, vp, undefined !== fixedRepetitions);
            if (intersections.length < 3)
                return;
            const min = new geometry_core_1.Point2d(), xProps = { nRepetitions: repetitions.x, min: min.x }, yProps = { nRepetitions: repetitions.y, min: min.y };
            if (!DecorateContext.getGridDimension(xProps, refSpacing.x, gridOrigin, geometry_core_1.Point3d.createFrom(xVec), intersections) ||
                !DecorateContext.getGridDimension(yProps, refSpacing.y, gridOrigin, geometry_core_1.Point3d.createFrom(yVec), intersections))
                return;
            // update vectors. (workaround for native passing primitives by reference)
            repetitions.x = xProps.nRepetitions;
            min.x = xProps.min;
            repetitions.y = yProps.nRepetitions;
            min.y = yProps.min;
            gridOrg.plus3Scaled(gridOrigin, 1, xVec, min.x, yVec, min.y, gridOrg);
        }
        else {
            gridOrg = gridOrigin;
            repetitions = fixedRepetitions;
        }
        if (0 === repetitions.x || 0 === repetitions.y)
            return;
        const gridX = xVec.scale(refSpacing.x), gridY = yVec.scale(refSpacing.y);
        const testPt = gridOrg.plus2Scaled(gridX, repetitions.x / 2.0, gridY, repetitions.y / 2.0);
        let maxGridPts = gridConstants.maxPoints;
        let maxGridRefs = gridConstants.maxRefs;
        if (maxGridPts < 10)
            maxGridPts = 10;
        if (maxGridRefs < 10)
            maxGridRefs = 10;
        // values are "per 1000 pixels"
        const minGridSeparationPixels = 1000 / maxGridPts, minRefSeparation = 1000 / maxGridRefs;
        let meterPerPixel = vp.getPixelSizeAtPoint(testPt);
        if ((refSpacing.x / meterPerPixel) < minRefSeparation || (refSpacing.y / meterPerPixel) < minRefSeparation)
            gridsPerRef = 0;
        // Avoid z fighting with coincident geometry
        gridOrg.plusScaled(viewZ, meterPerPixel, gridOrg); // was SumOf(DPoint2dCR point, DPoint2dCR vector, double s)
        meterPerPixel *= refScale;
        const drawDots = ((refSpacing.x / meterPerPixel) > minGridSeparationPixels) && ((refSpacing.y / meterPerPixel) > minGridSeparationPixels);
        const builder = this.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldDecoration, undefined, undefined);
        DecorateContext.drawGrid(builder, isoGrid, drawDots, gridOrg, gridX, gridY, gridsPerRef, repetitions, vp);
        this.addDecorationFromBuilder(builder);
    }
    /** @internal */
    static drawGrid(graphic, doIsogrid, drawDots, gridOrigin, xVec, yVec, gridsPerRef, repetitions, vp) {
        const eyePoint = vp.worldToViewMap.transform1.columnZ();
        const viewZ = geometry_core_1.Vector3d.createFrom(eyePoint);
        const aa = geometry_core_1.Geometry.conditionalDivideFraction(1, eyePoint.w);
        if (aa !== undefined) {
            const xyzEye = viewZ.scale(aa);
            viewZ.setFrom(gridOrigin.vectorTo(xyzEye));
        }
        let normResult = viewZ.normalize(viewZ);
        if (!normResult)
            return;
        const zVec = xVec.crossProduct(yVec);
        normResult = zVec.normalize(zVec);
        if (!normResult)
            return;
        const color = vp.getContrastToBackgroundColor();
        const lineColor = color.clone();
        const dotColor = color.clone();
        const planeColor = color.clone();
        lineColor.setTransparency(gridConstants.lineTransparency);
        dotColor.setTransparency(gridConstants.dotTransparency);
        planeColor.setTransparency(gridConstants.planeTransparency);
        let linePat = imodeljs_common_1.LinePixels.Solid;
        if (viewZ.dotProduct(zVec) < 0.0) { // Provide visual indication that grid is being viewed from the back (grid z not towards eye)...
            planeColor.setFrom(imodeljs_common_1.ColorDef.red);
            planeColor.setTransparency(gridConstants.planeTransparency);
            linePat = imodeljs_common_1.LinePixels.Code2;
        }
        const gpr = gridsPerRef > 0 ? gridsPerRef : 1;
        const rpg = 1 / gpr;
        if (doIsogrid)
            gridsPerRef = 0; // turn off reference grid for iso
        if (drawDots) {
            const dotXVec = geometry_core_1.Vector3d.createFrom(xVec);
            const dotYVec = geometry_core_1.Vector3d.createFrom(yVec);
            dotXVec.scale(rpg, dotXVec);
            dotYVec.scale(rpg, dotYVec);
            graphic.setSymbology(dotColor, planeColor, 1);
            DecorateContext.drawGridDots(graphic, doIsogrid, gridOrigin, dotYVec, repetitions.y * gpr, dotXVec, repetitions.x * gpr, gridsPerRef, vp);
        }
        if (0 < gridsPerRef) {
            graphic.setSymbology(lineColor, planeColor, 1, linePat);
            DecorateContext.drawGridRefs(graphic, gridOrigin, xVec, yVec, repetitions.x, repetitions.y);
            DecorateContext.drawGridRefs(graphic, gridOrigin, yVec, xVec, repetitions.y, repetitions.x);
        }
        // don't draw grid plane if perpendicular to view
        if (viewZ.isPerpendicularTo(xVec))
            return;
        // grid refs or points will give visual indication of grid plane...
        // note: references to same points here are okay
        const shapePoints = [
            gridOrigin,
            gridOrigin.plusScaled(xVec, repetitions.x),
            gridOrigin.plus2Scaled(xVec, repetitions.x, yVec, repetitions.y),
            gridOrigin.plusScaled(yVec, repetitions.y),
            gridOrigin,
        ];
        if (0 === gridsPerRef) {
            graphic.setSymbology(lineColor, planeColor, 1, linePat);
            graphic.addLineString(shapePoints);
        }
        graphic.setBlankingFill(planeColor);
        graphic.addShape(shapePoints);
    }
    /** Private grid-specific function for computing intersections of a ray with a convex set of clipping planes. */
    static getClipPlaneIntersection(clipDistance, origin, direction, convexSet) {
        clipDistance.min = -Number.MAX_VALUE;
        clipDistance.max = Number.MAX_VALUE;
        for (let i = 0; i < 6; i++) {
            const plane = convexSet.planes[i];
            const vD = plane.dotProductVector(direction);
            const vN = plane.evaluatePoint(origin);
            const testValue = -vN / vD;
            if (vD > 0.0) {
                if (testValue > clipDistance.min)
                    clipDistance.min = testValue;
            }
            else if (vD < 0.0) {
                if (testValue < clipDistance.max)
                    clipDistance.max = testValue;
            }
        }
        return clipDistance.min < clipDistance.max;
    }
    static drawGridDots(graphic, doIsoGrid, origin, rowVec, rowRepetitions, colVec, colRepetitions, refSpacing, vp) {
        const colSpacing = colVec.magnitude();
        const colNormal = colVec.normalize();
        if (!colNormal)
            return;
        const points = [];
        const cameraOn = vp.isCameraOn;
        let zCamera = 0.0;
        let zCameraLimit = 0.0;
        const viewZ = geometry_core_1.Vector3d.create();
        if (cameraOn) {
            const view = vp.view;
            const camera = view.camera;
            const sizeLimit = gridConstants.maxHorizon * colSpacing / vp.viewDelta.x;
            vp.rotation.rowZ(viewZ);
            zCamera = viewZ.dotProduct(camera.getEyePoint());
            zCameraLimit = zCamera - camera.focusDist * sizeLimit;
        }
        const corners = vp.getFrustum();
        const clipPlanes = corners.getRangePlanes(true, true, 0);
        const clipDistance = { min: 0, max: 0 };
        for (let i = 0; i < rowRepetitions; i++) {
            if (0 !== refSpacing && 0 === (i % refSpacing))
                continue;
            const dotOrigin = origin.plusScaled(rowVec, i);
            if (DecorateContext.getClipPlaneIntersection(clipDistance, dotOrigin, colNormal, clipPlanes)) {
                if (cameraOn) {
                    const startPoint = dotOrigin.plusScaled(colNormal, clipDistance.min);
                    const endPoint = dotOrigin.plusScaled(colNormal, clipDistance.max);
                    if (viewZ.dotProduct(startPoint) < zCameraLimit && viewZ.dotProduct(endPoint) < zCameraLimit)
                        continue;
                }
                let nToDisplay = 0;
                let jMin = Math.floor(clipDistance.min / colSpacing);
                let jMax = Math.ceil(clipDistance.max / colSpacing);
                // Choose values that result in the least amount of dots between jMin-jMax and 0-colRepetitions...
                jMin = jMin < 0 ? 0 : jMin;
                jMax = jMax > colRepetitions ? colRepetitions : jMax;
                const isoOffset = doIsoGrid && (i & 1) ? 0.5 : 0.0;
                for (let j = jMin; j <= jMax && nToDisplay < gridConstants.maxDotsInRow; j++) {
                    if (0 !== refSpacing && 0 === (j % refSpacing))
                        continue;
                    const point = dotOrigin.plusScaled(colVec, j + isoOffset);
                    if (cameraOn) {
                        const pointZ = viewZ.dotProduct(point);
                        if (pointZ < zCamera && pointZ > zCameraLimit)
                            points.push(point);
                    }
                    else {
                        points.push(point);
                    }
                    nToDisplay++;
                }
            }
        }
        if (points.length !== 0)
            graphic.addPointString(points);
    }
    static drawGridRefs(graphic, org, rowVec, colVec, rowRepetitions, colRepetitions) {
        const gridEnd = org.plusScaled(colVec, colRepetitions);
        for (let i = 0; i <= rowRepetitions; i += 1) {
            const linePoints = [
                org.plusScaled(rowVec, i),
                gridEnd.plusScaled(rowVec, i),
            ];
            graphic.addLineString(linePoints);
        }
    }
    /** Display skyBox graphic that encompasses entire scene and rotates with camera.
     * @see [[RenderSystem.createSkyBox]].
     */
    setSkyBox(graphic) { this._decorations.skyBox = graphic; }
    /** Set the graphic to be displayed behind all other geometry as the background of this context's [[Viewport]]. */
    setViewBackground(graphic) { this._decorations.viewBackground = graphic; }
}
exports.DecorateContext = DecorateContext;
/** Context used to create the scene for a [[Viewport]]. The scene consists of a set of [[RenderGraphic]]s produced by the
 * [[TileTree]]s visible within the viewport. Creating the scene may result in the enqueueing of [[TileRequest]]s for [[Tile]]s which
 * should be displayed in the viewport but are not yet loaded.
 * @internal
 */
class SceneContext extends RenderContext {
    constructor(vp, frustum) {
        super(vp, frustum);
        this.graphics = [];
        this.backgroundGraphics = [];
        this.missingTiles = new Set();
        this.hasMissingTiles = false; // ###TODO for asynchronous loading of child nodes...turn those into requests too.
        this.modelClassifiers = new Map(); // Model id to classifier model Id.
    }
    get viewFrustum() {
        return (undefined !== this.extendedFrustumPlane) ? Viewport_1.ViewFrustum.createFromViewportAndPlane(this.viewport, this.extendedFrustumPlane) : this.viewport.viewFrustum;
    }
    outputGraphic(graphic) {
        if (this._tiledGraphicsProviderType !== undefined) {
            switch (this._tiledGraphicsProviderType) {
                case TiledGraphicsProvider_1.TiledGraphicsProvider.Type.BackgroundMap:
                    this.backgroundGraphics.push(graphic);
                    break;
                default:
                    bentleyjs_core_1.assert(false, "currently unsupported graphics provider type");
            }
        }
        else {
            this.graphics.push(graphic);
        }
    }
    insertMissingTile(tile) {
        switch (tile.loadStatus) {
            case 0 /* NotLoaded */:
            case 1 /* Queued */:
            case 2 /* Loading */:
                this.missingTiles.add(tile);
                break;
        }
    }
    requestMissingTiles() {
        IModelApp_1.IModelApp.tileAdmin.requestTiles(this.viewport, this.missingTiles);
    }
    set tiledGraphicsProviderType(providerType) { this._tiledGraphicsProviderType = providerType; }
    getPlanarClassifier(id) { return this.planarClassifiers ? this.planarClassifiers.get(id) : undefined; }
    setPlanarClassifier(id, planarClassifier) {
        if (!this.planarClassifiers)
            this.planarClassifiers = new Map();
        this.planarClassifiers.set(id, planarClassifier);
    }
    getPlanarClassifierForModel(modelId) {
        const classifierId = this.modelClassifiers.get(modelId);
        return undefined === classifierId ? undefined : this.getPlanarClassifier(classifierId);
    }
}
exports.SceneContext = SceneContext;


/***/ }),

/***/ "./lib/ViewManager.js":
/*!****************************!*\
  !*** ./lib/ViewManager.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const EventController_1 = __webpack_require__(/*! ./tools/EventController */ "./lib/tools/EventController.js");
const Tool_1 = __webpack_require__(/*! ./tools/Tool */ "./lib/tools/Tool.js");
/** The ViewManager holds the list of opened views, plus the *selected view*. It also provides notifications of view open/close and suspend/resume.
 * Applications must call [[addViewport]] when new Viewports that should be associated with user events are created.
 *
 * A single ViewManager is created when [[IModelApp.startup]] is called. It can be accessed via the static member [[IModelApp.viewManager]].
 *
 * The ViewManager controls the render loop, which causes the contents of each registered [[Viewport]] to update on the screen.
 * @public
 */
class ViewManager {
    constructor() {
        this.inDynamicsMode = false;
        this.cursor = "default";
        this._viewports = [];
        this.decorators = [];
        this._invalidateScenes = false;
        this._skipSceneCreation = false;
        /** Called after the selected view changes.
         * @param old Previously selected viewport.
         * @param current Currently selected viewport.
         */
        this.onSelectedViewportChanged = new bentleyjs_core_1.BeUiEvent();
        /** Called after a view is opened. This can happen when the iModel is first opened or when a user opens a new view. */
        this.onViewOpen = new bentleyjs_core_1.BeUiEvent();
        /** Called after a view is closed. This can happen when the iModel is closed or when a user closes an open view. */
        this.onViewClose = new bentleyjs_core_1.BeUiEvent();
        /** Called after a view is suspended. This happens when the application is minimized or, on a tablet, when the application
         * is moved to the background.
         */
        this.onViewSuspend = new bentleyjs_core_1.BeUiEvent();
        /** Called after a suspended view is resumed. This can happen when a minimized application is restored
         * or, on a tablet, when the application is moved to the foreground.
         */
        this.onViewResume = new bentleyjs_core_1.BeUiEvent();
        /** Called at the beginning of each tick of the render loop, before any viewports have been updated.
         * The render loop is typically invoked by a requestAnimationFrame() callback. It will not be invoked if the ViewManager is tracking no viewports.
         * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.
         * @see [[ViewManager.onFinishRender]]
         */
        this.onBeginRender = new bentleyjs_core_1.BeEvent();
        /** Called at the end of each tick of the render loop, after all viewports have been updated.
         * The render loop is typically invoked by a requestAnimationFrame() callback. It will not be invoked if the ViewManager is tracking no viewports.
         * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.
         * @see [[ViewManager.onBeginRender]]
         */
        this.onFinishRender = new bentleyjs_core_1.BeEvent();
    }
    /** @internal */
    onInitialized() {
        this.addDecorator(IModelApp_1.IModelApp.accuSnap);
        this.addDecorator(IModelApp_1.IModelApp.tentativePoint);
        this.addDecorator(IModelApp_1.IModelApp.accuDraw);
        this.addDecorator(IModelApp_1.IModelApp.toolAdmin);
        this.cursor = "default";
    }
    /** @internal */
    onShutDown() {
        this._viewports.length = 0;
        this.decorators.length = 0;
        this._selectedView = undefined;
    }
    /** @internal */
    endDynamicsMode() {
        if (!this.inDynamicsMode)
            return;
        this.inDynamicsMode = false;
        const cursorVp = IModelApp_1.IModelApp.toolAdmin.cursorView;
        if (cursorVp)
            cursorVp.changeDynamics(undefined);
        for (const vp of this._viewports) {
            if (vp !== cursorVp)
                vp.changeDynamics(undefined);
        }
    }
    /** @internal */
    beginDynamicsMode() { this.inDynamicsMode = true; }
    /** @internal */
    get doesHostHaveFocus() { return document.hasFocus(); }
    /** Set the selected [[Viewport]] to undefined. */
    clearSelectedView() {
        const previousVp = this.selectedView;
        this._selectedView = undefined;
        this.notifySelectedViewportChanged(previousVp, undefined);
    }
    /** Sets the selected [[Viewport]]. */
    setSelectedView(vp) {
        if (undefined === vp)
            vp = this.getFirstOpenView();
        if (vp === this.selectedView) // already the selected view
            return bentleyjs_core_1.BentleyStatus.SUCCESS;
        if (undefined === vp) {
            this.clearSelectedView();
            return bentleyjs_core_1.BentleyStatus.ERROR;
        }
        const previousVp = this.selectedView;
        this._selectedView = vp;
        this.notifySelectedViewportChanged(previousVp, vp);
        if (undefined === previousVp)
            IModelApp_1.IModelApp.toolAdmin.startDefaultTool();
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    /** @internal */
    notifySelectedViewportChanged(previous, current) {
        IModelApp_1.IModelApp.toolAdmin.onSelectedViewportChanged(previous, current);
        this.onSelectedViewportChanged.emit({ previous, current });
    }
    /** The "selected view" is the default for certain operations.  */
    get selectedView() { return this._selectedView; }
    /** Get the first opened view. */
    getFirstOpenView() { return this._viewports.length > 0 ? this._viewports[0] : undefined; }
    /** Add a new Viewport to the list of opened views and create an EventController for it.
     * @param newVp the Viewport to add
     * @returns SUCCESS if vp was successfully added, ERROR if it was already present.
     * @note raises onViewOpen event with newVp.
     */
    addViewport(newVp) {
        if (this._viewports.includes(newVp)) // make sure its not already added
            return bentleyjs_core_1.BentleyStatus.ERROR;
        newVp.setEventController(new EventController_1.EventController(newVp)); // this will direct events to the viewport
        this._viewports.push(newVp);
        this.setSelectedView(newVp);
        // Start up the render loop if necessary.
        if (1 === this._viewports.length)
            IModelApp_1.IModelApp.toolAdmin.startEventLoop();
        this.onViewOpen.emit(newVp);
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    /** Remove a Viewport from the list of opened views, and optionally dispose of it.
     * Typically a Viewport is dropped when it is no longer of any use to the application, in which case it should also be
     * disposed of as it may hold significant GPU resources.
     * However in some cases a Viewport may be temporarily dropped to suspend rendering; and subsequently re-added to
     * resume rendering - for example, when the Viewport is temporarily hidden by other UI elements.
     * In the latter case it is up to the caller to ensure the Viewport is properly disposed of when it is no longer needed.
     * Attempting to invoke any function on a Viewport after it has been disposed is an error.
     * @param vp the Viewport to remove.
     * @param disposeOfViewport Whether or not to dispose of the Viewport. Defaults to true.
     * @return SUCCESS if vp was successfully removed, ERROR if it was not present.
     * @note raises onViewClose event with vp.
     */
    dropViewport(vp, disposeOfViewport = true) {
        const index = this._viewports.indexOf(vp);
        if (index === -1)
            return bentleyjs_core_1.BentleyStatus.ERROR;
        this.onViewClose.emit(vp);
        // make sure tools don't think the cursor is still in this viewport
        IModelApp_1.IModelApp.toolAdmin.onMouseLeave(vp); // tslint:disable-line:no-floating-promises
        vp.setEventController(undefined);
        this._viewports.splice(index, 1);
        if (this.selectedView === vp) // if removed viewport was selectedView, set it to undefined.
            this.setSelectedView(undefined);
        if (disposeOfViewport)
            vp.dispose();
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    /** Call the specified function on each [[Viewport]] registered with the ViewManager. */
    forEachViewport(func) { this._viewports.forEach((vp) => func(vp)); }
    /** Force each registered [[Viewport]] to regenerate its [[Decorations]] on the next frame. */
    invalidateDecorationsAllViews() { this.forEachViewport((vp) => vp.invalidateDecorations()); }
    /** @internal */
    onSelectionSetChanged(_iModel) { this.forEachViewport((vp) => vp.markSelectionSetDirty()); }
    /** @internal */
    invalidateViewportScenes() { this.forEachViewport((vp) => vp.sync.invalidateScene()); }
    /** @internal */
    validateViewportScenes() { this.forEachViewport((vp) => vp.sync.setValidScene()); }
    /** @internal */
    invalidateScenes() { this._invalidateScenes = true; }
    /** @internal */
    get sceneInvalidated() { return this._invalidateScenes; }
    /** @internal */
    onNewTilesReady() { this.invalidateScenes(); }
    /** Invoked by ToolAdmin event loop.
     * @internal
     */
    renderLoop() {
        if (0 === this._viewports.length)
            return;
        if (this._skipSceneCreation)
            this.validateViewportScenes();
        else if (this._invalidateScenes)
            this.invalidateViewportScenes();
        this._invalidateScenes = false;
        const cursorVp = IModelApp_1.IModelApp.toolAdmin.cursorView;
        this.onBeginRender.raiseEvent();
        if (undefined === cursorVp || cursorVp.renderFrame())
            for (const vp of this._viewports)
                if (vp !== cursorVp && !vp.renderFrame())
                    break;
        this.onFinishRender.raiseEvent();
    }
    /** Add a new [[Decorator]] to display decorations into the active views.
     * @param decorator The new decorator to add.
     * @throws Error if decorator is already active.
     * @returns a function that may be called to remove this decorator (in lieu of calling [[dropDecorator]].)
     * @see [[dropDecorator]]
     */
    addDecorator(decorator) {
        if (this.decorators.includes(decorator))
            throw new Error("decorator already registered");
        this.decorators.push(decorator);
        this.invalidateDecorationsAllViews();
        return () => { this.dropDecorator(decorator); };
    }
    /** Drop (remove) a [[Decorator]] so it is no longer active.
     * @param decorator The Decorator to drop.
     * @note Does nothing if decorator is not currently active.
     */
    dropDecorator(decorator) {
        const index = this.decorators.indexOf(decorator);
        if (index >= 0)
            this.decorators.splice(index, 1);
        this.invalidateDecorationsAllViews();
    }
    /** Get the tooltip for a pickable decoration.
     * @internal
     */
    async getDecorationToolTip(hit) {
        for (const decorator of this.decorators) {
            if (undefined !== decorator.testDecorationHit && undefined !== decorator.getDecorationToolTip && decorator.testDecorationHit(hit.sourceId))
                return decorator.getDecorationToolTip(hit);
        }
        return "";
    }
    /** Allow a pickable decoration to handle a button event that identified it for the SelectTool.
     * @internal
     */
    async onDecorationButtonEvent(hit, ev) {
        for (const decorator of IModelApp_1.IModelApp.viewManager.decorators) {
            if (undefined !== decorator.testDecorationHit && undefined !== decorator.onDecorationButtonEvent && decorator.testDecorationHit(hit.sourceId))
                return decorator.onDecorationButtonEvent(hit, ev);
        }
        return Tool_1.EventHandled.No;
    }
    /** Allow a pickable decoration to be snapped to by AccuSnap or TentativePoint.
     * @internal
     */
    getDecorationGeometry(hit) {
        for (const decorator of IModelApp_1.IModelApp.viewManager.decorators) {
            if (undefined !== decorator.testDecorationHit && undefined !== decorator.getDecorationGeometry && decorator.testDecorationHit(hit.sourceId))
                return decorator.getDecorationGeometry(hit);
        }
        return undefined;
    }
    get crossHairCursor() { return "url(cursors/crosshair.cur), crosshair"; }
    get dynamicsCursor() { return "url(cursors/dynamics.cur), move"; }
    get grabCursor() { return "url(cursors/openHand.cur), auto"; }
    get grabbingCursor() { return "url(cursors/closedHand.cur), auto"; }
    /** Change the cursor shown in all Viewports.
     * @param cursor The new cursor to display. If undefined, the default cursor is used.
     */
    setViewCursor(cursor = "default") {
        if (cursor === this.cursor)
            return;
        this.cursor = cursor;
        if (undefined !== this.selectedView) {
            this.selectedView.setCursor(cursor);
        }
    }
}
exports.ViewManager = ViewManager;


/***/ }),

/***/ "./lib/ViewState.js":
/*!**************************!*\
  !*** ./lib/ViewState.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const AuxCoordSys_1 = __webpack_require__(/*! ./AuxCoordSys */ "./lib/AuxCoordSys.js");
const CategorySelectorState_1 = __webpack_require__(/*! ./CategorySelectorState */ "./lib/CategorySelectorState.js");
const DisplayStyleState_1 = __webpack_require__(/*! ./DisplayStyleState */ "./lib/DisplayStyleState.js");
const EntityState_1 = __webpack_require__(/*! ./EntityState */ "./lib/EntityState.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const ModelSelectorState_1 = __webpack_require__(/*! ./ModelSelectorState */ "./lib/ModelSelectorState.js");
const ModelState_1 = __webpack_require__(/*! ./ModelState */ "./lib/ModelState.js");
const NotificationManager_1 = __webpack_require__(/*! ./NotificationManager */ "./lib/NotificationManager.js");
const GraphicBuilder_1 = __webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js");
const StandardView_1 = __webpack_require__(/*! ./StandardView */ "./lib/StandardView.js");
const TileTree_1 = __webpack_require__(/*! ./tile/TileTree */ "./lib/tile/TileTree.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/Viewport.js");
const SpatialClassification_1 = __webpack_require__(/*! ./SpatialClassification */ "./lib/SpatialClassification.js");
const TiledGraphicsProvider_1 = __webpack_require__(/*! ./TiledGraphicsProvider */ "./lib/TiledGraphicsProvider.js");
/** Describes the orientation of the grid displayed within a [[Viewport]].
 * @public
 */
var GridOrientationType;
(function (GridOrientationType) {
    /** Oriented with the view. */
    GridOrientationType[GridOrientationType["View"] = 0] = "View";
    /** Top */
    GridOrientationType[GridOrientationType["WorldXY"] = 1] = "WorldXY";
    /** Right */
    GridOrientationType[GridOrientationType["WorldYZ"] = 2] = "WorldYZ";
    /** Front */
    GridOrientationType[GridOrientationType["WorldXZ"] = 3] = "WorldXZ";
    /** Oriented by the [[AuxCoordSystem]] */
    GridOrientationType[GridOrientationType["AuxCoord"] = 4] = "AuxCoord";
})(GridOrientationType = exports.GridOrientationType || (exports.GridOrientationType = {}));
/** Describes the result of a viewing operation such as those exposed by [[ViewState]] and [[Viewport]].
 * @public
 */
var ViewStatus;
(function (ViewStatus) {
    ViewStatus[ViewStatus["Success"] = 0] = "Success";
    ViewStatus[ViewStatus["ViewNotInitialized"] = 1] = "ViewNotInitialized";
    ViewStatus[ViewStatus["AlreadyAttached"] = 2] = "AlreadyAttached";
    ViewStatus[ViewStatus["NotAttached"] = 3] = "NotAttached";
    ViewStatus[ViewStatus["DrawFailure"] = 4] = "DrawFailure";
    ViewStatus[ViewStatus["NotResized"] = 5] = "NotResized";
    ViewStatus[ViewStatus["ModelNotFound"] = 6] = "ModelNotFound";
    ViewStatus[ViewStatus["InvalidWindow"] = 7] = "InvalidWindow";
    ViewStatus[ViewStatus["MinWindow"] = 8] = "MinWindow";
    ViewStatus[ViewStatus["MaxWindow"] = 9] = "MaxWindow";
    ViewStatus[ViewStatus["MaxZoom"] = 10] = "MaxZoom";
    ViewStatus[ViewStatus["MaxDisplayDepth"] = 11] = "MaxDisplayDepth";
    ViewStatus[ViewStatus["InvalidUpVector"] = 12] = "InvalidUpVector";
    ViewStatus[ViewStatus["InvalidTargetPoint"] = 13] = "InvalidTargetPoint";
    ViewStatus[ViewStatus["InvalidLens"] = 14] = "InvalidLens";
    ViewStatus[ViewStatus["InvalidViewport"] = 15] = "InvalidViewport";
})(ViewStatus = exports.ViewStatus || (exports.ViewStatus = {}));
/** Margins for white space to be left around view volumes for [[ViewState.lookAtVolume]].
 * Values mean "fraction of view size" and must be between 0 and .25.
 * @public
 */
class MarginPercent {
    constructor(left, top, right, bottom) {
        this.left = left;
        this.top = top;
        this.right = right;
        this.bottom = bottom;
        const limitMargin = (val) => geometry_core_1.Geometry.clamp(val, 0.0, 0.25);
        this.left = limitMargin(left);
        this.top = limitMargin(top);
        this.right = limitMargin(right);
        this.bottom = limitMargin(bottom);
    }
}
exports.MarginPercent = MarginPercent;
/** @internal */
class ViewStateUndo {
}
exports.ViewStateUndo = ViewStateUndo;
/** @internal */
class ViewState3dUndo extends ViewStateUndo {
    constructor(view) {
        super();
        this.cameraOn = view.isCameraOn;
        this.origin = view.origin.clone();
        this.extents = view.extents.clone();
        this.rotation = view.rotation.clone();
        this.camera = view.camera.clone();
    }
    equalState(view) {
        return this.cameraOn === view.isCameraOn &&
            this.origin.isAlmostEqual(view.origin) &&
            this.extents.isAlmostEqual(view.extents) &&
            this.rotation.isAlmostEqual(view.rotation) &&
            (!this.cameraOn || this.camera.equals(view.camera)); // ###TODO: should this be less precise equality?
    }
}
/** @internal */
class ViewState2dUndo extends ViewStateUndo {
    constructor(view) {
        super();
        this.origin = view.origin.clone();
        this.delta = view.delta.clone();
        this.angle = view.angle.clone();
    }
    equalState(view) {
        return this.origin.isAlmostEqual(view.origin) &&
            this.delta.isAlmostEqual(view.delta) &&
            this.angle.isAlmostEqualNoPeriodShift(view.angle);
    }
}
/** The front-end state of a [[ViewDefinition]] element.
 * A ViewState is typically associated with a [[Viewport]] to display the contents of the view on the screen.
 * * @see [Views]($docs/learning/frontend/Views.md)
 * @public
 */
class ViewState extends EntityState_1.ElementState {
    /** @internal */
    static get className() { return "ViewDefinition"; }
    /** @internal */
    constructor(props, iModel, categoryOrClone, displayStyle) {
        super(props, iModel);
        this.description = props.description;
        this.isPrivate = props.isPrivate;
        this.displayStyle = displayStyle;
        this.categorySelector = categoryOrClone;
        if (!(categoryOrClone instanceof ViewState)) // is this from the clone method?
            return; // not from clone
        // from clone, 3rd argument is source ViewState
        const source = categoryOrClone;
        this.categorySelector = source.categorySelector.clone();
        this.displayStyle = source.displayStyle.clone();
        this._extentLimits = source._extentLimits;
        this._auxCoordSystem = source._auxCoordSystem;
        this._clipVector = source._clipVector;
    }
    /** Create a new ViewState object from a set of properties. Generally this is called internally by [[IModelConnection.Views.load]] after the properties
     * have been read from an iModel. But, it can also be used to create a ViewState in memory, from scratch or from properties stored elsewhere.
     */
    static createFromProps(_props, _iModel) { return undefined; }
    /** Get the ViewFlags from the [[DisplayStyleState]] of this ViewState.
     * @note Do not modify this object directly. Instead, use the setter as follows:
     *
     *  ```ts
     *  const flags = viewState.viewFlags.clone();
     *  flags.renderMode = RenderMode.SmoothShade; // or whatever alterations are desired
     *  viewState.viewFlags = flags;
     *  ```ts
     */
    get viewFlags() { return this.displayStyle.viewFlags; }
    /** Get the AnalysisDisplayProperties from the displayStyle of this ViewState. */
    get analysisStyle() { return this.displayStyle.analysisStyle; }
    /** Get the RenderSchedule.Script from the displayStyle of this viewState */
    get scheduleScript() { return this.displayStyle.scheduleScript; }
    /** Determine whether this ViewState exactly matches another. */
    equals(other) { return super.equals(other) && this.categorySelector.equals(other.categorySelector) && this.displayStyle.equals(other.displayStyle); }
    toJSON() {
        const json = super.toJSON();
        json.categorySelectorId = this.categorySelector.id;
        json.displayStyleId = this.displayStyle.id;
        json.isPrivate = this.isPrivate;
        json.description = this.description;
        return json;
    }
    /** Asynchronously load any required data for this ViewState from the backend.
     * @note callers should await the Promise returned by this method before using this ViewState.
     * @see [Views]($docs/learning/frontend/Views.md)
     */
    async load() {
        this._auxCoordSystem = undefined;
        const acsId = this.getAuxiliaryCoordinateSystemId();
        if (bentleyjs_core_1.Id64.isValid(acsId)) {
            const props = await this.iModel.elements.getProps(acsId);
            this._auxCoordSystem = AuxCoordSys_1.AuxCoordSystemState.fromProps(props[0], this.iModel);
        }
        const subcategories = this.iModel.subcategories.load(this.categorySelector.categories);
        if (undefined !== subcategories)
            await subcategories.promise;
        return Promise.resolve();
    }
    /** @internal */
    get areAllTileTreesLoaded() {
        let allLoaded = true;
        this.forEachTileTreeModel((model) => {
            // Loaded or NotFound qualify as "loaded" - either the load succeeded or failed.
            if (model.loadStatus < TileTree_1.TileTree.LoadStatus.Loaded)
                allLoaded = false;
        });
        return allLoaded;
    }
    /** Get the name of the [[ViewDefinition]] from which this ViewState originated. */
    get name() { return this.code.getValue(); }
    /** Get this view's background color. */
    get backgroundColor() { return this.displayStyle.backgroundColor; }
    /** Query the symbology overrides applied to geometry belonging to a specific subcategory when rendered using this ViewState.
     * @param id The Id of the subcategory.
     * @return The symbology overrides applied to all geometry belonging to the specified subcategory, or undefined if no such overrides exist.
     */
    getSubCategoryOverride(id) {
        return this.displayStyle.getSubCategoryOverride(id);
    }
    /** @internal */
    isSubCategoryVisible(id) {
        const app = this.iModel.subcategories.getSubCategoryAppearance(id);
        if (undefined === app)
            return false;
        const ovr = this.getSubCategoryOverride(id);
        if (undefined === ovr || undefined === ovr.invisible)
            return !app.invisible;
        else
            return !ovr.invisible;
    }
    /** Returns true if this ViewState is-a [[ViewState3d]] */
    is3d() { return this instanceof ViewState3d; }
    /** Returns true if this ViewState is-a [[ViewState2d]] */
    is2d() { return this instanceof ViewState2d; }
    /** Returns true if this ViewState is-a [[SpatialViewState]] */
    isSpatialView() { return this instanceof SpatialViewState; }
    /** Execute a function on each viewed model
     * @alpha
     */
    forEachTileTreeModel(func) { this.forEachModel((model) => func(model)); }
    /** @internal */
    createScene(context) {
        this.forEachTileTreeModel((model) => this.addModelToScene(model, context));
    }
    /** @internal */
    createBackgroundMap(context) {
        const backgroundMapProvider = this.displayStyle.backgroundMap;
        if (undefined !== backgroundMapProvider)
            this.createGraphicsFromProvider(context, backgroundMapProvider, TiledGraphicsProvider_1.TiledGraphicsProvider.Type.BackgroundMap);
    }
    /** @internal */
    createGraphicsFromProvider(context, provider, type) {
        const tree = provider.getTileTree(context.viewport);
        if (tree !== undefined) {
            context.tiledGraphicsProviderType = type;
            context.extendedFrustumPlane = tree.plane;
            tree.tileTree.drawScene(context);
            context.extendedFrustumPlane = undefined;
            context.tiledGraphicsProviderType = undefined;
        }
    }
    /** @internal */
    createProviderGraphics(context) {
        for (let type = TiledGraphicsProvider_1.TiledGraphicsProvider.Type.Geometry; type <= TiledGraphicsProvider_1.TiledGraphicsProvider.Type.Overlay; type++) {
            const providers = context.viewport.getTiledGraphicsProviders(type);
            if (providers !== undefined) {
                for (const provider of providers)
                    this.createGraphicsFromProvider(context, provider, type);
            }
        }
    }
    /** @internal */
    createClassification(context) {
        this.forEachTileTreeModel((model) => SpatialClassification_1.SpatialClassification.addModelClassifierToScene(model, context));
    }
    /** @internal */
    createSolarShadowMap(_context) { }
    /** Add view-specific decorations. The base implementation draws the grid. Subclasses must invoke super.decorate()
     * @internal
     */
    decorate(context) {
        this.drawGrid(context);
        if (undefined !== this.displayStyle.backgroundMapPlane)
            this.displayStyle.backgroundMap.decorate(context);
    }
    /** @internal */
    static getStandardViewMatrix(id) { return StandardView_1.StandardView.getStandardRotation(id); }
    /** Orient this view to one of the [[StandardView]] rotations. */
    setStandardRotation(id) { this.setRotation(ViewState.getStandardViewMatrix(id)); }
    /** Get the target point of the view. If there is no camera, center is returned. */
    getTargetPoint(result) { return this.getCenter(result); }
    /**  Get the point at the geometric center of the view. */
    getCenter(result) {
        const delta = this.getRotation().transpose().multiplyVector(this.getExtents());
        return this.getOrigin().plusScaled(delta, 0.5, result);
    }
    /** @internal */
    drawGrid(context) {
        const vp = context.viewport;
        if (!vp.isGridOn)
            return;
        const orientation = this.getGridOrientation();
        if (GridOrientationType.AuxCoord < orientation) {
            return; // NEEDSWORK...
        }
        if (GridOrientationType.AuxCoord === orientation) {
            this.auxiliaryCoordinateSystem.drawGrid(context);
            return;
        }
        const isoGrid = false;
        const gridsPerRef = this.getGridsPerRef();
        const spacing = geometry_core_1.Point2d.createFrom(this.getGridSpacing());
        const origin = geometry_core_1.Point3d.create();
        const matrix = geometry_core_1.Matrix3d.createIdentity();
        const fixedRepsAuto = geometry_core_1.Point2d.create();
        this.getGridSettings(vp, origin, matrix, orientation);
        context.drawStandardGrid(origin, matrix, spacing, gridsPerRef, isoGrid, orientation !== GridOrientationType.View ? fixedRepsAuto : undefined);
    }
    /** @internal */
    computeWorldToNpc(viewRot, inOrigin, delta, enforceFrontToBackRatio = true) {
        if (viewRot === undefined)
            viewRot = this.getRotation();
        const xVector = viewRot.rowX();
        const yVector = viewRot.rowY();
        const zVector = viewRot.rowZ();
        if (delta === undefined)
            delta = this.getExtents();
        if (inOrigin === undefined)
            inOrigin = this.getOrigin();
        let frustFraction = 1.0;
        let xExtent;
        let yExtent;
        let zExtent;
        let origin;
        // Compute root vectors along edges of view frustum.
        if (this.is3d() && this.isCameraOn) {
            const camera = this.camera;
            const eyeToOrigin = geometry_core_1.Vector3d.createStartEnd(camera.eye, inOrigin); // vector from origin on backplane to eye
            viewRot.multiplyVectorInPlace(eyeToOrigin); // align with view coordinates.
            const focusDistance = camera.focusDist;
            let zDelta = delta.z;
            let zBack = eyeToOrigin.z; // Distance from eye to backplane.
            let zFront = zBack + zDelta; // Distance from eye to frontplane.
            if (enforceFrontToBackRatio && zFront / zBack < Viewport_1.Viewport.nearScale24) {
                // In this case we are running up against the zBuffer resolution limitation (currently 24 bits).
                // Set back clipping plane at 10 kilometer which gives us a front clipping plane about 3 meters.
                // Decreasing the maximumBackClip (MicroStation uses 1 kilometer) will reduce the minimum front
                // clip, but also reduce the back clip (so far geometry may not be visible).
                const maximumBackClip = 10 * geometry_core_1.Constant.oneKilometer;
                if (-zBack > maximumBackClip) {
                    zBack = -maximumBackClip;
                    eyeToOrigin.z = zBack;
                }
                zFront = zBack * Viewport_1.Viewport.nearScale24;
                zDelta = zFront - eyeToOrigin.z;
            }
            // z out back of eye ===> origin z coordinates are negative.  (Back plane more negative than front plane)
            const backFraction = -zBack / focusDistance; // Perspective fraction at back clip plane.
            const frontFraction = -zFront / focusDistance; // Perspective fraction at front clip plane.
            frustFraction = frontFraction / backFraction;
            // delta.x,delta.y are view rectangle sizes at focus distance.  Scale to back plane:
            xExtent = xVector.scale(delta.x * backFraction); // xExtent at back == delta.x * backFraction.
            yExtent = yVector.scale(delta.y * backFraction); // yExtent at back == delta.y * backFraction.
            // Calculate the zExtent in the View coordinate system.
            zExtent = new geometry_core_1.Vector3d(eyeToOrigin.x * (frontFraction - backFraction), eyeToOrigin.y * (frontFraction - backFraction), zDelta);
            viewRot.multiplyTransposeVectorInPlace(zExtent); // rotate back to root coordinates.
            origin = new geometry_core_1.Point3d(eyeToOrigin.x * backFraction, // Calculate origin in eye coordinates
            eyeToOrigin.y * backFraction, eyeToOrigin.z);
            viewRot.multiplyTransposeVectorInPlace(origin); // Rotate back to root coordinates
            origin.plus(camera.eye, origin); // Add the eye point.
        }
        else {
            origin = inOrigin;
            xExtent = xVector.scale(delta.x);
            yExtent = yVector.scale(delta.y);
            zExtent = zVector.scale(delta.z);
        }
        // calculate the root-to-npc mapping (using expanded frustum)
        return { map: geometry_core_1.Map4d.createVectorFrustum(origin, xExtent, yExtent, zExtent, frustFraction), frustFraction };
    }
    /** Calculate the world coordinate Frustum from the parameters of this ViewState.
     * @param result Optional Frustum to hold result. If undefined a new Frustum is created.
     * @returns The 8-point Frustum with the corners of this ViewState, or undefined if the parameters are invalid.
     */
    calculateFrustum(result) {
        const val = this.computeWorldToNpc();
        if (undefined === val.map)
            return undefined;
        const box = result ? result.initNpc() : new imodeljs_common_1.Frustum();
        val.map.transform1.multiplyPoint3dArrayQuietNormalize(box.points);
        return box;
    }
    /** Initialize the origin, extents, and rotation from an existing Frustum
     * This function is commonly used in the implementation of [[ViewTool]]s as follows:
     *  1. Obtain the ViewState's initial frustum.
     *  2. Modify the frustum based on user input.
     *  3. Update the ViewState to match the modified frustum.
     * @param frustum the input Frustum.
     * @return Success if the frustum was successfully updated, or an appropriate error code.
     */
    setupFromFrustum(inFrustum) {
        const frustum = inFrustum.clone(); // make sure we don't modify input frustum
        frustum.fixPointOrder();
        const frustPts = frustum.points;
        const viewOrg = frustPts[imodeljs_common_1.Npc.LeftBottomRear];
        // frustumX, frustumY, frustumZ are vectors along edges of the frustum. They are NOT unit vectors.
        // X and Y should be perpendicular, and Z should be right handed.
        const frustumX = geometry_core_1.Vector3d.createFrom(frustPts[imodeljs_common_1.Npc.RightBottomRear].minus(viewOrg));
        const frustumY = geometry_core_1.Vector3d.createFrom(frustPts[imodeljs_common_1.Npc.LeftTopRear].minus(viewOrg));
        const frustumZ = geometry_core_1.Vector3d.createFrom(frustPts[imodeljs_common_1.Npc.LeftBottomFront].minus(viewOrg));
        const frustMatrix = geometry_core_1.Matrix3d.createRigidFromColumns(frustumX, frustumY, geometry_core_1.AxisOrder.XYZ);
        if (!frustMatrix)
            return ViewStatus.InvalidWindow;
        // if we're close to one of the standard views, adjust to it to remove any "fuzz"
        StandardView_1.StandardView.adjustToStandardRotation(frustMatrix);
        const xDir = frustMatrix.getColumn(0);
        const yDir = frustMatrix.getColumn(1);
        const zDir = frustMatrix.getColumn(2);
        // set up view Rotation matrix as rows of frustum matrix.
        const viewRot = frustMatrix.inverse();
        if (!viewRot)
            return ViewStatus.InvalidWindow;
        // Left handed frustum?
        const zSize = zDir.dotProduct(frustumZ);
        if (zSize < 0.0)
            return ViewStatus.InvalidWindow;
        const viewDiagRoot = new geometry_core_1.Vector3d();
        viewDiagRoot.plus2Scaled(xDir, xDir.dotProduct(frustumX), yDir, yDir.dotProduct(frustumY), viewDiagRoot); // vectors on the back plane
        viewDiagRoot.plusScaled(zDir, zSize, viewDiagRoot); // add in z vector perpendicular to x,y
        // use center of frustum and view diagonal for origin. Original frustum may not have been orthogonal
        frustum.getCenter().plusScaled(viewDiagRoot, -0.5, viewOrg);
        // delta is in view coordinates
        const viewDelta = viewRot.multiplyVector(viewDiagRoot);
        this.validateViewDelta(viewDelta, false);
        this.setOrigin(viewOrg);
        this.setExtents(viewDelta);
        this.setRotation(viewRot);
        return ViewStatus.Success;
    }
    /** Get or set the largest and smallest values allowed for the extents for this ViewState
     * The default limits vary based on the type of view:
     *   - Spatial view extents cannot exceed the diameter of the earth.
     *   - Drawing view extents cannot exceed twice the longest axis of the drawing model's range.
     *   - Sheet view extents cannot exceed ten times the paper size of the sheet.
     * Explicitly setting the extent limits overrides the default limits.
     * @see [[resetExtentLimits]] to restore the default limits.
     */
    get extentLimits() { return undefined !== this._extentLimits ? this._extentLimits : this.defaultExtentLimits; }
    set extentLimits(limits) { this._extentLimits = limits; }
    /** Resets the largest and smallest values allowed for the extents of this ViewState to their default values.
     * @see [[extentLimits]].
     */
    resetExtentLimits() { this._extentLimits = undefined; }
    setDisplayStyle(style) { this.displayStyle = style; }
    getDetails() { if (!this.jsonProperties.viewDetails)
        this.jsonProperties.viewDetails = new Object(); return this.jsonProperties.viewDetails; }
    /** @internal */
    adjustAspectRatio(windowAspect) {
        const extents = this.getExtents();
        const viewAspect = extents.x / extents.y;
        windowAspect *= this.getAspectRatioSkew();
        if (Math.abs(1.0 - (viewAspect / windowAspect)) < 1.0e-9)
            return;
        const oldDelta = extents.clone();
        if (viewAspect > windowAspect)
            extents.y = extents.x / windowAspect;
        else
            extents.x = extents.y * windowAspect;
        let origin = this.getOrigin();
        const trans = geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.createZero(), this.getRotation());
        const newOrigin = trans.multiplyPoint3d(origin);
        newOrigin.x += ((oldDelta.x - extents.x) / 2.0);
        newOrigin.y += ((oldDelta.y - extents.y) / 2.0);
        origin = trans.inverse().multiplyPoint3d(newOrigin);
        this.setOrigin(origin);
        this.setExtents(extents);
    }
    /** @internal */
    showFrustumErrorMessage(status) {
        let key;
        switch (status) {
            case ViewStatus.InvalidWindow:
                key = "InvalidWindow";
                break;
            case ViewStatus.MaxWindow:
                key = "MaxWindow";
                break;
            case ViewStatus.MinWindow:
                key = "MinWindow";
                break;
            case ViewStatus.MaxZoom:
                key = "MaxZoom";
                break;
            default:
                return;
        }
        IModelApp_1.IModelApp.notifications.outputMessage(new NotificationManager_1.NotifyMessageDetails(NotificationManager_1.OutputMessagePriority.Error, IModelApp_1.IModelApp.i18n.translate("Viewing." + key)));
    }
    /** @internal */
    validateViewDelta(delta, messageNeeded) {
        const limit = this.extentLimits;
        let error = ViewStatus.Success;
        const limitWindowSize = (v, ignoreError) => {
            if (v < limit.min) {
                v = limit.min;
                if (!ignoreError)
                    error = ViewStatus.MinWindow;
            }
            else if (v > limit.max) {
                v = limit.max;
                if (!ignoreError)
                    error = ViewStatus.MaxWindow;
            }
            return v;
        };
        delta.x = limitWindowSize(delta.x, false);
        delta.y = limitWindowSize(delta.y, false);
        delta.z = limitWindowSize(delta.z, true); // We ignore z error messages for the sake of 2D views
        if (messageNeeded && error !== ViewStatus.Success)
            this.showFrustumErrorMessage(error);
        return error;
    }
    /** Returns the view detail associated with the specified name, or undefined if none such exists.
     * @internal
     */
    peekDetail(name) { return this.getDetails()[name]; }
    /** Get the current value of a view detail. If not present, returns an empty object.
     * @internal
     */
    getDetail(name) { const v = this.getDetails()[name]; return v ? v : {}; }
    /** Change the value of a view detail.
     * @internal
     */
    setDetail(name, value) { this.getDetails()[name] = value; }
    /** Remove a view detail.
     * @internal
     */
    removeDetail(name) { delete this.getDetails()[name]; }
    /** Set the CategorySelector for this view. */
    setCategorySelector(categories) { this.categorySelector = categories; }
    /** get the auxiliary coordinate system state object for this ViewState. */
    get auxiliaryCoordinateSystem() {
        if (!this._auxCoordSystem)
            this._auxCoordSystem = this.createAuxCoordSystem("");
        return this._auxCoordSystem;
    }
    /** Get the Id of the auxiliary coordinate system for this ViewState */
    getAuxiliaryCoordinateSystemId() { return bentleyjs_core_1.Id64.fromJSON(this.getDetail("acs")); }
    /** Set or clear the AuxiliaryCoordinateSystem for this view.
     * @param acs the new AuxiliaryCoordinateSystem for this view. If undefined, no AuxiliaryCoordinateSystem will be used.
     */
    setAuxiliaryCoordinateSystem(acs) {
        this._auxCoordSystem = acs;
        if (acs)
            this.setDetail("acs", acs.id);
        else
            this.removeDetail("acs");
    }
    /** Determine whether the specified Category is displayed in this view */
    viewsCategory(id) { return this.categorySelector.isCategoryViewed(id); }
    /**  Get the aspect ratio (width/height) of this view */
    getAspectRatio() { const extents = this.getExtents(); return extents.x / extents.y; }
    /** Get the aspect ratio skew (x/y, usually 1.0) that is used to exaggerate one axis of the view. */
    getAspectRatioSkew() { return bentleyjs_core_1.JsonUtils.asDouble(this.getDetail("aspectSkew"), 1.0); }
    /** Set the aspect ratio skew (x/y) for this view. To remove aspect ratio skew, pass 1.0 for val. */
    setAspectRatioSkew(val) {
        if (!val || val === 1.0) {
            this.removeDetail("aspectSkew");
        }
        else {
            this.setDetail("aspectSkew", val);
        }
    }
    /** Get the unit vector that points in the view X (left-to-right) direction.
     * @param result optional Vector3d to be used for output. If undefined, a new object is created.
     */
    getXVector(result) { return this.getRotation().getRow(0, result); }
    /** Get the unit vector that points in the view Y (bottom-to-top) direction.
     * @param result optional Vector3d to be used for output. If undefined, a new object is created.
     */
    getYVector(result) { return this.getRotation().getRow(1, result); }
    /** Get the unit vector that points in the view Z (front-to-back) direction.
     * @param result optional Vector3d to be used for output. If undefined, a new object is created.
     */
    getZVector(result) { return this.getRotation().getRow(2, result); }
    /** Set or clear the clipping volume for this view.
     * @param clip the new clipping volume. If undefined, clipping is removed from view.
     * @note The ViewState takes ownership of the supplied ClipVector - it should not be modified after passing it to this function.
     */
    setViewClip(clip) {
        this._clipVector = clip;
        if (clip && clip.isValid)
            this.setDetail("clip", clip.toJSON());
        else
            this.removeDetail("clip");
    }
    /** Get the clipping volume for this view, if defined
     * @note Do *not* modify the returned ClipVector. If you wish to change the ClipVector, clone the returned ClipVector, modify it as desired, and pass the clone to [[setViewClip]].
     */
    getViewClip() {
        if (undefined === this._clipVector) {
            const clip = this.peekDetail("clip");
            this._clipVector = (undefined !== clip ? geometry_core_1.ClipVector.fromJSON(clip) : geometry_core_1.ClipVector.createEmpty());
        }
        return this._clipVector.isValid ? this._clipVector : undefined;
    }
    /** Set the grid settings for this view */
    setGridSettings(orientation, spacing, gridsPerRef) {
        switch (orientation) {
            case GridOrientationType.WorldYZ:
            case GridOrientationType.WorldXZ:
                if (!this.is3d())
                    return;
                break;
        }
        const details = this.getDetails();
        bentleyjs_core_1.JsonUtils.setOrRemoveNumber(details, "gridOrient", orientation, GridOrientationType.WorldXY);
        bentleyjs_core_1.JsonUtils.setOrRemoveNumber(details, "gridPerRef", gridsPerRef, 10);
        bentleyjs_core_1.JsonUtils.setOrRemoveNumber(details, "gridSpaceX", spacing.x, 1.0);
        bentleyjs_core_1.JsonUtils.setOrRemoveNumber(details, "gridSpaceY", spacing.y, spacing.x);
    }
    /** Populate the given origin and rotation with information from the grid settings from the grid orientation. */
    getGridSettings(vp, origin, rMatrix, orientation) {
        // start with global origin (for spatial views) and identity matrix
        rMatrix.setIdentity();
        origin.setFrom(vp.view.isSpatialView() ? vp.view.iModel.globalOrigin : geometry_core_1.Point3d.create());
        switch (orientation) {
            case GridOrientationType.View: {
                const centerWorld = geometry_core_1.Point3d.create(0.5, 0.5, 0.5);
                vp.npcToWorld(centerWorld, centerWorld);
                rMatrix.setFrom(vp.rotation);
                rMatrix.multiplyXYZtoXYZ(origin, origin);
                origin.z = centerWorld.z;
                rMatrix.multiplyTransposeVectorInPlace(origin);
                break;
            }
            case GridOrientationType.WorldXY:
                break;
            case GridOrientationType.WorldYZ: {
                const rowX = rMatrix.getRow(0);
                const rowY = rMatrix.getRow(1);
                const rowZ = rMatrix.getRow(2);
                rMatrix.setRow(0, rowY);
                rMatrix.setRow(1, rowZ);
                rMatrix.setRow(2, rowX);
                break;
            }
            case GridOrientationType.WorldXZ: {
                const rowX = rMatrix.getRow(0);
                const rowY = rMatrix.getRow(1);
                const rowZ = rMatrix.getRow(2);
                rMatrix.setRow(0, rowX);
                rMatrix.setRow(1, rowZ);
                rMatrix.setRow(2, rowY);
                break;
            }
        }
    }
    /** Get the grid settings for this view */
    getGridOrientation() { return bentleyjs_core_1.JsonUtils.asInt(this.getDetail("gridOrient"), GridOrientationType.WorldXY); }
    getGridsPerRef() { return bentleyjs_core_1.JsonUtils.asInt(this.getDetail("gridPerRef"), 10); }
    getGridSpacing() {
        const x = bentleyjs_core_1.JsonUtils.asInt(this.getDetail("gridSpaceX"), 1.0);
        return { x, y: bentleyjs_core_1.JsonUtils.asInt(this.getDetail("gridSpaceY"), x) };
    }
    /** Change the volume that this view displays, keeping its current rotation.
     * @param volume The new volume, in world-coordinates, for the view. The resulting view will show all of worldVolume, by fitting a
     * view-axis-aligned bounding box around it. For views that are not aligned with the world coordinate system, this will sometimes
     * result in a much larger volume than worldVolume.
     * @param aspect The X/Y aspect ratio of the view into which the result will be displayed. If the aspect ratio of the volume does not
     * match aspect, the shorter axis is lengthened and the volume is centered. If aspect is undefined, no adjustment is made.
     * @param margin The amount of "white space" to leave around the view volume (which essentially increases the volume
     * of space shown in the view.) If undefined, no additional white space is added.
     * @note for 2d views, only the X and Y values of volume are used.
     */
    lookAtVolume(volume, aspect, margin) {
        const rangeBox = imodeljs_common_1.Frustum.fromRange(volume).points;
        this.getRotation().multiplyVectorArrayInPlace(rangeBox);
        return this.lookAtViewAlignedVolume(geometry_core_1.Range3d.createArray(rangeBox), aspect, margin);
    }
    /** Look at a volume of space defined by a range in view local coordinates, keeping its current rotation.
     * @param volume The new volume, in view-coordinates, for the view. The resulting view will show all of volume.
     * @param aspect The X/Y aspect ratio of the view into which the result will be displayed. If the aspect ratio of the volume does not
     * match aspect, the shorter axis is lengthened and the volume is centered. If aspect is undefined, no adjustment is made.
     * @param margin The amount of "white space" to leave around the view volume (which essentially increases the volume
     * of space shown in the view.) If undefined, no additional white space is added.
     * @see lookAtVolume
     */
    lookAtViewAlignedVolume(volume, aspect, margin) {
        if (volume.isNull) // make sure volume is valid
            return;
        const viewRot = this.getRotation();
        const newOrigin = volume.low.clone();
        let newDelta = geometry_core_1.Vector3d.createStartEnd(volume.low, volume.high);
        const minimumDepth = geometry_core_1.Constant.oneMillimeter;
        if (newDelta.z < minimumDepth) {
            newOrigin.z -= (minimumDepth - newDelta.z) / 2.0;
            newDelta.z = minimumDepth;
        }
        let origNewDelta = newDelta.clone();
        const isCameraOn = this.is3d() && this.isCameraOn;
        if (isCameraOn) {
            // If the camera is on, the only way to guarantee we can see the entire volume is to set delta at the front plane, not focus plane.
            // That generally causes the view to be too large (objects in it are too small), since we can't tell whether the objects are at
            // the front or back of the view. For this reason, don't attempt to add any "margin" to camera views.
        }
        else if (margin) {
            // compute how much space we'll need for both of X and Y margins in root coordinates
            const wPercent = margin.left + margin.right;
            const hPercent = margin.top + margin.bottom;
            const marginHorizontal = wPercent / (1 - wPercent) * newDelta.x;
            const marginVert = hPercent / (1 - hPercent) * newDelta.y;
            // compute left and bottom margins in root coordinates
            const marginLeft = margin.left / (1 - wPercent) * newDelta.x;
            const marginBottom = margin.bottom / (1 - hPercent) * newDelta.y;
            // add the margins to the range
            newOrigin.x -= marginLeft;
            newOrigin.y -= marginBottom;
            newDelta.x += marginHorizontal;
            newDelta.y += marginVert;
            // don't fix the origin due to changes in delta here
            origNewDelta = newDelta.clone();
        }
        else {
            newDelta.scale(1.04, newDelta); // default "dilation"
        }
        if (isCameraOn) {
            // make sure that the zDelta is large enough so that entire model will be visible from any rotation
            const diag = newDelta.magnitudeXY();
            if (diag > newDelta.z)
                newDelta.z = diag;
        }
        this.validateViewDelta(newDelta, true);
        this.setExtents(newDelta);
        if (aspect)
            this.adjustAspectRatio(aspect);
        newDelta = this.getExtents();
        newOrigin.x -= (newDelta.x - origNewDelta.x) / 2.0;
        newOrigin.y -= (newDelta.y - origNewDelta.y) / 2.0;
        newOrigin.z -= (newDelta.z - origNewDelta.z) / 2.0;
        viewRot.multiplyTransposeVectorInPlace(newOrigin);
        this.setOrigin(newOrigin);
        if (!this.is3d())
            return;
        const cameraDef = this.camera;
        cameraDef.validateLens();
        // move the camera back so the entire x,y range is visible at front plane
        const frontDist = Math.max(newDelta.x, newDelta.y) / (2.0 * Math.tan(cameraDef.getLensAngle().radians / 2.0));
        const backDist = frontDist + newDelta.z;
        cameraDef.setFocusDistance(frontDist); // do this even if the camera isn't currently on.
        this.centerEyePoint(backDist); // do this even if the camera isn't currently on.
        this.verifyFocusPlane(); // changes delta/origin
    }
    addModelToScene(model, context) {
        const animId = undefined !== this.scheduleScript ? this.scheduleScript.getModelAnimationId(model.treeModelId) : undefined;
        model.loadTree(context.viewFlags.edgesRequired(), animId);
        if (undefined !== model.tileTree)
            model.tileTree.drawScene(context);
    }
    /** Set the rotation of this ViewState to the supplied rotation, by rotating it about a point.
     * @param rotation The new rotation matrix for this ViewState.
     * @param point The point to rotate about. If undefined, use the [[getTargetPoint]].
     */
    setRotationAboutPoint(rotation, point) {
        if (undefined === point)
            point = this.getTargetPoint();
        const inverse = rotation.clone().inverse();
        if (undefined === inverse)
            return;
        const targetMatrix = inverse.multiplyMatrixMatrix(this.getRotation());
        const worldTransform = geometry_core_1.Transform.createFixedPointAndMatrix(point, targetMatrix);
        const frustum = this.calculateFrustum();
        if (undefined !== frustum) {
            frustum.multiply(worldTransform);
            this.setupFromFrustum(frustum);
        }
    }
}
exports.ViewState = ViewState;
/** Defines the state of a view of 3d models.
 * @see [ViewState Parameters]($docs/learning/frontend/views#viewstate-parameters)
 * @public
 */
class ViewState3d extends ViewState {
    constructor(props, iModel, categories, displayStyle) {
        super(props, iModel, categories, displayStyle);
        /** Minimum distance for front plane */
        this.forceMinFrontDist = 0.0;
        this._cameraOn = bentleyjs_core_1.JsonUtils.asBool(props.cameraOn);
        this.origin = geometry_core_1.Point3d.fromJSON(props.origin);
        this.extents = geometry_core_1.Vector3d.fromJSON(props.extents);
        this.rotation = geometry_core_1.YawPitchRollAngles.fromJSON(props.angles).toMatrix3d();
        bentleyjs_core_1.assert(this.rotation.isRigid());
        this.camera = new imodeljs_common_1.Camera(props.camera);
    }
    /** @internal */
    static get className() { return "ViewDefinition3d"; }
    onRenderFrame(_viewport) { }
    allow3dManipulations() { return true; }
    /** @internal */
    saveForUndo() { return new ViewState3dUndo(this); }
    /** @internal */
    setFromUndo(val) {
        this._cameraOn = val.cameraOn;
        this.origin.setFrom(val.origin);
        this.extents.setFrom(val.extents);
        this.rotation.setFrom(val.rotation);
        this.camera.setFrom(val.camera);
    }
    toJSON() {
        const val = super.toJSON();
        val.cameraOn = this._cameraOn;
        val.origin = this.origin;
        val.extents = this.extents;
        val.angles = geometry_core_1.YawPitchRollAngles.createFromMatrix3d(this.rotation).toJSON();
        val.camera = this.camera;
        return val;
    }
    get isCameraOn() { return this._cameraOn; }
    setupFromFrustum(frustum) {
        const stat = super.setupFromFrustum(frustum);
        if (ViewStatus.Success !== stat)
            return stat;
        this.turnCameraOff();
        const frustPts = frustum.points;
        // use comparison of back, front plane X sizes to indicate camera or flat view ...
        const xBack = frustPts[imodeljs_common_1.Npc.LeftBottomRear].distance(frustPts[imodeljs_common_1.Npc.RightBottomRear]);
        const xFront = frustPts[imodeljs_common_1.Npc.LeftBottomFront].distance(frustPts[imodeljs_common_1.Npc.RightBottomFront]);
        const flatViewFractionTolerance = 1.0e-6;
        if (xFront > xBack * (1.0 + flatViewFractionTolerance))
            return ViewStatus.InvalidWindow;
        // see if the frustum is tapered, and if so, set up camera eyepoint and adjust viewOrg and delta.
        const compression = xFront / xBack;
        if (compression >= (1.0 - flatViewFractionTolerance))
            return ViewStatus.Success;
        // the frustum has perspective, turn camera on
        let viewOrg = frustPts[imodeljs_common_1.Npc.LeftBottomRear];
        const viewDelta = this.getExtents().clone();
        const zDir = this.getZVector();
        const frustumZ = viewOrg.vectorTo(frustPts[imodeljs_common_1.Npc.LeftBottomFront]);
        const frustOrgToEye = frustumZ.scale(1.0 / (1.0 - compression));
        const eyePoint = viewOrg.plus(frustOrgToEye);
        const backDistance = frustOrgToEye.dotProduct(zDir); // distance from eye to back plane of frustum
        const focusDistance = backDistance - (viewDelta.z / 2.0);
        const focalFraction = focusDistance / backDistance; // ratio of focus plane distance to back plane distance
        viewOrg = eyePoint.plus2Scaled(frustOrgToEye, -focalFraction, zDir, focusDistance - backDistance); // now project that point onto back plane
        viewDelta.x *= focalFraction; // adjust view delta for x and y so they are also at focus plane
        viewDelta.y *= focalFraction;
        this.setEyePoint(eyePoint);
        this.setFocusDistance(focusDistance);
        this.setOrigin(viewOrg);
        this.setExtents(viewDelta);
        this.setLensAngle(this.calcLensAngle());
        this.enableCamera();
        return ViewStatus.Success;
    }
    static calculateMaxDepth(delta, zVec) {
        const depthRatioLimit = 1.0E8; // Limit for depth Ratio.
        const maxTransformRowRatio = 1.0E5;
        const minXYComponent = Math.min(Math.abs(zVec.x), Math.abs(zVec.y));
        const maxDepthRatio = (0.0 === minXYComponent) ? depthRatioLimit : Math.min((maxTransformRowRatio / minXYComponent), depthRatioLimit);
        return Math.max(delta.x, delta.y) * maxDepthRatio;
    }
    getOrigin() { return this.origin; }
    getExtents() { return this.extents; }
    getRotation() { return this.rotation; }
    setOrigin(origin) { this.origin.setFrom(origin); }
    setExtents(extents) { this.extents.setFrom(extents); }
    setRotation(rot) { this.rotation.setFrom(rot); }
    /** @internal */
    enableCamera() { if (this.supportsCamera())
        this._cameraOn = true; }
    supportsCamera() { return true; }
    minimumFrontDistance() { return Math.max(15.2 * geometry_core_1.Constant.oneCentimeter, this.forceMinFrontDist); }
    isEyePointAbove(elevation) { return !this._cameraOn ? (this.getZVector().z > 0) : (this.getEyePoint().z > elevation); }
    getDisplayStyle3d() { return this.displayStyle; }
    /** Turn the camera off for this view. After this call, the camera parameters in this view definition are ignored and views that use it will
     * display with an orthographic (infinite focal length) projection of the view volume from the view direction.
     * @note To turn the camera back on, call #lookAt
     */
    turnCameraOff() { this._cameraOn = false; }
    /** Determine whether the camera is valid for this view */
    get isCameraValid() { return this.camera.isValid; }
    /** Calculate the lens angle formed by the current delta and focus distance */
    calcLensAngle() {
        const maxDelta = Math.max(this.extents.x, this.extents.y);
        return geometry_core_1.Angle.createRadians(2.0 * Math.atan2(maxDelta * 0.5, this.camera.getFocusDistance()));
    }
    /** Get the target point of the view. If there is no camera, view center is returned. */
    getTargetPoint(result) {
        if (!this._cameraOn)
            return super.getTargetPoint(result);
        const viewZ = this.getRotation().getRow(2);
        return this.getEyePoint().plusScaled(viewZ, -1.0 * this.getFocusDistance(), result);
    }
    /** Position the camera for this view and point it at a new target point.
     * @param eyePoint The new location of the camera.
     * @param targetPoint The new location to which the camera should point. This becomes the center of the view on the focus plane.
     * @param upVector A vector that orients the camera's "up" (view y). This vector must not be parallel to the vector from eye to target.
     * @param newExtents  The new size (width and height) of the view rectangle. The view rectangle is on the focus plane centered on the targetPoint.
     * If newExtents is undefined, the existing size is unchanged.
     * @param frontDistance The distance from the eyePoint to the front plane. If undefined, the existing front distance is used.
     * @param backDistance The distance from the eyePoint to the back plane. If undefined, the existing back distance is used.
     * @returns A [[ViewStatus]] indicating whether the camera was successfully positioned.
     * @note If the aspect ratio of viewDelta does not match the aspect ratio of a Viewport into which this view is displayed, it will be
     * adjusted when the [[Viewport]] is synchronized from this view.
     */
    lookAt(eyePoint, targetPoint, upVector, newExtents, frontDistance, backDistance) {
        const eye = new geometry_core_1.Point3d(eyePoint.x, eyePoint.y, eyePoint.z);
        const yVec = upVector.normalize();
        if (!yVec) // up vector zero length?
            return ViewStatus.InvalidUpVector;
        const zVec = geometry_core_1.Vector3d.createStartEnd(targetPoint, eye); // z defined by direction from eye to target
        const focusDist = zVec.normalizeWithLength(zVec).mag; // set focus at target point
        const minFrontDist = this.minimumFrontDistance();
        if (focusDist <= minFrontDist) // eye and target are too close together
            return ViewStatus.InvalidTargetPoint;
        const xVec = new geometry_core_1.Vector3d();
        if (yVec.crossProduct(zVec).normalizeWithLength(xVec).mag < geometry_core_1.Geometry.smallMetricDistance)
            return ViewStatus.InvalidUpVector; // up is parallel to z
        if (zVec.crossProduct(xVec).normalizeWithLength(yVec).mag < geometry_core_1.Geometry.smallMetricDistance)
            return ViewStatus.InvalidUpVector;
        // we now have rows of the rotation matrix
        const rotation = geometry_core_1.Matrix3d.createRows(xVec, yVec, zVec);
        backDistance = backDistance ? backDistance : this.getBackDistance();
        frontDistance = frontDistance ? frontDistance : this.getFrontDistance();
        const delta = newExtents ? new geometry_core_1.Vector3d(Math.abs(newExtents.x), Math.abs(newExtents.y), this.extents.z) : this.extents.clone();
        frontDistance = Math.max(frontDistance, (.5 * geometry_core_1.Constant.oneMeter));
        backDistance = Math.max(backDistance, focusDist + (.5 * geometry_core_1.Constant.oneMeter));
        if (backDistance < focusDist) // make sure focus distance is in front of back distance.
            backDistance = focusDist + geometry_core_1.Constant.oneMillimeter;
        if (frontDistance > focusDist)
            frontDistance = focusDist - minFrontDist;
        if (frontDistance < minFrontDist)
            frontDistance = minFrontDist;
        delta.z = (backDistance - frontDistance);
        const frontDelta = delta.scale(frontDistance / focusDist);
        const stat = this.validateViewDelta(frontDelta, false); // validate window size on front (smallest) plane
        if (ViewStatus.Success !== stat)
            return stat;
        if (delta.z > ViewState3d.calculateMaxDepth(delta, zVec)) // make sure we're not zoomed out too far
            return ViewStatus.MaxDisplayDepth;
        // The origin is defined as the lower left of the view rectangle on the focus plane, projected to the back plane.
        // Start at eye point, and move to center of back plane, then move left half of width. and down half of height
        const origin = eye.plus3Scaled(zVec, -backDistance, xVec, -0.5 * delta.x, yVec, -0.5 * delta.y);
        this.setEyePoint(eyePoint);
        this.setRotation(rotation);
        this.setFocusDistance(focusDist);
        this.setOrigin(origin);
        this.setExtents(delta);
        this.setLensAngle(this.calcLensAngle());
        this.enableCamera();
        return ViewStatus.Success;
    }
    /** Position the camera for this view and point it at a new target point, using a specified lens angle.
     * @param eyePoint The new location of the camera.
     * @param targetPoint The new location to which the camera should point. This becomes the center of the view on the focus plane.
     * @param upVector A vector that orients the camera's "up" (view y). This vector must not be parallel to the vector from eye to target.
     * @param fov The angle, in radians, that defines the field-of-view for the camera. Must be between .0001 and pi.
     * @param frontDistance The distance from the eyePoint to the front plane. If undefined, the existing front distance is used.
     * @param backDistance The distance from the eyePoint to the back plane. If undefined, the existing back distance is used.
     * @returns [[ViewStatus]] indicating whether the camera was successfully positioned.
     * @note The aspect ratio of the view remains unchanged.
     */
    lookAtUsingLensAngle(eyePoint, targetPoint, upVector, fov, frontDistance, backDistance) {
        const focusDist = eyePoint.vectorTo(targetPoint).magnitude(); // Set focus at target point
        if (focusDist <= geometry_core_1.Constant.oneMillimeter) // eye and target are too close together
            return ViewStatus.InvalidTargetPoint;
        if (fov.radians < .0001 || fov.radians > Math.PI)
            return ViewStatus.InvalidLens;
        const extent = 2.0 * Math.tan(fov.radians / 2.0) * focusDist;
        const delta = geometry_core_1.Vector2d.create(this.extents.x, this.extents.y);
        const longAxis = Math.max(delta.x, delta.y);
        delta.scale(extent / longAxis, delta);
        return this.lookAt(eyePoint, targetPoint, upVector, delta, frontDistance, backDistance);
    }
    /** Move the camera relative to its current location by a distance in camera coordinates.
     * @param distance to move camera. Length is in world units, direction relative to current camera orientation.
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     */
    moveCameraLocal(distance) {
        const distWorld = this.getRotation().multiplyTransposeVector(distance);
        return this.moveCameraWorld(distWorld);
    }
    /** Move the camera relative to its current location by a distance in world coordinates.
     * @param distance in world units.
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     */
    moveCameraWorld(distance) {
        if (!this._cameraOn) {
            this.origin.plus(distance, this.origin);
            return ViewStatus.Success;
        }
        const newTarget = this.getTargetPoint().plus(distance);
        const newEyePt = this.getEyePoint().plus(distance);
        return this.lookAt(newEyePt, newTarget, this.getYVector());
    }
    /** Rotate the camera from its current location about an axis relative to its current orientation.
     * @param angle The angle to rotate the camera.
     * @param axis The axis about which to rotate the camera. The axis is a direction relative to the current camera orientation.
     * @param aboutPt The point, in world coordinates, about which the camera is rotated. If aboutPt is undefined, the camera rotates in place
     *  (i.e. about the current eyePoint).
     * @note Even though the axis is relative to the current camera orientation, the aboutPt is in world coordinates, \b not relative to the camera.
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     */
    rotateCameraLocal(angle, axis, aboutPt) {
        const axisWorld = this.getRotation().multiplyTransposeVector(axis);
        return this.rotateCameraWorld(angle, axisWorld, aboutPt);
    }
    /** Rotate the camera from its current location about an axis in world coordinates.
     * @param angle The angle to rotate the camera.
     * @param axis The world-based axis (direction) about which to rotate the camera.
     * @param aboutPt The point, in world coordinates, about which the camera is rotated. If aboutPt is undefined, the camera rotates in place
     *  (i.e. about the current eyePoint).
     * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.
     */
    rotateCameraWorld(angle, axis, aboutPt) {
        const about = aboutPt ? aboutPt : this.getEyePoint();
        const rotation = geometry_core_1.Matrix3d.createRotationAroundVector(axis, angle);
        if (!rotation)
            return ViewStatus.InvalidUpVector; // Invalid axis given
        const trans = geometry_core_1.Transform.createFixedPointAndMatrix(about, rotation);
        const newTarget = trans.multiplyPoint3d(this.getTargetPoint());
        const upVec = rotation.multiplyVector(this.getYVector());
        return this.lookAt(this.getEyePoint(), newTarget, upVec);
    }
    /** Get the distance from the eyePoint to the front plane for this view. */
    getFrontDistance() { return this.getBackDistance() - this.extents.z; }
    /** Get the distance from the eyePoint to the back plane for this view. */
    getBackDistance() {
        // backDist is the z component of the vector from the origin to the eyePoint .
        const eyeOrg = this.origin.vectorTo(this.getEyePoint());
        this.getRotation().multiplyVector(eyeOrg, eyeOrg);
        return eyeOrg.z;
    }
    /** Place the eyepoint of the camera so it is aligned with the center of the view. This removes any 1-point perspective skewing that may be
     * present in the current view.
     * @param backDistance If defined, the new the distance from the eyepoint to the back plane. Otherwise the distance from the
     * current eyepoint is used.
     */
    centerEyePoint(backDistance) {
        const eyePoint = this.getExtents().scale(0.5);
        eyePoint.z = backDistance ? backDistance : this.getBackDistance();
        const eye = this.getRotation().multiplyTransposeXYZ(eyePoint.x, eyePoint.y, eyePoint.z);
        this.camera.setEyePoint(this.getOrigin().plus(eye));
    }
    /** Center the focus distance of the camera halfway between the front plane and the back plane, keeping the eyepoint,
     * lens angle, rotation, back distance, and front distance unchanged.
     * @note The focus distance, origin, and delta values are modified, but the view encloses the same volume and appears visually unchanged.
     */
    centerFocusDistance() {
        const backDist = this.getBackDistance();
        const frontDist = this.getFrontDistance();
        const eye = this.getEyePoint();
        const target = eye.plusScaled(this.getZVector(), frontDist - backDist);
        this.lookAtUsingLensAngle(eye, target, this.getYVector(), this.getLensAngle(), frontDist, backDist);
    }
    /** Ensure the focus plane lies between the front and back planes. If not, center it. */
    verifyFocusPlane() {
        if (!this._cameraOn)
            return;
        let backDist = this.getBackDistance();
        const frontDist = backDist - this.extents.z;
        const camera = this.camera;
        const extents = this.extents;
        const rot = this.rotation;
        if (backDist <= 0.0 || frontDist <= 0.0) {
            // the camera location is invalid. Set it based on the view range.
            const tanAngle = Math.tan(camera.lens.radians / 2.0);
            backDist = extents.z / tanAngle;
            camera.setFocusDistance(backDist / 2);
            this.centerEyePoint(backDist);
            return;
        }
        const focusDist = camera.focusDist;
        if (focusDist > frontDist && focusDist < backDist)
            return;
        // put it halfway between front and back planes
        camera.setFocusDistance((extents.z / 2.0) + frontDist);
        // moving the focus plane means we have to adjust the origin and delta too (they're on the focus plane, see diagram above)
        const ratio = camera.focusDist / focusDist;
        extents.x *= ratio;
        extents.y *= ratio;
        camera.eye.plus3Scaled(rot.rowZ(), -backDist, rot.rowX(), -0.5 * extents.x, rot.rowY(), -0.5 * extents.y, this.origin); // this centers the camera too
    }
    /** Get the current location of the eyePoint for camera in this view. */
    getEyePoint() { return this.camera.eye; }
    /** Get the lens angle for this view. */
    getLensAngle() { return this.camera.lens; }
    /** Set the lens angle for this view.
     *  @param angle The new lens angle in radians. Must be greater than 0 and less than pi.
     *  @note This does not change the view's current field-of-view. Instead, it changes the lens that will be used if the view
     *  is subsequently modified and the lens angle is used to position the eyepoint.
     *  @note To change the field-of-view (i.e. "zoom") of a view, pass a new viewDelta to #lookAt
     */
    setLensAngle(angle) { this.camera.setLensAngle(angle); }
    /** Change the location of the eyePoint for the camera in this view.
     * @param pt The new eyepoint.
     * @note This method is generally for internal use only. Moving the eyePoint arbitrarily can result in skewed or illegal perspectives.
     * The most common method for user-level camera positioning is #lookAt.
     */
    setEyePoint(pt) { this.camera.setEyePoint(pt); }
    /** Set the focus distance for this view.
     *  @note Changing the focus distance changes the plane on which the delta.x and delta.y values lie. So, changing focus distance
     *  without making corresponding changes to delta.x and delta.y essentially changes the lens angle, causing a "zoom" effect
     */
    setFocusDistance(dist) { this.camera.setFocusDistance(dist); }
    /**  Get the distance from the eyePoint to the focus plane for this view. */
    getFocusDistance() { return this.camera.focusDist; }
    createAuxCoordSystem(acsName) { return AuxCoordSys_1.AuxCoordSystem3dState.createNew(acsName, this.iModel); }
    decorate(context) {
        super.decorate(context);
        this.drawSkyBox(context);
        this.drawGroundPlane(context);
    }
    /** @internal */
    drawSkyBox(context) {
        const style3d = this.getDisplayStyle3d();
        if (!style3d.environment.sky.display)
            return;
        const vp = context.viewport;
        const skyBoxParams = style3d.loadSkyBoxParams(vp.target.renderSystem, vp);
        if (undefined !== skyBoxParams) {
            const skyBoxGraphic = IModelApp_1.IModelApp.renderSystem.createSkyBox(skyBoxParams);
            context.setSkyBox(skyBoxGraphic);
        }
    }
    /** Returns the ground elevation taken from the environment added with the global z position of this imodel. */
    getGroundElevation() {
        const env = this.getDisplayStyle3d().environment;
        return env.ground.elevation + this.iModel.globalOrigin.z;
    }
    /** Return the ground extents, which will originate either from the viewport frustum or the extents of the imodel. */
    getGroundExtents(vp) {
        const displayStyle = this.getDisplayStyle3d();
        const extents = new geometry_core_1.Range3d();
        if (!displayStyle.environment.ground.display)
            return extents; // Ground plane is not enabled
        const elevation = this.getGroundElevation();
        if (undefined !== vp) {
            const viewRay = geometry_core_1.Ray3d.create(geometry_core_1.Point3d.create(), vp.rotation.rowZ());
            const xyPlane = geometry_core_1.Plane3dByOriginAndUnitNormal.create(geometry_core_1.Point3d.create(0, 0, elevation), geometry_core_1.Vector3d.create(0, 0, 1));
            // first determine whether the ground plane is displayed in the view
            const worldFrust = vp.getFrustum();
            for (const point of worldFrust.points) {
                viewRay.origin = point; // We never modify the reference
                const xyzPoint = geometry_core_1.Point3d.create();
                const param = viewRay.intersectionWithPlane(xyPlane, xyzPoint);
                if (param === undefined)
                    return extents; // View does not show ground plane
            }
        }
        extents.setFrom(this.iModel.projectExtents);
        extents.low.z = extents.high.z = elevation;
        const center = extents.low.interpolate(.5, extents.high);
        const radius = extents.low.distance(extents.high);
        extents.setNull();
        extents.extendPoint(center); // Extents now contains single point
        extents.low.addScaledInPlace(geometry_core_1.Vector3d.create(-1, -1, -1), radius);
        extents.high.addScaledInPlace(geometry_core_1.Vector3d.create(1, 1, 1), radius);
        extents.low.z = extents.high.z = elevation;
        return extents;
    }
    /** @internal */
    drawGroundPlane(context) {
        const extents = this.getGroundExtents(context.viewport);
        if (extents.isNull)
            return;
        const ground = this.getDisplayStyle3d().environment.ground;
        if (!ground.display)
            return;
        const points = [extents.low.clone(), extents.low.clone(), extents.high.clone(), extents.high.clone()];
        points[1].x = extents.high.x;
        points[3].x = extents.low.x;
        const aboveGround = this.isEyePointAbove(extents.low.z);
        const gradient = ground.getGroundPlaneGradient(aboveGround);
        const texture = context.viewport.target.renderSystem.getGradientTexture(gradient, this.iModel);
        if (!texture)
            return;
        const matParams = new imodeljs_common_1.RenderMaterial.Params();
        matParams.diffuseColor = imodeljs_common_1.ColorDef.white;
        matParams.shadows = false;
        matParams.ambient = 1;
        matParams.diffuse = 0;
        const mapParams = new imodeljs_common_1.TextureMapping.Params();
        const transform = new imodeljs_common_1.TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0);
        mapParams.textureMatrix = transform;
        mapParams.textureMatrix.setTransform();
        matParams.textureMapping = new imodeljs_common_1.TextureMapping(texture, mapParams);
        const material = context.viewport.target.renderSystem.createMaterial(matParams, this.iModel);
        if (!material)
            return;
        const params = new imodeljs_common_1.GraphicParams();
        params.setLineColor(gradient.keys[0].color);
        params.setFillColor(imodeljs_common_1.ColorDef.white); // Fill should be set to opaque white for gradient texture...
        params.material = material;
        const builder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldDecoration);
        builder.activateGraphicParams(params);
        /// ### TODO: Until we have more support in geometry package for tracking UV coordinates of higher level geometry
        // we will use a PolyfaceBuilder here to add the ground plane as a quad, claim the polyface, and then send that to the GraphicBuilder
        const strokeOptions = new geometry_core_1.StrokeOptions();
        strokeOptions.needParams = true;
        const polyfaceBuilder = geometry_core_1.PolyfaceBuilder.create(strokeOptions);
        polyfaceBuilder.toggleReversedFacetFlag();
        const uvParams = [geometry_core_1.Point2d.create(0, 0), geometry_core_1.Point2d.create(1, 0), geometry_core_1.Point2d.create(1, 1), geometry_core_1.Point2d.create(0, 1)];
        polyfaceBuilder.addQuadFacet(points, uvParams);
        const polyface = polyfaceBuilder.claimPolyface(false);
        builder.addPolyface(polyface, true);
        context.addDecorationFromBuilder(builder);
    }
}
exports.ViewState3d = ViewState3d;
/** Defines a view of one or more SpatialModels.
 * The list of viewed models is stored by the ModelSelector.
 * @public
 */
class SpatialViewState extends ViewState3d {
    /** @internal */
    static get className() { return "SpatialViewDefinition"; }
    static createFromProps(props, iModel) {
        const cat = new CategorySelectorState_1.CategorySelectorState(props.categorySelectorProps, iModel);
        const displayStyleState = new DisplayStyleState_1.DisplayStyle3dState(props.displayStyleProps, iModel);
        const modelSelectorState = new ModelSelectorState_1.ModelSelectorState(props.modelSelectorProps, iModel);
        // use "new this" so subclasses are correct.
        return new this(props.viewDefinitionProps, iModel, cat, displayStyleState, modelSelectorState);
    }
    constructor(props, iModel, arg3, displayStyle, modelSelector) {
        super(props, iModel, arg3, displayStyle);
        this.modelSelector = modelSelector;
        if (arg3 instanceof SpatialViewState) { // from clone
            this.modelSelector = arg3.modelSelector.clone();
        }
    }
    equals(other) { return super.equals(other) && this.modelSelector.equals(other.modelSelector); }
    createAuxCoordSystem(acsName) { return AuxCoordSys_1.AuxCoordSystemSpatialState.createNew(acsName, this.iModel); }
    get defaultExtentLimits() { return { min: geometry_core_1.Constant.oneMillimeter, max: geometry_core_1.Constant.diameterOfEarth }; }
    computeFitRange() {
        // Loop over the current models in the model selector with loaded tile trees and union their ranges
        const range = new geometry_core_1.Range3d();
        this.forEachTileTreeModel((model) => {
            const tileTree = model.tileTree;
            if (tileTree !== undefined && tileTree.rootTile !== undefined) {
                const contentRange = tileTree.rootTile.computeWorldContentRange();
                bentleyjs_core_1.assert(!contentRange.isNull);
                bentleyjs_core_1.assert(contentRange.intersectsRange(this.iModel.projectExtents));
                range.extendRange(contentRange);
            }
        });
        if (range.isNull)
            range.setFrom(this.getViewedExtents());
        range.ensureMinLengths(1.0);
        return range;
    }
    getViewedExtents() {
        const extents = geometry_core_1.Range3d.fromJSON(this.iModel.projectExtents);
        extents.scaleAboutCenterInPlace(1.0001); // projectExtents. lying smack up against the extents is not excluded by frustum...
        extents.extendRange(this.getGroundExtents());
        return extents;
    }
    toJSON() {
        const val = super.toJSON();
        val.modelSelectorId = this.modelSelector.id;
        return val;
    }
    async load() {
        await super.load();
        await this.displayStyle.loadContextRealityModels();
        return this.modelSelector.load();
    }
    viewsModel(modelId) { return this.modelSelector.containsModel(modelId); }
    clearViewedModels() { this.modelSelector.models.clear(); }
    addViewedModel(id) { this.modelSelector.addModels(id); }
    removeViewedModel(id) { this.modelSelector.dropModels(id); }
    forEachModel(func) {
        for (const modelId of this.modelSelector.models) {
            const model = this.iModel.models.getLoaded(modelId);
            const model3d = undefined !== model ? model.asGeometricModel3d : undefined;
            if (undefined !== model3d)
                func(model3d);
        }
    }
    /** @alpha */
    forEachTileTreeModel(func) {
        this.displayStyle.forEachContextRealityModel((model) => func(model));
        this.forEachModel((model) => func(model));
    }
    /** @internal */
    createSolarShadowMap(context) {
        context.solarShadowMap = undefined;
        const displayStyle = this.getDisplayStyle3d();
        if (IModelApp_1.IModelApp.renderSystem.options.displaySolarShadows && this.viewFlags.shadows && displayStyle !== undefined) {
            const backgroundMapPlane = this.displayStyle.backgroundMapPlane;
            const viewFrustum = (undefined === backgroundMapPlane) ? context.viewFrustum : Viewport_1.ViewFrustum.createFromViewportAndPlane(context.viewport, backgroundMapPlane);
            const solarDirection = displayStyle.sunDirection ? displayStyle.sunDirection : geometry_core_1.Vector3d.create(-1, -1, -1).normalize();
            if (undefined !== viewFrustum) {
                context.solarShadowMap = IModelApp_1.IModelApp.renderSystem.getSolarShadowMap(viewFrustum.getFrustum(), solarDirection, displayStyle.settings.solarShadowsSettings, this.modelSelector, this.categorySelector, this.iModel);
                context.solarShadowMap.collectGraphics(context);
            }
        }
    }
}
exports.SpatialViewState = SpatialViewState;
/** Defines a spatial view that displays geometry on the image plane using a parallel orthographic projection.
 * @public
 */
class OrthographicViewState extends SpatialViewState {
    /** @internal */
    static get className() { return "OrthographicViewDefinition"; }
    constructor(props, iModel, categories, displayStyle, modelSelector) { super(props, iModel, categories, displayStyle, modelSelector); }
    supportsCamera() { return false; }
}
exports.OrthographicViewState = OrthographicViewState;
/** Defines the state of a view of a single 2d model.
 * @public
 */
class ViewState2d extends ViewState {
    /** @internal */
    static get className() { return "ViewDefinition2d"; }
    constructor(props, iModel, categories, displayStyle) {
        super(props, iModel, categories, displayStyle);
        this.origin = geometry_core_1.Point2d.fromJSON(props.origin);
        this.delta = geometry_core_1.Point2d.fromJSON(props.delta);
        this.angle = geometry_core_1.Angle.fromJSON(props.angle);
        this.baseModelId = bentleyjs_core_1.Id64.fromJSON(props.baseModelId);
    }
    toJSON() {
        const val = super.toJSON();
        val.origin = this.origin;
        val.delta = this.delta;
        val.angle = this.angle;
        val.baseModelId = this.baseModelId;
        return val;
    }
    /** @internal */
    saveForUndo() { return new ViewState2dUndo(this); }
    /** @internal */
    setFromUndo(val) {
        this.origin.setFrom(val.origin);
        this.delta.setFrom(val.delta);
        this.angle.setFrom(val.angle);
    }
    /** Return the model for this 2d view. */
    getViewedModel() {
        const model = this.iModel.models.getLoaded(this.baseModelId);
        if (model && !(model instanceof ModelState_1.GeometricModel2dState))
            return undefined;
        return model;
    }
    computeFitRange() { return this.getViewedExtents(); }
    getViewedExtents() {
        if (undefined === this._viewedExtents) {
            const model = this.iModel.models.getLoaded(this.baseModelId);
            if (undefined !== model && model.isGeometricModel && undefined !== model.tileTree) {
                this._viewedExtents = geometry_core_1.Range3d.create(model.tileTree.range.low, model.tileTree.range.high);
                model.tileTree.location.multiplyRange(this._viewedExtents, this._viewedExtents);
            }
        }
        return undefined !== this._viewedExtents ? this._viewedExtents : new geometry_core_1.Range3d();
    }
    onRenderFrame(_viewport) { }
    async load() {
        await super.load();
        return this.iModel.models.load(this.baseModelId);
    }
    allow3dManipulations() { return false; }
    getOrigin() { return new geometry_core_1.Point3d(this.origin.x, this.origin.y); }
    getExtents() { return new geometry_core_1.Vector3d(this.delta.x, this.delta.y); }
    getRotation() { return geometry_core_1.Matrix3d.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), this.angle); }
    setExtents(delta) { this.delta.set(delta.x, delta.y); }
    setOrigin(origin) { this.origin.set(origin.x, origin.y); }
    setRotation(rot) { const xColumn = rot.getColumn(0); this.angle.setRadians(Math.atan2(xColumn.y, xColumn.x)); }
    viewsModel(modelId) { return this.baseModelId.toString() === modelId.toString(); }
    forEachModel(func) {
        const model = this.iModel.models.getLoaded(this.baseModelId);
        const model2d = undefined !== model ? model.asGeometricModel2d : undefined;
        if (undefined !== model2d)
            func(model2d);
    }
    createAuxCoordSystem(acsName) { return AuxCoordSys_1.AuxCoordSystem2dState.createNew(acsName, this.iModel); }
}
exports.ViewState2d = ViewState2d;
/** A view of a DrawingModel
 * @public
 */
class DrawingViewState extends ViewState2d {
    /** @internal */
    static get className() { return "DrawingViewDefinition"; }
    static createFromProps(props, iModel) {
        const cat = new CategorySelectorState_1.CategorySelectorState(props.categorySelectorProps, iModel);
        const displayStyleState = new DisplayStyleState_1.DisplayStyle2dState(props.displayStyleProps, iModel);
        // use "new this" so subclasses are correct
        return new this(props.viewDefinitionProps, iModel, cat, displayStyleState);
    }
    get defaultExtentLimits() {
        if (undefined !== this._modelLimits)
            return this._modelLimits;
        const model = this.getViewedModel();
        const tree = undefined !== model ? model.tileTree : undefined;
        if (undefined === tree)
            return { min: geometry_core_1.Constant.oneMillimeter, max: geometry_core_1.Constant.diameterOfEarth };
        this._modelLimits = { min: geometry_core_1.Constant.oneMillimeter, max: 2.0 * tree.range.maxLength() };
        return this._modelLimits;
    }
}
exports.DrawingViewState = DrawingViewState;


/***/ }),

/***/ "./lib/Viewport.js":
/*!*************************!*\
  !*** ./lib/Viewport.js ***!
  \*************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Views */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const ElementLocateManager_1 = __webpack_require__(/*! ./ElementLocateManager */ "./lib/ElementLocateManager.js");
const HitDetail_1 = __webpack_require__(/*! ./HitDetail */ "./lib/HitDetail.js");
const IModelApp_1 = __webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./render/FeatureSymbology */ "./lib/render/FeatureSymbology.js");
const GraphicBuilder_1 = __webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js");
const System_1 = __webpack_require__(/*! ./render/System */ "./lib/render/System.js");
const StandardView_1 = __webpack_require__(/*! ./StandardView */ "./lib/StandardView.js");
const SubCategoriesCache_1 = __webpack_require__(/*! ./SubCategoriesCache */ "./lib/SubCategoriesCache.js");
const ViewContext_1 = __webpack_require__(/*! ./ViewContext */ "./lib/ViewContext.js");
const ViewState_1 = __webpack_require__(/*! ./ViewState */ "./lib/ViewState.js");
const Tool_1 = __webpack_require__(/*! ./tools/Tool */ "./lib/tools/Tool.js");
/** Viewport synchronization flags. Synchronization is handled internally - do not use directly.
 * @internal
 */
class SyncFlags {
    constructor() {
        this._decorations = false;
        this._scene = false;
        this._renderPlan = false;
        this._controller = false;
        this._rotatePoint = false;
        this._animationFraction = false;
        this._redrawPending = false;
    }
    get isValidDecorations() { return this._decorations; }
    get isValidScene() { return this._scene; }
    get isValidController() { return this._controller; }
    get isValidRenderPlan() { return this._renderPlan; }
    get isValidRotatePoint() { return this._rotatePoint; }
    get isValidAnimationFraction() { return this._animationFraction; }
    get isRedrawPending() { return this._redrawPending; }
    invalidateDecorations() { this._decorations = false; }
    invalidateScene() { this._scene = false; this.invalidateDecorations(); this.invalidateAnimationFraction(); }
    invalidateRenderPlan() { this._renderPlan = false; this.invalidateScene(); }
    invalidateController() { this._controller = false; this.invalidateRenderPlan(); }
    invalidateRotatePoint() { this._rotatePoint = false; }
    invalidateAnimationFraction() { this._animationFraction = false; }
    invalidateRedrawPending() { this._redrawPending = false; }
    setValidDecorations() { this._decorations = true; }
    setValidScene() { this._scene = true; }
    setValidController() { this._controller = true; }
    setValidRenderPlan() { this._renderPlan = true; }
    setValidRotatePoint() { this._rotatePoint = true; }
    setValidAnimationFraction() { this._animationFraction = true; }
    setRedrawPending() { this._redrawPending = true; }
    initFrom(other) { this._decorations = other._decorations; this._scene = other._scene; this._renderPlan = other._renderPlan; this._controller = other._controller; this._rotatePoint = other._rotatePoint; this._animationFraction = other._animationFraction; this._redrawPending = other._redrawPending; }
}
exports.SyncFlags = SyncFlags;
/** @see [[ChangeFlags]]
 * @beta
 */
var ChangeFlag;
(function (ChangeFlag) {
    ChangeFlag[ChangeFlag["None"] = 0] = "None";
    ChangeFlag[ChangeFlag["AlwaysDrawn"] = 1] = "AlwaysDrawn";
    ChangeFlag[ChangeFlag["NeverDrawn"] = 2] = "NeverDrawn";
    ChangeFlag[ChangeFlag["ViewedCategories"] = 4] = "ViewedCategories";
    ChangeFlag[ChangeFlag["ViewedModels"] = 8] = "ViewedModels";
    ChangeFlag[ChangeFlag["DisplayStyle"] = 16] = "DisplayStyle";
    ChangeFlag[ChangeFlag["FeatureOverrideProvider"] = 32] = "FeatureOverrideProvider";
    ChangeFlag[ChangeFlag["ViewedCategoriesPerModel"] = 64] = "ViewedCategoriesPerModel";
    ChangeFlag[ChangeFlag["All"] = 268435455] = "All";
    ChangeFlag[ChangeFlag["Overrides"] = 268435447] = "Overrides";
    ChangeFlag[ChangeFlag["Initial"] = 28] = "Initial";
})(ChangeFlag = exports.ChangeFlag || (exports.ChangeFlag = {}));
/** Viewport event synchronization flags. Used primarily for tracking changes which affect the viewport's [[FeatureSymbology.Overrides]].
 * Each time [[Viewport.renderFrame]] is invoked, the effects of any changes to these flags will be applied, and corresponding events dispatched.
 * An individual flag is true if the corresponding Viewport state has changed and needs to be synchronized.
 * @beta
 */
class ChangeFlags {
    /** The set of always drawn elements has changed. */
    get alwaysDrawn() { return this.isSet(ChangeFlag.AlwaysDrawn); }
    setAlwaysDrawn() { this.set(ChangeFlag.AlwaysDrawn); }
    /** The set of never drawn elements has changed. */
    get neverDrawn() { return this.isSet(ChangeFlag.NeverDrawn); }
    setNeverDrawn() { this.set(ChangeFlag.NeverDrawn); }
    /** The set of displayed categories has changed. */
    get viewedCategories() { return this.isSet(ChangeFlag.ViewedCategories); }
    setViewedCategories() { this.set(ChangeFlag.ViewedCategories); }
    /** The set of displayed models has changed. */
    get viewedModels() { return this.isSet(ChangeFlag.ViewedModels); }
    setViewedModels() { this.set(ChangeFlag.ViewedModels); }
    /** The display style or its settings such as [ViewFlags]($common) have changed. */
    get displayStyle() { return this.isSet(ChangeFlag.DisplayStyle); }
    setDisplayStyle() { this.set(ChangeFlag.DisplayStyle); }
    /** The [[FeatureOverrideProvider]] has changed, or its internal state has changed such that its overrides must be recomputed. */
    get featureOverrideProvider() { return this.isSet(ChangeFlag.FeatureOverrideProvider); }
    setFeatureOverrideProvider() { this.set(ChangeFlag.FeatureOverrideProvider); }
    /** The [[PerModelCategoryVisibility.Overrides]] associated with the viewport have changed.
     * @alpha
     */
    get viewedCategoriesPerModel() { return this.isSet(ChangeFlag.ViewedCategoriesPerModel); }
    setViewedCategoriesPerModel() { this.set(ChangeFlag.ViewedCategoriesPerModel); }
    constructor(flags = ChangeFlag.Initial) { this._flags = flags; }
    /** Return true if any of the specified flags are set. */
    isSet(flags) { return 0 !== (this._flags & flags); }
    /** Return true if all of the specified flags are set. */
    areAllSet(flags) { return flags === (this._flags & flags); }
    /** Set all of the specified flags. */
    set(flags) { this._flags |= flags; }
    /** Clear all of the specified flags. By default, clears all flags. */
    clear(flags = ChangeFlag.All) { this._flags &= ~flags; }
    /** Returns true if any flag affecting FeatureSymbology.Overrides is set. */
    get areFeatureOverridesDirty() { return this.isSet(ChangeFlag.Overrides); }
    /** Returns true if any flag is set. */
    get hasChanges() { return this.isSet(ChangeFlag.All); }
    get value() { return this._flags; }
}
exports.ChangeFlags = ChangeFlags;
/** A rectangle in integer view coordinates with (0,0) corresponding to the top-left corner of the view.
 *
 * Increasing **x** moves from left to right, and increasing **y** moves from top to bottom.
 * @public
 */
class ViewRect {
    /** Construct a new ViewRect. */
    constructor(left = 0, top = 0, right = 0, bottom = 0) { this.init(left, top, right, bottom); }
    /** The leftmost side of this ViewRect.  */
    get left() { return this._left; }
    set left(val) { this._left = Math.floor(val); }
    /** The topmost side of this ViewRect. */
    get top() { return this._top; }
    set top(val) { this._top = Math.floor(val); }
    /** The rightmost side of this ViewRect. */
    get right() { return this._right; }
    set right(val) { this._right = Math.floor(val); }
    /** The bottommost side of this ViewRect. */
    get bottom() { return this._bottom; }
    set bottom(val) { this._bottom = Math.floor(val); }
    /** True if this ViewRect has an area > 0. */
    get isNull() { return this.right <= this.left || this.bottom <= this.top; }
    /** True if `!isNull` */
    get isValid() { return !this.isNull; }
    /** The width (right-left) of this ViewRect. */
    get width() { return this.right - this.left; }
    set width(width) { this.right = this.left + width; }
    /** The height (bottom-top) of this ViewRect. */
    get height() { return this.bottom - this.top; }
    set height(height) { this.bottom = this.top + height; }
    /** The aspect ratio (width/height) of this ViewRect. */
    get aspect() { return this.isNull ? 1.0 : this.width / this.height; }
    /** The area (width*height) of this ViewRect. */
    get area() { return this.isNull ? 0 : this.width * this.height; }
    /** Initialize this ViewRect from its left/top/right/bottom parameters. */
    init(left, top, right, bottom) { this.left = left; this.bottom = bottom, this.right = right; this.top = top; }
    /** Initialize this ViewRect from two points.
     * @param topLeft The top-left corner.
     * @param bottomRight The bottom-right corner.
     */
    initFromPoints(topLeft, bottomRight) { this.init(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }
    /** Initialize this ViewRect from a range.
     * @param input The Range to use. `input.low` defines the top-left and `input.high` defines the bottom-right.
     */
    initFromRange(input) { this.initFromPoints(input.low, input.high); }
    /** Return true is this ViewRect is exactly equal to another ViewRect.
     * @param other The other ViewRect to compare
     */
    equals(other) { return this.left === other.left && this.right === other.right && this.bottom === other.bottom && this.top === other.top; }
    /** Initialize this ViewRect from another ViewRect. */
    setFrom(other) { this.init(other.left, other.top, other.right, other.bottom); }
    /** Duplicate this ViewRect.
     * @param result Optional ViewRect for result. If undefined, a new ViewRect is created.
     */
    clone(result) {
        if (undefined !== result) {
            result.setFrom(this);
            return result;
        }
        return new ViewRect(this.left, this.top, this.right, this.bottom);
    }
    extend(other) {
        if (this.left > other.left)
            this.left = other.left;
        if (this.top > other.top)
            this.top = other.top;
        if (this.right < other.right)
            this.right = other.right;
        if (this.bottom < other.bottom)
            this.bottom = other.bottom;
    }
    /** Inset this ViewRect by values in the x and y directions. Positive values make the ViewRect smaller, and negative values will make it larger.
     * @param deltaX The distance to inset the ViewRect in the x direction.
     * @param deltaY The distance to inset the ViewRect in the y direction.
     */
    inset(deltaX, deltaY) {
        if (this.width - 2 * deltaX <= 0 || this.height - 2 * deltaY <= 0) {
            this.init(0, 0, 0, 0);
            return;
        }
        this._left += deltaX;
        this._right -= deltaX;
        this._top += deltaY;
        this._bottom -= deltaY;
    }
    /** Inset this ViewRect by the same value in all directions.
     * @param offset The distance to inset this ViewRect. Positive values will make this ViewRect smaller and negative values will make it larger.
     * @note The inset operation can cause a previously valid ViewRect to become invalid.
     */
    insetUniform(offset) { this.inset(offset, offset); }
    /** Scale this ViewRect about its center by the supplied scale factors. */
    scaleAboutCenter(xScale, yScale) {
        const w = this.width;
        const h = this.height;
        const xDelta = (w - (w * xScale)) * 0.5;
        const yDelta = (h - (h * yScale)) * 0.5;
        this.inset(xDelta, yDelta);
    }
    /** Inset this ViewRect by a percentage of its current width.
     * @param percent The percentage of this ViewRect's width to inset in all directions.
     * @note The ViewRect will become smaller (or larger, if percent is negative) by `percent * width * 2` in each direction, since each side is moved by that distance.
     * @see [[inset]]
     */
    insetByPercent(percent) { this.insetUniform(this.width * percent); }
    /** Determine if this ViewRect is entirely contained within the bounds of another ViewRect. */
    isContained(other) { return this.left >= other.left && this.right <= other.right && this.bottom <= other.bottom && this.top >= other.top; }
    /** Return true if the supplied point is contained in this ViewRect.
     * @param point The point to test.
     * @note if the point is exactly on the left or top edges, this method returns true. If the point is exactly on the right or bottom edge, it returns false.
     */
    containsPoint(point) { return point.x >= this.left && point.x < this.right && point.y >= this.top && point.y < this.bottom; }
    /** Determine whether this ViewRect overlaps another. */
    overlaps(other) { return this.left <= other.right && this.top <= other.bottom && this.right >= other.left && this.bottom >= other.top; }
    /** Return a ViewRect that is the overlap (intersection) of this ViewRect and another ViewRect.
     * If the two ViewRects are equal, their value is the result. Otherwise, the result will always be smaller than either of them.
     */
    computeOverlap(other, out) {
        const maxOrgX = Math.max(this.left, other.left);
        const maxOrgY = Math.max(this.top, other.top);
        const minCrnX = Math.min(this.right, other.right);
        const minCrnY = Math.min(this.bottom, other.bottom);
        if (maxOrgX > minCrnX || maxOrgY > minCrnY)
            return undefined;
        const result = undefined !== out ? out : new ViewRect();
        result.left = maxOrgX;
        result.right = minCrnX;
        result.top = maxOrgY;
        result.bottom = minCrnY;
        return result;
    }
}
exports.ViewRect = ViewRect;
/** Coordinate system types
 * @public
 */
var CoordSystem;
(function (CoordSystem) {
    /** Coordinates are relative to the origin of the viewing rectangle.
     * x and y values correspond to pixels within that rectangle, with (x=0,y=0) corresponding to the top-left corner.
     */
    CoordSystem[CoordSystem["View"] = 0] = "View";
    /** Coordinates are in [Normalized Plane Coordinates]($docs/learning/glossary.md#npc). NPC is a coordinate system
     * for frustums in which each dimension [x,y,z] is normalized to hold values between 0.0 and 1.0.
     * [0,0,0] corresponds to the left-bottom-rear and [1,1,1] to the right-top-front of the frustum.
     */
    CoordSystem[CoordSystem["Npc"] = 1] = "Npc";
    /** Coordinates are in the coordinate system of the models in the view. For SpatialViews, this is the iModel's spatial coordinate system.
     * For 2d views, it is the coordinate system of the GeometricModel2d that the view shows.
     */
    CoordSystem[CoordSystem["World"] = 2] = "World";
})(CoordSystem = exports.CoordSystem || (exports.CoordSystem = {}));
/** Object to animate a Frustum transition of a viewport. The [[Viewport]] will show as many frames as necessary during the supplied duration.
 * @see [[Viewport.animateFrustumChange]]
 */
class Animator {
    /** Construct a new Animator.
     * @param totalTime The duration of the animation.
     * @param viewport The Viewport to animate.
     * @param startFrustum The Viewport's starting Frustum at the beginning of the animation.
     * @param endFrustum The Viewport's ending Frustum after the animation.
     */
    constructor(totalTime, viewport, startFrustum, endFrustum) {
        this.totalTime = totalTime;
        this.viewport = viewport;
        this.startFrustum = startFrustum;
        this.endFrustum = endFrustum;
        this._currFrustum = new imodeljs_common_1.Frustum();
        this._interpolator = geometry_core_1.SmoothTransformBetweenFrusta.create(startFrustum.points, endFrustum.points);
    }
    moveToTime(time) { this.interpolateFrustum(time / this.totalTime.milliseconds); }
    interpolateFrustum(fraction) {
        this._interpolator.fractionToWorldCorners(fraction, this._currFrustum.points);
        this.viewport.setupViewFromFrustum(this._currFrustum);
    }
    /**
     * Move to the appropriate frame, based on the current time, for the current animation.
     * @return true when finished to terminate the animation.
     */
    animate() {
        if (!this._interpolator) {
            this.viewport.setupViewFromFrustum(this.endFrustum);
            return true;
        }
        const currTime = bentleyjs_core_1.BeTimePoint.now();
        if (!this._startTime)
            this._startTime = currTime;
        const totalTimeMillis = this.totalTime.milliseconds;
        const endTime = this._startTime.milliseconds + totalTimeMillis;
        if (endTime <= currTime.milliseconds) {
            this.moveToTime(totalTimeMillis);
            return true;
        }
        let done = false;
        let index = currTime.milliseconds - this._startTime.milliseconds;
        if (index > totalTimeMillis) {
            done = true;
            index = totalTimeMillis;
        }
        this.moveToTime(index);
        return done;
    }
    /** Abort this animation, moving immediately to the final frame. */
    interrupt() {
        if (this._startTime)
            this.moveToTime(this.totalTime.milliseconds); // We've been interrupted after animation began. Skip to the final animation state
    }
}
/** Status for [[ViewportAnimator.animate]].
 * @public
 */
var RemoveMe;
(function (RemoveMe) {
    RemoveMe[RemoveMe["No"] = 0] = "No";
    RemoveMe[RemoveMe["Yes"] = 1] = "Yes";
})(RemoveMe = exports.RemoveMe || (exports.RemoveMe = {}));
/** A ViewportAnimator that animates decorations. While the animator is
 * active, decorations will be invalidated on each frame. The animator's
 * animateDecorations() function will be invoked to update any animation state; then
 * decorations will be re-requested and rendered.
 * @alpha
 */
class DecorationAnimator {
    constructor(duration) {
        this._start = bentleyjs_core_1.BeTimePoint.now();
        this._stop = this._start.plus(duration);
    }
    /** Override to update animation state, which can then be used on the next call to produce decorations.
     * @param viewport The viewport being animated
     * @param durationPercent The ratio of duration elapsed, in [0.0,1.0]
     * @returns RemoveMe.Yes to immediately remove this animator, RemoveMe::No to continue animating until duration elapsed or animator interrupted.
     * If this animator is interrupted, this function will be immediately invoked with durationPercent=1.0.
     */
    animateDecorations(_viewport, _durationPercent) { return RemoveMe.No; }
    animate(vp) {
        vp.invalidateDecorations();
        const total = this._stop.milliseconds - this._start.milliseconds;
        const elapsed = bentleyjs_core_1.BeTimePoint.now().milliseconds - this._start.milliseconds;
        const ratio = Math.min(elapsed / total, 1.0);
        const removeMe = this.animateDecorations(vp, ratio);
        return (RemoveMe.Yes === removeMe || ratio === 1.0) ? RemoveMe.Yes : RemoveMe.No;
    }
    onInterrupted(vp) {
        vp.invalidateDecorations();
        this.animateDecorations(vp, 1.0);
    }
}
exports.DecorationAnimator = DecorationAnimator;
/** Supplies facilities for interacting with a [[Viewport]]'s frustum.
 * @internal
 */
class ViewFrustum {
    constructor(view, clientWidth, clientHeight, aspectRatioLocked, displayedPlane) {
        this._viewCorners = new geometry_core_1.Range3d();
        /** @internal */
        this.frustFraction = 1.0;
        /** View origin, potentially expanded */
        this.viewOrigin = new geometry_core_1.Point3d();
        /** View delta, potentially expanded */
        this.viewDelta = new geometry_core_1.Vector3d();
        /** View origin (from ViewState, unexpanded) */
        this.viewOriginUnexpanded = new geometry_core_1.Point3d();
        /** View delta (from ViewState, unexpanded) */
        this.viewDeltaUnexpanded = new geometry_core_1.Vector3d();
        /** View rotation matrix (copied from ViewState) */
        this.rotation = new geometry_core_1.Matrix3d();
        /** @internal */
        this.worldToViewMap = geometry_core_1.Map4d.createIdentity();
        /** @internal */
        this.worldToNpcMap = geometry_core_1.Map4d.createIdentity();
        /** @internal */
        this.zClipAdjusted = false; // were the view z clip planes adjusted due to front/back clipping off?
        /** @internal */
        this.invalidFrustum = false;
        this._viewRange = new ViewRect();
        this._view = view;
        this._clientWidth = clientWidth;
        this._clientHeight = clientHeight;
        this._displayedPlane = displayedPlane;
        this._aspectRatioLocked = aspectRatioLocked;
        const origin = this.view.getOrigin().clone();
        const delta = this.view.getExtents().clone();
        this.rotation.setFrom(this.view.getRotation());
        // first, make sure none of the deltas are negative
        delta.x = Math.abs(delta.x);
        delta.y = Math.abs(delta.y);
        delta.z = Math.abs(delta.z);
        const limits = this.view.extentLimits;
        const clampRange = (val) => Math.min(Math.max(limits.min, val), limits.max);
        delta.x = clampRange(delta.x);
        delta.y = clampRange(delta.y);
        this.adjustAspectRatio(origin, delta);
        this.viewOriginUnexpanded.setFrom(origin);
        this.viewDeltaUnexpanded.setFrom(delta);
        this.viewOrigin.setFrom(origin);
        this.viewDelta.setFrom(delta);
        this.zClipAdjusted = false;
        if (this.view.is3d()) { // 3d viewport
            if (!this.view.allow3dManipulations()) {
                // we're in a "2d" view of a physical model. That means that we must have our orientation with z out of the screen with z=0 at the center.
                this.alignWithRootZ(); // make sure we're in a z Up view
                const extents = this.view.getViewedExtents();
                if (extents.isNull) {
                    extents.low.z = -ViewFrustum.get2dFrustumDepth();
                    extents.high.z = ViewFrustum.get2dFrustumDepth();
                }
                let zMax = Math.max(Math.abs(extents.low.z), Math.abs(extents.high.z));
                zMax = Math.max(zMax, 1.0); // make sure we have at least +-1m. Data may be purely planar
                delta.z = 2.0 * zMax;
                origin.z = -zMax;
            }
            else {
                if (this.view.isCameraOn)
                    this.validateCamera();
                this.adjustZPlanes(origin, delta); // make sure view volume includes entire volume of view
                // if the camera is on, don't allow front plane behind camera
                if (this.view.isCameraOn) {
                    const eyeOrg = this.view.camera.getEyePoint().minus(origin); // vector from eye to origin
                    this.toView(eyeOrg);
                    const frontDist = eyeOrg.z - delta.z; // front distance is backDist - delta.z
                    // allow ViewState to specify a minimum front dist, but in no case less than 6 inches
                    const minFrontDist = Math.max(15.2 * geometry_core_1.Constant.oneCentimeter, this.view.forceMinFrontDist);
                    if (frontDist < minFrontDist) {
                        // camera is too close to front plane, move origin away from eye to maintain a minimum front distance.
                        this.toView(origin);
                        origin.z -= (minFrontDist - frontDist);
                        this.fromView(origin);
                    }
                }
                // if we moved the z planes, set the "zClipAdjusted" flag.
                if (!origin.isExactEqual(this.viewOriginUnexpanded) || !delta.isExactEqual(this.viewDeltaUnexpanded))
                    this.zClipAdjusted = true;
            }
        }
        else { // 2d viewport
            this.alignWithRootZ();
            delta.z = 2 * ViewFrustum.get2dFrustumDepth();
            origin.z = -ViewFrustum.get2dFrustumDepth();
        }
        this.viewOrigin.setFrom(origin);
        this.viewDelta.setFrom(delta);
        const newRootToNpc = this.view.computeWorldToNpc(this.rotation, origin, delta, undefined === displayedPlane /* if displaying background map, don't enforce front/back ratio as no Z-Buffer */);
        if (newRootToNpc.map === undefined) { // invalid frustum
            this.invalidFrustum = true;
            return;
        }
        this.worldToNpcMap.setFrom(newRootToNpc.map);
        this.frustFraction = newRootToNpc.frustFraction;
        this.worldToViewMap.setFrom(this.calcNpcToView().multiplyMapMap(this.worldToNpcMap));
    }
    static get2dFrustumDepth() { return geometry_core_1.Constant.oneMeter; }
    /** The ViewState for this Viewport */
    get view() { return this._view; }
    set view(view) { this._view = view; }
    /** Get the rectangle of this Viewport in ViewCoordinates. */
    get _viewRect() { this._viewRange.init(0, 0, this._clientWidth, this._clientHeight); return this._viewRange; }
    static _copyOutput(from, to) { let pt = from; if (to) {
        to.setFrom(from);
        pt = to;
    } return pt; }
    /** @internal */
    toView(from, to) { this.rotation.multiplyVectorInPlace(ViewFrustum._copyOutput(from, to)); }
    /** @internal */
    fromView(from, to) { this.rotation.multiplyTransposeVectorInPlace(ViewFrustum._copyOutput(from, to)); }
    /** adjust the aspect ratio of the view volume to match the aspect ratio of the window of this Viewport.
     *  modifies the point and vector given
     *  @internal
     */
    adjustAspectRatio(origin, delta) {
        if (this._aspectRatioLocked)
            return;
        const windowAspect = this._viewRect.aspect * this.view.getAspectRatioSkew();
        const viewAspect = delta.x / delta.y;
        if (Math.abs(1.0 - (viewAspect / windowAspect)) < 1.0e-9)
            return;
        const oldDelta = delta.clone();
        if (viewAspect > windowAspect)
            delta.y = delta.x / windowAspect;
        else
            delta.x = delta.y * windowAspect;
        const newOrigin = origin.clone();
        this.toView(newOrigin);
        newOrigin.x += ((oldDelta.x - delta.x) / 2.0);
        newOrigin.y += ((oldDelta.y - delta.y) / 2.0);
        this.fromView(newOrigin, origin);
    }
    /** Ensure the rotation matrix for this view is aligns the root z with the view out (i.e. a "2d view"). */
    alignWithRootZ() {
        const zUp = geometry_core_1.Vector3d.unitZ();
        if (zUp.isAlmostEqual(this.rotation.rowZ()))
            return;
        const r = this.rotation.transpose();
        r.setColumn(2, zUp);
        geometry_core_1.Matrix3d.createRigidFromMatrix3d(r, geometry_core_1.AxisOrder.ZXY, r);
        r.transpose(this.rotation);
        this.view.setRotation(this.rotation); // Don't let viewState and viewport rotation be different.
    }
    validateCamera() {
        const view = this.view;
        if (!view.is3d())
            return;
        const camera = view.camera;
        camera.validateLens();
        if (camera.isFocusValid)
            return;
        const vDelta = view.getExtents();
        const maxDelta = vDelta.x > vDelta.y ? vDelta.x : vDelta.y;
        let focusDistance = maxDelta / (2.0 * Math.tan(camera.getLensAngle().radians / 2.0));
        if (focusDistance < vDelta.z / 2.0)
            focusDistance = vDelta.z / 2.0;
        const eyePoint = new geometry_core_1.Point3d(vDelta.x / 2.0, vDelta.y / 2.0, (vDelta.z / 2.0) + focusDistance);
        this.fromView(eyePoint);
        eyePoint.plus(view.getOrigin(), eyePoint);
        camera.setEyePoint(eyePoint);
        camera.setFocusDistance(focusDistance);
    }
    /** Adjust the front and back planes to encompass the entire viewed volume */
    adjustZPlanes(origin, delta) {
        const view = this.view;
        if (!view.is3d()) // only necessary for 3d views
            return;
        let extents = view.getViewedExtents();
        this.extendRangeForDisplayedPlane(extents);
        if (extents.isNull)
            return;
        // convert viewed extents in world coordinates to min/max in view aligned coordinates
        const viewTransform = geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.createZero(), this.rotation);
        const extFrust = imodeljs_common_1.Frustum.fromRange(extents);
        extFrust.multiply(viewTransform);
        extents = extFrust.toRange();
        this.rotation.multiplyVectorInPlace(origin); // put origin in view coordinates
        origin.z = extents.low.z; // set origin to back of viewed extents
        delta.z = extents.high.z - origin.z; // and delta to front of viewed extents
        this.rotation.multiplyTransposeVectorInPlace(origin);
        if (!view.isCameraOn)
            return;
        // if the camera is on, we need to make sure that the viewed volume is not behind the eye
        const eyeOrg = view.camera.getEyePoint().minus(origin);
        this.rotation.multiplyVectorInPlace(eyeOrg);
        // if the distance from the eye to origin in less than 1 meter, move the origin away from the eye. Usually, this means
        // that the camera is outside the viewed extents and pointed away from it. There's nothing to see anyway.
        if (eyeOrg.z < 1.0) {
            this.rotation.multiplyVectorInPlace(origin);
            origin.z -= (2.0 - eyeOrg.z);
            this.rotation.multiplyTransposeVectorInPlace(origin);
            delta.z = 1.0;
            return;
        }
        // if part of the viewed extents are behind the eye, don't include that.
        if (delta.z > eyeOrg.z)
            delta.z = eyeOrg.z;
    }
    extendRangeForDisplayedPlane(extents) {
        const view = this.view;
        if (!view.is3d()) // only necessary for 3d views
            return;
        if (this._displayedPlane === undefined)
            return;
        const planeNormal = this._displayedPlane.getNormalRef();
        const viewZ = this.rotation.getRow(2);
        const onPlane = viewZ.crossProduct(planeNormal); // vector on display plane.
        if (onPlane.magnitude() > 1.0E-8) {
            const intersect = new geometry_core_1.Point3d();
            const frustum = new imodeljs_common_1.Frustum();
            let includeHorizon = false;
            const worldToNpc = this.view.computeWorldToNpc(this.rotation, this.viewOrigin, this.viewDelta, false /* if displaying background map, don't enforce front/back ratio as no Z-Buffer */).map;
            const minimumEyeDistance = 10.0;
            const horizonDistance = 10000;
            worldToNpc.transform1.multiplyPoint3dArrayQuietNormalize(frustum.points);
            for (let i = 0; i < 4; i++) {
                const frustumRay = geometry_core_1.Ray3d.createStartEnd(frustum.points[i + 4], frustum.points[i]);
                const intersectDistance = frustumRay.intersectionWithPlane(this._displayedPlane, intersect);
                if (intersectDistance !== undefined && (!view.isCameraOn || intersectDistance > 0.0))
                    extents.extend(intersect);
                else
                    includeHorizon = true;
            }
            if (includeHorizon) {
                const rangeCenter = extents.fractionToPoint(.5, .5, .5);
                const normal = onPlane.unitCrossProduct(planeNormal); // on plane and parallel to view Z.
                extents.extend(rangeCenter.plusScaled(normal, horizonDistance));
            }
            if (view.isCameraOn) {
                extents.extend(view.getEyePoint().plusScaled(viewZ, -minimumEyeDistance));
            }
        }
        else {
            // display plane parallel to view....
            extents.extend(this._displayedPlane.getOriginRef().plusScaled(planeNormal, -1.0));
            extents.extend(this._displayedPlane.getOriginRef().plusScaled(planeNormal, 1.0));
        }
    }
    calcNpcToView() {
        const corners = this.getViewCorners();
        const map = geometry_core_1.Map4d.createBoxMap(imodeljs_common_1.NpcCorners[imodeljs_common_1.Npc._000], imodeljs_common_1.NpcCorners[imodeljs_common_1.Npc._111], corners.low, corners.high);
        bentleyjs_core_1.assert(undefined !== map, "undefined npcToViewMap");
        return undefined === map ? geometry_core_1.Map4d.createIdentity() : map;
    }
    /* Get the extents of this view, in ViewCoordinates, as a Range3d */
    getViewCorners() {
        const corners = this._viewCorners;
        const viewRect = this._viewRect;
        corners.high.x = viewRect.right;
        corners.low.y = viewRect.bottom; // y's are swapped on the screen!
        corners.low.x = 0;
        corners.high.y = 0;
        corners.low.z = -32767;
        corners.high.z = 32767;
        return corners;
    }
    /** @internal */
    static createFromViewport(vp, view) {
        return new ViewFrustum(view !== undefined ? view : vp.view, vp.viewRect.width, vp.viewRect.height, vp.isAspectRatioLocked);
    }
    /** @internal */
    static createFromViewportAndPlane(vp, plane) {
        const vf = new ViewFrustum(vp.view, vp.viewRect.width, vp.viewRect.height, vp.isAspectRatioLocked, plane);
        return vf.invalidFrustum ? undefined : vf;
    }
    /** Convert an array of points from CoordSystem.View to CoordSystem.Npc */
    viewToNpcArray(pts) {
        const corners = this.getViewCorners();
        const scrToNpcTran = geometry_core_1.Transform.createIdentity();
        geometry_core_1.Transform.initFromRange(corners.low, corners.high, undefined, scrToNpcTran);
        scrToNpcTran.multiplyPoint3dArrayInPlace(pts);
    }
    /** Convert an array of points from CoordSystem.Npc to CoordSystem.View */
    npcToViewArray(pts) {
        const corners = this.getViewCorners();
        for (const p of pts)
            corners.fractionToPoint(p.x, p.y, p.z, p);
    }
    /** Convert a point from CoordSystem.View to CoordSystem.Npc
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    viewToNpc(pt, out) {
        const corners = this.getViewCorners();
        const scrToNpcTran = geometry_core_1.Transform.createIdentity();
        geometry_core_1.Transform.initFromRange(corners.low, corners.high, undefined, scrToNpcTran);
        return scrToNpcTran.multiplyPoint3d(pt, out);
    }
    /** Convert a point from CoordSystem.Npc to CoordSystem.View
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    npcToView(pt, out) {
        const corners = this.getViewCorners();
        return corners.fractionToPoint(pt.x, pt.y, pt.z, out);
    }
    /** Convert an array of points from CoordSystem.World to CoordSystem.Npc */
    worldToNpcArray(pts) { this.worldToNpcMap.transform0.multiplyPoint3dArrayQuietNormalize(pts); }
    /** Convert an array of points from CoordSystem.Npc to CoordSystem.World */
    npcToWorldArray(pts) { this.worldToNpcMap.transform1.multiplyPoint3dArrayQuietNormalize(pts); }
    /** Convert an array of points from CoordSystem.World to CoordSystem.View */
    worldToViewArray(pts) { this.worldToViewMap.transform0.multiplyPoint3dArrayQuietNormalize(pts); }
    /** Convert an array of points from CoordSystem.World to CoordSystem.View, as Point4ds */
    worldToView4dArray(worldPts, viewPts) { this.worldToViewMap.transform0.multiplyPoint3dArray(worldPts, viewPts); }
    /** Convert an array of points from CoordSystem.View to CoordSystem.World */
    viewToWorldArray(pts) { this.worldToViewMap.transform1.multiplyPoint3dArrayQuietNormalize(pts); }
    /** Convert an array of points from CoordSystem.View as Point4ds to CoordSystem.World */
    view4dToWorldArray(viewPts, worldPts) { this.worldToViewMap.transform1.multiplyPoint4dArrayQuietRenormalize(viewPts, worldPts); }
    /**
     * Convert a point from CoordSystem.World to CoordSystem.Npc
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    worldToNpc(pt, out) { return this.worldToNpcMap.transform0.multiplyPoint3dQuietNormalize(pt, out); }
    /**
     * Convert a point from CoordSystem.Npc to CoordSystem.World
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    npcToWorld(pt, out) { return this.worldToNpcMap.transform1.multiplyPoint3dQuietNormalize(pt, out); }
    /**
     * Convert a point from CoordSystem.World to CoordSystem.View
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    worldToView(input, out) { return this.worldToViewMap.transform0.multiplyPoint3dQuietNormalize(input, out); }
    /**
     * Convert a point from CoordSystem.World to CoordSystem.View as Point4d
     * @param input the point to convert
     * @param out optional location for result. If undefined, a new Point4d is created.
     */
    worldToView4d(input, out) { return this.worldToViewMap.transform0.multiplyPoint3d(input, 1.0, out); }
    /**
     * Convert a point from CoordSystem.View to CoordSystem.World
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    viewToWorld(input, out) { return this.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(input, out); }
    /**
     * Convert a point from CoordSystem.View as a Point4d to CoordSystem.View
     * @param input the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    view4dToWorld(input, out) { return this.worldToViewMap.transform1.multiplyXYZWQuietRenormalize(input.x, input.y, input.z, input.w, out); }
    /** Get an 8-point Frustum corresponding to the 8 corners of the Viewport in the specified coordinate system.
     *
     * There are two sets of corners that may be of interest.
     * The "adjusted" box is the one that is computed by examining the "viewed extents" and moving
     * the front and back planes to enclose everything in the view.
     * The "unadjusted" box is the one that is stored in the ViewState.
     * @param sys Coordinate system for points
     * @param adjustedBox If true, retrieve the adjusted box. Otherwise retrieve the box that came from the view definition.
     * @param box optional Frustum for return value
     * @return the view frustum
     * @note The "adjusted" box may be either larger or smaller than the "unadjusted" box.
     */
    getFrustum(sys = CoordSystem.World, adjustedBox = true, box) {
        box = box ? box.initNpc() : new imodeljs_common_1.Frustum();
        // if they are looking for the "unexpanded" (that is before f/b clipping expansion) box, we need to get the npc
        // coordinates that correspond to the unexpanded box in the npc space of the Expanded view (that's the basis for all
        // of the root-based maps.)
        if (!adjustedBox && this.zClipAdjusted) {
            // to get unexpanded box, we have to go recompute rootToNpc from original View.
            const ueRootToNpc = this.view.computeWorldToNpc(this.rotation, this.viewOriginUnexpanded, this.viewDeltaUnexpanded);
            if (undefined === ueRootToNpc.map)
                return box; // invalid frustum
            // get the root corners of the unexpanded box
            const ueRootBox = new imodeljs_common_1.Frustum();
            ueRootToNpc.map.transform1.multiplyPoint3dArrayQuietNormalize(ueRootBox.points);
            // and convert them to npc coordinates of the expanded view
            this.worldToNpcArray(ueRootBox.points);
            box.setFrom(ueRootBox);
        }
        // now convert from NPC space to the specified coordinate system.
        switch (sys) {
            case CoordSystem.View:
                this.npcToViewArray(box.points);
                break;
            case CoordSystem.World:
                this.npcToWorldArray(box.points);
                break;
        }
        return box;
    }
    getPixelSizeAtPoint(inPoint) {
        const viewPt = !!inPoint ? this.worldToView(inPoint) : this.npcToView(new geometry_core_1.Point3d(0.5, 0.5, 0.5));
        const viewPt2 = new geometry_core_1.Point3d(viewPt.x + 1.0, viewPt.y, viewPt.z);
        return this.viewToWorld(viewPt).distance(this.viewToWorld(viewPt2));
    }
}
/** Maximum ratio of frontplane to backplane distance for 24 bit zbuffer */
ViewFrustum.nearScale24 = 0.0003;
exports.ViewFrustum = ViewFrustum;
/** @beta Event type for Viewport.onViewUndoRedo */
var ViewUndoEvent;
(function (ViewUndoEvent) {
    ViewUndoEvent[ViewUndoEvent["Undo"] = 0] = "Undo";
    ViewUndoEvent[ViewUndoEvent["Redo"] = 1] = "Redo";
})(ViewUndoEvent = exports.ViewUndoEvent || (exports.ViewUndoEvent = {}));
/** Allows the visibility of categories within a [[Viewport]] to be controlled on a per-[[ModelState]] basis.
 * If a category's visibility is overridden for a given model, then elements belonging to that category within that model will be displayed or hidden regardless of the category's inclusion in the Viewport's [[CategorySelectorState]].
 * The override affects geometry on all subcategories belonging to the overridden category. That is, if the category is overridden to be visible, then geometry on all subcategories of the category
 * will be visible, regardless of any [SubCategoryOverride]($common)s applied by the view's [[DisplayStyleState]].
 * @see [[Viewport.perModelCategoryVisibility]]
 * @beta
 */
var PerModelCategoryVisibility;
(function (PerModelCategoryVisibility) {
    /** Describes whether and how a category's visibility is overridden.
     * @beta
     */
    let Override;
    (function (Override) {
        /** The category's visibility is not overridden; its visibility is wholly controlled by the [[Viewport]]'s [[CategorySelectorState]]. */
        Override[Override["None"] = 0] = "None";
        /** The category is overridden to be visible. */
        Override[Override["Show"] = 1] = "Show";
        /** The category is overridden to be invisible. */
        Override[Override["Hide"] = 2] = "Hide";
    })(Override = PerModelCategoryVisibility.Override || (PerModelCategoryVisibility.Override = {}));
})(PerModelCategoryVisibility = exports.PerModelCategoryVisibility || (exports.PerModelCategoryVisibility = {}));
class PerModelCategoryVisibilityOverride {
    constructor(modelId, categoryId, visible) {
        this.modelId = modelId;
        this.categoryId = categoryId;
        this.visible = visible;
    }
    reset(modelId, categoryId, visible) {
        this.modelId = modelId;
        this.categoryId = categoryId;
        this.visible = visible;
    }
}
function compareCategoryOverrides(lhs, rhs) {
    const cmp = bentleyjs_core_1.compareStrings(lhs.modelId, rhs.modelId);
    return 0 === cmp ? bentleyjs_core_1.compareStrings(lhs.categoryId, rhs.categoryId) : cmp;
}
/** The Viewport-specific implementation of PerModelCategoryVisibility.Overrides.
 * ###TODO: Evaluate performance.
 * @internal
 */
class PerModelCategoryVisibilityOverrides extends bentleyjs_core_1.SortedArray {
    constructor(vp) {
        super(compareCategoryOverrides);
        this._scratch = new PerModelCategoryVisibilityOverride("0", "0", false);
        this._vp = vp;
    }
    getOverride(modelId, categoryId) {
        this._scratch.reset(modelId, categoryId, false);
        const ovr = this.findEqual(this._scratch);
        if (undefined !== ovr)
            return ovr.visible ? PerModelCategoryVisibility.Override.Show : PerModelCategoryVisibility.Override.Hide;
        else
            return PerModelCategoryVisibility.Override.None;
    }
    setOverride(modelIds, categoryIds, override) {
        const ovr = this._scratch;
        let changed = false;
        bentleyjs_core_1.Id64.forEach(modelIds, (modelId) => {
            bentleyjs_core_1.Id64.forEach(categoryIds, (categoryId) => {
                ovr.reset(modelId, categoryId, false);
                const index = this.indexOf(ovr);
                if (-1 === index) {
                    if (PerModelCategoryVisibility.Override.None !== override) {
                        this.insert(new PerModelCategoryVisibilityOverride(modelId, categoryId, PerModelCategoryVisibility.Override.Show === override));
                        changed = true;
                    }
                }
                else {
                    if (PerModelCategoryVisibility.Override.None === override) {
                        this._array.splice(index, 1);
                        changed = true;
                    }
                    else if (this._array[index].visible !== (PerModelCategoryVisibility.Override.Show === override)) {
                        this._array[index].visible = (PerModelCategoryVisibility.Override.Show === override);
                        changed = true;
                    }
                }
            });
        });
        if (changed) {
            this._vp.setViewedCategoriesPerModelChanged();
            if (PerModelCategoryVisibility.Override.None !== override) {
                // Ensure subcategories loaded.
                this._vp.subcategories.push(this._vp.iModel.subcategories, categoryIds, () => this._vp.setViewedCategoriesPerModelChanged());
            }
        }
    }
    clearOverrides(modelIds) {
        if (undefined === modelIds) {
            if (0 < this.length) {
                this.clear();
                this._vp.setViewedCategoriesPerModelChanged();
            }
            return;
        }
        for (let i = 0; i < this.length; /**/) {
            const ovr = this._array[i];
            const removed = !bentleyjs_core_1.Id64.iterate(modelIds, (modelId) => {
                if (modelId === ovr.modelId) {
                    this._array.splice(i, 1);
                    this._vp.setViewedCategoriesPerModelChanged();
                    return false; // halt iteration
                }
                return true; // continue iteration
            });
            if (!removed)
                ++i;
        }
    }
    addOverrides(fs, ovrs) {
        const cache = this._vp.iModel.subcategories;
        for (const ovr of this._array) {
            const subcats = cache.getSubCategories(ovr.categoryId);
            if (undefined === subcats)
                continue;
            // It's pointless to override for models which aren't displayed...except if we do this, and then someone enables that model,
            // we would need to regenerate our symbology overrides in response. Preferably people wouldn't bother overriding models that
            // they don't want us to draw...
            /* if (!this._vp.view.viewsModel(ovr.modelId))
              continue; */
            // ###TODO: Avoid recomputing upper and lower portions of model ID if model ID repeated.
            // (Array is sorted first by model ID).
            // Also avoid computing if no effective overrides.
            const modelLo = bentleyjs_core_1.Id64.getLowerUint32(ovr.modelId);
            const modelHi = bentleyjs_core_1.Id64.getUpperUint32(ovr.modelId);
            for (const subcat of subcats) {
                const subcatLo = bentleyjs_core_1.Id64.getLowerUint32(subcat);
                const subcatHi = bentleyjs_core_1.Id64.getUpperUint32(subcat);
                const vis = fs.isSubCategoryVisible(subcatLo, subcatHi);
                if (vis !== ovr.visible) {
                    // Only care if visibility differs from that defined for entire view
                    let entry = ovrs.get(modelLo, modelHi);
                    if (undefined === entry) {
                        entry = new bentleyjs_core_1.Id64.Uint32Set();
                        ovrs.set(modelLo, modelHi, entry);
                    }
                    entry.add(subcatLo, subcatHi);
                }
            }
        }
    }
}
/** A Viewport renders the contents of one or more Models onto an `HTMLCanvasElement`.
 *
 * It holds a [[ViewState]] object that defines its viewing parameters. [[ViewTool]]s may
 * modify the ViewState object. Changes to the ViewState are only reflected in a Viewport after the
 * [[synchWithView]] method is called.
 *
 * In general, because the Viewport essentially takes control of its attached ViewState, changes to the ViewState should be made
 * indirectly through the Viewport's own API. Doing so ensures that synchronization between the Viewport and its ViewState is reliable and automatic. For example:
 *
 *   * To change the set of categories or models displayed in the Viewport, use [[Viewport.changeCategoryDisplay]] and [[Viewport.changeModelDisplay]] rather than modifying the ViewState's [[CategorySelectorState]] or [[ModelSelectorState]] directly.
 *   * To change the [ViewFlags]($common), set [[Viewport.viewFlags]] rather than modifying the ViewState's [[DisplayStyleState]] directly.
 *   * To modify the [[DisplayStyleState]]:
 *    ```ts
 *    const style = viewport.displayStyle.clone();
 *    style.backgroundColor = ColorDef.red.clone(); // or any other desired modifications
 *    viewport.displayStyle = style;
 *    ```
 *
 * As changes to ViewState are made, Viewports also hold a stack of *previous copies* of it, to allow
 * for undo/redo (i.e. *View Previous* and *View Next*) of viewing tools.
 *
 * Changes to a Viewport's state can be monitored by attaching an event listener to a variety of specific events. Most such events are
 * triggered only once per frame, just before the Viewport's contents are rendered. For example, if the following sequence of events occurs:
 *
 *   * First frame is rendered
 *   * ViewFlags are modified
 *   * ViewFlags are modified again
 *   * Second frame is rendered
 *
 * The [[Viewport.onDisplayStyleChanged]] event will be invoked exactly once, when the second frame is rendered.
 *
 * @see [[ViewManager]]
 * @public
 */
class Viewport {
    /** @internal */
    constructor(target) {
        /** Event called whenever this viewport is synchronized with its [[ViewState]].
         * @note This event is invoked *very* frequently. To avoid negatively impacting performance, consider using one of the more specific Viewport events;
         * otherwise, avoid performing excessive computations in response to this event.
         */
        this.onViewChanged = new bentleyjs_core_1.BeEvent();
        /** Event called after reversing the most recent change to the Viewport from the undo stack or reapplying the most recently undone change to the Viewport from the redo stack.
         * @beta
         */
        this.onViewUndoRedo = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after this viewport's set of always-drawn elements changes.
         * @beta
         */
        this.onAlwaysDrawnChanged = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after this viewport's set of never-drawn elements changes.
         * @beta
         */
        this.onNeverDrawnChanged = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after this viewport's [[DisplayStyleState]] or its members change.
         * Aspects of the display style include [ViewFlags]($common), [SubCategoryOverride]($common)s, and [[Environment]] settings.
         * @beta
         */
        this.onDisplayStyleChanged = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after this viewport's set of displayed categories changes.
         * @beta
         */
        this.onViewedCategoriesChanged = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after this viewport's set of [[PerModelCategoryVisibility.Overrides]] changes.
         * @beta
         */
        this.onViewedCategoriesPerModelChanged = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after this viewport's set of displayed models changes.
         * @beta
         */
        this.onViewedModelsChanged = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after this viewport's [[FeatureOverrideProvider]] changes, or the internal state of the provider changes such that the overrides needed to be recomputed.
         * @beta
         */
        this.onFeatureOverrideProviderChanged = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after this viewport's [[FeatureSymbology.Overrides]] change.
         * @beta
         */
        this.onFeatureOverridesChanged = new bentleyjs_core_1.BeEvent();
        /** Event called on the next frame after any of the viewport's [[ChangeFlags]] changes.
         * @beta
         */
        this.onViewportChanged = new bentleyjs_core_1.BeEvent();
        this._animationFraction = 0.0;
        this._doContinuousRendering = false;
        /** @internal */
        this._changeFlags = new ChangeFlags();
        this._scheduleTime = 0.0;
        this._selectionSetDirty = true;
        this._perModelCategoryVisibility = new PerModelCategoryVisibilityOverrides(this);
        /** @internal */
        this.subcategories = new SubCategoriesCache_1.SubCategoriesCache.Queue();
        /** Current flash intensity from [0..1]
         * @internal
         */
        this.flashIntensity = 0;
        /** The length of time that the flash intensity will increase (in seconds)
         * @internal
         */
        this.flashDuration = 0;
        /** The number of tiles selected for display in the view as of the most recently-drawn frame.
         * The tiles selected may not meet the desired level-of-detail for the view, instead being temporarily drawn while
         * tiles of more appropriate level-of-detail are loaded asynchronously.
         * @note This member should be treated as read-only - it should only be modified internally.
         * @see Viewport.numRequestedTiles
         * @see Viewport.numReadyTiles
         */
        this.numSelectedTiles = 0;
        /** The number of tiles which were ready and met the desired level-of-detail for display in the view as of the most recently-drawn frame.
         * These tiles may *not* have been selected because some other (probably sibling) tiles were *not* ready for display.
         * This is a useful metric for determining how "complete" the view is - e.g., one indicator of progress toward view completion can be expressed as:
         * `  (numReadyTiles) / (numReadyTiles + numRequestedTiles)`
         * @note This member should be treated as read-only - it should only be modified internally.
         * @see Viewport.numSelectedTiles
         * @see Viewport.numRequestedTiles
         */
        this.numReadyTiles = 0;
        this._debugBoundingBoxes = 0 /* None */;
        this._freezeScene = false;
        this._fadeOutActive = false;
        this._alwaysDrawnExclusive = false;
        this._hilite = new imodeljs_common_1.Hilite.Settings();
        /** @internal */
        this._viewRange = new ViewRect();
        /** @internal */
        this.sync = new SyncFlags();
        /** Called when the visible contents of the viewport are redrawn.
         * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.
         */
        this.onRender = new bentleyjs_core_1.BeEvent();
        this._target = target;
        this._viewportId = Viewport._nextViewportId++;
    }
    /** @internal */
    get scheduleTime() { return this._scheduleTime; }
    /** @internal */
    get viewFrustum() { return this._viewFrustum; }
    /** This viewport's rotation matrix. */
    get rotation() { return this._viewFrustum.rotation; }
    /** The vector between the opposite corners of this viewport's extents. */
    get viewDelta() { return this._viewFrustum.viewDelta; }
    /** Provides conversions between world and view coordinates. */
    get worldToViewMap() { return this._viewFrustum.worldToViewMap; }
    /** @internal */
    get frustFraction() { return this._viewFrustum.frustFraction; }
    /** @internal */
    get animationFraction() { return this._animationFraction; }
    /** @internal */
    set animationFraction(fraction) {
        this._animationFraction = fraction;
        this.sync.invalidateAnimationFraction();
    }
    /** @internal */
    get isAspectRatioLocked() { return false; }
    /** @internal */
    get target() {
        bentleyjs_core_1.assert(undefined !== this._target, "Accessing RenderTarget of a disposed Viewport");
        return this._target;
    }
    /** The settings that control how elements are hilited in this Viewport. */
    get hilite() { return this._hilite; }
    set hilite(hilite) {
        this._hilite = hilite;
        this._selectionSetDirty = true;
    }
    /** Determine whether the Grid display is currently enabled in this Viewport.
     * @return true if the grid display is on.
     */
    get isGridOn() { return this.viewFlags.grid; }
    /** The [ViewFlags]($common) that determine how the contents of this Viewport are rendered. */
    get viewFlags() { return this.view.viewFlags; }
    set viewFlags(viewFlags) {
        if (!this.viewFlags.equals(viewFlags)) {
            this._changeFlags.setDisplayStyle();
            this.view.displayStyle.viewFlags = viewFlags;
        }
    }
    /** The display style controller how the contents of this viewport are rendered.
     * @note To ensure proper synchronization, do not directly modify the [[DisplayStyleState]] returned by the getter. Instead, create a new one (possibly by cloning this display style) and pass it to the setter.
     */
    get displayStyle() { return this.view.displayStyle; }
    set displayStyle(style) {
        this.view.displayStyle = style;
        this._changeFlags.setDisplayStyle();
    }
    /** Remove any [[SubCategoryOverride]] for the specified subcategory.
     * @param id The Id of the subcategory.
     * @see [[overrideSubCategory]]
     */
    dropSubCategoryOverride(id) {
        this.view.displayStyle.dropSubCategoryOverride(id);
        this._changeFlags.setDisplayStyle();
    }
    /** Override the symbology of geometry belonging to a specific subcategory when rendered within this viewport.
     * @param id The Id of the subcategory.
     * @param ovr The symbology overrides to apply to all geometry belonging to the specified subcategory.
     * @see [[dropSubCategoryOverride]]
     */
    overrideSubCategory(id, ovr) {
        this.view.displayStyle.overrideSubCategory(id, ovr);
        this._changeFlags.setDisplayStyle();
    }
    /** Query the symbology overrides applied to geometry belonging to a specific subcategory when rendered within this viewport.
     * @param id The Id of the subcategory.
     * @return The symbology overrides applied to all geometry belonging to the specified subcategory, or undefined if no such overrides exist.
     * @see [[overrideSubCategory]]
     */
    getSubCategoryOverride(id) {
        return this.view.displayStyle.getSubCategoryOverride(id);
    }
    /** Query the symbology with which geometry belonging to a specific subcategory is rendered within this viewport.
     * Every [[SubCategory]] defines a base symbology independent of any [[Viewport]].
     * If a [[SubCategoryOverride]] has been applied to the subcategory within the context of this [[Viewport]], it will be applied to the subcategory's base symbology.
     * @param id The Id of the subcategory.
     * @return The symbology of the subcategory within this viewport, including any overrides.
     * @see [[overrideSubCategory]]
     */
    getSubCategoryAppearance(id) {
        const app = this.iModel.subcategories.getSubCategoryAppearance(id);
        if (undefined === app)
            return imodeljs_common_1.SubCategoryAppearance.defaults;
        const ovr = this.getSubCategoryOverride(id);
        return undefined !== ovr ? ovr.override(app) : app;
    }
    /** Determine whether geometry belonging to a specific SubCategory is visible in this viewport, assuming the containing Category is displayed.
     * @param id The Id of the subcategory
     * @returns true if the subcategory is visible in this viewport.
     * @note Because this function does not know the Id of the containing Category, it does not check if the Category is enabled for display. The caller should check that separately if he knows the Id of the Category.
     */
    isSubCategoryVisible(id) { return this.view.isSubCategoryVisible(id); }
    /** Enable or disable display of elements belonging to a set of categories specified by Id.
     * Visibility of individual subcategories belonging to a category can be controlled separately through the use of [[SubCategoryOverride]]s.
     * By default, enabling display of a category does not affect display of subcategories thereof which have been overridden to be invisible.
     * @param categories The Id(s) of the categories to which the change should be applied. No other categories will be affected.
     * @param display Whether or not elements on the specified categories should be displayed in the viewport.
     * @param enableAllSubCategories Specifies that when enabling display for a category, all of its subcategories should also be displayed even if they are overridden to be invisible.
     */
    changeCategoryDisplay(categories, display, enableAllSubCategories = false) {
        this._changeFlags.setViewedCategories();
        if (!display) {
            this.view.categorySelector.dropCategories(categories);
            return;
        }
        this.view.categorySelector.addCategories(categories);
        const categoryIds = bentleyjs_core_1.Id64.toIdSet(categories);
        this.updateSubCategories(categoryIds, enableAllSubCategories);
    }
    updateSubCategories(categoryIds, enableAllSubCategories) {
        this.subcategories.push(this.iModel.subcategories, categoryIds, () => {
            if (enableAllSubCategories) {
                this.enableAllSubCategories(categoryIds);
                this._changeFlags.setViewedCategories();
            }
        });
    }
    enableAllSubCategories(categoryIds) {
        bentleyjs_core_1.Id64.forEach(categoryIds, (categoryId) => {
            const subCategoryIds = this.iModel.subcategories.getSubCategories(categoryId);
            if (undefined !== subCategoryIds) {
                for (const subCategoryId of subCategoryIds)
                    this.changeSubCategoryDisplay(subCategoryId, true);
            }
        });
    }
    /** @internal */
    getSubCategories(categoryId) { return this.iModel.subcategories.getSubCategories(categoryId); }
    /** Change the visibility of geometry belonging to the specified subcategory when displayed in this viewport.
     * @param subCategoryId The Id of the subcategory
     * @param display: True to make geometry belonging to the subcategory visible within this viewport, false to make it invisible.
     * @alpha
     */
    changeSubCategoryDisplay(subCategoryId, display) {
        const app = this.iModel.subcategories.getSubCategoryAppearance(subCategoryId);
        if (undefined === app)
            return; // category not enabled or subcategory not found
        const curOvr = this.getSubCategoryOverride(subCategoryId);
        const isAlreadyVisible = undefined !== curOvr && undefined !== curOvr.invisible ? !curOvr.invisible : !app.invisible;
        if (isAlreadyVisible === display)
            return;
        // Preserve existing overrides - just flip the visibility flag.
        const json = undefined !== curOvr ? curOvr.toJSON() : {};
        json.invisible = !display;
        this.overrideSubCategory(subCategoryId, imodeljs_common_1.SubCategoryOverride.fromJSON(json)); // will set the ChangeFlag appropriately
    }
    /** Returns true if this Viewport is currently displaying the model with the specified Id. */
    viewsModel(modelId) { return this.view.viewsModel(modelId); }
    /** Attempt to change the 2d Model this Viewport is displaying, if its ViewState is a ViewState2d.
     * @param baseModelId The Id of the new 2d Model to be displayed.
     * @param options options that determine how the new view is displayed
     * @note This function *only works* if the viewport is viewing a [[ViewState2d]], otherwise it does nothing. Also note that
     * the Model of baseModelId should be the same type (Drawing or Sheet) as the current view.
     * @note this method clones the current ViewState2d and sets its baseModelId to the supplied value. The DisplayStyle and CategorySelector remain unchanged.
     */
    async changeViewedModel2d(baseModelId, options) {
        if (!this.view.is2d)
            return;
        const newView = this.view.clone(); // start by cloning the current ViewState
        // NOTE: the cast below is necessary since baseModelId is marked as readonly after construction.
        //  We know this is a special case where it is safe to change it.
        newView.baseModelId = baseModelId; // change its baseModelId.
        await newView.load(); // make sure new model is loaded.
        this.changeView(newView); // switch this viewport to use new ViewState2d
        if (options && options.doFit) { // optionally fit view to the extents of the new model
            const range = await this.iModel.models.queryModelRanges([baseModelId]);
            this.zoomToVolume(geometry_core_1.Range3d.fromJSON(range[0]), options);
        }
    }
    /** Attempt to replace the set of models currently viewed by this viewport, if it is displaying a SpatialView
     * @param modelIds The Ids of the models to be displayed.
     * @returns false if this Viewport is not viewing a [[SpatialViewState]]
     * @note This function *only works* if the viewport is viewing a [[SpatialViewState]], otherwise it does nothing.
     */
    changeViewedModels(modelIds) {
        if (!this.view.isSpatialView())
            return false;
        this.view.modelSelector.models.clear();
        this.view.modelSelector.addModels(modelIds);
        this._changeFlags.setViewedModels();
        this.invalidateScene();
        return true;
    }
    /** Add or remove a set of models from those models currently displayed in this viewport.
     * @param modelIds The Ids of the models to add or remove.
     * @param display Whether or not to display the specified models in the viewport.
     * @returns false if this Viewport is not viewing a [[SpatialViewState]]
     * @note This function *only works* if the viewport is viewing a [[SpatialViewState]], otherwise it does nothing.
     */
    changeModelDisplay(models, display) {
        if (!this.view.isSpatialView())
            return false;
        const prevSize = this.view.modelSelector.models.size;
        if (display)
            this.view.modelSelector.addModels(models);
        else
            this.view.modelSelector.dropModels(models);
        if (this.view.modelSelector.models.size !== prevSize) {
            this._changeFlags.setViewedModels();
            this.invalidateScene();
        }
        return true;
    }
    /** @internal */
    get wantAntiAliasLines() { return 2 /* Off */; }
    /** @internal */
    get wantAntiAliasText() { return 0 /* Detect */; }
    /** Determines what type (if any) of debug graphics will be displayed to visualize [[Tile]] volumes.
     * @see [[Tile.DebugBoundingBoxes]]
     * @internal
     */
    get debugBoundingBoxes() { return this._debugBoundingBoxes; }
    set debugBoundingBoxes(boxes) {
        if (boxes !== this.debugBoundingBoxes) {
            this._debugBoundingBoxes = boxes;
            this.invalidateScene();
        }
    }
    /** When true, the scene will never be recreated. Chiefly for debugging purposes.
     * @internal
     */
    set freezeScene(freeze) {
        if (freeze !== this._freezeScene) {
            this._freezeScene = freeze;
            if (!freeze)
                this.invalidateScene();
        }
    }
    /** @internal */
    get analysisStyle() { return this.view.analysisStyle; }
    /** The iModel of this Viewport */
    get iModel() { return this.view.iModel; }
    /** @internal */
    get isPointAdjustmentRequired() { return this.view.is3d(); }
    /** @internal */
    get isSnapAdjustmentRequired() { return IModelApp_1.IModelApp.toolAdmin.acsPlaneSnapLock && this.view.is3d(); }
    /** @internal */
    get isContextRotationRequired() { return IModelApp_1.IModelApp.toolAdmin.acsContextLock; }
    /** Enables or disables "fade-out" mode. When this mode is enabled, transparent graphics are rendered with a flat alpha weight,
     * causing them to appear de-emphasized. This is typically used in contexts in which a handful of elements are to be emphasized in the view,
     * while the rest of the graphics are drawn transparently.
     */
    get isFadeOutActive() { return this._fadeOutActive; }
    set isFadeOutActive(active) {
        if (active !== this._fadeOutActive) {
            this._fadeOutActive = active;
            this.invalidateRenderPlan();
        }
    }
    dispose() {
        bentleyjs_core_1.assert(undefined !== this._target, "Double disposal of Viewport");
        this._target = bentleyjs_core_1.dispose(this._target);
        this.subcategories.dispose();
        IModelApp_1.IModelApp.tileAdmin.forgetViewport(this);
    }
    /** Enables or disables continuous rendering. Ideally, during each render frame a Viewport will do as little work as possible.
     * To make that possible, the viewport keeps track of what has changed about its internal state from one frame to the next.
     * For example, if the view frustum has not changed since the previous frame, it is likely that the viewport does not need to be
     * re-rendered at all.
     *
     * In some circumstances, it is desirable to bypass the logic that limits the amount of work performed each frame. A primary example
     * is a viewport that has some animations applied to it, or when diagnostic information like frames-per-second is being monitored.
     *
     * @note An application which enables continuous rendering should disable it as soon as it is no longer needed.
     */
    get continuousRendering() { return this._doContinuousRendering; }
    set continuousRendering(contRend) { this._doContinuousRendering = contRend; }
    /** This gives each Viewport a unique ID, which can be used for comparing and sorting Viewport objects inside collections.
     * @internal
     */
    get viewportId() { return this._viewportId; }
    /** The ViewState for this Viewport */
    get view() { return this._viewFrustum.view; }
    /** @internal */
    get pixelsPerInch() { /* ###TODO: This is apparently unobtainable information in a browser... */ return 96; }
    /** @internal */
    get backgroundMapPlane() { return this.view.displayStyle.backgroundMapPlane; }
    /** IDs of a set of elements which should not be rendered within this view.
     * @note Do not modify this set directly - use [[setNeverDrawn]] or [[clearNeverDrawn]] instead.
     * @note This set takes precedence over the [[alwaysDrawn]] set - if an element is present in both sets, it is never drawn.
     */
    get neverDrawn() { return this._neverDrawn; }
    /** IDs of a set of elements which should always be rendered within this view, regardless of category and subcategory visibility.
     * If the [[isAlwaysDrawnExclusive]] flag is also set, *only* those elements in this set will be drawn.
     * @note Do not modify this set directly - use [[setAlwaysDrawn]] or [[clearAlwaysDrawn]] instead.
     * @note The [[neverDrawn]] set takes precedence - if an element is present in both sets, it is never drawn.
     */
    get alwaysDrawn() { return this._alwaysDrawn; }
    /** Clear the set of always-drawn elements.
     * @see [[alwaysDrawn]]
     */
    clearAlwaysDrawn() {
        if ((undefined !== this.alwaysDrawn && 0 < this.alwaysDrawn.size) || this._alwaysDrawnExclusive) {
            if (undefined !== this.alwaysDrawn)
                this.alwaysDrawn.clear();
            this._alwaysDrawnExclusive = false;
            this._changeFlags.setAlwaysDrawn();
        }
    }
    /** Clear the set of never-drawn elements.
     * @see [[neverDrawn]]
     */
    clearNeverDrawn() {
        if (undefined !== this.neverDrawn && 0 < this.neverDrawn.size) {
            this.neverDrawn.clear();
            this._changeFlags.setNeverDrawn();
        }
    }
    /** Specify the IDs of a set of elements which should never be rendered within this view.
     * @see [[neverDrawn]].
     */
    setNeverDrawn(ids) {
        this._neverDrawn = ids;
        this._changeFlags.setNeverDrawn();
    }
    /** Specify the IDs of a set of elements which should always be rendered within this view, regardless of category and subcategory visibility.
     * @param ids The IDs of the elements to always draw.
     * @param exclusive If true, *only* the specified elements will be drawn.
     * @see [[alwaysDrawn]]
     * @see [[isAlwaysDrawnExclusive]]
     */
    setAlwaysDrawn(ids, exclusive = false) {
        this._alwaysDrawn = ids;
        this._alwaysDrawnExclusive = exclusive;
        this._changeFlags.setAlwaysDrawn();
    }
    /** Returns true if the set of elements in the [[alwaysDrawn]] set are the *only* elements rendered within this view. */
    get isAlwaysDrawnExclusive() { return this._alwaysDrawnExclusive; }
    /** Allows visibility of categories within this viewport to be overridden on a per-model basis.
     * @alpha
     */
    get perModelCategoryVisibility() { return this._perModelCategoryVisibility; }
    /** Adds visibility overrides for any subcategories whose visibility differs from that defined by the view's
     * category selector in the context of specific models.
     * @internal
     */
    addModelSubCategoryVisibilityOverrides(fs, ovrs) {
        this._perModelCategoryVisibility.addOverrides(fs, ovrs);
    }
    /** Sets an object which can customize the appearance of [[Feature]]s within a viewport.
     * If defined, the provider will be invoked whenever the overrides are determined to need updating.
     * The overrides can be explicitly marked as needing a refresh by calling [[Viewport.setFeatureOverrideProviderChanged]]. This is typically called when
     * the internal state of the provider changes such that the computed overrides must also change.
     * @see [[FeatureSymbology.Overrides]]
     */
    set featureOverrideProvider(provider) {
        if (provider !== this._featureOverrideProvider) {
            this._featureOverrideProvider = provider;
            this.setFeatureOverrideProviderChanged();
        }
    }
    /** Get the current FeatureOverrideProvider for this viewport if defined. */
    get featureOverrideProvider() {
        return this._featureOverrideProvider;
    }
    /** Notifies this viewport that the internal state of its [[FeatureOverrideProvider]] has changed such that its
     * [[FeatureSymbology.Overrides]] should be recomputed.
     */
    setFeatureOverrideProviderChanged() {
        this._changeFlags.setFeatureOverrideProvider();
    }
    /** Add a TiledGraphicsProvider
     * @internal
     */
    addTiledGraphicsProvider(type, provider) {
        if (undefined === this._tiledGraphicsProviders)
            this._tiledGraphicsProviders = new Map();
        if (undefined === this._tiledGraphicsProviders.get(type))
            this._tiledGraphicsProviders.set(type, new Set());
        this._tiledGraphicsProviders.get(type).add(provider);
    }
    /** Remove a TiledGraphicsProvider
     * @internal
     */
    removeTiledGraphicsProvider(type, provider) {
        if (undefined !== this._tiledGraphicsProviders && undefined !== this._tiledGraphicsProviders.get(type))
            this._tiledGraphicsProviders.get(type).delete(provider);
    }
    /** Get the tiled graphics providers for given type
     * @internal
     */
    getTiledGraphicsProviders(type) {
        return this._tiledGraphicsProviders ? this._tiledGraphicsProviders.get(type) : undefined;
    }
    /** @internal */
    setViewedCategoriesPerModelChanged() {
        this._changeFlags.setViewedCategoriesPerModel();
    }
    /** @internal */
    markSelectionSetDirty() { this._selectionSetDirty = true; }
    /** True if this is a 3d view with the camera turned on. */
    get isCameraOn() { return this.view.is3d() && this.view.isCameraOn; }
    /** @internal */
    invalidateDecorations() { this.sync.invalidateDecorations(); }
    /** @internal */
    invalidateRenderPlan() { this.sync.invalidateRenderPlan(); }
    /** @internal */
    changeDynamics(dynamics) {
        this.target.changeDynamics(dynamics);
        this.invalidateDecorations();
    }
    /** Set or clear the currently *flashed* element.
     * @param id The Id of the element to flash. If undefined, remove (un-flash) the currently flashed element
     * @param duration The amount of time, in seconds, the flash intensity will increase (see [[flashDuration]])
     * @internal
     */
    setFlashed(id, duration) {
        if (id !== this._flashedElem) {
            this.lastFlashedElem = this._flashedElem;
            this._flashedElem = id;
        }
        this.flashDuration = duration;
    }
    get auxCoordSystem() { return this.view.auxiliaryCoordinateSystem; }
    getAuxCoordRotation(result) { return this.auxCoordSystem.getRotation(result); }
    getAuxCoordOrigin(result) { return this.auxCoordSystem.getOrigin(result); }
    /** The number of outstanding requests for tiles to be displayed in this viewport.
     * @see Viewport.numSelectedTiles
     */
    get numRequestedTiles() { return IModelApp_1.IModelApp.tileAdmin.getNumRequestsForViewport(this); }
    /** @internal */
    toView(from, to) { this._viewFrustum.toView(from, to); }
    /** @internal */
    fromView(from, to) { this._viewFrustum.fromView(from, to); }
    /** Change the ViewState of this Viewport
     * @param view a fully loaded (see discussion at [[ViewState.load]] ) ViewState
     */
    changeView(view) {
        this.updateChangeFlags(view);
        this.doSetupFromView(view);
        this.invalidateScene();
        this.sync.invalidateController();
        this.target.reset();
    }
    /** @internal */
    invalidateScene() { this.sync.invalidateScene(); }
    /** Computes the range of npc depth values for a region of the screen
     * @param rect the rectangle to test. If undefined, test entire view
     * @param result optional DepthRangeNpc to store the result
     * @returns the minimum and maximum depth values within the region, or undefined.
     */
    determineVisibleDepthRange(rect, result) {
        if (result) { // Null result if given
            result.minimum = 1;
            result.maximum = 0;
        }
        // Default to a (0, 0, 0) to (1, 1, 1) range if no range was provided
        rect = (rect && rect.isValid) ? rect : this.viewRect;
        // Determine the screen rectangle in which to query visible depth min + max
        const readRect = rect.computeOverlap(this.viewRect);
        if (undefined === readRect)
            return undefined;
        let retVal;
        this.readPixels(readRect, 4 /* GeometryAndDistance */, (pixels) => {
            if (!pixels)
                return;
            let maximum = 0;
            let minimum = 1;
            const frac = this._viewFrustum.frustFraction;
            for (let x = readRect.left; x < readRect.right; ++x) {
                for (let y = readRect.top; y < readRect.bottom; ++y) {
                    let npcZ = pixels.getPixel(x, y).distanceFraction;
                    if (npcZ <= 0.0)
                        continue;
                    if (frac < 1.0)
                        npcZ *= frac / (1.0 + npcZ * (frac - 1.0));
                    minimum = Math.min(minimum, npcZ);
                    maximum = Math.max(maximum, npcZ);
                }
            }
            if (maximum <= 0)
                return;
            if (undefined === result) {
                result = { minimum, maximum };
            }
            else {
                result.minimum = minimum;
                result.maximum = maximum;
            }
            retVal = result;
        });
        return retVal;
    }
    /** Turn the camera on if it is currently off. If the camera is already on, adjust it to use the supplied lens angle.
     * @param lensAngle The lens angle for the camera. If undefined, use view.camera.lens.
     * @note This method will fail if the ViewState is not 3d.
     */
    turnCameraOn(lensAngle) {
        const view = this.view;
        if (!view.is3d())
            return ViewState_1.ViewStatus.InvalidViewport;
        if (!lensAngle)
            lensAngle = view.camera.lens;
        imodeljs_common_1.Camera.validateLensAngle(lensAngle);
        if (view.isCameraOn)
            return view.lookAtUsingLensAngle(view.getEyePoint(), view.getTargetPoint(), view.getYVector(), lensAngle);
        // We need to figure out a new camera target. To do that, we need to know where the geometry is in the view.
        // We use the depth of the center of the view for that.
        let depthRange = this.determineVisibleDepthRange();
        if (!depthRange)
            depthRange = { minimum: 0, maximum: 1 };
        const middle = depthRange.minimum + ((depthRange.maximum - depthRange.minimum) / 2.0);
        const corners = [
            new geometry_core_1.Point3d(0.0, 0.0, middle),
            new geometry_core_1.Point3d(1.0, 1.0, middle),
            new geometry_core_1.Point3d(0.0, 0.0, depthRange.maximum),
            new geometry_core_1.Point3d(1.0, 1.0, depthRange.maximum),
        ];
        this.npcToWorldArray(corners);
        const eye = corners[2].interpolate(0.5, corners[3]); // middle of closest plane
        const target = corners[0].interpolate(0.5, corners[1]); // middle of halfway plane
        const backDist = eye.distance(target) * 2.0;
        const frontDist = view.minimumFrontDistance();
        return view.lookAtUsingLensAngle(eye, target, view.getYVector(), lensAngle, frontDist, backDist);
    }
    /** Orient this viewport to one of the [[StandardView]] rotations. */
    setStandardRotation(id) {
        this.view.setStandardRotation(id);
        this.setupFromView();
    }
    doSetupFromView(view) {
        const vf = ViewFrustum.createFromViewport(this, view);
        if (undefined === vf)
            return ViewState_1.ViewStatus.InvalidViewport;
        this._viewFrustum = vf;
        this.sync.invalidateRenderPlan();
        this.sync.setValidController();
        this.onViewChanged.raiseEvent(this);
        return ViewState_1.ViewStatus.Success;
    }
    /** Establish the parameters of this Viewport from the current information in its ViewState */
    setupFromView() {
        return this.doSetupFromView(this.view);
    }
    /** Call [[setupFromView]] on this Viewport and optionally save previous state in view undo stack */
    synchWithView(_saveInUndo) { this.setupFromView(); }
    /** Convert an array of points from CoordSystem.View to CoordSystem.Npc */
    viewToNpcArray(pts) { this._viewFrustum.viewToNpcArray(pts); }
    /** Convert an array of points from CoordSystem.Npc to CoordSystem.View */
    npcToViewArray(pts) { this._viewFrustum.npcToViewArray(pts); }
    /** Convert a point from CoordSystem.View to CoordSystem.Npc
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    viewToNpc(pt, out) { return this._viewFrustum.viewToNpc(pt, out); }
    /** Convert a point from CoordSystem.Npc to CoordSystem.View
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    npcToView(pt, out) { return this._viewFrustum.npcToView(pt, out); }
    /** Convert an array of points from CoordSystem.World to CoordSystem.Npc */
    worldToNpcArray(pts) { this._viewFrustum.worldToNpcArray(pts); }
    /** Convert an array of points from CoordSystem.Npc to CoordSystem.World */
    npcToWorldArray(pts) { this._viewFrustum.npcToWorldArray(pts); }
    /** Convert an array of points from CoordSystem.World to CoordSystem.View */
    worldToViewArray(pts) { this._viewFrustum.worldToViewArray(pts); }
    /** Convert an array of points from CoordSystem.World to CoordSystem.View, as Point4ds */
    worldToView4dArray(worldPts, viewPts) { this._viewFrustum.worldToView4dArray(worldPts, viewPts); }
    /** Convert an array of points from CoordSystem.View to CoordSystem.World */
    viewToWorldArray(pts) { this._viewFrustum.viewToWorldArray(pts); }
    /** Convert an array of points from CoordSystem.View as Point4ds to CoordSystem.World */
    view4dToWorldArray(viewPts, worldPts) { this._viewFrustum.view4dToWorldArray(viewPts, worldPts); }
    /** Convert a point from CoordSystem.World to CoordSystem.Npc
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    worldToNpc(pt, out) { return this._viewFrustum.worldToNpc(pt, out); }
    /** Convert a point from CoordSystem.Npc to CoordSystem.World
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    npcToWorld(pt, out) { return this._viewFrustum.npcToWorld(pt, out); }
    /** Convert a point from CoordSystem.World to CoordSystem.View
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    worldToView(input, out) { return this._viewFrustum.worldToView(input, out); }
    /** Convert a point from CoordSystem.World to CoordSystem.View as Point4d
     * @param input the point to convert
     * @param out optional location for result. If undefined, a new Point4d is created.
     */
    worldToView4d(input, out) { return this._viewFrustum.worldToView4d(input, out); }
    /** Convert a point from CoordSystem.View to CoordSystem.World
     * @param pt the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    viewToWorld(input, out) { return this._viewFrustum.viewToWorld(input, out); }
    /** Convert a point from CoordSystem.View as a Point4d to CoordSystem.View
     * @param input the point to convert
     * @param out optional location for result. If undefined, a new Point3d is created.
     */
    view4dToWorld(input, out) { return this._viewFrustum.view4dToWorld(input, out); }
    /** Converts inches to pixels based on screen DPI.
     * @Note this information may not be accurate in some browsers.
     * @param inches the number of inches to convert
     * @returns the corresponding number of pixels
     */
    pixelsFromInches(inches) { return inches * this.pixelsPerInch; }
    /** Get an 8-point Frustum corresponding to the 8 corners of the Viewport in the specified coordinate system.
     *
     * There are two sets of corners that may be of interest.
     * The "adjusted" box is the one that is computed by examining the "viewed extents" and moving
     * the front and back planes to enclose everything in the view.
     * The "unadjusted" box is the one that is stored in the ViewState.
     * @param sys Coordinate system for points
     * @param adjustedBox If true, retrieve the adjusted box. Otherwise retrieve the box that came from the view definition.
     * @param box optional Frustum for return value
     * @return the view frustum
     * @note The "adjusted" box may be either larger or smaller than the "unadjusted" box.
     */
    getFrustum(sys = CoordSystem.World, adjustedBox = true, box) { return this._viewFrustum.getFrustum(sys, adjustedBox, box); }
    /** Get a copy of the current (adjusted) frustum of this viewport, in world coordinates. */
    getWorldFrustum(box) { return this.getFrustum(CoordSystem.World, true, box); }
    finishViewChange(startFrust, options) {
        options = options === undefined ? {} : options;
        this.synchWithView(options.saveInUndo === undefined || options.saveInUndo);
        if (options.animateFrustumChange === undefined || options.animateFrustumChange)
            this.animateFrustumChange(startFrust, this.getFrustum(), options.animationTime);
    }
    /** Scroll the view by a given number of pixels.
     * @param screenDist distance to scroll, in pixels
     */
    scroll(screenDist, options) {
        const view = this.view;
        if (!view)
            return;
        const startFrust = this.getFrustum().clone();
        if (view.is3d() && view.isCameraOn) {
            const offset = new geometry_core_1.Vector3d(screenDist.x, screenDist.y, 0.0);
            const frust = this.getFrustum(CoordSystem.View, false);
            frust.translate(offset);
            this.viewToWorldArray(frust.points);
            view.setupFromFrustum(frust);
            view.centerEyePoint();
        }
        else {
            const pts = [new geometry_core_1.Point3d(), new geometry_core_1.Point3d(screenDist.x, screenDist.y, 0)];
            this.viewToWorldArray(pts);
            const dist = pts[1].minus(pts[0]);
            const newOrg = view.getOrigin().plus(dist);
            view.setOrigin(newOrg);
        }
        this.finishViewChange(startFrust, options);
    }
    /** Zoom the view by a scale factor, placing the new center at the projection of the given point (world coordinates)
     * on the focal plane.
     * Updates ViewState and re-synchs Viewport. Does not save in view undo buffer.
     */
    zoom(newCenter, factor, options) {
        const view = this.view;
        if (!view)
            return;
        const startFrust = this.getFrustum().clone();
        if (view.is3d() && view.isCameraOn) {
            const centerNpc = newCenter ? this.worldToNpc(newCenter) : imodeljs_common_1.NpcCenter.clone();
            const scaleTransform = geometry_core_1.Transform.createFixedPointAndMatrix(centerNpc, geometry_core_1.Matrix3d.createScale(factor, factor, 1.0));
            const offset = centerNpc.minus(imodeljs_common_1.NpcCenter); // offset by difference of old/new center
            offset.z = 0.0; // z center stays the same.
            const offsetTransform = geometry_core_1.Transform.createTranslationXYZ(offset.x, offset.y, offset.z);
            const product = offsetTransform.multiplyTransformTransform(scaleTransform);
            const frust = new imodeljs_common_1.Frustum();
            product.multiplyPoint3dArrayInPlace(frust.points);
            this.npcToWorldArray(frust.points);
            view.setupFromFrustum(frust);
            view.centerEyePoint();
        }
        else {
            // for non-camera views, do the zooming by adjusting the origin and delta directly so there can be no
            // chance of the rotation changing due to numerical precision errors calculating it from the frustum corners.
            const delta = view.getExtents().clone();
            delta.x *= factor;
            delta.y *= factor;
            // first check to see whether the zoom operation results in an invalid view. If so, make sure we don't change anything
            view.validateViewDelta(delta, true);
            const center = newCenter ? newCenter.clone() : view.getCenter().clone();
            if (!view.allow3dManipulations())
                center.z = 0.0;
            const newOrg = view.getOrigin().clone();
            this.toView(newOrg);
            this.toView(center);
            view.setExtents(delta);
            newOrg.x = center.x - delta.x / 2.0;
            newOrg.y = center.y - delta.y / 2.0;
            this.fromView(newOrg);
            view.setOrigin(newOrg);
        }
        this.finishViewChange(startFrust, options);
    }
    /** Zoom the view to a show the tightest box around a given set of PlacementProps. Optionally, change view rotation.
     * @param props array of PlacementProps. Will zoom to the union of the placements.
     * @param options options that control how the view change works and whether to change view rotation.
     */
    zoomToPlacementProps(placementProps, options) {
        if (placementProps.length === 0)
            return;
        const hasAngle = (arg) => arg.angle !== undefined;
        if (undefined !== options) {
            if (undefined !== options.standardViewId) {
                this.view.setStandardRotation(options.standardViewId);
            }
            else if (undefined !== options.placementRelativeId) {
                const firstProps = placementProps[0];
                const firstPlacement = hasAngle(firstProps) ? imodeljs_common_1.Placement2d.fromJSON(firstProps) : imodeljs_common_1.Placement3d.fromJSON(firstProps);
                const viewRotation = StandardView_1.StandardView.getStandardRotation(options.placementRelativeId).clone();
                viewRotation.multiplyMatrixMatrixTranspose(firstPlacement.transform.matrix, viewRotation);
                this.view.setRotation(viewRotation);
            }
            else if (undefined !== options.viewRotation) {
                this.view.setRotation(options.viewRotation);
            }
        }
        const viewTransform = geometry_core_1.Transform.createOriginAndMatrix(undefined, this.view.getRotation());
        const frust = new imodeljs_common_1.Frustum();
        const viewRange = new geometry_core_1.Range3d();
        for (const props of placementProps) {
            const placement = hasAngle(props) ? imodeljs_common_1.Placement2d.fromJSON(props) : imodeljs_common_1.Placement3d.fromJSON(props);
            viewRange.extendArray(placement.getWorldCorners(frust).points, viewTransform);
        }
        this.view.lookAtViewAlignedVolume(viewRange, this.viewRect.aspect, options ? options.marginPercent : undefined);
        this.finishViewChange(this.getFrustum().clone(), options);
    }
    /** Zoom the view to a show the tightest box around a given set of ElementProps. Optionally, change view rotation.
     * @param props element props. Will zoom to the union of the placements.
     * @param options options that control how the view change works and whether to change view rotation.
     */
    zoomToElementProps(elementProps, options) {
        if (elementProps.length === 0)
            return;
        const placementProps = [];
        for (const props of elementProps) {
            if (props.placement !== undefined && this.view.viewsModel(props.model))
                placementProps.push(props.placement);
        }
        this.zoomToPlacementProps(placementProps, options);
    }
    /** Zoom the view to a show the tightest box around a given set of elements. Optionally, change view rotation.
     * @param ids the element id(s) to include. Will zoom to the union of the placements.
     * @param options options that control how the view change works and whether to change view rotation.
     */
    async zoomToElements(ids, options) {
        this.zoomToElementProps(await this.iModel.elements.getProps(ids), options);
    }
    /** Zoom the view to a volume of space in world coordinates.
     * @param volume The low and high corners, in world coordinates.
     * @param options options that control how the view change works
     */
    zoomToVolume(volume, options) {
        this.view.lookAtVolume(volume, this.viewRect.aspect, options ? options.marginPercent : undefined);
        this.finishViewChange(this.getFrustum().clone(), options);
    }
    /** Shortcut to call view.setupFromFrustum and then [[setupFromView]]
     * @param inFrustum the new viewing frustum
     * @returns true if both steps were successful
     */
    setupViewFromFrustum(inFrustum) {
        const validSize = this.view.setupFromFrustum(inFrustum);
        // note: always call setupFromView, even if setupFromFrustum failed
        return (ViewState_1.ViewStatus.Success === this.setupFromView() && ViewState_1.ViewStatus.Success === validSize);
    }
    /** @internal */
    computeViewRange() {
        this.setupFromView(); // can't proceed if viewport isn't valid (not active)
        return this.view.computeFitRange();
    }
    /** @internal */
    animate() {
        if (this._animator && this._animator.animate())
            this._animator = undefined;
    }
    /** @internal */
    removeAnimator() { this.setAnimator(undefined); }
    setAnimator(animator) {
        if (this._animator)
            this._animator.interrupt(); // will be destroyed
        this._animator = animator;
    }
    /** @internal */
    animateFrustumChange(start, end, animationTime) {
        if (!animationTime || 0.0 >= animationTime.milliseconds)
            animationTime = Tool_1.ToolSettings.animationTime;
        this.setAnimator(new Animator(animationTime, this, start, end));
    }
    /** @internal */
    applyViewState(val, animationTime) {
        this.updateChangeFlags(val);
        const startFrust = this.getFrustum();
        this._viewFrustum.view = val;
        this.synchWithView(false);
        if (animationTime)
            this.animateFrustumChange(startFrust, this.getFrustum(), animationTime);
    }
    /** Invoked from applyViewState and changeView to potentially recompute change flags based on differences between current and new ViewState. */
    updateChangeFlags(newView) {
        // Before the first call to changeView, this.view is undefined because we have no frustum. Our API pretends it is never undefined.
        const oldView = undefined !== this.viewFrustum ? this.view : undefined;
        if (undefined === oldView || oldView === newView)
            return;
        const flags = this._changeFlags;
        if (!flags.displayStyle && !oldView.displayStyle.equalState(newView.displayStyle))
            flags.setDisplayStyle();
        if (!flags.viewedCategories && !oldView.categorySelector.equalState(newView.categorySelector))
            flags.setViewedCategories();
        if (!flags.neverDrawn) {
            const oldExclude = oldView.displayStyle.settings.excludedElements;
            const newExclude = newView.displayStyle.settings.excludedElements;
            if (oldExclude.size !== newExclude.size) {
                flags.setNeverDrawn();
            }
            else {
                for (const exclude of oldExclude)
                    if (!newExclude.has(exclude)) {
                        flags.setNeverDrawn();
                        break;
                    }
            }
        }
        if (flags.viewedModels)
            return;
        if (oldView.is2d() && newView.is2d()) {
            if (oldView.baseModelId !== newView.baseModelId)
                flags.setViewedModels();
        }
        else if (oldView.isSpatialView() && newView.isSpatialView()) {
            if (!oldView.modelSelector.equalState(newView.modelSelector))
                flags.setViewedModels();
        }
        else {
            // switched between 2d and 3d view.
            flags.setViewedModels();
        }
    }
    static roundGrid(num, units) {
        const sign = ((num * units) < 0.0) ? -1.0 : 1.0;
        num = (num * sign) / units + 0.5;
        return units * sign * Math.floor(num);
    }
    getGridOrientation(origin, rMatrix) {
        if (this.view.isSpatialView())
            origin.setFrom(this.iModel.globalOrigin);
        switch (this.view.getGridOrientation()) {
            case ViewState_1.GridOrientationType.View: {
                const center = this.view.getCenter();
                this.toView(center);
                this.toView(origin);
                origin.z = center.z;
                this.fromView(origin);
                break;
            }
            case ViewState_1.GridOrientationType.WorldXY:
                break;
            case ViewState_1.GridOrientationType.WorldYZ: {
                geometry_core_1.Matrix3d.createRows(rMatrix.getRow(1), rMatrix.getRow(2), rMatrix.getRow(0), rMatrix);
                break;
            }
            case ViewState_1.GridOrientationType.WorldXZ: {
                geometry_core_1.Matrix3d.createRows(rMatrix.getRow(0), rMatrix.getRow(2), rMatrix.getRow(1), rMatrix);
                break;
            }
        }
    }
    pointToStandardGrid(point, rMatrix, origin) {
        const planeNormal = rMatrix.getRow(2);
        let eyeVec;
        if (this.view.is3d() && this.isCameraOn)
            eyeVec = this.view.camera.eye.vectorTo(point);
        else
            eyeVec = this._viewFrustum.rotation.getRow(2).clone();
        eyeVec.normalizeInPlace();
        linePlaneIntersect(point, point, eyeVec, origin, planeNormal, false);
        // // get origin and point in view coordinate system
        const pointView = point.clone();
        const originView = origin.clone();
        this.toView(pointView);
        this.toView(originView);
        // subtract off the origin
        pointView.y -= originView.y;
        pointView.x -= originView.x;
        // round off the remainder to the grid distances
        const gridSpacing = this.view.getGridSpacing();
        pointView.x = Viewport.roundGrid(pointView.x, gridSpacing.x);
        pointView.y = Viewport.roundGrid(pointView.y, gridSpacing.y);
        // add the origin back in
        pointView.x += originView.x;
        pointView.y += originView.y;
        // go back to root coordinate system
        this.fromView(pointView);
        point.setFrom(pointView);
    }
    /** @internal */
    pointToGrid(point) {
        if (ViewState_1.GridOrientationType.AuxCoord === this.view.getGridOrientation()) {
            this.pointToStandardGrid(point, this.getAuxCoordRotation(), this.getAuxCoordOrigin());
            return;
        }
        const origin = new geometry_core_1.Point3d();
        const rMatrix = geometry_core_1.Matrix3d.createIdentity();
        this.getGridOrientation(origin, rMatrix);
        this.pointToStandardGrid(point, rMatrix, origin);
    }
    /** Get the width of a pixel (a unit vector in the x direction in view coordinates) at a given point in world coordinates, returning the result in meters (world units).
     *
     * This is most useful to determine how large something is in a view. In particular, in a perspective view
     * the result of this method will be a larger number for points closer to the back of the view Frustum (that is,
     * one pixel of the view represents more spatial area at the back of the Frustum than the front.)
     * @param point The point to test, in World coordinates. If undefined, the center of the view in NPC space is used.
     * @returns The width of a view pixel at the supplied world point, in meters.
     */
    getPixelSizeAtPoint(point) {
        if (point === undefined)
            point = this.npcToWorld(imodeljs_common_1.NpcCenter); // if undefined, use center of view
        const worldPts = [];
        const viewPts = [];
        viewPts[0] = this.worldToView4d(point);
        viewPts[1] = viewPts[0].clone();
        viewPts[1].x += viewPts[1].w; // form a vector one pixel wide in x direction.
        this.view4dToWorldArray(viewPts, worldPts);
        return worldPts[0].distance(worldPts[1]);
    }
    get _wantInvertBlackAndWhite() {
        const bgColor = this.view.backgroundColor.colors;
        return ((bgColor.r + bgColor.g + bgColor.b) > (255 * 3) / 2);
    }
    /** Get a color that will contrast to the current background color of this Viewport. Either Black or White depending on which will have the most contrast. */
    getContrastToBackgroundColor() {
        return this._wantInvertBlackAndWhite ? imodeljs_common_1.ColorDef.black : imodeljs_common_1.ColorDef.white; // should we use black or white?
    }
    processFlash() {
        let needsFlashUpdate = false;
        if (this._flashedElem !== this.lastFlashedElem) {
            this.flashIntensity = 0.0;
            this.flashUpdateTime = bentleyjs_core_1.BeTimePoint.now();
            this.lastFlashedElem = this._flashedElem; // flashing has begun; this is now the previous flash
            needsFlashUpdate = this._flashedElem === undefined; // notify render thread that flash has been turned off (signified by undefined elem)
        }
        if (this._flashedElem !== undefined && this.flashIntensity < 1.0) {
            const flashDuration = bentleyjs_core_1.BeDuration.fromSeconds(this.flashDuration);
            const flashElapsed = bentleyjs_core_1.BeTimePoint.now().milliseconds - this.flashUpdateTime.milliseconds;
            this.flashIntensity = Math.min(flashElapsed, flashDuration.milliseconds) / flashDuration.milliseconds; // how intense do we want the flash effect to be from [0..1]?
            needsFlashUpdate = true;
        }
        return needsFlashUpdate;
    }
    /** @internal */
    createSceneContext() { return new ViewContext_1.SceneContext(this); }
    /** @internal */
    renderFrame() {
        const changeFlags = this._changeFlags;
        if (changeFlags.hasChanges)
            this._changeFlags = new ChangeFlags(ChangeFlag.None);
        const sync = this.sync;
        const view = this.view;
        const target = this.target;
        // Start timer for tile loading time
        const timer = new bentleyjs_core_1.StopWatch(undefined, true);
        this.animate();
        // Allow ViewState instance to change any state which might affect logic below...
        view.onRenderFrame(this);
        let isRedrawNeeded = sync.isRedrawPending || this._doContinuousRendering;
        sync.invalidateRedrawPending();
        if (target.updateViewRect()) {
            target.onResized();
            sync.invalidateController();
        }
        if (this._selectionSetDirty) {
            target.setHiliteSet(view.iModel.hilited);
            this._selectionSetDirty = false;
            isRedrawNeeded = true;
        }
        let overridesNeeded = changeFlags.areFeatureOverridesDirty;
        if (!sync.isValidAnimationFraction) {
            target.animationFraction = this.animationFraction;
            isRedrawNeeded = true;
            sync.setValidAnimationFraction();
            const scheduleScript = view.displayStyle.scheduleScript;
            if (scheduleScript) {
                const scheduleTime = scheduleScript.duration.fractionToPoint(target.animationFraction);
                if (scheduleTime !== this._scheduleTime) {
                    this._scheduleTime = scheduleTime;
                    target.animationBranches = scheduleScript.getAnimationBranches(scheduleTime);
                    if (scheduleScript.containsFeatureOverrides)
                        overridesNeeded = true;
                }
            }
        }
        if (overridesNeeded) {
            const ovr = new FeatureSymbology_1.FeatureSymbology.Overrides(this);
            target.overrideFeatureSymbology(ovr);
            isRedrawNeeded = true;
        }
        if (!sync.isValidController)
            this.setupFromView();
        if (!sync.isValidScene) {
            if (!this._freezeScene) {
                this.numSelectedTiles = this.numReadyTiles = 0;
                const context = this.createSceneContext();
                view.createClassification(context);
                view.createScene(context);
                view.createBackgroundMap(context);
                view.createProviderGraphics(context);
                view.createSolarShadowMap(context);
                context.requestMissingTiles();
                target.changeScene(context.graphics);
                target.changeBackgroundMap(context.backgroundGraphics);
                target.changePlanarClassifiers(context.planarClassifiers);
                target.changeSolarShadowMap(context.solarShadowMap);
                isRedrawNeeded = true;
            }
            sync.setValidScene();
        }
        if (!sync.isValidRenderPlan) {
            target.changeRenderPlan(System_1.RenderPlan.createFromViewport(this));
            sync.setValidRenderPlan();
            isRedrawNeeded = true;
        }
        if (!sync.isValidDecorations) {
            const decorations = new System_1.Decorations();
            this.addDecorations(decorations);
            target.changeDecorations(decorations);
            isRedrawNeeded = true;
        }
        if (this.processFlash()) {
            target.setFlashed(undefined !== this._flashedElem ? this._flashedElem : bentleyjs_core_1.Id64.invalid, this.flashIntensity);
            isRedrawNeeded = true;
        }
        timer.stop();
        if (isRedrawNeeded) {
            target.drawFrame(timer.elapsed.milliseconds);
            this.onRender.raiseEvent(this);
        }
        // Dispatch change events after timer has stopped and update has finished.
        if (changeFlags.hasChanges) {
            this.onViewportChanged.raiseEvent(this, changeFlags);
            if (changeFlags.displayStyle)
                this.onDisplayStyleChanged.raiseEvent(this);
            if (changeFlags.viewedModels)
                this.onViewedModelsChanged.raiseEvent(this, changeFlags);
            if (changeFlags.areFeatureOverridesDirty) {
                this.onFeatureOverridesChanged.raiseEvent(this);
                if (changeFlags.alwaysDrawn)
                    this.onAlwaysDrawnChanged.raiseEvent(this);
                if (changeFlags.neverDrawn)
                    this.onNeverDrawnChanged.raiseEvent(this);
                if (changeFlags.viewedCategories)
                    this.onViewedCategoriesChanged.raiseEvent(this);
                if (changeFlags.viewedCategoriesPerModel)
                    this.onViewedCategoriesPerModelChanged.raiseEvent(this);
                if (changeFlags.featureOverrideProvider)
                    this.onFeatureOverrideProviderChanged.raiseEvent(this);
            }
        }
        return true;
    }
    /** @internal */
    addDecorations(_decorations) { }
    /** Read selected data about each pixel within a rectangular region of this Viewport.
     * @param rect The area of the viewport's contents to read. The origin specifies the upper-left corner. Must lie entirely within the viewport's dimensions.
     * @param selector Specifies which aspect(s) of data to read.
     * @param receiver A function accepting a [[Pixel.Buffer]] object from which the selected data can be retrieved, or receiving undefined if the viewport is not active, the rect is out of bounds, or some other error.
     * @param excludeNonLocatable If true, geometry with the "non-locatable" flag set will not be drawn.
     * @note The [[Pixel.Buffer]] supplied to the `receiver` function becomes invalid once that function exits. Do not store a reference to it.
     * @beta
     */
    readPixels(rect, selector, receiver, excludeNonLocatable = false) {
        const viewRect = this.viewRect;
        if (!rect.isContained(viewRect))
            receiver(undefined);
        else
            this.target.readPixels(rect, selector, receiver, excludeNonLocatable);
    }
    /** Read the current image from this viewport from the rendering system. If a view rectangle outside the actual view is specified, the entire view is captured.
     * @param rect The area of the view to read. The origin of a viewRect must specify the upper left corner.
     * @param targetSize The size of the image to be returned. The size can be larger or smaller than the original view.
     * @param flipVertically If true, the image is flipped along the x-axis.
     * @returns The contents of the viewport within the specified rectangle as a bitmap image, or undefined if the image could not be read.
     * @note By default the image is returned upside-down. Pass `true` for `flipVertically` to flip it along the x-axis.
     */
    readImage(rect = new ViewRect(0, 0, -1, -1), targetSize = geometry_core_1.Point2d.createZero(), flipVertically = false) {
        return this.target.readImage(rect, targetSize, flipVertically);
    }
    /** Get the point at the specified x and y location in the pixel buffer in npc coordinates
     * @beta
     */
    getPixelDataNpcPoint(pixels, x, y, out) {
        const z = pixels.getPixel(x, y).distanceFraction;
        if (z <= 0.0)
            return undefined;
        const vf = this._viewFrustum;
        const result = undefined !== out ? out : new geometry_core_1.Point3d();
        const viewRect = this.viewRect;
        result.x = (x + 0.5 - viewRect.left) / viewRect.width;
        result.y = 1.0 - (y + 0.5 - viewRect.top) / viewRect.height;
        if (vf.frustFraction < 1.0)
            result.z = z * vf.frustFraction / (1.0 + z * (vf.frustFraction - 1.0)); // correct to npc if camera on.
        else
            result.z = z;
        return result;
    }
    /** Get the point at the specified x and y location in the pixel buffer in world coordinates
     * @beta
     */
    getPixelDataWorldPoint(pixels, x, y, out) {
        const npc = this.getPixelDataNpcPoint(pixels, x, y, out);
        if (undefined !== npc)
            this.npcToWorld(npc, npc);
        return npc;
    }
}
/** Maximum ratio of frontplane to backplane distance for 24 bit zbuffer.
 * @internal
 */
Viewport.nearScale24 = 0.0003;
/** Don't allow entries in the view undo buffer unless they're separated by more than this amount of time. */
Viewport.undoDelay = bentleyjs_core_1.BeDuration.fromSeconds(.5);
Viewport._nextViewportId = 1;
exports.Viewport = Viewport;
/** An interactive Viewport that exists within an HTMLDivElement. ScreenViewports can receive HTML events.
 * To render the contents of a ScreenViewport, it must be added to the [[ViewManager]] via ViewManager.addViewport().
 * Every frame, the ViewManager will update the Viewport's state and re-render its contents if anything has changed.
 * To halt this loop, use ViewManager.dropViewport() to remove the viewport from the ViewManager.
 *
 * A ScreenViewport internally owns significant WebGL resources which must be explicitly disposed of when the viewport is no longer needed.
 * This is achieved by invoking the viewport's dispose() method. ViewManager.dropViewport() invokes dispose() on the viewport by default.
 *
 * The lifetime of a ScreenViewport typically follows a pattern:
 * ```
 *  1. Application creates the viewport via ScreenViewport.create()
 *  2. The viewport is added to the render loop via ViewManager.addViewport()
 *  3. When the application is finished with the viewport, it removes it from the render loop and disposes of it via ViewManager.dropViewport().
 * ```
 *
 * In some cases it may be useful to temporarily suspend a viewport's render loop. In this case the lifetime of the viewport proceeds as follows:
 * ```
 *  1. Application creates the viewport via ScreenViewport.create()
 *  2. The viewport is added to the render loop via ViewManager.addViewport()
 *  3. At some point the render loop is suspended via ViewManager.dropViewport(viewport, false), indicating the viewport should not be disposed.
 *  4. Optionally, resume rendering by returning to step 2.
 *  5. When the application is finished with the viewport:
 *    5a. If it is currently registered with the ViewManager, it is dropped and disposed of via ViewManager.dropViewport()
 *    5b. Otherwise, it is disposed of by invoking its dispose() method directly.
 * ```
 * @public
 */
class ScreenViewport extends Viewport {
    /** @internal */
    constructor(canvas, parentDiv, target) {
        super(target);
        /** The number of entries in the view undo/redo buffer. */
        this.maxUndoSteps = 20;
        this._forwardStack = [];
        this._backStack = [];
        this.canvas = canvas;
        this.parentDiv = parentDiv;
        // first remove all children of the parent Div
        ScreenViewport.removeAllChildren(parentDiv);
        const div = this.vpDiv = document.createElement("div");
        div.className = "imodeljs-vp";
        this.addChildDiv(this.parentDiv, div, 0);
        this.addChildDiv(this.vpDiv, canvas, 10);
        this.target.updateViewRect();
        this.decorationDiv = this.addNewDiv("overlay-decorators", true, 30);
        this.toolTipDiv = this.addNewDiv("overlay-tooltip", false, 40);
        this.setCursor();
    }
    /** Create a new ScreenViewport that shows a View of an iModel into an HTMLDivElement. This method will create a new HTMLCanvasElement as a child of the supplied parentDiv.
     * It also creates two new child HTMLDivElements: one of class "overlay-decorators" for HTML overlay decorators, and one of class
     * "overlay-tooltip" for ToolTips. All the new child HTMLElements are the same size as the parentDiv.
     * @param parentDiv The HTMLDivElement to contain the ScreenViewport. The element must have non-zero width and height.
     * @param view The ViewState for the ScreenViewport.
     * @note After creating a new ScreenViewport, you must call [[ViewManager.addViewport]] for it to become "live". You must also ensure you dispose of it properly.
     * @throws Error if `parentDiv` has zero width or height.
     */
    static create(parentDiv, view) {
        if (0 === parentDiv.clientWidth || 0 === parentDiv.clientHeight)
            throw new Error("viewport cannot be created from a div with zero width or height");
        const canvas = document.createElement("canvas");
        const vp = new this(canvas, parentDiv, IModelApp_1.IModelApp.renderSystem.createTarget(canvas));
        vp.changeView(view);
        return vp;
    }
    /** Remove all of the children of an HTMLDivElement.
     * @internal
     */
    static removeAllChildren(el) {
        while (el.lastChild)
            el.removeChild(el.lastChild);
    }
    /** set Div style to absolute, {0,0,100%,100%}
     * @internal
     */
    static setToParentSize(div) {
        const style = div.style;
        style.position = "absolute";
        style.top = style.left = "0";
        style.height = style.width = "100%";
    }
    /**  add a child element to this.vpDiv and set its size and position the same as the parent.  */
    addChildDiv(parent, element, zIndex) {
        ScreenViewport.setToParentSize(element);
        // get the (computed) z-index value of the parent, as an integer.
        const parentZ = parseInt(window.getComputedStyle(this.vpDiv).zIndex || "0", 10);
        element.style.zIndex = (parentZ + zIndex).toString();
        parent.appendChild(element);
    }
    /** @internal */
    addNewDiv(className, overflowHidden, z) {
        const div = document.createElement("div");
        div.className = className;
        div.style.pointerEvents = "none";
        div.style.overflow = overflowHidden ? "hidden" : "visible";
        this.addChildDiv(this.vpDiv, div, z);
        return div;
    }
    /** Open the toolTip window in this ScreenViewport with the supplied message and location. The tooltip will be a child of [[ScreenViewport.toolTipDiv]].
     * @param message The message to display
     * @param location The position of the toolTip, in view coordinates. If undefined, use center of view.
     * @param options the ToolTip options
     * @note There is only one ToolTip window, so calling this method more than once will move the toolTip and show the second message.
     */
    openToolTip(message, location, options) {
        IModelApp_1.IModelApp.notifications.openToolTip(this.toolTipDiv, message, location, options);
    }
    /** Set the event controller for this Viewport. Destroys previous controller, if one was defined. */
    setEventController(controller) { if (this._evController) {
        this._evController.destroy();
    } this._evController = controller; }
    /** Find a point on geometry visible in this Viewport, within a radius of supplied pick point.
     * @param pickPoint Point to search about, in world coordinates
     * @param radius Radius, in pixels, of the circular area to search.
     * @param allowNonLocatable If true, include geometry with non-locatable flag set.
     * @param out Optional Point3d to hold the result. If undefined, a new Point3d is returned.
     * @returns The point, in world coordinates, on the element closest to `pickPoint`, or undefined if no elements within `radius`.
     */
    pickNearestVisibleGeometry(pickPoint, radius, allowNonLocatable = true, out) {
        const picker = new ElementLocateManager_1.ElementPicker();
        const options = new ElementLocateManager_1.LocateOptions();
        options.allowNonLocatable = allowNonLocatable;
        if (0 !== picker.doPick(this, pickPoint, radius, options)) {
            const result = undefined !== out ? out : new geometry_core_1.Point3d();
            result.setFrom(picker.getHit(0).getPoint());
            return result;
        }
        if (undefined === this.backgroundMapPlane)
            return undefined;
        const eyePoint = this.worldToViewMap.transform1.columnZ();
        const direction = geometry_core_1.Vector3d.createFrom(eyePoint);
        const aa = geometry_core_1.Geometry.conditionalDivideFraction(1, eyePoint.w);
        if (aa !== undefined) {
            const xyzEye = direction.scale(aa);
            direction.setFrom(pickPoint.vectorTo(xyzEye));
        }
        direction.scaleToLength(-1.0, direction);
        const rayToEye = geometry_core_1.Ray3d.create(pickPoint, direction);
        const projectedPt = geometry_core_1.Point3d.createZero();
        if (undefined === rayToEye.intersectionWithPlane(this.backgroundMapPlane, projectedPt))
            return undefined;
        const mapResult = undefined !== out ? out : new geometry_core_1.Point3d();
        mapResult.setFrom(projectedPt);
        return mapResult;
    }
    /** @internal */
    pickCanvasDecoration(pt) { return this.target.pickOverlayDecoration(pt); }
    /** Get the ClientRect of the canvas for this Viewport. */
    getClientRect() { return this.canvas.getBoundingClientRect(); }
    /** The ViewRect for this ScreenViewport. Left and top will be 0, right will be the width, and bottom will be the height. */
    get viewRect() { this._viewRange.init(0, 0, this.canvas.clientWidth, this.canvas.clientHeight); return this._viewRange; }
    /** @internal */
    addDecorations(decorations) {
        ScreenViewport.removeAllChildren(this.decorationDiv);
        const context = new ViewContext_1.DecorateContext(this, decorations);
        this.view.decorate(context);
        for (const decorator of IModelApp_1.IModelApp.viewManager.decorators)
            decorator.decorate(context);
        this.sync.setValidDecorations();
    }
    /** Change the cursor for this Viewport */
    setCursor(cursor = "default") { this.canvas.style.cursor = cursor; }
    /** @internal */
    synchWithView(saveInUndo) {
        super.setupFromView();
        if (saveInUndo)
            this.saveViewUndo();
    }
    /** Change the ViewState of this Viewport
     * @param view a fully loaded (see discussion at [[ViewState.load]] ) ViewState
     */
    changeView(view) {
        this.clearViewUndo();
        super.changeView(view);
        this.saveViewUndo();
    }
    /** @internal */
    get viewCmdTargetCenter() { return this._viewCmdTargetCenter; }
    /** @internal */
    set viewCmdTargetCenter(center) { this._viewCmdTargetCenter = center ? center.clone() : undefined; }
    /** True if an undoable viewing operation exists on the stack */
    get isUndoPossible() { return 0 < this._backStack.length; }
    /** True if a redoable viewing operation exists on the stack */
    get isRedoPossible() { return 0 < this._forwardStack.length; }
    /** Clear the undo buffers of this Viewport. This resets the undo stack. */
    clearViewUndo() {
        this._currentBaseline = undefined;
        this._forwardStack.length = 0;
        this._backStack.length = 0;
    }
    /** Saves the current state of this viewport's [[ViewState]] in the undo stack, such that it can be restored by a call to [[ScreenViewport.doUndo]]. */
    saveViewUndo() {
        if (!this.view)
            return;
        // the first time we're called we need to establish the baseline
        if (!this._currentBaseline)
            this._currentBaseline = this.view.saveForUndo();
        if (this._currentBaseline.equalState(this.view))
            return; // nothing changed, we're done
        const backStack = this._backStack;
        if (backStack.length >= this.maxUndoSteps) // don't save more than max
            backStack.shift(); // remove the oldest entry
        /** Sometimes we get requests to save undo entries from rapid viewing operations (e.g. mouse wheel rolls). To avoid lots of
         * little useless intermediate view undo steps that mean nothing, if we get a call to this within a minimum time (1/2 second by default)
         * we don't add a new entry to the view undo buffer.
         */
        const now = bentleyjs_core_1.BeTimePoint.now();
        if (Viewport.undoDelay.isZero || backStack.length < 1 || backStack[backStack.length - 1].undoTime.plus(Viewport.undoDelay).before(now)) {
            this._currentBaseline.undoTime = now; // save time we put this entry in undo buffer
            this._backStack.push(this._currentBaseline); // save previous state
            this._forwardStack.length = 0; // not possible to do redo after this
        }
        this._currentBaseline = this.view.saveForUndo();
    }
    /** Reverses the most recent change to the Viewport from the undo stack. */
    doUndo(animationTime) {
        if (0 === this._backStack.length || this._currentBaseline === undefined)
            return;
        this._forwardStack.push(this._currentBaseline);
        this._currentBaseline = this._backStack.pop();
        this.view.setFromUndo(this._currentBaseline);
        this.applyViewState(this.view, animationTime);
        this.onViewUndoRedo.raiseEvent(this, ViewUndoEvent.Undo);
    }
    /** Re-applies the most recently un-done change to the Viewport from the redo stack. */
    doRedo(animationTime) {
        if (0 === this._forwardStack.length || this._currentBaseline === undefined)
            return;
        this._backStack.push(this._currentBaseline);
        this._currentBaseline = this._forwardStack.pop();
        this.view.setFromUndo(this._currentBaseline);
        this.applyViewState(this.view, animationTime);
        this.onViewUndoRedo.raiseEvent(this, ViewUndoEvent.Redo);
    }
    /** Clear the view undo buffer and establish the current ViewState as the new baseline. */
    resetUndo() {
        this.clearViewUndo();
        this.saveViewUndo(); // Set up new baseline state
    }
    /** Show the surface normal for geometry under the cursor when snapping. */
    static drawLocateHitDetail(context, aperture, hit) {
        if (!context.viewport.view.is3d())
            return; // Not valuable feedback in 2d...
        if (!(hit instanceof HitDetail_1.SnapDetail) || !hit.normal || hit.isPointAdjusted)
            return; // AccuSnap will flash edge/segment geometry if not a surface hit or snap location has been adjusted...
        const builder = context.createGraphicBuilder(GraphicBuilder_1.GraphicType.WorldOverlay);
        const color = context.viewport.hilite.color.invert(); // Invert hilite color for good contrast
        const colorFill = color.clone();
        color.setTransparency(100);
        colorFill.setTransparency(200);
        builder.setSymbology(color, colorFill, 1);
        const radius = (2.5 * aperture) * context.viewport.getPixelSizeAtPoint(hit.snapPoint);
        const rMatrix = geometry_core_1.Matrix3d.createRigidHeadsUp(hit.normal);
        const ellipse = geometry_core_1.Arc3d.createScaledXYColumns(hit.snapPoint, rMatrix, radius, radius, geometry_core_1.AngleSweep.create360());
        builder.addArc(ellipse, true, true);
        builder.addArc(ellipse, false, false);
        const length = (0.6 * radius);
        const normal = geometry_core_1.Vector3d.create();
        ellipse.vector0.normalize(normal);
        const pt1 = hit.snapPoint.plusScaled(normal, length);
        const pt2 = hit.snapPoint.plusScaled(normal, -length);
        builder.addLineString([pt1, pt2]);
        ellipse.vector90.normalize(normal);
        const pt3 = hit.snapPoint.plusScaled(normal, length);
        const pt4 = hit.snapPoint.plusScaled(normal, -length);
        builder.addLineString([pt3, pt4]);
        context.addDecorationFromBuilder(builder);
    }
    /** @internal */
    drawLocateCursor(context, pt, aperture, isLocateCircleOn, hit) {
        if (hit)
            ScreenViewport.drawLocateHitDetail(context, aperture, hit);
        if (isLocateCircleOn) {
            // draw a filled and outlined circle to represent the size of the location aperture in the current view.
            const radius = Math.floor(aperture * 0.5) + 0.5;
            const position = this.worldToView(pt);
            position.x = Math.floor(position.x) + 0.5;
            position.y = Math.floor(position.y) + 0.5;
            const drawDecoration = (ctx) => {
                ctx.beginPath();
                ctx.strokeStyle = "rgba(255,255,255,.4)";
                ctx.fillStyle = "rgba(255,255,255,.2)";
                ctx.arc(0, 0, radius, 0, 2 * Math.PI);
                ctx.fill();
                ctx.stroke();
                ctx.beginPath();
                ctx.strokeStyle = "rgba(0,0,0,.8)";
                ctx.lineWidth = 1;
                ctx.arc(0, 0, radius + 1, 0, 2 * Math.PI);
                ctx.stroke();
            };
            context.addCanvasDecoration({ position, drawDecoration }, true);
        }
    }
}
exports.ScreenViewport = ScreenViewport;
/** Forms a 2-way connection between 2 Viewports of the same iModel, such that any change of the parameters in one will be reflected in the other.
 * For example, Navigator uses this class to synchronize two views for revision comparison.
 * @note It is possible to synchronize two Viewports from two different [[IModelConnection]]s of the same iModel.
 * @alpha
 */
class TwoWayViewportSync {
    constructor() {
        this._removals = [];
        this._isEcho = false;
    }
    syncView(source, target) {
        if (this._isEcho)
            return;
        this._isEcho = true; // so we don't react to the echo of this sync
        target.applyViewState(source.view.clone(target.iModel));
        this._isEcho = false;
    }
    /** Establish the connection between two Viewports. When this method is called, view2 is initialized with the state of view1. */
    connect(view1, view2) {
        this.disconnect();
        view2.applyViewState(view1.view.clone(view2.iModel)); // use view1 as the starting point
        // listen to the onViewChanged events from both views
        this._removals.push(view1.onViewChanged.addListener(() => this.syncView(view1, view2)));
        this._removals.push(view2.onViewChanged.addListener(() => this.syncView(view2, view1)));
    }
    /** Remove the connection between the two views. */
    disconnect() { this._removals.forEach((removal) => removal()); }
}
exports.TwoWayViewportSync = TwoWayViewportSync;
/** An off-screen viewport is not rendered to the screen. It is never added to the [[ViewManager]], therefore does not participate in
 * the render loop. It must be initialized with an explicit height and width, and its renderFrame function must be manually invoked.
 * @internal
 */
class OffScreenViewport extends Viewport {
    static create(view, viewRect) {
        const rect = new ViewRect(0, 0, 1, 1);
        if (undefined !== viewRect)
            rect.setFrom(viewRect);
        const vp = new this(IModelApp_1.IModelApp.renderSystem.createOffscreenTarget(rect));
        vp.changeView(view);
        vp.sync.setValidDecorations(); // decorations are not used offscreen
        return vp;
    }
    get viewRect() { return this.target.viewRect; }
    setRect(rect, temporary = false) {
        this.target.setViewRect(rect, temporary);
        this.changeView(this.view);
    }
}
exports.OffScreenViewport = OffScreenViewport;
/** @internal */
function linePlaneIntersect(outP, linePt, lineNormal, planePt, planeNormal, perpendicular) {
    let dot = 0;
    if (lineNormal)
        dot = lineNormal.dotProduct(planeNormal);
    else
        perpendicular = true;
    let temp;
    if (perpendicular || Math.abs(dot) < .001) {
        const t = linePt.vectorTo(planePt).dotProduct(planeNormal);
        temp = planeNormal.scale(t);
    }
    else {
        const t = (planeNormal.dotProduct(planePt) - planeNormal.dotProduct(linePt)) / dot;
        temp = lineNormal.scale(t);
    }
    outP.setFrom(temp.plus(linePt));
}
exports.linePlaneIntersect = linePlaneIntersect;


/***/ }),

/***/ "./lib/imodeljs-frontend.js":
/*!**********************************!*\
  !*** ./lib/imodeljs-frontend.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__export(__webpack_require__(/*! ./tools/AccuDrawTool */ "./lib/tools/AccuDrawTool.js"));
__export(__webpack_require__(/*! ./tools/EditManipulator */ "./lib/tools/EditManipulator.js"));
__export(__webpack_require__(/*! ./tools/ElementSetTool */ "./lib/tools/ElementSetTool.js"));
__export(__webpack_require__(/*! ./tools/EventController */ "./lib/tools/EventController.js"));
__export(__webpack_require__(/*! ./tools/MeasureTool */ "./lib/tools/MeasureTool.js"));
__export(__webpack_require__(/*! ./tools/SelectTool */ "./lib/tools/SelectTool.js"));
__export(__webpack_require__(/*! ./tools/ToolAdmin */ "./lib/tools/ToolAdmin.js"));
__export(__webpack_require__(/*! ./tools/Tool */ "./lib/tools/Tool.js"));
__export(__webpack_require__(/*! ./tools/ViewTool */ "./lib/tools/ViewTool.js"));
__export(__webpack_require__(/*! ./tools/ClipViewTool */ "./lib/tools/ClipViewTool.js"));
__export(__webpack_require__(/*! ./tools/PrimitiveTool */ "./lib/tools/PrimitiveTool.js"));
__export(__webpack_require__(/*! ./tools/IdleTool */ "./lib/tools/IdleTool.js"));
__export(__webpack_require__(/*! ./AccuDraw */ "./lib/AccuDraw.js"));
__export(__webpack_require__(/*! ./AccuSnap */ "./lib/AccuSnap.js"));
__export(__webpack_require__(/*! ./AuxCoordSys */ "./lib/AuxCoordSys.js"));
__export(__webpack_require__(/*! ./DevTools */ "./lib/DevTools.js"));
__export(__webpack_require__(/*! ./FrontendRequestContext */ "./lib/FrontendRequestContext.js"));
__export(__webpack_require__(/*! ./CategorySelectorState */ "./lib/CategorySelectorState.js"));
__export(__webpack_require__(/*! ./ContextRealityModelState */ "./lib/ContextRealityModelState.js"));
__export(__webpack_require__(/*! ./SpatialClassification */ "./lib/SpatialClassification.js"));
__export(__webpack_require__(/*! ./DisplayStyleState */ "./lib/DisplayStyleState.js"));
__export(__webpack_require__(/*! ./ElementLocateManager */ "./lib/ElementLocateManager.js"));
__export(__webpack_require__(/*! ./EmphasizeElements */ "./lib/EmphasizeElements.js"));
__export(__webpack_require__(/*! ./EntityState */ "./lib/EntityState.js"));
__export(__webpack_require__(/*! ./FuzzySearch */ "./lib/FuzzySearch.js"));
__export(__webpack_require__(/*! ./GeoServices */ "./lib/GeoServices.js"));
__export(__webpack_require__(/*! ./HitDetail */ "./lib/HitDetail.js"));
__export(__webpack_require__(/*! ./IModelConnection */ "./lib/IModelConnection.js"));
__export(__webpack_require__(/*! ./ImageUtil */ "./lib/ImageUtil.js"));
__export(__webpack_require__(/*! ./FrontendLoggerCategory */ "./lib/FrontendLoggerCategory.js"));
__export(__webpack_require__(/*! ./Marker */ "./lib/Marker.js"));
__export(__webpack_require__(/*! ./ModelSelectorState */ "./lib/ModelSelectorState.js"));
__export(__webpack_require__(/*! ./ModelState */ "./lib/ModelState.js"));
__export(__webpack_require__(/*! ./NotificationManager */ "./lib/NotificationManager.js"));
__export(__webpack_require__(/*! ./Plugin */ "./lib/Plugin.js"));
__export(__webpack_require__(/*! ./SelectionSet */ "./lib/SelectionSet.js"));
__export(__webpack_require__(/*! ./Sheet */ "./lib/Sheet.js"));
__export(__webpack_require__(/*! ./Sprites */ "./lib/Sprites.js"));
__export(__webpack_require__(/*! ./StandardView */ "./lib/StandardView.js"));
__export(__webpack_require__(/*! ./SubCategoriesCache */ "./lib/SubCategoriesCache.js"));
__export(__webpack_require__(/*! ./TentativePoint */ "./lib/TentativePoint.js"));
__export(__webpack_require__(/*! ./QuantityFormatter */ "./lib/QuantityFormatter.js"));
__export(__webpack_require__(/*! ./ViewContext */ "./lib/ViewContext.js"));
__export(__webpack_require__(/*! ./ViewManager */ "./lib/ViewManager.js"));
__export(__webpack_require__(/*! ./Viewport */ "./lib/Viewport.js"));
__export(__webpack_require__(/*! ./ViewState */ "./lib/ViewState.js"));
__export(__webpack_require__(/*! ./IModelApp */ "./lib/IModelApp.js"));
__export(__webpack_require__(/*! ./NoRenderApp */ "./lib/NoRenderApp.js"));
__export(__webpack_require__(/*! ./tile/TileAdmin */ "./lib/tile/TileAdmin.js"));
__export(__webpack_require__(/*! ./tile/TileTree */ "./lib/tile/TileTree.js"));
__export(__webpack_require__(/*! ./tile/WebMapTileTree */ "./lib/tile/WebMapTileTree.js"));
__export(__webpack_require__(/*! ./render/FeatureSymbology */ "./lib/render/FeatureSymbology.js"));
__export(__webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js"));
__export(__webpack_require__(/*! ./render/MockRender */ "./lib/render/MockRender.js"));
__export(__webpack_require__(/*! ./render/System */ "./lib/render/System.js"));
__export(__webpack_require__(/*! ./render/webgl/Target */ "./lib/render/webgl/Target.js"));
__export(__webpack_require__(/*! ./oidc/OidcBrowserClient */ "./lib/oidc/OidcBrowserClient.js"));
__export(__webpack_require__(/*! ./TiledGraphicsProvider */ "./lib/TiledGraphicsProvider.js"));
__export(__webpack_require__(/*! ./TerrainProvider */ "./lib/TerrainProvider.js"));
__export(__webpack_require__(/*! ./properties/EditorParams */ "./lib/properties/EditorParams.js"));
__export(__webpack_require__(/*! ./properties/Record */ "./lib/properties/Record.js"));
__export(__webpack_require__(/*! ./properties/Value */ "./lib/properties/Value.js"));
__export(__webpack_require__(/*! ./properties/ToolSettingsValue */ "./lib/properties/ToolSettingsValue.js"));
__export(__webpack_require__(/*! ./SolarCalculate */ "./lib/SolarCalculate.js"));
if (( true) && (typeof window !== "undefined") && window) {
    if (!window.iModelJsVersions)
        window.iModelJsVersions = new Map();
    window.iModelJsVersions.set("imodeljs-frontend", "1.0.0");
}
/** @docs-package-description
 * The ($frontend) package always runs in a web browser. It contains classes for [querying iModels and showing views]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description IModelApp
 * Classes for configuring and administering an iModel.js application.
 * See [the learning articles]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description IModelConnection
 * Classes for working with a connection to an [iModel briefcase]($docs/learning/IModels.md)
 */
/**
 * @docs-group-description ElementState
 * Classes for working with the *state* of Elements in the frontend.
 * See [the learning articles]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description ModelState
 * Classes for working with the *state* of Models in the frontend.
 * See [the learning articles]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description Tools
 * Classes for [working with Tools]($docs/learning/frontend/Tools.md)
 */
/**
 * @docs-group-description Views
 * Classes for [working with Views]($docs/learning/frontend/Views.md)
 */
/**
 * @docs-group-description LocatingElements
 * Classes for locating and snapping to elements in views.
 * See [the learning articles]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description AccuDraw
 * AccuDraw provides helpful assistance for creating and modifying elements in a view.
 * See [the learning articles]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description Notifications
 * Notifications provide feedback to the user of something of interest.
 * See [the learning articles]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description Plugins
 * Classes for creating and managing runtime [Plugins]($docs/learning/frontend/Plugins.md)
 */
/**
 * @docs-group-description Properties
 * Classes for working with property records and descriptions.
 */
/**
 * @docs-group-description Rendering
 * Classes for rendering the contents of views.
 */
/**
 * @docs-group-description SelectionSet
 * Classes for working with the set of selected elements.
 * See [the learning articles]($docs/learning/frontend/index.md).
 */
/**
 * @docs-group-description Tile
 * Classes for selecting and drawing tiles in views.
 */
/**
 * @docs-group-description WebGL
 * Classes for interfacing to WebGL in browsers.
 */


/***/ }),

/***/ "./lib/oidc/OidcBrowserClient.js":
/*!***************************************!*\
  !*** ./lib/oidc/OidcBrowserClient.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module OIDC */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_clients_1 = __webpack_require__(/*! @bentley/imodeljs-clients */ "@bentley/imodeljs-clients");
const oidc_client_1 = __webpack_require__(/*! oidc-client */ "../../common/temp/node_modules/.registry.npmjs.org/oidc-client/1.7.1/node_modules/oidc-client/lib/oidc-client.min.js");
const FrontendLoggerCategory_1 = __webpack_require__(/*! ../FrontendLoggerCategory */ "./lib/FrontendLoggerCategory.js");
const loggerCategory = FrontendLoggerCategory_1.FrontendLoggerCategory.OidcBrowserClient;
/** Utility to forward oidc-client logs to the Bentley logger */
class OidcClientLogger {
    constructor() {
    }
    debug(message, ...optionalParams) {
        bentleyjs_core_1.Logger.logTrace(loggerCategory, message, () => optionalParams);
    }
    info(message, ...optionalParams) {
        bentleyjs_core_1.Logger.logInfo(loggerCategory, message, () => optionalParams);
    }
    warn(message, ...optionalParams) {
        bentleyjs_core_1.Logger.logWarning(loggerCategory, message, () => optionalParams);
    }
    error(message, ...optionalParams) {
        bentleyjs_core_1.Logger.logError(loggerCategory, message, () => optionalParams);
    }
    static initializeLevel() {
        const logLevel = bentleyjs_core_1.Logger.getLevel(loggerCategory);
        switch (logLevel) {
            case bentleyjs_core_1.LogLevel.Error:
                oidc_client_1.Log.level = oidc_client_1.Log.ERROR;
                break;
            case bentleyjs_core_1.LogLevel.Warning:
                oidc_client_1.Log.level = oidc_client_1.Log.WARN;
                break;
            case bentleyjs_core_1.LogLevel.Info:
                oidc_client_1.Log.level = oidc_client_1.Log.INFO;
                break;
            case bentleyjs_core_1.LogLevel.Trace:
                oidc_client_1.Log.level = oidc_client_1.Log.DEBUG;
                break;
            case bentleyjs_core_1.LogLevel.None:
                oidc_client_1.Log.level = oidc_client_1.Log.NONE;
                break;
            default:
        }
    }
    /** Initializes forwarding of OidcClient logs to the Bentley Logger */
    static initializeLogger() {
        oidc_client_1.Log.logger = new OidcClientLogger();
        this.initializeLevel();
    }
    /** Resets (or clears) forwarding of OidcClient logs to the Bentley Logger */
    static reset() {
        oidc_client_1.Log.reset();
    }
}
/**
 * Utility to generate OIDC/OAuth tokens for frontend applications
 * @beta
 */
class OidcBrowserClient extends imodeljs_clients_1.OidcClient {
    /** Constructor */
    constructor(_configuration) {
        super();
        this._configuration = _configuration;
        /** Event called when the user's sign-in state changes - this may be due to calls to signIn(), signOut() or simply because the token expired */
        this.onUserStateChanged = new bentleyjs_core_1.BeEvent();
        this._onUserStateChanged = (user) => {
            if (this.getIsRedirecting()) {
                /*
                 * no need to raise the event when still redirecting, since
                 * the application will be refreshed after the authorization is complete.
                 * We as we're about to get a redirect
                 */
                return;
            }
            this.initAccessToken(user);
            try {
                this.onUserStateChanged.raiseEvent(this._accessToken);
            }
            catch (err) {
                bentleyjs_core_1.Logger.logError(loggerCategory, "Error thrown when handing OidcBrowserClient.onUserStateChanged event", () => ({ message: err.message }));
            }
        };
        /**
         * Raised when a user session has been established (or re-established).
         * This can happen on startup, after token refresh or token callback.
         */
        this._onUserLoaded = (user) => {
            this._onUserStateChanged(user);
        };
        /**
         * Raised when a user session has been terminated.
         */
        this._onUserUnloaded = () => {
            this._onUserStateChanged(undefined);
        };
        /**
         * Raised prior to the access token expiring
         */
        this._onAccessTokenExpiring = () => {
        };
        /**
         * Raised after the access token has expired.
         */
        this._onAccessTokenExpired = () => {
            this._onUserStateChanged(undefined);
        };
        /**
         * Raised when the automatic silent renew has failed.
         */
        this._onSilentRenewError = () => {
            this._onUserStateChanged(undefined);
        };
        /**
         * Raised when the user's sign-in status at the OP has changed.
         */
        this._onUserSignedOut = () => {
            this._onUserStateChanged(undefined);
        };
        const redirectUri = new URL(this._configuration.redirectUri);
        this._redirectPath = redirectUri.pathname;
    }
    /**
     * Used to initialize the client - must be awaited before any other methods are called
     * @throws [[Error]] in some cases of authorization failure
     * - if the login times out without the user providing the necessary input, or
     * - if the user hasn't consented to the scopes.
     */
    async initialize(requestContext) {
        /*
         * Any redirection in a SPA causes the entire application to be re-initialized, and subsequently
         * causes this method to be called again. This happens thrice during authorization:
         * - when the application loads up for the first time (signIn hasn't happened yet)
         * - when authorization provider causes browser to redirect to the supplied (and registered) redirectUri
         * - when application causes a redirection after the token was retrieved
         */
        // Initialize user manager and logging
        await this.createUserManager(requestContext);
        OidcClientLogger.initializeLogger();
        if (this.getIsRedirecting()) {
            // Handle redirection to extract the accessToken
            await this.handleRedirectCallback();
        }
        else {
            // Sign-in hasn't happened, or has just happened and we are in the final successful redirection
            await this.nonInteractiveSignIn(requestContext); // load from state, or try silent sign-in
        }
    }
    getIsRedirecting() {
        return (window.location.pathname === this._redirectPath);
    }
    /**
     * Used to handle the redirection that happens as part of an orchestrated SignIn.
     * If the current pathname is the redirect path, it triggers the redirect call back and completes
     * the SignIn. The returned promise evaluates to true, and the browser is redirected back to the
     * root path.
     * If the current pathname is NOT the redirect path, the returned promise resolves right away with
     * a false value.
     * The application should use this method whenever a redirection happens - since redirection typically causes
     * the re-initialization of a Single Page Application, this method is called already as part of the initialization
     * routine.
     */
    async handleRedirectCallback() {
        if (!this.getIsRedirecting())
            return false;
        try {
            let user;
            if (window.parent !== window) {
                // This is an i-frame, and we are doing a silent signin.
                await this._userManager.signinSilentCallback();
            }
            else {
                user = await this._userManager.signinRedirectCallback();
                bentleyjs_core_1.assert(user && !user.expired, "Expected userManager.signinRedirectCallback to always resolve to authorized user");
                window.location.replace(user.state.successRedirectUrl);
            }
        }
        catch (err) {
            bentleyjs_core_1.Logger.logError(loggerCategory, "Authentication error - cannot retrieve token after redirection");
        }
        return true;
    }
    /**
     * Attempts a silent sign in with the authorization provider
     * @return Resolves to authenticated user if the silent sign in succeeded
     * @throws [[Error]] If the silent sign in fails
     */
    async signInSilent(requestContext) {
        requestContext.enter();
        bentleyjs_core_1.assert(!!this._userManager, "OidcBrowserClient not initialized");
        const user = await this._userManager.signinSilent();
        bentleyjs_core_1.assert(user && !user.expired, "Expected userManager.signinSilent to always resolve to authorized user");
        return user;
    }
    /**
     * Gets the user from storage
     * @return User found in storage.
     * - Resolves to null if no user was found.
     * - Does not call any events if the user is loaded from storage
     * - Returned user may have expired - so it's up to the caller to check the expired state
     */
    async getUser(requestContext) {
        requestContext.enter();
        bentleyjs_core_1.assert(!!this._userManager, "OidcBrowserClient not initialized");
        return this._userManager.getUser();
    }
    /**
     * Attempts a non-interactive signIn
     * - tries to load the user from session or local storage
     * - tries to silently sign-in the user
     */
    async nonInteractiveSignIn(requestContext) {
        // Load user from session/local storage
        const user = await this.getUser(requestContext);
        if (user && !user.expired) {
            this._onUserLoaded(user); // Call only because getUser() doesn't call any events
            return true;
        }
        // Attempt a silent sign-in
        try {
            await this.signInSilent(requestContext); // calls events
        }
        catch (err) {
            bentleyjs_core_1.Logger.logInfo(loggerCategory, "Silent sign-in failed");
            return false;
        }
        return true;
    }
    /**
     * Start the sign-in process
     * - calls the onUserStateChanged() call back after the authorization completes
     * or if there is an error.
     * - redirects application to the redirectUri specified in the configuration and then
     * redirects back to root when sign-in is complete.
     */
    async signIn(requestContext, successRedirectUrl) {
        requestContext.enter();
        if (!this._userManager)
            throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.AuthStatus.Error, "OidcBrowserClient not initialized", bentleyjs_core_1.Logger.logError, loggerCategory);
        // Non interactive sign-in
        const status = await this.nonInteractiveSignIn(requestContext);
        if (status)
            return;
        // Attempt an interactive signin - returns a promise to redirect
        await this._userManager.signinRedirect({
            data: {
                successRedirectUrl: successRedirectUrl || window.location.href,
            },
        }); // tslint:disable-line:no-floating-promises
    }
    /**
     * Start the sign-out process
     * - calls the onUserStateChanged() call back after the authorization completes
     *   or if there is an error.
     * - redirects application to the postSignoutRedirectUri specified in the configuration when the sign out is
     *   complete
     */
    async signOut(requestContext) {
        requestContext.enter();
        await this._userManager.signoutRedirect(); // tslint:disable-line:no-floating-promises
    }
    /**
     * Returns a promise that resolves to the AccessToken of the currently authorized user.
     * The token is refreshed as necessary.
     * @throws [[BentleyError]] If signIn() was not called, or there was an authorization error.
     */
    async getAccessToken(requestContext) {
        if (this._accessToken)
            return this._accessToken;
        if (requestContext)
            requestContext.enter();
        throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.AuthStatus.Error, "Not signed in.", bentleyjs_core_1.Logger.logError, loggerCategory);
    }
    /**
     * Set to true if there's a current authorized user or client (in the case of agent applications).
     * Set to true if signed in and the access token has not expired, and false otherwise.
     */
    get isAuthorized() {
        return !!this._accessToken;
    }
    /** Set to true if the user has signed in, but the token has expired and requires a refresh */
    get hasExpired() {
        return !!this._accessToken; // Always silently refreshed
    }
    /** Set to true if signed in - the accessToken may be active or may have expired and require a refresh */
    get hasSignedIn() {
        return !!this._accessToken; // Always silently refreshed
    }
    /** Disposes the resources held by this client */
    dispose() {
        if (!this._userManager)
            return;
        this._userManager.events.removeUserLoaded(this._onUserLoaded);
        this._userManager.events.removeAccessTokenExpiring(this._onAccessTokenExpiring);
        this._userManager.events.removeAccessTokenExpired(this._onAccessTokenExpired);
        this._userManager.events.removeUserUnloaded(this._onUserUnloaded);
        this._userManager.events.removeSilentRenewError(this._onSilentRenewError);
        this._userManager.events.removeUserSignedOut(this._onUserSignedOut);
        OidcClientLogger.reset();
        this._userManager = undefined;
    }
    async createUserManager(requestContext) {
        const settings = await this.getUserManagerSettings(requestContext);
        this._userManager = new oidc_client_1.UserManager(settings);
        this._userManager.events.addUserLoaded(this._onUserLoaded);
        this._userManager.events.addUserUnloaded(this._onUserUnloaded);
        this._userManager.events.addAccessTokenExpiring(this._onAccessTokenExpiring);
        this._userManager.events.addAccessTokenExpired(this._onAccessTokenExpired);
        this._userManager.events.addSilentRenewError(this._onSilentRenewError);
        this._userManager.events.addUserSignedOut(this._onUserSignedOut);
        return this._userManager;
    }
    async getUserManagerSettings(requestContext) {
        const userManagerSettings = {
            authority: await this.getUrl(requestContext),
            client_id: this._configuration.clientId,
            redirect_uri: this._configuration.redirectUri,
            silent_redirect_uri: this._configuration.redirectUri,
            post_logout_redirect_uri: this._configuration.postSignoutRedirectUri,
            automaticSilentRenew: true,
            response_type: "id_token token",
            query_status_response_type: "id_token token",
            scope: this._configuration.scope,
        };
        return userManagerSettings;
    }
    initAccessToken(user) {
        if (!user) {
            this._accessToken = undefined;
            return;
        }
        const startsAt = new Date((user.expires_at - user.expires_in) * 1000);
        const expiresAt = new Date(user.expires_at * 1000);
        const userInfo = imodeljs_clients_1.UserInfo.fromJson(user.profile);
        this._accessToken = imodeljs_clients_1.AccessToken.fromJsonWebTokenString(user.access_token, startsAt, expiresAt, userInfo);
    }
}
exports.OidcBrowserClient = OidcBrowserClient;


/***/ }),

/***/ "./lib/properties/EditorParams.js":
/*!****************************************!*\
  !*** ./lib/properties/EditorParams.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for Property Editor Param Types
 * @alpha
 */
var PropertyEditorParamTypes;
(function (PropertyEditorParamTypes) {
    PropertyEditorParamTypes[PropertyEditorParamTypes["ButtonGroupData"] = 0] = "ButtonGroupData";
    PropertyEditorParamTypes[PropertyEditorParamTypes["CheckBoxIcons"] = 1] = "CheckBoxIcons";
    PropertyEditorParamTypes[PropertyEditorParamTypes["Icon"] = 2] = "Icon";
    PropertyEditorParamTypes[PropertyEditorParamTypes["InputEditorSize"] = 3] = "InputEditorSize";
    PropertyEditorParamTypes[PropertyEditorParamTypes["JSON"] = 4] = "JSON";
    PropertyEditorParamTypes[PropertyEditorParamTypes["MultilineText"] = 5] = "MultilineText";
    PropertyEditorParamTypes[PropertyEditorParamTypes["Range"] = 6] = "Range";
    PropertyEditorParamTypes[PropertyEditorParamTypes["Slider"] = 7] = "Slider";
    PropertyEditorParamTypes[PropertyEditorParamTypes["SuppressUnitLabel"] = 8] = "SuppressUnitLabel";
    PropertyEditorParamTypes[PropertyEditorParamTypes["SuppressEditorLabel"] = 9] = "SuppressEditorLabel";
    PropertyEditorParamTypes[PropertyEditorParamTypes["ColorData"] = 10] = "ColorData";
    PropertyEditorParamTypes[PropertyEditorParamTypes["CustomFormattedNumber"] = 11] = "CustomFormattedNumber";
})(PropertyEditorParamTypes = exports.PropertyEditorParamTypes || (exports.PropertyEditorParamTypes = {}));
/*  Not yet supported
  |  JsonEditorParams | RangeEditorParams | SliderEditorParams |
  | IconEditorParams | CheckBoxIconsEditorParams | SuppressUnitLabelEditorParams
*/


/***/ }),

/***/ "./lib/properties/Record.js":
/*!**********************************!*\
  !*** ./lib/properties/Record.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * PropertyRecord contains instance information about a Property, including a
 * value that can be edited using a PropertyEditor and converted using a TypeConverter.
 * @beta
 */
class PropertyRecord {
    constructor(value, property) {
        this.value = value;
        this.property = property;
    }
    /** Creates a copy of this PropertyRecord with a new value */
    copyWithNewValue(newValue) {
        return new PropertyRecord(newValue, this.property);
    }
}
exports.PropertyRecord = PropertyRecord;


/***/ }),

/***/ "./lib/properties/ToolSettingsValue.js":
/*!*********************************************!*\
  !*** ./lib/properties/ToolSettingsValue.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Properties */
Object.defineProperty(exports, "__esModule", { value: true });
const Value_1 = __webpack_require__(/*! ./Value */ "./lib/properties/Value.js");
const Record_1 = __webpack_require__(/*! ./Record */ "./lib/properties/Record.js");
/** Primitive ToolSettings Value.
 * @beta
 */
class ToolSettingsValue {
    constructor(value, displayValue) {
        this.valueFormat = Value_1.PropertyValueFormat.Primitive;
        this.value = value;
        this.displayValue = displayValue;
    }
    get isNullValue() {
        return undefined === this.value;
    }
    get hasDisplayValue() {
        return undefined !== this.displayValue;
    }
    update(newValue) {
        if (newValue.valueFormat !== this.valueFormat)
            throw new Error("ToolSettingsValue.update requires both values to be of the same format");
        if (this.value === newValue.value && this.displayValue === newValue.displayValue)
            return false;
        this.value = newValue.value;
        this.displayValue = newValue.displayValue;
        return true;
    }
    clone() {
        return new ToolSettingsValue(this.value, this.displayValue);
    }
}
exports.ToolSettingsValue = ToolSettingsValue;
/** Class used to identify a specific ToolSettings property value. This is the minimal amount of info necessary to specify which property a value is associated with. This is used to both
 * display property in UI, save and retrieve the state of the property, and to allow the UI to inform the Tool code about property changes.
 * @beta
 */
class ToolSettingsPropertyItem {
    constructor(value, propertyName) {
        this.value = value;
        this.propertyName = propertyName;
    }
}
exports.ToolSettingsPropertyItem = ToolSettingsPropertyItem;
/** Class used to identify a specific ToolSettings property value that can be enabled/disabled in UI.
 * @beta
 */
class ToolSettingsPropertySyncItem extends ToolSettingsPropertyItem {
    constructor(value, propertyName, isDisabled) {
        super(value, propertyName);
        this.isDisabled = isDisabled;
    }
}
exports.ToolSettingsPropertySyncItem = ToolSettingsPropertySyncItem;
/** Property Record to specify an editor in Tool Settings zone.
 * @beta
 */
class ToolSettingsPropertyRecord extends Record_1.PropertyRecord {
    constructor(value, property, editorPosition, isReadonly = false) {
        super(value, property);
        this.editorPosition = editorPosition;
        this.isReadonly = isReadonly;
    }
    static clone(record, newValue) {
        const value = Object.assign({}, newValue ? newValue : record.value);
        const newRecord = new ToolSettingsPropertyRecord(value, record.property, record.editorPosition, record.isReadonly);
        newRecord.isDisabled = record.isDisabled;
        return newRecord;
    }
}
exports.ToolSettingsPropertyRecord = ToolSettingsPropertyRecord;


/***/ }),

/***/ "./lib/properties/Value.js":
/*!*********************************!*\
  !*** ./lib/properties/Value.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Properties */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Enumeration for Format of the property value.
 * @beta
 */
var PropertyValueFormat;
(function (PropertyValueFormat) {
    PropertyValueFormat[PropertyValueFormat["Primitive"] = 0] = "Primitive";
    PropertyValueFormat[PropertyValueFormat["Array"] = 1] = "Array";
    PropertyValueFormat[PropertyValueFormat["Struct"] = 2] = "Struct";
})(PropertyValueFormat = exports.PropertyValueFormat || (exports.PropertyValueFormat = {}));


/***/ }),

/***/ "./lib/render/FeatureSymbology.js":
/*!****************************************!*\
  !*** ./lib/render/FeatureSymbology.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const Viewport_1 = __webpack_require__(/*! ../Viewport */ "./lib/Viewport.js");
function copyIdSetToUint32Set(dst, src) {
    dst.clear();
    if (undefined !== src) {
        for (const id of src)
            dst.addId(id);
    }
}
/** Contains types that enable an application to customize how [Feature]($common)s are drawn within a [[Viewport]].
 * @public
 */
var FeatureSymbology;
(function (FeatureSymbology) {
    /** Defines overrides for selected aspects of a [Feature]($common)'s symbology.
     * Any member defined in the Appearance overrides that aspect of symbology for all [Feature]($common)s to which the Appearance is applied.
     * @see [[FeatureSymbology.Overrides]]
     */
    class Appearance {
        constructor(props) {
            this.rgb = props.rgb;
            this.weight = props.weight;
            this.transparency = props.transparency;
            this.linePixels = props.linePixels;
            this.ignoresMaterial = props.ignoresMaterial;
            this.nonLocatable = props.nonLocatable;
            if (undefined !== this.weight)
                this.weight = Math.max(1, Math.min(this.weight, 32));
            if (undefined !== this.transparency) {
                this.transparency = Math.max(0, Math.min(this.transparency, 1));
                // Fix up rounding errors...
                const smallDelta = 0.0001;
                if (1.0 - this.transparency < smallDelta)
                    this.transparency = 1.0;
                else if (this.transparency < smallDelta)
                    this.transparency = 0.0;
            }
        }
        static fromJSON(props) {
            if (undefined === props || (undefined === props.rgb && undefined === props.weight && undefined === props.transparency && undefined === props.linePixels && !props.ignoresMaterial && !props.nonLocatable))
                return this.defaults;
            else
                return new Appearance(props);
        }
        /** Create an Appearance that overrides only the RGB color of a [Feature]($common).
         * @note The transparency component of the ColorDef is ignored.
         */
        static fromRgb(color) { return this.fromJSON({ rgb: imodeljs_common_1.RgbColor.fromColorDef(color) }); }
        /** Create an Appearance that overrides the RGB and transparency of a Feature.
         * The Appearance's transparency is derived from the transparency component of the ColorDef.
         */
        static fromRgba(color) {
            return this.fromJSON({
                rgb: imodeljs_common_1.RgbColor.fromColorDef(color),
                transparency: color.colors.t / 255,
            });
        }
        /** Create an Appearance that overrides only the transparency */
        static fromTransparency(transparencyValue) { return this.fromJSON({ transparency: transparencyValue }); }
        /** Create an Appearance with overrides corresponding to those defined by the supplied SubCategoryOverride. */
        static fromSubCategoryOverride(ovr) {
            const rgb = undefined !== ovr.color ? imodeljs_common_1.RgbColor.fromColorDef(ovr.color) : undefined;
            const transparency = undefined !== ovr.transparency ? ovr.transparency : undefined;
            const weight = undefined !== ovr.weight ? ovr.weight : undefined;
            const ignoresMaterial = undefined !== ovr.material && bentleyjs_core_1.Id64.isValid(ovr.material) ? true : undefined;
            return this.fromJSON({ rgb, transparency, weight, ignoresMaterial });
        }
        get overridesRgb() { return undefined !== this.rgb; }
        get overridesTransparency() { return undefined !== this.transparency; }
        get overridesLinePixels() { return undefined !== this.linePixels; }
        get overridesWeight() { return undefined !== this.weight; }
        get overridesSymbology() { return this.overridesRgb || this.overridesTransparency || this.overridesWeight || this.overridesLinePixels || !!this.ignoresMaterial; }
        get isFullyTransparent() { return undefined !== this.transparency && this.transparency >= 1.0; }
        equals(other) {
            return this.rgbIsEqual(other.rgb) && this.weight === other.weight && this.transparency === other.transparency && this.linePixels === other.linePixels && this.ignoresMaterial === other.ignoresMaterial;
        }
        toJSON() {
            return {
                rgb: this.rgb,
                weight: this.weight,
                transparency: this.transparency,
                linePixels: this.linePixels,
                ignoresMaterial: this.ignoresMaterial ? true : undefined,
                nonLocatable: this.nonLocatable ? true : undefined,
            };
        }
        /** Produce an Appearance from the supplied Appearance in which any aspect not defined by the base Appearance is overridden by this Appearance. */
        extendAppearance(base) {
            if (!this.overridesSymbology)
                return base;
            const props = base.toJSON();
            if (undefined === props.rgb)
                props.rgb = this.rgb;
            if (undefined === props.transparency)
                props.transparency = this.transparency;
            if (undefined === props.linePixels)
                props.linePixels = this.linePixels;
            if (undefined === props.weight)
                props.weight = this.weight;
            if (undefined === props.ignoresMaterial && this.ignoresMaterial)
                props.ignoresMaterial = true;
            if (undefined === props.nonLocatable && this.nonLocatable)
                props.nonLocatable = true;
            return Appearance.fromJSON(props);
        }
        rgbIsEqual(rgb) { return undefined === this.rgb ? undefined === rgb ? true : false : undefined === rgb ? false : this.rgb.equals(rgb); }
    }
    /** An Appearance which overrides nothing. */
    Appearance.defaults = new Appearance({});
    FeatureSymbology.Appearance = Appearance;
    /** Allows a [[Viewport]] to customize the appearance of individual [Feature]($common)s within it.
     *
     * The Viewport computes its base Overrides based on the following:
     *  - The set of categories enabled for display in its [[CategorySelectorState]]. Every [[SubCategory]] belonging to an enabled [[Category]] is added to the set of visible subcategories - all other subcategories are assumed to be invisible.
     *  - For the set of visible subcategories, any [[SubCategoryOverride]]s defined by the view's [[DisplayStyleState]] are applied. This may render some subcategories invisible, and change the symbology of others.
     *  - The visibility of each [GeometryClass]($common) is set based on the view's [[ViewFlags]].
     *  - The line weight is overridden to 1 pixel for all Features if line weight has been disabled by the view's [[ViewFlags]].
     *  - The sets of elements which are always drawn and never drawn are initialized from the [[Viewport]]'s sets.
     * An application can further customize the symbology of any Features by registering a [[FeatureOverrideProvider]] with a [[Viewport]]. That provider's addFeatureOverrides function will be invoked
     * whenever the Overrides need to be regenerated.
     *
     * To override the symbology of *most* Features within a view, specify a [[defaultOverrides]] to be applied to any Feature not explicitly overridden.
     * If default overrides are defined and some Features should draw normally without being affected by the default overrides, override that Feature with
     * an Appearance which defines no overrides.
     *
     * It is possible to override multiple aspects of a Feature. For example, you might specify that all elements belonging to subcategory "A" should be drawn in red, and
     * that the element with Id "0x123" should be drawn with 0.25 transparency. In this case, when drawing a Feature with subcategory "A" and element Id "0x123", the two overrides will
     * be merged, causing the Feature's geometry to draw 25% transparent red. On the other hand, if subcategory "A" is specified to draw in red and element "0x123" to draw in green,
     * the color specified by the element override will take precedence over that specified for the subcategory, resulting in a green Feature.
     *
     * @see [[Viewport.alwaysDrawn]]
     * @see [[Viewport.neverDrawn]]
     */
    class Overrides {
        /** Construct a new Overrides. The result is an empty set of overrides if no view or viewport is supplied.
         * @param view If supplied, the overrides will be initialized based on the current state of the view or viewport.
         */
        constructor(view) {
            /** Ids of elements which should never be drawn. This takes precedence over [[_alwaysDrawn]]. @internal */
            this._neverDrawn = new bentleyjs_core_1.Id64.Uint32Set();
            /** Ids of elements which should always be drawn. [[_neverDrawn]] takes precedence over this set. @internal */
            this._alwaysDrawn = new bentleyjs_core_1.Id64.Uint32Set();
            /** If true, no elements *except* those defined in the "always drawn" set will be drawn.
             * @see [[setAlwaysDrawn]]
             */
            this.isAlwaysDrawnExclusive = false;
            /** Overrides applied to any feature not explicitly overridden. @internal */
            this._defaultOverrides = Appearance.defaults;
            /** Whether construction geometry should be drawn. @internal */
            this._constructions = false;
            /** Whether dimensions should be drawn. @internal */
            this._dimensions = false;
            /** Whether area patterns should be drawn. @internal */
            this._patterns = false;
            /** Whether line weights should be applied. If false, all lines are rendered 1-pixel wide. @internal */
            this._lineWeights = true;
            /** Overrides applied to all elements belonging to each model. @internal */
            this._modelOverrides = new bentleyjs_core_1.Id64.Uint32Map();
            /** Overrides applied to specific elements. @internal */
            this._elementOverrides = new bentleyjs_core_1.Id64.Uint32Map();
            /** Overrides applied to geometry belonging to each subcategory. @internal */
            this._subCategoryOverrides = new bentleyjs_core_1.Id64.Uint32Map();
            /** The set of displayed subcategories. Geometry belonging to subcategories not included in this set will not be drawn. @internal */
            this._visibleSubCategories = new bentleyjs_core_1.Id64.Uint32Set();
            /** Per-model, a set of subcategories whose visibility should be inverted for elements within that model.
             * Populated by Viewport.
             * @internal
             */
            this._modelSubCategoryOverrides = new bentleyjs_core_1.Id64.Uint32Map();
            /** Ids of animation nodes which should never be drawn.
             * @internal
             */
            this.neverDrawnAnimationNodes = new Set();
            /** Mapping of animation node Ids to overrides applied to the corresponding animation nodes.
             * @internal
             */
            this.animationNodeOverrides = new Map();
            if (undefined !== view) {
                if (view instanceof Viewport_1.Viewport)
                    this.initFromViewport(view);
                else
                    this.initFromView(view);
            }
        }
        /** Overrides applied to features for which no other overrides are defined */
        get defaultOverrides() { return this._defaultOverrides; }
        /** Whether or not line weights are applied. If false, all lines are drawn with a weight of 1. */
        get lineWeights() { return this._lineWeights; }
        /** @internal */
        isNeverDrawn(elemIdLo, elemIdHi, animationNodeId) {
            if (this._neverDrawn.has(elemIdLo, elemIdHi))
                return true;
            else
                return 0 !== animationNodeId && this.neverDrawnAnimationNodes.has(animationNodeId);
        }
        /** @internal */
        isAlwaysDrawn(idLo, idHi) { return this._alwaysDrawn.has(idLo, idHi); }
        /** Returns true if the [[SubCategory]] specified by Id is in the set of visible subcategories. @internal */
        isSubCategoryVisible(idLo, idHi) { return this._visibleSubCategories.has(idLo, idHi); }
        /** @internal */
        isSubCategoryVisibleInModel(subcatLo, subcatHi, modelLo, modelHi) {
            let vis = this.isSubCategoryVisible(subcatLo, subcatHi);
            const modelOvr = this._modelSubCategoryOverrides.get(modelLo, modelHi);
            if (undefined !== modelOvr && modelOvr.has(subcatLo, subcatHi))
                vis = !vis;
            return vis;
        }
        /** @internal */
        getModelOverrides(idLo, idHi) { return this._modelOverrides.get(idLo, idHi); }
        /** @internal */
        getElementOverrides(idLo, idHi, animationNodeId) {
            const app = this._elementOverrides.get(idLo, idHi);
            if (app !== undefined || 0 === animationNodeId)
                return app;
            return this.animationNodeOverrides.get(animationNodeId);
        }
        /** @internal */
        getSubCategoryOverrides(idLo, idHi) { return this._subCategoryOverrides.get(idLo, idHi); }
        /** Add a [[SubCategory]] to the set of visible subcategories. */
        setVisibleSubCategory(id) { this._visibleSubCategories.addId(id); }
        /** Specify the Id of an element which should never be drawn in this view. */
        setNeverDrawn(id) { this._neverDrawn.addId(id); }
        /** Specify the Id of an element which should always be drawn in this view. */
        setAlwaysDrawn(id) { this._alwaysDrawn.addId(id); }
        /** Specify the Id of a animation node which should never be drawn in this view. */
        setAnimationNodeNeverDrawn(id) { this.neverDrawnAnimationNodes.add(id); }
        /** Specify the Ids of elements which should never be drawn in this view. */
        setNeverDrawnSet(ids) { copyIdSetToUint32Set(this._neverDrawn, ids); }
        /** Specify the Ids of elements which should always be drawn in this view. */
        setAlwaysDrawnSet(ids, exclusive) { copyIdSetToUint32Set(this._alwaysDrawn, ids); this.isAlwaysDrawnExclusive = exclusive; }
        /** Returns the feature's Appearance overrides, or undefined if the feature is not visible. */
        getFeatureAppearance(feature, modelId, type = imodeljs_common_1.BatchType.Primary) {
            return this.getAppearance(bentleyjs_core_1.Id64.getLowerUint32(feature.elementId), bentleyjs_core_1.Id64.getUpperUint32(feature.elementId), bentleyjs_core_1.Id64.getLowerUint32(feature.subCategoryId), bentleyjs_core_1.Id64.getUpperUint32(feature.subCategoryId), feature.geometryClass, bentleyjs_core_1.Id64.getLowerUint32(modelId), bentleyjs_core_1.Id64.getUpperUint32(modelId), type, 0);
        }
        /** Returns a feature's Appearance overrides, or undefined if the feature is not visible.
         * Takes Id64s as pairs of unsigned 32-bit integers, because that is how they are stored by the PackedFeatureTable associated with each batch of graphics.
         * This API is much uglier but also much more efficient.
         * @internal
         */
        getAppearance(elemLo, elemHi, subcatLo, subcatHi, geomClass, modelLo, modelHi, type, animationNodeId) {
            if (imodeljs_common_1.BatchType.VolumeClassifier === type)
                return this.getClassifierAppearance(elemLo, elemHi, subcatLo, subcatHi, modelLo, modelHi);
            let app = !this._lineWeights ? Overrides._weight1Appearance : Appearance.defaults;
            const modelApp = this.getModelOverrides(modelLo, modelHi);
            if (undefined !== modelApp)
                app = modelApp.extendAppearance(app);
            // Is the element visible?
            let elemApp, alwaysDrawn = false;
            if (bentleyjs_core_1.Id64.isValidUint32Pair(elemLo, elemHi)) {
                if (this.isNeverDrawn(elemLo, elemHi, animationNodeId))
                    return undefined;
                alwaysDrawn = this.isAlwaysDrawn(elemLo, elemHi);
                if (!alwaysDrawn && this.isAlwaysDrawnExclusive)
                    return undefined;
                // Element overrides take precedence
                elemApp = this.getElementOverrides(elemLo, elemHi, animationNodeId);
                if (undefined !== elemApp)
                    app = undefined !== modelApp ? elemApp.extendAppearance(app) : elemApp;
            }
            if (bentleyjs_core_1.Id64.isValidUint32Pair(subcatLo, subcatHi)) {
                if (!alwaysDrawn && !this.isSubCategoryVisibleInModel(subcatLo, subcatHi, modelLo, modelHi))
                    return undefined;
                const subCat = this.getSubCategoryOverrides(subcatLo, subcatHi);
                if (undefined !== subCat)
                    app = subCat.extendAppearance(app);
            }
            if (undefined === elemApp && undefined === modelApp)
                app = this._defaultOverrides.extendAppearance(app);
            let visible = alwaysDrawn || this.isClassVisible(geomClass);
            if (visible && app.isFullyTransparent)
                visible = false; // don't bother rendering something with full transparency...
            return visible ? app : undefined;
        }
        /** Classifiers behave totally differently...in particular they are never invisible unless fully-transparent.
         * @internal
         */
        getClassifierAppearance(elemLo, elemHi, subcatLo, subcatHi, modelLo, modelHi) {
            let app = Appearance.defaults;
            const modelApp = this.getModelOverrides(modelLo, modelHi);
            if (undefined !== modelApp)
                app = modelApp.extendAppearance(app);
            const elemApp = this.getElementOverrides(elemLo, elemHi, 0);
            if (undefined !== elemApp)
                app = undefined !== modelApp ? elemApp.extendAppearance(app) : elemApp;
            if (bentleyjs_core_1.Id64.isValidUint32Pair(subcatLo, subcatHi)) {
                const subCat = this.getSubCategoryOverrides(subcatLo, subcatHi);
                if (undefined !== subCat)
                    app = subCat.extendAppearance(app);
            }
            if (undefined === elemApp && undefined === modelApp)
                app = this._defaultOverrides.extendAppearance(app);
            if (app.isFullyTransparent)
                return undefined;
            else
                return app;
        }
        /** @internal */
        isClassVisible(geomClass) {
            switch (geomClass) {
                case imodeljs_common_1.GeometryClass.Construction: return this._constructions;
                case imodeljs_common_1.GeometryClass.Dimension: return this._dimensions;
                case imodeljs_common_1.GeometryClass.Pattern: return this._patterns;
                default: return true;
            }
        }
        /** Specify overrides for all elements within the specified model.
         * @param id The Id of the model.
         * @param app The symbology overrides.
         * @param replaceExisting Specifies whether to replace a pre-existing override for the same model.
         * @note These overrides take priority over all other overrides.
         * @note If [[defaultOverrides]] are defined, they will not apply to any element within this model, even if the supplied Appearance overrides nothing.
         */
        overrideModel(id, app, replaceExisting = true) {
            const idLo = bentleyjs_core_1.Id64.getLowerUint32(id);
            const idHi = bentleyjs_core_1.Id64.getUpperUint32(id);
            if (replaceExisting || undefined === this.getModelOverrides(idLo, idHi))
                this._modelOverrides.set(idLo, idHi, app);
        }
        /** Specify overrides for all geometry belonging to the specified [[SubCategory]].
         * @param id The Id of the subcategory.
         * @param app The symbology overrides.
         * @param replaceExisting Specifies whether to replace a pre-existing override for the same subcategory.
         * @note These overrides have lower priority than element and model overrides.
         * @note If [[defaultOverrides]] are defined, they will not apply to any geometry within this subcategory, even if the supplied Appearance overrides nothing.
         */
        overrideSubCategory(id, app, replaceExisting = true) {
            // NB: We used to do nothing if this.isSubCategoryVisible() => false but now models can turn invisible subcategories visible in their own context.
            const idLo = bentleyjs_core_1.Id64.getLowerUint32(id);
            const idHi = bentleyjs_core_1.Id64.getUpperUint32(id);
            // NB: Appearance may specify no overridden symbology - this means "don't apply the default overrides to this subcategory"
            if (replaceExisting || undefined === this.getSubCategoryOverrides(idLo, idHi))
                this._subCategoryOverrides.set(idLo, idHi, app);
        }
        /** Specify overrides for all geometry originating from the specified element.
         * @param id The Id of the element.
         * @param app The symbology overrides.
         * @param replaceExisting Specifies whether to replace a pre-existing override for the same element.
         * @note These overrides take precedence over subcategory overrides, but not over model overrides.
         * @note If [[defaultOverrides]] are defined, they will not apply to this element, even if the supplied Appearance overrides nothing.
         */
        overrideElement(id, app, replaceExisting = true) {
            const idLo = bentleyjs_core_1.Id64.getLowerUint32(id);
            const idHi = bentleyjs_core_1.Id64.getUpperUint32(id);
            if (this.isNeverDrawn(idLo, idHi, 0))
                return;
            // NB: Appearance may specify no overridden symbology - this means "don't apply the default overrides to this element"
            if (replaceExisting || undefined === this.getElementOverrides(idLo, idHi, 0))
                this._elementOverrides.set(idLo, idHi, app);
        }
        /** Specify overrides for all geometry originating from the specified animation node.
         * @param id The Id of the animation node.
         * @param app The symbology overrides.
         * @note These overides do not take precedence over element overrides.
         */
        overrideAnimationNode(id, app) { this.animationNodeOverrides.set(id, app); }
        /** Defines a default Appearance to be applied to any [Feature]($common) *not* explicitly overridden.
         * @param appearance The symbology overides.
         * @param replaceExisting Specifies whether to replace the current default overrides if they are already defined.
         */
        setDefaultOverrides(appearance, replaceExisting = true) {
            if (replaceExisting || !appearance.overridesSymbology)
                this._defaultOverrides = appearance;
        }
        /** Initialize these Overrides based on a specific view.
         * @internal
         */
        initFromView(view) {
            this._initFromView(view);
            this._initSubCategoryOverrides(view);
        }
        /** Initialize these Overrides based on a specific viewport.
         * @internal
         */
        initFromViewport(viewport) {
            const view = viewport.view;
            this._initFromView(view);
            if (undefined !== viewport.neverDrawn)
                this.setNeverDrawnSet(viewport.neverDrawn);
            if (undefined !== viewport.alwaysDrawn)
                this.setAlwaysDrawnSet(viewport.alwaysDrawn, viewport.isAlwaysDrawnExclusive);
            if (undefined !== view.scheduleScript)
                view.scheduleScript.getSymbologyOverrides(this, viewport.scheduleTime);
            if (undefined !== viewport.featureOverrideProvider)
                viewport.featureOverrideProvider.addFeatureOverrides(this, viewport);
            viewport.addModelSubCategoryVisibilityOverrides(this, this._modelSubCategoryOverrides);
            // This will include any per-model subcategory visibility overrides added above.
            this._initSubCategoryOverrides(view);
        }
        _initFromView(view) {
            const { viewFlags } = view;
            const { constructions, dimensions, patterns } = viewFlags;
            this.neverDrawnAnimationNodes.clear();
            this.animationNodeOverrides.clear();
            const excludedElements = view.displayStyle.settings.excludedElements;
            excludedElements.forEach((element) => {
                this.setNeverDrawn(element);
            });
            this._constructions = constructions;
            this._dimensions = dimensions;
            this._patterns = patterns;
            this._lineWeights = viewFlags.weights;
            for (const categoryId of view.categorySelector.categories) {
                const subCategoryIds = view.iModel.subcategories.getSubCategories(categoryId);
                if (undefined === subCategoryIds)
                    continue;
                for (const subCategoryId of subCategoryIds) {
                    if (view.isSubCategoryVisible(subCategoryId)) {
                        const idLo = bentleyjs_core_1.Id64.getLowerUint32(subCategoryId);
                        const idHi = bentleyjs_core_1.Id64.getUpperUint32(subCategoryId);
                        this._visibleSubCategories.add(idLo, idHi);
                    }
                }
            }
        }
        _initSubCategoryOverrides(view) {
            const addOverride = (idLo, idHi) => {
                const subCategoryId = bentleyjs_core_1.Id64.fromUint32Pair(idLo, idHi);
                const ovr = view.getSubCategoryOverride(subCategoryId);
                if (undefined !== ovr) {
                    const app = Appearance.fromSubCategoryOverride(ovr);
                    if (app.overridesSymbology)
                        this._subCategoryOverrides.set(idLo, idHi, app);
                }
            };
            // Add overrides for all subcategories visible in the view
            this._visibleSubCategories.forEach((idLo, idHi) => {
                addOverride(idLo, idHi);
            });
            // Add overrides for all subcategories overridden to be visible in specific models
            this._modelSubCategoryOverrides.forEach((_modelIdLo, _modelIdHi, subcats) => {
                subcats.forEach((idLo, idHi) => {
                    if (!this.isSubCategoryVisible(idLo, idHi)) {
                        // Overridden to be visible in one or more models - will need the appearance overrides
                        addOverride(idLo, idHi);
                    }
                });
            });
        }
        /** Returns true if geometry belonging to the specified subcategory will be drawn. */
        isSubCategoryIdVisible(id) { return this.isSubCategoryVisible(bentleyjs_core_1.Id64.getLowerUint32(id), bentleyjs_core_1.Id64.getUpperUint32(id)); }
        /** Returns the overrides applied to geometry belonging to the specified model, if any such are defined. */
        getModelOverridesById(id) { return this.getModelOverrides(bentleyjs_core_1.Id64.getLowerUint32(id), bentleyjs_core_1.Id64.getUpperUint32(id)); }
        /** Returns the overrides applied to geometry belonging to the specified element, if any such are defined. */
        getElementOverridesById(id) { return this.getElementOverrides(bentleyjs_core_1.Id64.getLowerUint32(id), bentleyjs_core_1.Id64.getUpperUint32(id), 0); }
        /** Returns the overrides applied to geometry belonging to the specified subcategory, if any such are defined. */
        getSubCategoryOverridesById(id) { return this.getSubCategoryOverrides(bentleyjs_core_1.Id64.getLowerUint32(id), bentleyjs_core_1.Id64.getUpperUint32(id)); }
        /** Returns true if the specified Feature will be drawn. */
        isFeatureVisible(feature) {
            const { elementId, subCategoryId, geometryClass } = feature;
            const isValidElemId = !bentleyjs_core_1.Id64.isInvalid(elementId);
            const elemIdParts = isValidElemId ? bentleyjs_core_1.Id64.getUint32Pair(elementId) : undefined;
            if (undefined !== elemIdParts && this.isNeverDrawn(elemIdParts.lower, elemIdParts.upper, 0))
                return false;
            const alwaysDrawn = undefined !== elemIdParts && this.isAlwaysDrawn(elemIdParts.lower, elemIdParts.upper);
            if (alwaysDrawn || this.isAlwaysDrawnExclusive)
                return alwaysDrawn;
            // NB: This ignores per-model subcategory visibility overrides, because caller did not specify a model.
            if (!this.isSubCategoryIdVisible(subCategoryId))
                return false;
            return this.isClassVisible(geometryClass);
        }
    }
    Overrides._weight1Appearance = Appearance.fromJSON({ weight: 1 });
    FeatureSymbology.Overrides = Overrides;
})(FeatureSymbology = exports.FeatureSymbology || (exports.FeatureSymbology = {}));


/***/ }),

/***/ "./lib/render/GraphicBuilder.js":
/*!**************************************!*\
  !*** ./lib/render/GraphicBuilder.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/**
 * Describes the type of a [[GraphicBuilder]], which defines the coordinate system in which the builder's geometry is defined and
 * controls the behavior of the [[RenderGraphic]] produced by the builder.
 * @note For those types for which depth-testing is disabled, the order in which the individual geometric primitives are drawn determines which geometry draws on top of other geometry.
 *  - Within a [[GraphicList]], each [[RenderGraphic]] is rendered in the order in which it appears in the list; and
 *  - Within a single [[RenderGraphic]], each geometric primitive is rendered in the ordered in which it was added to the GraphicBuilder.
 * @public
 */
var GraphicType;
(function (GraphicType) {
    /**
     * Renders behind all other graphics. For example, the border of a [[SheetViewState]] is of this type.
     * Coordinates: [[CoordSystem.View]].
     * [[RenderMode]]: [[RenderMode.SmoothShade]].
     * Lighting: none.
     * Depth-testing: disabled.
     * @see [[Decorations.viewBackground]]
     */
    GraphicType[GraphicType["ViewBackground"] = 0] = "ViewBackground";
    /** Used for the scene itself, dynamics, and 'normal' decorations. */
    /**
     * Renders as if it were part of the scene. All of the [[ViewFlags]] applied to the view's normal geometry also applies to these types of decorations.
     * Coordinates: [[CoordSystem.World]].
     * Lighting and [[RenderMode]]: from view.
     * Depth-testing: enabled.
     * @see [[Decorations.normal]].
     */
    GraphicType[GraphicType["Scene"] = 1] = "Scene";
    /** Renders within the scene. Coordinates: world. RenderMode: smooth. Lighting: default. Z-testing: enabled */
    /** Renders within the scene, but ignores the view's [[ViewFlags]].
     * Coordinates: [[CoordSystem.World]].
     * Lighting: default.
     * [[RenderMode]]: [[RenderMode.SmoothShade]].
     * Depth-testing: enabled.
     * @see [[Decorations.world]].
     */
    GraphicType[GraphicType["WorldDecoration"] = 2] = "WorldDecoration";
    /**
     * Renders as an overlay on top of the scene. These decorations differ from [[GraphicType.WorldDecoration]] only in that depth-testing is disabled.
     * For example, the ACS triad and [[WindowAreaTool]] decorations are of this type.
     * Coordinates: [[CoordSystem.World]].
     * [[RenderMode]]: [[RenderMode.SmoothShade]]
     * Lighting: default.
     * Depth-testing: disabled.
     * Renders atop the scene. Coordinates: world. RenderMode: smooth. Lighting: none. Z-testing: disabled
     * @note Overlay decorations typically employ some degree of transparency to ensure that they do not fully obscure the scene.
     * @see [[Decorations.worldOverlay]]
     */
    GraphicType[GraphicType["WorldOverlay"] = 3] = "WorldOverlay";
    /**
     * Renders as an overlay on top of the scene. These decorations differ from [[GraphicType.WorldOverlay]] only in that their geometry is defined in view coordinates rather than world.
     * Coordinates: [[CoordSystem.View]].
     * [[RenderMode]]: [[RenderMode.SmoothShade]]
     * Lighting: default.
     * Depth-testing: disabled.
     * @note For more flexibility in defining view overlay decorations, consider using a [[CanvasDecorationList]].
     * @see [[Decorations.viewOverlay]]
     */
    GraphicType[GraphicType["ViewOverlay"] = 4] = "ViewOverlay";
})(GraphicType = exports.GraphicType || (exports.GraphicType = {}));
/** Provides methods for constructing a [[RenderGraphic]] from geometric primitives.
 * GraphicBuilder is primarily used for creating [[Decorations]] to be displayed inside a [[Viewport]].
 *
 * The typical process for constructing a [[RenderGraphic]] proceeds as follows:
 *  1. Use [[RenderContext.createGraphicBuilder]] to obtain a builder.
 *  2. Set up the symbology using [[GraphicBuilder.activateGraphicParams]].
 *  3. Add one or more geometric primitives using methods like [[GraphicBuilder.addShape]] and [[GraphicBuilder.addLineString]], possibly setting new symbology in between.
 *  4. Use [[GraphicBuilder.finish]] to produce the finished [[RenderGraphic]].
 *
 * @note Most of the methods which add geometry to the builder take ownership of their inputs rather than cloning them.
 * So, for example, if you pass an array of points to addLineString(), you should not subsequently modify that array.
 *
 * @see [[Decorator]].
 * @see [[RenderContext.createGraphicBuilder]].
 * @see [[RenderSystem.createGraphicBuilder]].
 * @see [[DecorateContext]].
 * @see [[DynamicsContext]].
 * @public
 */
class GraphicBuilder {
    /** The local coordinate system transform applied to this builder's geometry. */
    get placement() { return this._placement; }
    set placement(tf) { this._placement.setFrom(tf); }
    /** @internal */
    get isViewCoordinates() { return this.type === GraphicType.ViewBackground || this.type === GraphicType.ViewOverlay; }
    /** @internal */
    get isWorldCoordinates() { return !this.isViewCoordinates; }
    /** @internal */
    get isSceneGraphic() { return this.type === GraphicType.Scene; }
    /** @internal */
    get isViewBackground() { return this.type === GraphicType.ViewBackground; }
    /** @internal */
    get isOverlay() { return this.type === GraphicType.ViewOverlay || this.type === GraphicType.WorldOverlay; }
    /** @internal */
    get iModel() { return this.viewport.iModel; }
    /** @internal */
    constructor(placement = geometry_core_1.Transform.identity, type, viewport, pickId) {
        this._placement = placement;
        this.type = type;
        this.viewport = viewport;
        if (undefined !== pickId)
            this.pickId = pickId.toString();
    }
    /** Add Range3d edges. Useful for debugging.
     * @public
     */
    addRangeBox(range) {
        const frustum = imodeljs_common_1.Frustum.fromRange(range);
        const p = frustum.points;
        this.addLineString([
            p[imodeljs_common_1.Npc.LeftBottomFront],
            p[imodeljs_common_1.Npc.LeftTopFront],
            p[imodeljs_common_1.Npc.RightTopFront],
            p[imodeljs_common_1.Npc.RightBottomFront],
            p[imodeljs_common_1.Npc.RightBottomRear],
            p[imodeljs_common_1.Npc.RightTopRear],
            p[imodeljs_common_1.Npc.LeftTopRear],
            p[imodeljs_common_1.Npc.LeftBottomRear],
            p[imodeljs_common_1.Npc.LeftBottomFront].clone(),
            p[imodeljs_common_1.Npc.RightBottomFront].clone(),
        ]);
        this.addLineString([p[imodeljs_common_1.Npc.LeftTopFront].clone(), p[imodeljs_common_1.Npc.LeftTopRear].clone()]);
        this.addLineString([p[imodeljs_common_1.Npc.RightTopFront].clone(), p[imodeljs_common_1.Npc.RightTopRear].clone()]);
        this.addLineString([p[imodeljs_common_1.Npc.LeftBottomRear].clone(), p[imodeljs_common_1.Npc.RightBottomRear].clone()]);
    }
    /** Sets the current active symbology for this builder. Any new geometry subsequently added will be drawn using the specified symbology.
     * @param lineColor The color in which to draw lines.
     * @param fillColor The color in which to draw filled regions.
     * @param lineWidth The width in pixels to draw lines. The renderer will clamp this value to an integer in the range [1, 32].
     * @param linePixels The pixel pattern in which to draw lines.
     * @see [[GraphicBuilder.activateGraphicParams]] for additional symbology options.
     */
    setSymbology(lineColor, fillColor, lineWidth, linePixels = imodeljs_common_1.LinePixels.Solid) {
        this.activateGraphicParams(imodeljs_common_1.GraphicParams.fromSymbology(lineColor, fillColor, lineWidth, linePixels));
    }
    /** Set blanking fill symbology for decoration.
     * @internal
     */
    setBlankingFill(fillColor) { this.activateGraphicParams(imodeljs_common_1.GraphicParams.fromBlankingFill(fillColor)); }
}
exports.GraphicBuilder = GraphicBuilder;


/***/ }),

/***/ "./lib/render/MockRender.js":
/*!**********************************!*\
  !*** ./lib/render/MockRender.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
Object.defineProperty(exports, "__esModule", { value: true });
const Viewport_1 = __webpack_require__(/*! ../Viewport */ "./lib/Viewport.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/System.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const GeometryListBuilder_1 = __webpack_require__(/*! ./primitives/geometry/GeometryListBuilder */ "./lib/render/primitives/geometry/GeometryListBuilder.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** Contains extensible mock implementations of the various components of a RenderSystem, intended for use in tests.
 * Use these for tests instead of the default RenderSystem wherever possible because:
 *  (1) Electron has a bug on Windows in which it fails to obtain a WebGLRenderingContext when running inside a VM (e.g., during CI job); and
 *  (2) To decouple the logic which uses aspects of the RenderSystem from the full implementation.
 * Any and all of these types can be extended for the purposes of specific tests.
 * To use this:
 *  (1) If overriding anything in the implementation supplied herein, pass a SystemFactory function to MockRender.App.systemFactory.
 *  (2) Call MockRender.App.startup() instead of IModelApp.startup() before tests begin.
 *  (3) Likewise call MockRender.App.shutdown() when finished. This resets the SystemFactory to its default.
 * @internal
 */
var MockRender;
(function (MockRender) {
    /** @internal */
    class Target extends System_1.RenderTarget {
        constructor(_system) {
            super();
            this._system = _system;
        }
        get renderSystem() { return this._system; }
        get cameraFrustumNearScaleLimit() { return 0; }
        get wantInvertBlackBackground() { return false; }
        get animationFraction() { return 0; }
        set animationFraction(_fraction) { }
        changeScene(_scene) { }
        changeBackgroundMap(_backgroundMap) { }
        changeDynamics(_dynamics) { }
        changeDecorations(_decs) { }
        changeRenderPlan(_plan) { }
        drawFrame(_sceneTime) { }
        updateViewRect() { return false; }
        readPixels(_rect, _selector, receiver, _excludeNonLocatable) { receiver(undefined); }
    }
    MockRender.Target = Target;
    /** @internal */
    class OnScreenTarget extends Target {
        constructor(system, _canvas) {
            super(system);
            this._canvas = _canvas;
        }
        get viewRect() { return new Viewport_1.ViewRect(0, 0, this._canvas.clientWidth, this._canvas.clientHeight); }
        setViewRect(_rect, _temp) { }
    }
    MockRender.OnScreenTarget = OnScreenTarget;
    /** @internal */
    class OffScreenTarget extends Target {
        constructor(system, _viewRect) {
            super(system);
            this._viewRect = _viewRect;
        }
        get viewRect() { return this._viewRect; }
        setViewRect(rect, _temp) { this._viewRect.setFrom(rect); }
    }
    MockRender.OffScreenTarget = OffScreenTarget;
    /** @internal */
    class Builder extends GeometryListBuilder_1.PrimitiveBuilder {
        constructor(system, placement = geometry_core_1.Transform.identity, type, viewport, pickId) {
            super(system, type, viewport, placement, pickId);
        }
    }
    MockRender.Builder = Builder;
    /** @internal */
    class Graphic extends System_1.RenderGraphic {
        constructor() { super(); }
        dispose() { }
        collectStatistics(_stats) { }
    }
    MockRender.Graphic = Graphic;
    /** @internal */
    class List extends Graphic {
        constructor(graphics) {
            super();
            this.graphics = graphics;
        }
        dispose() {
            for (const graphic of this.graphics)
                bentleyjs_core_1.dispose(graphic);
            this.graphics.length = 0;
        }
    }
    MockRender.List = List;
    /** @internal */
    class Branch extends Graphic {
        constructor(branch, transform, clips) {
            super();
            this.branch = branch;
            this.transform = transform;
            this.clips = clips;
        }
        dispose() { this.branch.dispose(); }
    }
    MockRender.Branch = Branch;
    /** @internal */
    class Batch extends Graphic {
        constructor(graphic, featureTable, range) {
            super();
            this.graphic = graphic;
            this.featureTable = featureTable;
            this.range = range;
        }
        dispose() {
            bentleyjs_core_1.dispose(this.graphic);
        }
    }
    MockRender.Batch = Batch;
    /** @internal */
    class System extends System_1.RenderSystem {
        constructor() { super(); }
        get isValid() { return true; }
        dispose() { }
        get maxTextureSize() { return 4096; }
        createTarget(canvas) { return new OnScreenTarget(this, canvas); }
        createOffscreenTarget(rect) { return new OffScreenTarget(this, rect); }
        createGraphicBuilder(placement, type, viewport, pickableId) { return new Builder(this, placement, type, viewport, pickableId); }
        createGraphicList(primitives) { return new List(primitives); }
        createGraphicBranch(branch, transform, clips) { return new Branch(branch, transform, clips); }
        createBatch(graphic, features, range) { return new Batch(graphic, features, range); }
        createMesh(_params) { return new Graphic(); }
        createPolyline(_params) { return new Graphic(); }
        createPointString(_params) { return new Graphic(); }
        createPointCloud(_args, _imodel) { return new Graphic(); }
    }
    MockRender.System = System;
    /** An implementation of IModelApp which uses a MockRender.System by default.
     * @internal
     */
    class App {
        static startup(opts) {
            opts = opts ? opts : {};
            opts.renderSys = this.systemFactory();
            IModelApp_1.IModelApp.startup(opts);
        }
        static shutdown() {
            this.systemFactory = () => App.createDefaultRenderSystem();
            IModelApp_1.IModelApp.shutdown();
        }
        static createDefaultRenderSystem() { return new System(); }
    }
    App.systemFactory = () => App.createDefaultRenderSystem();
    MockRender.App = App;
})(MockRender = exports.MockRender || (exports.MockRender = {}));


/***/ }),

/***/ "./lib/render/System.js":
/*!******************************!*\
  !*** ./lib/render/System.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const ImageUtil_1 = __webpack_require__(/*! ../ImageUtil */ "./lib/ImageUtil.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const Viewport_1 = __webpack_require__(/*! ../Viewport */ "./lib/Viewport.js");
const MeshPrimitives_1 = __webpack_require__(/*! ./primitives/mesh/MeshPrimitives */ "./lib/render/primitives/mesh/MeshPrimitives.js");
const VertexTable_1 = __webpack_require__(/*! ./primitives/VertexTable */ "./lib/render/primitives/VertexTable.js");
// tslint:disable:no-const-enum
/** Contains metadata about memory consumed by the render system or aspect thereof.
 * @internal
 */
var RenderMemory;
(function (RenderMemory) {
    /** Describes memory consumed by a particular type of resource.
     * @internal
     */
    class Consumers {
        constructor() {
            this.totalBytes = 0; // total number of bytes consumed by all consumers
            this.maxBytes = 0; // largest number of bytes consumed by a single consumer
            this.count = 0; // total number of consumers of this type
        }
        addConsumer(numBytes) {
            this.totalBytes += numBytes;
            this.maxBytes = Math.max(this.maxBytes, numBytes);
            ++this.count;
        }
        clear() {
            this.totalBytes = this.maxBytes = this.count = 0;
        }
    }
    RenderMemory.Consumers = Consumers;
    /** Describes memory consumed by GPU-allocated buffers.
     * @internal
     */
    class Buffers extends Consumers {
        constructor() {
            super();
            this.consumers = [];
            for (let i = 0; i < 8 /* COUNT */; i++)
                this.consumers[i] = new Consumers();
        }
        get surfaces() { return this.consumers[0 /* Surfaces */]; }
        get visibleEdges() { return this.consumers[1 /* VisibleEdges */]; }
        get silhouetteEdges() { return this.consumers[2 /* SilhouetteEdges */]; }
        get polylineEdges() { return this.consumers[3 /* PolylineEdges */]; }
        get polylines() { return this.consumers[4 /* Polylines */]; }
        get pointStrings() { return this.consumers[5 /* PointStrings */]; }
        get pointClouds() { return this.consumers[6 /* PointClouds */]; }
        get instances() { return this.consumers[7 /* Instances */]; }
        clear() {
            for (const consumer of this.consumers)
                consumer.clear();
            super.clear();
        }
        addBuffer(type, numBytes) {
            this.addConsumer(numBytes);
            this.consumers[type].addConsumer(numBytes);
        }
    }
    RenderMemory.Buffers = Buffers;
    /** @internal */
    class Statistics {
        constructor() {
            this._totalBytes = 0;
            this.buffers = new Buffers();
            this.consumers = [];
            for (let i = 0; i < 7 /* COUNT */; i++)
                this.consumers[i] = new Consumers();
        }
        get totalBytes() { return this._totalBytes; }
        get textures() { return this.consumers[0 /* Textures */]; }
        get vertexTables() { return this.consumers[1 /* VertexTables */]; }
        get featureTables() { return this.consumers[2 /* FeatureTables */]; }
        get featureOverrides() { return this.consumers[3 /* FeatureOverrides */]; }
        get clipVolumes() { return this.consumers[4 /* ClipVolumes */]; }
        get planarClassifiers() { return this.consumers[5 /* PlanarClassifiers */]; }
        get shadowMaps() { return this.consumers[6 /* ShadowMaps */]; }
        addBuffer(type, numBytes) {
            this._totalBytes += numBytes;
            this.buffers.addBuffer(type, numBytes);
        }
        addConsumer(type, numBytes) {
            this._totalBytes += numBytes;
            this.consumers[type].addConsumer(numBytes);
        }
        clear() {
            this._totalBytes = 0;
            this.buffers.clear();
            for (const consumer of this.consumers)
                consumer.clear();
        }
        addTexture(numBytes) { this.addConsumer(0 /* Textures */, numBytes); }
        addVertexTable(numBytes) { this.addConsumer(1 /* VertexTables */, numBytes); }
        addFeatureTable(numBytes) { this.addConsumer(2 /* FeatureTables */, numBytes); }
        addFeatureOverrides(numBytes) { this.addConsumer(3 /* FeatureOverrides */, numBytes); }
        addClipVolume(numBytes) { this.addConsumer(4 /* ClipVolumes */, numBytes); }
        addPlanarClassifier(numBytes) { this.addConsumer(5 /* PlanarClassifiers */, numBytes); }
        addShadowMap(numBytes) { this.addConsumer(6 /* ShadowMaps */, numBytes); }
        addSurface(numBytes) { this.addBuffer(0 /* Surfaces */, numBytes); }
        addVisibleEdges(numBytes) { this.addBuffer(1 /* VisibleEdges */, numBytes); }
        addSilhouetteEdges(numBytes) { this.addBuffer(2 /* SilhouetteEdges */, numBytes); }
        addPolylineEdges(numBytes) { this.addBuffer(3 /* PolylineEdges */, numBytes); }
        addPolyline(numBytes) { this.addBuffer(4 /* Polylines */, numBytes); }
        addPointString(numBytes) { this.addBuffer(5 /* PointStrings */, numBytes); }
        addPointCloud(numBytes) { this.addBuffer(6 /* PointClouds */, numBytes); }
        addInstances(numBytes) { this.addBuffer(7 /* Instances */, numBytes); }
    }
    RenderMemory.Statistics = Statistics;
})(RenderMemory = exports.RenderMemory || (exports.RenderMemory = {}));
/** A RenderPlan holds a Frustum and the render settings for displaying a RenderScene into a RenderTarget.
 * @internal
 */
class RenderPlan {
    get frustum() { return this._curFrustum.getFrustum(); }
    get fraction() { return this._curFrustum.frustFraction; }
    selectExpandedFrustum() { if (undefined !== this.expandedFrustum)
        this._curFrustum = this.expandedFrustum; }
    selectViewFrustum() { this._curFrustum = this.viewFrustum; }
    constructor(is3d, viewFlags, bgColor, monoColor, hiliteSettings, aaLines, aaText, viewFrustum, isFadeOutActive, expandedFrustum, activeVolume, hline, lights, analysisStyle, ao) {
        this.is3d = is3d;
        this.viewFlags = viewFlags;
        this.bgColor = bgColor;
        this.monoColor = monoColor;
        this.hiliteSettings = hiliteSettings;
        this.aaLines = aaLines;
        this.aaText = aaText;
        this.activeVolume = activeVolume;
        this.hline = hline;
        this.lights = lights;
        this._curFrustum = this.viewFrustum = viewFrustum;
        this.expandedFrustum = expandedFrustum;
        this.analysisStyle = analysisStyle;
        this.ao = ao;
        this.isFadeOutActive = isFadeOutActive;
    }
    static createFromViewport(vp) {
        const view = vp.view;
        const style = view.displayStyle;
        const hline = style.is3d() ? style.settings.hiddenLineSettings : undefined;
        const ao = style.is3d() ? style.settings.ambientOcclusionSettings : undefined;
        const lights = undefined; // view.is3d() ? view.getLights() : undefined
        const clipVec = view.getViewClip();
        const expandedFrustum = (undefined === vp.backgroundMapPlane) ? undefined : Viewport_1.ViewFrustum.createFromViewportAndPlane(vp, vp.backgroundMapPlane);
        const rp = new RenderPlan(view.is3d(), style.viewFlags, view.backgroundColor, style.monochromeColor, vp.hilite, vp.wantAntiAliasLines, vp.wantAntiAliasText, vp.viewFrustum, vp.isFadeOutActive, expandedFrustum, clipVec, hline, lights, style.analysisStyle, ao);
        if (rp.analysisStyle !== undefined && rp.analysisStyle.scalarThematicSettings !== undefined)
            rp.analysisTexture = vp.target.renderSystem.getGradientTexture(imodeljs_common_1.Gradient.Symb.createThematic(rp.analysisStyle.scalarThematicSettings), vp.iModel);
        return rp;
    }
}
exports.RenderPlan = RenderPlan;
/** Abstract representation of an object which can be rendered by a [[RenderSystem]].
 * Two broad classes of graphics exist:
 *  - "Scene" graphics generated on the back-end to represent the contents of the models displayed in a [[Viewport]]; and
 *  - [[Decorations]] created on the front-end to be rendered along with the scene.
 * The latter are produced using a [[GraphicBuilder]].
 * @public
 */
class RenderGraphic {
}
exports.RenderGraphic = RenderGraphic;
/** An opaque representation of a clip volume applied to geometry within a [[Viewport]].
 * A RenderClipVolume is created from a [[ClipVector]] and takes ownership of that ClipVector, expecting that it will not be modified while the RenderClipVolume still references it.
 * @see [System.createClipVolume]
 * @beta
 */
class RenderClipVolume {
    constructor(clipVector) {
        this.clipVector = clipVector;
    }
}
exports.RenderClipVolume = RenderClipVolume;
/** An opaque representation of a shadow map.
 * @internal
 */
class RenderSolarShadowMap {
}
exports.RenderSolarShadowMap = RenderSolarShadowMap;
/** An opaque representation of a planar classifier applied to geometry within a [[Viewport]].
 * @beta
 */
class RenderPlanarClassifier {
}
exports.RenderPlanarClassifier = RenderPlanarClassifier;
/** Models that may be used as classifiers.  Detecting their type requires a range query.
 * @beta
 */
class RenderClassifierModel {
    constructor(type) {
        this.type = type;
    }
}
exports.RenderClassifierModel = RenderClassifierModel;
/** A set of [[RenderGraphic]]s and [[CanvasDecoration]]s produced by [[Tool]]s and [[Decorator]]s, used to decorate the contents of a [[Viewport]].
 * @public
 */
class Decorations {
    /** A view decoration created from a [[SkyBox]] rendered behind all other geometry to provide environmental context. */
    get skyBox() { return this._skyBox; }
    set skyBox(skyBox) { bentleyjs_core_1.dispose(this._skyBox); this._skyBox = skyBox; }
    /** A view decoration drawn as the background of the view. @see [[GraphicType.ViewBackground]]. */
    get viewBackground() { return this._viewBackground; }
    set viewBackground(viewBackground) { bentleyjs_core_1.dispose(this._viewBackground); this._viewBackground = viewBackground; }
    /** Decorations drawn as if they were part of the scene. @see [[GraphicType.Scene]]. */
    get normal() { return this._normal; }
    set normal(normal) { bentleyjs_core_1.disposeArray(this._normal); this._normal = normal; }
    /** Decorations drawn as if they were part of the world, but ignoring the view's [[ViewFlags]]. @see [[GraphicType.WorldDecoration]]. */
    get world() { return this._world; }
    set world(world) { bentleyjs_core_1.disposeArray(this._world); this._world = world; }
    /** Overlay decorations drawn in world coordinates. @see [[GraphicType.WorldOverlay]]. */
    get worldOverlay() { return this._worldOverlay; }
    set worldOverlay(worldOverlay) { bentleyjs_core_1.disposeArray(this._worldOverlay); this._worldOverlay = worldOverlay; }
    /** Overlay decorations drawn in view coordinates. @see [[GraphicType.ViewOverlay]]. */
    get viewOverlay() { return this._viewOverlay; }
    set viewOverlay(viewOverlay) { bentleyjs_core_1.disposeArray(this._viewOverlay); this._viewOverlay = viewOverlay; }
    dispose() {
        this.skyBox = undefined;
        this.viewBackground = undefined;
        this.world = undefined;
        this.worldOverlay = undefined;
        this.viewOverlay = undefined;
        this.normal = undefined;
    }
}
exports.Decorations = Decorations;
/**
 * A node in a scene graph. The branch itself is not renderable. Instead it contains a list of RenderGraphics,
 * and a transform, symbology overrides, and clip volume which are to be applied when rendering them.
 * Branches can be nested to build an arbitrarily-complex scene graph.
 * @see [[RenderSystem.createBranch]]
 * @public
 */
class GraphicBranch {
    /** Constructor
     * @param ownsEntries If true, when this branch is [[dispose]]d, all of the [[RenderGraphic]]s it contains will also be disposed.
     */
    constructor(ownsEntries = false) {
        /** The child nodes of this branch */
        this.entries = [];
        this._viewFlagOverrides = new imodeljs_common_1.ViewFlag.Overrides();
        this.ownsEntries = ownsEntries;
    }
    /** Add a graphic to this branch. */
    add(graphic) { this.entries.push(graphic); }
    /** @internal */
    getViewFlags(flags, out) { return this._viewFlagOverrides.apply(flags.clone(out)); }
    /** @internal */
    setViewFlags(flags) { this._viewFlagOverrides.overrideAll(flags); }
    /** @internal */
    setViewFlagOverrides(ovr) { this._viewFlagOverrides.copyFrom(ovr); }
    dispose() { this.clear(); }
    get isEmpty() { return 0 === this.entries.length; }
    /** Empties the list of [[RenderGraphic]]s contained in this branch, and if the [[GraphicBranch.ownsEntries]] flag is set, also disposes of them. */
    clear() {
        if (this.ownsEntries)
            bentleyjs_core_1.disposeArray(this.entries);
        else
            this.entries.length = 0;
    }
    /** @internal */
    collectStatistics(stats) {
        for (const entry of this.entries)
            entry.collectStatistics(stats);
    }
}
exports.GraphicBranch = GraphicBranch;
/** Describes aspects of a pixel as read from a [[Viewport]].
 * @see [[Viewport.readPixels]]
 * @beta
 */
var Pixel;
(function (Pixel) {
    /** Describes a single pixel within a [[Pixel.Buffer]]. */
    class Data {
        /** @internal */
        constructor(feature, distanceFraction = -1.0, type = 0 /* Unknown */, planarity = 0 /* Unknown */, featureTable) {
            this.feature = feature;
            this.distanceFraction = distanceFraction;
            this.type = type;
            this.planarity = planarity;
            this.featureTable = featureTable;
        }
        get elementId() { return undefined !== this.feature ? this.feature.elementId : undefined; }
        get subCategoryId() { return undefined !== this.feature ? this.feature.subCategoryId : undefined; }
        get geometryClass() { return undefined !== this.feature ? this.feature.geometryClass : undefined; }
    }
    Pixel.Data = Data;
})(Pixel = exports.Pixel || (exports.Pixel = {}));
/**
 * An immutable, packed representation of a [[FeatureTable]]. The features are packed into a single array of 32-bit integer values,
 * wherein each feature occupies 3 32-bit integers.
 * @internal
 */
class PackedFeatureTable {
    get byteLength() { return this._data.byteLength; }
    /** Construct a PackedFeatureTable from the packed binary data.
     * This is used internally when deserializing Tiles in iMdl format.
     * @internal
     */
    constructor(data, modelId, numFeatures, maxFeatures, type, animationNodeIds) {
        this._data = data;
        this.modelId = modelId;
        this.maxFeatures = maxFeatures;
        this.numFeatures = numFeatures;
        this.type = type;
        this._animationNodeIds = animationNodeIds;
        switch (this.numFeatures) {
            case 0:
                this.anyDefined = false;
                break;
            case 1:
                this.anyDefined = this.getFeature(0).isDefined;
                break;
            default:
                this.anyDefined = true;
                break;
        }
        bentleyjs_core_1.assert(this._data.length >= this._subCategoriesOffset);
        bentleyjs_core_1.assert(this.maxFeatures >= this.numFeatures);
        bentleyjs_core_1.assert(undefined === this._animationNodeIds || this._animationNodeIds.length === this.numFeatures);
    }
    /** Create a packed feature table from a [[FeatureTable]]. */
    static pack(featureTable) {
        // We must determine how many subcategories we have ahead of time to compute the size of the Uint32Array, as
        // the array cannot be resized after it is created.
        // We are not too worried about this as FeatureTables created on the front-end will contain few if any features; those obtained from the
        // back-end arrive within tiles already in the packed format.
        const subcategories = new Map();
        for (const iv of featureTable.getArray()) {
            const found = subcategories.get(iv.value.subCategoryId.toString());
            if (undefined === found)
                subcategories.set(iv.value.subCategoryId, subcategories.size);
        }
        // We need 3 32-bit integers per feature, plus 2 32-bit integers per subcategory.
        const subCategoriesOffset = 3 * featureTable.length;
        const nUint32s = subCategoriesOffset + 2 * subcategories.size;
        const uint32s = new Uint32Array(nUint32s);
        for (const iv of featureTable.getArray()) {
            const feature = iv.value;
            const index = iv.index * 3;
            let subCategoryIndex = subcategories.get(feature.subCategoryId);
            bentleyjs_core_1.assert(undefined !== subCategoryIndex); // we inserted it above...
            subCategoryIndex |= (feature.geometryClass << 24);
            uint32s[index + 0] = bentleyjs_core_1.Id64.getLowerUint32(feature.elementId);
            uint32s[index + 1] = bentleyjs_core_1.Id64.getUpperUint32(feature.elementId);
            uint32s[index + 2] = subCategoryIndex;
        }
        subcategories.forEach((index, id, _map) => {
            const index32 = subCategoriesOffset + 2 * index;
            uint32s[index32 + 0] = bentleyjs_core_1.Id64.getLowerUint32(id);
            uint32s[index32 + 1] = bentleyjs_core_1.Id64.getUpperUint32(id);
        });
        return new PackedFeatureTable(uint32s, featureTable.modelId, featureTable.length, featureTable.maxFeatures, featureTable.type);
    }
    /** Retrieve the Feature associated with the specified index. */
    getFeature(featureIndex) {
        const packed = this.getPackedFeature(featureIndex);
        const elemId = bentleyjs_core_1.Id64.fromUint32Pair(packed.elementId.lower, packed.elementId.upper);
        const subcatId = bentleyjs_core_1.Id64.fromUint32Pair(packed.subCategoryId.lower, packed.subCategoryId.upper);
        return new imodeljs_common_1.Feature(elemId, subcatId, packed.geometryClass);
    }
    /** Returns the Feature associated with the specified index, or undefined if the index is out of range. */
    findFeature(featureIndex) {
        return featureIndex < this.numFeatures ? this.getFeature(featureIndex) : undefined;
    }
    /** @internal */
    getElementIdPair(featureIndex) {
        bentleyjs_core_1.assert(featureIndex < this.numFeatures);
        const offset = 3 * featureIndex;
        return {
            lower: this._data[offset],
            upper: this._data[offset + 1],
        };
    }
    /** @internal */
    getSubCategoryIdPair(featureIndex) {
        const index = 3 * featureIndex;
        let subCatIndex = this._data[index + 2];
        subCatIndex = (subCatIndex & 0x00ffffff) >>> 0;
        subCatIndex = subCatIndex * 2 + this._subCategoriesOffset;
        return { lower: this._data[subCatIndex], upper: this._data[subCatIndex + 1] };
    }
    /** @internal */
    getAnimationNodeId(featureIndex) {
        return undefined !== this._animationNodeIds ? this._animationNodeIds[featureIndex] : 0;
    }
    /** @internal */
    getPackedFeature(featureIndex) {
        bentleyjs_core_1.assert(featureIndex < this.numFeatures);
        const index32 = 3 * featureIndex;
        const elementId = { lower: this._data[index32], upper: this._data[index32 + 1] };
        const subCatIndexAndClass = this._data[index32 + 2];
        const geometryClass = (subCatIndexAndClass >>> 24) & 0xff;
        let subCatIndex = (subCatIndexAndClass & 0x00ffffff) >>> 0;
        subCatIndex = subCatIndex * 2 + this._subCategoriesOffset;
        const subCategoryId = { lower: this._data[subCatIndex], upper: this._data[subCatIndex + 1] };
        const animationNodeId = this.getAnimationNodeId(featureIndex);
        return { elementId, subCategoryId, geometryClass, animationNodeId };
    }
    /** Returns the element ID of the Feature associated with the specified index, or undefined if the index is out of range. */
    findElementId(featureIndex) {
        if (featureIndex >= this.numFeatures)
            return undefined;
        else
            return this.readId(3 * featureIndex);
    }
    /** Return true if this table contains exactly 1 feature. */
    get isUniform() { return 1 === this.numFeatures; }
    /** If this table contains exactly 1 feature, return it. */
    get uniform() { return this.isUniform ? this.getFeature(0) : undefined; }
    get isVolumeClassifier() { return imodeljs_common_1.BatchType.VolumeClassifier === this.type; }
    get isPlanarClassifier() { return imodeljs_common_1.BatchType.VolumeClassifier === this.type; }
    get isClassifier() { return this.isVolumeClassifier || this.isPlanarClassifier; }
    /** Unpack the features into a [[FeatureTable]]. */
    unpack() {
        const table = new imodeljs_common_1.FeatureTable(this.maxFeatures, this.modelId);
        for (let i = 0; i < this.numFeatures; i++) {
            const feature = this.getFeature(i);
            table.insertWithIndex(feature, i);
        }
        return table;
    }
    get _subCategoriesOffset() { return this.numFeatures * 3; }
    readId(offset32) {
        return bentleyjs_core_1.Id64.fromUint32Pair(this._data[offset32], this._data[offset32 + 1]);
    }
}
exports.PackedFeatureTable = PackedFeatureTable;
/** A RenderTarget connects a [[Viewport]] to a WebGLRenderingContext to enable the viewport's contents to be displayed on the screen.
 * Application code rarely interacts directly with a RenderTarget - instead, it interacts with a Viewport which forwards requests to the implementation
 * of the RenderTarget.
 * @internal
 */
class RenderTarget {
    pickOverlayDecoration(_pt) { return undefined; }
    static get frustumDepth2d() { return 1.0; } // one meter
    static get maxDisplayPriority() { return (1 << 23) - 32; }
    static get minDisplayPriority() { return -this.maxDisplayPriority; }
    /** Returns a transform mapping an object's display priority to a depth from 0 to frustumDepth2d. */
    static depthFromDisplayPriority(priority) {
        return (priority - this.minDisplayPriority) / (this.maxDisplayPriority - this.minDisplayPriority) * this.frustumDepth2d;
    }
    get animationBranches() { return undefined; }
    set animationBranches(_transforms) { }
    get solarShadowMap() { return undefined; }
    createGraphicBuilder(type, viewport, placement = geometry_core_1.Transform.identity, pickableId) { return this.renderSystem.createGraphicBuilder(placement, type, viewport, pickableId); }
    dispose() { }
    reset() { }
    changePlanarClassifiers(_classifiers) { }
    changeSolarShadowMap(_solarShadowMap) { }
    overrideFeatureSymbology(_ovr) { }
    setHiliteSet(_hilited) { }
    setFlashed(_elementId, _intensity) { }
    onResized() { }
    readImage(_rect, _targetSize, _flipVertically) { return undefined; }
}
exports.RenderTarget = RenderTarget;
/** A RenderSystem provides access to resources used by the internal WebGL-based rendering system.
 * An application rarely interacts directly with the RenderSystem; instead it interacts with types like [[Viewport]] which
 * coordinate with the RenderSystem on the application's behalf.
 * @see [[IModelApp.renderSystem]].
 * @public
 */
class RenderSystem {
    /** Initialize the RenderSystem with the specified options.
     * @note The RenderSystem takes ownership of the supplied Options and freezes it.
     * @internal
     */
    constructor(options) {
        this.options = undefined !== options ? options : {};
        Object.freeze(this.options);
        if (undefined !== this.options.disabledExtensions)
            Object.freeze(this.options.disabledExtensions);
    }
    /** @internal */
    get maxTextureSize() { return 0; }
    /** @internal */
    get supportsInstancing() { return true; }
    /** Find a previously-created [RenderMaterial]($common) by its ID.
     * @param _key The unique ID of the material within the context of the IModelConnection. Typically an element ID.
     * @param _imodel The IModelConnection with which the material is associated.
     * @returns A previously-created material matching the specified ID, or undefined if no such material exists.
     */
    findMaterial(_key, _imodel) { return undefined; }
    /** Create a [RenderMaterial]($common) from parameters
     * If the parameters include a non-empty key, and no previously-created material already exists with that key, the newly-created material will be cached on the IModelConnection such
     * that it can later be retrieved by the same key using [[RenderSystem.findMaterial]].
     * @param _params A description of the material's properties.
     * @param _imodel The IModelConnection associated with the material.
     * @returns the newly-created material, or undefined if the material could not be created or if a material with the same key as that specified in the params already exists.
     */
    createMaterial(_params, _imodel) { return undefined; }
    /** @internal */
    createTriMesh(args, instances) {
        const params = VertexTable_1.MeshParams.create(args);
        return this.createMesh(params, instances);
    }
    /** @internal */
    createIndexedPolylines(args, instances) {
        if (args.flags.isDisjoint) {
            const pointStringParams = VertexTable_1.PointStringParams.create(args);
            return undefined !== pointStringParams ? this.createPointString(pointStringParams, instances) : undefined;
        }
        else {
            const polylineParams = VertexTable_1.PolylineParams.create(args);
            return undefined !== polylineParams ? this.createPolyline(polylineParams, instances) : undefined;
        }
    }
    /** @internal */
    createMesh(_params, _instances) { return undefined; }
    /** @internal */
    createPolyline(_params, _instances) { return undefined; }
    /** @internal */
    createPointString(_params, _instances) { return undefined; }
    /** @internal */
    createPointCloud(_args, _imodel) { return undefined; }
    /** @internal */
    createSheetTilePolyfaces(_corners, _clip) { return []; }
    /** @internal */
    createSheetTile(_tile, _polyfaces, _tileColor) { return []; }
    /** @internal */
    createClipVolume(_clipVector) { return undefined; }
    /** @internal */
    getSpatialClassificationModel(_classifierModelId, _iModel) { return undefined; }
    /** @internal */
    addSpatialClassificationModel(_modelId, _classificationModel, _iModel) { }
    /** @internal */
    createPlanarClassifier(_properties, _tileTree, _classifiedModel, _sceneContext) { return undefined; }
    /** @internal */
    getSolarShadowMap(_frustum, _direction, _settings, _models, _categories, _imodel) { return undefined; }
    /** @internal */
    createTile(tileTexture, corners) {
        const rasterTile = new MeshPrimitives_1.MeshArgs();
        // corners
        // [0] [1]
        // [2] [3]
        // Quantize the points according to their range
        rasterTile.points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.create(...corners)));
        for (let i = 0; i < 4; ++i)
            rasterTile.points.add(corners[i]);
        // Now remove the translation from the quantized points and put it into a transform instead.
        // This prevents graphical artifacts when quantization origin is large relative to quantization scale.
        // ###TODO: Would be better not to create a branch for every tile.
        const qorigin = rasterTile.points.params.origin;
        const transform = geometry_core_1.Transform.createTranslationXYZ(qorigin.x, qorigin.y, qorigin.z);
        qorigin.setZero();
        rasterTile.vertIndices = [0, 1, 2, 2, 1, 3];
        rasterTile.textureUv = [
            new geometry_core_1.Point2d(0.0, 0.0),
            new geometry_core_1.Point2d(1.0, 0.0),
            new geometry_core_1.Point2d(0.0, 1.0),
            new geometry_core_1.Point2d(1.0, 1.0),
        ];
        rasterTile.texture = tileTexture;
        rasterTile.isPlanar = true;
        const trimesh = this.createTriMesh(rasterTile);
        if (undefined === trimesh)
            return undefined;
        const branch = new GraphicBranch(true);
        branch.add(trimesh);
        return this.createBranch(branch, transform);
    }
    /** Create a Graphic for a [[SkyBox]] which encompasses the entire scene, rotating with the camera. */
    createSkyBox(_params) { return undefined; }
    /** Create a RenderGraphic consisting of a list of Graphics, with optional transform and symbology overrides applied to the list */
    createBranch(branch, transform) {
        return this.createGraphicBranch(branch, transform);
    }
    /** Find a previously-created [[RenderTexture]] by its ID.
     * @param _key The unique ID of the texture within the context of the IModelConnection. Typically an element ID.
     * @param _imodel The IModelConnection with which the texture is associated.
     * @returns A previously-created texture matching the specified ID, or undefined if no such texture exists.
     */
    findTexture(_key, _imodel) { return undefined; }
    /** Find or create a [[RenderTexture]] from a persistent texture element.
     * @param id The ID of the texture element.
     * @param iModel The IModel containing the texture element.
     * @returns A Promise resolving to the created RenderTexture or to undefined if the texture could not be created.
     * @note If the texture is successfully created, it will be cached on the IModelConnection such that it can later be retrieved by its ID using [[RenderSystem.findTexture]].
     * @see [[RenderSystem.loadTextureImage]].
     * @internal
     */
    async loadTexture(id, iModel) {
        let texture = this.findTexture(id.toString(), iModel);
        if (undefined === texture) {
            const image = await this.loadTextureImage(id, iModel);
            if (undefined !== image) {
                // This will return a pre-existing RenderTexture if somebody else loaded it while we were awaiting the image.
                texture = this.createTextureFromImage(image.image, imodeljs_common_1.ImageSourceFormat.Png === image.format, iModel, new imodeljs_common_1.RenderTexture.Params(id.toString()));
            }
        }
        return texture;
    }
    /**
     * Load a texture image given the ID of a texture element.
     * @param id The ID of the texture element.
     * @param iModel The IModel containing the texture element.
     * @returns A Promise resolving to a TextureImage created from the texture element's data, or to undefined if the TextureImage could not be created.
     * @see [[RenderSystem.loadTexture]]
     * @internal
     */
    async loadTextureImage(id, iModel) {
        const elemProps = await iModel.elements.getProps(id);
        if (1 !== elemProps.length)
            return undefined;
        const textureProps = elemProps[0];
        if (undefined === textureProps.data || "string" !== typeof (textureProps.data) || undefined === textureProps.format || "number" !== typeof (textureProps.format))
            return undefined;
        const format = textureProps.format;
        if (!imodeljs_common_1.isValidImageSourceFormat(format))
            return undefined;
        const imageSource = new imodeljs_common_1.ImageSource(bentleyjs_core_1.base64StringToUint8Array(textureProps.data), format);
        const imagePromise = ImageUtil_1.imageElementFromImageSource(imageSource);
        return imagePromise.then((image) => ({ image, format }));
    }
    /** Obtain a texture created from a gradient.
     * @param _symb The description of the gradient.
     * @param _imodel The IModelConnection with which the texture is associated.
     * @returns A texture created from the gradient image, or undefined if the texture could not be created.
     * @note If a texture matching the specified gradient already exists, it will be returned.
     * Otherwise, the newly-created texture will be cached on the IModelConnection such that a subsequent call to getGradientTexture with an equivalent gradient will
     * return the previously-created texture.
     * @beta
     */
    getGradientTexture(_symb, _imodel) { return undefined; }
    /** Create a new texture from an [[ImageBuffer]]. */
    createTextureFromImageBuffer(_image, _imodel, _params) { return undefined; }
    /** Create a new texture from an HTML image. Typically the image was extracted from a binary representation of a jpeg or png via [[imageElementFromImageSource]] */
    createTextureFromImage(_image, _hasAlpha, _imodel, _params) { return undefined; }
    /** Create a new texture from an [[ImageSource]]. */
    async createTextureFromImageSource(source, imodel, params) {
        return ImageUtil_1.imageElementFromImageSource(source).then((image) => IModelApp_1.IModelApp.hasRenderSystem ? this.createTextureFromImage(image, imodeljs_common_1.ImageSourceFormat.Png === source.format, imodel, params) : undefined);
    }
    /** Create a new texture from a cube of HTML images.
     * @internal
     */
    createTextureFromCubeImages(_posX, _negX, _posY, _negY, _posZ, _negZ, _imodel, _params) { return undefined; }
    /** @internal */
    onInitialized() { }
    /** @internal */
    enableDiagnostics(_enable) { }
}
exports.RenderSystem = RenderSystem;
/** Clip/Transform for a branch that are varied over time.
 * @internal
 */
class AnimationBranchState {
    constructor(transform, clip, omit) { this.transform = transform; this.clip = clip; this.omit = omit; }
}
exports.AnimationBranchState = AnimationBranchState;


/***/ }),

/***/ "./lib/render/primitives/AuxChannelTable.js":
/*!**************************************************!*\
  !*** ./lib/render/primitives/AuxChannelTable.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
/** @internal */
class AuxChannel {
    constructor(props) {
        this.name = props.name;
        this.inputs = props.inputs;
        this.indices = props.indices;
    }
}
exports.AuxChannel = AuxChannel;
/** @internal */
class AuxDisplacementChannel extends AuxChannel {
    constructor(props) {
        super(props);
        this.qOrigin = Float32Array.from(props.qOrigin);
        this.qScale = Float32Array.from(props.qScale);
    }
}
exports.AuxDisplacementChannel = AuxDisplacementChannel;
/** @internal */
class AuxParamChannel extends AuxChannel {
    constructor(props) {
        super(props);
        this.qOrigin = props.qOrigin[0];
        this.qScale = props.qScale[0];
    }
}
exports.AuxParamChannel = AuxParamChannel;
/**
 * Represents one or more channels of auxiliary per-vertex data which can be used to animate and resymbolize a mesh in various ways.
 * Each channel holds a fixed number of bytes for each vertex (typically 2 bytes for normals and params, 6 bytes for displacements).
 * The channels are interleaved in a rectangular array such that the data for each vertex is stored contiguously; that is, if a displacement and
 * a normal channel exist, then the first vertex's displacement is followed by the first vertex's normal, which is followed by the second
 * vertex's displacement and normal; and so on.
 * @internal
 */
class AuxChannelTable {
    constructor(props, displacements, normals, params) {
        this.data = props.data;
        this.width = props.width;
        this.height = props.height;
        this.numVertices = props.count;
        this.numBytesPerVertex = props.numBytesPerVertex;
        this.displacements = displacements;
        this.normals = normals;
        this.params = params;
    }
    static fromJSON(props) {
        let displacements;
        let normals;
        let params;
        if (undefined !== props.displacements && 0 < props.displacements.length) {
            displacements = [];
            for (const displacement of props.displacements)
                displacements.push(new AuxDisplacementChannel(displacement));
        }
        if (undefined !== props.normals && 0 < props.normals.length) {
            normals = [];
            for (const normal of props.normals)
                normals.push(new AuxChannel(normal));
        }
        if (undefined !== props.params && 0 < props.params.length) {
            params = [];
            for (const param of props.params)
                params.push(new AuxParamChannel(param));
        }
        return undefined !== displacements || undefined !== normals || undefined !== params ? new AuxChannelTable(props, displacements, normals, params) : undefined;
    }
}
exports.AuxChannelTable = AuxChannelTable;


/***/ }),

/***/ "./lib/render/primitives/ColorMap.js":
/*!*******************************************!*\
  !*** ./lib/render/primitives/ColorMap.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/** @internal */
class ColorMap extends bentleyjs_core_1.IndexMap {
    constructor() {
        super(bentleyjs_core_1.compareNumbers, 0xffff);
        this._hasTransparency = false;
    }
    hasColor(color) { return -1 !== this.indexOf(color); }
    insert(color) {
        // The table should never contain a mix of opaque and translucent colors.
        if (this.isEmpty)
            this._hasTransparency = ColorMap.isTranslucent(color);
        else
            bentleyjs_core_1.assert(ColorMap.isTranslucent(color) === this.hasTransparency);
        return super.insert(color);
    }
    get hasTransparency() { return this._hasTransparency; }
    get isUniform() { return 1 === this.length; }
    toColorIndex(index, indices) {
        index.reset();
        if (0 === this.length) {
            bentleyjs_core_1.assert(false, "empty color map");
            return;
        }
        else if (1 === this.length) {
            index.initUniform(this._array[0].value);
        }
        else {
            const colors = new Uint32Array(this.length);
            for (const entry of this._array)
                colors[entry.index] = entry.value;
            index.initNonUniform(colors, indices, this.hasTransparency);
        }
    }
    static isTranslucent(color) {
        this._scratchColorDef.tbgr = color;
        return 255 !== this._scratchColorDef.getAlpha();
    }
}
ColorMap._scratchColorDef = new imodeljs_common_1.ColorDef();
exports.ColorMap = ColorMap;


/***/ }),

/***/ "./lib/render/primitives/DisplayParams.js":
/*!************************************************!*\
  !*** ./lib/render/primitives/DisplayParams.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
function compareMaterials(lhs, rhs) {
    return bentleyjs_core_1.comparePossiblyUndefined((lhMat, rhMat) => lhMat === rhMat ? 0 : bentleyjs_core_1.compareStringsOrUndefined(lhMat.key, rhMat.key), lhs, rhs);
}
function compareTextureMappings(lhs, rhs) {
    return bentleyjs_core_1.comparePossiblyUndefined((lhTex, rhTex) => lhTex === rhTex ? 0 : bentleyjs_core_1.compareStringsOrUndefined(lhTex.texture.key, rhTex.texture.key), lhs, rhs);
}
/** This class is used to determine if things can be batched together for display.
 * @internal
 */
class DisplayParams {
    constructor(type, lineColor, fillColor, width = 0, linePixels = imodeljs_common_1.LinePixels.Solid, fillFlags = imodeljs_common_1.FillFlags.None, material, gradient, ignoreLighting = false, textureMapping) {
        this.type = DisplayParams.Type.Mesh;
        this.type = type;
        this.material = material;
        this.gradient = gradient;
        this.lineColor = DisplayParams.adjustTransparencyInPlace(lineColor);
        this.fillColor = DisplayParams.adjustTransparencyInPlace(fillColor);
        this.width = width;
        this.linePixels = linePixels;
        this.fillFlags = fillFlags;
        this.ignoreLighting = ignoreLighting;
        this._textureMapping = textureMapping;
        bentleyjs_core_1.assert(undefined === material || undefined === textureMapping);
    }
    /** Creates a DisplayParams object for a particular type (mesh, linear, text) based on the specified GraphicParams. */
    static createForType(type, gf, resolveGradient) {
        const lineColor = DisplayParams.adjustTransparencyInPlace(gf.lineColor.clone());
        switch (type) {
            case DisplayParams.Type.Mesh: {
                let gradientMapping;
                if (undefined !== gf.gradient && undefined !== resolveGradient) {
                    const gradientTexture = resolveGradient(gf.gradient);
                    if (undefined !== gradientTexture)
                        gradientMapping = new imodeljs_common_1.TextureMapping(gradientTexture, new imodeljs_common_1.TextureMapping.Params());
                }
                return new DisplayParams(type, lineColor, DisplayParams.adjustTransparencyInPlace(gf.fillColor.clone()), gf.rasterWidth, gf.linePixels, gf.fillFlags, gf.material, gf.gradient, false, gradientMapping);
            }
            case DisplayParams.Type.Linear:
                return new DisplayParams(type, lineColor, lineColor, gf.rasterWidth, gf.linePixels);
            default: // DisplayParams.Type.Text
                return new DisplayParams(type, lineColor, lineColor, 0, imodeljs_common_1.LinePixels.Solid, imodeljs_common_1.FillFlags.Always, undefined, undefined, true);
        }
    }
    /** Creates a DisplayParams object that describes mesh geometry based on the specified GraphicParams. */
    static createForMesh(gf, resolveGradient) {
        return DisplayParams.createForType(DisplayParams.Type.Mesh, gf, resolveGradient);
    }
    /** Creates a DisplayParams object that describes linear geometry based on the specified GraphicParams. */
    static createForLinear(gf) {
        return DisplayParams.createForType(DisplayParams.Type.Linear, gf);
    }
    /** Creates a DisplayParams object that describes text geometry based on the specified GraphicParams. */
    static createForText(gf) {
        return DisplayParams.createForType(DisplayParams.Type.Text, gf);
    }
    get regionEdgeType() {
        if (this.hasBlankingFill)
            return DisplayParams.RegionEdgeType.None;
        if (this.gradient !== undefined && undefined !== this.gradient.flags) {
            // Even if the gradient is not outlined, produce an outline to be displayed as the region's edges when fill ViewFlag is off.
            const gradFlags = this.gradient.flags;
            if (0 !== (gradFlags & imodeljs_common_1.Gradient.Flags.Outline) || imodeljs_common_1.FillFlags.None === (this.fillFlags & imodeljs_common_1.FillFlags.Always))
                return DisplayParams.RegionEdgeType.Outline;
            return DisplayParams.RegionEdgeType.None;
        }
        return (!this.fillColor.equals(this.lineColor)) ? DisplayParams.RegionEdgeType.Outline : DisplayParams.RegionEdgeType.Default;
    }
    get wantRegionOutline() {
        return DisplayParams.RegionEdgeType.Outline === this.regionEdgeType;
    }
    get hasBlankingFill() { return imodeljs_common_1.FillFlags.Blanking === (this.fillFlags & imodeljs_common_1.FillFlags.Blanking); }
    get hasFillTransparency() { return 255 !== this.fillColor.getAlpha(); }
    get hasLineTransparency() { return 255 !== this.lineColor.getAlpha(); }
    get textureMapping() { return undefined !== this.material ? this.material.textureMapping : this._textureMapping; }
    get isTextured() { return undefined !== this.textureMapping; }
    /** Determines if the properties of this DisplayParams object are equal to those of another DisplayParams object.  */
    equals(rhs, purpose = DisplayParams.ComparePurpose.Strict) {
        if (DisplayParams.ComparePurpose.Merge === purpose)
            return 0 === this.compareForMerge(rhs);
        else if (rhs === this)
            return true;
        if (this.type !== rhs.type)
            return false;
        if (this.ignoreLighting !== rhs.ignoreLighting)
            return false;
        if (this.width !== rhs.width)
            return false;
        if (this.linePixels !== rhs.linePixels)
            return false;
        if (this.fillFlags !== rhs.fillFlags)
            return false;
        if (this.wantRegionOutline !== rhs.wantRegionOutline)
            return false;
        if (this.material !== rhs.material)
            return false;
        if (this.textureMapping !== rhs.textureMapping)
            return false;
        if (!this.fillColor.equals(rhs.fillColor))
            return false;
        if (!this.lineColor.equals(rhs.lineColor))
            return false;
        return true;
    }
    compareForMerge(rhs) {
        if (rhs === this)
            return 0;
        let diff = bentleyjs_core_1.compareNumbers(this.type, rhs.type);
        if (0 === diff) {
            diff = bentleyjs_core_1.compareBooleans(this.ignoreLighting, rhs.ignoreLighting);
            if (0 === diff) {
                diff = bentleyjs_core_1.compareNumbers(this.width, rhs.width);
                if (0 === diff) {
                    diff = bentleyjs_core_1.compareNumbers(this.linePixels, rhs.linePixels);
                    if (0 === diff) {
                        diff = bentleyjs_core_1.compareNumbers(this.fillFlags, rhs.fillFlags);
                        if (0 === diff) {
                            diff = bentleyjs_core_1.compareBooleans(this.wantRegionOutline, rhs.wantRegionOutline);
                            if (0 === diff) {
                                diff = bentleyjs_core_1.compareBooleans(this.hasFillTransparency, rhs.hasFillTransparency);
                                if (0 === diff) {
                                    diff = bentleyjs_core_1.compareBooleans(this.hasLineTransparency, rhs.hasLineTransparency);
                                    if (0 === diff) {
                                        diff = compareMaterials(this.material, rhs.material);
                                        if (0 === diff && undefined === this.material && this.isTextured) {
                                            diff = compareTextureMappings(this.textureMapping, rhs.textureMapping);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
        return diff;
    }
    /**
     * Given a ColorDef object, check its transparency and if it falls below the minimum, mark the color as fully opaque.
     * @return The original reference to the color provided, which has possibly been modified.
     */
    static adjustTransparencyInPlace(color) {
        if (color.colors.t < DisplayParams.minTransparency)
            color.setTransparency(0);
        return color;
    }
}
DisplayParams.minTransparency = 15; // Threshold below which we consider a color fully opaque
exports.DisplayParams = DisplayParams;
/** @internal */
(function (DisplayParams) {
    let Type;
    (function (Type) {
        Type[Type["Mesh"] = 0] = "Mesh";
        Type[Type["Linear"] = 1] = "Linear";
        Type[Type["Text"] = 2] = "Text";
    })(Type = DisplayParams.Type || (DisplayParams.Type = {}));
    let RegionEdgeType;
    (function (RegionEdgeType) {
        RegionEdgeType[RegionEdgeType["None"] = 0] = "None";
        RegionEdgeType[RegionEdgeType["Default"] = 1] = "Default";
        RegionEdgeType[RegionEdgeType["Outline"] = 2] = "Outline";
    })(RegionEdgeType = DisplayParams.RegionEdgeType || (DisplayParams.RegionEdgeType = {}));
    let ComparePurpose;
    (function (ComparePurpose) {
        ComparePurpose[ComparePurpose["Merge"] = 0] = "Merge";
        ComparePurpose[ComparePurpose["Strict"] = 1] = "Strict";
    })(ComparePurpose = DisplayParams.ComparePurpose || (DisplayParams.ComparePurpose = {}));
})(DisplayParams = exports.DisplayParams || (exports.DisplayParams = {}));


/***/ }),

/***/ "./lib/render/primitives/PointCloudPrimitive.js":
/*!******************************************************!*\
  !*** ./lib/render/primitives/PointCloudPrimitive.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/** @internal */
class PointCloudArgs {
    constructor(points, pointParams, colors, features) {
        this.features = new imodeljs_common_1.FeatureIndex();
        this.points = points;
        this.colors = colors;
        this.pointParams = pointParams;
        features.toFeatureIndex(this.features);
    }
}
exports.PointCloudArgs = PointCloudArgs;


/***/ }),

/***/ "./lib/render/primitives/Polyface.js":
/*!*******************************************!*\
  !*** ./lib/render/primitives/Polyface.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
/** @internal */
class PolyfacePrimitive {
    get indexedPolyface() { return this._polyface; }
    static create(params, pf, displayEdges = true, isPlanar = false) {
        return new PolyfacePrimitive(params, pf, displayEdges, isPlanar);
    }
    constructor(params, pf, displayEdges, isPlanar) {
        this.displayParams = params;
        this._polyface = pf;
        this.displayEdges = displayEdges;
        this.isPlanar = isPlanar;
    }
    clone() { return new PolyfacePrimitive(this.displayParams, this._polyface.clone(), this.displayEdges, this.isPlanar); }
    transform(trans) { return this._polyface.tryTransformInPlace(trans); }
}
exports.PolyfacePrimitive = PolyfacePrimitive;
/** @internal */
class PolyfacePrimitiveList extends Array {
    constructor(...args) { super(...args); }
}
exports.PolyfacePrimitiveList = PolyfacePrimitiveList;


/***/ }),

/***/ "./lib/render/primitives/Primitives.js":
/*!*********************************************!*\
  !*** ./lib/render/primitives/Primitives.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
var ToleranceRatio;
(function (ToleranceRatio) {
    ToleranceRatio.vertex = 0.1;
    ToleranceRatio.facetArea = 0.1;
})(ToleranceRatio = exports.ToleranceRatio || (exports.ToleranceRatio = {}));
/** @internal */
class GeometryOptions {
    constructor(normals = 1 /* Always */, surfaces = 0 /* No */, preserveOrder = 0 /* No */, edges = 1 /* Yes */) {
        this.normals = normals;
        this.surfaces = surfaces;
        this.preserveOrder = preserveOrder;
        this.edges = edges;
    }
    get wantSurfacesOnly() { return this.surfaces === 1 /* Yes */; }
    get wantPreserveOrder() { return this.preserveOrder === 1 /* Yes */; }
    get wantEdges() { return this.edges === 1 /* Yes */; }
    static createForGraphicBuilder(params, normals = 1 /* Always */, surfaces = 0 /* No */) {
        return new GeometryOptions(normals, surfaces, (params.isOverlay || params.isViewBackground) ? 1 /* Yes */ : 0 /* No */, params.isSceneGraphic ? 1 /* Yes */ : 0 /* No */);
    }
}
exports.GeometryOptions = GeometryOptions;
/** @internal */
class Triangle {
    constructor(singleSided = true) {
        this.indices = new Uint32Array(3);
        this.visible = [true, true, true];
        this.singleSided = singleSided;
    }
    setIndices(a, b, c) {
        this.indices[0] = a;
        this.indices[1] = b;
        this.indices[2] = c;
    }
    setEdgeVisibility(a, b, c) {
        this.visible[0] = a;
        this.visible[1] = b;
        this.visible[2] = c;
    }
    isEdgeVisible(index) {
        bentleyjs_core_1.assert(index < 3 && index >= 0);
        return this.visible[index];
    }
    get isDegenerate() { return this.indices[0] === this.indices[1] || this.indices[0] === this.indices[2] || this.indices[1] === this.indices[2]; }
}
exports.Triangle = Triangle;
/** @internal */
class TriangleList {
    constructor() {
        this._flags = [];
        this.indices = [];
    }
    get length() { return this._flags.length; }
    get isEmpty() { return 0 === this.length; }
    addTriangle(triangle) {
        let flags = triangle.singleSided ? 1 : 0;
        for (let i = 0; i < 3; i++) {
            if (triangle.isEdgeVisible(i))
                flags |= (0x0002 << i);
            this.indices.push(triangle.indices[i]);
        }
        this._flags.push(flags);
    }
    getTriangle(index, out) {
        const triangle = undefined !== out ? out : new Triangle();
        if (index > this.length) {
            bentleyjs_core_1.assert(false);
            return new Triangle();
        }
        const flags = this._flags[index];
        triangle.singleSided = 0 !== (flags & 0x0001);
        const baseIndex = index * 3;
        for (let i = 0; i < 3; i++) {
            triangle.indices[i] = this.indices[baseIndex + i];
            triangle.visible[i] = 0 !== (flags & 0x0002 << i);
        }
        return triangle;
    }
}
exports.TriangleList = TriangleList;
/** @internal */
class TriangleKey {
    constructor(triangle) {
        this._sortedIndices = new Uint32Array(3);
        const index = triangle.indices;
        const sorted = this._sortedIndices;
        if (index[0] < index[1]) {
            if (index[0] < index[2]) {
                sorted[0] = index[0];
                if (index[1] < index[2]) {
                    sorted[1] = index[1];
                    sorted[2] = index[2];
                }
                else {
                    sorted[1] = index[2];
                    sorted[2] = index[1];
                }
            }
            else {
                sorted[0] = index[2];
                sorted[1] = index[0];
                sorted[2] = index[1];
            }
        }
        else {
            if (index[1] < index[2]) {
                sorted[0] = index[1];
                if (index[0] < index[2]) {
                    sorted[1] = index[0];
                    sorted[2] = index[2];
                }
                else {
                    sorted[1] = index[2];
                    sorted[2] = index[0];
                }
            }
            else {
                sorted[0] = index[2];
                sorted[1] = index[1];
                sorted[2] = index[0];
            }
        }
        bentleyjs_core_1.assert(sorted[0] < sorted[1]);
        bentleyjs_core_1.assert(sorted[1] < sorted[2]);
    }
    compare(rhs) {
        let diff = 0;
        for (let i = 0; i < 3; i++) {
            diff = this._sortedIndices[i] - rhs._sortedIndices[i];
            if (0 !== diff)
                break;
        }
        return diff;
    }
}
exports.TriangleKey = TriangleKey;
/** @internal */
class TriangleSet extends bentleyjs_core_1.SortedArray {
    constructor() {
        super((lhs, rhs) => lhs.compare(rhs));
    }
    insertKey(triangle, onInsert) {
        return this.insert(new TriangleKey(triangle), onInsert);
    }
}
exports.TriangleSet = TriangleSet;


/***/ }),

/***/ "./lib/render/primitives/Strokes.js":
/*!******************************************!*\
  !*** ./lib/render/primitives/Strokes.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
/** @internal */
class StrokesPrimitivePointList {
    constructor(points = []) { this.points = [...points]; }
}
exports.StrokesPrimitivePointList = StrokesPrimitivePointList;
/** @internal */
class StrokesPrimitivePointLists extends Array {
    constructor(...args) { super(...args); }
}
exports.StrokesPrimitivePointLists = StrokesPrimitivePointLists;
/** @internal */
class StrokesPrimitive {
    static create(params, isDisjoint, isPlanar) {
        return new StrokesPrimitive(params, isDisjoint, isPlanar);
    }
    constructor(params, isDisjoint, isPlanar) {
        this.displayParams = params;
        this.strokes = new StrokesPrimitivePointLists();
        this.isDisjoint = isDisjoint;
        this.isPlanar = isPlanar;
    }
    transform(trans) {
        for (const strk of this.strokes) {
            trans.multiplyPoint3dArrayInPlace(strk.points);
        }
    }
}
exports.StrokesPrimitive = StrokesPrimitive;
/** @internal */
class StrokesPrimitiveList extends Array {
    constructor(...args) { super(...args); }
}
exports.StrokesPrimitiveList = StrokesPrimitiveList;


/***/ }),

/***/ "./lib/render/primitives/VertexKey.js":
/*!********************************************!*\
  !*** ./lib/render/primitives/VertexKey.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
class VertexKey {
    constructor(position, fillColor, normal, uvParam) {
        this.octEncodedNormal = 0;
        this.normalValid = false;
        this.position = position.clone();
        this.fillColor = fillColor;
        if (undefined !== normal) {
            this.normalValid = true;
            this.octEncodedNormal = normal.value;
        }
        if (undefined !== uvParam)
            this.uvParam = uvParam.clone();
    }
    static create(props) { return new VertexKey(props.position, props.fillColor, props.normal, props.uvParam); }
    equals(rhs) {
        bentleyjs_core_1.assert(this.normalValid === rhs.normalValid);
        if (!this.position.equals(rhs.position) || this.octEncodedNormal !== rhs.octEncodedNormal || this.fillColor !== rhs.fillColor)
            return false;
        if (undefined === this.uvParam) {
            bentleyjs_core_1.assert(undefined === rhs.uvParam);
            return true;
        }
        else {
            bentleyjs_core_1.assert(undefined !== rhs.uvParam);
            return this.uvParam.isAlmostEqual(rhs.uvParam, 0.1);
        }
    }
    compare(rhs) {
        if (this === rhs)
            return 0;
        let diff = this.position.compare(rhs.position);
        if (0 === diff) {
            diff = this.octEncodedNormal - rhs.octEncodedNormal;
            if (0 === diff) {
                diff = this.fillColor - rhs.fillColor;
                if (0 === diff && undefined !== this.uvParam) {
                    bentleyjs_core_1.assert(undefined !== rhs.uvParam);
                    diff = bentleyjs_core_1.compareWithTolerance(this.uvParam.x, rhs.uvParam.x);
                    if (0 === diff) {
                        diff = bentleyjs_core_1.compareWithTolerance(this.uvParam.x, rhs.uvParam.y);
                    }
                }
            }
        }
        return diff;
    }
}
exports.VertexKey = VertexKey;
/** @internal */
class VertexMap extends bentleyjs_core_1.IndexMap {
    constructor() { super((lhs, rhs) => lhs.compare(rhs)); }
    insertKey(props, onInsert) {
        return this.insert(VertexKey.create(props), onInsert);
    }
}
exports.VertexMap = VertexMap;


/***/ }),

/***/ "./lib/render/primitives/VertexTable.js":
/*!**********************************************!*\
  !*** ./lib/render/primitives/VertexTable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const IModelApp_1 = __webpack_require__(/*! ../../IModelApp */ "./lib/IModelApp.js");
// tslint:disable:no-const-enum
/**
 * Holds an array of indices into a VertexTable. Each index is a 24-bit unsigned integer.
 * The order of the indices specifies the order in which vertices are drawn.
 * @internal
 */
class VertexIndices {
    /**
     * Directly construct from an array of bytes in which each index occupies 3 contiguous bytes.
     * The length of the array must be a multiple of 3. This object takes ownership of the array.
     */
    constructor(data) {
        this.data = data;
        bentleyjs_core_1.assert(0 === this.data.length % 3);
    }
    /** Get the number of 24-bit indices. */
    get length() { return this.data.length / 3; }
    /** Convert an array of 24-bit unsigned integer values into a VertexIndices object. */
    static fromArray(indices) {
        const bytes = new Uint8Array(indices.length * 3);
        for (let i = 0; i < indices.length; i++)
            this.encodeIndex(indices[i], bytes, i * 3);
        return new VertexIndices(bytes);
    }
    static encodeIndex(index, bytes, byteIndex) {
        bentleyjs_core_1.assert(byteIndex + 2 < bytes.length);
        bytes[byteIndex + 0] = index & 0x000000ff;
        bytes[byteIndex + 1] = (index & 0x0000ff00) >> 8;
        bytes[byteIndex + 2] = (index & 0x00ff0000) >> 16;
    }
}
exports.VertexIndices = VertexIndices;
function computeDimensions(nEntries, nRgbaPerEntry, nExtraRgba) {
    const maxSize = IModelApp_1.IModelApp.renderSystem.maxTextureSize;
    const nRgba = nEntries * nRgbaPerEntry + nExtraRgba;
    if (nRgba < maxSize)
        return { width: nRgba, height: 1 };
    // Make roughly square to reduce unused space in last row
    let width = Math.ceil(Math.sqrt(nRgba));
    // Ensure a given entry's RGBA values all fit on the same row.
    const remainder = width % nRgbaPerEntry;
    if (0 !== remainder) {
        width += nRgbaPerEntry - remainder;
    }
    // Compute height
    const height = Math.ceil(nRgba / width);
    bentleyjs_core_1.assert(height <= maxSize);
    bentleyjs_core_1.assert(width <= maxSize);
    bentleyjs_core_1.assert(width * height >= nRgba);
    bentleyjs_core_1.assert(Math.floor(height) === height);
    bentleyjs_core_1.assert(Math.floor(width) === width);
    // Row padding should never be necessary...
    bentleyjs_core_1.assert(0 === width % nRgbaPerEntry);
    return { width, height };
}
const scratchColorDef = new imodeljs_common_1.ColorDef();
/**
 * Represents vertex data (position, color, normal, UV params, etc) in a rectangular array.
 * Each vertex is described by one or more contiguous 4-byte ('RGBA') values.
 * This allows vertex data to be uploaded to the GPU as a texture and vertex data to be sampled
 * from that texture using a single vertex ID representing an index into the array.
 * Vertex color is identified by a 16-bit index into a color table appended to the vertex data.
 * @internal
 */
class VertexTable {
    /** Construct a VertexTable. The VertexTable takes ownership of all input data - it must not be later modified by the caller. */
    constructor(props) {
        this.data = props.data;
        this.qparams = props.qparams;
        this.width = props.width;
        this.height = props.height;
        this.hasTranslucency = true === props.hasTranslucency;
        this.uniformColor = props.uniformColor;
        this.featureIndexType = props.featureIndexType;
        this.uniformFeatureID = props.uniformFeatureID;
        this.numVertices = props.numVertices;
        this.numRgbaPerVertex = props.numRgbaPerVertex;
        this.uvParams = props.uvParams;
    }
    static buildFrom(builder, colorIndex, featureIndex) {
        const { numVertices, numRgbaPerVertex } = builder;
        const numColors = colorIndex.isUniform ? 0 : colorIndex.numColors;
        const dimensions = computeDimensions(numVertices, numRgbaPerVertex, numColors);
        bentleyjs_core_1.assert(0 === dimensions.width % numRgbaPerVertex || (0 < numColors && 1 === dimensions.height));
        const data = new Uint8Array(dimensions.width * dimensions.height * 4);
        builder.data = data;
        for (let i = 0; i < numVertices; i++)
            builder.appendVertex(i);
        builder.appendColorTable(colorIndex);
        builder.data = undefined;
        return new VertexTable({
            data,
            qparams: builder.qparams,
            width: dimensions.width,
            height: dimensions.height,
            hasTranslucency: colorIndex.hasAlpha,
            uniformColor: colorIndex.uniform,
            numVertices,
            numRgbaPerVertex,
            uvParams: builder.uvParams,
            featureIndexType: featureIndex.type,
            uniformFeatureID: featureIndex.type === imodeljs_common_1.FeatureIndexType.Uniform ? featureIndex.featureID : undefined,
        });
    }
    static createForPolylines(args) {
        const polylines = args.polylines;
        if (0 < polylines.length)
            return this.buildFrom(new SimpleBuilder(args), args.colors, args.features);
        else
            return undefined;
    }
}
exports.VertexTable = VertexTable;
/** Describes point string geometry to be submitted to the rendering system.
 * @internal
 */
class PointStringParams {
    constructor(vertices, indices, weight) {
        this.vertices = vertices;
        this.indices = indices;
        this.weight = weight;
    }
    static create(args) {
        if (!args.flags.isDisjoint)
            return undefined;
        const vertices = VertexTable.createForPolylines(args);
        if (undefined === vertices)
            return undefined;
        const polylines = args.polylines;
        let vertIndices = polylines[0].vertIndices;
        if (1 < polylines.length) {
            // We used to assert this wouldn't happen - apparently it does...
            vertIndices = [];
            for (const polyline of polylines)
                for (const vertIndex of polyline.vertIndices)
                    vertIndices.push(vertIndex);
        }
        const vertexIndices = VertexIndices.fromArray(vertIndices);
        bentleyjs_core_1.assert(vertexIndices.length === vertIndices.length);
        return new PointStringParams(vertices, vertexIndices, args.width);
    }
}
exports.PointStringParams = PointStringParams;
class PolylineVertex {
    constructor() {
        this.isSegmentStart = false;
        this.isPolylineStartOrEnd = false;
        this.vertexIndex = 0;
        this.prevIndex = 0;
        this.nextIndex = 0;
    }
    init(isSegmentStart, isPolylineStartOrEnd, vertexIndex, prevIndex, nextIndex) {
        this.isSegmentStart = isSegmentStart;
        this.isPolylineStartOrEnd = isPolylineStartOrEnd;
        this.vertexIndex = vertexIndex;
        this.prevIndex = prevIndex;
        this.nextIndex = nextIndex;
    }
    computeParam(negatePerp, adjacentToJoint = false, joint = false, noDisplacement = false) {
        if (joint)
            return 12 /* kJointBase */;
        let param = 0 /* kNone */;
        if (noDisplacement)
            param = 96 /* kNoneAdjustWeight */; // prevent getting tossed before width adjustment
        else if (adjacentToJoint)
            param = 9 /* kMiterInsideOnly */;
        else
            param = this.isPolylineStartOrEnd ? 3 /* kSquare */ : 6 /* kMiter */;
        let adjust = 0;
        if (negatePerp)
            adjust = 24 /* kNegatePerp */;
        if (!this.isSegmentStart)
            adjust += 48 /* kNegateAlong */;
        return param + adjust;
    }
}
class PolylineTesselator {
    constructor(polylines, points, doJointTriangles) {
        this._numIndices = 0;
        this._vertIndex = [];
        this._prevIndex = [];
        this._nextIndex = [];
        this._nextParam = [];
        this._position = [];
        this._polylines = polylines;
        this._points = points;
        this._doJoints = doJointTriangles;
    }
    static fromPolyline(args) {
        return new PolylineTesselator(args.polylines, args.points, wantJointTriangles(args.width, args.flags.is2d));
    }
    static fromMesh(args) {
        if (undefined !== args.edges.polylines.lines && undefined !== args.points)
            return new PolylineTesselator(args.edges.polylines.lines, args.points, wantJointTriangles(args.edges.width, args.is2d));
        return undefined;
    }
    tesselate() {
        for (const p of this._points.list)
            this._position.push(p.unquantize(this._points.params));
        this._tesselate();
        const vertIndex = VertexIndices.fromArray(this._vertIndex);
        const prevIndex = VertexIndices.fromArray(this._prevIndex);
        const nextIndexAndParam = new Uint8Array(this._numIndices * 4);
        for (let i = 0; i < this._numIndices; i++) {
            const index = this._nextIndex[i];
            const j = i * 4;
            VertexIndices.encodeIndex(index, nextIndexAndParam, j);
            nextIndexAndParam[j + 3] = this._nextParam[i] & 0x000000ff;
        }
        return {
            indices: vertIndex,
            prevIndices: prevIndex,
            nextIndicesAndParams: nextIndexAndParam,
        };
    }
    _tesselate() {
        const v0 = new PolylineVertex(), v1 = new PolylineVertex();
        const maxJointDot = -0.7;
        for (const line of this._polylines) {
            if (line.numIndices < 2)
                continue;
            const last = line.numIndices - 1;
            const isClosed = line.vertIndices[0] === line.vertIndices[last];
            for (let i = 0; i < last; ++i) {
                const idx0 = line.vertIndices[i];
                const idx1 = line.vertIndices[i + 1];
                const isStart = (0 === i);
                const isEnd = (last - 1 === i);
                const prevIdx0 = isStart ? (isClosed ? line.vertIndices[last - 1] : idx0) : line.vertIndices[i - 1];
                const nextIdx1 = isEnd ? (isClosed ? line.vertIndices[1] : idx1) : line.vertIndices[i + 2];
                v0.init(true, isStart && !isClosed, idx0, prevIdx0, idx1);
                v1.init(false, isEnd && !isClosed, idx1, nextIdx1, idx0);
                const jointAt0 = this._doJoints && (isClosed || !isStart) && this._dotProduct(v0) > maxJointDot;
                const jointAt1 = this._doJoints && (isClosed || !isEnd) && this._dotProduct(v1) > maxJointDot;
                if (jointAt0 || jointAt1) {
                    this._addVertex(v0, v0.computeParam(true, jointAt0, false, false));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, false));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, false));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, false));
                    this._addVertex(v0, v0.computeParam(false, jointAt0, false, false));
                    this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));
                    this._addVertex(v1, v1.computeParam(true, jointAt1, false, false));
                }
                else {
                    this._addVertex(v0, v0.computeParam(true));
                    this._addVertex(v1, v1.computeParam(false));
                    this._addVertex(v0, v0.computeParam(false));
                    this._addVertex(v0, v0.computeParam(false));
                    this._addVertex(v1, v1.computeParam(false));
                    this._addVertex(v1, v1.computeParam(true));
                }
            }
        }
    }
    _dotProduct(v) {
        const pos = this._position[v.vertexIndex];
        const prevDir = geometry_core_1.Vector3d.createStartEnd(this._position[v.prevIndex], pos);
        const nextDir = geometry_core_1.Vector3d.createStartEnd(this._position[v.nextIndex], pos);
        return prevDir.dotProduct(nextDir);
    }
    _addVertex(vertex, param) {
        this._vertIndex[this._numIndices] = vertex.vertexIndex;
        this._prevIndex[this._numIndices] = vertex.prevIndex;
        this._nextIndex[this._numIndices] = vertex.nextIndex;
        this._nextParam[this._numIndices] = param;
        this._numIndices++;
    }
}
/** @internal */
function isValidSurfaceType(value) {
    switch (value) {
        case 0 /* Unlit */:
        case 1 /* Lit */:
        case 2 /* Textured */:
        case 3 /* TexturedLit */:
        case 4 /* VolumeClassifier */:
            return true;
        default:
            return false;
    }
}
exports.isValidSurfaceType = isValidSurfaceType;
function convertPolylinesAndEdges(polylines, edges) {
    let numIndices = undefined !== edges ? edges.length : 0;
    if (undefined !== polylines)
        for (const pd of polylines)
            numIndices += (pd.vertIndices.length - 1);
    if (0 === numIndices)
        return undefined;
    numIndices *= 6;
    const indexBytes = new Uint8Array(numIndices * 3);
    const endPointAndQuadIndexBytes = new Uint8Array(numIndices * 4);
    let ndx = 0;
    let ndx2 = 0;
    const addPoint = (p0, p1, quadIndex) => {
        VertexIndices.encodeIndex(p0, indexBytes, ndx);
        ndx += 3;
        VertexIndices.encodeIndex(p1, endPointAndQuadIndexBytes, ndx2);
        endPointAndQuadIndexBytes[ndx2 + 3] = quadIndex;
        ndx2 += 4;
    };
    if (undefined !== polylines) {
        for (const pd of polylines) {
            const num = pd.vertIndices.length - 1;
            for (let i = 0; i < num; ++i) {
                let p0 = pd.vertIndices[i];
                let p1 = pd.vertIndices[i + 1];
                if (p1 < p0) { // swap so that lower index is first.
                    p0 = p1;
                    p1 = pd.vertIndices[i];
                }
                addPoint(p0, p1, 0);
                addPoint(p1, p0, 2);
                addPoint(p0, p1, 1);
                addPoint(p0, p1, 1);
                addPoint(p1, p0, 2);
                addPoint(p1, p0, 3);
            }
        }
    }
    if (undefined !== edges) {
        for (const meshEdge of edges) {
            const p0 = meshEdge.indices[0];
            const p1 = meshEdge.indices[1];
            addPoint(p0, p1, 0);
            addPoint(p1, p0, 2);
            addPoint(p0, p1, 1);
            addPoint(p0, p1, 1);
            addPoint(p1, p0, 2);
            addPoint(p1, p0, 3);
        }
    }
    return {
        indices: new VertexIndices(indexBytes),
        endPointAndQuadIndices: endPointAndQuadIndexBytes,
    };
}
function convertSilhouettes(edges, normalPairs) {
    const base = convertPolylinesAndEdges(undefined, edges);
    if (undefined === base)
        return undefined;
    const normalPairBytes = new Uint8Array(normalPairs.length * 6 * 4);
    const normalPair16 = new Uint16Array(normalPairBytes.buffer);
    let ndx = 0;
    for (const pair of normalPairs) {
        for (let i = 0; i < 6; i++) {
            normalPair16[ndx++] = pair.first.value;
            normalPair16[ndx++] = pair.second.value;
        }
    }
    return {
        indices: base.indices,
        endPointAndQuadIndices: base.endPointAndQuadIndices,
        normalPairs: normalPairBytes,
    };
}
function wantJointTriangles(weight, is2d) {
    // Joints are incredibly expensive. In 3d, only generate them if the line is sufficiently wide for them to be noticeable.
    const jointWidthThreshold = 5;
    return is2d || weight > jointWidthThreshold;
}
function convertEdges(meshArgs) {
    const args = meshArgs.edges;
    if (undefined === args)
        return undefined;
    let polylines;
    let segments;
    if (wantJointTriangles(args.width, meshArgs.is2d)) {
        segments = convertPolylinesAndEdges(args.polylines.lines, args.edges.edges);
    }
    else {
        segments = convertPolylinesAndEdges(undefined, args.edges.edges);
        const tesselator = PolylineTesselator.fromMesh(meshArgs);
        if (undefined !== tesselator)
            polylines = tesselator.tesselate();
    }
    // ###TODO: why the heck are the edges and normals of SilhouetteEdgeArgs potentially undefined???
    const silhouettes = undefined !== args.silhouettes.edges && undefined !== args.silhouettes.normals ? convertSilhouettes(args.silhouettes.edges, args.silhouettes.normals) : undefined;
    if (undefined === segments && undefined === silhouettes && undefined === polylines)
        return undefined;
    return {
        weight: args.width,
        linePixels: args.linePixels,
        segments,
        silhouettes,
        polylines,
    };
}
/**
 * Describes mesh geometry to be submitted to the rendering system.
 * A mesh consists of a surface and its edges, which may include any combination of silhouettes, polylines, and single segments.
 * The surface and edges all refer to the same vertex table.
 */
class MeshParams {
    /** Directly construct a MeshParams. The MeshParams takes ownership of all input data. */
    constructor(vertices, surface, edges, isPlanar, auxChannels) {
        this.vertices = vertices;
        this.surface = surface;
        this.edges = edges;
        this.isPlanar = !!isPlanar;
        this.auxChannels = auxChannels;
    }
    /** Construct from a MeshArgs. */
    static create(args) {
        const builder = MeshBuilder.create(args);
        const vertices = VertexTable.buildFrom(builder, args.colors, args.features);
        const surfaceIndices = VertexIndices.fromArray(args.vertIndices);
        const surface = {
            type: builder.type,
            indices: surfaceIndices,
            fillFlags: args.fillFlags,
            hasBakedLighting: args.hasBakedLighting,
            texture: args.texture,
            material: args.material,
        };
        const edges = convertEdges(args);
        return new MeshParams(vertices, surface, edges, args.isPlanar);
    }
}
exports.MeshParams = MeshParams;
/**
 * Describes a set of tesselated polylines.
 * Each segment of each polyline is triangulated into a quad. Additional triangles may be inserted
 * between segments to enable rounded corners.
 */
class PolylineParams {
    /** Directly construct a PolylineParams. The PolylineParams takes ownership of all input data. */
    constructor(vertices, polyline, weight, linePixels, isPlanar, type = imodeljs_common_1.PolylineTypeFlags.Normal) {
        this.vertices = vertices;
        this.polyline = polyline;
        this.isPlanar = isPlanar;
        this.weight = weight;
        this.linePixels = linePixels;
        this.type = type;
    }
    /** Construct from an PolylineArgs. */
    static create(args) {
        bentleyjs_core_1.assert(!args.flags.isDisjoint);
        const vertices = VertexTable.createForPolylines(args);
        if (undefined === vertices)
            return undefined;
        const tesselator = PolylineTesselator.fromPolyline(args);
        if (undefined === tesselator)
            return undefined;
        return new PolylineParams(vertices, tesselator.tesselate(), args.width, args.linePixels, args.flags.isPlanar, args.flags.type);
    }
}
exports.PolylineParams = PolylineParams;
/** Builds a VertexTable from some data type supplying the vertex data. */
class VertexTableBuilder {
    constructor() {
        this._curIndex = 0;
    }
    get uvParams() { return undefined; }
    appendColorTable(colorIndex) {
        if (undefined !== colorIndex.nonUniform) {
            for (const color of colorIndex.nonUniform.colors) {
                this.appendColor(color);
            }
        }
    }
    advance(nBytes) {
        this._curIndex += nBytes;
        bentleyjs_core_1.assert(this._curIndex <= this.data.length);
    }
    append8(val) {
        bentleyjs_core_1.assert(0 <= val);
        bentleyjs_core_1.assert(val <= 0xff);
        bentleyjs_core_1.assert(val === Math.floor(val));
        this.data[this._curIndex] = val;
        this.advance(1);
    }
    append16(val) {
        this.append8(val & 0x00ff);
        this.append8(val >>> 8);
    }
    append32(val) {
        this.append16(val & 0x0000ffff);
        this.append16(val >>> 16);
    }
    appendColor(tbgr) {
        const colorDef = scratchColorDef;
        colorDef.tbgr = tbgr;
        const colors = colorDef.colors;
        // invert transparency => alpha
        colors.t = 255 - colors.t;
        // premultiply alpha...
        switch (colors.t) {
            case 0:
                colors.r = colors.g = colors.b = 0;
                break;
            case 255:
                break;
            default: {
                const f = colors.t / 255.0;
                colors.r = Math.floor(colors.r * f + 0.5);
                colors.g = Math.floor(colors.g * f + 0.5);
                colors.b = Math.floor(colors.b * f + 0.5);
                break;
            }
        }
        // Store 32-bit value in little-endian order (red first)
        this.append8(colors.r);
        this.append8(colors.g);
        this.append8(colors.b);
        this.append8(colors.t);
    }
}
exports.VertexTableBuilder = VertexTableBuilder;
/**
 * Supplies vertex data from a PolylineArgs or MeshArgs. Each vertex consists of 12 bytes:
 *  pos.x           00
 *  pos.y           02
 *  pos.z           04
 *  colorIndex      06
 *  featureIndex    08
 */
class SimpleBuilder extends VertexTableBuilder {
    constructor(args) {
        super();
        this.args = args;
        bentleyjs_core_1.assert(undefined !== this.args.points);
    }
    get numVertices() { return this.args.points.length; }
    get numRgbaPerVertex() { return 3; }
    get qparams() { return this.args.points.params; }
    appendVertex(vertIndex) {
        this.appendPosition(vertIndex);
        this.appendColorIndex(vertIndex);
        this.appendFeatureIndex(vertIndex);
    }
    appendPosition(vertIndex) {
        const points = this.args.points;
        this.append16(points.list[vertIndex].x);
        this.append16(points.list[vertIndex].y);
        this.append16(points.list[vertIndex].z);
    }
    appendColorIndex(vertIndex) {
        if (undefined !== this.args.colors.nonUniform) {
            this.append16(this.args.colors.nonUniform.indices[vertIndex]);
        }
        else {
            this.advance(2);
        }
    }
    appendFeatureIndex(vertIndex) {
        if (undefined !== this.args.features.featureIDs) {
            this.append32(this.args.features.featureIDs[vertIndex]);
        }
        else {
            this.advance(4);
        }
    }
}
/** Supplies vertex data from a MeshArgs. */
class MeshBuilder extends SimpleBuilder {
    constructor(args, type) {
        super(args);
        this.type = type;
    }
    static create(args) {
        if (args.isVolumeClassifier)
            return new MeshBuilder(args, 4 /* VolumeClassifier */);
        const isLit = undefined !== args.normals && 0 < args.normals.length;
        const isTextured = undefined !== args.texture;
        let uvParams;
        if (isTextured) {
            const uvRange = geometry_core_1.Range2d.createNull();
            const fpts = args.textureUv;
            const pt2d = new geometry_core_1.Point2d();
            if (undefined !== fpts && fpts.length > 0)
                for (let i = 0; i < args.points.length; i++)
                    uvRange.extendPoint(geometry_core_1.Point2d.create(fpts[i].x, fpts[i].y, pt2d));
            uvParams = imodeljs_common_1.QParams2d.fromRange(uvRange);
        }
        if (isLit)
            return isTextured ? new TexturedLitMeshBuilder(args, uvParams) : new LitMeshBuilder(args);
        else
            return isTextured ? new TexturedMeshBuilder(args, uvParams) : new MeshBuilder(args, 0 /* Unlit */);
    }
}
/** Supplies vertex data from a MeshArgs where each vertex consists of 16 bytes.
 * In addition to the SimpleBuilder data, the final 4 bytes hold the quantized UV params
 * The color index is left uninitialized as it is unused.
 */
class TexturedMeshBuilder extends MeshBuilder {
    constructor(args, qparams, type = 2 /* Textured */) {
        super(args, type);
        this._qpoint = new imodeljs_common_1.QPoint2d();
        this._qparams = qparams;
        bentleyjs_core_1.assert(undefined !== args.textureUv);
    }
    get numRgbaPerVertex() { return 4; }
    get uvParams() { return this._qparams; }
    appendVertex(vertIndex) {
        this.appendPosition(vertIndex);
        this.appendNormal(vertIndex);
        this.appendFeatureIndex(vertIndex);
        this.appendUVParams(vertIndex);
    }
    appendNormal(_vertIndex) { this.advance(2); } // no normal for unlit meshes
    appendUVParams(vertIndex) {
        this._qpoint.init(this.args.textureUv[vertIndex], this._qparams);
        this.append16(this._qpoint.x);
        this.append16(this._qpoint.y);
    }
}
/** As with TexturedMeshBuilder, but the color index is replaced with the oct-encoded normal value. */
class TexturedLitMeshBuilder extends TexturedMeshBuilder {
    constructor(args, qparams) {
        super(args, qparams, 3 /* TexturedLit */);
        bentleyjs_core_1.assert(undefined !== args.normals);
    }
    appendNormal(vertIndex) { this.append16(this.args.normals[vertIndex].value); }
}
/** 16 bytes. The last 2 bytes are unused; the 2 immediately preceding it hold the oct-encoded normal value. */
class LitMeshBuilder extends MeshBuilder {
    constructor(args) {
        super(args, 1 /* Lit */);
        bentleyjs_core_1.assert(undefined !== args.normals);
    }
    get numRgbaPerVertex() { return 4; }
    appendVertex(vertIndex) {
        super.appendVertex(vertIndex);
        this.append16(this.args.normals[vertIndex].value);
        this.advance(2); // 2 unused bytes
    }
}


/***/ }),

/***/ "./lib/render/primitives/geometry/GeometryAccumulator.js":
/*!***************************************************************!*\
  !*** ./lib/render/primitives/geometry/GeometryAccumulator.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const System_1 = __webpack_require__(/*! ../../System */ "./lib/render/System.js");
const MeshPrimitives_1 = __webpack_require__(/*! ../mesh/MeshPrimitives */ "./lib/render/primitives/mesh/MeshPrimitives.js");
const MeshBuilderMap_1 = __webpack_require__(/*! ../mesh/MeshBuilderMap */ "./lib/render/primitives/mesh/MeshBuilderMap.js");
const GeometryPrimitives_1 = __webpack_require__(/*! ./GeometryPrimitives */ "./lib/render/primitives/geometry/GeometryPrimitives.js");
const GeometryList_1 = __webpack_require__(/*! ./GeometryList */ "./lib/render/primitives/geometry/GeometryList.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
class GeometryAccumulator {
    constructor(iModel, system, surfacesOnly = false, transform = geometry_core_1.Transform.createIdentity(), tileRange = geometry_core_1.Range3d.createNull()) {
        this.geometries = new GeometryList_1.GeometryList();
        this.checkGlyphBoxes = false; // #TODO: obviously update when checkGlyphBoxes needs to be mutable
        this._surfacesOnly = surfacesOnly;
        this._transform = transform;
        this.iModel = iModel;
        this.system = system;
        this.tileRange = tileRange;
    }
    get surfacesOnly() { return this._surfacesOnly; }
    get transform() { return this._transform; }
    get isEmpty() { return this.geometries.isEmpty; }
    get haveTransform() { return !this._transform.isIdentity; }
    getPrimitiveRange(pGeom) {
        const pRange = new geometry_core_1.Range3d();
        pGeom.range(undefined, pRange);
        if (pRange.isNull)
            return undefined;
        return pRange;
    }
    calculateTransform(transform, range) {
        if (this.haveTransform)
            this._transform.multiplyTransformTransform(transform, transform);
        transform.multiplyRange(range, range);
    }
    addLoop(loop, displayParams, transform, disjoint) {
        const range = this.getPrimitiveRange(loop);
        if (!range)
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromLoop(loop, transform, range, displayParams, disjoint));
    }
    addLineString(pts, displayParams, transform) {
        // Do this.getPrimitiveRange() manually, so there is no need to create a PointString3d object just to find the range
        const range = geometry_core_1.Range3d.createNull();
        range.extendArray(pts, undefined);
        if (range.isNull)
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromLineString(pts, transform, range, displayParams));
    }
    addPointString(pts, displayParams, transform) {
        // Do this.getPrimitiveRange() manually, so there is no need to create a PointString3d object just to find the range
        const range = geometry_core_1.Range3d.createNull();
        range.extendArray(pts, undefined);
        if (range.isNull)
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromPointString(pts, transform, range, displayParams));
    }
    addPath(path, displayParams, transform, disjoint) {
        const range = this.getPrimitiveRange(path);
        if (!range)
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromPath(path, transform, range, displayParams, disjoint));
    }
    addPolyface(ipf, displayParams, transform) {
        const range = this.getPrimitiveRange(ipf);
        if (undefined === range)
            return false;
        this.calculateTransform(transform, range);
        return this.addGeometry(GeometryPrimitives_1.Geometry.createFromPolyface(ipf, transform, range, displayParams));
    }
    addGeometry(geom) { this.geometries.push(geom); return true; }
    clear() { this.geometries.clear(); }
    reset(transform = geometry_core_1.Transform.createIdentity(), surfacesOnly = false) {
        this.clear();
        this._transform = transform;
        this._surfacesOnly = surfacesOnly;
    }
    /**
     * Generates a MeshBuilderMap
     * native: GeometryAccumulator::ToMeshBuilderMap(GeometryOptionsCR options, double tolerance, FeatureTableP featureTable, ViewContextR context) const
     * note  : removed featureTable, ViewContext
     * @param tolerance should derive from Viewport.getPixelSizeAtPoint
     */
    toMeshBuilderMap(options, tolerance, pickableId) {
        const { geometries } = this; // declare internal dependencies
        const { wantSurfacesOnly, wantPreserveOrder } = options;
        const range = geometries.computeRange();
        const is2d = !range.isNull && range.isAlmostZeroZ;
        return MeshBuilderMap_1.MeshBuilderMap.createFromGeometries(geometries, tolerance, range, is2d, wantSurfacesOnly, wantPreserveOrder, pickableId);
    }
    toMeshes(options, tolerance, pickableId) {
        if (this.geometries.isEmpty)
            return new MeshPrimitives_1.MeshList();
        const builderMap = this.toMeshBuilderMap(options, tolerance, pickableId);
        return builderMap.toMeshes();
    }
    /**
     * Populate a list of Graphic objects from the accumulated Geometry objects.
     * removed ViewContext
     */
    saveToGraphicList(graphics, options, tolerance, pickableId) {
        const meshes = this.toMeshes(options, tolerance, pickableId);
        if (0 === meshes.length)
            return undefined;
        const args = new MeshPrimitives_1.MeshGraphicArgs();
        // All of the meshes are quantized to the same range.
        // If that range is small relative to the distance from the origin, quantization errors can produce display artifacts.
        // Remove the translation from the quantization parameters and apply it in the transform instead.
        const branch = new System_1.GraphicBranch(true);
        const qorigin = new geometry_core_1.Point3d();
        for (const mesh of meshes) {
            const verts = mesh.points;
            if (branch.isEmpty) {
                qorigin.setFrom(verts.params.origin);
            }
            else {
                bentleyjs_core_1.assert(verts.params.origin.isAlmostEqual(qorigin));
            }
            verts.params.origin.setZero();
            const graphic = mesh.getGraphics(args, this.system);
            if (undefined !== graphic)
                branch.add(graphic);
        }
        if (!branch.isEmpty) {
            const transform = geometry_core_1.Transform.createTranslationXYZ(qorigin.x, qorigin.y, qorigin.z);
            graphics.push(this.system.createBranch(branch, transform));
        }
        return meshes.features;
    }
}
exports.GeometryAccumulator = GeometryAccumulator;


/***/ }),

/***/ "./lib/render/primitives/geometry/GeometryList.js":
/*!********************************************************!*\
  !*** ./lib/render/primitives/geometry/GeometryList.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
/** @internal */
class GeometryList {
    constructor() {
        this._list = [];
    }
    get first() { return this._list[0]; }
    get isEmpty() { return this._list.length === 0; }
    get length() { return this._list.length; }
    push(geom) {
        return this._list.push(geom);
    }
    append(src) {
        this._list.push(...src._list);
        return this;
    }
    clear() { this._list.length = 0; }
    computeRange() {
        const range = geometry_core_1.Range3d.createNull();
        const extendRange = (geom) => range.extendRange(geom.tileRange);
        this._list.forEach(extendRange);
        return range;
    }
    computeQuantizationParams() { return imodeljs_common_1.QParams3d.fromRange(this.computeRange()); }
    [Symbol.iterator]() {
        let key = 0;
        return { next: () => { const result = key < this._list.length ? { value: this._list[key], done: false } : { value: this._list[key - 1], done: true }; key++; return result; } };
    }
}
exports.GeometryList = GeometryList;


/***/ }),

/***/ "./lib/render/primitives/geometry/GeometryListBuilder.js":
/*!***************************************************************!*\
  !*** ./lib/render/primitives/geometry/GeometryListBuilder.js ***!
  \***************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const GraphicBuilder_1 = __webpack_require__(/*! ../../GraphicBuilder */ "./lib/render/GraphicBuilder.js");
const Primitives_1 = __webpack_require__(/*! ../Primitives */ "./lib/render/primitives/Primitives.js");
const System_1 = __webpack_require__(/*! ../../System */ "./lib/render/System.js");
const DisplayParams_1 = __webpack_require__(/*! ../DisplayParams */ "./lib/render/primitives/DisplayParams.js");
const GeometryAccumulator_1 = __webpack_require__(/*! ./GeometryAccumulator */ "./lib/render/primitives/geometry/GeometryAccumulator.js");
function copy2dTo3d(pts2d, depth) {
    const pts3d = [];
    for (const point of pts2d)
        pts3d.push(geometry_core_1.Point3d.create(point.x, point.y, depth));
    return pts3d;
}
/** @internal */
class GeometryListBuilder extends GraphicBuilder_1.GraphicBuilder {
    constructor(system, type, viewport, placement = geometry_core_1.Transform.identity, pickableId, accumulatorTf = geometry_core_1.Transform.identity) {
        super(placement, type, viewport, pickableId);
        this.graphicParams = new imodeljs_common_1.GraphicParams();
        this.accum = new GeometryAccumulator_1.GeometryAccumulator(this.iModel, system, undefined, accumulatorTf);
    }
    finish() {
        const graphic = this.finishGraphic(this.accum);
        this.accum.clear();
        return graphic;
    }
    activateGraphicParams(graphicParams) {
        this.graphicParams = graphicParams;
    }
    addArc2d(ellipse, isEllipse, filled, zDepth) {
        if (0.0 === zDepth) {
            this.addArc(ellipse, isEllipse, filled);
        }
        else {
            const ell = ellipse;
            ell.center.z = zDepth;
            this.addArc(ell, isEllipse, filled);
        }
    }
    addArc(ellipse, isEllipse, filled) {
        let curve;
        let isLoop = false;
        if (isEllipse || filled) {
            curve = geometry_core_1.Loop.create(ellipse);
            isLoop = true;
        }
        else {
            curve = geometry_core_1.Path.create(ellipse);
        }
        if (filled && !isEllipse && !ellipse.sweep.isFullCircle) {
            const gapSegment = geometry_core_1.LineSegment3d.create(ellipse.startPoint(), ellipse.endPoint());
            gapSegment.markerBits = 0x00010000; // Set the CURVE_PRIMITIVE_BIT_GapCurve marker bit
            curve.children.push(gapSegment);
        }
        const displayParams = curve.isAnyRegionType ? this.getMeshDisplayParams() : this.getLinearDisplayParams();
        if (isLoop)
            this.accum.addLoop(curve, displayParams, this.placement, false);
        else
            this.accum.addPath(curve, displayParams, this.placement, false);
    }
    /** take ownership of input points and add as a line string to this builder */
    addLineString(points) {
        if (2 === points.length && points[0].isAlmostEqual(points[1]))
            this.accum.addPointString(points, this.getLinearDisplayParams(), this.placement);
        else
            this.accum.addLineString(points, this.getLinearDisplayParams(), this.placement);
    }
    addLineString2d(points, zDepth) {
        const pts3d = copy2dTo3d(points, zDepth);
        this.addLineString(pts3d);
    }
    /** take ownership of input points and add as a point string to this builder */
    addPointString(points) {
        this.accum.addPointString(points, this.getLinearDisplayParams(), this.placement);
    }
    addPointString2d(points, zDepth) {
        const pts3d = copy2dTo3d(points, zDepth);
        this.addPointString(pts3d);
    }
    addShape(points) {
        const loop = geometry_core_1.Loop.create(geometry_core_1.LineString3d.create(points));
        this.accum.addLoop(loop, this.getMeshDisplayParams(), this.placement, false);
    }
    addShape2d(points, zDepth) {
        const pts3d = copy2dTo3d(points, zDepth);
        this.addShape(pts3d);
    }
    addPath(path) {
        this.accum.addPath(path, this.getLinearDisplayParams(), this.placement, false);
    }
    addLoop(loop) {
        this.accum.addLoop(loop, this.getMeshDisplayParams(), this.placement, false);
    }
    addPolyface(meshData) {
        this.accum.addPolyface(meshData, this.getMeshDisplayParams(), this.placement);
    }
    getGraphicParams() { return this.graphicParams; }
    getDisplayParams(type) { return DisplayParams_1.DisplayParams.createForType(type, this.graphicParams); }
    getMeshDisplayParams() { return DisplayParams_1.DisplayParams.createForMesh(this.graphicParams, (grad) => this.resolveGradient(grad)); }
    getLinearDisplayParams() { return DisplayParams_1.DisplayParams.createForLinear(this.graphicParams); }
    get textDisplayParams() { return DisplayParams_1.DisplayParams.createForText(this.graphicParams); }
    get system() { return this.accum.system; }
    add(geom) { this.accum.addGeometry(geom); }
    reInitialize(localToWorld, accumTf = geometry_core_1.Transform.createIdentity()) {
        this.accum.reset(accumTf);
        this.activateGraphicParams(this.graphicParams);
        this.placement = localToWorld;
        this.reset();
    }
    resolveGradient(gradient) {
        return this.system.getGradientTexture(gradient, this.iModel);
    }
}
exports.GeometryListBuilder = GeometryListBuilder;
/** @internal */
class PrimitiveBuilder extends GeometryListBuilder {
    constructor() {
        super(...arguments);
        this.primitives = [];
    }
    finishGraphic(accum) {
        let featureTable;
        if (!accum.isEmpty) {
            // Overlay decorations don't test Z. Tools like to layer multiple primitives on top of one another; they rely on the primitives rendering
            // in that same order to produce correct results (e.g., a thin line rendered atop a thick line of another color).
            // No point generating edges for graphics that are always rendered in smooth shade mode.
            const options = Primitives_1.GeometryOptions.createForGraphicBuilder(this);
            const tolerance = this.computeTolerance(accum);
            featureTable = accum.saveToGraphicList(this.primitives, options, tolerance, this.pickId);
        }
        let graphic = (this.primitives.length !== 1) ? this.accum.system.createGraphicList(this.primitives) : this.primitives.pop();
        if (undefined !== featureTable) {
            const range = new geometry_core_1.Range3d(); // ###TODO compute range...
            graphic = this.accum.system.createBatch(graphic, System_1.PackedFeatureTable.pack(featureTable), range);
        }
        return graphic;
    }
    computeTolerance(accum) {
        const toleranceMult = 0.25;
        if (this.isViewCoordinates)
            return toleranceMult;
        if (!this.viewport)
            return 20;
        const range = accum.geometries.computeRange(); // NB: Already multiplied by transform...
        // NB: Geometry::CreateFacetOptions() will apply any scale factors from transform...no need to do it here.
        const pt = range.low.interpolate(0.5, range.high);
        return this.viewport.getPixelSizeAtPoint(pt) * toleranceMult;
    }
    reset() { this.primitives = []; }
}
exports.PrimitiveBuilder = PrimitiveBuilder;


/***/ }),

/***/ "./lib/render/primitives/geometry/GeometryPrimitives.js":
/*!**************************************************************!*\
  !*** ./lib/render/primitives/geometry/GeometryPrimitives.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const DisplayParams_1 = __webpack_require__(/*! ../DisplayParams */ "./lib/render/primitives/DisplayParams.js");
const Strokes_1 = __webpack_require__(/*! ../Strokes */ "./lib/render/primitives/Strokes.js");
const Polyface_1 = __webpack_require__(/*! ../Polyface */ "./lib/render/primitives/Polyface.js");
/** @internal */
class Geometry {
    constructor(transform, tileRange, displayParams) {
        this.transform = transform;
        this.tileRange = tileRange;
        this.displayParams = displayParams;
    }
    static createFromPointString(pts, tf, tileRange, params) {
        return new PrimitivePointStringGeometry(pts, tf, tileRange, params);
    }
    static createFromLineString(pts, tf, tileRange, params) {
        return new PrimitiveLineStringGeometry(pts, tf, tileRange, params);
    }
    static createFromLoop(loop, tf, tileRange, params, disjoint) {
        return new PrimitiveLoopGeometry(loop, tf, tileRange, params, disjoint);
    }
    static createFromPath(path, tf, tileRange, params, disjoint) {
        return new PrimitivePathGeometry(path, tf, tileRange, params, disjoint);
    }
    static createFromPolyface(ipf, tf, tileRange, params) {
        return new PrimitivePolyfaceGeometry(ipf, tf, tileRange, params);
    }
    getPolyfaces(tolerance) {
        const facetOptions = geometry_core_1.StrokeOptions.createForFacets();
        facetOptions.chordTol = tolerance;
        if (this.displayParams.isTextured)
            facetOptions.needParams = true;
        // if (!this.displayParams.ignoreLighting) // ###TODO And not 2D...
        //   facetOptions.needNormals = true;
        return this._getPolyfaces(facetOptions);
    }
    getStrokes(tolerance) {
        const strokeOptions = geometry_core_1.StrokeOptions.createForCurves();
        strokeOptions.chordTol = tolerance;
        return this._getStrokes(strokeOptions);
    }
    get hasTexture() { return this.displayParams.isTextured; }
    doDecimate() { return false; }
    doVertexCluster() { return true; }
    part() { return undefined; }
}
exports.Geometry = Geometry;
/** @internal */
class PrimitivePathGeometry extends Geometry {
    constructor(path, tf, range, params, isDisjoint) {
        super(tf, range, params);
        this.path = path;
        this.isDisjoint = isDisjoint;
    }
    _getPolyfaces(_facetOptions) { return undefined; }
    _getStrokes(facetOptions) {
        return PrimitivePathGeometry.getStrokesForLoopOrPath(this.path, facetOptions, this.displayParams, this.isDisjoint, this.transform);
    }
    static getStrokesForLoopOrPath(loopOrPath, facetOptions, params, isDisjoint, transform) {
        const strksList = new Strokes_1.StrokesPrimitiveList();
        if (!loopOrPath.isAnyRegionType || params.wantRegionOutline) {
            const strksPts = new Strokes_1.StrokesPrimitivePointLists();
            PrimitivePathGeometry.collectCurveStrokes(strksPts, loopOrPath, facetOptions, transform);
            if (strksPts.length > 0) {
                const isPlanar = loopOrPath.isAnyRegionType;
                bentleyjs_core_1.assert(isPlanar === params.wantRegionOutline);
                const strksPrim = Strokes_1.StrokesPrimitive.create(params, isDisjoint, isPlanar);
                strksPrim.strokes = strksPts;
                strksList.push(strksPrim);
            }
        }
        return strksList;
    }
    static collectCurveStrokes(strksPts, loopOrPath, facetOptions, trans) {
        const strokes = loopOrPath.getPackedStrokes(facetOptions);
        if (undefined !== strokes) {
            const pts = strokes.getPoint3dArray();
            trans.multiplyPoint3dArrayInPlace(pts);
            strksPts.push(new Strokes_1.StrokesPrimitivePointList(pts));
        }
    }
}
exports.PrimitivePathGeometry = PrimitivePathGeometry;
/** @internal */
class PrimitivePointStringGeometry extends Geometry {
    constructor(pts, tf, range, params) {
        super(tf, range, params);
        this.pts = pts;
    }
    _getPolyfaces(_facetOptions) {
        return undefined;
    }
    _getStrokes(_facetOptions) {
        const strksList = new Strokes_1.StrokesPrimitiveList();
        const strksPts = new Strokes_1.StrokesPrimitivePointLists(new Strokes_1.StrokesPrimitivePointList(this.pts));
        const strksPrim = Strokes_1.StrokesPrimitive.create(this.displayParams, true, false);
        strksPrim.strokes = strksPts;
        strksPrim.transform(this.transform);
        strksList.push(strksPrim);
        return strksList;
    }
}
exports.PrimitivePointStringGeometry = PrimitivePointStringGeometry;
/** @internal */
class PrimitiveLineStringGeometry extends Geometry {
    constructor(pts, tf, range, params) {
        super(tf, range, params);
        this.pts = pts;
    }
    _getPolyfaces(_facetOptions) {
        return undefined;
    }
    _getStrokes(_facetOptions) {
        const strksList = new Strokes_1.StrokesPrimitiveList();
        const strksPts = new Strokes_1.StrokesPrimitivePointLists(new Strokes_1.StrokesPrimitivePointList(this.pts));
        const strksPrim = Strokes_1.StrokesPrimitive.create(this.displayParams, false, false);
        strksPrim.strokes = strksPts;
        strksPrim.transform(this.transform);
        strksList.push(strksPrim);
        return strksList;
    }
}
exports.PrimitiveLineStringGeometry = PrimitiveLineStringGeometry;
/** @internal */
class PrimitiveLoopGeometry extends Geometry {
    constructor(loop, tf, range, params, isDisjoint) {
        super(tf, range, params);
        this.loop = loop;
        this.isDisjoint = isDisjoint;
    }
    _getPolyfaces(facetOptions) {
        if (!this.loop.isAnyRegionType) {
            return undefined;
        }
        // The following is good for single loop things according to Earlin.
        const contour = geometry_core_1.SweepContour.createForLinearSweep(this.loop);
        if (contour !== undefined) {
            const pfBuilder = geometry_core_1.PolyfaceBuilder.create(facetOptions);
            contour.emitFacets(pfBuilder, false, this.transform); // build facets and emit them to the builder
            const polyface = pfBuilder.claimPolyface();
            const wantEdges = DisplayParams_1.DisplayParams.RegionEdgeType.Default === this.displayParams.regionEdgeType;
            const isPlanar = true;
            return new Polyface_1.PolyfacePrimitiveList(Polyface_1.PolyfacePrimitive.create(this.displayParams, polyface, wantEdges, isPlanar));
        } // ###TODO: this approach might not work with holes
        return undefined;
    }
    _getStrokes(facetOptions) {
        return PrimitivePathGeometry.getStrokesForLoopOrPath(this.loop, facetOptions, this.displayParams, this.isDisjoint, this.transform);
    }
}
exports.PrimitiveLoopGeometry = PrimitiveLoopGeometry;
/** @internal */
class PrimitivePolyfaceGeometry extends Geometry {
    constructor(polyface, tf, range, params) {
        super(tf, range, params);
        this.polyface = polyface;
    }
    _getPolyfaces(_facetOptions) {
        if (!this.hasTexture) { // clear parameters
            if (this.polyface.data.param) {
                this.polyface.data.param.clear();
            }
            if (this.polyface.data.paramIndex) {
                this.polyface.data.paramIndex = [];
            }
        }
        bentleyjs_core_1.assert(this.transform.isIdentity);
        return new Polyface_1.PolyfacePrimitiveList(Polyface_1.PolyfacePrimitive.create(this.displayParams, this.polyface));
    }
    _getStrokes(_facetOptions) { return undefined; }
}
exports.PrimitivePolyfaceGeometry = PrimitivePolyfaceGeometry;


/***/ }),

/***/ "./lib/render/primitives/mesh/MeshBuilder.js":
/*!***************************************************!*\
  !*** ./lib/render/primitives/mesh/MeshBuilder.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const VertexKey_1 = __webpack_require__(/*! ../VertexKey */ "./lib/render/primitives/VertexKey.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const Primitives_1 = __webpack_require__(/*! ../Primitives */ "./lib/render/primitives/Primitives.js");
const MeshPrimitives_1 = __webpack_require__(/*! ./MeshPrimitives */ "./lib/render/primitives/mesh/MeshPrimitives.js");
/** @internal */
class MeshBuilder {
    get currentPolyface() { return this._currentPolyface; }
    set displayParams(params) { this.mesh.displayParams = params; }
    /** create reference for vertexMap on demand */
    get vertexMap() {
        if (undefined === this._vertexMap)
            this._vertexMap = new VertexKey_1.VertexMap();
        return this._vertexMap;
    }
    /** create reference for triangleSet on demand */
    get triangleSet() {
        if (undefined === this._triangleSet)
            this._triangleSet = new Primitives_1.TriangleSet();
        return this._triangleSet;
    }
    constructor(mesh, tolerance, areaTolerance, tileRange) {
        this.mesh = mesh;
        this.tolerance = tolerance;
        this.areaTolerance = areaTolerance;
        this.tileRange = tileRange;
    }
    /** create a new MeshBuilder */
    static create(props) {
        const mesh = MeshPrimitives_1.Mesh.create(props);
        const { tolerance, areaTolerance, range } = props;
        return new MeshBuilder(mesh, tolerance, areaTolerance, range);
    }
    /**
     * iterate through each point list of the strokes primitive and either load the point string or polyline into builder
     * @param strokes lists of stroke primitive point lists to iterate
     * @param isDisjoint if true add point string, else add polyline
     * @param fillColor
     */
    addStrokePointLists(strokes, isDisjoint, fillColor) {
        for (const strokePoints of strokes) {
            if (isDisjoint)
                this.addPointString(strokePoints.points, fillColor);
            else
                this.addPolyline(strokePoints.points, fillColor);
        }
    }
    /**
     * add data from polyface into mesh builder
     * @param polyface the indexed polyface to iterate the facets of to load each facet's triangles' vertices
     * @param props the properties required for this operation
     */
    addFromPolyface(polyface, props) {
        const visitor = polyface.createVisitor();
        while (visitor.moveToNextFacet()) {
            this.addFromPolyfaceVisitor(visitor, props);
        }
        this.endPolyface();
    }
    /**
     * @param visitor the PolyfaceVisitor containing the face data to be added
     * @param props the properties required for this operation:
     */
    addFromPolyfaceVisitor(visitor, options) {
        const { pointCount, normalCount, paramCount, requireNormals } = visitor;
        const { includeParams, mappedTexture } = options;
        const isDegenerate = requireNormals && normalCount < pointCount; // TFS#790263: Degenerate triangle - no normals.
        // a triangle must have at least 3 points
        if (pointCount < 3 || isDegenerate)
            return;
        const haveParam = includeParams && paramCount > 0;
        const triangleCount = pointCount - 2;
        bentleyjs_core_1.assert(!includeParams || paramCount > 0);
        bentleyjs_core_1.assert(!haveParam || undefined !== mappedTexture);
        const polyfaceVisitorOptions = Object.assign({}, options, { triangleCount, haveParam });
        // The face represented by this visitor should be convex (we request that in facet options) - so we do a simple fan triangulation.
        for (let triangleIndex = 0; triangleIndex < triangleCount; triangleIndex++) {
            const triangle = this.createTriangle(triangleIndex, visitor, polyfaceVisitorOptions);
            if (undefined !== triangle)
                this.addTriangle(triangle);
        }
    }
    createTriangleVertices(triangleIndex, visitor, options) {
        const { point, requireNormals } = visitor;
        const { fillColor, haveParam } = options;
        const qPointParams = this.mesh.points.params;
        // If we do not have UVParams stored on the IndexedPolyface, compute them now
        let params;
        if (haveParam && options.mappedTexture) {
            bentleyjs_core_1.assert(this.mesh.points.length === 0 || this.mesh.uvParams.length !== 0);
            const mappedTexture = options.mappedTexture;
            const transformToImodel = mappedTexture.params.textureMatrix.transform;
            if (transformToImodel)
                params = mappedTexture.computeUVParams(visitor, transformToImodel);
            bentleyjs_core_1.assert(params !== undefined);
        }
        const vertices = [];
        for (let i = 0; i < 3; ++i) {
            const vertexIndex = 0 === i ? 0 : triangleIndex + i;
            const position = imodeljs_common_1.QPoint3d.create(point.getPoint3dAtUncheckedPointIndex(vertexIndex), qPointParams);
            const normal = requireNormals ? imodeljs_common_1.OctEncodedNormal.fromVector(visitor.getNormal(vertexIndex)) : undefined;
            const uvParam = params ? params[vertexIndex] : undefined;
            vertices[i] = { position, fillColor, normal, uvParam };
        }
        // Previously we would add all 3 vertices to our map, then detect degenerate triangles in AddTriangle().
        // This led to unused vertex data, and caused mismatch in # of vertices when recreating the MeshBuilder from the data in the tile cache.
        // Detect beforehand instead.
        if (vertices[0].position.equals(vertices[1].position) || vertices[0].position.equals(vertices[2].position) || vertices[1].position.equals(vertices[2].position))
            return undefined;
        return vertices;
    }
    createTriangle(triangleIndex, visitor, options) {
        // generate vertex key properties for each of the three sides of the triangle
        const vertices = this.createTriangleVertices(triangleIndex, visitor, options);
        // avoid creating degenerate triangles
        if (undefined === vertices)
            return undefined;
        const { edgeVisible } = visitor;
        const triangle = new Primitives_1.Triangle();
        triangle.setEdgeVisibility(0 === triangleIndex ? edgeVisible[0] : false, edgeVisible[triangleIndex + 1], triangleIndex === options.triangleCount - 1 ? edgeVisible[triangleIndex + 2] : false);
        // set each triangle index to the index associated with the vertex key location in the vertex map
        vertices.forEach((vertexProps, i) => {
            const vertexKeyIndex = this.addVertex(vertexProps);
            triangle.indices[i] = vertexKeyIndex;
            // if the current polyface exists, map the vertex key index to the visitor's client point index
            if (this.currentPolyface !== undefined)
                this.currentPolyface.vertexIndexMap.set(vertexKeyIndex, visitor.clientPointIndex(i));
        });
        return triangle;
    }
    /** removed Feature for now */
    addPolyline(pts, fillColor) {
        const { mesh } = this;
        const poly = new imodeljs_common_1.MeshPolyline();
        const points = pts instanceof imodeljs_common_1.QPoint3dList ? pts : imodeljs_common_1.QPoint3dList.createFrom(pts, mesh.points.params);
        for (const position of points)
            poly.addIndex(this.addVertex({ position, fillColor }));
        mesh.addPolyline(poly);
    }
    /** removed Feature for now */
    addPointString(pts, fillColor) {
        const { mesh } = this;
        const poly = new imodeljs_common_1.MeshPolyline();
        const points = imodeljs_common_1.QPoint3dList.createFrom(pts, mesh.points.params);
        for (const position of points)
            poly.addIndex(this.addVertex({ position, fillColor }));
        mesh.addPolyline(poly);
    }
    beginPolyface(polyface, options) {
        // ###TODO generateNoEdges no edges case
        // maybe this --> (options.generateNoEdges && 0 === polyface.data.edgeVisible.length)
        const triangles = this.mesh.triangles;
        this._currentPolyface = new MeshBuilderPolyface(polyface, options, triangles === undefined ? 0 : triangles.length);
    }
    endPolyface() {
        const { currentPolyface, mesh } = this;
        if (undefined === currentPolyface)
            return;
        if (mesh.edges === undefined)
            mesh.edges = new imodeljs_common_1.MeshEdges();
        // ###TODO
        // MeshEdgesBuilder(m_tileRange, *m_mesh, *m_currentPolyface).BuildEdges(*m_mesh->m_edges, m_currentPolyface.get());
    }
    addVertex(vertex, addToMeshOnInsert = true) {
        // if vertex key isn't duplicate, then also insert properties into mesh
        const onInsert = (vk) => this.mesh.addVertex(vk);
        return this.vertexMap.insertKey(vertex, addToMeshOnInsert ? onInsert : undefined);
    }
    addTriangle(triangle) {
        // Prefer to avoid adding vertices originating from degenerate triangles before we get here...
        bentleyjs_core_1.assert(!triangle.isDegenerate);
        const onInsert = (_vk) => this.mesh.addTriangle(triangle);
        this.triangleSet.insertKey(triangle, onInsert);
    }
}
exports.MeshBuilder = MeshBuilder;
/** @internal */
class MeshEdgeCreationOptions {
    constructor(type = 0 /* NoEdges */) {
        this.minCreaseAngle = 20.0 * geometry_core_1.Angle.radiansPerDegree;
        this.type = type;
    }
    get generateAllEdges() { return this.type === 7 /* AllEdges */; }
    get generateNoEdges() { return this.type === 0 /* NoEdges */; }
    get generateSheetEdges() { return 0 !== (this.type & 1 /* SheetEdges */); }
    get generateCreaseEdges() { return 0 !== (this.type & 2 /* CreaseEdges */); }
    /** Create edge chains for polyfaces that do not already have them. */
    get createEdgeChains() { return 0 !== (this.type & 8 /* CreateChains */); }
}
exports.MeshEdgeCreationOptions = MeshEdgeCreationOptions;
/** @internal */
class MeshBuilderPolyface {
    constructor(polyface, edgeOptions, baseTriangleIndex) {
        this.vertexIndexMap = new Map();
        this.polyface = polyface;
        this.edgeOptions = edgeOptions;
        this.baseTriangleIndex = baseTriangleIndex;
    }
}
exports.MeshBuilderPolyface = MeshBuilderPolyface;


/***/ }),

/***/ "./lib/render/primitives/mesh/MeshBuilderMap.js":
/*!******************************************************!*\
  !*** ./lib/render/primitives/mesh/MeshBuilderMap.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const Primitives_1 = __webpack_require__(/*! ../Primitives */ "./lib/render/primitives/Primitives.js");
const MeshBuilder_1 = __webpack_require__(/*! ./MeshBuilder */ "./lib/render/primitives/mesh/MeshBuilder.js");
const MeshPrimitives_1 = __webpack_require__(/*! ./MeshPrimitives */ "./lib/render/primitives/mesh/MeshPrimitives.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/** @internal */
class MeshBuilderMap extends bentleyjs_core_1.Dictionary {
    constructor(tolerance, range, is2d, preserveKeyOrder = false, id) {
        super((lhs, rhs) => lhs.compare(rhs));
        this._keyOrder = 0;
        this.tolerance = tolerance;
        this.vertexTolerance = tolerance * Primitives_1.ToleranceRatio.vertex;
        this.facetAreaTolerance = tolerance * Primitives_1.ToleranceRatio.facetArea;
        this.range = range;
        this.is2d = is2d;
        this._preserveKeyOrder = preserveKeyOrder;
        if (undefined !== id) {
            const table = new imodeljs_common_1.FeatureTable(1);
            this.features = new MeshPrimitives_1.Mesh.Features(table);
            this.features.add(new imodeljs_common_1.Feature(id), 0);
        }
    }
    static createFromGeometries(geometries, tolerance, range, is2d, wantSurfacesOnly, wantPreserveOrder, id) {
        const map = new MeshBuilderMap(tolerance, range, is2d, wantPreserveOrder, id);
        for (const geom of geometries)
            map.loadGeometry(geom, wantSurfacesOnly);
        return map;
    }
    toMeshes() {
        const meshes = new MeshPrimitives_1.MeshList(undefined !== this.features ? this.features.table : undefined);
        for (const builder of this._values)
            meshes.push(builder.mesh);
        return meshes;
    }
    /**
     * extract polyfaces and strokes from geometry into MeshBuilder stored in builderMap
     * @param geom Geometry instance to extract polyfaces and strokes from
     * @param wantSurfacesOnly if true prevent strokes from being loaded into builders
     */
    loadGeometry(geom, wantSurfacesOnly) {
        this.loadPolyfacePrimitiveList(geom);
        if (!wantSurfacesOnly)
            this.loadStrokePrimitiveList(geom);
    }
    /**
     * extract polyface primitives from geometry in meshBuilder stored in builderMap
     * @param geom Geometry instance to extract polyfaces from
     */
    loadPolyfacePrimitiveList(geom) {
        const polyfaces = geom.getPolyfaces(this.tolerance);
        if (polyfaces !== undefined)
            for (const polyface of polyfaces)
                this.loadIndexedPolyface(polyface);
    }
    /**
     * extract indexed polyfaces into meshBuilder stored in builderMap
     * @param polyface PolyfacePrimitive to extract indexed polyfaces from
     */
    loadIndexedPolyface(polyface) {
        const { indexedPolyface, displayParams, isPlanar } = polyface;
        const { pointCount, normalCount } = indexedPolyface;
        const { fillColor, isTextured } = displayParams;
        const textureMapping = displayParams.textureMapping;
        if (pointCount === 0)
            return;
        const builder = this.getBuilder(displayParams, 0 /* Mesh */, normalCount > 0, isPlanar);
        builder.addFromPolyface(indexedPolyface, { includeParams: isTextured, fillColor: fillColor.tbgr, mappedTexture: textureMapping });
    }
    /**
     * extract stroke primitives from geometry in meshBuilder stored in builderMap
     * @param geom Geometry instance to extract strokes from
     */
    loadStrokePrimitiveList(geom) {
        const strokes = geom.getStrokes(this.tolerance);
        if (undefined !== strokes)
            for (const stroke of strokes)
                this.loadStrokesPrimitive(stroke);
    }
    /**
     * extract strokes primitive into meshBuilder stored in builderMap
     * @param strokePrimitive StrokesPrimitive instance to extractfrom
     */
    loadStrokesPrimitive(strokePrimitive) {
        const { displayParams, isDisjoint, isPlanar, strokes } = strokePrimitive;
        const type = isDisjoint ? 2 /* Point */ : 1 /* Polyline */;
        const builder = this.getBuilder(displayParams, type, false, isPlanar);
        builder.addStrokePointLists(strokes, isDisjoint, displayParams.fillColor.tbgr);
    }
    getBuilder(displayParams, type, hasNormals, isPlanar) {
        const { facetAreaTolerance, tolerance, is2d, range } = this;
        const key = this.getKey(displayParams, type, hasNormals, isPlanar);
        return this.getBuilderFromKey(key, { displayParams, type, range, is2d, isPlanar, tolerance, areaTolerance: facetAreaTolerance, features: this.features });
    }
    getKey(displayParams, type, hasNormals, isPlanar) {
        const key = new MeshBuilderMap.Key(displayParams, type, hasNormals, isPlanar);
        if (this._preserveKeyOrder)
            key.order = ++this._keyOrder;
        return key;
    }
    /**
     * gets builder associated with key if defined, otherwise creates a new builder and sets that with key
     * @param key MeshBuilderMap.Key to associate with builder
     * @param props MeshBuilder.Props required to create builder if it does not already exist
     * @returns builder reference, changes will update instance stored in builderMap
     */
    getBuilderFromKey(key, props) {
        let builder = this.get(key);
        if (undefined === builder) {
            builder = MeshBuilder_1.MeshBuilder.create(props);
            this.set(key, builder);
        }
        return builder;
    }
}
exports.MeshBuilderMap = MeshBuilderMap;
/** @internal */
(function (MeshBuilderMap) {
    class Key {
        constructor(params, type, hasNormals, isPlanar) {
            this.order = 0;
            this.params = params;
            this.type = type;
            this.hasNormals = hasNormals;
            this.isPlanar = isPlanar;
        }
        static createFromMesh(mesh) {
            return new Key(mesh.displayParams, mesh.type, mesh.normals.length !== 0, mesh.isPlanar);
        }
        compare(rhs) {
            let diff = bentleyjs_core_1.compareNumbers(this.order, rhs.order);
            if (0 === diff) {
                diff = bentleyjs_core_1.compareNumbers(this.type, rhs.type);
                if (0 === diff) {
                    diff = bentleyjs_core_1.compareBooleans(this.isPlanar, rhs.isPlanar);
                    if (0 === diff) {
                        diff = bentleyjs_core_1.compareBooleans(this.hasNormals, rhs.hasNormals);
                        if (0 === diff) {
                            diff = this.params.compareForMerge(rhs.params);
                        }
                    }
                }
            }
            return diff;
        }
        equals(rhs) { return 0 === this.compare(rhs); }
    }
    MeshBuilderMap.Key = Key;
})(MeshBuilderMap = exports.MeshBuilderMap || (exports.MeshBuilderMap = {}));


/***/ }),

/***/ "./lib/render/primitives/mesh/MeshPrimitives.js":
/*!******************************************************!*\
  !*** ./lib/render/primitives/mesh/MeshPrimitives.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const DisplayParams_1 = __webpack_require__(/*! ../DisplayParams */ "./lib/render/primitives/DisplayParams.js");
const ColorMap_1 = __webpack_require__(/*! ../ColorMap */ "./lib/render/primitives/ColorMap.js");
const Primitives_1 = __webpack_require__(/*! ../Primitives */ "./lib/render/primitives/Primitives.js");
/* Information needed to draw a set of indexed polylines using a shared vertex buffer.
 * @internal
 */
class PolylineArgs {
    constructor(points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createNull())), polylines = [], pointParams, is2d = false, isPlanar = false) {
        this.colors = new imodeljs_common_1.ColorIndex();
        this.features = new imodeljs_common_1.FeatureIndex();
        this.width = 0;
        this.linePixels = imodeljs_common_1.LinePixels.Solid;
        this.points = points;
        this.polylines = polylines;
        if (undefined === pointParams) {
            this.pointParams = imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createNull());
        }
        else {
            this.pointParams = pointParams;
        }
        this.flags = new imodeljs_common_1.PolylineFlags(is2d, isPlanar);
    }
    get isValid() { return this.polylines.length !== 0; }
    reset() {
        this.flags.initDefaults();
        this.points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createNull()));
        this.polylines = [];
        this.colors.reset();
        this.features.reset();
    }
    init(mesh) {
        this.reset();
        if (undefined === mesh.polylines)
            return;
        this.width = mesh.displayParams.width;
        this.linePixels = mesh.displayParams.linePixels;
        this.flags.is2d = mesh.is2d;
        this.flags.isPlanar = mesh.isPlanar;
        this.flags.isDisjoint = 2 /* Point */ === mesh.type;
        if (DisplayParams_1.DisplayParams.RegionEdgeType.Outline === mesh.displayParams.regionEdgeType) {
            // This polyline is behaving as the edges of a region surface.
            if (undefined === mesh.displayParams.gradient || mesh.displayParams.gradient.isOutlined)
                this.flags.setIsNormalEdge();
            else
                this.flags.setIsOutlineEdge(); // edges only displayed if fill undisplayed...
        }
        mesh.polylines.forEach((polyline) => {
            const indexedPolyline = new imodeljs_common_1.PolylineData();
            if (indexedPolyline.init(polyline)) {
                this.polylines.push(indexedPolyline);
            }
        });
        if (!this.isValid) {
            return false;
        }
        this.finishInit(mesh);
        return true;
    }
    finishInit(mesh) {
        this.pointParams = mesh.points.params;
        this.points = mesh.points;
        mesh.colorMap.toColorIndex(this.colors, mesh.colors);
        mesh.toFeatureIndex(this.features);
    }
}
exports.PolylineArgs = PolylineArgs;
/** The vertices of the edges are shared with those of the surface
 * @internal
 */
class MeshArgsEdges {
    constructor() {
        this.edges = new imodeljs_common_1.EdgeArgs();
        this.silhouettes = new imodeljs_common_1.SilhouetteEdgeArgs();
        this.polylines = new imodeljs_common_1.PolylineEdgeArgs();
        this.width = 0;
        this.linePixels = imodeljs_common_1.LinePixels.Solid;
    }
    clear() {
        this.edges.clear();
        this.silhouettes.clear();
        this.polylines.clear();
        this.width = 0;
        this.linePixels = imodeljs_common_1.LinePixels.Solid;
    }
    get isValid() { return this.edges.isValid || this.silhouettes.isValid || this.polylines.isValid; }
}
exports.MeshArgsEdges = MeshArgsEdges;
/* A carrier of information needed to describe a triangle mesh and its edges.
 * @internal
 */
class MeshArgs {
    constructor() {
        this.edges = new MeshArgsEdges();
        this.colors = new imodeljs_common_1.ColorIndex();
        this.features = new imodeljs_common_1.FeatureIndex();
        this.fillFlags = imodeljs_common_1.FillFlags.None;
        this.isPlanar = false;
        this.is2d = false;
        this.hasBakedLighting = false;
        this.isVolumeClassifier = false;
    }
    clear() {
        this.edges.clear();
        this.vertIndices = undefined;
        this.points = undefined;
        this.normals = undefined;
        this.textureUv = undefined;
        this.texture = undefined;
        this.colors.reset();
        this.features.reset();
        this.material = undefined;
        this.fillFlags = imodeljs_common_1.FillFlags.None;
        this.isPlanar = this.is2d = this.hasBakedLighting = this.isVolumeClassifier = false;
    }
    init(mesh) {
        this.clear();
        if (undefined === mesh.triangles || mesh.triangles.isEmpty)
            return false;
        bentleyjs_core_1.assert(0 < mesh.points.length);
        this.vertIndices = mesh.triangles.indices;
        this.points = mesh.points;
        if (!mesh.displayParams.ignoreLighting && 0 < mesh.normals.length)
            this.normals = mesh.normals;
        if (0 < mesh.uvParams.length)
            this.textureUv = mesh.uvParams;
        mesh.colorMap.toColorIndex(this.colors, mesh.colors);
        mesh.toFeatureIndex(this.features);
        this.material = mesh.displayParams.material;
        if (undefined !== mesh.displayParams.textureMapping)
            this.texture = mesh.displayParams.textureMapping.texture;
        this.fillFlags = mesh.displayParams.fillFlags;
        this.isPlanar = mesh.isPlanar;
        this.is2d = mesh.is2d;
        this.hasBakedLighting = (true === mesh.hasBakedLighting);
        this.isVolumeClassifier = (true === mesh.isVolumeClassifier);
        this.edges.width = mesh.displayParams.width;
        this.edges.linePixels = mesh.displayParams.linePixels;
        const meshEdges = mesh.edges;
        if (undefined === meshEdges)
            return true;
        this.edges.edges.init(mesh.edges);
        this.edges.silhouettes.init(mesh.edges);
        const polylines = [];
        meshEdges.polylines.forEach((meshPolyline) => {
            const polyline = new imodeljs_common_1.PolylineData();
            if (polyline.init(meshPolyline)) {
                polylines.push(polyline);
            }
        });
        this.edges.polylines.init(polylines);
        return true;
    }
}
exports.MeshArgs = MeshArgs;
/** @internal */
class MeshGraphicArgs {
    constructor() {
        this.polylineArgs = new PolylineArgs();
        this.meshArgs = new MeshArgs();
    }
}
exports.MeshGraphicArgs = MeshGraphicArgs;
/** @internal */
class Mesh {
    constructor(props) {
        this.normals = [];
        this.uvParams = [];
        this.colorMap = new ColorMap_1.ColorMap(); // used to be called ColorTable
        this.colors = [];
        const { displayParams, features, type, range, is2d, isPlanar } = props;
        this._data = 0 /* Mesh */ === type ? new Primitives_1.TriangleList() : new imodeljs_common_1.MeshPolylineList();
        this.displayParams = displayParams;
        this.features = features;
        this.type = type;
        this.is2d = is2d;
        this.isPlanar = isPlanar;
        this.hasBakedLighting = (true === props.hasBakedLighting);
        this.isVolumeClassifier = (true === props.isVolumeClassifier);
        this.points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(range));
    }
    static create(props) { return new Mesh(props); }
    get triangles() { return 0 /* Mesh */ === this.type ? this._data : undefined; }
    get polylines() { return 0 /* Mesh */ !== this.type ? this._data : undefined; }
    toFeatureIndex(index) {
        if (undefined !== this.features)
            this.features.toFeatureIndex(index);
    }
    getGraphics(args, system, instances) {
        if (undefined !== this.triangles && this.triangles.length !== 0) {
            if (args.meshArgs.init(this))
                return system.createTriMesh(args.meshArgs, instances);
        }
        else if (undefined !== this.polylines && this.polylines.length !== 0 && args.polylineArgs.init(this)) {
            return system.createIndexedPolylines(args.polylineArgs, instances);
        }
        return undefined;
    }
    addPolyline(poly) {
        const { type, polylines } = this;
        bentleyjs_core_1.assert(1 /* Polyline */ === type || 2 /* Point */ === type);
        bentleyjs_core_1.assert(undefined !== polylines);
        if (1 /* Polyline */ === type && poly.indices.length < 2)
            return;
        if (undefined !== polylines)
            polylines.push(poly);
    }
    addTriangle(triangle) {
        const { triangles, type } = this;
        bentleyjs_core_1.assert(0 /* Mesh */ === type);
        bentleyjs_core_1.assert(undefined !== triangles);
        if (undefined !== triangles)
            triangles.addTriangle(triangle);
    }
    addVertex(props) {
        const { position, normal, uvParam, fillColor } = props;
        this.points.push(position);
        if (undefined !== normal)
            this.normals.push(normal);
        if (undefined !== uvParam)
            this.uvParams.push(uvParam);
        // Don't allocate color indices until we have non-uniform colors
        if (0 === this.colorMap.length) {
            this.colorMap.insert(fillColor);
            bentleyjs_core_1.assert(this.colorMap.isUniform);
            bentleyjs_core_1.assert(0 === this.colorMap.indexOf(fillColor));
        }
        else if (!this.colorMap.isUniform || !this.colorMap.hasColor(fillColor)) {
            // Back-fill uniform value (index=0) for existing vertices if previously uniform
            if (0 === this.colors.length)
                this.colors.length = this.points.length - 1;
            this.colors.push(this.colorMap.insert(fillColor));
            bentleyjs_core_1.assert(!this.colorMap.isUniform);
        }
        return this.points.length - 1;
    }
}
exports.Mesh = Mesh;
/** @internal */
(function (Mesh) {
    class Features {
        constructor(table) {
            this.indices = [];
            this.uniform = 0;
            this.initialized = false;
            this.table = table;
        }
        add(feat, numVerts) {
            const index = this.table.insert(feat);
            if (!this.initialized) {
                // First feature - uniform.
                this.uniform = index;
                this.initialized = true;
            }
            else if (0 < this.indices.length) {
                // Already non-uniform
                this.indices.push(index);
            }
            else {
                // Second feature - back-fill uniform for existing verts
                while (this.indices.length < numVerts - 1)
                    this.indices.push(this.uniform);
                this.indices.push(index);
            }
        }
        setIndices(indices) {
            this.indices.length = 0;
            this.uniform = 0;
            this.initialized = 0 < indices.length;
            bentleyjs_core_1.assert(0 < indices.length);
            if (1 === indices.length)
                this.uniform = indices[0];
            else if (1 < indices.length)
                this.indices = indices;
        }
        toFeatureIndex(index) {
            if (!this.initialized) {
                index.type = imodeljs_common_1.FeatureIndexType.Empty;
            }
            else if (this.indices.length === 0) {
                index.type = imodeljs_common_1.FeatureIndexType.Uniform;
                index.featureID = this.uniform;
            }
            else {
                index.type = imodeljs_common_1.FeatureIndexType.NonUniform;
                index.featureIDs = new Uint32Array(this.indices);
            }
        }
    }
    Mesh.Features = Features;
})(Mesh = exports.Mesh || (exports.Mesh = {}));
/** @internal */
class MeshList extends Array {
    constructor(features) {
        super();
        this.features = features;
    }
}
exports.MeshList = MeshList;


/***/ }),

/***/ "./lib/render/webgl/BranchState.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/BranchState.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const FeatureSymbology_1 = __webpack_require__(/*! ../FeatureSymbology */ "./lib/render/FeatureSymbology.js");
/**
 * Represents a branch node in the scene graph, with associated view flags and transform to be applied to
 * all sub-nodes of the branch.
 * @internal
 */
class BranchState {
    static fromBranch(prev, branch) {
        const vf = branch.branch.getViewFlags(prev.viewFlags);
        const transform = prev.transform.multiplyTransformTransform(branch.localToWorldTransform);
        const ovrs = undefined !== branch.branch.symbologyOverrides ? branch.branch.symbologyOverrides : prev.symbologyOverrides;
        return new BranchState(vf, transform, ovrs, branch.clips, branch.planarClassifier);
    }
    static create(ovrs, flags, transform, clip, planarClassifier) {
        return new BranchState(imodeljs_common_1.ViewFlags.createFrom(flags), undefined !== transform ? transform.clone() : geometry_core_1.Transform.createIdentity(), ovrs, clip, planarClassifier);
    }
    static createForDecorations() {
        const vf = new imodeljs_common_1.ViewFlags();
        vf.renderMode = imodeljs_common_1.RenderMode.SmoothShade;
        vf.sourceLights = false;
        vf.cameraLights = false;
        vf.solarLight = false;
        return new BranchState(vf, geometry_core_1.Transform.createIdentity(), new FeatureSymbology_1.FeatureSymbology.Overrides());
    }
    get viewFlags() { return this._viewFlags; }
    set viewFlags(vf) { vf.clone(this._viewFlags); }
    get showClipVolume() { return this.viewFlags.clipVolume; }
    constructor(flags, transform, ovrs, clip, planarClassifier) {
        this._viewFlags = flags;
        this.transform = transform;
        this.symbologyOverrides = ovrs;
        this.clipVolume = clip;
        this.planarClassifier = planarClassifier;
    }
}
exports.BranchState = BranchState;
/**
 * Represents the current state of the scene graph. As the scene graph is traversed,
 * branch states are pushed and popped. Pushing a branch state replaces the current view flags
 * and multiplies the current transform with the branch's transform. Popping it inverts this
 * operation. The state at the top of the stack applies to the rendering of all primitives.
 * The stack does not store the scene graph itself.
 * @internal
 */
class BranchStack {
    constructor(flags, transform) {
        this._stack = [];
        this.pushState(BranchState.create(new FeatureSymbology_1.FeatureSymbology.Overrides(), flags, transform));
    }
    get top() {
        bentleyjs_core_1.assert(!this.empty);
        return this._stack[this._stack.length - 1];
    }
    get bottom() {
        bentleyjs_core_1.assert(!this.empty);
        return this._stack[0];
    }
    get length() { return this._stack.length; }
    get empty() { return 0 === this.length; }
    pushBranch(branch) {
        bentleyjs_core_1.assert(this.length > 0);
        this.pushState(BranchState.fromBranch(this.top, branch));
    }
    pushState(state) {
        this._stack.push(state);
    }
    pop() {
        bentleyjs_core_1.assert(!this.empty);
        if (!this.empty) {
            this._stack.pop();
        }
    }
    setViewFlags(vf) { bentleyjs_core_1.assert(1 === this.length); this.top.viewFlags = vf; }
    setSymbologyOverrides(ovrs) {
        bentleyjs_core_1.assert(1 === this.length);
        this.top.symbologyOverrides = ovrs;
    }
}
exports.BranchStack = BranchStack;
/**
 * Assigns a transient, unique 32-bit integer ID to each Batch in a RenderCommands.
 * A batch ID of 0 means "no batch".
 * The first batch gets batch ID of 1.
 * The next batch gets the previous batch's ID plus the number of features in the previous batch's feature table
 * (or 1, if empty feature table).
 * The IDs are set temporarily as members on the Batch objects and reset to 0 immediately after rendering.
 * The currentBatch member identifies the batch containing primitives currently being drawn.
 * The combination of the current batch's ID (passed as uniform to shader) and the index of a given Feature within
 * its batch's FeatureTable (stored in vertex table) produce a unique ID for every feature rendered during a frame.
 * During rendering, the feature IDs are written to the "feature ID" color attachment.
 * The batch IDs remain valid during a call to Target.readPixels() so that they can be used to extract
 * Features from the Batch's FeatureTables.
 * @internal
 */
class BatchState {
    constructor() {
        this._batches = []; // NB: this list is ordered - but *not* indexed - by batch ID.
    }
    get currentBatch() { return this._curBatch; }
    get currentBatchId() { return undefined !== this._curBatch ? this._curBatch.batchId : 0; }
    get isEmpty() { return 0 === this._batches.length; }
    push(batch, allowAdd) {
        bentleyjs_core_1.assert(undefined === this.currentBatch, "batches cannot nest");
        this.getBatchId(batch, allowAdd);
        this._curBatch = batch;
    }
    pop() {
        bentleyjs_core_1.assert(undefined !== this.currentBatch);
        this._curBatch = undefined;
    }
    reset() {
        bentleyjs_core_1.assert(undefined === this.currentBatch);
        for (const batch of this._batches)
            batch.batchId = 0;
        this._batches.length = 0;
        this._curBatch = undefined;
    }
    getElementId(featureId) {
        const batch = this.find(featureId);
        if (undefined === batch)
            return bentleyjs_core_1.Id64.invalid;
        const featureIndex = featureId - batch.batchId;
        bentleyjs_core_1.assert(featureIndex >= 0);
        const parts = batch.featureTable.getElementIdPair(featureIndex);
        return bentleyjs_core_1.Id64.fromUint32Pair(parts.lower, parts.upper);
    }
    getFeature(featureId) {
        const batch = this.find(featureId);
        if (undefined === batch)
            return undefined;
        const featureIndex = featureId - batch.batchId;
        bentleyjs_core_1.assert(featureIndex >= 0);
        return batch.featureTable.findFeature(featureIndex);
    }
    get numFeatureIds() { return this.nextBatchId; }
    get numBatches() { return this._batches.length; }
    findBatchId(featureId) {
        const batch = this.find(featureId);
        return undefined !== batch ? batch.batchId : 0;
    }
    get nextBatchId() {
        if (this.isEmpty)
            return 1;
        const prev = this._batches[this._batches.length - 1];
        bentleyjs_core_1.assert(0 !== prev.batchId);
        let prevNumFeatures = prev.featureTable.numFeatures;
        if (0 === prevNumFeatures)
            prevNumFeatures = 1;
        return prev.batchId + prevNumFeatures;
    }
    getBatchId(batch, allowAdd) {
        if (allowAdd && 0 === batch.batchId) {
            batch.batchId = this.nextBatchId;
            this._batches.push(batch);
        }
        return batch.batchId;
    }
    indexOf(featureId) {
        if (featureId <= 0)
            return -1;
        const found = bentleyjs_core_1.lowerBound(featureId, this._batches, (lhs, rhs) => {
            // Determine if the requested feature ID is within the range of this batch.
            if (lhs < rhs.batchId)
                return -1;
            const numFeatures = rhs.featureTable.numFeatures;
            const nextBatchId = rhs.batchId + (numFeatures > 0 ? numFeatures : 1);
            return lhs < nextBatchId ? 0 : 1;
        });
        return found.index < this._batches.length ? found.index : -1;
    }
    find(featureId) {
        const index = this.indexOf(featureId);
        return -1 !== index ? this._batches[index] : undefined;
    }
}
exports.BatchState = BatchState;


/***/ }),

/***/ "./lib/render/webgl/CachedGeometry.js":
/*!********************************************!*\
  !*** ./lib/render/webgl/CachedGeometry.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const Handle_1 = __webpack_require__(/*! ./Handle */ "./lib/render/webgl/Handle.js");
const TechniqueId_1 = __webpack_require__(/*! ./TechniqueId */ "./lib/render/webgl/TechniqueId.js");
const EdgeOverrides_1 = __webpack_require__(/*! ./EdgeOverrides */ "./lib/render/webgl/EdgeOverrides.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
/** Represents a geometric primitive ready to be submitted to the GPU for rendering.
 * @internal
 */
class CachedGeometry {
    /**
     * Functions for obtaining a subclass of CachedGeometry.
     * IMPORTANT: Do NOT use code like `const surface = cachedGeom as SurfaceGeometry`.
     * Instanced geometry holds a reference to the shared geometry rendered for each instance - such casts will fail,
     * while the casting `functions` will forward to the shared geometry.
     */
    get asLUT() { return undefined; }
    get asSurface() { return undefined; }
    get asMesh() { return undefined; }
    get asEdge() { return undefined; }
    get asSilhouette() { return undefined; }
    get asInstanced() { return undefined; }
    get isInstanced() { return undefined !== this.asInstanced; }
    // Returns the edge/line weight used to render this geometry
    _getLineWeight(_params) { return 0; }
    // Returns the edge/line pattern used to render this geometry
    _getLineCode(_params) { return EdgeOverrides_1.LineCode.solid; }
    // Returns true if this is a lit surface
    get isLitSurface() { return false; }
    // Returns true if this is an unlit surface with baked-in lighting (e.g. 3mx, scalable mesh reality models)
    get hasBakedLighting() { return false; }
    // Returns true if this primititive constains auxilliary animation data.
    get hasAnimation() { return false; }
    // Intended to be overridden by specific subclasses
    get material() { return undefined; }
    get polylineBuffers() { return undefined; }
    set uniformFeatureIndices(_value) { }
    get featuresInfo() { return undefined; }
    get isEdge() {
        switch (this.renderOrder) {
            case 4 /* Edge */:
            case 5 /* Silhouette */:
            case 12 /* PlanarEdge */:
            case 13 /* PlanarSilhouette */:
                return true;
            default:
                return false;
        }
    }
    wantWoWReversal(params) {
        return !params.isOverlayPass && this._wantWoWReversal(params.target);
    }
    getLineCode(params) {
        return params.target.currentViewFlags.styles ? this._getLineCode(params) : EdgeOverrides_1.LineCode.solid;
    }
    getLineWeight(params) {
        if (!params.target.currentViewFlags.weights) {
            return 1.0;
        }
        const minWeight = 1;
        let weight = this._getLineWeight(params);
        weight = Math.max(weight, minWeight);
        weight = Math.min(weight, 31.0);
        return weight;
    }
    // Returns true if flashing this geometry should mix its color with the hilite color. If not, the geometry color will be brightened instead.
    wantMixHiliteColorForFlash(vf, target) {
        // By default only surfaces rendered with lighting get brightened. Overridden for reality meshes since they have lighting baked-in.
        if (this.hasBakedLighting || 4 /* Classification */ === this.getRenderPass(target))
            return true;
        else if (!this.isLitSurface)
            return false;
        else if (imodeljs_common_1.RenderMode.SmoothShade !== vf.renderMode)
            return false;
        else
            return vf.sourceLights || vf.cameraLights || vf.solarLight;
    }
    computeRange(output) {
        if (undefined === this._range) {
            const lowX = this.qOrigin[0];
            const lowY = this.qOrigin[1];
            const lowZ = this.qOrigin[2];
            const hiX = 0xffff * this.qScale[0] + lowX;
            const hiY = 0xffff * this.qScale[1] + lowY;
            const hiZ = 0xffff * this.qScale[2] + lowZ;
            this._range = geometry_core_1.Range3d.createXYZXYZ(lowX, lowY, lowZ, hiX, hiY, hiZ);
        }
        return this._range.clone(output);
    }
}
exports.CachedGeometry = CachedGeometry;
/** Geometry which is drawn using indices into a look-up texture of vertex data, via gl.drawArrays()
 * @internal
 */
class LUTGeometry extends CachedGeometry {
    get asLUT() { return this; }
    draw() { this._draw(0); }
    drawInstanced(numInstances) { this._draw(numInstances); }
    // Override this if your color varies based on the target
    getColor(_target) { return this.lut.colorInfo; }
    get qOrigin() { return this.lut.qOrigin; }
    get qScale() { return this.lut.qScale; }
    get hasAnimation() { return this.lut.hasAnimation; }
    constructor() { super(); }
}
exports.LUTGeometry = LUTGeometry;
/** Parameters used to construct an IndexedGeometry
 * @internal
 */
class IndexedGeometryParams {
    constructor(positions, indices, numIndices) {
        this.positions = positions;
        this.indices = indices;
        this.numIndices = numIndices;
    }
    static create(positions, qparams, indices) {
        const posBuf = Handle_1.QBufferHandle3d.create(qparams, positions);
        const indBuf = Handle_1.BufferHandle.createBuffer(GL_1.GL.Buffer.Target.ElementArrayBuffer, indices);
        if (undefined === posBuf || undefined === indBuf)
            return undefined;
        return new IndexedGeometryParams(posBuf, indBuf, indices.length);
    }
    static createFromList(positions, indices) {
        return IndexedGeometryParams.create(positions.toTypedArray(), positions.params, indices);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.positions);
        bentleyjs_core_1.dispose(this.indices);
    }
}
exports.IndexedGeometryParams = IndexedGeometryParams;
/** A geometric primitive which is rendered using gl.drawElements() with one or more vertex buffers indexed by an index buffer.
 * @internal
 */
class IndexedGeometry extends CachedGeometry {
    _wantWoWReversal(_target) { return false; }
    constructor(params) {
        super();
        this._params = params;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._params);
    }
    bindVertexArray(attr) {
        attr.enableArray(this._params.positions, 3, GL_1.GL.DataType.UnsignedShort, false, 0, 0);
    }
    draw() {
        this._params.indices.bind(GL_1.GL.Buffer.Target.ElementArrayBuffer);
        System_1.System.instance.context.drawElements(GL_1.GL.PrimitiveType.Triangles, this._params.numIndices, GL_1.GL.DataType.UnsignedInt, 0);
    }
    get qOrigin() { return this._params.positions.origin; }
    get qScale() { return this._params.positions.scale; }
}
exports.IndexedGeometry = IndexedGeometry;
/** A geometric primitive representative of a set of clipping planes to clip a volume of space.
 * @internal
 */
class ClipMaskGeometry extends IndexedGeometry {
    constructor(indices, vertices) {
        super(IndexedGeometryParams.createFromList(vertices, indices));
    }
    collectStatistics(stats) {
        stats.addClipVolume(this._params.positions.bytesUsed + this._params.indices.bytesUsed);
    }
    getTechniqueId(_target) { return 19 /* ClipMask */; }
    getRenderPass(_target) { return 255 /* None */; }
    get renderOrder() { return 2 /* Surface */; }
}
exports.ClipMaskGeometry = ClipMaskGeometry;
/** a cube of quads in normalized device coordinates for skybox rendering techniques
 * @internal
 */
class SkyBoxQuads {
    constructor() {
        const skyBoxSz = 1.0;
        const qVerts = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromNormalizedRange());
        // NB: After applying the rotation matrix in the shader, Back becomes (Bottom), etc.
        // See the notes in the parens below.
        // ###TODO: Make this indexed.  Currently not indexed because of previous six-sided texture system.
        // Back (Bottom after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, skyBoxSz)); // back upper left - 0
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz)); // back upper right - 1
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower left - 2
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz)); // back upper right - 1
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower right - 3
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower left - 2
        // Front (Top after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower right - 7
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6
        // Top (Front after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz)); // back upper right - 1
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, skyBoxSz)); // back upper left - 0
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz)); // back upper right - 1
        // Bottom (Back after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower left - 2
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower right - 3
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower right - 3
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower right - 7
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6
        // Left (Right after rotation)
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, skyBoxSz)); // back upper left - 0
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower left - 2
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper left - 4
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6
        qVerts.add(new geometry_core_1.Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower left - 2
        // Right (Left after rotation)
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, skyBoxSz)); // back upper right - 1
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower right - 3
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, skyBoxSz, -skyBoxSz)); // front upper right - 5
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower right - 7
        qVerts.add(new geometry_core_1.Point3d(skyBoxSz, -skyBoxSz, skyBoxSz)); // back lower right - 3
        this.vertices = qVerts.toTypedArray();
        this.vertexParams = qVerts.params;
    }
    createParams() {
        return SkyBoxGeometryParams.create(this.vertices, this.vertexParams);
    }
}
/** Parameters used to construct an SkyBox
 * @internal
 */
class SkyBoxGeometryParams {
    constructor(positions) {
        this.positions = positions;
    }
    static create(positions, qparams) {
        const posBuf = Handle_1.QBufferHandle3d.create(qparams, positions);
        if (undefined === posBuf)
            return undefined;
        return new SkyBoxGeometryParams(posBuf);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.positions);
    }
}
exports.SkyBoxGeometryParams = SkyBoxGeometryParams;
/** @internal */
(function (SkyBoxQuads) {
    let _skyBoxQuads;
    function getInstance() {
        if (undefined === _skyBoxQuads)
            _skyBoxQuads = new SkyBoxQuads();
        return _skyBoxQuads;
    }
    SkyBoxQuads.getInstance = getInstance;
})(SkyBoxQuads || (SkyBoxQuads = {}));
/** Geometry used for view-space rendering techniques.
 * @internal
 */
class SkyBoxQuadsGeometry extends CachedGeometry {
    constructor(ndxGeomParams, texture) {
        super();
        this.cube = texture;
        this._techniqueId = 20 /* SkyBox */;
        this._params = ndxGeomParams;
    }
    static create(texture) {
        const sbxGeomParams = SkyBoxQuads.getInstance().createParams();
        return undefined !== sbxGeomParams ? new SkyBoxQuadsGeometry(sbxGeomParams, texture) : undefined;
    }
    collectStatistics(_stats) {
        // Not interested in tracking this.
    }
    getTechniqueId(_target) { return this._techniqueId; }
    getRenderPass(_target) { return 10 /* SkyBox */; }
    get renderOrder() { return 2 /* Surface */; }
    bindVertexArray(attr) {
        attr.enableArray(this._params.positions, 3, GL_1.GL.DataType.UnsignedShort, false, 0, 0);
    }
    draw() {
        System_1.System.instance.context.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, 36);
    }
    get qOrigin() { return this._params.positions.origin; }
    get qScale() { return this._params.positions.scale; }
    dispose() {
        bentleyjs_core_1.dispose(this._params);
    }
    _wantWoWReversal(_target) { return false; }
}
exports.SkyBoxQuadsGeometry = SkyBoxQuadsGeometry;
/** A quad with its corners mapped to the dimensions as the viewport, used for special rendering techniques.
 * @internal
 */
class ViewportQuad {
    constructor() {
        this.indices = new Uint32Array(6);
        const pt = new geometry_core_1.Point3d(-1, -1, 0);
        const vertices = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromNormalizedRange());
        vertices.add(pt);
        pt.x = 1;
        vertices.add(pt);
        pt.y = 1;
        vertices.add(pt);
        pt.x = -1;
        vertices.add(pt);
        this.vertices = vertices.toTypedArray();
        this.vertexParams = vertices.params;
        this.indices[0] = 0;
        this.indices[1] = 1;
        this.indices[2] = 2;
        this.indices[3] = 0;
        this.indices[4] = 2;
        this.indices[5] = 3;
    }
    createParams() {
        return IndexedGeometryParams.create(this.vertices, this.vertexParams, this.indices);
    }
}
/** @internal */
(function (ViewportQuad) {
    let _viewportQuad;
    function getInstance() {
        if (undefined === _viewportQuad)
            _viewportQuad = new ViewportQuad();
        return _viewportQuad;
    }
    ViewportQuad.getInstance = getInstance;
})(ViewportQuad || (ViewportQuad = {}));
/** Geometry used for view-space rendering techniques.
 * @internal
 */
class ViewportQuadGeometry extends IndexedGeometry {
    constructor(params, techniqueId) {
        super(params);
        this._techniqueId = techniqueId;
    }
    static create(techniqueId) {
        const params = ViewportQuad.getInstance().createParams();
        return undefined !== params ? new ViewportQuadGeometry(params, techniqueId) : undefined;
    }
    getTechniqueId(_target) { return this._techniqueId; }
    getRenderPass(_target) { return 3 /* OpaqueGeneral */; }
    get renderOrder() { return 2 /* Surface */; }
    collectStatistics(_stats) {
        // NB: These don't really count...
    }
}
exports.ViewportQuadGeometry = ViewportQuadGeometry;
/** Geometry used for view-space rendering techniques which involve sampling one or more textures.
 * @internal
 */
class TexturedViewportQuadGeometry extends ViewportQuadGeometry {
    constructor(params, techniqueId, textures) {
        super(params, techniqueId);
        this._textures = textures;
        // TypeScript compiler will happily accept TextureHandle (or any other type) in place of WebGLTexture.
        // There is no such 'type' as WebGLTexture at run-time.
        bentleyjs_core_1.assert(this._textures.every((tx) => !(tx instanceof Texture_1.TextureHandle)));
    }
}
exports.TexturedViewportQuadGeometry = TexturedViewportQuadGeometry;
/** Geometry used for rendering default gradient-style or single texture spherical skybox.
 * @internal
 */
class SkySphereViewportQuadGeometry extends ViewportQuadGeometry {
    constructor(params, skybox, techniqueId) {
        super(params, techniqueId);
        this.worldPos = new Float32Array(4 * 3);
        this._worldPosBuff = new Handle_1.BufferHandle();
        this.typeAndExponents = new Float32Array(3);
        this.zenithColor = new Float32Array(3);
        this.skyColor = new Float32Array(3);
        this.groundColor = new Float32Array(3);
        this.nadirColor = new Float32Array(3);
        this.zOffset = skybox.zOffset;
        const sphere = skybox.sphere;
        this.rotation = undefined !== sphere ? sphere.rotation : 0.0;
        if (undefined !== sphere) {
            this.skyTexture = sphere.texture;
            this.typeAndExponents[0] = 0.0;
            this.typeAndExponents[1] = 1.0;
            this.typeAndExponents[2] = 1.0;
            this.zenithColor[0] = 0.0;
            this.zenithColor[1] = 0.0;
            this.zenithColor[2] = 0.0;
            this.nadirColor[0] = 0.0;
            this.nadirColor[1] = 0.0;
            this.nadirColor[2] = 0.0;
            this.skyColor[0] = 0.0;
            this.skyColor[1] = 0.0;
            this.skyColor[2] = 0.0;
            this.groundColor[0] = 0.0;
            this.groundColor[1] = 0.0;
            this.groundColor[2] = 0.0;
        }
        else {
            const gradient = skybox.gradient;
            this.zenithColor[0] = gradient.zenithColor.colors.r / 255.0;
            this.zenithColor[1] = gradient.zenithColor.colors.g / 255.0;
            this.zenithColor[2] = gradient.zenithColor.colors.b / 255.0;
            this.nadirColor[0] = gradient.nadirColor.colors.r / 255.0;
            this.nadirColor[1] = gradient.nadirColor.colors.g / 255.0;
            this.nadirColor[2] = gradient.nadirColor.colors.b / 255.0;
            if (gradient.twoColor) {
                this.typeAndExponents[0] = -1.0;
                this.typeAndExponents[1] = 4.0;
                this.typeAndExponents[2] = 4.0;
                this.skyColor[0] = 0.0;
                this.skyColor[1] = 0.0;
                this.skyColor[2] = 0.0;
                this.groundColor[0] = 0.0;
                this.groundColor[1] = 0.0;
                this.groundColor[2] = 0.0;
            }
            else {
                this.typeAndExponents[0] = 1.0;
                this.typeAndExponents[1] = gradient.skyExponent;
                this.typeAndExponents[2] = gradient.groundExponent;
                this.skyColor[0] = gradient.skyColor.colors.r / 255.0;
                this.skyColor[1] = gradient.skyColor.colors.g / 255.0;
                this.skyColor[2] = gradient.skyColor.colors.b / 255.0;
                this.groundColor[0] = gradient.groundColor.colors.r / 255.0;
                this.groundColor[1] = gradient.groundColor.colors.g / 255.0;
                this.groundColor[2] = gradient.groundColor.colors.b / 255.0;
            }
        }
    }
    static createGeometry(skybox) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined === params)
            return undefined;
        const technique = undefined !== skybox.sphere ? 22 /* SkySphereTexture */ : 21 /* SkySphereGradient */;
        return new SkySphereViewportQuadGeometry(params, skybox, technique);
    }
    get worldPosBuff() { return this._worldPosBuff; }
    bind() {
        this._worldPosBuff.bindData(GL_1.GL.Buffer.Target.ArrayBuffer, this.worldPos, GL_1.GL.Buffer.Usage.StreamDraw);
    }
    dispose() {
        bentleyjs_core_1.dispose(this._worldPosBuff);
    }
}
exports.SkySphereViewportQuadGeometry = SkySphereViewportQuadGeometry;
/** Geometry used when rendering ambient occlusion information to an output texture
 * @internal
 */
class AmbientOcclusionGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(depthAndOrder) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined === params) {
            return undefined;
        }
        // Will derive positions and normals from depthAndOrder.
        return new AmbientOcclusionGeometry(params, [depthAndOrder]);
    }
    get depthAndOrder() { return this._textures[0]; }
    get noise() { return System_1.System.instance.noiseTexture.getHandle(); }
    constructor(params, textures) {
        super(params, 23 /* AmbientOcclusion */, textures);
    }
}
exports.AmbientOcclusionGeometry = AmbientOcclusionGeometry;
/** @internal */
class BlurGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(texToBlur, depthAndOrder, blurDir) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined === params) {
            return undefined;
        }
        return new BlurGeometry(params, [texToBlur, depthAndOrder], blurDir);
    }
    get textureToBlur() { return this._textures[0]; }
    get depthAndOrder() { return this._textures[1]; }
    constructor(params, textures, blurDir) {
        super(params, 24 /* Blur */, textures);
        this.blurDir = blurDir;
    }
}
exports.BlurGeometry = BlurGeometry;
/** Geometry used during the 'composite' pass to apply transparency and/or hilite effects.
 * @internal
 */
class CompositeGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(opaque, accum, reveal, hilite) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined === params)
            return undefined;
        const textures = [opaque, accum, reveal, hilite];
        return new CompositeGeometry(params, textures);
    }
    get opaque() { return this._textures[0]; }
    get accum() { return this._textures[1]; }
    get reveal() { return this._textures[2]; }
    get hilite() { return this._textures[3]; }
    get occlusion() {
        return this._textures.length > 4 ? this._textures[4] : undefined;
    }
    set occlusion(occlusion) {
        bentleyjs_core_1.assert((undefined === occlusion) === (undefined !== this.occlusion));
        if (undefined !== occlusion)
            this._textures[4] = occlusion;
        else
            this._textures.length = 4;
    }
    // Invoked each frame to determine the appropriate Technique to use.
    update(flags) { this._techniqueId = this.determineTechnique(flags); }
    determineTechnique(flags) {
        return TechniqueId_1.computeCompositeTechniqueId(flags);
    }
    constructor(params, textures) {
        super(params, 6 /* CompositeHilite */, textures);
        bentleyjs_core_1.assert(4 <= this._textures.length);
    }
}
exports.CompositeGeometry = CompositeGeometry;
/** Geometry used to ping-pong the pick buffer data in between opaque passes.
 * @internal
 */
class CopyPickBufferGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(featureId, depthAndOrder) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined !== params) {
            return new CopyPickBufferGeometry(params, [featureId, depthAndOrder]);
        }
        else {
            return undefined;
        }
    }
    get featureId() { return this._textures[0]; }
    get depthAndOrder() { return this._textures[1]; }
    constructor(params, textures) {
        super(params, 14 /* CopyPickBuffers */, textures);
    }
}
exports.CopyPickBufferGeometry = CopyPickBufferGeometry;
class CombineTexturesGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(texture0, texture1) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined !== params) {
            return new CombineTexturesGeometry(params, [texture0, texture1]);
        }
        else {
            return undefined;
        }
    }
    get texture0() { return this._textures[0]; }
    get texture1() { return this._textures[1]; }
    constructor(params, textures) {
        super(params, 25 /* CombineTextures */, textures);
    }
}
exports.CombineTexturesGeometry = CombineTexturesGeometry;
/** @internal */
class SingleTexturedViewportQuadGeometry extends TexturedViewportQuadGeometry {
    static createGeometry(texture, techId) {
        const params = ViewportQuad.getInstance().createParams();
        if (undefined === params) {
            return undefined;
        }
        return new SingleTexturedViewportQuadGeometry(params, texture, techId);
    }
    get texture() { return this._textures[0]; }
    set texture(texture) { this._textures[0] = texture; }
    constructor(params, texture, techId) {
        super(params, techId, [texture]);
    }
}
exports.SingleTexturedViewportQuadGeometry = SingleTexturedViewportQuadGeometry;
/** @internal */
class PolylineBuffers {
    constructor(indices, prevIndices, nextIndicesAndParams) {
        this.indices = indices;
        this.prevIndices = prevIndices;
        this.nextIndicesAndParams = nextIndicesAndParams;
    }
    static create(polyline) {
        const indices = Handle_1.BufferHandle.createArrayBuffer(polyline.indices.data);
        const prev = Handle_1.BufferHandle.createArrayBuffer(polyline.prevIndices.data);
        const next = Handle_1.BufferHandle.createArrayBuffer(polyline.nextIndicesAndParams);
        return undefined !== indices && undefined !== prev && undefined !== next ? new PolylineBuffers(indices, prev, next) : undefined;
    }
    collectStatistics(stats, type) {
        stats.addBuffer(type, this.indices.bytesUsed + this.prevIndices.bytesUsed + this.nextIndicesAndParams.bytesUsed);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.indices);
        bentleyjs_core_1.dispose(this.prevIndices);
        bentleyjs_core_1.dispose(this.nextIndicesAndParams);
    }
}
exports.PolylineBuffers = PolylineBuffers;


/***/ }),

/***/ "./lib/render/webgl/ClipVolume.js":
/*!****************************************!*\
  !*** ./lib/render/webgl/ClipVolume.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/System.js");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const Viewport_1 = __webpack_require__(/*! ../../Viewport */ "./lib/Viewport.js");
const FrameBuffer_1 = __webpack_require__(/*! ./FrameBuffer */ "./lib/render/webgl/FrameBuffer.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_2 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "./lib/render/webgl/RenderState.js");
const DrawCommand_1 = __webpack_require__(/*! ./DrawCommand */ "./lib/render/webgl/DrawCommand.js");
/** Maintains a texture representing clipping planes. Updated when view matrix changes.
 * @internal
 */
class ClippingPlanes {
    constructor(planes, texture) {
        /** Most recently-applied view matrix. */
        this._transform = geometry_core_1.Transform.createZero();
        /** Position at which to write next texture data. */
        this._curPos = 0;
        this._texture = texture;
        this._planes = planes;
        this._view = new DataView(texture.data.buffer);
    }
    static create(planes) {
        return System_2.System.instance.capabilities.supportsTextureFloat ? FloatPlanes.create(planes) : PackedPlanes.create(planes);
    }
    dispose() {
        bentleyjs_core_1.dispose(this._texture.handle);
    }
    get bytesUsed() { return this._texture.handle.bytesUsed; }
    getTexture(transform) {
        if (transform.isAlmostEqual(this._transform))
            return this._texture.handle;
        this.reset();
        transform.clone(this._transform);
        // Avoid allocations inside loop...
        const pInwardNormal = new geometry_core_1.Vector3d();
        const dir = new geometry_core_1.Vector3d();
        const pos = new geometry_core_1.Point3d();
        const v0 = new geometry_core_1.Vector3d();
        let numSetsProcessed = 0;
        for (const set of this._planes.planes.convexSets) {
            if (set.planes.length === 0)
                continue;
            for (const plane of set.planes) {
                plane.inwardNormalRef.clone(pInwardNormal);
                let pDistance = plane.distance;
                // Transform direction of clip plane
                const norm = pInwardNormal;
                transform.matrix.multiplyVector(norm, dir);
                dir.normalizeInPlace();
                // Transform distance of clip plane
                transform.multiplyPoint3d(norm.scale(pDistance, v0), pos);
                v0.setFromPoint3d(pos);
                pInwardNormal.set(dir.x, dir.y, dir.z);
                pDistance = -v0.dotProduct(dir);
                // The plane has been transformed into view space
                this.appendPlane(pInwardNormal, pDistance);
            }
            if (++numSetsProcessed < this._planes.numSets)
                this.appendZeroPlane();
        }
        this._texture.handle.replaceTextureData(this._texture.data);
        return this._texture.handle;
    }
    /** Exposed for testing purposes. */
    getTextureData(transform) {
        this.getTexture(transform);
        return this._texture.data;
    }
    appendFloat(value) { this._view.setFloat32(this._curPos, value, true); this.advance(4); }
    appendUint8(value) { this._view.setUint8(this._curPos, value); this.advance(1); }
    advance(numBytes) { this._curPos += numBytes; }
    reset() { this._curPos = 0; }
    appendValues(a, b, c, d) {
        this.append(a);
        this.append(b);
        this.append(c);
        this.append(d);
    }
    appendPlane(normal, distance) { this.appendValues(normal.x, normal.y, normal.z, distance); }
    appendZeroPlane() { this.appendValues(0, 0, 0, 0); }
}
/** Stores clip planes in floating-point texture.
 * @internal
 */
class FloatPlanes extends ClippingPlanes {
    static create(planes) {
        const totalNumPlanes = planes.numPlanes + planes.numSets - 1;
        const data = new Float32Array(totalNumPlanes * 4);
        const handle = Texture_1.Texture2DHandle.createForData(1, totalNumPlanes, data, false, GL_1.GL.Texture.WrapMode.ClampToEdge, GL_1.GL.Texture.Format.Rgba);
        return undefined !== handle ? new FloatPlanes(planes, { handle, data }) : undefined;
    }
    append(value) { this.appendFloat(value); }
    constructor(planes, texture) { super(planes, texture); }
}
/** Stores clip planes packed into RGBA texture.
 * @internal
 */
class PackedPlanes extends ClippingPlanes {
    static create(planes) {
        const totalNumPlanes = planes.numPlanes + planes.numSets - 1;
        const data = new Uint8Array(totalNumPlanes * 4 * 4);
        const handle = Texture_1.Texture2DHandle.createForData(4, totalNumPlanes, data, false, GL_1.GL.Texture.WrapMode.ClampToEdge, GL_1.GL.Texture.Format.Rgba);
        return undefined !== handle ? new PackedPlanes(planes, { handle, data }) : undefined;
    }
    append(value) {
        const sign = value < 0 ? 1 : 0;
        value = Math.abs(value);
        const exponent = Math.floor(Math.log10(value)) + 1;
        value = value / Math.pow(10, exponent);
        const bias = 38;
        let temp = value * 256;
        const b0 = Math.floor(temp);
        temp = (temp - b0) * 256;
        const b1 = Math.floor(temp);
        temp = (temp - b1) * 256;
        const b2 = Math.floor(temp);
        const b3 = (exponent + bias) * 2 + sign;
        this.appendUint8(b0);
        this.appendUint8(b1);
        this.appendUint8(b2);
        this.appendUint8(b3);
    }
    constructor(planes, texture) { super(planes, texture); }
}
/** A 3D clip volume defined as a texture derived from a set of planes.
 * @internal
 */
class ClipPlanesVolume extends System_1.RenderClipVolume {
    constructor(clip, planes) {
        super(clip);
        this._planes = planes;
    }
    collectStatistics(stats) {
        if (undefined !== this._planes)
            stats.addClipVolume(this._planes.bytesUsed);
    }
    get type() { return 2 /* Planes */; }
    /** Create a new ClipPlanesVolume from a ClipVector.
     * * The result is undefined if
     *   * (a) there is more than one clipper
     *   * (b) the clipper does not have clipPlaneSet (for instance, a pure mask clipper has mask planes but not primary clip planes)
     */
    static create(clipVec) {
        if (1 !== clipVec.clips.length)
            return undefined;
        const clipPrim = clipVec.clips[0];
        const clipPlaneSet = clipPrim.fetchClipPlanesRef();
        return undefined !== clipPlaneSet ? ClipPlanesVolume.createFromClipPlaneSet(clipPlaneSet, clipVec) : undefined;
    }
    static createFromClipPlaneSet(clipPlaneSet, clip) {
        let numPlanes = 0;
        let numSets = 0;
        for (const set of clipPlaneSet.convexSets) {
            const setLength = set.planes.length;
            if (setLength !== 0) {
                numSets++;
                numPlanes += setLength;
            }
        }
        if (numPlanes === 0)
            return undefined;
        const planes = ClippingPlanes.create({ planes: clipPlaneSet, numPlanes, numSets });
        return new ClipPlanesVolume(clip, planes);
    }
    dispose() {
        this._planes = bentleyjs_core_1.dispose(this._planes);
    }
    /** Push this ClipPlanesVolume clipping onto a target. */
    pushToTarget(target) {
        if (undefined !== this._planes) {
            const texture = this._planes.getTexture(target.viewMatrix);
            target.clips.set(texture.height, texture);
        }
    }
    /** Push this ClipPlanesVolume clipping onto the target of a shader program executor. */
    pushToShaderExecutor(shader) {
        this.pushToTarget(shader.target);
    }
    /** Pop this ClipPlanesVolume clipping from a target. */
    pop(target) {
        target.clips.clear();
    }
    /** Exposed for testing purposes. */
    getTextureData(transform = geometry_core_1.Transform.identity) {
        return undefined !== this._planes ? this._planes.getTextureData(transform) : undefined;
    }
}
exports.ClipPlanesVolume = ClipPlanesVolume;
/** A 2D clip volume defined as a texture derived from a masked set of planes.
 * @internal
 */
class ClipMaskVolume extends System_1.RenderClipVolume {
    constructor(geometry, clip) {
        super(clip);
        this.geometry = geometry;
        this.frustum = new imodeljs_common_1.Frustum();
        this.rect = new Viewport_1.ViewRect(0, 0, 0, 0);
    }
    collectStatistics(stats) {
        this.geometry.collectStatistics(stats);
        if (undefined !== this._texture)
            stats.addClipVolume(this._texture.bytesUsed);
    }
    get type() { return 1 /* Mask */; }
    /** Create a new ClipMaskVolume from a clip vector. */
    static create(clipVec) {
        const range = clipVec.boundingRange;
        if (range.isNull)
            return undefined;
        const pts = [
            geometry_core_1.Point3d.create(range.low.x, range.low.y, 0),
            geometry_core_1.Point3d.create(range.high.x, range.low.y, 0),
            geometry_core_1.Point3d.create(range.high.x, range.high.y, 0),
            geometry_core_1.Point3d.create(range.low.x, range.high.y, 0),
        ];
        // Clip the polygon into smaller polygons inside the clipping region
        const clippedPolygonInsides = geometry_core_1.ClipUtilities.clipPolygonToClipShape(pts, clipVec.clips[0]); // ### TODO: Currently assume that there is only one shape...
        const indices = [];
        const vertices = imodeljs_common_1.QPoint3dList.createFrom([], imodeljs_common_1.QParams3d.fromRange(range));
        const strokeOptions = new geometry_core_1.StrokeOptions();
        strokeOptions.shouldTriangulate = true;
        const polyfaceBuilder = geometry_core_1.PolyfaceBuilder.create(strokeOptions);
        for (const clippedPolygon of clippedPolygonInsides) {
            if (clippedPolygon.length < 3) {
                continue;
            }
            else if (clippedPolygon.length === 3) {
                polyfaceBuilder.addTriangleFacet(clippedPolygon);
            }
            else if (clippedPolygon.length === 4) {
                polyfaceBuilder.addQuadFacet(clippedPolygon);
            }
            else if (clippedPolygon.length > 4) {
                // Clipped polygon must be triangulated before appending
                const triangulatedPolygonGraph = geometry_core_1.Triangulator.createTriangulatedGraphFromSingleLoop(clippedPolygon);
                geometry_core_1.Triangulator.flipTriangles(triangulatedPolygonGraph);
                polyfaceBuilder.addGraph(triangulatedPolygonGraph, false);
            }
        }
        const polyface = polyfaceBuilder.claimPolyface();
        const nPoints = polyface.pointCount;
        const pPoints = polyface.data.point;
        bentleyjs_core_1.assert(nPoints !== 0);
        for (let i = 0; i < nPoints; i++)
            vertices.add(pPoints.getPoint3dAtUncheckedPointIndex(i));
        const visitor = geometry_core_1.IndexedPolyfaceVisitor.create(polyface, 0);
        while (visitor.moveToNextFacet())
            for (let i = 0; i < 3; i++)
                indices.push(visitor.clientPointIndex(i));
        bentleyjs_core_1.assert(indices.length > 0);
        if (indices.length === 0 || vertices.length === 0)
            return undefined;
        return new ClipMaskVolume(new CachedGeometry_1.ClipMaskGeometry(new Uint32Array(indices), vertices), clipVec);
    }
    get texture() { return this._texture; }
    get fbo() { return this._fbo; }
    dispose() {
        this._texture = bentleyjs_core_1.dispose(this._texture);
        this._fbo = bentleyjs_core_1.dispose(this._fbo);
    }
    /** Push this ClipMaskVolume clipping onto a target. */
    pushToTarget(_target) { bentleyjs_core_1.assert(false); }
    /** Push this ClipMaskVolume clipping onto the target of a program executor. */
    pushToShaderExecutor(shader) {
        const texture = this.getTexture(shader);
        if (texture !== undefined)
            shader.target.clipMask = texture;
    }
    /** Pop this ClipMaskVolume clipping from a target. */
    pop(target) {
        if (target.is2d && this._texture !== undefined)
            target.clipMask = undefined;
    }
    /** Update the clip mask using the shader executor's target and return the resulting texture. */
    getTexture(exec) {
        const target = exec.target;
        if (!target.is2d)
            return undefined;
        const frust = target.planFrustum;
        const rect = target.viewRect;
        const frustumChanged = !this.frustum.equals(frust);
        const textureChanged = this._texture === undefined || this.rect.width !== rect.width || this.rect.height !== rect.height;
        if (textureChanged) {
            this.dispose();
            this._texture = Texture_1.TextureHandle.createForAttachment(rect.width, rect.height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
            if (this._texture !== undefined)
                this._fbo = FrameBuffer_1.FrameBuffer.create([this._texture]);
        }
        this.rect.init(rect.left, rect.top, rect.right, rect.bottom);
        if (textureChanged || frustumChanged) {
            this.frustum.setFrom(frust);
            this.render(exec);
        }
        return this._texture;
    }
    render(exec) {
        if (this._fbo === undefined)
            return;
        const state = new RenderState_1.RenderState();
        state.flags.depthMask = false;
        state.flags.blend = false;
        state.flags.depthTest = false;
        // Render clip geometry as a mask
        System_2.System.instance.frameBufferStack.execute(this._fbo, true, () => {
            const prevState = System_2.System.instance.currentRenderState.clone();
            const target = exec.target;
            System_2.System.instance.applyRenderState(state);
            const context = System_2.System.instance.context;
            context.clearColor(0, 0, 0, 0);
            context.clear(context.COLOR_BUFFER_BIT);
            if (undefined === ClipMaskVolume._drawParams)
                ClipMaskVolume._drawParams = new DrawCommand_1.DrawParams();
            const params = ClipMaskVolume._drawParams;
            params.init(exec.params, this.geometry, target.currentTransform);
            exec.drawInterrupt(params);
            // Restore previous render state
            System_2.System.instance.applyRenderState(prevState);
        });
    }
}
exports.ClipMaskVolume = ClipMaskVolume;


/***/ }),

/***/ "./lib/render/webgl/ColorInfo.js":
/*!***************************************!*\
  !*** ./lib/render/webgl/ColorInfo.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const FloatRGBA_1 = __webpack_require__(/*! ./FloatRGBA */ "./lib/render/webgl/FloatRGBA.js");
/* Describes a primitive's basic color properties
 * @internal
 */
class ColorInfo {
    constructor(hasTranslucency, uniform) {
        this.hasTranslucency = hasTranslucency;
        this._uniform = uniform;
    }
    static createUniform(color) { return new ColorInfo(color.hasTranslucency, color); }
    static createNonUniform(hasTranslucency) { return hasTranslucency ? this._nonUniformTranslucent : this._nonUniformOpaque; }
    static createFromColorDef(color) { return this.createUniform(FloatRGBA_1.FloatPreMulRgba.fromColorDef(color)); }
    static createFromColorIndex(colorIndex) {
        return undefined !== colorIndex.uniform ? this.createFromColorDef(colorIndex.uniform) : this.createNonUniform(colorIndex.hasAlpha);
    }
    static createFromVertexTable(vt) {
        return undefined !== vt.uniformColor ? this.createFromColorDef(vt.uniformColor) : this.createNonUniform(vt.hasTranslucency);
    }
    get isUniform() { return undefined !== this._uniform; }
    get isNonUniform() { return !this.isUniform; }
    get uniform() { bentleyjs_core_1.assert(this.isUniform); return this._uniform; }
}
ColorInfo._nonUniformTranslucent = new ColorInfo(true);
ColorInfo._nonUniformOpaque = new ColorInfo(false);
exports.ColorInfo = ColorInfo;


/***/ }),

/***/ "./lib/render/webgl/Diagnostics.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/Diagnostics.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
/** Provides facilities for conditionally executing diagnostic/debug code. By default, all facilities are disabled - they must be explicitly enabled.
 * @internal
 */
class Debug {
    /** If [[Debug.printEnabled]] is true, outputs a message using `console.log`.
     * @param message A function which returns a string. If [[Debug.printEnabled]] is false, the function is never evaluated.
     */
    static print(message) {
        if (this.printEnabled)
            console.log(message()); // tslint:disable-line:no-console
    }
    /** If [[Debug.evaluate]] is true, executes the supplied function and returns its result; otherwise returns the supplied default value.
     * @param evaluate The function to execute
     * @param defaultValue The value to return if [[Debug.evaluate]] is false
     * @returns The return value of `evaluate` if [[Debug.evaluate]] is true; otherwise, the `defaultValue`.
     */
    static evaluate(evaluate, defaultValue) {
        return this.evaluateEnabled ? evaluate() : defaultValue;
    }
    /** If [[Debug.evaluateEnabled]] is true, returns whether the currently-bound framebuffer is complete. */
    static get isValidFrameBuffer() { return GL_1.GL.FrameBuffer.Status.Complete === this.checkFrameBufferStatus(); }
    /** If [[Debug.evaluateEnabled]] is true, returns the status of the currently-bound framebuffer. */
    static checkFrameBufferStatus() {
        return this.evaluate(() => System_1.System.instance.context.checkFramebufferStatus(GL_1.GL.FrameBuffer.TARGET), GL_1.GL.FrameBuffer.Status.Complete);
    }
}
/** Whether [[Debug.print]] will actually produce output. */
Debug.printEnabled = false;
/** Whether [[Debug.evaluate]] will actually evaluate an expression. */
Debug.evaluateEnabled = false;
exports.Debug = Debug;


/***/ }),

/***/ "./lib/render/webgl/DrawCommand.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/DrawCommand.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./lib/render/webgl/Matrix.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const Graphic_1 = __webpack_require__(/*! ./Graphic */ "./lib/render/webgl/Graphic.js");
const Mesh_1 = __webpack_require__(/*! ./Mesh */ "./lib/render/webgl/Mesh.js");
// tslint:disable:no-const-enum
/** @internal */
class ShaderProgramParams {
    constructor() {
        this._renderPass = 255 /* None */;
        this._projectionMatrix = new Matrix_1.Matrix4();
        this._viewMatrix = new Matrix_1.Matrix4();
    }
    get target() { bentleyjs_core_1.assert(undefined !== this._target); return this._target; }
    get renderPass() { return this._renderPass; }
    get projectionMatrix() { return this._projectionMatrix; }
    get viewMatrix() { return this._viewMatrix; }
    get isViewCoords() { return 9 /* ViewOverlay */ === this.renderPass || 0 /* Background */ === this.renderPass; }
    get isOverlayPass() { return 8 /* WorldOverlay */ === this.renderPass || 9 /* ViewOverlay */ === this.renderPass; }
    get context() { return System_1.System.instance.context; }
    init(target, pass = 3 /* OpaqueGeneral */) {
        this._renderPass = pass;
        this._target = target;
        if (this.isViewCoords) {
            const rect = target.viewRect;
            Matrix_1.Matrix4.fromOrtho(0.0, rect.width, rect.height, 0.0, -1.0, 1.0, this._projectionMatrix);
        }
        else {
            Matrix_1.Matrix4.fromMatrix4d(target.projectionMatrix, this._projectionMatrix);
        }
        Matrix_1.Matrix4.fromTransform(this.target.viewMatrix, this._viewMatrix);
    }
}
exports.ShaderProgramParams = ShaderProgramParams;
const _scratchTransform = geometry_core_1.Transform.createIdentity();
/** @internal */
class DrawParams {
    constructor() {
        this._modelViewMatrix = new Matrix_1.Matrix4();
        this._modelMatrix = new Matrix_1.Matrix4();
    }
    get geometry() { bentleyjs_core_1.assert(undefined !== this._geometry); return this._geometry; }
    get programParams() { bentleyjs_core_1.assert(undefined !== this._programParams); return this._programParams; }
    get modelViewMatrix() { return this._modelViewMatrix; }
    // Used strictly by planar classification shaders - otherwise not necessarily initialized!
    get modelMatrix() { return this._modelMatrix; }
    get target() { return this.programParams.target; }
    get renderPass() { return this.programParams.renderPass; }
    get projectionMatrix() { return this.programParams.projectionMatrix; }
    get viewMatrix() { return this.programParams.viewMatrix; }
    get isViewCoords() { return this.programParams.isViewCoords; }
    get isOverlayPass() { return this.programParams.isOverlayPass; }
    get context() { return this.programParams.context; }
    init(programParams, geometry, modelMatrix = geometry_core_1.Transform.identity, pass) {
        this._programParams = programParams;
        if (undefined === pass)
            pass = programParams.renderPass;
        else
            bentleyjs_core_1.assert(pass === this.programParams.renderPass);
        this._geometry = geometry;
        if (this.isViewCoords) {
            // Zero out Z for silly clipping tools...
            const tf = modelMatrix.clone(_scratchTransform);
            tf.matrix.coffs[2] = tf.matrix.coffs[5] = tf.matrix.coffs[8] = 0.0;
            Matrix_1.Matrix4.fromTransform(tf, this._modelViewMatrix);
        }
        else {
            let modelViewMatrix = this.target.viewMatrix.clone(_scratchTransform);
            // For instanced geometry, the "model view" matrix is really a transform from center of instanced geometry range to view.
            // Shader will compute final model-view matrix based on this and the per-instance transform.
            const instancedGeom = geometry.asInstanced;
            if (undefined !== instancedGeom) {
                modelViewMatrix = modelViewMatrix.multiplyTransformTransform(instancedGeom.getRtcTransform(modelMatrix), modelViewMatrix);
            }
            else {
                Matrix_1.Matrix4.fromTransform(modelMatrix, this._modelMatrix);
                modelViewMatrix = modelViewMatrix.multiplyTransformTransform(modelMatrix, modelViewMatrix);
            }
            Matrix_1.Matrix4.fromTransform(modelViewMatrix, this._modelViewMatrix);
        }
    }
}
exports.DrawParams = DrawParams;
/** @internal */
class DrawCommand {
    preExecute(_exec) { }
    postExecute(_exec) { }
    get primitive() { return undefined; }
    get branch() { return undefined; }
    get pushOrPop() { return undefined; }
    get isPrimitiveCommand() { return undefined !== this.primitive; }
    get featureIndexType() { return undefined !== this.primitive ? this.primitive.featureIndexType : imodeljs_common_1.FeatureIndexType.Empty; }
    get hasFeatureOverrides() { return imodeljs_common_1.FeatureIndexType.Empty !== this.featureIndexType; }
    get renderOrder() { return undefined !== this.primitive ? this.primitive.renderOrder : 1 /* BlankingRegion */; }
    get hasAnimation() { return undefined !== this.primitive ? this.primitive.hasAnimation : false; }
    get isInstanced() { return undefined !== this.primitive ? this.primitive.isInstanced : false; }
    getRenderPass(target) { return undefined !== this.primitive ? this.primitive.getRenderPass(target) : 255 /* None */; }
    getTechniqueId(target) { return undefined !== this.primitive ? this.primitive.getTechniqueId(target) : -1 /* Invalid */; }
    getOmitStatus(_target) { return 0 /* Neutral */; }
    isPushCommand(branch) {
        return 0 /* Push */ === this.pushOrPop && (undefined === branch || this.branch === branch);
    }
    isPopCommand(branch) {
        return 1 /* Pop */ === this.pushOrPop && (undefined === branch || this.branch === branch);
    }
    static createForBranch(branch, pushOrPop) { return new BranchCommand(branch, pushOrPop); }
    static createForPrimitive(primitive, batch) {
        return undefined !== batch ? new BatchPrimitiveCommand(primitive, batch) : new PrimitiveCommand(primitive);
    }
}
exports.DrawCommand = DrawCommand;
class BranchCommand extends DrawCommand {
    get branch() { return this._branch; }
    get pushOrPop() { return this._pushOrPop; }
    constructor(branch, pushOrPop) {
        super();
        this._branch = branch;
        this._pushOrPop = pushOrPop;
    }
    getAnimationBranch(target) {
        return (this._branch.branch.animationId && target.animationBranches) ? target.animationBranches.get(this._branch.branch.animationId) : undefined;
    }
    getOmitStatus(target) {
        const animationBranch = this.getAnimationBranch(target);
        return (animationBranch && animationBranch.omit) ? (this._pushOrPop === 0 /* Push */ ? 1 /* Begin */ : -1 /* End */) : 0 /* Neutral */;
    }
    preExecute(_exec) {
        const animationBranch = this.getAnimationBranch(_exec.target);
        if (animationBranch) {
            if (animationBranch.transform) {
                let branchTransform = animationBranch.transform;
                const prevLocalToWorld = _exec.target.currentTransform;
                const prevWorldToLocal = prevLocalToWorld.inverse();
                if (prevLocalToWorld && prevWorldToLocal)
                    branchTransform = prevWorldToLocal.multiplyTransformTransform(branchTransform.multiplyTransformTransform(prevLocalToWorld));
                this._branch.localToWorldTransform = branchTransform;
            }
            if (animationBranch.clip !== undefined && animationBranch.clip.type === 2 /* Planes */)
                this._branch.clips = animationBranch.clip;
        }
    }
    execute(exec) {
        if (0 /* Push */ === this._pushOrPop) {
            exec.pushBranch(this._branch);
        }
        else {
            exec.popBranch();
        }
    }
}
/** Draw a primitive with no symbology overrides */
class PrimitiveCommand extends DrawCommand {
    constructor(primitive) {
        super();
        this._primitive = primitive;
    }
    get primitive() { return this._primitive; }
    execute(exec) {
        if (!System_1.System.instance.options.cullAgainstActiveVolume || !exec.target.isGeometryOutsideActiveVolume(this._primitive.cachedGeometry))
            this._primitive.draw(exec);
    }
}
/** Draw a batch primitive, possibly with symbology overridden per-feature
 * @internal
 */
class BatchPrimitiveCommand extends PrimitiveCommand {
    constructor(primitive, batch) {
        super(primitive);
        this._batch = batch;
    }
    preExecute(exec) {
        exec.target.pushBatch(this._batch);
    }
    postExecute(exec) {
        exec.target.popBatch();
    }
    computeIsFlashed(flashedId) {
        // ###TODO Can this be done in a less-ugly way? It's trying to determine if the batch's graphic is a classification primitive.
        const sp = this.primitive.cachedGeometry.asSurface;
        if (undefined !== sp && undefined !== sp.mesh.features && sp.mesh.features.isUniform) {
            const fi = sp.mesh.features.uniform;
            const featureElementId = this._batch.featureTable.findElementId(fi);
            if (undefined !== featureElementId)
                return featureElementId.toString() === flashedId.toString();
        }
        return bentleyjs_core_1.Id64.isInvalid(flashedId);
    }
}
exports.BatchPrimitiveCommand = BatchPrimitiveCommand;
/** A list of DrawCommands to be rendered, ordered by render pass.
 * @internal
 */
class RenderCommands {
    constructor(target, stack, batchState) {
        this._scratchFrustum = new imodeljs_common_1.Frustum();
        this._scratchRange = new geometry_core_1.Range3d();
        this._forcedRenderPass = 255 /* None */;
        this._opaqueOverrides = false;
        this._translucentOverrides = false;
        this._addTranslucentAsOpaque = false; // true when rendering for _ReadPixels to force translucent items to be drawn in opaque pass.
        this.target = target;
        this._stack = stack;
        this._batchState = batchState;
        this._commands = Array(16 /* COUNT */);
        for (let i = 0; i < 16 /* COUNT */; ++i)
            this._commands[i] = [];
    }
    get isEmpty() {
        for (const commands of this._commands)
            if (0 < commands.length)
                return false;
        return true;
    }
    get currentViewFlags() { return this._stack.top.viewFlags; }
    get compositeFlags() {
        let flags = 0 /* None */;
        if (this.hasCommands(5 /* Translucent */))
            flags |= 1 /* Translucent */;
        if (this.hasCommands(7 /* Hilite */) || this.hasCommands(12 /* HiliteClassification */) || this.hasCommands(14 /* HilitePlanarClassification */))
            flags |= 2 /* Hilite */;
        if (this.target.wantAmbientOcclusion)
            flags |= 4 /* AmbientOcclusion */;
        return flags;
    }
    get _curBatch() { return this._batchState.currentBatch; }
    hasCommands(pass) { return 0 !== this.getCommands(pass).length; }
    isOpaquePass(pass) { return pass >= 1 /* OpaqueLinear */ && pass <= 3 /* OpaqueGeneral */; }
    addGraphics(scene, forcedPass = 255 /* None */) {
        this._forcedRenderPass = forcedPass;
        scene.forEach((entry) => entry.addCommands(this));
        this._forcedRenderPass = 255 /* None */;
    }
    /** Add backgroundMap graphics to their own render pass. */
    addBackgroundMapGraphics(backgroundMapGraphics) {
        this._forcedRenderPass = 11 /* BackgroundMap */;
        backgroundMapGraphics.forEach((entry) => entry.addCommands(this));
        this._forcedRenderPass = 255 /* None */;
    }
    addDecorations(dec, forcedPass = 255 /* None */) {
        this._forcedRenderPass = forcedPass;
        for (const entry of dec) {
            entry.addCommands(this);
        }
        this._forcedRenderPass = 255 /* None */;
    }
    addWorldDecorations(decs) {
        const world = this.target.getWorldDecorations(decs);
        this.pushAndPopBranch(world, () => {
            for (const entry of world.branch.entries) {
                entry.addCommands(this);
            }
        });
    }
    addPickableDecorations(decs) {
        if (undefined !== decs.normal) {
            for (const normal of decs.normal) {
                const gf = normal;
                if (gf.isPickable)
                    gf.addCommands(this);
            }
        }
        if (undefined !== decs.world) {
            const world = this.target.getWorldDecorations(decs.world);
            this.pushAndPopBranch(world, () => {
                for (const gf of world.branch.entries) {
                    if (gf.isPickable)
                        gf.addCommands(this);
                }
            });
        }
    }
    addBackground(gf) {
        if (undefined === gf)
            return;
        bentleyjs_core_1.assert(255 /* None */ === this._forcedRenderPass);
        this._forcedRenderPass = 0 /* Background */;
        this._stack.pushState(this.target.decorationState);
        gf.addCommands(this);
        this._stack.pop();
        this._forcedRenderPass = 255 /* None */;
    }
    addSkyBox(gf) {
        if (undefined === gf)
            return;
        bentleyjs_core_1.assert(255 /* None */ === this._forcedRenderPass);
        this._forcedRenderPass = 10 /* SkyBox */;
        this._stack.pushState(this.target.decorationState);
        gf.addCommands(this);
        this._stack.pop();
        this._forcedRenderPass = 255 /* None */;
    }
    addDrawCommand(command, pass) {
        if (undefined === pass)
            pass = this.getRenderPass(command);
        if (255 /* None */ === pass) // Edges will return none if they don't want to draw at all (edges not turned on).
            return;
        if (255 /* None */ !== this._forcedRenderPass) {
            // Add the command to the forced render pass (background).
            this.getCommands(this._forcedRenderPass).push(command);
            return;
        }
        let ovrType = imodeljs_common_1.FeatureIndexType.Empty;
        if (this._opaqueOverrides || this._translucentOverrides)
            ovrType = command.featureIndexType;
        const haveFeatureOverrides = imodeljs_common_1.FeatureIndexType.Empty !== ovrType;
        if (5 /* Translucent */ === pass && this._addTranslucentAsOpaque) {
            switch (command.renderOrder) {
                case 10 /* PlanarSurface */:
                    pass = 2 /* OpaquePlanar */;
                    break;
                case 2 /* Surface */:
                    pass = 3 /* OpaqueGeneral */;
                    break;
                default:
                    pass = 1 /* OpaqueLinear */;
                    break;
            }
        }
        switch (pass) {
            // If this command ordinarily renders translucent, but some features have been overridden to be opaque, must draw in both passes
            case 5 /* Translucent */:
                if (this._opaqueOverrides && haveFeatureOverrides) {
                    let opaquePass;
                    switch (command.renderOrder) {
                        case 10 /* PlanarSurface */:
                            opaquePass = 2 /* OpaquePlanar */;
                            break;
                        case 2 /* Surface */:
                            opaquePass = 3 /* OpaqueGeneral */;
                            break;
                        default:
                            opaquePass = 1 /* OpaqueLinear */;
                            break;
                    }
                    this.getCommands(opaquePass).push(command);
                }
                break;
            // If this command ordinarily renders opaque, but some features have been overridden to be translucent,
            // must draw in both passes unless we are overriding translucent geometry to draw in the opaque pass for _ReadPixels.
            case 1 /* OpaqueLinear */:
            case 2 /* OpaquePlanar */:
                // Want these items to draw in general opaque pass so they are not in pick data.
                if (imodeljs_common_1.FeatureIndexType.Empty === command.featureIndexType)
                    pass = 3 /* OpaqueGeneral */;
            /* falls through */
            case 3 /* OpaqueGeneral */:
                if (this._translucentOverrides && haveFeatureOverrides && !this._addTranslucentAsOpaque)
                    this.getCommands(5 /* Translucent */).push(command);
                break;
        }
        this.getCommands(pass).push(command);
    }
    getRenderPass(command) { return command.getRenderPass(this.target); }
    getCommands(pass) {
        let idx = pass;
        bentleyjs_core_1.assert(idx < this._commands.length);
        if (idx >= this._commands.length)
            idx -= 1;
        return this._commands[idx];
    }
    addHiliteBranch(branch, batch, pass) {
        this.pushAndPopBranchForPass(pass, branch, () => {
            branch.branch.entries.forEach((entry) => entry.addHiliteCommands(this, batch, pass));
        });
    }
    pushAndPopBranchForPass(pass, branch, func) {
        bentleyjs_core_1.assert(255 /* None */ !== pass);
        this._stack.pushBranch(branch);
        if (branch.planarClassifier)
            branch.planarClassifier.pushBatchState(this._batchState);
        const cmds = this.getCommands(pass);
        cmds.push(DrawCommand.createForBranch(branch, 0 /* Push */));
        func();
        this._stack.pop();
        if (cmds[cmds.length - 1].isPushCommand(branch))
            cmds.pop();
        else
            cmds.push(DrawCommand.createForBranch(branch, 1 /* Pop */));
    }
    pushAndPopBranch(branch, func) {
        this._stack.pushBranch(branch);
        if (branch.planarClassifier)
            branch.planarClassifier.pushBatchState(this._batchState);
        let cmds;
        const emptyRenderPass = 255 /* None */ === this._forcedRenderPass, start = emptyRenderPass ? 0 : this._forcedRenderPass, end = emptyRenderPass ? this._commands.length : start + 1;
        for (let i = start; i < end; ++i) {
            cmds = this._commands[i];
            cmds.push(DrawCommand.createForBranch(branch, 0 /* Push */));
        }
        // Add the commands from within the branch
        func();
        const popCmd = DrawCommand.createForBranch(branch, 1 /* Pop */);
        for (let i = start; i < end; ++i) {
            cmds = this._commands[i];
            bentleyjs_core_1.assert(0 < cmds.length);
            if (0 < cmds.length && cmds[cmds.length - 1].isPushCommand(branch))
                cmds.pop();
            else
                cmds.push(popCmd);
        }
        this._stack.pop();
    }
    clear() {
        bentleyjs_core_1.assert(this._batchState.isEmpty);
        this._clearCommands();
    }
    _clearCommands() {
        this._commands.forEach((cmds) => { cmds.splice(0); });
    }
    initForPickOverlays(overlays) {
        this._clearCommands();
        this._addTranslucentAsOpaque = true;
        this._stack.pushState(this.target.decorationState);
        for (const overlay of overlays) {
            const gf = overlay;
            if (gf.isPickable)
                gf.addCommands(this);
        }
        this._stack.pop();
        this._addTranslucentAsOpaque = false;
    }
    init(scene, backgroundMap, dec, dynamics, initForReadPixels = false) {
        this.clear();
        if (initForReadPixels) {
            this._addTranslucentAsOpaque = true; // Set flag to force translucent geometry to be put into the opaque pass.
            // Add the scene graphics.
            this.addGraphics(scene);
            // Also add any pickable decorations.
            if (undefined !== dec)
                this.addPickableDecorations(dec);
            this._addTranslucentAsOpaque = false;
            this.setupClassificationByVolume();
            return;
        }
        this.addGraphics(scene);
        this.addBackgroundMapGraphics(backgroundMap);
        if (undefined !== dynamics && 0 < dynamics.length) {
            this.addDecorations(dynamics);
        }
        if (undefined !== dec) {
            this.addBackground(dec.viewBackground);
            this.addSkyBox(dec.skyBox);
            if (undefined !== dec.normal && 0 < dec.normal.length) {
                this.addGraphics(dec.normal);
            }
            if (undefined !== dec.world && 0 < dec.world.length) {
                this.addWorldDecorations(dec.world);
            }
            this._stack.pushState(this.target.decorationState);
            if (undefined !== dec.viewOverlay && 0 < dec.viewOverlay.length) {
                this.addDecorations(dec.viewOverlay, 9 /* ViewOverlay */);
            }
            if (undefined !== dec.worldOverlay && 0 < dec.worldOverlay.length) {
                this.addDecorations(dec.worldOverlay, 8 /* WorldOverlay */);
            }
            this._stack.pop();
        }
        this.setupClassificationByVolume();
    }
    addPrimitive(prim) {
        // ###TODO Would be nice if we could detect outside active volume here, but active volume only applies to specific render passes
        // if (this.target.isGeometryOutsideActiveVolume(prim.cachedGeometry))
        //   return;
        if (undefined !== this._frustumPlanes) { // See if we can cull this primitive.
            if (4 /* Classification */ === prim.getRenderPass(this.target)) {
                const geom = prim.cachedGeometry;
                geom.computeRange(this._scratchRange);
                let frustum = imodeljs_common_1.Frustum.fromRange(this._scratchRange, this._scratchFrustum);
                frustum = frustum.transformBy(this.target.currentTransform, frustum);
                if (0 /* Outside */ === this._frustumPlanes.computeFrustumContainment(frustum)) {
                    return;
                }
            }
        }
        const command = DrawCommand.createForPrimitive(prim, this._curBatch);
        this.addDrawCommand(command);
        if (255 /* None */ === this._forcedRenderPass && prim.isEdge) {
            const vf = this.target.currentViewFlags;
            if (vf.renderMode !== imodeljs_common_1.RenderMode.Wireframe && vf.hiddenEdges)
                this.addDrawCommand(command, 6 /* HiddenEdge */);
        }
    }
    addBranch(branch) {
        this.pushAndPopBranch(branch, () => {
            branch.branch.entries.forEach((entry) => entry.addCommands(this));
        });
    }
    computeBatchHiliteRenderPass(batch) {
        let pass = 7 /* Hilite */;
        if (batch.graphic instanceof Mesh_1.MeshGraphic) {
            const mg = batch.graphic;
            if (4 /* VolumeClassifier */ === mg.surfaceType)
                pass = 12 /* HiliteClassification */;
        }
        else if (batch.graphic instanceof Graphic_1.GraphicsArray) {
            const ga = batch.graphic;
            if (ga.graphics[0] instanceof Mesh_1.MeshGraphic) {
                const mg = ga.graphics[0];
                if (4 /* VolumeClassifier */ === mg.surfaceType)
                    pass = 12 /* HiliteClassification */;
            }
        }
        return pass;
    }
    addBatch(batch) {
        // Batches (aka element tiles) should only draw during ordinary (translucent or opaque) passes.
        // They may draw during both, or neither.
        // NB: This is no longer true - pickable overlay decorations are defined as Batches. Problem?
        // assert(RenderPass.None === this._forcedRenderPass);
        bentleyjs_core_1.assert(!this._opaqueOverrides && !this._translucentOverrides);
        bentleyjs_core_1.assert(undefined === this._curBatch);
        // If all features are overridden to be invisible, draw no graphics in this batch
        const overrides = batch.getOverrides(this.target);
        if (overrides.allHidden)
            return;
        if (!batch.range.isNull) {
            // ###TODO Would be nice if we could detect outside active volume here, but active volume only applies to specific render passes
            // if (this.target.isRangeOutsideActiveVolume(batch.range))
            //   return;
            if (undefined !== this._frustumPlanes) {
                let frustum = imodeljs_common_1.Frustum.fromRange(batch.range, this._scratchFrustum);
                frustum = frustum.transformBy(this.target.currentTransform, frustum);
                if (0 /* Outside */ === this._frustumPlanes.computeFrustumContainment(frustum)) {
                    return;
                }
            }
        }
        this._batchState.push(batch, true);
        if (this.currentViewFlags.transparency) {
            this._opaqueOverrides = overrides.anyOpaque;
            this._translucentOverrides = overrides.anyTranslucent;
        }
        batch.graphic.addCommands(this);
        this._batchState.pop();
        // If the batch contains hilited features, need to render them in the hilite pass
        const anyHilited = overrides.anyHilited;
        const planarClassifierHilited = this._stack.top.planarClassifier && this._stack.top.planarClassifier.anyHilited;
        if (anyHilited || planarClassifierHilited)
            batch.graphic.addHiliteCommands(this, batch, planarClassifierHilited ? 14 /* HilitePlanarClassification */ : this.computeBatchHiliteRenderPass(batch));
        this._opaqueOverrides = this._translucentOverrides = false;
    }
    // Define a culling frustum. Commands associated with Graphics whose ranges do not intersect the frustum will be skipped.
    setCheckRange(frustum) { this._frustumPlanes = new imodeljs_common_1.FrustumPlanes(frustum); }
    // Clear the culling frustum.
    clearCheckRange() { this._frustumPlanes = undefined; }
    setupClassificationByVolume() {
        // To make is easier to process the classifiers individually, set up a secondary command list for them where they
        // are each separated by their own push & pop and can more easily be accessed by index.
        const groupedCmds = this._commands[4 /* Classification */];
        const byIndexCmds = this._commands[13 /* ClassificationByIndex */];
        const numCmds = groupedCmds.length;
        let curCmdIndex = 0;
        while (curCmdIndex < numCmds) {
            // Find the next set of clasifiers (should be between a push & pop branch).
            const pushCmd = groupedCmds[curCmdIndex++];
            if (!pushCmd.isPushCommand())
                continue;
            let primCmdIndex = curCmdIndex++;
            if (!groupedCmds[primCmdIndex].isPrimitiveCommand)
                continue;
            while (groupedCmds[curCmdIndex].isPrimitiveCommand)
                ++curCmdIndex;
            const popCmdIndex = curCmdIndex++;
            const popCmd = groupedCmds[popCmdIndex];
            if (!popCmd.isPopCommand())
                continue;
            // Loop through the primitive commands between the push and pop, copying them to the byIndex command list.
            while (primCmdIndex < popCmdIndex) {
                byIndexCmds.push(pushCmd);
                byIndexCmds.push(groupedCmds[primCmdIndex++]);
                byIndexCmds.push(popCmd);
            }
        }
    }
}
exports.RenderCommands = RenderCommands;


/***/ }),

/***/ "./lib/render/webgl/EdgeOverrides.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/EdgeOverrides.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const FloatRGBA_1 = __webpack_require__(/*! ./FloatRGBA */ "./lib/render/webgl/FloatRGBA.js");
/** Describes one of the pre-defined line patterns. See Render.LinePixels.
 * @internal
 */
var LineCode;
(function (LineCode) {
    function valueFromLinePixels(pixels) {
        switch (pixels) {
            case imodeljs_common_1.LinePixels.Code0: return 0;
            case imodeljs_common_1.LinePixels.Code1: return 1;
            case imodeljs_common_1.LinePixels.Code2: return 2;
            case imodeljs_common_1.LinePixels.Code3: return 3;
            case imodeljs_common_1.LinePixels.Code4: return 4;
            case imodeljs_common_1.LinePixels.Code5: return 5;
            case imodeljs_common_1.LinePixels.Code6: return 6;
            case imodeljs_common_1.LinePixels.Code7: return 7;
            case imodeljs_common_1.LinePixels.HiddenLine: return 8;
            case imodeljs_common_1.LinePixels.Invisible: return 9;
            default: return 0;
        }
    }
    LineCode.valueFromLinePixels = valueFromLinePixels;
    LineCode.solid = 0;
    LineCode.count = 16; // only 10 line codes, but pad to 16 to make height a power of two.
    LineCode.size = 32;
    // NB: Non-power-of-two textures in WebGL only support clamp-to-edge.
    // Make this a power of two so we can use repeat.
    LineCode.lineCodeData = [
        0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
        0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,
        0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,
        0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
        0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
    ];
})(LineCode = exports.LineCode || (exports.LineCode = {}));
/** @internal */
class EdgeOverrides {
    constructor(style, forceOpaque = false) {
        this._forceOpaque = false;
        this.init(forceOpaque, style);
    }
    get color() { return this._color; }
    get lineCode() { return this._lineCode; }
    get weight() { return this._weight; }
    get forceOpaque() { return this._forceOpaque; }
    get overridesColor() { return undefined !== this.color; }
    get overridesLineCode() { return undefined !== this.lineCode; }
    get overridesWeight() { return undefined !== this.weight; }
    get overridesAlpha() { return this.forceOpaque; }
    get anyOverridden() { return this.overridesColor || this.overridesLineCode || this.overridesWeight || this.overridesAlpha; }
    computeOvrFlags() {
        let flags = 0 /* None */;
        if (this.overridesColor)
            flags |= 6 /* Rgba */;
        if (this.overridesWeight)
            flags |= 8 /* Weight */;
        if (this.overridesLineCode)
            flags |= 64 /* LineCode */;
        if (this.overridesAlpha)
            flags |= 4 /* Alpha */;
        return flags;
    }
    init(forceOpaque, style) {
        this._forceOpaque = forceOpaque;
        if (undefined === style) {
            this._color = undefined;
            this._weight = undefined;
            this._lineCode = undefined;
        }
        else {
            this._color = undefined !== style.color ? FloatRGBA_1.FloatPreMulRgba.fromColorDef(style.color) : undefined;
            this._weight = style.width;
            this._lineCode = undefined !== style.pattern ? LineCode.valueFromLinePixels(style.pattern) : undefined;
        }
    }
}
exports.EdgeOverrides = EdgeOverrides;


/***/ }),

/***/ "./lib/render/webgl/FeatureDimensions.js":
/*!***********************************************!*\
  !*** ./lib/render/webgl/FeatureDimensions.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
class LUTParams {
    constructor(width, height) { this.width = width; this.height = height; }
}
exports.LUTParams = LUTParams;
/** Describes the dimensions of a texture used as a look-up table
 * @internal
 */
class LUTDimensions {
    constructor(nEntries, nRgbaPerEntry, nExtraRgba = 0, nTables = 1) {
        const dims = LUTDimensions.computeWidthAndHeight(nEntries, nRgbaPerEntry, nExtraRgba, nTables);
        this.width = dims.width;
        this.height = dims.height;
    }
    static computeWidthAndHeight(nEntries, nRgbaPerEntry, nExtraRgba = 0, nTables = 1) {
        const maxSize = System_1.System.instance.capabilities.maxTextureSize;
        const nRgba = nEntries * nRgbaPerEntry * nTables + nExtraRgba;
        if (nRgba < maxSize)
            return { width: nRgba, height: 1 };
        // Make roughly square to reduce unused space in last row
        let width = Math.ceil(Math.sqrt(nRgba));
        // Ensure a given entry's RGBA values all fit on the same row.
        const remainder = width % nRgbaPerEntry;
        if (0 !== remainder) {
            width += nRgbaPerEntry - remainder;
        }
        // Compute height
        const height = Math.ceil(nRgba / width);
        bentleyjs_core_1.assert(height <= maxSize);
        bentleyjs_core_1.assert(width <= maxSize);
        bentleyjs_core_1.assert(width * height >= nRgba);
        bentleyjs_core_1.assert(Math.floor(height) === height);
        bentleyjs_core_1.assert(Math.floor(width) === width);
        // Row padding should never be necessary...
        bentleyjs_core_1.assert(0 === width % nRgbaPerEntry);
        return { width, height };
    }
}
exports.LUTDimensions = LUTDimensions;
/** @internal */
function getFeatureName(dim) {
    switch (dim) {
        case 0 /* Empty */: return "Empty";
        case 1 /* SingleUniform */: return "Single/Uniform";
        case 2 /* SingleNonUniform */: return "Single/Non-uniform";
        case 3 /* Multiple */: return "Multiple";
        default:
            bentleyjs_core_1.assert(false);
            return "Invalid";
    }
}
exports.getFeatureName = getFeatureName;
/** @internal */
function computeFeatureDimension(dim, type) {
    switch (type) {
        case imodeljs_common_1.FeatureIndexType.Empty:
            return 0 /* Empty */;
        case imodeljs_common_1.FeatureIndexType.NonUniform:
            bentleyjs_core_1.assert(0 /* Uniform */ !== dim);
            return 3 /* Multiple */;
        default:
            return 0 /* Uniform */ === dim ? 1 /* SingleUniform */ : 2 /* SingleNonUniform */;
    }
}
exports.computeFeatureDimension = computeFeatureDimension;


/***/ }),

/***/ "./lib/render/webgl/FeaturesInfo.js":
/*!******************************************!*\
  !*** ./lib/render/webgl/FeaturesInfo.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
class FeaturesInfo {
    constructor(uniform) { this.uniform = uniform; }
    static create(featureIndex) {
        switch (featureIndex.type) {
            case imodeljs_common_1.FeatureIndexType.Empty: return undefined;
            case imodeljs_common_1.FeatureIndexType.Uniform: return new FeaturesInfo(featureIndex.featureID);
            default: return FeaturesInfo._nonUniform;
        }
    }
    static createUniform(id) { return new FeaturesInfo(id); }
    static createFromVertexTable(vt) {
        switch (vt.featureIndexType) {
            case imodeljs_common_1.FeatureIndexType.Empty: return undefined;
            case imodeljs_common_1.FeatureIndexType.NonUniform: return FeaturesInfo._nonUniform;
            default:
                bentleyjs_core_1.assert(undefined !== vt.uniformFeatureID);
                return new FeaturesInfo(vt.uniformFeatureID);
        }
    }
    static createFromFeatureIds(ids) {
        if (undefined === ids || 0 === ids.length)
            return undefined;
        bentleyjs_core_1.assert(0 === ids.length % 3);
        const nFeatures = ids.length / 3;
        for (let i = 1; i < nFeatures; i++) {
            const index = i * 3;
            if (ids[index + 0] !== ids[0] || ids[index + 1] !== ids[1] || ids[index + 2] !== ids[2])
                return FeaturesInfo._nonUniform;
        }
        const uniform = ids[0] | (ids[1] << 8) | (ids[2] << 16);
        return FeaturesInfo.createUniform(uniform);
    }
    get type() { return undefined !== this.uniform ? imodeljs_common_1.FeatureIndexType.Uniform : imodeljs_common_1.FeatureIndexType.NonUniform; }
    get isUniform() { return imodeljs_common_1.FeatureIndexType.Uniform === this.type; }
    get isNonUniform() { return !this.isUniform; }
}
FeaturesInfo._nonUniform = new FeaturesInfo(undefined);
exports.FeaturesInfo = FeaturesInfo;


/***/ }),

/***/ "./lib/render/webgl/FloatRGBA.js":
/*!***************************************!*\
  !*** ./lib/render/webgl/FloatRGBA.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
function assertComponent(c) { bentleyjs_core_1.assert(1.0 >= c && 0.0 <= c); }
function assertRgb(rgb) {
    assertComponent(rgb.red);
    assertComponent(rgb.green);
    assertComponent(rgb.blue);
}
function assertRgba(rgba) {
    assertComponent(rgba.red);
    assertComponent(rgba.green);
    assertComponent(rgba.blue);
    assertComponent(rgba.alpha);
}
/**
 * An RGB color with components in the range [0, 1].
 * @internal
 */
class FloatRgb {
    constructor() {
        this._value = new Float32Array(3);
    }
    /** Set from red, green, and blue components, or colorDefValue. */
    setValues(red, green, blue, colorDefValue) {
        this._value[0] = red;
        this._value[1] = green;
        this._value[2] = blue;
        this._colorDefValue = colorDefValue;
        assertRgb(this);
    }
    setFromColorDef(def) {
        if (this._colorDefValue === def.tbgr)
            return;
        const c = def.colors;
        this.setValues(c.r / 255.0, c.g / 255.0, c.b / 255.0, def.tbgr);
    }
    /** Create a FloatRgb using a ColorDef. */
    static fromColorDef(def) {
        const rgb = new FloatRgb();
        rgb.setFromColorDef(def);
        return rgb;
    }
    get red() { return this._value[0]; }
    get green() { return this._value[1]; }
    get blue() { return this._value[2]; }
    get colorDefValue() { return this._colorDefValue; }
    bind(uniform) { uniform.setUniform3fv(this._value); }
}
exports.FloatRgb = FloatRgb;
/** @internal */
class Rgba {
    constructor() {
        this._value = new Float32Array(4);
    }
    setValues(r, g, b, a, colorDefValue) {
        this._value[0] = r;
        this._value[1] = g;
        this._value[2] = b;
        this._value[3] = a;
        this._colorDefValue = colorDefValue;
        assertRgba(this);
    }
    get red() { return this._value[0]; }
    get green() { return this._value[1]; }
    get blue() { return this._value[2]; }
    get alpha() { return this._value[3]; }
    get colorDefValue() { return this._colorDefValue; }
    get hasTranslucency() { return 1.0 !== this.alpha; }
    equals(rhs) {
        return this.colorDefValue === rhs.colorDefValue || (this.red === rhs.red && this.green === rhs.green && this.blue === rhs.blue && this.alpha === rhs.alpha);
    }
    get isWhite() {
        return this.red === 1.0 && this.green === 1.0 && this.blue === 1.0;
    }
    bind(uniform) { uniform.setUniform4fv(this._value); }
}
exports.Rgba = Rgba;
/** @internal */
class FloatRgba extends Rgba {
    setFromColorDef(def, transparency) {
        const c = def.colors;
        if (undefined !== transparency) {
            c.t = transparency;
            def = imodeljs_common_1.ColorDef.from(c.r, c.g, c.b, c.t);
        }
        if (this._colorDefValue === def.tbgr)
            return;
        this.setValues(c.r / 255.0, c.g / 255.0, c.b / 255.0, (255.0 - c.t) / 255.0, def.tbgr);
    }
    setFromFloatRgba(rgba) {
        this.setValues(rgba.red, rgba.green, rgba.blue, rgba.alpha, rgba.colorDefValue);
    }
    /** Create a FloatRgba using a ColorDef. */
    static fromColorDef(def, transparency) {
        const rgba = new FloatRgba();
        rgba.setFromColorDef(def, transparency);
        return rgba;
    }
}
exports.FloatRgba = FloatRgba;
/**
 * An RGBA color with components in the range [0, 1], wherein the red, green, and blue components are pre-multiplied by the alpha component.
 * @internal
 */
class FloatPreMulRgba extends Rgba {
    /** Set a FloatPreMulRgba using a ColorDef (premultiplied by alpha).
     * @param def A ColorDef used to create a new FloatPreMulRgba.
     */
    setFromColorDef(def) {
        if (this._colorDefValue === def.tbgr)
            return;
        const c = def.colors;
        const a = (255.0 - c.t) / 255.0;
        this.setValues(c.r * a / 255.0, c.g * a / 255.0, c.b * a / 255.0, a, def.tbgr);
    }
    /** Create a FloatPreMulRgba using a ColorDef. */
    static fromColorDef(def) {
        const rgba = new FloatPreMulRgba();
        rgba.setFromColorDef(def);
        return rgba;
    }
}
exports.FloatPreMulRgba = FloatPreMulRgba;
/**
 * A mutable implementation of a FloatRgb for internal use where changing of values is desirable without requiring allocating a new instance.
 * @internal
 */
class MutableFloatRgb extends FloatRgb {
    setRgbValues(red, green, blue) {
        this.setValues(red, green, blue);
    }
    static fromColorDef(def) {
        const rgb = new MutableFloatRgb();
        rgb.setFromColorDef(def);
        return rgb;
    }
}
exports.MutableFloatRgb = MutableFloatRgb;
/**
 * A mutable implementation of a FloatRgba for internal use where changing of values is desirable without requiring allocating a new instance.
 * @internal
 */
class MutableFloatRgba extends FloatRgba {
    setRgbaValues(red, green, blue, alpha) {
        this.setValues(red, green, blue, alpha);
    }
    static fromColorDef(def) {
        const rgb = new MutableFloatRgba();
        rgb.setFromColorDef(def);
        return rgb;
    }
}
exports.MutableFloatRgba = MutableFloatRgba;


/***/ }),

/***/ "./lib/render/webgl/FrameBuffer.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/FrameBuffer.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const RenderBuffer_1 = __webpack_require__(/*! ./RenderBuffer */ "./lib/render/webgl/RenderBuffer.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
/** @internal */
class FrameBuffer {
    constructor(fbo, colorTextures, depthBuffer) {
        this._bindState = 0 /* Unbound */;
        this._colorTextures = [];
        this._colorAttachments = [];
        this._fbo = fbo;
        const gl = System_1.System.instance.context;
        this.bind(false);
        let i = 0;
        for (const colTex of colorTextures) {
            const attachmentEnum = gl.COLOR_ATTACHMENT0 + i;
            this._colorAttachments.push(attachmentEnum);
            this._colorTextures.push(colTex);
            const texHandle = colTex.getHandle();
            if (undefined !== texHandle)
                gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentEnum, gl.TEXTURE_2D, texHandle, 0);
            i++;
        }
        if (depthBuffer !== undefined) {
            this.depthBuffer = depthBuffer;
            const dbHandle = depthBuffer.getHandle();
            if (undefined !== dbHandle) {
                if (depthBuffer instanceof RenderBuffer_1.RenderBuffer) {
                    gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, dbHandle);
                }
                else {
                    // Looks like we only get a 24 bit depth buffer anyway, so use a 24-8 with a stencil.
                    // gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, dbHandle, 0);
                    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, dbHandle, 0);
                }
            }
        }
        this.unbind();
    }
    get isDisposed() { return this._fbo === undefined; }
    get isBound() { return 1 /* Bound */ === this._bindState || 2 /* BoundWithAttachments */ === this._bindState; }
    get isSuspended() { return 3 /* Suspended */ === this._bindState; }
    getColor(ndx) {
        bentleyjs_core_1.assert(ndx < this._colorTextures.length);
        return this._colorTextures[ndx];
    }
    static create(colorTextures, depthBuffer) {
        const fbo = System_1.System.instance.context.createFramebuffer();
        if (null === fbo) {
            return undefined;
        }
        return new FrameBuffer(fbo, colorTextures, depthBuffer);
    }
    dispose() {
        // NB: The FrameBuffer does not *own* the textures and depth buffer.
        if (!this.isDisposed) {
            System_1.System.instance.context.deleteFramebuffer(this._fbo);
            this._fbo = undefined;
        }
    }
    bind(bindAttachments = false) {
        bentleyjs_core_1.assert(undefined !== this._fbo);
        bentleyjs_core_1.assert(!this.isBound);
        if (undefined === this._fbo)
            return false;
        const gl = System_1.System.instance.context;
        gl.bindFramebuffer(GL_1.GL.FrameBuffer.TARGET, this._fbo);
        if (bindAttachments) {
            System_1.System.instance.setDrawBuffers(this._colorAttachments);
            this._bindState = 2 /* BoundWithAttachments */;
        }
        else {
            this._bindState = 1 /* Bound */;
        }
        return true;
    }
    unbind() {
        bentleyjs_core_1.assert(this.isBound);
        System_1.System.instance.context.bindFramebuffer(GL_1.GL.FrameBuffer.TARGET, null);
        this._bindState = 0 /* Unbound */;
    }
    suspend() { bentleyjs_core_1.assert(this.isBound); this._bindState = 3 /* Suspended */; }
    // Chiefly for debugging currently - assumes RGBA, unsigned byte, want all pixels.
    get debugPixels() {
        if (!this.isBound || 0 === this._colorTextures.length)
            return undefined;
        const tex = this._colorTextures[0];
        if (GL_1.GL.Texture.Format.Rgba !== tex.format || GL_1.GL.Texture.DataType.UnsignedByte !== tex.dataType)
            return undefined;
        const buffer = new Uint8Array(tex.width * tex.height * 4);
        for (let i = 0; i < buffer.length; i += 4) {
            buffer[i] = 0xba;
            buffer[i + 1] = 0xad;
            buffer[i + 2] = 0xf0;
            buffer[i + 3] = 0x0d;
        }
        System_1.System.instance.context.readPixels(0, 0, tex.width, tex.height, tex.format, tex.dataType, buffer);
        return buffer;
    }
}
exports.FrameBuffer = FrameBuffer;
/** @internal */
class FrameBufferStack {
    constructor() {
        // FrameBuffers within this array are not owned, as this is only a storage device holding references
        this._stack = [];
    }
    get _top() { return !this.isEmpty ? this._stack[this._stack.length - 1] : undefined; }
    push(fbo, withAttachments) {
        if (undefined !== this._top) {
            this._top.fbo.suspend();
        }
        bentleyjs_core_1.assert(!fbo.isBound);
        fbo.bind(withAttachments);
        bentleyjs_core_1.assert(fbo.isBound);
        this._stack.push({ fbo, withAttachments });
    }
    pop() {
        bentleyjs_core_1.assert(!this.isEmpty);
        if (undefined === this._top) {
            return;
        }
        const fbo = this._top.fbo;
        this._stack.pop();
        bentleyjs_core_1.assert(fbo.isBound);
        fbo.unbind();
        bentleyjs_core_1.assert(!fbo.isBound);
        if (this.isEmpty) {
            System_1.System.instance.context.bindFramebuffer(GL_1.GL.FrameBuffer.TARGET, null);
        }
        else {
            const top = this._top;
            bentleyjs_core_1.assert(top.fbo.isSuspended);
            top.fbo.bind(top.withAttachments);
            bentleyjs_core_1.assert(top.fbo.isBound);
        }
    }
    get currentColorBuffer() {
        bentleyjs_core_1.assert(!this.isEmpty);
        return undefined !== this._top ? this._top.fbo.getColor(0) : undefined;
    }
    get isEmpty() { return 0 === this._stack.length; }
    execute(fbo, withAttachments, func) {
        this.push(fbo, withAttachments);
        func();
        this.pop();
    }
}
exports.FrameBufferStack = FrameBufferStack;


/***/ }),

/***/ "./lib/render/webgl/GL.js":
/*!********************************!*\
  !*** ./lib/render/webgl/GL.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
if (typeof (WebGLRenderingContext) === "undefined") {
    global.WebGLRenderingContext = new Proxy({}, { get: () => 0 });
}
/** @internal */
var GL;
(function (GL) {
    let BlendEquation;
    (function (BlendEquation) {
        BlendEquation[BlendEquation["Add"] = WebGLRenderingContext.FUNC_ADD] = "Add";
        BlendEquation[BlendEquation["Subtract"] = WebGLRenderingContext.FUNC_SUBTRACT] = "Subtract";
        BlendEquation[BlendEquation["ReverseSubtract"] = WebGLRenderingContext.FUNC_REVERSE_SUBTRACT] = "ReverseSubtract";
        BlendEquation[BlendEquation["Default"] = BlendEquation.Add] = "Default";
    })(BlendEquation = GL.BlendEquation || (GL.BlendEquation = {}));
    let BlendFactor;
    (function (BlendFactor) {
        BlendFactor[BlendFactor["Zero"] = WebGLRenderingContext.ZERO] = "Zero";
        BlendFactor[BlendFactor["One"] = WebGLRenderingContext.ONE] = "One";
        BlendFactor[BlendFactor["SrcColor"] = WebGLRenderingContext.SRC_COLOR] = "SrcColor";
        BlendFactor[BlendFactor["OneMinusSrcColor"] = WebGLRenderingContext.ONE_MINUS_SRC_COLOR] = "OneMinusSrcColor";
        BlendFactor[BlendFactor["DstColor"] = WebGLRenderingContext.DST_COLOR] = "DstColor";
        BlendFactor[BlendFactor["OneMinusDstColor"] = WebGLRenderingContext.ONE_MINUS_DST_COLOR] = "OneMinusDstColor";
        BlendFactor[BlendFactor["SrcAlpha"] = WebGLRenderingContext.SRC_ALPHA] = "SrcAlpha";
        BlendFactor[BlendFactor["OneMinusSrcAlpha"] = WebGLRenderingContext.ONE_MINUS_SRC_ALPHA] = "OneMinusSrcAlpha";
        BlendFactor[BlendFactor["DstAlpha"] = WebGLRenderingContext.DST_ALPHA] = "DstAlpha";
        BlendFactor[BlendFactor["OneMinusDstAlpha"] = WebGLRenderingContext.ONE_MINUS_DST_ALPHA] = "OneMinusDstAlpha";
        BlendFactor[BlendFactor["ConstColor"] = WebGLRenderingContext.CONSTANT_COLOR] = "ConstColor";
        BlendFactor[BlendFactor["OneMinusConstColor"] = WebGLRenderingContext.ONE_MINUS_CONSTANT_COLOR] = "OneMinusConstColor";
        BlendFactor[BlendFactor["ConstAlpha"] = WebGLRenderingContext.CONSTANT_ALPHA] = "ConstAlpha";
        BlendFactor[BlendFactor["OneMinusConstAlpha"] = WebGLRenderingContext.ONE_MINUS_CONSTANT_ALPHA] = "OneMinusConstAlpha";
        BlendFactor[BlendFactor["AlphaSaturate"] = WebGLRenderingContext.SRC_ALPHA_SATURATE] = "AlphaSaturate";
        BlendFactor[BlendFactor["DefaultSrc"] = BlendFactor.One] = "DefaultSrc";
        BlendFactor[BlendFactor["DefaultDst"] = BlendFactor.Zero] = "DefaultDst";
    })(BlendFactor = GL.BlendFactor || (GL.BlendFactor = {}));
    let Buffer;
    (function (Buffer) {
        let Target;
        (function (Target) {
            Target[Target["ArrayBuffer"] = WebGLRenderingContext.ARRAY_BUFFER] = "ArrayBuffer";
            Target[Target["ElementArrayBuffer"] = WebGLRenderingContext.ELEMENT_ARRAY_BUFFER] = "ElementArrayBuffer";
        })(Target = Buffer.Target || (Buffer.Target = {}));
        let Binding;
        (function (Binding) {
            Binding[Binding["ArrayBuffer"] = WebGLRenderingContext.ARRAY_BUFFER_BINDING] = "ArrayBuffer";
            Binding[Binding["ElementArrayBuffer"] = WebGLRenderingContext.ELEMENT_ARRAY_BUFFER_BINDING] = "ElementArrayBuffer";
        })(Binding = Buffer.Binding || (Buffer.Binding = {}));
        let Parameter;
        (function (Parameter) {
            Parameter[Parameter["Size"] = WebGLRenderingContext.BUFFER_SIZE] = "Size";
            Parameter[Parameter["Usage"] = WebGLRenderingContext.BUFFER_USAGE] = "Usage";
        })(Parameter = Buffer.Parameter || (Buffer.Parameter = {}));
        let Usage;
        (function (Usage) {
            Usage[Usage["DynamicDraw"] = WebGLRenderingContext.DYNAMIC_DRAW] = "DynamicDraw";
            Usage[Usage["StaticDraw"] = WebGLRenderingContext.STATIC_DRAW] = "StaticDraw";
            Usage[Usage["StreamDraw"] = WebGLRenderingContext.STREAM_DRAW] = "StreamDraw";
        })(Usage = Buffer.Usage || (Buffer.Usage = {}));
    })(Buffer = GL.Buffer || (GL.Buffer = {}));
    let StencilOperation;
    (function (StencilOperation) {
        StencilOperation[StencilOperation["Keep"] = WebGLRenderingContext.KEEP] = "Keep";
        StencilOperation[StencilOperation["Zero"] = WebGLRenderingContext.ZERO] = "Zero";
        StencilOperation[StencilOperation["Replace"] = WebGLRenderingContext.REPLACE] = "Replace";
        StencilOperation[StencilOperation["Incr"] = WebGLRenderingContext.INCR] = "Incr";
        StencilOperation[StencilOperation["IncrWrap"] = WebGLRenderingContext.INCR_WRAP] = "IncrWrap";
        StencilOperation[StencilOperation["Decr"] = WebGLRenderingContext.DECR] = "Decr";
        StencilOperation[StencilOperation["DecrWrap"] = WebGLRenderingContext.DECR_WRAP] = "DecrWrap";
        StencilOperation[StencilOperation["Invert"] = WebGLRenderingContext.INVERT] = "Invert";
        StencilOperation[StencilOperation["Default"] = StencilOperation.Keep] = "Default";
    })(StencilOperation = GL.StencilOperation || (GL.StencilOperation = {}));
    let StencilFunction;
    (function (StencilFunction) {
        StencilFunction[StencilFunction["Never"] = WebGLRenderingContext.NEVER] = "Never";
        StencilFunction[StencilFunction["Less"] = WebGLRenderingContext.LESS] = "Less";
        StencilFunction[StencilFunction["LEqual"] = WebGLRenderingContext.LEQUAL] = "LEqual";
        StencilFunction[StencilFunction["Greater"] = WebGLRenderingContext.GREATER] = "Greater";
        StencilFunction[StencilFunction["GEqual"] = WebGLRenderingContext.GEQUAL] = "GEqual";
        StencilFunction[StencilFunction["Equal"] = WebGLRenderingContext.EQUAL] = "Equal";
        StencilFunction[StencilFunction["NotEqual"] = WebGLRenderingContext.NOTEQUAL] = "NotEqual";
        StencilFunction[StencilFunction["Always"] = WebGLRenderingContext.ALWAYS] = "Always";
        StencilFunction[StencilFunction["Default"] = StencilFunction.Always] = "Default";
    })(StencilFunction = GL.StencilFunction || (GL.StencilFunction = {}));
    let CullFace;
    (function (CullFace) {
        CullFace[CullFace["Front"] = WebGLRenderingContext.FRONT] = "Front";
        CullFace[CullFace["Back"] = WebGLRenderingContext.BACK] = "Back";
        CullFace[CullFace["FrontAndBack"] = WebGLRenderingContext.FRONT_AND_BACK] = "FrontAndBack";
        CullFace[CullFace["Default"] = CullFace.Back] = "Default";
    })(CullFace = GL.CullFace || (GL.CullFace = {}));
    let DataType;
    (function (DataType) {
        DataType[DataType["Byte"] = WebGLRenderingContext.BYTE] = "Byte";
        DataType[DataType["Short"] = WebGLRenderingContext.SHORT] = "Short";
        DataType[DataType["UnsignedByte"] = WebGLRenderingContext.UNSIGNED_BYTE] = "UnsignedByte";
        DataType[DataType["UnsignedShort"] = WebGLRenderingContext.UNSIGNED_SHORT] = "UnsignedShort";
        DataType[DataType["UnsignedInt"] = WebGLRenderingContext.UNSIGNED_INT] = "UnsignedInt";
        DataType[DataType["Float"] = WebGLRenderingContext.FLOAT] = "Float";
        // WebGL 2 has more data types
        // HalfFloat = WebGLRenderingContext.HALF_FLOAT,
    })(DataType = GL.DataType || (GL.DataType = {}));
    let FrontFace;
    (function (FrontFace) {
        FrontFace[FrontFace["CounterClockwise"] = WebGLRenderingContext.CCW] = "CounterClockwise";
        FrontFace[FrontFace["Clockwise"] = WebGLRenderingContext.CW] = "Clockwise";
        FrontFace[FrontFace["Default"] = FrontFace.CounterClockwise] = "Default";
    })(FrontFace = GL.FrontFace || (GL.FrontFace = {}));
    let DepthFunc;
    (function (DepthFunc) {
        DepthFunc[DepthFunc["Never"] = WebGLRenderingContext.NEVER] = "Never";
        DepthFunc[DepthFunc["Less"] = WebGLRenderingContext.LESS] = "Less";
        DepthFunc[DepthFunc["Equal"] = WebGLRenderingContext.EQUAL] = "Equal";
        DepthFunc[DepthFunc["LessOrEqual"] = WebGLRenderingContext.LEQUAL] = "LessOrEqual";
        DepthFunc[DepthFunc["Greater"] = WebGLRenderingContext.GREATER] = "Greater";
        DepthFunc[DepthFunc["NotEqual"] = WebGLRenderingContext.NOTEQUAL] = "NotEqual";
        DepthFunc[DepthFunc["GreaterOrEqual"] = WebGLRenderingContext.GEQUAL] = "GreaterOrEqual";
        DepthFunc[DepthFunc["Always"] = WebGLRenderingContext.ALWAYS] = "Always";
        DepthFunc[DepthFunc["Default"] = DepthFunc.LessOrEqual] = "Default";
    })(DepthFunc = GL.DepthFunc || (GL.DepthFunc = {}));
    let Capability;
    (function (Capability) {
        Capability[Capability["Blend"] = WebGLRenderingContext.BLEND] = "Blend";
        Capability[Capability["BlendColor"] = WebGLRenderingContext.BLEND_COLOR] = "BlendColor";
        Capability[Capability["BlendEquationAlpha"] = WebGLRenderingContext.BLEND_EQUATION_ALPHA] = "BlendEquationAlpha";
        Capability[Capability["BlendEquationRGB"] = WebGLRenderingContext.BLEND_EQUATION_RGB] = "BlendEquationRGB";
        Capability[Capability["BlendSrcAlpha"] = WebGLRenderingContext.BLEND_SRC_ALPHA] = "BlendSrcAlpha";
        Capability[Capability["BlendSrcRgb"] = WebGLRenderingContext.BLEND_SRC_RGB] = "BlendSrcRgb";
        Capability[Capability["BlendDstAlpha"] = WebGLRenderingContext.BLEND_DST_ALPHA] = "BlendDstAlpha";
        Capability[Capability["BlendDstRgb"] = WebGLRenderingContext.BLEND_DST_RGB] = "BlendDstRgb";
        Capability[Capability["CullFace"] = WebGLRenderingContext.CULL_FACE] = "CullFace";
        Capability[Capability["CullFaceMode"] = WebGLRenderingContext.CULL_FACE_MODE] = "CullFaceMode";
        Capability[Capability["DepthFunc"] = WebGLRenderingContext.DEPTH_FUNC] = "DepthFunc";
        Capability[Capability["DepthTest"] = WebGLRenderingContext.DEPTH_TEST] = "DepthTest";
        Capability[Capability["DepthWriteMask"] = WebGLRenderingContext.DEPTH_WRITEMASK] = "DepthWriteMask";
        Capability[Capability["FrontFace"] = WebGLRenderingContext.FRONT_FACE] = "FrontFace";
        Capability[Capability["StencilFrontFunc"] = WebGLRenderingContext.STENCIL_FUNC] = "StencilFrontFunc";
        Capability[Capability["StencilFrontRef"] = WebGLRenderingContext.STENCIL_REF] = "StencilFrontRef";
        Capability[Capability["StencilFrontValueMask"] = WebGLRenderingContext.STENCIL_VALUE_MASK] = "StencilFrontValueMask";
        Capability[Capability["StencilFrontWriteMask"] = WebGLRenderingContext.STENCIL_WRITEMASK] = "StencilFrontWriteMask";
        Capability[Capability["StencilFrontOpFail"] = WebGLRenderingContext.STENCIL_FAIL] = "StencilFrontOpFail";
        Capability[Capability["StencilFrontOpZFail"] = WebGLRenderingContext.STENCIL_PASS_DEPTH_FAIL] = "StencilFrontOpZFail";
        Capability[Capability["StencilFrontOpZPass"] = WebGLRenderingContext.STENCIL_PASS_DEPTH_PASS] = "StencilFrontOpZPass";
        Capability[Capability["StencilBackFunc"] = WebGLRenderingContext.STENCIL_BACK_FUNC] = "StencilBackFunc";
        Capability[Capability["StencilBackRef"] = WebGLRenderingContext.STENCIL_BACK_REF] = "StencilBackRef";
        Capability[Capability["StencilBackValueMask"] = WebGLRenderingContext.STENCIL_BACK_VALUE_MASK] = "StencilBackValueMask";
        Capability[Capability["StencilBackWriteMask"] = WebGLRenderingContext.STENCIL_BACK_WRITEMASK] = "StencilBackWriteMask";
        Capability[Capability["StencilBackOpFail"] = WebGLRenderingContext.STENCIL_BACK_FAIL] = "StencilBackOpFail";
        Capability[Capability["StencilBackOpZFail"] = WebGLRenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL] = "StencilBackOpZFail";
        Capability[Capability["StencilBackOpZPass"] = WebGLRenderingContext.STENCIL_BACK_PASS_DEPTH_PASS] = "StencilBackOpZPass";
        Capability[Capability["StencilTest"] = WebGLRenderingContext.STENCIL_TEST] = "StencilTest";
        Capability[Capability["StencilWriteMask"] = WebGLRenderingContext.STENCIL_WRITEMASK] = "StencilWriteMask";
    })(Capability = GL.Capability || (GL.Capability = {}));
    let Texture;
    (function (Texture) {
        let Target;
        (function (Target) {
            Target[Target["TwoDee"] = WebGLRenderingContext.TEXTURE_2D] = "TwoDee";
            Target[Target["CubeMap"] = WebGLRenderingContext.TEXTURE_CUBE_MAP] = "CubeMap";
            Target[Target["CubeMapPositiveX"] = WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X] = "CubeMapPositiveX";
            Target[Target["CubeMapNegativeX"] = WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X] = "CubeMapNegativeX";
            Target[Target["CubeMapPositiveY"] = WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y] = "CubeMapPositiveY";
            Target[Target["CubeMapNegativeY"] = WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y] = "CubeMapNegativeY";
            Target[Target["CubeMapPositiveZ"] = WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z] = "CubeMapPositiveZ";
            Target[Target["CubeMapNegativeZ"] = WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z] = "CubeMapNegativeZ";
        })(Target = Texture.Target || (Texture.Target = {}));
        let Format;
        (function (Format) {
            Format[Format["Rgb"] = WebGLRenderingContext.RGB] = "Rgb";
            Format[Format["Rgba"] = WebGLRenderingContext.RGBA] = "Rgba";
            Format[Format["DepthStencil"] = WebGLRenderingContext.DEPTH_STENCIL] = "DepthStencil";
            Format[Format["Luminance"] = WebGLRenderingContext.LUMINANCE] = "Luminance";
            Format[Format["DepthComponent"] = WebGLRenderingContext.DEPTH_COMPONENT] = "DepthComponent";
        })(Format = Texture.Format || (Texture.Format = {}));
        // This name is unambiguous as it is qualified by the namespace...https://github.com/palantir/tslint/issues/3789
        let DataType;
        (function (DataType) {
            DataType[DataType["Float"] = WebGLRenderingContext.FLOAT] = "Float";
            DataType[DataType["UnsignedByte"] = WebGLRenderingContext.UNSIGNED_BYTE] = "UnsignedByte";
            //    UnsignedInt24_8 = WebGLRenderingContext.UNSIGNED_INT_24_8,
            DataType[DataType["UnsignedInt"] = WebGLRenderingContext.UNSIGNED_INT] = "UnsignedInt";
        })(DataType = Texture.DataType || (Texture.DataType = {}));
        let WrapMode;
        (function (WrapMode) {
            WrapMode[WrapMode["Repeat"] = WebGLRenderingContext.REPEAT] = "Repeat";
            WrapMode[WrapMode["MirroredRepeat"] = WebGLRenderingContext.MIRRORED_REPEAT] = "MirroredRepeat";
            WrapMode[WrapMode["ClampToEdge"] = WebGLRenderingContext.CLAMP_TO_EDGE] = "ClampToEdge";
        })(WrapMode = Texture.WrapMode || (Texture.WrapMode = {}));
    })(Texture = GL.Texture || (GL.Texture = {}));
    let ShaderType;
    (function (ShaderType) {
        ShaderType[ShaderType["Fragment"] = WebGLRenderingContext.FRAGMENT_SHADER] = "Fragment";
        ShaderType[ShaderType["Vertex"] = WebGLRenderingContext.VERTEX_SHADER] = "Vertex";
    })(ShaderType = GL.ShaderType || (GL.ShaderType = {}));
    let ShaderParameter;
    (function (ShaderParameter) {
        ShaderParameter[ShaderParameter["CompileStatus"] = WebGLRenderingContext.COMPILE_STATUS] = "CompileStatus";
    })(ShaderParameter = GL.ShaderParameter || (GL.ShaderParameter = {}));
    let ProgramParameter;
    (function (ProgramParameter) {
        ProgramParameter[ProgramParameter["LinkStatus"] = WebGLRenderingContext.LINK_STATUS] = "LinkStatus";
    })(ProgramParameter = GL.ProgramParameter || (GL.ProgramParameter = {}));
    let PrimitiveType;
    (function (PrimitiveType) {
        PrimitiveType[PrimitiveType["Points"] = WebGLRenderingContext.POINTS] = "Points";
        PrimitiveType[PrimitiveType["Lines"] = WebGLRenderingContext.LINES] = "Lines";
        PrimitiveType[PrimitiveType["Triangles"] = WebGLRenderingContext.TRIANGLES] = "Triangles";
    })(PrimitiveType = GL.PrimitiveType || (GL.PrimitiveType = {}));
    let RenderBuffer;
    (function (RenderBuffer) {
        RenderBuffer.TARGET = WebGLRenderingContext.RENDERBUFFER;
        let Format;
        (function (Format) {
            Format[Format["DepthComponent16"] = WebGLRenderingContext.DEPTH_COMPONENT16] = "DepthComponent16";
            // Currently this is the only supported format
        })(Format = RenderBuffer.Format || (RenderBuffer.Format = {}));
    })(RenderBuffer = GL.RenderBuffer || (GL.RenderBuffer = {}));
    let FrameBuffer;
    (function (FrameBuffer) {
        FrameBuffer.TARGET = WebGLRenderingContext.FRAMEBUFFER;
        let Status;
        (function (Status) {
            Status[Status["Complete"] = WebGLRenderingContext.FRAMEBUFFER_COMPLETE] = "Complete";
            Status[Status["IncompleteAttachment"] = WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT] = "IncompleteAttachment";
            Status[Status["IncompleteMissingAttachment"] = WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT] = "IncompleteMissingAttachment";
            Status[Status["IncompleteDimensions"] = WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS] = "IncompleteDimensions";
            Status[Status["Unsupported"] = WebGLRenderingContext.FRAMEBUFFER_UNSUPPORTED] = "Unsupported";
        })(Status = FrameBuffer.Status || (FrameBuffer.Status = {}));
    })(FrameBuffer = GL.FrameBuffer || (GL.FrameBuffer = {}));
    let BufferBit;
    (function (BufferBit) {
        BufferBit[BufferBit["Color"] = WebGLRenderingContext.COLOR_BUFFER_BIT] = "Color";
        BufferBit[BufferBit["Depth"] = WebGLRenderingContext.DEPTH_BUFFER_BIT] = "Depth";
        BufferBit[BufferBit["Stencil"] = WebGLRenderingContext.STENCIL_BUFFER_BIT] = "Stencil";
    })(BufferBit = GL.BufferBit || (GL.BufferBit = {}));
    GL.POLYGON_OFFSET_FILL = WebGLRenderingContext.POLYGON_OFFSET_FILL;
})(GL = exports.GL || (exports.GL = {}));

/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(/*! ./../../../../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js */ "../../common/temp/node_modules/.registry.npmjs.org/webpack/4.32.2/node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./lib/render/webgl/Graphic.js":
/*!*************************************!*\
  !*** ./lib/render/webgl/Graphic.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/System.js");
const FeatureSymbology_1 = __webpack_require__(/*! ../FeatureSymbology */ "./lib/render/FeatureSymbology.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
const FeatureDimensions_1 = __webpack_require__(/*! ./FeatureDimensions */ "./lib/render/webgl/FeatureDimensions.js");
const EdgeOverrides_1 = __webpack_require__(/*! ./EdgeOverrides */ "./lib/render/webgl/EdgeOverrides.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
function isFeatureHilited(feature, hilites) {
    if (hilites.isEmpty)
        return false;
    return hilites.elements.has(feature.elementId.lower, feature.elementId.upper) ||
        hilites.subcategories.has(feature.subCategoryId.lower, feature.subCategoryId.upper);
}
/** @internal */
class FeatureOverrides {
    constructor(target) {
        this._lastOverridesUpdated = bentleyjs_core_1.BeTimePoint.now();
        this._lastFlashUpdated = bentleyjs_core_1.BeTimePoint.now();
        this._lastHiliteUpdated = bentleyjs_core_1.BeTimePoint.now();
        this.lutParams = new FeatureDimensions_1.LUTParams(1, 1);
        this.anyOverridden = true;
        this.allHidden = true;
        this.anyTranslucent = true;
        this.anyOpaque = true;
        this.anyHilited = true;
        this.target = target;
    }
    get byteLength() { return undefined !== this.lut ? this.lut.bytesUsed : 0; }
    get isUniform() { return 2 === this.lutParams.width && 1 === this.lutParams.height; }
    get isUniformFlashed() {
        if (!this.isUniform || undefined === this.lut)
            return false;
        const lut = this.lut;
        const flags = lut.dataBytes[0];
        return 0 !== (flags & 16 /* Flashed */);
    }
    _initialize(map, ovrs, hilite, flashed) {
        const nFeatures = map.numFeatures;
        const dims = FeatureDimensions_1.LUTDimensions.computeWidthAndHeight(nFeatures, 2);
        const width = dims.width;
        const height = dims.height;
        bentleyjs_core_1.assert(width * height >= nFeatures);
        this.lutParams = new FeatureDimensions_1.LUTParams(width, height);
        const data = new Uint8Array(width * height * 4);
        const creator = new Texture_1.Texture2DDataUpdater(data);
        this.buildLookupTable(creator, map, ovrs, flashed, hilite);
        return Texture_1.TextureHandle.createForData(width, height, data, true, GL_1.GL.Texture.WrapMode.ClampToEdge);
    }
    _update(map, lut, flashed, hilites, ovrs) {
        const updater = new Texture_1.Texture2DDataUpdater(lut.dataBytes);
        if (undefined === ovrs) {
            this.updateFlashedAndHilited(updater, map, flashed, hilites);
        }
        else {
            bentleyjs_core_1.assert(undefined !== hilites);
            this.buildLookupTable(updater, map, ovrs, flashed, hilites);
        }
        lut.update(updater);
    }
    buildLookupTable(data, map, ovr, flashedIdParts, hilites) {
        const modelIdParts = bentleyjs_core_1.Id64.getUint32Pair(map.modelId);
        const isModelHilited = hilites.models.has(modelIdParts.lower, modelIdParts.upper);
        this.anyOpaque = this.anyTranslucent = this.anyHilited = false;
        let nHidden = 0;
        let nOverridden = 0;
        // NB: We currently use 2 RGBA values per feature as follows:
        //  [0]
        //      R = override flags (see FeatureOverrides::Flags)
        //      G = line weight
        //      B = line code
        //      A = 1 if no-locatable
        //  [1]
        //      RGB = rgb
        //      A = alpha
        for (let i = 0; i < map.numFeatures; i++) {
            const feature = map.getPackedFeature(i);
            const dataIndex = i * 4 * 2;
            const app = ovr.getAppearance(feature.elementId.lower, feature.elementId.upper, feature.subCategoryId.lower, feature.subCategoryId.upper, feature.geometryClass, modelIdParts.lower, modelIdParts.upper, map.type, feature.animationNodeId);
            if (undefined === app || app.isFullyTransparent) {
                // The feature is not visible. We don't care about any of the other overrides, because we're not going to render it.
                data.setOvrFlagsAtIndex(dataIndex, 1 /* Visibility */);
                nHidden++;
                nOverridden++;
                continue;
            }
            let flags = 0 /* None */;
            if (isModelHilited || isFeatureHilited(feature, hilites)) {
                flags |= 32 /* Hilited */;
                this.anyHilited = true;
            }
            if (app.overridesRgb && app.rgb) {
                flags |= 2 /* Rgb */;
                const rgb = app.rgb;
                data.setByteAtIndex(dataIndex + 4, rgb.r);
                data.setByteAtIndex(dataIndex + 5, rgb.g);
                data.setByteAtIndex(dataIndex + 6, rgb.b);
            }
            if (undefined !== app.transparency) {
                // transparency in range [0, 1]...convert to byte and invert so 0=transparent...
                flags |= 4 /* Alpha */;
                let alpha = 1.0 - app.transparency;
                alpha = Math.floor(0xff * alpha + 0.5);
                data.setByteAtIndex(dataIndex + 7, alpha);
                if (0xff === alpha)
                    this.anyOpaque = true;
                else
                    this.anyTranslucent = true;
            }
            if (app.overridesWeight && app.weight) {
                flags |= 8 /* Weight */;
                let weight = app.weight;
                weight = Math.min(31, weight);
                weight = Math.max(1, weight);
                data.setByteAtIndex(dataIndex + 1, weight);
            }
            if (app.overridesLinePixels && app.linePixels) {
                flags |= 64 /* LineCode */;
                const lineCode = EdgeOverrides_1.LineCode.valueFromLinePixels(app.linePixels);
                data.setByteAtIndex(dataIndex + 2, lineCode);
            }
            if (app.ignoresMaterial)
                flags |= 128 /* IgnoreMaterial */;
            if (undefined !== flashedIdParts && feature.elementId.lower === flashedIdParts.lower && feature.elementId.upper === flashedIdParts.upper)
                flags |= 16 /* Flashed */;
            data.setByteAtIndex(dataIndex + 3, app.nonLocatable ? 1 : 0);
            data.setOvrFlagsAtIndex(dataIndex, flags);
            if (0 /* None */ !== flags || app.nonLocatable)
                nOverridden++;
        }
        this.allHidden = (nHidden === map.numFeatures);
        this.anyOverridden = (nOverridden > 0);
    }
    // NB: If hilites is undefined, it means that the hilited set has not changed.
    updateFlashedAndHilited(data, map, flashed, hilites) {
        this.anyOverridden = this.anyHilited = false;
        let isModelHilited = false;
        let needElemId = undefined !== flashed;
        let needSubCatId = false;
        if (undefined !== hilites) {
            const modelId = bentleyjs_core_1.Id64.getUint32Pair(map.modelId);
            isModelHilited = hilites.models.has(modelId.lower, modelId.upper);
            needSubCatId = !isModelHilited && !hilites.subcategories.isEmpty;
            needElemId = needElemId || (!isModelHilited && !hilites.elements.isEmpty);
        }
        for (let i = 0; i < map.numFeatures; i++) {
            const dataIndex = i * 4 * 2;
            const oldFlags = data.getFlagsAtIndex(dataIndex);
            if (0 /* None */ !== (oldFlags & 1 /* Visibility */)) {
                // Do the same thing as when applying feature overrides - if it's invisible, none of the other flags matter
                // (and if we don't check this we can end up rendering silhouettes around invisible elements in selection set)
                this.anyOverridden = true;
                continue;
            }
            let isFlashed = false;
            let isHilited = undefined !== hilites ? isModelHilited : (0 !== (oldFlags & 32 /* Hilited */));
            if (needElemId) {
                const elemId = map.getElementIdPair(i);
                if (undefined !== flashed)
                    isFlashed = elemId.lower === flashed.lower && elemId.upper === flashed.upper;
                if (!isHilited && undefined !== hilites)
                    isHilited = hilites.elements.has(elemId.lower, elemId.upper);
            }
            if (needSubCatId && !isHilited) {
                const subcat = map.getSubCategoryIdPair(i);
                isHilited = hilites.subcategories.has(subcat.lower, subcat.upper);
            }
            let newFlags = isFlashed ? (oldFlags | 16 /* Flashed */) : (oldFlags & ~16 /* Flashed */);
            newFlags = isHilited ? (newFlags | 32 /* Hilited */) : (newFlags & ~32 /* Hilited */);
            data.setOvrFlagsAtIndex(dataIndex, newFlags);
            if (0 /* None */ !== newFlags) {
                this.anyOverridden = true;
                this.anyHilited = this.anyHilited || isHilited;
            }
        }
    }
    static createFromTarget(target) {
        return new FeatureOverrides(target);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.lut);
        this.lut = undefined;
    }
    initFromMap(map) {
        const nFeatures = map.numFeatures;
        bentleyjs_core_1.assert(0 < nFeatures);
        this.lut = undefined;
        const ovrs = this.target.currentFeatureSymbologyOverrides;
        const hilite = this.target.hilites;
        this.lut = this._initialize(map, ovrs, hilite, this.target.flashed);
        this._lastOverridesUpdated = this._lastFlashUpdated = this._lastHiliteUpdated = bentleyjs_core_1.BeTimePoint.now();
    }
    update(features) {
        const styleLastUpdated = this.target.overridesUpdateTime;
        const flashLastUpdated = this.target.flashedUpdateTime;
        const ovrsUpdated = this._lastOverridesUpdated.before(styleLastUpdated);
        const hiliteLastUpdated = this.target.hiliteUpdateTime;
        const hiliteUpdated = this._lastHiliteUpdated.before(hiliteLastUpdated);
        const ovrs = ovrsUpdated ? this.target.currentFeatureSymbologyOverrides : undefined;
        const hilite = this.target.hilites;
        if (ovrsUpdated || hiliteUpdated || this._lastFlashUpdated.before(flashLastUpdated)) {
            this._update(features, this.lut, this.target.flashed, undefined !== ovrs || hiliteUpdated ? hilite : undefined, ovrs);
            this._lastOverridesUpdated = styleLastUpdated;
            this._lastFlashUpdated = flashLastUpdated;
            this._lastHiliteUpdated = hiliteLastUpdated;
        }
    }
}
exports.FeatureOverrides = FeatureOverrides;
/** @internal */
class Graphic extends System_1.RenderGraphic {
    get isPickable() { return false; }
    addHiliteCommands(_commands, _batch, _pass) { bentleyjs_core_1.assert(false); }
    toPrimitive() { return undefined; }
}
exports.Graphic = Graphic;
/** @internal */
class Batch extends Graphic {
    constructor(graphic, features, range) {
        super();
        this.batchId = 0; // Transient ID assigned while rendering a frame, reset afterward.
        this._overrides = [];
        this.graphic = graphic;
        this.featureTable = features;
        this.range = range;
    }
    // Note: This does not remove FeatureOverrides from the array, but rather disposes of the WebGL resources they contain
    dispose() {
        bentleyjs_core_1.dispose(this.graphic);
        for (const over of this._overrides) {
            over.target.onBatchDisposed(this);
            bentleyjs_core_1.dispose(over);
        }
        this._overrides.length = 0;
    }
    collectStatistics(stats) {
        this.graphic.collectStatistics(stats);
        stats.addFeatureTable(this.featureTable.byteLength);
        for (const ovrs of this._overrides)
            stats.addFeatureOverrides(ovrs.byteLength);
    }
    addCommands(commands) { commands.addBatch(this); }
    get isPickable() { return true; }
    getOverrides(target) {
        let ret;
        for (const ovr of this._overrides) {
            if (ovr.target === target) {
                ret = ovr;
                break;
            }
        }
        if (undefined === ret) {
            ret = FeatureOverrides.createFromTarget(target);
            this._overrides.push(ret);
            target.addBatch(this);
            ret.initFromMap(this.featureTable);
        }
        ret.update(this.featureTable);
        return ret;
    }
    onTargetDisposed(target) {
        let index = 0;
        let foundIndex = -1;
        for (const ovr of this._overrides) {
            if (ovr.target === target) {
                foundIndex = index;
                break;
            }
            index++;
        }
        if (foundIndex > -1) {
            bentleyjs_core_1.dispose(this._overrides[foundIndex]);
            this._overrides.splice(foundIndex, 1);
        }
    }
}
exports.Batch = Batch;
/** @internal */
class Branch extends Graphic {
    constructor(branch, localToWorld = geometry_core_1.Transform.createIdentity(), clips, viewFlags, planarClassifier) {
        super();
        this.branch = branch;
        this.localToWorldTransform = localToWorld;
        this.clips = clips;
        this.planarClassifier = planarClassifier;
        if (undefined !== viewFlags)
            branch.setViewFlags(viewFlags);
    }
    dispose() { this.branch.dispose(); }
    collectStatistics(stats) {
        this.branch.collectStatistics(stats);
        if (undefined !== this.clips)
            this.clips.collectStatistics(stats);
    }
    addCommands(commands) { commands.addBranch(this); }
    addHiliteCommands(commands, batch, pass) { commands.addHiliteBranch(this, batch, pass); }
}
exports.Branch = Branch;
/** @internal */
class WorldDecorations extends Branch {
    constructor(viewFlags) {
        super(new System_1.GraphicBranch(), geometry_core_1.Transform.identity, undefined, viewFlags);
        // World decorations ignore all the symbology overrides for the "scene" geometry...
        this.branch.symbologyOverrides = new FeatureSymbology_1.FeatureSymbology.Overrides();
    }
    init(decs) {
        this.branch.clear();
        for (const dec of decs) {
            this.branch.add(dec);
        }
    }
}
exports.WorldDecorations = WorldDecorations;
/** @internal */
class GraphicsArray extends Graphic {
    // Note: We assume the graphics array we get contains undisposed graphics to start
    constructor(graphics) {
        super();
        this.graphics = graphics;
    }
    dispose() {
        for (const graphic of this.graphics)
            bentleyjs_core_1.dispose(graphic);
        this.graphics.length = 0;
    }
    addCommands(commands) {
        for (const graphic of this.graphics) {
            graphic.addCommands(commands);
        }
    }
    addHiliteCommands(commands, batch, pass) {
        for (const graphic of this.graphics) {
            graphic.addHiliteCommands(commands, batch, pass);
        }
    }
    collectStatistics(stats) {
        for (const graphic of this.graphics)
            graphic.collectStatistics(stats);
    }
}
exports.GraphicsArray = GraphicsArray;


/***/ }),

/***/ "./lib/render/webgl/Handle.js":
/*!************************************!*\
  !*** ./lib/render/webgl/Handle.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
/**
 * A handle to a WebGLBuffer, such as a vertex or index buffer.
 * The WebGLBuffer is allocated by the constructor and should be freed by a call to dispose().
 * @internal
 */
class BufferHandle {
    /** Allocates the WebGLBuffer using the supplied context. Free the WebGLBuffer using dispose() */
    constructor() {
        this._bytesUsed = 0;
        const glBuffer = System_1.System.instance.context.createBuffer();
        // gl.createBuffer() returns WebGLBuffer | null...
        if (null !== glBuffer) {
            this._glBuffer = glBuffer;
        }
        else {
            this._glBuffer = undefined;
        }
        bentleyjs_core_1.assert(!this.isDisposed);
    }
    get isDisposed() { return this._glBuffer === undefined; }
    get bytesUsed() { return this._bytesUsed; }
    /** Frees the WebGL buffer */
    dispose() {
        if (!this.isDisposed) {
            System_1.System.instance.context.deleteBuffer(this._glBuffer);
            this._glBuffer = undefined;
        }
    }
    /** Binds this buffer to the specified target */
    bind(target) {
        if (undefined !== this._glBuffer) {
            System_1.System.instance.context.bindBuffer(target, this._glBuffer);
        }
    }
    /** Sets the specified target to be bound to no buffer */
    static unbind(target) { System_1.System.instance.context.bindBuffer(target, null); }
    /** Binds this buffer to the specified target and sets the buffer's data store. */
    bindData(target, data, usage = GL_1.GL.Buffer.Usage.StaticDraw) {
        this.bind(target);
        System_1.System.instance.context.bufferData(target, data, usage);
        BufferHandle.unbind(target);
        this._bytesUsed = data.byteLength;
    }
    /** Creates a BufferHandle and binds its data */
    static createBuffer(target, data, usage = GL_1.GL.Buffer.Usage.StaticDraw) {
        const handle = new BufferHandle();
        if (handle.isDisposed) {
            return undefined;
        }
        handle.bindData(target, data, usage);
        return handle;
    }
    /** Creates a BufferHandle and binds its data */
    static createArrayBuffer(data, usage = GL_1.GL.Buffer.Usage.StaticDraw) {
        return BufferHandle.createBuffer(GL_1.GL.Buffer.Target.ArrayBuffer, data, usage);
    }
    isBound(binding) { return System_1.System.instance.context.getParameter(binding) === this._glBuffer; }
}
exports.BufferHandle = BufferHandle;
function setScale(index, value, array) {
    array[index] = 0.0 !== value ? 1.0 / value : value;
}
/**
 * Converts 2d quantization parameters to a format appropriate for submittal to the GPU.
 * params[0] = origin.x
 * params[1] = origin.y
 * params[2] = scale.x
 * params[3] = scale.y
 * @internal
 */
function qparams2dToArray(params) {
    const arr = new Float32Array(4);
    arr[0] = params.origin.x;
    arr[1] = params.origin.y;
    setScale(2, params.scale.x, arr);
    setScale(3, params.scale.y, arr);
    return arr;
}
exports.qparams2dToArray = qparams2dToArray;
/** @internal */
function qorigin3dToArray(qorigin) {
    const origin = new Float32Array(3);
    origin[0] = qorigin.x;
    origin[1] = qorigin.y;
    origin[2] = qorigin.z;
    return origin;
}
exports.qorigin3dToArray = qorigin3dToArray;
/** @internal */
function qscale3dToArray(qscale) {
    const scale = new Float32Array(3);
    setScale(0, qscale.x, scale);
    setScale(1, qscale.y, scale);
    setScale(2, qscale.z, scale);
    return scale;
}
exports.qscale3dToArray = qscale3dToArray;
/** Converts 3d quantization params to a pair of Float32Arrays
 * @internal
 */
function qparams3dToArray(params) {
    const origin = qorigin3dToArray(params.origin);
    const scale = qscale3dToArray(params.scale);
    return { origin, scale };
}
exports.qparams3dToArray = qparams3dToArray;
/** A handle to a WebGLBuffer intended to hold quantized 2d points
 * @internal
 */
class QBufferHandle2d extends BufferHandle {
    constructor(params) {
        super();
        this.params = qparams2dToArray(params);
    }
    static create(params, data) {
        const handle = new QBufferHandle2d(params);
        if (handle.isDisposed) {
            return undefined;
        }
        handle.bindData(GL_1.GL.Buffer.Target.ArrayBuffer, data);
        return handle;
    }
}
exports.QBufferHandle2d = QBufferHandle2d;
/* A handle to a WebGLBuffer intended to hold quantized 3d points
 * @internal
 */
class QBufferHandle3d extends BufferHandle {
    constructor(params) {
        super();
        this.origin = qorigin3dToArray(params.origin);
        this.scale = qscale3dToArray(params.scale);
    }
    static create(params, data) {
        const handle = new QBufferHandle3d(params);
        if (handle.isDisposed) {
            return undefined;
        }
        handle.bindData(GL_1.GL.Buffer.Target.ArrayBuffer, data);
        return handle;
    }
}
exports.QBufferHandle3d = QBufferHandle3d;
/** A handle to the location of an attribute within a shader program
 * @internal
 */
class AttributeHandle {
    constructor(glId) { this._glId = glId; }
    static create(program, name, required = false) {
        const glId = System_1.System.instance.context.getAttribLocation(program, name);
        if (-1 === glId) {
            bentleyjs_core_1.assert(!required, "getAttribLocation failed for " + name);
            return undefined;
        }
        return new AttributeHandle(glId);
    }
    setVertexAttribPointer(size, type, normalized, stride, offset) {
        System_1.System.instance.context.vertexAttribPointer(this._glId, size, type, normalized, stride, offset);
    }
    enableVertexAttribArray(instanced = false) { System_1.System.instance.enableVertexAttribArray(this._glId, instanced); }
    enableArray(buffer, size, type, normalized, stride, offset, instanced = false) {
        buffer.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        this.setVertexAttribPointer(size, type, normalized, stride, offset);
        this.enableVertexAttribArray(instanced);
        BufferHandle.unbind(GL_1.GL.Buffer.Target.ArrayBuffer);
    }
}
exports.AttributeHandle = AttributeHandle;
/** A handle to the location of a uniform within a shader program
 * @internal
 */
class UniformHandle {
    constructor(location) {
        this._type = 0 /* Undefined */;
        this._data = [];
        this._location = location;
    }
    static create(program, name, required = true) {
        const location = System_1.System.instance.context.getUniformLocation(program, name);
        if (null === location) {
            bentleyjs_core_1.assert(!required, "getUniformLocation failed for " + name);
            return undefined;
        }
        return new UniformHandle(location);
    }
    updateData(type, data) {
        bentleyjs_core_1.assert(0 /* Undefined */ !== type && 8 /* Int */ !== type && 3 /* Float */ !== type);
        let updated = this._type !== type;
        if (updated) {
            this._type = type;
            if (this._data.length !== data.length)
                this._data.length = data.length;
        }
        for (let i = 0; i < data.length; i++) {
            const datum = data[i];
            updated = updated || this._data[i] !== datum;
            this._data[i] = datum;
        }
        return updated;
    }
    updateDatum(type, datum) {
        bentleyjs_core_1.assert(8 /* Int */ === type || 3 /* Float */ === type);
        // NB: Yes, calling data.length without actually changing the length shows up as a significant performance bottleneck...
        if (this._data.length !== 1)
            this._data.length = 1;
        const updated = this._type !== type || this._data[0] !== datum;
        this._type = type;
        this._data[0] = datum;
        return updated;
    }
    setMatrix3(mat) {
        if (this.updateData(1 /* Mat3 */, mat.data))
            System_1.System.instance.context.uniformMatrix3fv(this._location, false, mat.data);
    }
    setMatrix4(mat) {
        if (this.updateData(2 /* Mat4 */, mat.data))
            System_1.System.instance.context.uniformMatrix4fv(this._location, false, mat.data);
    }
    setUniform1fv(data) {
        if (this.updateData(4 /* FloatArray */, data))
            System_1.System.instance.context.uniform1fv(this._location, data);
    }
    setUniform2fv(data) {
        if (this.updateData(5 /* Vec2 */, data))
            System_1.System.instance.context.uniform2fv(this._location, data);
    }
    setUniform3fv(data) {
        if (this.updateData(6 /* Vec3 */, data))
            System_1.System.instance.context.uniform3fv(this._location, data);
    }
    setUniform4fv(data) {
        if (this.updateData(7 /* Vec4 */, data))
            System_1.System.instance.context.uniform4fv(this._location, data);
    }
    setUniform1i(data) {
        if (this.updateDatum(8 /* Int */, data))
            System_1.System.instance.context.uniform1i(this._location, data);
    }
    setUniform1f(data) {
        if (this.updateDatum(3 /* Float */, data))
            System_1.System.instance.context.uniform1f(this._location, data);
    }
}
exports.UniformHandle = UniformHandle;


/***/ }),

/***/ "./lib/render/webgl/InstancedGeometry.js":
/*!***********************************************!*\
  !*** ./lib/render/webgl/InstancedGeometry.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const Handle_1 = __webpack_require__(/*! ./Handle */ "./lib/render/webgl/Handle.js");
const FeaturesInfo_1 = __webpack_require__(/*! ./FeaturesInfo */ "./lib/render/webgl/FeaturesInfo.js");
/** @internal */
class InstanceBuffers {
    constructor(shared, count, transforms, rtcCenter, transformsData, symbology, featureIds, featuresInfo) {
        // The model matrix from which _rtcTransform was previously computed. If it changes, _rtcTransform must be recomputed.
        this._modelMatrix = geometry_core_1.Transform.createIdentity();
        this.shared = shared;
        this.numInstances = count;
        this.transforms = transforms;
        this.featureIds = featureIds;
        this.featuresInfo = featuresInfo;
        this.symbology = symbology;
        this._rtcCenter = rtcCenter;
        this._rtcTransform = geometry_core_1.Transform.createTranslation(this._rtcCenter);
        this._transforms = transformsData;
    }
    static create(params, shared) {
        const { count, featureIds, symbologyOverrides, transforms } = params;
        bentleyjs_core_1.assert(count > 0 && Math.floor(count) === count);
        bentleyjs_core_1.assert(count === transforms.length / 12);
        bentleyjs_core_1.assert(undefined === featureIds || count === featureIds.length / 3);
        bentleyjs_core_1.assert(undefined === symbologyOverrides || count * 8 === symbologyOverrides.length);
        let idBuf;
        if (undefined !== featureIds && undefined === (idBuf = Handle_1.BufferHandle.createArrayBuffer(featureIds)))
            return undefined;
        const featuresInfo = FeaturesInfo_1.FeaturesInfo.createFromFeatureIds(featureIds);
        let symBuf;
        if (undefined !== symbologyOverrides && undefined === (symBuf = Handle_1.BufferHandle.createArrayBuffer(symbologyOverrides)))
            return undefined;
        const tfBuf = Handle_1.BufferHandle.createArrayBuffer(transforms);
        return undefined !== tfBuf ? new InstanceBuffers(shared, count, tfBuf, params.transformCenter, transforms, symBuf, idBuf, featuresInfo) : undefined;
    }
    getRtcTransform(modelMatrix) {
        if (!this._modelMatrix.isAlmostEqual(modelMatrix)) {
            modelMatrix.clone(this._modelMatrix);
            const rtcTransform = geometry_core_1.Transform.createTranslation(this._rtcCenter);
            modelMatrix.multiplyTransformTransform(rtcTransform, this._rtcTransform);
        }
        return this._rtcTransform;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.transforms);
        bentleyjs_core_1.dispose(this.featureIds);
        bentleyjs_core_1.dispose(this.symbology);
    }
    get rtcCenter() { return this._rtcCenter; }
    collectStatistics(stats) {
        const featureBytes = undefined !== this.featureIds ? this.featureIds.bytesUsed : 0;
        const symBytes = undefined !== this.symbology ? this.symbology.bytesUsed : 0;
        const bytesUsed = this.transforms.bytesUsed + symBytes + featureBytes;
        stats.addInstances(bytesUsed);
    }
    computeRange(reprRange, out) {
        if (undefined !== this._range)
            return this._range.clone(out);
        this._range = new geometry_core_1.Range3d();
        const tfs = this._transforms;
        if (undefined === tfs) {
            bentleyjs_core_1.assert(false);
            return this._range.clone(out);
        }
        this._transforms = undefined;
        const numFloatsPerTransform = 3 * 4;
        bentleyjs_core_1.assert(0 === tfs.length % (3 * 4));
        const tf = geometry_core_1.Transform.createIdentity();
        const r = new geometry_core_1.Range3d();
        for (let i = 0; i < tfs.length; i += numFloatsPerTransform) {
            tf.setFromJSON({
                origin: [tfs[i + 3], tfs[i + 7], tfs[i + 11]],
                matrix: [
                    [tfs[i + 0], tfs[i + 1], tfs[i + 2]],
                    [tfs[i + 4], tfs[i + 5], tfs[i + 6]],
                    [tfs[i + 8], tfs[i + 9], tfs[i + 10]],
                ],
            });
            reprRange.clone(r);
            tf.multiplyRange(r, r);
            this._range.extendRange(r);
        }
        const rtcTransform = geometry_core_1.Transform.createTranslation(this._rtcCenter);
        rtcTransform.multiplyRange(this._range, this._range);
        return this._range.clone(out);
    }
}
exports.InstanceBuffers = InstanceBuffers;
/** @internal */
class InstancedGeometry extends CachedGeometry_1.CachedGeometry {
    get numInstances() { return this._buffers.numInstances; }
    get transforms() { return this._buffers.transforms; }
    get featureIds() { return this._buffers.featureIds; }
    get symbology() { return this._buffers.symbology; }
    getRtcTransform(modelMatrix) { return this._buffers.getRtcTransform(modelMatrix); }
    get asInstanced() { return this; }
    get asLUT() { return this._repr.asLUT; }
    get asMesh() { return this._repr.asMesh; }
    get asSurface() { return this._repr.asSurface; }
    get asEdge() { return this._repr.asEdge; }
    get asSilhouette() { return this._repr.asSilhouette; }
    get renderOrder() { return this._repr.renderOrder; }
    get isLitSurface() { return this._repr.isLitSurface; }
    get hasBakedLighting() { return this._repr.hasBakedLighting; }
    get hasAnimation() { return this._repr.hasAnimation; }
    get qOrigin() { return this._repr.qOrigin; }
    get qScale() { return this._repr.qScale; }
    get material() { return this._repr.material; }
    get polylineBuffers() { return this._repr.polylineBuffers; }
    set uniformFeatureIndices(_value) { bentleyjs_core_1.assert(false); } // This is used for decoration graphics. No such thing as instanced decorations.
    get isEdge() { return this._repr.isEdge; }
    get featuresInfo() { return this._buffers.featuresInfo; }
    getTechniqueId(target) { return this._repr.getTechniqueId(target); }
    getRenderPass(target) { return this._repr.getRenderPass(target); }
    wantWoWReversal(params) { return this._repr.wantWoWReversal(params); }
    getLineCode(params) { return this._repr.getLineCode(params); }
    getLineWeight(params) { return this._repr.getLineWeight(params); }
    get rtcCenter() { return this._buffers.rtcCenter; }
    constructor(repr, ownsRepr, buffers) {
        super();
        this._repr = repr;
        this._ownsRepr = ownsRepr;
        this._buffers = buffers;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._buffers);
        if (this._ownsRepr)
            this._repr.dispose();
    }
    bindVertexArray(handle) {
        this._repr.bindVertexArray(handle);
    }
    _wantWoWReversal(_target) {
        bentleyjs_core_1.assert(false, "Should never be called");
        return false;
    }
    draw() {
        this._repr.drawInstanced(this.numInstances);
    }
    computeRange(output) {
        if (undefined === this._range) {
            this._range = new geometry_core_1.Range3d();
            const reprRange = this._repr.computeRange();
            this._buffers.computeRange(reprRange, this._range);
        }
        return this._range.clone(output);
    }
    collectStatistics(stats) {
        this._repr.collectStatistics(stats);
        if (!this._buffers.shared)
            this._buffers.collectStatistics(stats);
    }
}
exports.InstancedGeometry = InstancedGeometry;


/***/ }),

/***/ "./lib/render/webgl/Material.js":
/*!**************************************!*\
  !*** ./lib/render/webgl/Material.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/** @internal */
class Material extends imodeljs_common_1.RenderMaterial {
    constructor(materialParams) {
        super(materialParams);
        this.diffuseUniform = new Float32Array(4); // [red, green, blue, overridden]
        this.alphaUniform = new Float32Array(2); // [alpha, overridden]
        this.specular = new Float32Array(4); // [red, green, blue, exponent]
        this.weights = new Float32Array(3); // [diffuse weight, specular weight, reflect]
        this.diffuseUniform[3] = undefined !== materialParams.diffuseColor ? 1.0 : 0.0;
        if (undefined !== materialParams.diffuseColor) {
            const diffRgb = materialParams.diffuseColor.colors;
            this.diffuseUniform[0] = diffRgb.r / 255;
            this.diffuseUniform[1] = diffRgb.g / 255;
            this.diffuseUniform[2] = diffRgb.b / 255;
        }
        else {
            this.diffuseUniform[0] = this.diffuseUniform[1] = this.diffuseUniform[2] = 1.0;
        }
        this.specular[3] = materialParams.specularExponent;
        if (materialParams.specularColor) {
            const specRgb = materialParams.specularColor.colors;
            this.specular[0] = specRgb.r / 255;
            this.specular[1] = specRgb.g / 255;
            this.specular[2] = specRgb.b / 255;
        }
        else {
            this.specular[0] = this.specular[1] = this.specular[2] = 1.0;
        }
        if (materialParams.reflectColor)
            this.reflectColor = materialParams.reflectColor.clone();
        this.weights[0] = materialParams.diffuse;
        this.weights[1] = materialParams.specular;
        this.weights[2] = materialParams.reflect;
        if (0.0 !== materialParams.transparency) {
            this.alphaUniform[0] = 1.0 - materialParams.transparency;
            this.alphaUniform[1] = 1.0;
        }
        else {
            this.alphaUniform[0] = 1.0;
            this.alphaUniform[1] = 0.0;
        }
    }
    get textureWeight() { return undefined !== this.textureMapping ? this.textureMapping.params.weight : 1.0; }
    get overridesRgb() { return 1.0 === this.diffuseUniform[3]; }
    get overridesAlpha() { return 1.0 === this.alphaUniform[1]; }
    get hasTranslucency() { return this.overridesAlpha && this.alphaUniform[0] < 1.0; }
}
Material.default = new Material(imodeljs_common_1.RenderMaterial.Params.defaults);
exports.Material = Material;
Object.freeze(Material.default);


/***/ }),

/***/ "./lib/render/webgl/Matrix.js":
/*!************************************!*\
  !*** ./lib/render/webgl/Matrix.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
class Matrix3 {
    constructor() {
        this.data = new Float32Array(3 * 3);
    }
    initIdentity() {
        this.setValues(1, 0, 0, 0, 1, 0, 0, 0, 1);
    }
    static fromIdentity(out) {
        const mat = undefined !== out ? out : new Matrix3();
        mat.initIdentity();
        return mat;
    }
    copyFrom(src) {
        for (let i = 0; i < this.data.length; i++) {
            this.data[i] = src.data[i];
        }
    }
    clone(out) {
        const mat = undefined !== out ? out : new Matrix3();
        mat.copyFrom(this);
        return mat;
    }
    setValues(m00, m01, m02, m10, m11, m12, m20, m21, m22) {
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m10 = m10;
        this.m11 = m11;
        this.m12 = m12;
        this.m20 = m20;
        this.m21 = m21;
        this.m22 = m22;
    }
    static fromValues(m00, m01, m02, m10, m11, m12, m20, m21, m22, out) {
        const mat = undefined !== out ? out : new Matrix3();
        mat.setValues(m00, m01, m02, m10, m11, m12, m20, m21, m22);
        return mat;
    }
    initFromMatrix3d(rot) {
        this.setValues(rot.at(0, 0), rot.at(0, 1), rot.at(0, 2), rot.at(1, 0), rot.at(1, 1), rot.at(1, 2), rot.at(2, 0), rot.at(2, 1), rot.at(2, 2));
    }
    static fromMatrix3d(rot, out) {
        const mat = undefined !== out ? out : new Matrix3();
        mat.initFromMatrix3d(rot);
        return mat;
    }
    toMatrix3d() {
        const data = this.data;
        return geometry_core_1.Matrix3d.createRowValues(data[0], data[3], data[6], data[1], data[4], data[7], data[2], data[5], data[8]);
    }
    swap(firstIndex, secondIndex) {
        bentleyjs_core_1.assert(firstIndex < this.data.length);
        bentleyjs_core_1.assert(secondIndex < this.data.length);
        bentleyjs_core_1.assert(secondIndex !== firstIndex);
        const tmp = this.data[firstIndex];
        this.data[firstIndex] = this.data[secondIndex];
        this.data[secondIndex] = tmp;
    }
    transpose() {
        this.swap(1, 3);
        this.swap(5, 7);
        this.swap(2, 6);
    }
    static fromTranspose(src, out) {
        const mat = src.clone(out);
        mat.transpose();
        return mat;
    }
    get(index) { bentleyjs_core_1.assert(index < this.data.length); return this.data[index]; }
    set(index, value) { bentleyjs_core_1.assert(index < this.data.length); this.data[index] = value; }
    at(row, col) { return this.get(col * 3 + row); }
    setAt(row, col, value) { this.set(col * 3 + row, value); }
    get m00() { return this.at(0, 0); }
    set m00(value) { this.setAt(0, 0, value); }
    get m01() { return this.at(0, 1); }
    set m01(value) { this.setAt(0, 1, value); }
    get m02() { return this.at(0, 2); }
    set m02(value) { this.setAt(0, 2, value); }
    get m10() { return this.at(1, 0); }
    set m10(value) { this.setAt(1, 0, value); }
    get m11() { return this.at(1, 1); }
    set m11(value) { this.setAt(1, 1, value); }
    get m12() { return this.at(1, 2); }
    set m12(value) { this.setAt(1, 2, value); }
    get m20() { return this.at(2, 0); }
    set m20(value) { this.setAt(2, 0, value); }
    get m21() { return this.at(2, 1); }
    set m21(value) { this.setAt(2, 1, value); }
    get m22() { return this.at(2, 2); }
    set m22(value) { this.setAt(2, 2, value); }
}
exports.Matrix3 = Matrix3;
/** @internal */
class Matrix4 {
    constructor() {
        this.data = new Float32Array(4 * 4);
    }
    copyFrom(src) {
        for (let i = 0; i < this.data.length; i++) {
            this.data[i] = src.data[i];
        }
    }
    clone(out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.copyFrom(this);
        return mat;
    }
    initIdentity() {
        this.setValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
    }
    static fromIdentity(out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.initIdentity();
        return mat;
    }
    setValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33) {
        this.m00 = m00;
        this.m01 = m01;
        this.m02 = m02;
        this.m03 = m03;
        this.m10 = m10;
        this.m11 = m11;
        this.m12 = m12;
        this.m13 = m13;
        this.m20 = m20;
        this.m21 = m21;
        this.m22 = m22;
        this.m23 = m23;
        this.m30 = m30;
        this.m31 = m31;
        this.m32 = m32;
        this.m33 = m33;
    }
    static fromValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.setValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);
        return mat;
    }
    getRotation(out) {
        const rot = undefined !== out ? out : new Matrix3();
        rot.setValues(this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, this.m20, this.m21, this.m22);
        return rot;
    }
    initFromTransform(transform) {
        const mat = transform.matrix;
        const org = transform.origin;
        this.setValues(mat.at(0, 0), mat.at(0, 1), mat.at(0, 2), org.x, mat.at(1, 0), mat.at(1, 1), mat.at(1, 2), org.y, mat.at(2, 0), mat.at(2, 1), mat.at(2, 2), org.z, 0, 0, 0, 1);
    }
    static fromTransform(transform, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.initFromTransform(transform);
        return mat;
    }
    toTransform() {
        const data = this.data;
        bentleyjs_core_1.assert(0.0 === data[3] && 0.0 === data[7] && 0.0 === data[11] && 1.0 === data[15]);
        const origin = new geometry_core_1.Point3d(data[12], data[13], data[14]);
        const rotMat = geometry_core_1.Matrix3d.createIdentity();
        for (let i = 0; i < 3; i++)
            for (let j = 0; j < 3; j++)
                rotMat.setAt(i, j, data[i + j * 4]);
        return geometry_core_1.Transform.createRefs(origin, rotMat);
    }
    initFromMatrix4d(mat) {
        this.setValues(mat.atIJ(0, 0), mat.atIJ(0, 1), mat.atIJ(0, 2), mat.atIJ(0, 3), mat.atIJ(1, 0), mat.atIJ(1, 1), mat.atIJ(1, 2), mat.atIJ(1, 3), mat.atIJ(2, 0), mat.atIJ(2, 1), mat.atIJ(2, 2), mat.atIJ(2, 3), mat.atIJ(3, 0), mat.atIJ(3, 1), mat.atIJ(3, 2), mat.atIJ(3, 3));
    }
    static fromMatrix4d(mat, out) {
        const result = undefined !== out ? out : new Matrix4();
        result.initFromMatrix4d(mat);
        return result;
    }
    toMatrix4d() {
        const data = this.data;
        return geometry_core_1.Matrix4d.createRowValues(data[0], data[4], data[8], data[12], data[1], data[5], data[9], data[13], data[2], data[6], data[10], data[14], data[3], data[7], data[11], data[15]);
    }
    lookAt(eye, center, up) {
        const f = normalizedDifference(center, eye);
        if (undefined === f) {
            return false;
        }
        const s = fromNormalizedCrossProduct(f, up);
        if (undefined === s) {
            return false;
        }
        const u = geometry_core_1.Vector3d.createCrossProduct(s.x, s.y, s.z, f.x, f.y, f.z);
        this.setValues(s.x, s.y, s.z, -s.dotProduct(eye), u.x, u.y, u.z, -u.dotProduct(eye), -f.x, -f.y, -f.z, f.dotProduct(eye), 0, 0, 0, 1);
        return true;
    }
    static fromLookAt(eye, center, up, out) {
        const mat = undefined !== out ? out : new Matrix4();
        return mat.lookAt(eye, center, up) ? mat : undefined;
    }
    // left, right, bottom, top, near, far
    frustum(l, r, b, t, n, f) {
        this.setValues((2 * n) / (r - l), 0, (r + l) / (r - l), 0, 0, (2 * n) / (t - b), (t + b) / (t - b), 0, 0, 0, -(f + n) / (f - n), -(2 * f * n) / (f - n), 0, 0, -1, 0);
    }
    static fromFrustum(l, r, b, t, n, f, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.frustum(l, r, b, t, n, f);
        return mat;
    }
    perspective(fovY, aspectRatio, nearZ, farZ) {
        const frustumHeight = Math.tan(fovY / 360 * Math.PI) * nearZ;
        const frustumWidth = frustumHeight * aspectRatio;
        this.frustum(-frustumWidth, frustumWidth, -frustumHeight, frustumHeight, nearZ, farZ);
    }
    static fromPerspective(fovY, aspectRatio, nearZ, farZ, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.perspective(fovY, aspectRatio, nearZ, farZ);
        return mat;
    }
    ortho(l, r, b, t, n, f) {
        this.setValues(2 / (r - l), 0, 0, -(r + l) / (r - l), 0, 2 / (t - b), 0, -(t + b) / (t - b), 0, 0, -2 / (f - n), -(f + n) / (f - n), 0, 0, 0, 1);
    }
    static fromOrtho(l, r, b, t, n, f, out) {
        const mat = undefined !== out ? out : new Matrix4();
        mat.ortho(l, r, b, t, n, f);
        return mat;
    }
    invert() {
        const d = this.data;
        const d0 = d[0];
        const d1 = d[1];
        const d2 = d[2];
        const d3 = d[3];
        this.setValues(d[5] * d[10] * d[15] - d[5] * d[11] * d[14] - d[9] * d[6] * d[15] + d[9] * d[7] * d[14] + d[13] * d[6] * d[11] - d[13] * d[7] * d[10], -d[4] * d[10] * d[15] + d[4] * d[11] * d[14] + d[8] * d[6] * d[15] - d[8] * d[7] * d[14] - d[12] * d[6] * d[11] + d[12] * d[7] * d[10], d[4] * d[9] * d[15] - d[4] * d[11] * d[13] - d[8] * d[5] * d[15] + d[8] * d[7] * d[13] + d[12] * d[5] * d[11] - d[12] * d[7] * d[9], -d[4] * d[9] * d[14] + d[4] * d[10] * d[13] + d[8] * d[5] * d[14] - d[8] * d[6] * d[13] - d[12] * d[5] * d[10] + d[12] * d[6] * d[9], -d[1] * d[10] * d[15] + d[1] * d[11] * d[14] + d[9] * d[2] * d[15] - d[9] * d[3] * d[14] - d[13] * d[2] * d[11] + d[13] * d[3] * d[10], d[0] * d[10] * d[15] - d[0] * d[11] * d[14] - d[8] * d[2] * d[15] + d[8] * d[3] * d[14] + d[12] * d[2] * d[11] - d[12] * d[3] * d[10], -d[0] * d[9] * d[15] + d[0] * d[11] * d[13] + d[8] * d[1] * d[15] - d[8] * d[3] * d[13] - d[12] * d[1] * d[11] + d[12] * d[3] * d[9], d[0] * d[9] * d[14] - d[0] * d[10] * d[13] - d[8] * d[1] * d[14] + d[8] * d[2] * d[13] + d[12] * d[1] * d[10] - d[12] * d[2] * d[9], d[1] * d[6] * d[15] - d[1] * d[7] * d[14] - d[5] * d[2] * d[15] + d[5] * d[3] * d[14] + d[13] * d[2] * d[7] - d[13] * d[3] * d[6], -d[0] * d[6] * d[15] + d[0] * d[7] * d[14] + d[4] * d[2] * d[15] - d[4] * d[3] * d[14] - d[12] * d[2] * d[7] + d[12] * d[3] * d[6], d[0] * d[5] * d[15] - d[0] * d[7] * d[13] - d[4] * d[1] * d[15] + d[4] * d[3] * d[13] + d[12] * d[1] * d[7] - d[12] * d[3] * d[5], -d[0] * d[5] * d[14] + d[0] * d[6] * d[13] + d[4] * d[1] * d[14] - d[4] * d[2] * d[13] - d[12] * d[1] * d[6] + d[12] * d[2] * d[5], -d[1] * d[6] * d[11] + d[1] * d[7] * d[10] + d[5] * d[2] * d[11] - d[5] * d[3] * d[10] - d[9] * d[2] * d[7] + d[9] * d[3] * d[6], d[0] * d[6] * d[11] - d[0] * d[7] * d[10] - d[4] * d[2] * d[11] + d[4] * d[3] * d[10] + d[8] * d[2] * d[7] - d[8] * d[3] * d[6], -d[0] * d[5] * d[11] + d[0] * d[7] * d[9] + d[4] * d[1] * d[11] - d[4] * d[3] * d[9] - d[8] * d[1] * d[7] + d[8] * d[3] * d[5], d[0] * d[5] * d[10] - d[0] * d[6] * d[9] - d[4] * d[1] * d[10] + d[4] * d[2] * d[9] + d[8] * d[1] * d[6] - d[8] * d[2] * d[5]);
        const determinant = d0 * d[0] + d1 * d[4] + d2 * d[8] + d3 * d[12];
        if (0 === determinant) {
            this.initIdentity();
            return false;
        }
        this.multiplyByScalar(1 / determinant);
        return true;
    }
    static fromInverse(src, out) {
        const mat = src.clone(out);
        return mat.invert() ? mat : undefined;
    }
    swap(firstIndex, secondIndex) {
        bentleyjs_core_1.assert(firstIndex < this.data.length);
        bentleyjs_core_1.assert(secondIndex < this.data.length);
        bentleyjs_core_1.assert(secondIndex !== firstIndex);
        const tmp = this.data[firstIndex];
        this.data[firstIndex] = this.data[secondIndex];
        this.data[secondIndex] = tmp;
    }
    transpose() {
        this.swap(1, 4);
        this.swap(2, 8);
        this.swap(3, 12);
        this.swap(6, 9);
        this.swap(7, 13);
        this.swap(11, 14);
    }
    static fromTranspose(src, out) {
        const mat = src.clone(out);
        mat.transpose();
        return mat;
    }
    multiplyBy(other) {
        const a = this.data;
        const b = other.data;
        this.setValues(a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3], a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7], a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11], a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15], a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3], a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7], a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11], a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15], a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3], a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7], a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11], a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15], a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3], a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7], a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11], a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]);
    }
    static fromProduct(a, b, out) {
        const mat = a.clone(out);
        mat.multiplyBy(b);
        return mat;
    }
    multiplyByScalar(scalar) {
        for (let i = 0; i < this.data.length; i++) {
            this.data[i] *= scalar;
        }
    }
    get(index) { bentleyjs_core_1.assert(index < this.data.length); return this.data[index]; }
    set(index, value) { bentleyjs_core_1.assert(index < this.data.length); this.data[index] = value; }
    at(row, col) { return this.get(col * 4 + row); }
    setAt(row, col, value) { this.set(col * 4 + row, value); }
    get m00() { return this.at(0, 0); }
    set m00(value) { this.setAt(0, 0, value); }
    get m01() { return this.at(0, 1); }
    set m01(value) { this.setAt(0, 1, value); }
    get m02() { return this.at(0, 2); }
    set m02(value) { this.setAt(0, 2, value); }
    get m03() { return this.at(0, 3); }
    set m03(value) { this.setAt(0, 3, value); }
    get m10() { return this.at(1, 0); }
    set m10(value) { this.setAt(1, 0, value); }
    get m11() { return this.at(1, 1); }
    set m11(value) { this.setAt(1, 1, value); }
    get m12() { return this.at(1, 2); }
    set m12(value) { this.setAt(1, 2, value); }
    get m13() { return this.at(1, 3); }
    set m13(value) { this.setAt(1, 3, value); }
    get m20() { return this.at(2, 0); }
    set m20(value) { this.setAt(2, 0, value); }
    get m21() { return this.at(2, 1); }
    set m21(value) { this.setAt(2, 1, value); }
    get m22() { return this.at(2, 2); }
    set m22(value) { this.setAt(2, 2, value); }
    get m23() { return this.at(2, 3); }
    set m23(value) { this.setAt(2, 3, value); }
    get m30() { return this.at(3, 0); }
    set m30(value) { this.setAt(3, 0, value); }
    get m31() { return this.at(3, 1); }
    set m31(value) { this.setAt(3, 1, value); }
    get m32() { return this.at(3, 2); }
    set m32(value) { this.setAt(3, 2, value); }
    get m33() { return this.at(3, 3); }
    set m33(value) { this.setAt(3, 3, value); }
}
exports.Matrix4 = Matrix4;
// missing Vector3d functions
/** @internal */
function fromNormalizedCrossProduct(vec0, vec1) {
    return vec0.unitCrossProduct(vec1);
}
exports.fromNormalizedCrossProduct = fromNormalizedCrossProduct;
/** @internal */
function normalizedDifference(target, origin) {
    return geometry_core_1.Vector3d.createStartEnd(origin, target).normalize();
}
exports.normalizedDifference = normalizedDifference;


/***/ }),

/***/ "./lib/render/webgl/Mesh.js":
/*!**********************************!*\
  !*** ./lib/render/webgl/Mesh.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const EdgeOverrides_1 = __webpack_require__(/*! ./EdgeOverrides */ "./lib/render/webgl/EdgeOverrides.js");
const ColorInfo_1 = __webpack_require__(/*! ./ColorInfo */ "./lib/render/webgl/ColorInfo.js");
const Graphic_1 = __webpack_require__(/*! ./Graphic */ "./lib/render/webgl/Graphic.js");
const FeaturesInfo_1 = __webpack_require__(/*! ./FeaturesInfo */ "./lib/render/webgl/FeaturesInfo.js");
const VertexLUT_1 = __webpack_require__(/*! ./VertexLUT */ "./lib/render/webgl/VertexLUT.js");
const Primitive_1 = __webpack_require__(/*! ./Primitive */ "./lib/render/webgl/Primitive.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const Handle_1 = __webpack_require__(/*! ./Handle */ "./lib/render/webgl/Handle.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const InstancedGeometry_1 = __webpack_require__(/*! ./InstancedGeometry */ "./lib/render/webgl/InstancedGeometry.js");
/** @internal */
class MeshData {
    constructor(lut, params) {
        this.lut = lut;
        this.features = FeaturesInfo_1.FeaturesInfo.createFromVertexTable(params.vertices);
        this.texture = params.surface.texture;
        this.material = params.surface.material;
        this.type = params.surface.type;
        this.fillFlags = params.surface.fillFlags;
        this.isPlanar = params.isPlanar;
        this.hasBakedLighting = params.surface.hasBakedLighting;
        const edges = params.edges;
        this.edgeWidth = undefined !== edges ? edges.weight : 1;
        this.edgeLineCode = EdgeOverrides_1.LineCode.valueFromLinePixels(undefined !== edges ? edges.linePixels : imodeljs_common_1.LinePixels.Solid);
    }
    static create(params) {
        const lut = VertexLUT_1.VertexLUT.createFromVertexTable(params.vertices, params.auxChannels);
        return undefined !== lut ? new MeshData(lut, params) : undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.lut);
        if (undefined !== this.texture && undefined === this.texture.key && !this.texture.isOwned)
            this.texture.dispose();
    }
}
exports.MeshData = MeshData;
/** @internal */
class MeshGraphic extends Graphic_1.Graphic {
    constructor(data, params, instances) {
        super();
        this._primitives = [];
        this.meshData = data;
        this._instances = instances;
        this.addPrimitive(() => SurfaceGeometry.create(this.meshData, params.surface.indices), instances);
        // Classifiers are surfaces only...no edges.
        if (this.surfaceType === 4 /* VolumeClassifier */ || undefined === params.edges)
            return;
        const edges = params.edges;
        if (undefined !== edges.silhouettes)
            this.addPrimitive(() => SilhouetteEdgeGeometry.createSilhouettes(this.meshData, edges.silhouettes), instances);
        if (undefined !== edges.segments)
            this.addPrimitive(() => EdgeGeometry.create(this.meshData, edges.segments), instances);
        if (undefined !== edges.polylines)
            this.addPrimitive(() => PolylineEdgeGeometry.create(this.meshData, edges.polylines), instances);
    }
    static create(params, instances) {
        const buffers = undefined !== instances ? InstancedGeometry_1.InstanceBuffers.create(instances, true) : undefined;
        if (undefined === buffers && undefined !== instances)
            return undefined;
        const data = MeshData.create(params);
        return undefined !== data ? new MeshGraphic(data, params, buffers) : undefined;
    }
    addPrimitive(createGeom, instances) {
        const primitive = Primitive_1.Primitive.createShared(createGeom, instances);
        if (undefined !== primitive)
            this._primitives.push(primitive);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.meshData);
        for (const primitive of this._primitives)
            bentleyjs_core_1.dispose(primitive);
        this._primitives.length = 0;
    }
    collectStatistics(stats) {
        stats.addVertexTable(this.meshData.lut.bytesUsed);
        this._primitives.forEach((prim) => prim.collectStatistics(stats));
        // Only count the shared instance buffers once...
        if (undefined !== this._instances)
            this._instances.collectStatistics(stats);
    }
    addCommands(cmds) { this._primitives.forEach((prim) => prim.addCommands(cmds)); }
    addHiliteCommands(cmds, batch, pass) { this._primitives.forEach((prim) => prim.addHiliteCommands(cmds, batch, pass)); }
    setUniformFeatureIndices(id) {
        this.meshData.features = FeaturesInfo_1.FeaturesInfo.createUniform(id);
    }
    get surfaceType() { return this.meshData.type; }
}
exports.MeshGraphic = MeshGraphic;
/** Defines one aspect of the geometry of a mesh (surface or edges)
 * @internal
 */
class MeshGeometry extends CachedGeometry_1.LUTGeometry {
    get asMesh() { return this; }
    _getLineWeight(params) { return this.computeEdgeWeight(params); }
    // Convenience accessors...
    get edgeWidth() { return this.mesh.edgeWidth; }
    get edgeLineCode() { return this.mesh.edgeLineCode; }
    get featuresInfo() { return this.mesh.features; }
    get surfaceType() { return this.mesh.type; }
    get fillFlags() { return this.mesh.fillFlags; }
    get isPlanar() { return this.mesh.isPlanar; }
    get colorInfo() { return this.mesh.lut.colorInfo; }
    get uniformColor() { return this.colorInfo.isUniform ? this.colorInfo.uniform : undefined; }
    get texture() { return this.mesh.texture; }
    get hasBakedLighting() { return this.mesh.hasBakedLighting; }
    get lut() { return this.mesh.lut; }
    get hasScalarAnimation() { return this.mesh.lut.hasScalarAnimation; }
    constructor(mesh, numIndices) {
        super();
        this._numIndices = numIndices;
        this.mesh = mesh;
    }
    computeEdgeWeight(params) { return params.target.getEdgeWeight(params, this.edgeWidth); }
    computeEdgeLineCode(params) { return params.target.getEdgeLineCode(params, this.edgeLineCode); }
    computeEdgeColor(target) { return target.isEdgeColorOverridden ? target.edgeColor : this.colorInfo; }
    computeEdgePass(target) {
        const vf = target.currentViewFlags;
        if (imodeljs_common_1.RenderMode.SmoothShade === vf.renderMode && !vf.visibleEdges) {
            return 255 /* None */;
        }
        // Only want translucent edges in wireframe mode.
        const isTranslucent = imodeljs_common_1.RenderMode.Wireframe === vf.renderMode && vf.transparency && this.colorInfo.hasTranslucency;
        return isTranslucent ? 5 /* Translucent */ : 1 /* OpaqueLinear */;
    }
}
exports.MeshGeometry = MeshGeometry;
/** @internal */
class EdgeGeometry extends MeshGeometry {
    get asSurface() { return undefined; }
    get asEdge() { return this; }
    get asSilhouette() { return undefined; }
    static create(mesh, edges) {
        const indexBuffer = Handle_1.BufferHandle.createArrayBuffer(edges.indices.data);
        const endPointBuffer = Handle_1.BufferHandle.createArrayBuffer(edges.endPointAndQuadIndices);
        return undefined !== indexBuffer && undefined !== endPointBuffer ? new EdgeGeometry(indexBuffer, endPointBuffer, edges.indices.length, mesh) : undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._indices);
        bentleyjs_core_1.dispose(this._endPointAndQuadIndices);
    }
    collectStatistics(stats) {
        stats.addVisibleEdges(this._indices.bytesUsed + this._endPointAndQuadIndices.bytesUsed);
    }
    bindVertexArray(attr) {
        attr.enableArray(this._indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    _draw(numInstances) {
        this._indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        System_1.System.instance.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);
    }
    _wantWoWReversal(_target) { return true; }
    _getLineCode(params) { return this.computeEdgeLineCode(params); }
    getTechniqueId(_target) { return 4 /* Edge */; }
    getRenderPass(target) { return this.computeEdgePass(target); }
    get renderOrder() { return this.isPlanar ? 12 /* PlanarEdge */ : 4 /* Edge */; }
    getColor(target) { return this.computeEdgeColor(target); }
    get endPointAndQuadIndices() { return this._endPointAndQuadIndices; }
    constructor(indices, endPointAndQuadsIndices, numIndices, mesh) {
        super(mesh, numIndices);
        this._indices = indices;
        this._endPointAndQuadIndices = endPointAndQuadsIndices;
    }
}
exports.EdgeGeometry = EdgeGeometry;
/** @internal */
class SilhouetteEdgeGeometry extends EdgeGeometry {
    get asSilhouette() { return this; }
    static createSilhouettes(mesh, params) {
        const indexBuffer = Handle_1.BufferHandle.createArrayBuffer(params.indices.data);
        const endPointBuffer = Handle_1.BufferHandle.createArrayBuffer(params.endPointAndQuadIndices);
        const normalsBuffer = Handle_1.BufferHandle.createArrayBuffer(params.normalPairs);
        return undefined !== indexBuffer && undefined !== endPointBuffer && undefined !== normalsBuffer ? new SilhouetteEdgeGeometry(indexBuffer, endPointBuffer, normalsBuffer, params.indices.length, mesh) : undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._normalPairs);
        super.dispose();
    }
    collectStatistics(stats) {
        stats.addSilhouetteEdges(this._indices.bytesUsed + this._endPointAndQuadIndices.bytesUsed + this._normalPairs.bytesUsed);
    }
    getTechniqueId(_target) { return 5 /* SilhouetteEdge */; }
    get renderOrder() { return this.isPlanar ? 13 /* PlanarSilhouette */ : 5 /* Silhouette */; }
    get normalPairs() { return this._normalPairs; }
    constructor(indices, endPointAndQuadsIndices, normalPairs, numIndices, mesh) {
        super(indices, endPointAndQuadsIndices, numIndices, mesh);
        this._normalPairs = normalPairs;
    }
}
exports.SilhouetteEdgeGeometry = SilhouetteEdgeGeometry;
/** @internal */
class PolylineEdgeGeometry extends MeshGeometry {
    static create(mesh, polyline) {
        const buffers = CachedGeometry_1.PolylineBuffers.create(polyline);
        return undefined !== buffers ? new PolylineEdgeGeometry(polyline.indices.length, buffers, mesh) : undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._buffers);
    }
    collectStatistics(stats) {
        this._buffers.collectStatistics(stats, 3 /* PolylineEdges */);
    }
    _wantWoWReversal(_target) { return true; }
    _getLineWeight(params) { return this.computeEdgeWeight(params); }
    _getLineCode(params) { return this.computeEdgeLineCode(params); }
    getTechniqueId(_target) { return 1 /* Polyline */; }
    getRenderPass(target) { return this.computeEdgePass(target); }
    get renderOrder() { return this.isPlanar ? 12 /* PlanarEdge */ : 4 /* Edge */; }
    get polylineBuffers() { return this._buffers; }
    bindVertexArray(attr) {
        attr.enableArray(this._buffers.indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    _draw(numInstances) {
        const gl = System_1.System.instance;
        this._buffers.indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        gl.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);
    }
    constructor(numIndices, buffers, mesh) {
        super(mesh, numIndices);
        this._buffers = buffers;
    }
}
exports.PolylineEdgeGeometry = PolylineEdgeGeometry;
function wantMaterials(vf) { return vf.materials && imodeljs_common_1.RenderMode.SmoothShade === vf.renderMode; }
function wantLighting(vf) {
    return imodeljs_common_1.RenderMode.SmoothShade === vf.renderMode && (vf.sourceLights || vf.cameraLights || vf.solarLight);
}
/** @internal */
class SurfaceGeometry extends MeshGeometry {
    static create(mesh, indices) {
        const indexBuffer = Handle_1.BufferHandle.createArrayBuffer(indices.data);
        return undefined !== indexBuffer ? new SurfaceGeometry(indexBuffer, indices.length, mesh) : undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this._indices);
    }
    collectStatistics(stats) {
        stats.addSurface(this._indices.bytesUsed);
    }
    get isLit() { return 1 /* Lit */ === this.surfaceType || 3 /* TexturedLit */ === this.surfaceType; }
    get isTextured() { return 2 /* Textured */ === this.surfaceType || 3 /* TexturedLit */ === this.surfaceType; }
    get isGlyph() { return undefined !== this.texture && this.texture.isGlyph; }
    get isTileSection() { return undefined !== this.texture && this.texture.isTileSection; }
    get isClassifier() { return 4 /* VolumeClassifier */ === this.surfaceType; }
    get asSurface() { return this; }
    get asEdge() { return undefined; }
    get asSilhouette() { return undefined; }
    bindVertexArray(attr) {
        attr.enableArray(this._indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    _draw(numInstances) {
        const system = System_1.System.instance;
        const gl = system.context;
        const offset = 1 /* BlankingRegion */ === this.renderOrder;
        if (offset) {
            gl.enable(GL_1.GL.POLYGON_OFFSET_FILL);
            gl.polygonOffset(1.0, 1.0);
        }
        this._indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        system.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);
        if (offset) {
            gl.disable(GL_1.GL.POLYGON_OFFSET_FILL);
        }
    }
    getTechniqueId(_target) { return 0 /* Surface */; }
    get isLitSurface() { return this.isLit; }
    get hasBakedLighting() { return this.mesh.hasBakedLighting; }
    get renderOrder() {
        if (imodeljs_common_1.FillFlags.Behind === (this.fillFlags & imodeljs_common_1.FillFlags.Behind))
            return 1 /* BlankingRegion */;
        else
            return this.isPlanar ? 10 /* PlanarSurface */ : 2 /* Surface */;
    }
    getColor(target) {
        if (imodeljs_common_1.FillFlags.Background === (this.fillFlags & imodeljs_common_1.FillFlags.Background))
            return ColorInfo_1.ColorInfo.createUniform(target.bgColor);
        else
            return this.colorInfo;
    }
    getRenderPass(target) {
        if (this.isClassifier)
            return 4 /* Classification */;
        const mat = this.isLit ? this.mesh.material : undefined;
        const opaquePass = this.isPlanar ? 2 /* OpaquePlanar */ : 3 /* OpaqueGeneral */;
        const fillFlags = this.fillFlags;
        if (this.isGlyph && target.isReadPixelsInProgress)
            return opaquePass;
        const vf = target.currentViewFlags;
        if (imodeljs_common_1.RenderMode.Wireframe === vf.renderMode) {
            const showFill = imodeljs_common_1.FillFlags.Always === (fillFlags & imodeljs_common_1.FillFlags.Always) || (vf.fill && imodeljs_common_1.FillFlags.ByView === (fillFlags & imodeljs_common_1.FillFlags.ByView));
            if (!showFill) {
                return 255 /* None */;
            }
        }
        if (!this.isGlyph) {
            if (!vf.transparency || imodeljs_common_1.RenderMode.SolidFill === vf.renderMode || imodeljs_common_1.RenderMode.HiddenLine === vf.renderMode) {
                return opaquePass;
            }
        }
        if (undefined !== this.texture && this.wantTextures(target, true)) {
            if (this.texture.hasTranslucency)
                return 5 /* Translucent */;
            // material may have texture weight < 1 - if so must account for material or element alpha below
            if (undefined === mat || (mat.textureMapping !== undefined && mat.textureMapping.params.weight >= 1))
                return opaquePass;
        }
        const hasAlpha = (undefined !== mat && wantMaterials(vf) && mat.hasTranslucency) || this.getColor(target).hasTranslucency;
        return hasAlpha ? 5 /* Translucent */ : opaquePass;
    }
    _wantWoWReversal(target) {
        const fillFlags = this.fillFlags;
        if (imodeljs_common_1.FillFlags.None !== (fillFlags & imodeljs_common_1.FillFlags.Background))
            return false; // fill color explicitly from background
        if (imodeljs_common_1.FillFlags.None !== (fillFlags & imodeljs_common_1.FillFlags.Always))
            return true; // fill displayed even in wireframe
        const vf = target.currentViewFlags;
        if (imodeljs_common_1.RenderMode.Wireframe === vf.renderMode || vf.visibleEdges)
            return false; // never invert surfaces when edges are displayed
        if (this.isLit && wantLighting(vf))
            return false;
        // Don't invert white pixels of textures...
        return !this.wantTextures(target, this.isTextured);
    }
    get material() { return this.mesh.material; }
    computeSurfaceFlags(params) {
        const target = params.target;
        const vf = target.currentViewFlags;
        let flags = wantMaterials(vf) ? 0 /* None */ : 8 /* IgnoreMaterial */;
        if (this.isLit) {
            flags |= 4 /* HasNormals */;
            if (wantLighting(vf)) {
                flags |= 2 /* ApplyLighting */;
            }
            // Textured meshes store normal in place of color index.
            // Untextured lit meshes store normal where textured meshes would store UV coords.
            // Tell shader where to find normal.
            if (!this.isTextured) {
                flags |= 64 /* HasColorAndNormal */;
            }
        }
        if (this.wantTextures(target, this.isTextured)) {
            flags |= 1 /* HasTexture */;
        }
        switch (params.renderPass) {
            // NB: We need this for opaque pass due to SolidFill (must compute transparency, discard below threshold, render opaque at or above threshold)
            case 1 /* OpaqueLinear */:
            case 2 /* OpaquePlanar */:
            case 3 /* OpaqueGeneral */:
            case 5 /* Translucent */: {
                const mode = vf.renderMode;
                if (!this.isGlyph && (imodeljs_common_1.RenderMode.HiddenLine === mode || imodeljs_common_1.RenderMode.SolidFill === mode)) {
                    flags |= 16 /* TransparencyThreshold */;
                    if (imodeljs_common_1.RenderMode.HiddenLine === mode && imodeljs_common_1.FillFlags.Always !== (this.fillFlags & imodeljs_common_1.FillFlags.Always)) {
                        // fill flags test for text - doesn't render with bg fill in hidden line mode.
                        flags |= 32 /* BackgroundFill */;
                    }
                    break;
                }
            }
        }
        return flags;
    }
    constructor(indices, numIndices, mesh) {
        super(mesh, numIndices);
        this._indices = indices;
    }
    wantTextures(target, surfaceTextureExists) {
        if (this.hasScalarAnimation && undefined !== target.analysisTexture)
            return true;
        if (!surfaceTextureExists)
            return false;
        if (this.isGlyph) {
            return true;
        }
        const fill = this.fillFlags;
        const flags = target.currentViewFlags;
        // ###TODO need to distinguish between gradient fill and actual textures...
        switch (flags.renderMode) {
            case imodeljs_common_1.RenderMode.SmoothShade: return flags.textures;
            case imodeljs_common_1.RenderMode.Wireframe: return imodeljs_common_1.FillFlags.Always === (fill & imodeljs_common_1.FillFlags.Always) || (flags.fill && imodeljs_common_1.FillFlags.ByView === (fill & imodeljs_common_1.FillFlags.ByView));
            default: return imodeljs_common_1.FillFlags.Always === (fill & imodeljs_common_1.FillFlags.Always);
        }
    }
}
exports.SurfaceGeometry = SurfaceGeometry;


/***/ }),

/***/ "./lib/render/webgl/PlanarClassifier.js":
/*!**********************************************!*\
  !*** ./lib/render/webgl/PlanarClassifier.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const FrameBuffer_1 = __webpack_require__(/*! ./FrameBuffer */ "./lib/render/webgl/FrameBuffer.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/System.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./lib/render/webgl/Matrix.js");
const TileTree_1 = __webpack_require__(/*! ../../tile/TileTree */ "./lib/tile/TileTree.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const System_2 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const SceneCompositor_1 = __webpack_require__(/*! ./SceneCompositor */ "./lib/render/webgl/SceneCompositor.js");
const BranchState_1 = __webpack_require__(/*! ./BranchState */ "./lib/render/webgl/BranchState.js");
const Graphic_1 = __webpack_require__(/*! ./Graphic */ "./lib/render/webgl/Graphic.js");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "./lib/render/webgl/RenderState.js");
const DrawCommand_1 = __webpack_require__(/*! ./DrawCommand */ "./lib/render/webgl/DrawCommand.js");
const FloatRGBA_1 = __webpack_require__(/*! ./FloatRGBA */ "./lib/render/webgl/FloatRGBA.js");
class PlanarClassifierDrawArgs extends TileTree_1.Tile.DrawArgs {
    constructor(_classifierPlanes, _classifier, context, location, root, now, purgeOlderThan, clip) {
        super(context, location, root, now, purgeOlderThan, clip);
        this._classifierPlanes = _classifierPlanes;
        this._classifier = _classifier;
    }
    get frustumPlanes() { return this._classifierPlanes; }
    drawGraphics() {
        if (!this.graphics.isEmpty) {
            this._classifier.addGraphic(this.context.createBranch(this.graphics, this.location));
        }
    }
    static create(context, classifier, tileTree, planes) {
        const now = bentleyjs_core_1.BeTimePoint.now();
        const purgeOlderThan = now.minus(tileTree.expirationTime);
        return new PlanarClassifierDrawArgs(planes, classifier, context, tileTree.location.clone(), tileTree, now, purgeOlderThan, tileTree.clipVolume);
    }
}
/** @internal */
class PlanarClassifier extends System_1.RenderPlanarClassifier {
    constructor(_classifierProperties) {
        super();
        this._classifierProperties = _classifierProperties;
        this._projectionMatrix = new Matrix_1.Matrix4();
        this._graphics = [];
        this._width = 0;
        this._height = 0;
        this._baseBatchId = 0;
        this._anyHilited = false;
        this._plane = geometry_core_1.Plane3dByOriginAndUnitNormal.create(new geometry_core_1.Point3d(0, 0, 0), new geometry_core_1.Vector3d(0, 0, 1)); // TBD -- Support other planes - default to X-Y for now.
        this._postProjectionMatrix = geometry_core_1.Matrix4d.createRowValues(/* Row 1 */ 0, 1, 0, 0, /* Row 1 */ 0, 0, -1, 0, /* Row 3 */ 1, 0, 0, 0, /* Row 4 */ 0, 0, 0, 1);
        this._postProjectionMatrixNpc = geometry_core_1.Matrix4d.createRowValues(/* Row 1 */ 0, 1, 0, 0, /* Row 1 */ 0, 0, 1, 0, /* Row 3 */ 1, 0, 0, 0, /* Row 4 */ 0, 0, 0, 1);
    }
    get hiliteTexture() { return this._hiliteTexture; }
    get combinedTexture() { return this._combinedTexture; }
    get projectionMatrix() { return this._projectionMatrix; }
    get properties() { return this._classifierProperties; }
    get baseBatchId() { return this._baseBatchId; }
    get anyHilited() { return this._anyHilited; }
    get insideDisplay() { return this._classifierProperties.flags.inside; }
    get outsideDisplay() { return this._classifierProperties.flags.outside; }
    addGraphic(graphic) { this._graphics.push(graphic); }
    static create(properties, tileTree, classifiedModel, sceneContext) {
        const classifier = new PlanarClassifier(properties);
        classifier.collectGraphics(sceneContext, classifiedModel, tileTree);
        return classifier;
    }
    collectStatistics(stats) {
        if (undefined !== this._colorTexture)
            stats.addPlanarClassifier(this._colorTexture.bytesUsed);
        if (undefined !== this._featureTexture)
            stats.addPlanarClassifier(this._featureTexture.bytesUsed);
        if (undefined !== this._hiliteTexture)
            stats.addPlanarClassifier(this._hiliteTexture.bytesUsed);
    }
    dispose() {
        this._colorTexture = bentleyjs_core_1.dispose(this._colorTexture);
        this._featureTexture = bentleyjs_core_1.dispose(this._featureTexture);
        this._hiliteTexture = bentleyjs_core_1.dispose(this._hiliteTexture);
        this._fbo = bentleyjs_core_1.dispose(this._fbo);
        this._hiliteFbo = bentleyjs_core_1.dispose(this._hiliteFbo);
    }
    push(exec) {
        if (undefined !== this._colorTexture)
            exec.target.planarClassifiers.push(this);
    }
    pop(target) {
        if (undefined !== this._colorTexture)
            target.planarClassifiers.pop();
    }
    pushBatches(batchState, graphics) {
        graphics.forEach((graphic) => {
            if (graphic instanceof Graphic_1.Batch) {
                batchState.push(graphic, true);
                batchState.pop();
            }
            else if (graphic instanceof Graphic_1.Branch) {
                const branch = graphic;
                this.pushBatches(batchState, branch.branch.entries);
            }
        });
    }
    pushBatchState(batchState) {
        this._baseBatchId = batchState.nextBatchId - 1;
        if (undefined !== this._graphics)
            this.pushBatches(batchState, this._graphics);
    }
    collectGraphics(context, classifiedModel, tileTree) {
        const classifierZ = this._plane.getNormalRef();
        if (undefined === context.viewFrustum)
            return;
        const viewState = context.viewFrustum.view;
        if (undefined === viewState)
            return;
        const viewX = context.viewFrustum.rotation.rowX();
        const viewZ = context.viewFrustum.rotation.rowZ();
        const minCrossMagnitude = 1.0E-4;
        if (viewZ === undefined)
            return; // View without depth?....
        let classifierX = viewZ.crossProduct(classifierZ);
        let classifierY;
        if (classifierX.magnitude() < minCrossMagnitude) {
            classifierY = viewX.crossProduct(classifierZ);
            classifierX = classifierY.crossProduct(classifierZ).normalize();
        }
        else {
            classifierX.normalizeInPlace();
            classifierY = classifierZ.crossProduct(classifierX).normalize();
        }
        const frustumX = classifierZ, frustumY = classifierX, frustumZ = classifierY;
        const classifierMatrix = geometry_core_1.Matrix3d.createRows(frustumX, frustumY, frustumZ);
        const classifierTransform = geometry_core_1.Transform.createRefs(geometry_core_1.Point3d.createZero(), classifierMatrix);
        let npcRange = geometry_core_1.Range3d.createXYZXYZ(0, 0, 0, 1, 1, 1);
        const viewFrustum = context.viewFrustum.getFrustum();
        const viewMap = viewFrustum.toMap4d();
        const viewPlanes = new imodeljs_common_1.FrustumPlanes(viewFrustum);
        if (classifiedModel && classifiedModel.tileTree) {
            const tileRange = geometry_core_1.Range3d.createNull();
            classifiedModel.tileTree.accumlateTransformedRange(tileRange, viewMap.transform0, viewPlanes);
            if (undefined === tileRange)
                return;
            npcRange = npcRange.intersect(tileRange);
        }
        PlanarClassifier._scratchFrustum.initFromRange(npcRange);
        viewMap.transform1.multiplyPoint3dArrayQuietNormalize(PlanarClassifier._scratchFrustum.points);
        const range = geometry_core_1.Range3d.createTransformedArray(classifierTransform, PlanarClassifier._scratchFrustum.points);
        range.low.x = Math.min(range.low.x, -.0001); // Always include classification plane.
        range.high.x = Math.max(range.high.x, .0001);
        this._frustum = imodeljs_common_1.Frustum.fromRange(range);
        if (viewState.isCameraOn) {
            const projectionRay = geometry_core_1.Ray3d.create(viewState.getEyePoint(), viewZ.crossProduct(classifierX).normalize());
            const projectionDistance = projectionRay.intersectionWithPlane(this._plane);
            if (undefined !== projectionDistance) {
                const eyePoint = classifierTransform.multiplyPoint3d(projectionRay.fractionToPoint(projectionDistance));
                const near = Math.max(.01, eyePoint.z - range.high.z);
                const far = eyePoint.z - range.low.z;
                const minFraction = 1.0 / 50.0;
                const fraction = Math.max(minFraction, near / far);
                for (let i = imodeljs_common_1.Npc.LeftBottomFront; i <= imodeljs_common_1.Npc.RightTopFront; i++) {
                    const frustumPoint = this._frustum.points[i];
                    frustumPoint.x = frustumPoint.x * fraction;
                    frustumPoint.y = eyePoint.y + (frustumPoint.y - eyePoint.y) * fraction;
                }
            }
        }
        classifierMatrix.transposeInPlace();
        classifierMatrix.multiplyVectorArrayInPlace(this._frustum.points);
        const frustumMap = this._frustum.toMap4d();
        if (undefined === frustumMap) {
            bentleyjs_core_1.assert(false);
            return;
        }
        this._projectionMatrix.initFromMatrix4d(this._postProjectionMatrixNpc.multiplyMatrixMatrix(frustumMap.transform0));
        const drawArgs = PlanarClassifierDrawArgs.create(context, this, tileTree, new imodeljs_common_1.FrustumPlanes(this._frustum));
        tileTree.draw(drawArgs);
    }
    draw(target) {
        if (undefined === this._frustum) {
            bentleyjs_core_1.assert(false);
            return;
        }
        if (this._graphics === undefined)
            return;
        const requiredHeight = 2 * Math.max(target.viewRect.width, target.viewRect.height);
        const requiredWidth = requiredHeight;
        if (requiredWidth !== this._width || requiredHeight !== this._height)
            this.dispose();
        this._width = requiredWidth;
        this._height = requiredHeight;
        const useMRT = System_2.System.instance.capabilities.supportsDrawBuffers;
        if (undefined === this._fbo) {
            const colorTextureHandle = Texture_1.TextureHandle.createForAttachment(this._width, this._height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
            const featureTextureHandle = Texture_1.TextureHandle.createForAttachment(this._width, this._height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
            const combinedTextureHandle = Texture_1.TextureHandle.createForAttachment(this._width, 2 * this._height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
            if (undefined === colorTextureHandle ||
                undefined === featureTextureHandle ||
                undefined === combinedTextureHandle) {
                bentleyjs_core_1.assert(false, "Failed to create planar classifier texture");
                return;
            }
            this._colorTexture = new Texture_1.Texture(new imodeljs_common_1.RenderTexture.Params(undefined, 2 /* TileSection */, true), colorTextureHandle);
            this._featureTexture = new Texture_1.Texture(new imodeljs_common_1.RenderTexture.Params(undefined, 2 /* TileSection */, true), featureTextureHandle);
            this._combinedTexture = new Texture_1.Texture(new imodeljs_common_1.RenderTexture.Params(undefined, 2 /* TileSection */, true), combinedTextureHandle);
            if (useMRT)
                this._fbo = FrameBuffer_1.FrameBuffer.create([colorTextureHandle, featureTextureHandle]);
            else {
                this._fbo = FrameBuffer_1.FrameBuffer.create([colorTextureHandle]);
                this._featureFbo = FrameBuffer_1.FrameBuffer.create([featureTextureHandle]);
            }
            this._combinedFbo = FrameBuffer_1.FrameBuffer.create([combinedTextureHandle]);
        }
        if (undefined === this._fbo || (!useMRT && undefined === this._featureFbo)) {
            bentleyjs_core_1.assert(false, "unable to create frame buffer objects");
            return;
        }
        const prevState = System_2.System.instance.currentRenderState.clone();
        System_2.System.instance.context.viewport(0, 0, this._width, this._height);
        const state = new RenderState_1.RenderState();
        state.flags.depthMask = false;
        state.flags.blend = false;
        state.flags.depthTest = false;
        const viewFlags = target.currentViewFlags.clone();
        viewFlags.renderMode = imodeljs_common_1.RenderMode.SmoothShade;
        viewFlags.transparency = false;
        viewFlags.textures = false;
        viewFlags.sourceLights = false;
        viewFlags.cameraLights = false;
        viewFlags.solarLight = false;
        viewFlags.shadows = false;
        viewFlags.noGeometryMap = true;
        viewFlags.monochrome = false;
        viewFlags.materials = false;
        viewFlags.ambientOcclusion = false;
        viewFlags.visibleEdges = viewFlags.hiddenEdges = false;
        const batchState = new BranchState_1.BatchState();
        System_2.System.instance.applyRenderState(state);
        const prevPlan = target.plan;
        const prevBgColor = FloatRGBA_1.FloatRgba.fromColorDef(imodeljs_common_1.ColorDef.white);
        prevBgColor.setFromFloatRgba(target.bgColor);
        target.bgColor.setFromColorDef(imodeljs_common_1.ColorDef.from(0, 0, 0, 255)); // Avoid white on white reversal.
        target.changeFrustum(this._frustum, this._frustum.getFraction(), true);
        target.projectionMatrix.setFrom(this._postProjectionMatrix.multiplyMatrixMatrix(target.projectionMatrix));
        target.branchStack.setViewFlags(viewFlags);
        const renderCommands = new DrawCommand_1.RenderCommands(target, new BranchState_1.BranchStack(), batchState);
        renderCommands.addGraphics(this._graphics);
        const system = System_2.System.instance;
        const gl = system.context;
        if (undefined !== this._featureFbo) {
            system.frameBufferStack.execute(this._fbo, true, () => {
                gl.clearColor(0, 0, 0, 0);
                gl.clear(GL_1.GL.BufferBit.Color);
                target.compositor.currentRenderTargetIndex = 0;
                target.techniques.execute(target, renderCommands.getCommands(2 /* OpaquePlanar */), 15 /* PlanarClassification */); // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.
            });
            system.frameBufferStack.execute(this._featureFbo, true, () => {
                gl.clearColor(0, 0, 0, 0);
                gl.clear(GL_1.GL.BufferBit.Color);
                target.compositor.currentRenderTargetIndex = 1;
                target.techniques.execute(target, renderCommands.getCommands(2 /* OpaquePlanar */), 15 /* PlanarClassification */); // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.
            });
        }
        else {
            system.frameBufferStack.execute(this._fbo, true, () => {
                const clearPickAndColor = CachedGeometry_1.ViewportQuadGeometry.create(18 /* ClearPickAndColor */);
                target.techniques.draw(SceneCompositor_1.getDrawParams(target, clearPickAndColor));
                target.techniques.execute(target, renderCommands.getCommands(2 /* OpaquePlanar */), 15 /* PlanarClassification */); // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.
            });
        }
        // Create combined texture with color followed by featureIds.
        system.frameBufferStack.execute(this._combinedFbo, true, () => {
            gl.clearColor(0, 0, 0, 0);
            const combineTextures = CachedGeometry_1.CombineTexturesGeometry.createGeometry(this._colorTexture.texture.getHandle(), this._featureTexture.texture.getHandle());
            target.techniques.draw(SceneCompositor_1.getDrawParams(target, combineTextures));
        });
        const hiliteCommands = renderCommands.getCommands(7 /* Hilite */);
        if (false !== (this._anyHilited = 0 !== hiliteCommands.length)) {
            if (undefined === this._hiliteFbo) {
                const hiliteTextureHandle = Texture_1.TextureHandle.createForAttachment(this._width, this._height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
                this._hiliteTexture = new Texture_1.Texture(new imodeljs_common_1.RenderTexture.Params(undefined, 2 /* TileSection */, true), hiliteTextureHandle);
                if (undefined === hiliteTextureHandle || undefined === (this._hiliteFbo = FrameBuffer_1.FrameBuffer.create([hiliteTextureHandle]))) {
                    bentleyjs_core_1.assert(false, "Failed to create planar classifier hilite texture");
                    return;
                }
            }
            system.frameBufferStack.execute(this._hiliteFbo, true, () => {
                gl.clearColor(0, 0, 0, 0);
                gl.clear(GL_1.GL.BufferBit.Color);
                target.techniques.execute(target, hiliteCommands, 7 /* Hilite */);
            });
        }
        // Create combined texture with color followed by featureIds.  We do this to conserve texture units - could use color and feature textures directly otherwise.
        System_2.System.instance.context.viewport(0, 0, this._width, 2 * this._height);
        system.frameBufferStack.execute(this._combinedFbo, true, () => {
            gl.clearColor(0, 0, 0, 0);
            const combineTextures = CachedGeometry_1.CombineTexturesGeometry.createGeometry(this._colorTexture.texture.getHandle(), this._featureTexture.texture.getHandle());
            target.techniques.draw(SceneCompositor_1.getDrawParams(target, combineTextures));
        });
        batchState.reset(); // Reset the batch Ids...
        target.bgColor.setFromFloatRgba(prevBgColor);
        if (prevPlan)
            target.changeRenderPlan(prevPlan);
        system.applyRenderState(prevState);
        gl.viewport(0, 0, target.viewRect.width, target.viewRect.height); // Restore viewport
    }
}
PlanarClassifier._scratchFrustum = new imodeljs_common_1.Frustum();
exports.PlanarClassifier = PlanarClassifier;


/***/ }),

/***/ "./lib/render/webgl/PointCloud.js":
/*!****************************************!*\
  !*** ./lib/render/webgl/PointCloud.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const FeaturesInfo_1 = __webpack_require__(/*! ./FeaturesInfo */ "./lib/render/webgl/FeaturesInfo.js");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const Handle_1 = __webpack_require__(/*! ./Handle */ "./lib/render/webgl/Handle.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
class PointCloudGeometry extends CachedGeometry_1.CachedGeometry {
    constructor(pointCloud) {
        super();
        this._colorHandle = undefined;
        this._vertices = Handle_1.QBufferHandle3d.create(pointCloud.pointParams, pointCloud.points);
        this._vertexCount = pointCloud.points.length / 3;
        this.features = FeaturesInfo_1.FeaturesInfo.create(pointCloud.features);
        if (undefined !== pointCloud.colors)
            this._colorHandle = Handle_1.BufferHandle.createArrayBuffer(pointCloud.colors);
    }
    dispose() { bentleyjs_core_1.dispose(this._vertices); }
    collectStatistics(stats) {
        const bytesUsed = this._vertices.bytesUsed + (undefined !== this._colorHandle ? this._colorHandle.bytesUsed : 0);
        stats.addPointCloud(bytesUsed);
    }
    _wantWoWReversal(_target) { return false; }
    getTechniqueId(_target) { return 2 /* PointCloud */; }
    getRenderPass(_target) { return 3 /* OpaqueGeneral */; }
    get renderOrder() { return 2 /* Surface */; }
    get qOrigin() { return this._vertices.origin; }
    get qScale() { return this._vertices.scale; }
    get colors() { return this._colorHandle; }
    get featuresInfo() { return this.features; }
    get hasBakedLighting() { return true; }
    bindVertexArray(attr) { attr.enableArray(this._vertices, 3, GL_1.GL.DataType.UnsignedShort, false, 0, 0); }
    draw() {
        const gl = System_1.System.instance.context;
        gl.drawArrays(GL_1.GL.PrimitiveType.Points, 0, this._vertexCount);
    }
}
exports.PointCloudGeometry = PointCloudGeometry;


/***/ }),

/***/ "./lib/render/webgl/PointString.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/PointString.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const VertexLUT_1 = __webpack_require__(/*! ./VertexLUT */ "./lib/render/webgl/VertexLUT.js");
const FeaturesInfo_1 = __webpack_require__(/*! ./FeaturesInfo */ "./lib/render/webgl/FeaturesInfo.js");
const Handle_1 = __webpack_require__(/*! ./Handle */ "./lib/render/webgl/Handle.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
/** @internal */
class PointStringGeometry extends CachedGeometry_1.LUTGeometry {
    constructor(indices, numIndices, lut, qparams, weight, features) {
        super();
        this.numIndices = numIndices;
        this.indices = indices;
        this.lut = lut;
        this.vertexParams = qparams;
        this.weight = weight;
        this.features = features;
    }
    _wantWoWReversal(_target) { return true; }
    getTechniqueId(_target) { return 3 /* PointString */; }
    getRenderPass(_target) { return 1 /* OpaqueLinear */; }
    get featuresInfo() { return this.features; }
    get renderOrder() { return 11 /* PlanarLinear */; }
    bindVertexArray(attr) {
        attr.enableArray(this.indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    _getLineWeight(_params) { return this.weight; }
    _draw(numInstances) {
        const gl = System_1.System.instance;
        this.indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        gl.drawArrays(GL_1.GL.PrimitiveType.Points, 0, this.numIndices, numInstances);
    }
    static create(params) {
        const indices = Handle_1.BufferHandle.createArrayBuffer(params.indices.data);
        if (undefined === indices)
            return undefined;
        const lut = VertexLUT_1.VertexLUT.createFromVertexTable(params.vertices);
        if (undefined === lut)
            return undefined;
        return new PointStringGeometry(indices, params.indices.length, lut, params.vertices.qparams, params.weight, FeaturesInfo_1.FeaturesInfo.createFromVertexTable(params.vertices));
    }
    dispose() {
        bentleyjs_core_1.dispose(this.lut);
        bentleyjs_core_1.dispose(this.indices);
    }
    collectStatistics(stats) {
        stats.addVertexTable(this.lut.bytesUsed);
        stats.addPointString(this.indices.bytesUsed);
    }
}
exports.PointStringGeometry = PointStringGeometry;


/***/ }),

/***/ "./lib/render/webgl/Polyline.js":
/*!**************************************!*\
  !*** ./lib/render/webgl/Polyline.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const FeaturesInfo_1 = __webpack_require__(/*! ./FeaturesInfo */ "./lib/render/webgl/FeaturesInfo.js");
const EdgeOverrides_1 = __webpack_require__(/*! ./EdgeOverrides */ "./lib/render/webgl/EdgeOverrides.js");
const VertexLUT_1 = __webpack_require__(/*! ./VertexLUT */ "./lib/render/webgl/VertexLUT.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** @internal */
class PolylineGeometry extends CachedGeometry_1.LUTGeometry {
    constructor(lut, buffers, params) {
        super();
        this.vertexParams = params.vertices.qparams;
        this.features = FeaturesInfo_1.FeaturesInfo.createFromVertexTable(params.vertices);
        this.lineWeight = params.weight;
        this.lineCode = EdgeOverrides_1.LineCode.valueFromLinePixels(params.linePixels);
        this.type = params.type;
        this._isPlanar = params.isPlanar;
        this.lut = lut;
        this.numIndices = params.polyline.indices.length;
        this._buffers = buffers;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.lut);
        bentleyjs_core_1.dispose(this._buffers);
    }
    collectStatistics(stats) {
        this._buffers.collectStatistics(stats, 4 /* Polylines */);
        stats.addVertexTable(this.lut.bytesUsed);
    }
    get isAnyEdge() { return imodeljs_common_1.PolylineTypeFlags.Normal !== this.type; }
    get isNormalEdge() { return imodeljs_common_1.PolylineTypeFlags.Edge === this.type; }
    get isOutlineEdge() { return imodeljs_common_1.PolylineTypeFlags.Outline === this.type; }
    get renderOrder() {
        if (this.isAnyEdge)
            return this.isPlanar ? 12 /* PlanarEdge */ : 4 /* Edge */;
        else
            return this.isPlanar ? 11 /* PlanarLinear */ : 3 /* Linear */;
    }
    _wantWoWReversal(_target) { return true; }
    get polylineBuffers() { return this._buffers; }
    _computeEdgePass(target, colorInfo) {
        const vf = target.currentViewFlags;
        if (imodeljs_common_1.RenderMode.SmoothShade === vf.renderMode && !vf.visibleEdges)
            return 255 /* None */;
        // Only want to return Translucent for edges if rendering in Wireframe mode ###TODO: what about overrides?
        const isTranslucent = imodeljs_common_1.RenderMode.Wireframe === vf.renderMode && vf.transparency && colorInfo.hasTranslucency;
        return isTranslucent ? 5 /* Translucent */ : 1 /* OpaqueLinear */;
    }
    getRenderPass(target) {
        const vf = target.currentViewFlags;
        if (this.isEdge) {
            let pass = this._computeEdgePass(target, this.lut.colorInfo);
            // Only display the outline in wireframe if Fill is off...
            if (255 /* None */ !== pass && this.isOutlineEdge && imodeljs_common_1.RenderMode.Wireframe === vf.renderMode && vf.fill)
                pass = 255 /* None */;
            return pass;
        }
        const isTranslucent = vf.transparency && this.lut.colorInfo.hasTranslucency;
        return isTranslucent ? 5 /* Translucent */ : 1 /* OpaqueLinear */;
    }
    getTechniqueId(_target) { return 1 /* Polyline */; }
    get isPlanar() { return this._isPlanar; }
    get isEdge() { return this.isAnyEdge; }
    get qOrigin() { return this.lut.qOrigin; }
    get qScale() { return this.lut.qScale; }
    get numRgbaPerVertex() { return this.lut.numRgbaPerVertex; }
    get featuresInfo() { return this.features; }
    _getLineWeight(params) {
        return this.isEdge ? params.target.getEdgeWeight(params, this.lineWeight) : this.lineWeight;
    }
    _getLineCode(params) {
        return this.isEdge ? params.target.getEdgeLineCode(params, this.lineCode) : this.lineCode;
    }
    getColor(target) { return this.isEdge && target.isEdgeColorOverridden ? target.edgeColor : this.lut.colorInfo; }
    bindVertexArray(attr) {
        attr.enableArray(this._buffers.indices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
    }
    _draw(numInstances) {
        const gl = System_1.System.instance;
        this._buffers.indices.bind(GL_1.GL.Buffer.Target.ArrayBuffer);
        gl.drawArrays(GL_1.GL.PrimitiveType.Triangles, 0, this.numIndices, numInstances);
    }
    static create(params) {
        const lut = VertexLUT_1.VertexLUT.createFromVertexTable(params.vertices);
        if (undefined === lut)
            return undefined;
        const buffers = CachedGeometry_1.PolylineBuffers.create(params.polyline);
        if (undefined === buffers)
            return undefined;
        return new PolylineGeometry(lut, buffers, params);
    }
}
exports.PolylineGeometry = PolylineGeometry;


/***/ }),

/***/ "./lib/render/webgl/Primitive.js":
/*!***************************************!*\
  !*** ./lib/render/webgl/Primitive.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const Graphic_1 = __webpack_require__(/*! ./Graphic */ "./lib/render/webgl/Graphic.js");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const DrawCommand_1 = __webpack_require__(/*! ./DrawCommand */ "./lib/render/webgl/DrawCommand.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const InstancedGeometry_1 = __webpack_require__(/*! ./InstancedGeometry */ "./lib/render/webgl/InstancedGeometry.js");
/** @internal */
class Primitive extends Graphic_1.Graphic {
    constructor(cachedGeom) {
        super();
        this.isPixelMode = false;
        this.cachedGeometry = cachedGeom;
    }
    static create(createGeom, instances) {
        const instanceBuffers = undefined !== instances ? InstancedGeometry_1.InstanceBuffers.create(instances, false) : undefined;
        if (undefined === instanceBuffers && undefined !== instances)
            return undefined;
        return this.createShared(createGeom, instanceBuffers);
    }
    static createShared(createGeom, instances) {
        let geom = createGeom();
        if (undefined === geom)
            return undefined;
        if (undefined !== instances) {
            bentleyjs_core_1.assert(geom instanceof CachedGeometry_1.LUTGeometry, "Invalid geometry type for instancing");
            geom = new InstancedGeometry_1.InstancedGeometry(geom, true, instances);
            // Ensure range computed immediately so we can discard the Float32Array holding the instance transforms...
            geom.computeRange();
        }
        return undefined !== geom ? new this(geom) : undefined;
    }
    dispose() {
        bentleyjs_core_1.dispose(this.cachedGeometry);
    }
    collectStatistics(stats) {
        this.cachedGeometry.collectStatistics(stats);
    }
    getRenderPass(target) {
        if (this.isPixelMode)
            return 9 /* ViewOverlay */;
        switch (target.primitiveVisibility) {
            case 2 /* Uninstanced */:
                if (this.cachedGeometry.isInstanced)
                    return 255 /* None */;
                break;
            case 1 /* Instanced */:
                if (!this.cachedGeometry.isInstanced)
                    return 255 /* None */;
                break;
        }
        return this.cachedGeometry.getRenderPass(target);
    }
    get featureIndexType() {
        const feature = this.cachedGeometry.featuresInfo;
        return undefined !== feature ? feature.type : imodeljs_common_1.FeatureIndexType.Empty;
    }
    get usesMaterialColor() {
        const materialData = this.cachedGeometry.material;
        return undefined !== materialData && (materialData.overridesRgb || materialData.overridesAlpha);
    }
    addCommands(commands) { commands.addPrimitive(this); }
    addHiliteCommands(commands, batch, pass) {
        // Edges do not contribute to hilite pass.
        // Note that IsEdge() does not imply geom->ToEdge() => true...polylines can be edges too...
        if (!this.isEdge) {
            commands.getCommands(pass).push(DrawCommand_1.DrawCommand.createForPrimitive(this, batch));
        }
    }
    setUniformFeatureIndices(featId) { this.cachedGeometry.uniformFeatureIndices = featId; }
    get hasAnimation() { return this.cachedGeometry.hasAnimation; }
    get isInstanced() { return this.cachedGeometry.isInstanced; }
    get isLit() { return this.cachedGeometry.isLitSurface; }
    get isEdge() { return this.cachedGeometry.isEdge; }
    get renderOrder() { return this.cachedGeometry.renderOrder; }
    toPrimitive() { return this; }
    draw(shader) {
        // ###TODO: local to world should be pushed before we're invoked...we shouldn't need to pass (or copy) it
        if (undefined === Primitive._drawParams)
            Primitive._drawParams = new DrawCommand_1.DrawParams();
        const drawParams = Primitive._drawParams;
        drawParams.init(shader.params, this.cachedGeometry, shader.target.currentTransform, shader.renderPass);
        shader.draw(drawParams);
    }
    getTechniqueId(target) { return this.cachedGeometry.getTechniqueId(target); }
}
exports.Primitive = Primitive;
/** @internal */
class SkyCubePrimitive extends Primitive {
    constructor(cachedGeom) { super(cachedGeom); }
    draw(shader) {
        // Alter viewport to maintain square aspect ratio of skybox images even as viewRect resizes
        const vh = shader.target.viewRect.height;
        const vw = shader.target.viewRect.width;
        if (vw > vh)
            System_1.System.instance.context.viewport(0, -(vw - vh) / 2, vw, vw);
        else
            System_1.System.instance.context.viewport(-(vh - vw) / 2, 0, vh, vh);
        super.draw(shader); // Draw the skybox cubemap
        System_1.System.instance.context.viewport(0, 0, vw, vh); // Restore viewport
    }
}
exports.SkyCubePrimitive = SkyCubePrimitive;
/** @internal */
class SkySpherePrimitive extends Primitive {
    constructor(cachedGeom) { super(cachedGeom); }
    draw(shader) {
        super.draw(shader); // Draw the skybox sphere
    }
}
exports.SkySpherePrimitive = SkySpherePrimitive;


/***/ }),

/***/ "./lib/render/webgl/RenderBuffer.js":
/*!******************************************!*\
  !*** ./lib/render/webgl/RenderBuffer.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
/** @internal */
class RenderBuffer {
    getHandle() { return this._glBuffer; }
    static create(width, height, format = GL_1.GL.RenderBuffer.Format.DepthComponent16) {
        const gl = System_1.System.instance.context;
        const glBuffer = gl.createRenderbuffer();
        if (null === glBuffer) {
            return undefined;
        }
        bentleyjs_core_1.assert(0 < width && 0 < height);
        RenderBuffer.bindBuffer(glBuffer);
        gl.renderbufferStorage(GL_1.GL.RenderBuffer.TARGET, format, width, height);
        RenderBuffer.unbind();
        return new RenderBuffer(glBuffer);
    }
    get isDisposed() { return this._glBuffer === undefined || this._glBuffer === null; }
    dispose() {
        if (!this.isDisposed) {
            System_1.System.instance.context.deleteRenderbuffer(this._glBuffer);
            this._glBuffer = undefined;
        }
    }
    bind() {
        bentleyjs_core_1.assert(undefined !== this._glBuffer);
        if (undefined !== this._glBuffer) {
            RenderBuffer.bindBuffer(this._glBuffer);
        }
    }
    constructor(glBuffer) { this._glBuffer = glBuffer; }
    static bindBuffer(glBuffer) { System_1.System.instance.context.bindRenderbuffer(GL_1.GL.RenderBuffer.TARGET, glBuffer); }
    static unbind() { this.bindBuffer(null); }
}
exports.RenderBuffer = RenderBuffer;


/***/ }),

/***/ "./lib/render/webgl/RenderFlags.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/RenderFlags.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
// tslint:disable:no-const-enum
Object.defineProperty(exports, "__esModule", { value: true });
/** Reserved texture units for specific sampler variables, to avoid conflicts between shader components which each have their own textures.
 * @internal
 */
var TextureUnit;
(function (TextureUnit) {
    // For shaders which know exactly which textures will be used
    TextureUnit[TextureUnit["Zero"] = WebGLRenderingContext.TEXTURE0] = "Zero";
    TextureUnit[TextureUnit["One"] = WebGLRenderingContext.TEXTURE1] = "One";
    TextureUnit[TextureUnit["Two"] = WebGLRenderingContext.TEXTURE2] = "Two";
    TextureUnit[TextureUnit["Three"] = WebGLRenderingContext.TEXTURE3] = "Three";
    TextureUnit[TextureUnit["Four"] = WebGLRenderingContext.TEXTURE4] = "Four";
    TextureUnit[TextureUnit["Five"] = WebGLRenderingContext.TEXTURE5] = "Five";
    TextureUnit[TextureUnit["Six"] = WebGLRenderingContext.TEXTURE6] = "Six";
    TextureUnit[TextureUnit["Seven"] = WebGLRenderingContext.TEXTURE7] = "Seven";
    TextureUnit[TextureUnit["ClipVolume"] = TextureUnit.Zero] = "ClipVolume";
    TextureUnit[TextureUnit["FeatureSymbology"] = TextureUnit.One] = "FeatureSymbology";
    TextureUnit[TextureUnit["SurfaceTexture"] = TextureUnit.Two] = "SurfaceTexture";
    TextureUnit[TextureUnit["LineCode"] = TextureUnit.Two] = "LineCode";
    TextureUnit[TextureUnit["PickFeatureId"] = TextureUnit.Three] = "PickFeatureId";
    TextureUnit[TextureUnit["PickDepthAndOrder"] = TextureUnit.Four] = "PickDepthAndOrder";
    TextureUnit[TextureUnit["VertexLUT"] = TextureUnit.Five] = "VertexLUT";
    TextureUnit[TextureUnit["AuxChannelLUT"] = TextureUnit.Six] = "AuxChannelLUT";
    TextureUnit[TextureUnit["PlanarClassification"] = TextureUnit.Six] = "PlanarClassification";
    TextureUnit[TextureUnit["PlanarClassificationHilite"] = TextureUnit.Six] = "PlanarClassificationHilite";
    TextureUnit[TextureUnit["ShadowMap"] = TextureUnit.Seven] = "ShadowMap";
})(TextureUnit = exports.TextureUnit || (exports.TextureUnit = {}));
/** @internal */
function isPlanar(order) { return order >= 8 /* PlanarBit */; }
exports.isPlanar = isPlanar;
/** @internal */
function isSurface(order) { return order <= 2 /* Surface */ || order === 10 /* PlanarSurface */; }
exports.isSurface = isSurface;


/***/ }),

/***/ "./lib/render/webgl/RenderState.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/RenderState.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
/** @internal */
class RenderStateFlags {
    constructor(src) {
        this.cull = false;
        this.depthTest = false;
        this.blend = false;
        this.stencilTest = false;
        this.depthMask = true;
        this.colorWrite = true;
        if (src) {
            this.copyFrom(src);
        }
    }
    copyFrom(src) {
        this.cull = src.cull;
        this.depthTest = src.depthTest;
        this.blend = src.blend;
        this.stencilTest = src.stencilTest;
        this.depthMask = src.depthMask;
        this.colorWrite = src.colorWrite;
    }
    clone(result) {
        if (!result) {
            return new RenderStateFlags(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    equals(rhs) {
        return this.cull === rhs.cull
            && this.depthTest === rhs.depthTest
            && this.blend === rhs.blend
            && this.stencilTest === rhs.stencilTest
            && this.depthMask === rhs.depthMask
            && this.colorWrite === rhs.colorWrite;
    }
    apply(previousFlags) {
        RenderStateFlags.enableOrDisable(this.cull, GL_1.GL.Capability.CullFace, previousFlags.cull);
        RenderStateFlags.enableOrDisable(this.depthTest, GL_1.GL.Capability.DepthTest, previousFlags.depthTest);
        RenderStateFlags.enableOrDisable(this.blend, GL_1.GL.Capability.Blend, previousFlags.blend);
        RenderStateFlags.enableOrDisable(this.stencilTest, GL_1.GL.Capability.StencilTest, previousFlags.stencilTest);
        if (previousFlags.depthMask !== this.depthMask) {
            System_1.System.instance.context.depthMask(this.depthMask);
        }
        if (previousFlags.colorWrite !== this.colorWrite) {
            System_1.System.instance.context.colorMask(this.colorWrite, this.colorWrite, this.colorWrite, this.colorWrite);
        }
    }
    static enableOrDisable(currentFlag, value, previousFlag) {
        if (currentFlag !== previousFlag) {
            const gl = System_1.System.instance.context;
            if (currentFlag) {
                gl.enable(value);
            }
            else {
                gl.disable(value);
            }
        }
    }
}
exports.RenderStateFlags = RenderStateFlags;
/** @internal */
class RenderStateBlend {
    constructor(src) {
        this.color = [0.0, 0.0, 0.0, 0.0];
        this.equationRgb = GL_1.GL.BlendEquation.Default;
        this.equationAlpha = GL_1.GL.BlendEquation.Default;
        this.functionSourceRgb = GL_1.GL.BlendFactor.DefaultSrc;
        this.functionSourceAlpha = GL_1.GL.BlendFactor.DefaultSrc;
        this.functionDestRgb = GL_1.GL.BlendFactor.DefaultDst;
        this.functionDestAlpha = GL_1.GL.BlendFactor.DefaultDst;
        if (src) {
            this.copyFrom(src);
        }
    }
    apply(previousBlend) {
        const gl = System_1.System.instance.context;
        if (previousBlend === undefined || !this.equalColors(previousBlend)) {
            gl.blendColor(this.color[0], this.color[1], this.color[2], this.color[3]);
        }
        if (previousBlend === undefined || previousBlend.equationRgb !== this.equationRgb || previousBlend.equationAlpha !== this.equationAlpha) {
            gl.blendEquationSeparate(this.equationRgb, this.equationAlpha);
        }
        if (previousBlend === undefined || previousBlend.functionSourceRgb !== this.functionSourceRgb || previousBlend.functionSourceAlpha !== this.functionSourceAlpha
            || previousBlend.functionDestRgb !== this.functionDestRgb || previousBlend.functionDestAlpha !== this.functionDestAlpha) {
            gl.blendFuncSeparate(this.functionSourceRgb, this.functionDestRgb, this.functionSourceAlpha, this.functionDestAlpha);
        }
    }
    copyFrom(src) {
        this.setColor(src.color);
        this.equationRgb = src.equationRgb;
        this.equationAlpha = src.equationAlpha;
        this.functionSourceRgb = src.functionSourceRgb;
        this.functionSourceAlpha = src.functionSourceAlpha;
        this.functionDestRgb = src.functionDestRgb;
        this.functionDestAlpha = src.functionDestAlpha;
    }
    clone(result) {
        if (!result) {
            return new RenderStateBlend(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    equals(rhs) {
        return this.equalColors(rhs)
            && this.equationRgb === rhs.equationRgb
            && this.equationAlpha === rhs.equationAlpha
            && this.functionSourceRgb === rhs.functionSourceRgb
            && this.functionSourceAlpha === rhs.functionSourceAlpha
            && this.functionDestRgb === rhs.functionDestRgb
            && this.functionDestAlpha === rhs.functionDestAlpha;
    }
    equalColors(rhs) {
        return this.color[0] === rhs.color[0] &&
            this.color[1] === rhs.color[1] &&
            this.color[2] === rhs.color[2] &&
            this.color[3] === rhs.color[3];
    }
    setColor(color) {
        this.color[0] = color[0];
        this.color[1] = color[1];
        this.color[2] = color[2];
        this.color[3] = color[3];
    }
    setBlendFunc(src, dst) {
        this.setBlendFuncSeparate(src, src, dst, dst);
    }
    setBlendFuncSeparate(srcRgb, srcAlpha, dstRgb, dstAlpha) {
        this.functionSourceRgb = srcRgb;
        this.functionSourceAlpha = srcAlpha;
        this.functionDestRgb = dstRgb;
        this.functionDestAlpha = dstAlpha;
    }
}
exports.RenderStateBlend = RenderStateBlend;
/** @internal */
class RenderStateStencilOperation {
    constructor(src) {
        this.fail = GL_1.GL.StencilOperation.Default;
        this.zFail = GL_1.GL.StencilOperation.Default;
        this.zPass = GL_1.GL.StencilOperation.Default;
        if (src) {
            this.copyFrom(src);
        }
    }
    copyFrom(src) {
        this.fail = src.fail;
        this.zFail = src.zFail;
        this.zPass = src.zPass;
    }
    clone(result) {
        if (!result) {
            return new RenderStateStencilOperation(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    equals(rhs) {
        return this.fail === rhs.fail
            && this.zFail === rhs.zFail
            && this.zPass === rhs.zPass;
    }
}
exports.RenderStateStencilOperation = RenderStateStencilOperation;
/** @internal */
class RenderStateStencilFunction {
    constructor(src) {
        this.function = GL_1.GL.StencilFunction.Default;
        this.ref = 0;
        this.mask = 0xFFFFFFFF;
        if (src) {
            this.copyFrom(src);
        }
    }
    copyFrom(src) {
        this.function = src.function;
        this.ref = src.ref;
        this.mask = src.mask;
    }
    clone(result) {
        if (!result) {
            return new RenderStateStencilFunction(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    equals(rhs) {
        return this.function === rhs.function
            && this.ref === rhs.ref
            && this.mask === rhs.mask;
    }
}
exports.RenderStateStencilFunction = RenderStateStencilFunction;
/** @internal */
class RenderStateStencil {
    constructor(src) {
        this.frontFunction = new RenderStateStencilFunction();
        this.backFunction = new RenderStateStencilFunction();
        this.frontOperation = new RenderStateStencilOperation();
        this.backOperation = new RenderStateStencilOperation();
        if (src) {
            this.copyFrom(src);
        }
    }
    apply(previousStencil) {
        const gl = System_1.System.instance.context;
        if (previousStencil === undefined || !previousStencil.frontFunction.equals(this.frontFunction)) {
            gl.stencilFuncSeparate(GL_1.GL.CullFace.Front, this.frontFunction.function, this.frontFunction.ref, this.frontFunction.mask);
        }
        if (previousStencil === undefined || !previousStencil.backFunction.equals(this.backFunction)) {
            gl.stencilFuncSeparate(GL_1.GL.CullFace.Back, this.backFunction.function, this.backFunction.ref, this.backFunction.mask);
        }
        if (previousStencil === undefined || !previousStencil.frontOperation.equals(this.frontOperation)) {
            gl.stencilOpSeparate(GL_1.GL.CullFace.Front, this.frontOperation.fail, this.frontOperation.zFail, this.frontOperation.zPass);
        }
        if (previousStencil === undefined || !previousStencil.backOperation.equals(this.backOperation)) {
            gl.stencilOpSeparate(GL_1.GL.CullFace.Back, this.backOperation.fail, this.backOperation.zFail, this.backOperation.zPass);
        }
    }
    copyFrom(src) {
        this.frontFunction.copyFrom(src.frontFunction);
        this.backFunction.copyFrom(src.backFunction);
        this.frontOperation.copyFrom(src.frontOperation);
        this.backOperation.copyFrom(src.backOperation);
    }
    clone(result) {
        if (!result) {
            return new RenderStateStencil(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    equals(rhs) {
        return this.frontFunction.equals(rhs.frontFunction)
            && this.backFunction.equals(rhs.backFunction)
            && this.frontOperation.equals(rhs.frontOperation)
            && this.backOperation.equals(rhs.backOperation);
    }
}
exports.RenderStateStencil = RenderStateStencil;
/** Encapsulates the state of an OpenGL context.
 * to modify the context for a rendering operation, do *not* directly call
 * functions like glDepthMask(), glBlendFunc(), etc - otherwise such calls may adversely
 * affect subsequent rendering operations.
 * Instead, set up a RenderState as desired and invoke System.instance.applyRenderState()
 * The context tracks the most-recently applied RenderState, allowing it to minimize
 * the number of GL state changes actually invoked, improving performance.
 * @internal
 */
class RenderState {
    constructor(src) {
        this.flags = new RenderStateFlags();
        this.blend = new RenderStateBlend();
        this.stencil = new RenderStateStencil();
        this.frontFace = GL_1.GL.FrontFace.Default;
        this.cullFace = GL_1.GL.CullFace.Default;
        this.depthFunc = GL_1.GL.DepthFunc.Default;
        this.stencilMask = 0xFFFFFFFF;
        if (src) {
            this.copyFrom(src);
        }
    }
    copyFrom(src) {
        this.flags.copyFrom(src.flags);
        this.blend.copyFrom(src.blend);
        this.stencil.copyFrom(src.stencil);
        this.frontFace = src.frontFace;
        this.cullFace = src.cullFace;
        this.depthFunc = src.depthFunc;
        this.stencilMask = src.stencilMask;
    }
    clone(result) {
        if (!result) {
            return new RenderState(this);
        }
        else {
            result.copyFrom(this);
            return result;
        }
    }
    set clockwiseFrontFace(clockwise) {
        this.frontFace = clockwise ? GL_1.GL.FrontFace.Clockwise : GL_1.GL.FrontFace.CounterClockwise;
    }
    equals(rhs) {
        return this.flags.equals(rhs.flags)
            && this.blend.equals(rhs.blend)
            && this.stencil.equals(rhs.stencil)
            && this.frontFace === rhs.frontFace
            && this.cullFace === rhs.cullFace
            && this.depthFunc === rhs.depthFunc
            && this.stencilMask === rhs.stencilMask;
    }
    apply(prevState) {
        this.flags.apply(prevState.flags);
        if (this.flags.blend) {
            if (prevState.flags.blend)
                this.blend.apply(prevState.blend);
            else
                this.blend.apply();
        }
        if (this.flags.cull) {
            if (!prevState.flags.cull || prevState.cullFace !== this.cullFace) {
                System_1.System.instance.context.cullFace(this.cullFace);
            }
        }
        if (this.flags.depthTest) {
            if (!prevState.flags.depthTest || prevState.depthFunc !== this.depthFunc) {
                System_1.System.instance.context.depthFunc(this.depthFunc);
            }
        }
        if (this.flags.stencilTest) {
            if (prevState.flags.stencilTest)
                this.stencil.apply(prevState.stencil);
            else
                this.stencil.apply();
        }
        if (this.frontFace !== prevState.frontFace) {
            System_1.System.instance.context.frontFace(this.frontFace);
        }
        if (this.stencilMask !== prevState.stencilMask) {
            System_1.System.instance.context.stencilMask(this.stencilMask);
        }
    }
}
RenderState.defaults = new RenderState();
exports.RenderState = RenderState;
Object.freeze(RenderState.defaults);


/***/ }),

/***/ "./lib/render/webgl/SceneCompositor.js":
/*!*********************************************!*\
  !*** ./lib/render/webgl/SceneCompositor.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const FrameBuffer_1 = __webpack_require__(/*! ./FrameBuffer */ "./lib/render/webgl/FrameBuffer.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const System_2 = __webpack_require__(/*! ../System */ "./lib/render/System.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const DrawCommand_1 = __webpack_require__(/*! ./DrawCommand */ "./lib/render/webgl/DrawCommand.js");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "./lib/render/webgl/RenderState.js");
const Diagnostics_1 = __webpack_require__(/*! ./Diagnostics */ "./lib/render/webgl/Diagnostics.js");
let progParams;
let drawParams;
/** @internal */
function getDrawParams(target, geometry) {
    if (undefined === progParams) {
        progParams = new DrawCommand_1.ShaderProgramParams();
        drawParams = new DrawCommand_1.DrawParams();
    }
    progParams.init(target);
    drawParams.init(progParams, geometry);
    return drawParams;
}
exports.getDrawParams = getDrawParams;
// Maintains the textures used by a SceneCompositor. The textures are reallocated when the dimensions of the viewport change.
class Textures {
    dispose() {
        this.accumulation = bentleyjs_core_1.dispose(this.accumulation);
        this.revealage = bentleyjs_core_1.dispose(this.revealage);
        this.color = bentleyjs_core_1.dispose(this.color);
        this.featureId = bentleyjs_core_1.dispose(this.featureId);
        this.depthAndOrder = bentleyjs_core_1.dispose(this.depthAndOrder);
        this.hilite = bentleyjs_core_1.dispose(this.hilite);
        this.occlusion = bentleyjs_core_1.dispose(this.occlusion);
        this.occlusionBlur = bentleyjs_core_1.dispose(this.occlusionBlur);
    }
    init(width, height) {
        bentleyjs_core_1.assert(undefined === this.accumulation);
        let pixelDataType = GL_1.GL.Texture.DataType.UnsignedByte;
        switch (System_1.System.instance.capabilities.maxRenderType) {
            case 2 /* TextureFloat */: {
                pixelDataType = GL_1.GL.Texture.DataType.Float;
                break;
            }
            case 1 /* TextureHalfFloat */: {
                const ext = System_1.System.instance.capabilities.queryExtensionObject("OES_texture_half_float");
                if (undefined !== ext) {
                    pixelDataType = ext.HALF_FLOAT_OES;
                    break;
                }
            }
            /* falls through */
            case 0 /* TextureUnsignedByte */: {
                break;
            }
        }
        // NB: Both of these must be of the same type, because they are borrowed by pingpong and bound to the same frame buffer.
        this.accumulation = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, pixelDataType);
        this.revealage = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, pixelDataType);
        // Hilite texture is a simple on-off, but the smallest texture format WebGL allows us to use as output is RGBA with a byte per component.
        this.hilite = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        this.color = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        this.featureId = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        this.depthAndOrder = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        return undefined !== this.accumulation
            && undefined !== this.revealage
            && undefined !== this.color
            && undefined !== this.featureId
            && undefined !== this.depthAndOrder
            && undefined !== this.hilite;
    }
    enableOcclusion(width, height) {
        bentleyjs_core_1.assert(undefined === this.occlusion && undefined === this.occlusionBlur);
        this.occlusion = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        this.occlusionBlur = Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        return undefined !== this.occlusion && undefined !== this.occlusionBlur;
    }
    disableOcclusion() {
        bentleyjs_core_1.assert(undefined !== this.occlusion && undefined !== this.occlusionBlur);
        this.occlusion = bentleyjs_core_1.dispose(this.occlusion);
        this.occlusionBlur = bentleyjs_core_1.dispose(this.occlusionBlur);
    }
}
// Maintains the framebuffers used by a SceneCompositor. The color attachments are supplied by a Textures object.
class FrameBuffers {
    init(textures, depth) {
        const boundColor = System_1.System.instance.frameBufferStack.currentColorBuffer;
        if (undefined === boundColor)
            return false;
        this.opaqueColor = FrameBuffer_1.FrameBuffer.create([boundColor], depth);
        this.opaqueAndCompositeColor = FrameBuffer_1.FrameBuffer.create([textures.color], depth);
        this.depthAndOrder = FrameBuffer_1.FrameBuffer.create([textures.depthAndOrder], depth);
        this.hilite = FrameBuffer_1.FrameBuffer.create([textures.hilite]);
        this.hiliteUsingStencil = FrameBuffer_1.FrameBuffer.create([textures.hilite], depth);
        if (1 /* TextureUnsignedInt24Stencil8 */ === System_1.System.instance.capabilities.maxDepthType)
            this.stencilSet = FrameBuffer_1.FrameBuffer.create([], depth);
        return undefined !== this.opaqueColor
            && undefined !== this.opaqueAndCompositeColor
            && undefined !== this.depthAndOrder
            && undefined !== this.hilite
            && undefined !== this.hiliteUsingStencil;
    }
    toggleOcclusion(textures) {
        if (undefined !== textures.occlusion) {
            bentleyjs_core_1.assert(undefined !== textures.occlusionBlur);
            this.occlusion = FrameBuffer_1.FrameBuffer.create([textures.occlusion]);
            this.occlusionBlur = FrameBuffer_1.FrameBuffer.create([textures.occlusionBlur]);
        }
        else {
            bentleyjs_core_1.assert(undefined === textures.occlusionBlur);
            this.occlusion = bentleyjs_core_1.dispose(this.occlusion);
            this.occlusionBlur = bentleyjs_core_1.dispose(this.occlusionBlur);
        }
    }
    dispose() {
        this.opaqueColor = bentleyjs_core_1.dispose(this.opaqueColor);
        this.opaqueAndCompositeColor = bentleyjs_core_1.dispose(this.opaqueAndCompositeColor);
        this.depthAndOrder = bentleyjs_core_1.dispose(this.depthAndOrder);
        this.hilite = bentleyjs_core_1.dispose(this.hilite);
        this.hiliteUsingStencil = bentleyjs_core_1.dispose(this.hiliteUsingStencil);
        this.stencilSet = bentleyjs_core_1.dispose(this.stencilSet);
        this.occlusion = bentleyjs_core_1.dispose(this.occlusion);
        this.occlusionBlur = bentleyjs_core_1.dispose(this.occlusionBlur);
    }
}
// Maintains the geometry used to execute screenspace operations for a SceneCompositor.
class Geometry {
    init(textures) {
        bentleyjs_core_1.assert(undefined === this.composite);
        this.composite = CachedGeometry_1.CompositeGeometry.createGeometry(textures.color.getHandle(), textures.accumulation.getHandle(), textures.revealage.getHandle(), textures.hilite.getHandle());
        this.stencilCopy = CachedGeometry_1.ViewportQuadGeometry.create(17 /* CopyStencil */);
        return undefined !== this.composite;
    }
    toggleOcclusion(textures) {
        if (undefined !== textures.occlusion) {
            bentleyjs_core_1.assert(undefined !== textures.occlusionBlur);
            this.composite.occlusion = textures.occlusion.getHandle();
            this.occlusion = CachedGeometry_1.AmbientOcclusionGeometry.createGeometry(textures.depthAndOrder.getHandle());
            this.occlusionXBlur = CachedGeometry_1.BlurGeometry.createGeometry(textures.occlusion.getHandle(), textures.depthAndOrder.getHandle(), new geometry_core_1.Vector2d(1.0, 0.0));
            this.occlusionYBlur = CachedGeometry_1.BlurGeometry.createGeometry(textures.occlusionBlur.getHandle(), textures.depthAndOrder.getHandle(), new geometry_core_1.Vector2d(0.0, 1.0));
        }
        else {
            bentleyjs_core_1.assert(undefined === textures.occlusionBlur);
            this.composite.occlusion = undefined;
            this.occlusion = bentleyjs_core_1.dispose(this.occlusion);
            this.occlusionXBlur = bentleyjs_core_1.dispose(this.occlusionXBlur);
            this.occlusionYBlur = bentleyjs_core_1.dispose(this.occlusionYBlur);
        }
    }
    dispose() {
        this.composite = bentleyjs_core_1.dispose(this.composite);
        this.stencilCopy = bentleyjs_core_1.dispose(this.stencilCopy);
        this.occlusion = bentleyjs_core_1.dispose(this.occlusion);
        this.occlusionXBlur = bentleyjs_core_1.dispose(this.occlusionXBlur);
        this.occlusionYBlur = bentleyjs_core_1.dispose(this.occlusionYBlur);
    }
}
// Represents a view of data read from a region of the frame buffer.
class PixelBuffer {
    constructor(rect, selector, compositor) {
        this._scratchUint32Array = new Uint32Array(1);
        this._scratchUint8Array = new Uint8Array(this._scratchUint32Array.buffer);
        this._scratchVector3d = new geometry_core_1.Vector3d();
        this._mult = new geometry_core_1.Vector3d(1.0, 1.0 / 255.0, 1.0 / 65025.0);
        this._invalidPixelData = new System_2.Pixel.Data();
        this._rect = rect.clone();
        this._selector = selector;
        this._batchState = compositor.target.batchState;
        if (0 /* None */ !== (selector & 4 /* GeometryAndDistance */)) {
            const depthAndOrderBytes = compositor.readDepthAndOrder(rect);
            if (undefined !== depthAndOrderBytes)
                this._depthAndOrder = new Uint32Array(depthAndOrderBytes.buffer);
            else
                this._selector &= ~4 /* GeometryAndDistance */;
        }
        if (0 /* None */ !== (selector & 1 /* Feature */)) {
            const features = compositor.readFeatureIds(rect);
            if (undefined !== features)
                this._featureId = new Uint32Array(features.buffer);
            else
                this._selector &= ~1 /* Feature */;
        }
    }
    get _numPixels() { return this._rect.width * this._rect.height; }
    getPixelIndex(x, y) {
        if (x < this._rect.left || y < this._rect.top)
            return this._numPixels;
        x -= this._rect.left;
        y -= this._rect.top;
        if (x >= this._rect.width || y >= this._rect.height)
            return this._numPixels;
        // NB: View coords have origin at top-left; GL at bottom-left. So our rows are upside-down.
        y = this._rect.height - 1 - y;
        return y * this._rect.width + x;
    }
    getPixel32(data, pixelIndex) {
        return pixelIndex < data.length ? data[pixelIndex] : undefined;
    }
    getFeature(pixelIndex) {
        const featureId = this.getFeatureId(pixelIndex);
        return undefined !== featureId ? this._batchState.getFeature(featureId) : undefined;
    }
    getFeatureId(pixelIndex) {
        return undefined !== this._featureId ? this.getPixel32(this._featureId, pixelIndex) : undefined;
    }
    getFeatureTable(pixelIndex) {
        const featureId = this.getFeatureId(pixelIndex);
        if (undefined !== featureId) {
            const batch = this._batchState.find(featureId);
            if (undefined !== batch)
                return batch.featureTable;
        }
        return undefined;
    }
    decodeDepthRgba(depthAndOrder) {
        this._scratchUint32Array[0] = depthAndOrder;
        const bytes = this._scratchUint8Array;
        const fpt = geometry_core_1.Vector3d.create(bytes[1] / 255.0, bytes[2] / 255.0, bytes[3] / 255.0, this._scratchVector3d);
        let depth = fpt.dotProduct(this._mult);
        bentleyjs_core_1.assert(0.0 <= depth);
        bentleyjs_core_1.assert(1.01 >= depth); // rounding error...
        depth = Math.min(1.0, depth);
        depth = Math.max(0.0, depth);
        return depth;
    }
    decodeRenderOrderRgba(depthAndOrder) {
        this._scratchUint32Array[0] = depthAndOrder;
        const encByte = this._scratchUint8Array[0];
        const enc = encByte / 255.0;
        const dec = Math.floor(16.0 * enc + 0.5);
        return dec;
    }
    getPixel(x, y) {
        const px = this._invalidPixelData;
        const index = this.getPixelIndex(x, y);
        if (index >= this._numPixels)
            return px;
        // Initialize to the defaults...
        let distanceFraction = px.distanceFraction;
        let geometryType = px.type;
        let planarity = px.planarity;
        const haveFeatureIds = 0 /* None */ !== (this._selector & 1 /* Feature */);
        const feature = haveFeatureIds ? this.getFeature(index) : undefined;
        const featureTable = haveFeatureIds ? this.getFeatureTable(index) : undefined;
        if (0 /* None */ !== (this._selector & 4 /* GeometryAndDistance */) && undefined !== this._depthAndOrder) {
            const depthAndOrder = this.getPixel32(this._depthAndOrder, index);
            if (undefined !== depthAndOrder) {
                distanceFraction = this.decodeDepthRgba(depthAndOrder);
                const orderWithPlanarBit = this.decodeRenderOrderRgba(depthAndOrder);
                const order = orderWithPlanarBit & ~8 /* PlanarBit */;
                planarity = (orderWithPlanarBit === order) ? 3 /* NonPlanar */ : 2 /* Planar */;
                switch (order) {
                    case 0 /* None */:
                        geometryType = 1 /* None */;
                        planarity = 1 /* None */;
                        break;
                    case 1 /* BlankingRegion */:
                    case 2 /* Surface */:
                        geometryType = 2 /* Surface */;
                        break;
                    case 3 /* Linear */:
                        geometryType = 3 /* Linear */;
                        break;
                    case 4 /* Edge */:
                        geometryType = 4 /* Edge */;
                        break;
                    case 5 /* Silhouette */:
                        geometryType = 5 /* Silhouette */;
                        break;
                    default:
                        // ###TODO: may run into issues with point clouds - they are not written correctly in C++.
                        bentleyjs_core_1.assert(false, "Invalid render order");
                        geometryType = 1 /* None */;
                        planarity = 1 /* None */;
                        break;
                }
            }
        }
        return new System_2.Pixel.Data(feature, distanceFraction, geometryType, planarity, featureTable);
    }
    get isEmpty() { return 0 /* None */ === this._selector; }
    static create(rect, selector, compositor) {
        const pdb = new PixelBuffer(rect, selector, compositor);
        return pdb.isEmpty ? undefined : pdb;
    }
}
/** Orchestrates rendering of the scene on behalf of a Target.
 * This base class exists only so we don't have to export all the types of the shared Compositor members like Textures, FrameBuffers, etc.
 * @internal
 */
class SceneCompositor {
    constructor(target) { this.target = target; }
    static create(target) {
        return System_1.System.instance.capabilities.supportsDrawBuffers ? new MRTCompositor(target) : new MPCompositor(target);
    }
}
exports.SceneCompositor = SceneCompositor;
// The actual base class. Specializations are provided based on whether or not multiple render targets are supported.
class Compositor extends SceneCompositor {
    constructor(target, fbos, geometry) {
        super(target);
        this._width = -1;
        this._height = -1;
        this._includeOcclusion = false;
        this._textures = new Textures();
        this._readPickDataFromPingPong = true;
        this._opaqueRenderState = new RenderState_1.RenderState();
        this._translucentRenderState = new RenderState_1.RenderState();
        this._noDepthMaskRenderState = new RenderState_1.RenderState();
        this._stencilSetRenderState = new RenderState_1.RenderState();
        this._classifyColorRenderState = new RenderState_1.RenderState();
        this._classifyPickDataRenderState = new RenderState_1.RenderState();
        this._debugStencilRenderState = new RenderState_1.RenderState();
        this._debugStencil = 0; // 0 to draw stencil volumes normally, 1 to draw as opaque, 2 to draw blended
        this._frameBuffers = fbos;
        this._geom = geometry;
        this._opaqueRenderState.flags.depthTest = true;
        this._translucentRenderState.flags.depthMask = false;
        this._translucentRenderState.flags.blend = this._translucentRenderState.flags.depthTest = true;
        this._translucentRenderState.blend.setBlendFuncSeparate(GL_1.GL.BlendFactor.One, GL_1.GL.BlendFactor.Zero, GL_1.GL.BlendFactor.One, GL_1.GL.BlendFactor.OneMinusSrcAlpha);
        this._noDepthMaskRenderState.flags.depthMask = false;
        this._stencilSetRenderState.flags.depthTest = true;
        this._stencilSetRenderState.flags.depthMask = false;
        this._stencilSetRenderState.flags.colorWrite = false;
        this._stencilSetRenderState.flags.stencilTest = true;
        this._stencilSetRenderState.depthFunc = GL_1.GL.DepthFunc.LessOrEqual;
        this._stencilSetRenderState.stencil.frontFunction.function = GL_1.GL.StencilFunction.Always;
        this._stencilSetRenderState.stencil.frontOperation.zFail = GL_1.GL.StencilOperation.IncrWrap;
        this._stencilSetRenderState.stencil.backFunction.function = GL_1.GL.StencilFunction.Always;
        this._stencilSetRenderState.stencil.backOperation.zFail = GL_1.GL.StencilOperation.DecrWrap;
        this._classifyPickDataRenderState.flags.depthTest = false;
        this._classifyPickDataRenderState.flags.depthMask = false;
        this._classifyPickDataRenderState.flags.colorWrite = true;
        this._classifyPickDataRenderState.flags.stencilTest = true;
        this._classifyPickDataRenderState.flags.cull = true;
        this._classifyPickDataRenderState.cullFace = GL_1.GL.CullFace.Front;
        this._classifyPickDataRenderState.stencil.backFunction.function = GL_1.GL.StencilFunction.NotEqual;
        this._classifyPickDataRenderState.stencil.backOperation.zPass = GL_1.GL.StencilOperation.Zero; // this will clear the stencil
        // Let all of the operations remain at Keep so that the stencil will remain in tact for the subsequent blend draw to the color buffer.
        this._classifyColorRenderState.flags.depthTest = false;
        this._classifyColorRenderState.flags.depthMask = false;
        this._classifyColorRenderState.flags.colorWrite = true;
        this._classifyColorRenderState.flags.stencilTest = true;
        this._classifyColorRenderState.stencil.frontFunction.function = GL_1.GL.StencilFunction.NotEqual;
        this._classifyColorRenderState.stencil.frontOperation.fail = GL_1.GL.StencilOperation.Zero;
        this._classifyColorRenderState.stencil.frontOperation.zFail = GL_1.GL.StencilOperation.Zero;
        this._classifyColorRenderState.stencil.frontOperation.zPass = GL_1.GL.StencilOperation.Zero; // this will clear the stencil
        this._classifyColorRenderState.stencil.backFunction.function = GL_1.GL.StencilFunction.NotEqual;
        this._classifyColorRenderState.stencil.backOperation.fail = GL_1.GL.StencilOperation.Zero;
        this._classifyColorRenderState.stencil.backOperation.zFail = GL_1.GL.StencilOperation.Zero;
        this._classifyColorRenderState.stencil.backOperation.zPass = GL_1.GL.StencilOperation.Zero; // this will clear the stencil
        this._classifyColorRenderState.flags.blend = true; // blend func will be set before using
        if (this._debugStencil > 0) {
            this._debugStencilRenderState.flags.depthTest = true;
            this._debugStencilRenderState.flags.blend = true;
            this._debugStencilRenderState.blend.setBlendFunc(GL_1.GL.BlendFactor.OneMinusConstColor, GL_1.GL.BlendFactor.ConstColor);
            this._debugStencilRenderState.blend.color = [0.67, 0.67, 0.67, 1.0];
        }
    }
    /** This function generates a texture that contains ambient occlusion information to be applied later. */
    renderAmbientOcclusion() {
        const system = System_1.System.instance;
        // Render unblurred ambient occlusion based on depth buffer
        let fbo = this._frameBuffers.occlusion;
        system.frameBufferStack.execute(fbo, true, () => {
            System_1.System.instance.applyRenderState(RenderState_1.RenderState.defaults);
            const params = getDrawParams(this.target, this._geom.occlusion);
            this.target.techniques.draw(params);
        });
        this.target.recordPerformanceMetric("Compute AO");
        // Render the X-blurred ambient occlusion based on unblurred ambient occlusion
        fbo = this._frameBuffers.occlusionBlur;
        system.frameBufferStack.execute(fbo, true, () => {
            System_1.System.instance.applyRenderState(RenderState_1.RenderState.defaults);
            const params = getDrawParams(this.target, this._geom.occlusionXBlur);
            this.target.techniques.draw(params);
        });
        this.target.recordPerformanceMetric("Blur AO X");
        // Render the Y-blurred ambient occlusion based on X-blurred ambient occlusion (render into original occlusion framebuffer)
        fbo = this._frameBuffers.occlusion;
        system.frameBufferStack.execute(fbo, true, () => {
            System_1.System.instance.applyRenderState(RenderState_1.RenderState.defaults);
            const params = getDrawParams(this.target, this._geom.occlusionYBlur);
            this.target.techniques.draw(params);
        });
        this.target.recordPerformanceMetric("Blur AO Y");
    }
    update() {
        const rect = this.target.viewRect;
        const width = rect.width;
        const height = rect.height;
        const includeOcclusion = this.target.wantAmbientOcclusion;
        // If not yet initialized, or dimensions changed, initialize.
        if (undefined === this._textures.accumulation || width !== this._width || height !== this._height) {
            this._width = width;
            this._height = height;
            // init() first calls dispose(), which releases all of our fbos, textures, etc, and resets the _includeOcclusion flag.
            if (!this.init()) {
                bentleyjs_core_1.assert(false, "Failed to initialize scene compositor");
                return false;
            }
        }
        // Allocate or free ambient occlusion-related resources if necessary
        if (includeOcclusion !== this._includeOcclusion) {
            this._includeOcclusion = includeOcclusion;
            if (includeOcclusion) {
                if (!this._textures.enableOcclusion(width, height)) {
                    bentleyjs_core_1.assert(false, "Failed to initialize occlusion textures");
                    return false;
                }
            }
            else {
                this._textures.disableOcclusion();
            }
            this._frameBuffers.toggleOcclusion(this._textures);
            this._geom.toggleOcclusion(this._textures);
        }
        return true;
    }
    draw(commands) {
        if (!this.update()) {
            bentleyjs_core_1.assert(false);
            return;
        }
        const compositeFlags = commands.compositeFlags;
        const needComposite = 0 /* None */ !== compositeFlags;
        // Clear output targets
        this.clearOpaque(needComposite);
        // Render the background
        this.renderBackground(commands, needComposite);
        this.target.recordPerformanceMetric("Render Background");
        // Render the sky box
        this.renderSkyBox(commands, needComposite);
        this.target.recordPerformanceMetric("Render SkyBox");
        // Render the background map graphics
        this.renderBackgroundMap(commands, needComposite);
        this.target.recordPerformanceMetric("Render BackgroundMap (background map)");
        // Enable clipping
        this.target.pushActiveVolume();
        this.target.recordPerformanceMetric("Enable Clipping");
        // Render opaque geometry
        this.renderOpaque(commands, compositeFlags, false);
        this.target.recordPerformanceMetric("Render Opaque");
        // Render stencil volumes
        this.renderClassification(commands, needComposite, false);
        this.target.recordPerformanceMetric("Render Stencils");
        if (needComposite) {
            this._geom.composite.update(compositeFlags);
            this.clearTranslucent();
            this.renderTranslucent(commands);
            this.target.recordPerformanceMetric("Render Translucent");
            this.renderHilite(commands);
            this.target.recordPerformanceMetric("Render Hilite");
            this.composite();
            this.target.recordPerformanceMetric("Composite");
        }
        this.target.popActiveVolume();
    }
    get fullHeight() { return this.target.viewRect.height; }
    drawForReadPixels(commands, overlays) {
        if (!this.update()) {
            bentleyjs_core_1.assert(false);
            return;
        }
        this.clearOpaque(false);
        this.target.recordPerformanceMetric("Render Background");
        // On entry the RenderCommands has been initialized for all scene graphics and pickable decorations with the exception of world overlays.
        // It's possible we have no pickable scene graphics or decorations, but do have pickable world overlays.
        const haveRenderCommands = !commands.isEmpty;
        if (haveRenderCommands) {
            this.target.pushActiveVolume();
            this.target.recordPerformanceMetric("Enable Clipping");
            this.renderOpaque(commands, 0 /* None */, true);
            this.target.recordPerformanceMetric("Render Opaque");
            this.renderClassification(commands, false, true);
            this.target.recordPerformanceMetric("Render Stencils");
            this.target.popActiveVolume();
        }
        if (undefined === overlays || 0 === overlays.length)
            return;
        // Now populate the opaque passes with any pickable world overlays
        commands.initForPickOverlays(overlays);
        if (commands.isEmpty)
            return;
        // Clear the depth buffer so that overlay decorations win the depth test.
        // (If *only* overlays exist, then clearOpaque() above already took care of this).
        if (haveRenderCommands) {
            const system = System_1.System.instance;
            system.frameBufferStack.execute(this._frameBuffers.opaqueColor, true, () => {
                system.applyRenderState(RenderState_1.RenderState.defaults);
                system.context.clearDepth(1.0);
                system.context.clear(GL_1.GL.BufferBit.Depth);
            });
        }
        // Render overlays as opaque into the pick buffers
        this.renderOpaque(commands, 0 /* None */, true);
        this.target.recordPerformanceMetric("Overlay Draws");
    }
    readPixels(rect, selector) {
        return PixelBuffer.create(rect, selector, this);
    }
    readDepthAndOrder(rect) { return this.readFrameBuffer(rect, this._frameBuffers.depthAndOrder); }
    readFeatureIds(rect) {
        const tex = this._textures.featureId;
        if (undefined === tex)
            return undefined;
        const fbo = FrameBuffer_1.FrameBuffer.create([tex]);
        const result = this.readFrameBuffer(rect, fbo);
        bentleyjs_core_1.dispose(fbo);
        return result;
    }
    readFrameBuffer(rect, fbo) {
        if (undefined === fbo || !Diagnostics_1.Debug.isValidFrameBuffer)
            return undefined;
        // NB: ViewRect origin at top-left; GL origin at bottom-left
        const bottom = this.fullHeight - rect.bottom;
        const gl = System_1.System.instance.context;
        const bytes = new Uint8Array(rect.width * rect.height * 4);
        let result = bytes;
        System_1.System.instance.frameBufferStack.execute(fbo, true, () => {
            try {
                gl.readPixels(rect.left, bottom, rect.width, rect.height, gl.RGBA, gl.UNSIGNED_BYTE, bytes);
            }
            catch (e) {
                result = undefined;
            }
        });
        return result;
    }
    dispose() {
        this._depth = bentleyjs_core_1.dispose(this._depth);
        this._includeOcclusion = false;
        bentleyjs_core_1.dispose(this._textures);
        bentleyjs_core_1.dispose(this._frameBuffers);
        bentleyjs_core_1.dispose(this._geom);
    }
    init() {
        this.dispose();
        this._depth = System_1.System.instance.createDepthBuffer(this._width, this._height);
        if (this._depth !== undefined) {
            return this._textures.init(this._width, this._height)
                && this._frameBuffers.init(this._textures, this._depth)
                && this._geom.init(this._textures);
        }
        return false;
    }
    renderBackgroundMap(commands, needComposite) {
        const cmds = commands.getCommands(11 /* BackgroundMap */);
        if (0 === cmds.length) {
            return;
        }
        this.target.plan.selectExpandedFrustum();
        this.target.changeFrustum(this.target.plan.frustum, this.target.plan.fraction, this.target.plan.is3d);
        const fbStack = System_1.System.instance.frameBufferStack;
        const fbo = this.getBackgroundFbo(needComposite);
        fbStack.execute(fbo, true, () => {
            System_1.System.instance.applyRenderState(this.getRenderState(11 /* BackgroundMap */));
            this.target.techniques.execute(this.target, cmds, 11 /* BackgroundMap */);
        });
        this.target.plan.selectViewFrustum();
        this.target.changeFrustum(this.target.plan.frustum, this.target.plan.fraction, this.target.plan.is3d);
    }
    renderSkyBox(commands, needComposite) {
        const cmds = commands.getCommands(10 /* SkyBox */);
        if (0 === cmds.length) {
            return;
        }
        const fbStack = System_1.System.instance.frameBufferStack;
        const fbo = this.getBackgroundFbo(needComposite);
        fbStack.execute(fbo, true, () => {
            this.target.pushState(this.target.decorationState);
            System_1.System.instance.applyRenderState(this.getRenderState(10 /* SkyBox */));
            this.target.techniques.execute(this.target, cmds, 10 /* SkyBox */);
            this.target.popBranch();
        });
    }
    renderBackground(commands, needComposite) {
        const cmds = commands.getCommands(0 /* Background */);
        if (0 === cmds.length) {
            return;
        }
        const fbStack = System_1.System.instance.frameBufferStack;
        const fbo = this.getBackgroundFbo(needComposite);
        fbStack.execute(fbo, true, () => {
            this.target.pushState(this.target.decorationState);
            System_1.System.instance.applyRenderState(this.getRenderState(0 /* Background */));
            this.target.techniques.execute(this.target, cmds, 0 /* Background */);
            this.target.popBranch();
        });
    }
    findFlashedClassifier(cmdsByIndex) {
        if (!bentleyjs_core_1.Id64.isValid(this.target.flashedId))
            return -1; // nothing flashed
        for (let i = 1; i < cmdsByIndex.length; i += 3) {
            const command = cmdsByIndex[i];
            if (command.isPrimitiveCommand) {
                if (command instanceof DrawCommand_1.BatchPrimitiveCommand) {
                    const batch = command;
                    if (batch.computeIsFlashed(this.target.flashedId)) {
                        return (i - 1) / 3;
                    }
                }
            }
        }
        return -1; // couldn't find it
    }
    renderIndexedClassifier(cmdsByIndex, index, needComposite) {
        // Set the stencil for the given classifier stencil volume.
        System_1.System.instance.frameBufferStack.execute(this._frameBuffers.stencilSet, false, () => {
            this.target.pushState(this.target.decorationState);
            System_1.System.instance.applyRenderState(this._stencilSetRenderState);
            this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, 4 /* Classification */, index);
            this.target.popBranch();
        });
        // Process the stencil for the pick data.
        this.renderIndexedClassifierForReadPixels(cmdsByIndex, index, this._classifyPickDataRenderState, needComposite);
    }
    renderClassification(commands, needComposite, renderForReadPixels) {
        const cmds = commands.getCommands(4 /* Classification */);
        const cmdsByIndex = commands.getCommands(13 /* ClassificationByIndex */);
        if (0 === cmds.length || 0 === cmdsByIndex.length)
            return;
        if (this._debugStencil > 0) {
            System_1.System.instance.frameBufferStack.execute(this.getBackgroundFbo(needComposite), true, () => {
                if (1 === this._debugStencil) {
                    System_1.System.instance.applyRenderState(this.getRenderState(3 /* OpaqueGeneral */));
                    this.target.techniques.execute(this.target, cmds, 3 /* OpaqueGeneral */);
                }
                else {
                    this.target.pushState(this.target.decorationState);
                    System_1.System.instance.applyRenderState(this._debugStencilRenderState);
                    this.target.techniques.execute(this.target, cmds, 4 /* Classification */);
                    this.target.popBranch();
                }
            });
            return;
        }
        const fbStack = System_1.System.instance.frameBufferStack;
        const fboSet = this._frameBuffers.stencilSet;
        const fboCopy = this.getBackgroundFbo(needComposite);
        if (undefined === fboSet || undefined === fboCopy)
            return;
        // Clear the stencil.
        fbStack.execute(fboSet, false, () => {
            System_1.System.instance.context.clearStencil(0);
            System_1.System.instance.context.clear(GL_1.GL.BufferBit.Stencil);
        });
        if (renderForReadPixels) {
            // We need to render the classifier stencil volumes one at a time, so first count them then render them in a loop.
            const numClassifiers = cmdsByIndex.length / 3;
            for (let i = 0; i < numClassifiers; ++i)
                this.renderIndexedClassifier(cmdsByIndex, i, needComposite);
            return;
        }
        const flashedClassifier = this.findFlashedClassifier(cmdsByIndex);
        // Process the selected classifiers.
        const cmdsH = commands.getCommands(12 /* HiliteClassification */);
        if (cmds.length > 0) {
            // Set the stencil for the given classifier stencil volume.
            fbStack.execute(fboSet, false, () => {
                this.target.pushState(this.target.decorationState);
                System_1.System.instance.applyRenderState(this._stencilSetRenderState);
                this.target.techniques.execute(this.target, cmdsH, 7 /* Hilite */);
                this.target.popBranch();
            });
            // Process the stencil volumes, blending into the current color buffer.
            fbStack.execute(fboCopy, true, () => {
                this.target.pushState(this.target.decorationState);
                this._classifyColorRenderState.blend.color = [1.0, 1.0, 1.0, 0.2];
                this._classifyColorRenderState.blend.setBlendFunc(GL_1.GL.BlendFactor.ConstAlpha, GL_1.GL.BlendFactor.OneMinusConstAlpha); // Mix with select/hilite color
                System_1.System.instance.applyRenderState(this._classifyColorRenderState);
                const params = getDrawParams(this.target, this._geom.stencilCopy);
                this.target.techniques.draw(params);
                this.target.popBranch();
            });
        }
        // Process the flashed classifier if there is one.
        if (flashedClassifier !== -1) {
            // Set the stencil for this one classifier.
            fbStack.execute(this._frameBuffers.stencilSet, false, () => {
                this.target.pushState(this.target.decorationState);
                System_1.System.instance.applyRenderState(this._stencilSetRenderState);
                this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, 4 /* Classification */, flashedClassifier);
                this.target.popBranch();
            });
            // Process the stencil.
            fbStack.execute(fboCopy, true, () => {
                this.target.pushState(this.target.decorationState);
                this._classifyColorRenderState.blend.color = [1.0, 1.0, 1.0, this.target.flashIntensity * 0.5];
                this._classifyColorRenderState.blend.setBlendFuncSeparate(GL_1.GL.BlendFactor.ConstAlpha, GL_1.GL.BlendFactor.ConstAlpha, GL_1.GL.BlendFactor.One, GL_1.GL.BlendFactor.OneMinusConstAlpha); // want to just add flash color
                System_1.System.instance.applyRenderState(this._classifyColorRenderState);
                this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, 2 /* OpaquePlanar */, flashedClassifier);
                this.target.popBranch();
            });
        }
        // Process the area outside the classifiers.
        // ###TODO: Need a way to only do this to reality mesh and point cloud data
        // Set the stencil using the stencil command list.
        fbStack.execute(fboSet, false, () => {
            this.target.pushState(this.target.decorationState);
            System_1.System.instance.applyRenderState(this._stencilSetRenderState);
            this.target.techniques.execute(this.target, cmds, 4 /* Classification */);
            this.target.popBranch();
        });
        // Process the stencil volumes, blending into the current color buffer.
        fbStack.execute(fboCopy, true, () => {
            this.target.pushState(this.target.decorationState);
            this._classifyColorRenderState.stencil.frontFunction.function = GL_1.GL.StencilFunction.Equal;
            this._classifyColorRenderState.stencil.backFunction.function = GL_1.GL.StencilFunction.Equal;
            this._classifyColorRenderState.blend.color = [1.0, 1.0, 1.0, 0.4];
            this._classifyColorRenderState.blend.setBlendFuncSeparate(GL_1.GL.BlendFactor.Zero, GL_1.GL.BlendFactor.Zero, GL_1.GL.BlendFactor.ConstAlpha, GL_1.GL.BlendFactor.One); // want to just darken dest. color
            System_1.System.instance.applyRenderState(this._classifyColorRenderState);
            this._classifyColorRenderState.stencil.frontFunction.function = GL_1.GL.StencilFunction.NotEqual;
            this._classifyColorRenderState.stencil.backFunction.function = GL_1.GL.StencilFunction.NotEqual;
            const params = getDrawParams(this.target, this._geom.stencilCopy);
            this.target.techniques.draw(params);
            this.target.popBranch();
        });
    }
    renderHilite(commands) {
        const system = System_1.System.instance;
        system.frameBufferStack.execute(this._frameBuffers.hilite, true, () => {
            // Clear the hilite buffer.
            system.context.clearColor(0, 0, 0, 0);
            system.context.clear(GL_1.GL.BufferBit.Color);
            // Draw the normal hilite geometry.
            this.drawPass(commands, 7 /* Hilite */);
        });
        // Process planar classifiers
        const planarClassifierCmds = commands.getCommands(14 /* HilitePlanarClassification */);
        if (0 !== planarClassifierCmds.length) {
            system.frameBufferStack.execute(this._frameBuffers.hiliteUsingStencil, true, () => {
                system.applyRenderState(this._opaqueRenderState);
                system.context.clearDepth(1.0);
                system.context.clear(GL_1.GL.BufferBit.Depth);
                system.context.clearColor(0, 0, 0, 0);
                system.context.clear(GL_1.GL.BufferBit.Color);
                this.target.techniques.execute(this.target, planarClassifierCmds, 14 /* HilitePlanarClassification */);
            });
        }
        // Process the hilite stencil volumes.
        const cmds = commands.getCommands(12 /* HiliteClassification */);
        if (0 === cmds.length) {
            return;
        }
        // Set the stencil for the given classifier stencil volume.
        system.frameBufferStack.execute(this._frameBuffers.stencilSet, false, () => {
            this.target.pushState(this.target.decorationState);
            system.applyRenderState(this._stencilSetRenderState);
            this.target.techniques.execute(this.target, cmds, 7 /* Hilite */);
            this.target.popBranch();
        });
        // Process the stencil for the hilite data.
        system.frameBufferStack.execute(this._frameBuffers.hiliteUsingStencil, true, () => {
            system.applyRenderState(this._classifyPickDataRenderState);
            this.target.techniques.execute(this.target, cmds, 7 /* Hilite */);
        });
    }
    composite() {
        System_1.System.instance.applyRenderState(RenderState_1.RenderState.defaults);
        const params = getDrawParams(this.target, this._geom.composite);
        this.target.techniques.draw(params);
    }
    getRenderState(pass) {
        switch (pass) {
            case 1 /* OpaqueLinear */:
            case 2 /* OpaquePlanar */:
            case 3 /* OpaqueGeneral */:
            case 14 /* HilitePlanarClassification */:
                return this._opaqueRenderState;
            case 5 /* Translucent */:
                return this._translucentRenderState;
            default:
                return this._noDepthMaskRenderState;
        }
    }
    drawPass(commands, pass, pingPong = false) {
        const cmds = commands.getCommands(pass);
        if (0 === cmds.length) {
            return;
        }
        else if (pingPong) {
            this.pingPong();
        }
        System_1.System.instance.applyRenderState(this.getRenderState(pass));
        this.target.techniques.execute(this.target, cmds, pass);
    }
}
class MRTFrameBuffers extends FrameBuffers {
    init(textures, depth) {
        if (!super.init(textures, depth))
            return false;
        bentleyjs_core_1.assert(undefined === this.opaqueAll);
        const boundColor = System_1.System.instance.frameBufferStack.currentColorBuffer;
        if (undefined === boundColor)
            return false;
        const colorAndPick = [boundColor, textures.featureId, textures.depthAndOrder];
        this.opaqueAll = FrameBuffer_1.FrameBuffer.create(colorAndPick, depth);
        colorAndPick[0] = textures.color;
        this.opaqueAndCompositeAll = FrameBuffer_1.FrameBuffer.create(colorAndPick, depth);
        const colors = [textures.accumulation, textures.revealage];
        this.translucent = FrameBuffer_1.FrameBuffer.create(colors, depth);
        this.clearTranslucent = FrameBuffer_1.FrameBuffer.create(colors);
        // We borrow the SceneCompositor's accum and revealage textures for the surface pass.
        // First we render edges, writing to our textures.
        // Then we copy our textures to borrowed textures.
        // Finally we render surfaces, writing to our textures and reading from borrowed textures.
        const pingPong = [textures.accumulation, textures.revealage];
        this.pingPong = FrameBuffer_1.FrameBuffer.create(pingPong);
        const ids = [boundColor, textures.featureId];
        this.idOnly = FrameBuffer_1.FrameBuffer.create(ids, depth);
        colorAndPick[0] = textures.color;
        this.idOnlyAndComposite = FrameBuffer_1.FrameBuffer.create(ids, depth);
        return undefined !== this.opaqueAll
            && undefined !== this.opaqueAndCompositeAll
            && undefined !== this.pingPong
            && undefined !== this.translucent
            && undefined !== this.clearTranslucent
            && undefined !== this.idOnly
            && undefined !== this.idOnlyAndComposite;
    }
    dispose() {
        super.dispose();
        this.opaqueAll = bentleyjs_core_1.dispose(this.opaqueAll);
        this.opaqueAndCompositeAll = bentleyjs_core_1.dispose(this.opaqueAndCompositeAll);
        this.pingPong = bentleyjs_core_1.dispose(this.pingPong);
        this.translucent = bentleyjs_core_1.dispose(this.translucent);
        this.clearTranslucent = bentleyjs_core_1.dispose(this.clearTranslucent);
        this.idOnly = bentleyjs_core_1.dispose(this.idOnly);
        this.idOnlyAndComposite = bentleyjs_core_1.dispose(this.idOnlyAndComposite);
    }
}
class MRTGeometry extends Geometry {
    init(textures) {
        if (!super.init(textures))
            return false;
        bentleyjs_core_1.assert(undefined === this.copyPickBuffers);
        this.copyPickBuffers = CachedGeometry_1.CopyPickBufferGeometry.createGeometry(textures.featureId.getHandle(), textures.depthAndOrder.getHandle());
        this.clearTranslucent = CachedGeometry_1.ViewportQuadGeometry.create(13 /* OITClearTranslucent */);
        this.clearPickAndColor = CachedGeometry_1.ViewportQuadGeometry.create(18 /* ClearPickAndColor */);
        return undefined !== this.copyPickBuffers && undefined !== this.clearTranslucent && undefined !== this.clearPickAndColor;
    }
    dispose() {
        super.dispose();
        this.copyPickBuffers = bentleyjs_core_1.dispose(this.copyPickBuffers);
        this.clearTranslucent = bentleyjs_core_1.dispose(this.clearTranslucent);
        this.clearPickAndColor = bentleyjs_core_1.dispose(this.clearPickAndColor);
    }
}
// SceneCompositor used when multiple render targets are supported (WEBGL_draw_buffers exists and supports at least 4 color attachments).
class MRTCompositor extends Compositor {
    constructor(target) {
        super(target, new MRTFrameBuffers(), new MRTGeometry());
    }
    get currentRenderTargetIndex() {
        bentleyjs_core_1.assert(false, "MRT is supported");
        return 0;
    }
    set currentRenderTargetIndex(_index) {
        bentleyjs_core_1.assert(false, "MRT is supported");
    }
    get featureIds() { return this.getSamplerTexture(this._readPickDataFromPingPong ? 0 : 1); }
    get depthAndOrder() { return this.getSamplerTexture(this._readPickDataFromPingPong ? 1 : 2); }
    get _fbos() { return this._frameBuffers; }
    get _geometry() { return this._geom; }
    clearOpaque(needComposite) {
        const fbo = needComposite ? this._fbos.opaqueAndCompositeAll : this._fbos.opaqueAll;
        const system = System_1.System.instance;
        system.frameBufferStack.execute(fbo, true, () => {
            // Clear pick data buffers to 0's and color buffer to background color
            // (0,0,0,0) in elementID0 and ElementID1 buffers indicates invalid element id
            // (0,0,0,0) in DepthAndOrder buffer indicates render order 0 and encoded depth of 0 (= far plane)
            system.applyRenderState(this._noDepthMaskRenderState);
            const params = getDrawParams(this.target, this._geometry.clearPickAndColor);
            this.target.techniques.draw(params);
            // Clear depth buffer
            system.applyRenderState(RenderState_1.RenderState.defaults); // depthMask == true.
            system.context.clearDepth(1.0);
            system.context.clear(GL_1.GL.BufferBit.Depth);
        });
    }
    renderOpaque(commands, compositeFlags, renderForReadPixels) {
        // Output the first 2 passes to color and pick data buffers. (All 3 in the case of rendering for readPixels()).
        this._readPickDataFromPingPong = true;
        const needComposite = 0 /* None */ !== compositeFlags;
        const needAO = 0 /* None */ !== (compositeFlags & 4 /* AmbientOcclusion */);
        let fbStack = System_1.System.instance.frameBufferStack;
        fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeAll : this._fbos.opaqueAll, true, () => {
            this.drawPass(commands, 1 /* OpaqueLinear */);
            this.drawPass(commands, 2 /* OpaquePlanar */, true);
            if (needAO || renderForReadPixels) {
                this.drawPass(commands, 3 /* OpaqueGeneral */, true);
                if (needAO)
                    this.renderAmbientOcclusion();
            }
        });
        this._readPickDataFromPingPong = false;
        // The general pass (and following) will not bother to write to pick buffers and so can read from the actual pick buffers.
        if (!renderForReadPixels && !needAO) {
            fbStack = System_1.System.instance.frameBufferStack;
            fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor, true, () => {
                this.drawPass(commands, 3 /* OpaqueGeneral */, false);
                this.drawPass(commands, 6 /* HiddenEdge */, false);
            });
        }
    }
    renderIndexedClassifierForReadPixels(cmdsByIndex, index, state, needComposite) {
        this._readPickDataFromPingPong = true;
        const fbStack = System_1.System.instance.frameBufferStack;
        fbStack.execute(needComposite ? this._fbos.idOnlyAndComposite : this._fbos.idOnly, true, () => {
            System_1.System.instance.applyRenderState(state);
            this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, 3 /* OpaqueGeneral */, index);
        });
        this._readPickDataFromPingPong = false;
    }
    clearTranslucent() {
        System_1.System.instance.applyRenderState(this._noDepthMaskRenderState);
        System_1.System.instance.frameBufferStack.execute(this._fbos.clearTranslucent, true, () => {
            const params = getDrawParams(this.target, this._geometry.clearTranslucent);
            this.target.techniques.draw(params);
        });
    }
    renderTranslucent(commands) {
        System_1.System.instance.frameBufferStack.execute(this._fbos.translucent, true, () => {
            this.drawPass(commands, 5 /* Translucent */);
        });
    }
    pingPong() {
        System_1.System.instance.applyRenderState(this._noDepthMaskRenderState);
        System_1.System.instance.frameBufferStack.execute(this._fbos.pingPong, true, () => {
            const params = getDrawParams(this.target, this._geometry.copyPickBuffers);
            this.target.techniques.draw(params);
        });
    }
    getBackgroundFbo(needComposite) { return needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor; }
    get _samplerFbo() { return this._readPickDataFromPingPong ? this._fbos.pingPong : this._fbos.opaqueAll; }
    getSamplerTexture(index) { return this._samplerFbo.getColor(index); }
}
class MPFrameBuffers extends FrameBuffers {
    init(textures, depth) {
        if (!super.init(textures, depth))
            return false;
        bentleyjs_core_1.assert(undefined === this.accumulation);
        this.accumulation = FrameBuffer_1.FrameBuffer.create([textures.accumulation], depth);
        this.revealage = FrameBuffer_1.FrameBuffer.create([textures.revealage], depth);
        this.featureId = FrameBuffer_1.FrameBuffer.create([textures.featureId], depth);
        this.featureIdWithDepth = FrameBuffer_1.FrameBuffer.create([textures.featureId], depth);
        return undefined !== this.accumulation && undefined !== this.revealage && undefined !== this.featureId && undefined !== this.featureIdWithDepth;
    }
    dispose() {
        super.dispose();
        this.accumulation = bentleyjs_core_1.dispose(this.accumulation);
        this.revealage = bentleyjs_core_1.dispose(this.revealage);
        this.featureId = bentleyjs_core_1.dispose(this.featureId);
        this.featureIdWithDepth = bentleyjs_core_1.dispose(this.featureIdWithDepth);
    }
}
class MPGeometry extends Geometry {
    init(textures) {
        if (!super.init(textures))
            return false;
        bentleyjs_core_1.assert(undefined === this.copyColor);
        this.copyColor = CachedGeometry_1.SingleTexturedViewportQuadGeometry.createGeometry(textures.featureId.getHandle(), 15 /* CopyColor */);
        return undefined !== this.copyColor;
    }
    dispose() {
        super.dispose();
        this.copyColor = bentleyjs_core_1.dispose(this.copyColor);
    }
}
// Compositor used when multiple render targets are not supported (WEBGL_draw_buffers not available or fewer than 4 color attachments supported).
// This falls back to multi-pass rendering in place of MRT rendering, which has obvious performance implications.
// The chief use case is iOS.
class MPCompositor extends Compositor {
    constructor(target) {
        super(target, new MPFrameBuffers(), new MPGeometry());
        this._currentRenderTargetIndex = 0;
        this._drawMultiPassDepth = true;
        this._opaqueRenderStateNoZWt = new RenderState_1.RenderState();
        this._opaqueRenderStateNoZWt.flags.depthTest = true;
        this._opaqueRenderStateNoZWt.flags.depthMask = false;
    }
    getRenderState(pass) {
        switch (pass) {
            case 1 /* OpaqueLinear */:
            case 2 /* OpaquePlanar */:
            case 3 /* OpaqueGeneral */:
                return this._drawMultiPassDepth ? this._opaqueRenderState : this._opaqueRenderStateNoZWt;
        }
        return super.getRenderState(pass);
    }
    get _fbos() { return this._frameBuffers; }
    get _geometry() { return this._geom; }
    get currentRenderTargetIndex() { return this._currentRenderTargetIndex; }
    set currentRenderTargetIndex(index) { this._currentRenderTargetIndex = index; }
    get featureIds() { return this._readPickDataFromPingPong ? this._textures.accumulation : this._textures.featureId; }
    get depthAndOrder() { return this._readPickDataFromPingPong ? this._textures.revealage : this._textures.depthAndOrder; }
    getBackgroundFbo(needComposite) { return needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor; }
    clearOpaque(needComposite) {
        const bg = this.target.bgColor;
        this.clearFbo(needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor, bg.red, bg.green, bg.blue, bg.alpha, true);
        this.clearFbo(this._fbos.depthAndOrder, 0, 0, 0, 0, false);
        this.clearFbo(this._fbos.featureId, 0, 0, 0, 0, false);
    }
    renderOpaque(commands, compositeFlags, renderForReadPixels) {
        // Output the first 2 passes to color and pick data buffers. (All 3 in the case of rendering for readPixels()).
        this._readPickDataFromPingPong = true;
        const needComposite = 0 /* None */ !== compositeFlags;
        const needAO = 0 /* None */ !== (compositeFlags & 4 /* AmbientOcclusion */);
        const colorFbo = needComposite ? this._fbos.opaqueAndCompositeColor : this._fbos.opaqueColor;
        this.drawOpaquePass(colorFbo, commands, 1 /* OpaqueLinear */, false);
        this.drawOpaquePass(colorFbo, commands, 2 /* OpaquePlanar */, true);
        if (renderForReadPixels || needAO) {
            this.drawOpaquePass(colorFbo, commands, 3 /* OpaqueGeneral */, true);
            if (needAO)
                this.renderAmbientOcclusion();
        }
        this._readPickDataFromPingPong = false;
        // The general pass (and following) will not bother to write to pick buffers and so can read from the actual pick buffers.
        if (!renderForReadPixels && !needAO) {
            System_1.System.instance.frameBufferStack.execute(colorFbo, true, () => {
                this._drawMultiPassDepth = true; // for OpaqueGeneral
                this.drawPass(commands, 3 /* OpaqueGeneral */, false);
                this.drawPass(commands, 6 /* HiddenEdge */, false);
            });
        }
    }
    renderIndexedClassifierForReadPixels(cmdsByIndex, index, state, _needComposite) {
        // Note that we only need to render to the Id textures here, no color, since the color buffer is not used in readPixels.
        this._readPickDataFromPingPong = true;
        const stack = System_1.System.instance.frameBufferStack;
        this._currentRenderTargetIndex = 1;
        stack.execute(this._fbos.featureIdWithDepth, true, () => {
            state.stencil.backOperation.zPass = GL_1.GL.StencilOperation.Zero;
            System_1.System.instance.applyRenderState(state);
            this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, 3 /* OpaqueGeneral */, index);
        });
        this._currentRenderTargetIndex = 0;
        this._readPickDataFromPingPong = false;
    }
    // ###TODO: For readPixels(), could skip rendering color...also could skip rendering depth and/or element ID depending upon selector...
    drawOpaquePass(colorFbo, commands, pass, pingPong) {
        const stack = System_1.System.instance.frameBufferStack;
        this._drawMultiPassDepth = true;
        if (!this.target.isReadPixelsInProgress) {
            stack.execute(colorFbo, true, () => this.drawPass(commands, pass, pingPong));
            this._drawMultiPassDepth = false;
        }
        this._currentRenderTargetIndex++;
        if (!this.target.isReadPixelsInProgress || 0 /* None */ !== (this.target.readPixelsSelector & 1 /* Feature */)) {
            stack.execute(this._fbos.featureId, true, () => this.drawPass(commands, pass, pingPong && this._drawMultiPassDepth));
            this._drawMultiPassDepth = false;
        }
        this._currentRenderTargetIndex++;
        if (!this.target.isReadPixelsInProgress || 0 /* None */ !== (this.target.readPixelsSelector & 4 /* GeometryAndDistance */)) {
            stack.execute(this._fbos.depthAndOrder, true, () => this.drawPass(commands, pass, pingPong && this._drawMultiPassDepth));
        }
        this._currentRenderTargetIndex = 0;
    }
    clearTranslucent() {
        this.clearFbo(this._fbos.accumulation, 0, 0, 0, 1, false);
        this.clearFbo(this._fbos.revealage, 1, 0, 0, 1, false);
    }
    renderTranslucent(commands) {
        System_1.System.instance.frameBufferStack.execute(this._fbos.accumulation, true, () => {
            this.drawPass(commands, 5 /* Translucent */);
        });
        this._currentRenderTargetIndex = 1;
        System_1.System.instance.frameBufferStack.execute(this._fbos.revealage, true, () => {
            this.drawPass(commands, 5 /* Translucent */);
        });
        this._currentRenderTargetIndex = 0;
    }
    pingPong() {
        System_1.System.instance.applyRenderState(this._noDepthMaskRenderState);
        this.copyFbo(this._textures.featureId, this._fbos.accumulation);
        this.copyFbo(this._textures.depthAndOrder, this._fbos.revealage);
    }
    copyFbo(src, dst) {
        const geom = this._geometry.copyColor;
        geom.texture = src.getHandle();
        System_1.System.instance.frameBufferStack.execute(dst, true, () => {
            const params = getDrawParams(this.target, geom);
            this.target.techniques.draw(params);
        });
    }
    clearFbo(fbo, red, green, blue, alpha, andDepth) {
        const system = System_1.System.instance;
        const gl = system.context;
        system.frameBufferStack.execute(fbo, true, () => {
            system.applyRenderState(andDepth ? RenderState_1.RenderState.defaults : this._noDepthMaskRenderState);
            gl.clearColor(red, green, blue, alpha);
            let bit = GL_1.GL.BufferBit.Color;
            if (andDepth) {
                gl.clearDepth(1.0);
                bit |= GL_1.GL.BufferBit.Depth;
            }
            gl.clear(bit);
        });
    }
}


/***/ }),

/***/ "./lib/render/webgl/ShaderBuilder.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/ShaderBuilder.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ShaderProgram_1 = __webpack_require__(/*! ./ShaderProgram */ "./lib/render/webgl/ShaderProgram.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const TechniqueFlags_1 = __webpack_require__(/*! ./TechniqueFlags */ "./lib/render/webgl/TechniqueFlags.js");
const Vertex_1 = __webpack_require__(/*! ./glsl/Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Instancing_1 = __webpack_require__(/*! ./glsl/Instancing */ "./lib/render/webgl/glsl/Instancing.js");
const Clipping_1 = __webpack_require__(/*! ./glsl/Clipping */ "./lib/render/webgl/glsl/Clipping.js");
/** @internal */
var Convert;
(function (Convert) {
    function typeToString(type) {
        switch (type) {
            case 0 /* Boolean */: return "bool";
            case 1 /* Int */: return "int";
            case 2 /* Float */: return "float";
            case 3 /* Vec2 */: return "vec2";
            case 4 /* Vec3 */: return "vec3";
            case 5 /* Vec4 */: return "vec4";
            case 6 /* Mat3 */: return "mat3";
            case 7 /* Mat4 */: return "mat4";
            case 8 /* Sampler2D */: return "sampler2D";
            case 9 /* SamplerCube */: return "samplerCube";
            default:
                bentleyjs_core_1.assert(false);
                return "undefined";
        }
    }
    Convert.typeToString = typeToString;
    function scopeToString(scope) {
        switch (scope) {
            case 0 /* Global */: return "";
            case 1 /* Varying */: return "varying";
            case 2 /* Uniform */: return "uniform";
            case 3 /* Attribute */: return "attribute";
            default:
                bentleyjs_core_1.assert(false);
                return "undefined";
        }
    }
    Convert.scopeToString = scopeToString;
    function precisionToString(precision) {
        switch (precision) {
            case 0 /* Default */: return "";
            case 1 /* Low */: return "lowp";
            case 2 /* Medium */: return "mediump";
            case 3 /* High */: return "highp";
            default:
                bentleyjs_core_1.assert(false);
                return "undefined";
        }
    }
    Convert.precisionToString = precisionToString;
})(Convert || (Convert = {}));
/** Represents a variable within a fragment or vertex shader.
 * @internal
 */
class ShaderVariable {
    constructor(name, type, scope, precision, isConst, addBinding, value) {
        this.isConst = false; // for global variables only
        this._addBinding = addBinding;
        this.name = name;
        this.value = value;
        this.type = type;
        this.scope = scope;
        this.precision = precision;
        this.isConst = isConst;
    }
    static create(name, type, scope, addBinding, precision = 0 /* Default */) {
        return new ShaderVariable(name, type, scope, precision, false, addBinding, undefined);
    }
    static createGlobal(name, type, value, isConst = false) {
        return new ShaderVariable(name, type, 0 /* Global */, 0 /* Default */, isConst, undefined, value);
    }
    get hasBinding() { return undefined !== this._addBinding; }
    addBinding(prog) {
        if (undefined !== this._addBinding)
            this._addBinding(prog);
    }
    get typeName() { return Convert.typeToString(this.type); }
    get scopeName() { return Convert.scopeToString(this.scope); }
    get precisionName() { return Convert.precisionToString(this.precision); }
    /** Constructs the single-line declaration of this variable */
    buildDeclaration() {
        const parts = new Array();
        if (this.isConst)
            parts.push("const");
        const scopeName = this.scopeName;
        if (0 < scopeName.length)
            parts.push(scopeName);
        const precisionName = this.precisionName;
        if (0 < precisionName.length)
            parts.push(precisionName);
        parts.push(this.typeName);
        parts.push(this.name);
        if (undefined !== this.value && 0 < this.value.length) {
            parts.push("=");
            parts.push(this.value);
        }
        return parts.join(" ") + ";";
    }
}
exports.ShaderVariable = ShaderVariable;
/**
 * Represents the set of variables defined and used within a fragment or vertex shader.
 * If the same variable is used in both the fragment and vertex shader (e.g., a varying variable), it should be defined in both ShaderBuilders' ShaderVariables object.
 * @internal
 */
class ShaderVariables {
    constructor() {
        this.list = new Array();
    }
    /** Find an existing variable with the specified name */
    find(name) { return this.list.find((v) => v.name === name); }
    /** Add a new variable, if a variable with the same name does not already exist. */
    addVariable(v) {
        const found = this.find(v.name);
        if (undefined !== found) {
            bentleyjs_core_1.assert(found.type === v.type);
            // assume same binding etc...
        }
        else {
            this.list.push(v);
        }
    }
    addUniform(name, type, binding, precision = 0 /* Default */) {
        this.addVariable(ShaderVariable.create(name, type, 2 /* Uniform */, binding, precision));
    }
    addAttribute(name, type, binding) {
        this.addVariable(ShaderVariable.create(name, type, 3 /* Attribute */, binding));
    }
    addVarying(name, type) {
        this.addVariable(ShaderVariable.create(name, type, 1 /* Varying */));
    }
    addGlobal(name, type, value, isConst = false) {
        this.addVariable(ShaderVariable.createGlobal(name, type, value, isConst));
    }
    addConstant(name, type, value) {
        this.addGlobal(name, type, value, true);
    }
    /** Constructs the lines of glsl code declaring all of the variables. */
    buildDeclarations() {
        let decls = "";
        for (const v of this.list) {
            decls += v.buildDeclaration() + "\n";
        }
        return decls;
    }
    /**
     * For every uniform and attribute variable not contained in the optional 'predefined' list, invokes the associated binding function
     * to add the corresponding Uniform or Attribute object to the ShaderProgram.
     */
    addBindings(prog, predefined) {
        for (const v of this.list) {
            // Some variables exist in both frag and vert shaders - only add them to the program once.
            if (v.hasBinding && (undefined === predefined || undefined === predefined.find(v.name))) {
                v.addBinding(prog);
            }
        }
    }
    get length() { return this.list.length; }
    // Return true if GL_MAX_VARYING_VECTORS has been exceeded for the minimum guaranteed value of 8.
    exceedsMaxVaryingVectors() {
        // Varyings go into a matrix of 4 columns and GL_MAX_VARYING_VECTORS rows of floats.
        // The packing rules are defined by the standard. Specifically each row can contain one of:
        //  vec4
        //  vec3 (+ float)
        //  vec2 (+ vec2)
        //  vec2 (+ float (+ float))
        //  float (+ float (+ float (+ float)))
        const registers = [0, 0, 0, 0, 0, 0, 0, 0];
        for (const variable of this.list) {
            if (1 /* Varying */ !== variable.scope)
                continue;
            let variableSize = 0;
            switch (variable.type) {
                case 1 /* Int */:
                case 2 /* Float */:
                    variableSize = 1;
                    break;
                case 3 /* Vec2 */:
                    variableSize = 2;
                    break;
                case 4 /* Vec3 */:
                    variableSize = 3;
                    break;
                case 5 /* Vec4 */:
                    variableSize = 4;
                    break;
                default:
                    bentleyjs_core_1.assert(false, "Invalid varying variable type");
                    continue;
            }
            // Find the first available slot into which to insert this variable
            let slotAvailable = false;
            for (let i = 0; i < 8; i++) {
                const newSize = registers[i] + variableSize;
                if (newSize <= 4) {
                    registers[i] = newSize;
                    slotAvailable = true;
                    break;
                }
            }
            if (!slotAvailable)
                return true;
        }
        return false;
    }
}
exports.ShaderVariables = ShaderVariables;
/** Convenience API for assembling glsl source code.
 * @internal
 */
class SourceBuilder {
    constructor() {
        this.source = "";
    }
    /* Append the specified string to the glsl source */
    add(what) { this.source += what; }
    /* Append a new-line to the glsl source */
    newline() { this.add("\n"); }
    /* Append the specified string to the glsl source, followed by a new-line */
    addline(what) { this.add(what); this.newline(); }
    /**
     * Construct a function definition given the function signature and body. For example:
     * buildFunctionDefintion("float average(float a, float b)", "\n  return (a + b) / 2.0;\n");
     * will produce:
     *  "float average(float a, float b) {
     *     return (a + b) / 2.0;
     *   }"
     * For an inline function:
     * buildFunctionDefintion("float average(float a, float b)", "return (a + b) / 2.0;");
     * will produce:
     *  "float average(float a, float b) { return (a + b) / 2.0; }"
     */
    static buildFunctionDefinition(declaration, implementation) {
        // If implementation does not start with a newline then assume it is an inline function & add spaces between braces.
        if ("\n" === implementation.charAt(0))
            return declaration + " {" + implementation + "}\n\n";
        else
            return declaration + " { " + implementation + " }\n\n";
    }
    /** Constructs a function definition as described by buildFunctionDefinition() and appends it to the glsl source. */
    addFunction(declaration, implementation) { this.add(SourceBuilder.buildFunctionDefinition(declaration, implementation)); }
    /** Constructs the definition of the main() function using the supplied function body and appends it to the glsl source. */
    addMain(implementation) { this.addFunction("void main()", implementation); }
}
exports.SourceBuilder = SourceBuilder;
/*
 * Represents a fragment or vertex shader under construction. The shader consists of a set of defined variables,
 * plus a set of code snippets which can be concatenated together to form the shader source.
 * @internal
 */
class ShaderBuilder extends ShaderVariables {
    constructor(maxComponents, flags) {
        super();
        this.components = new Array();
        this.functions = new Array();
        this.extensions = new Array();
        this.headerComment = "";
        this.components.length = maxComponents;
        this._flags = flags;
    }
    get usesVertexTable() { return 0 /* None */ !== (this._flags & 1 /* VertexTable */); }
    get usesInstancedGeometry() { return 0 /* None */ !== (this._flags & 2 /* Instanced */); }
    addComponent(index, component) {
        bentleyjs_core_1.assert(index < this.components.length);
        // assume if caller is replacing an existing component, they know what they're doing...
        this.components[index] = component;
    }
    removeComponent(index) {
        bentleyjs_core_1.assert(index < this.components.length);
        this.components[index] = undefined;
    }
    getComponent(index) {
        bentleyjs_core_1.assert(index < this.components.length);
        return this.components[index];
    }
    addFunction(declarationOrFull, implementation) {
        let def = declarationOrFull;
        if (undefined !== implementation) {
            def = SourceBuilder.buildFunctionDefinition("\n" + declarationOrFull, implementation);
        }
        if (undefined === this.findFunction(def)) {
            this.functions.push(def);
        }
    }
    replaceFunction(existing, replacement) {
        const index = this.functions.indexOf(existing);
        if (-1 !== index) {
            this.functions[index] = replacement;
        }
        bentleyjs_core_1.assert(-1 !== index);
        return -1 !== index;
    }
    findFunction(func) {
        return this.functions.find((f) => f === func);
    }
    addExtension(extName) {
        if (-1 === this.extensions.indexOf(extName)) {
            this.extensions.push(extName);
        }
    }
    buildPreludeCommon(isFrag = false, isLit = false, maxClippingPlanes = 0) {
        const src = new SourceBuilder();
        src.addline("#version 100");
        src.addline("#define TEXTURE texture2D");
        src.addline("#define TEXTURE_CUBE textureCube");
        if (maxClippingPlanes > 0)
            src.addline("#define MAX_CLIPPING_PLANES " + maxClippingPlanes);
        // Header comment
        src.newline();
        if ("" !== this.headerComment) {
            src.addline(this.headerComment);
            src.newline();
        }
        // Extensions
        let needMultiDrawBuffers = false;
        for (const ext of this.extensions) {
            if (ext === "GL_EXT_draw_buffers") {
                bentleyjs_core_1.assert(System_1.System.instance.capabilities.supportsDrawBuffers, "GL_EXT_draw_buffers unsupported");
                needMultiDrawBuffers = true;
            }
            src.addline("#extension " + ext + " : enable");
        }
        // Default precisions
        src.addline("precision highp float;");
        src.addline("precision highp int;");
        src.newline();
        // Variable declarations
        src.add(this.buildDeclarations());
        if (!isFrag) {
            src.addline("#define MAT_NORM g_nmx");
            if (!this.usesInstancedGeometry) {
                src.addline("#define MAT_MV u_mv");
                src.addline("#define MAT_MVP u_mvp");
                src.addline("#define MAT_MODEL u_modelMatrix");
            }
            else {
                src.addline("#define MAT_MV g_mv");
                src.addline("#define MAT_MVP g_mvp");
                src.addline("#define MAT_MODEL g_instancedModelMatrix");
            }
        }
        else {
            src.addline("#define FragColor gl_FragColor");
            if (needMultiDrawBuffers) {
                src.addline("#define FragColor0 gl_FragData[0]");
                src.addline("#define FragColor1 gl_FragData[1]");
                src.addline("#define FragColor2 gl_FragData[2]");
                src.addline("#define FragColor3 gl_FragData[3]");
            }
            if (isLit) {
                // ###TODO: Source Lighting
            }
        }
        // Functions
        for (const func of this.functions) {
            src.add(func);
        }
        if (0 !== this.functions.length)
            src.newline();
        return src;
    }
}
exports.ShaderBuilder = ShaderBuilder;
/** Assembles the source code for a vertex shader from a set of modular components.
 * @internal
 */
class VertexShaderBuilder extends ShaderBuilder {
    constructor(flags) {
        super(6 /* COUNT */, flags);
        this._computedVarying = new Array();
        this._initializers = new Array();
        if (this.usesInstancedGeometry)
            Instancing_1.addInstancedModelMatrixRTC(this);
        Vertex_1.addPosition(this, this.usesVertexTable);
    }
    get computedVarying() { return this._computedVarying; }
    get initializers() { return this._initializers; }
    buildPrelude() { return this.buildPreludeCommon(); }
    get(id) { return this.getComponent(id); }
    set(id, component) { this.addComponent(id, component); }
    unset(id) { this.removeComponent(id); }
    addInitializer(initializer) { this._initializers.push(initializer); }
    addComputedVarying(name, type, computation) {
        this.addVarying(name, type);
        this._computedVarying.push(computation);
    }
    buildSource() {
        const prelude = this.buildPrelude();
        const main = new SourceBuilder();
        main.newline();
        const computePosition = this.get(4 /* ComputePosition */);
        bentleyjs_core_1.assert(undefined !== computePosition);
        if (undefined !== computePosition) {
            prelude.addFunction("vec4 computePosition(vec4 rawPos)", computePosition);
        }
        // Initialization logic that should occur at start of main() - primarily global variables whose values
        // are too complex to compute inline or which depend on uniforms and/or other globals.
        for (const init of this._initializers) {
            main.addline("  {" + init + "  }\n");
        }
        main.addline("  vec4 rawPosition = unquantizeVertexPosition(a_pos, u_qOrigin, u_qScale);");
        const adjustRawPosition = this.get(0 /* AdjustRawPosition */);
        if (undefined !== adjustRawPosition) {
            prelude.addFunction("vec4 adjustRawPosition(vec4 rawPos)", adjustRawPosition);
            main.addline("  rawPosition = adjustRawPosition(rawPosition);");
        }
        const checkForEarlyDiscard = this.get(1 /* CheckForEarlyDiscard */);
        if (undefined !== checkForEarlyDiscard) {
            prelude.addFunction("bool checkForEarlyDiscard(vec4 rawPos)", checkForEarlyDiscard);
            main.add(Vertex_1.GLSLVertex.earlyDiscard);
        }
        const computeFeatureOverrides = this.get(2 /* ComputeFeatureOverrides */);
        if (undefined !== computeFeatureOverrides) {
            prelude.addFunction("void computeFeatureOverrides()", computeFeatureOverrides);
            main.addline("  computeFeatureOverrides();");
        }
        const checkForDiscard = this.get(3 /* CheckForDiscard */);
        if (undefined !== checkForDiscard) {
            prelude.addFunction("bool checkForDiscard()", checkForDiscard);
            main.add(Vertex_1.GLSLVertex.discard);
        }
        main.addline("  gl_Position = computePosition(rawPosition);");
        for (const comp of this._computedVarying) {
            main.addline("  " + comp);
        }
        const checkForLateDiscard = this.get(5 /* CheckForLateDiscard */);
        if (undefined !== checkForLateDiscard) {
            prelude.addFunction("bool checkForLateDiscard()", checkForLateDiscard);
            main.addline(Vertex_1.GLSLVertex.lateDiscard);
        }
        prelude.addMain(main.source);
        return prelude.source;
    }
}
exports.VertexShaderBuilder = VertexShaderBuilder;
/** Assembles the source code for a fragment shader from a set of modular components.
 * @internal
 */
class FragmentShaderBuilder extends ShaderBuilder {
    constructor(flags) {
        super(17 /* COUNT */, flags);
        this.maxClippingPlanes = 0;
    }
    get(id) { return this.getComponent(id); }
    set(id, component) { this.addComponent(id, component); }
    unset(id) { this.removeComponent(id); }
    addDrawBuffersExtension() {
        bentleyjs_core_1.assert(System_1.System.instance.capabilities.supportsDrawBuffers, "WEBGL_draw_buffers unsupported");
        this.addExtension("GL_EXT_draw_buffers");
    }
    buildSource() {
        const applyLighting = this.get(7 /* ApplyLighting */);
        const prelude = this.buildPrelude(undefined !== applyLighting);
        const computeBaseColor = this.get(1 /* ComputeBaseColor */);
        bentleyjs_core_1.assert(undefined !== computeBaseColor);
        if (undefined !== computeBaseColor) {
            prelude.addFunction("vec4 computeBaseColor()", computeBaseColor);
        }
        const main = new SourceBuilder();
        main.newline();
        const checkForEarlyDiscard = this.get(0 /* CheckForEarlyDiscard */);
        if (undefined !== checkForEarlyDiscard) {
            prelude.addFunction("bool checkForEarlyDiscard()", checkForEarlyDiscard);
            main.addline("  if (checkForEarlyDiscard()) { discard; return; }");
        }
        const applyClipping = this.get(10 /* ApplyClipping */);
        if (undefined !== applyClipping) {
            prelude.addFunction("void applyClipping()", applyClipping);
            main.addline("  applyClipping();");
        }
        main.addline("  vec4 baseColor = computeBaseColor();");
        const applyMaterialOverrides = this.get(2 /* ApplyMaterialOverrides */);
        if (undefined !== applyMaterialOverrides) {
            prelude.addFunction("vec4 applyMaterialOverrides(vec4 baseColor)", applyMaterialOverrides);
            main.addline("  baseColor = applyMaterialOverrides(baseColor);");
        }
        const applyPlanarClassifier = this.get(12 /* ApplyPlanarClassifier */);
        if (undefined !== applyPlanarClassifier) {
            prelude.addFunction("vec4 applyPlanarClassifications(vec4 baseColor)", applyPlanarClassifier);
            main.addline("  baseColor = applyPlanarClassifications(baseColor);");
        }
        const applySolarShadowMap = this.get(13 /* ApplySolarShadowMap */);
        if (undefined !== applySolarShadowMap) {
            prelude.addFunction("vec4 applySolarShadowMap(vec4 baseColor)", applySolarShadowMap);
            main.addline("  baseColor = applySolarShadowMap(baseColor);");
        }
        const applyFeatureColor = this.get(3 /* ApplyFeatureColor */);
        if (undefined !== applyFeatureColor) {
            prelude.addFunction("vec4 applyFeatureColor(vec4 baseColor)", applyFeatureColor);
            main.addline("  baseColor = applyFeatureColor(baseColor);");
        }
        const finalize = this.get(4 /* FinalizeBaseColor */);
        if (undefined !== finalize) {
            prelude.addFunction("vec4 finalizeBaseColor(vec4 baseColor)", finalize);
            main.addline("  baseColor = finalizeBaseColor(baseColor);");
        }
        const checkForDiscard = this.get(5 /* CheckForDiscard */);
        if (undefined !== checkForDiscard) {
            prelude.addFunction("bool checkForDiscard(vec4 baseColor)", checkForDiscard);
            main.addline("  if (checkForDiscard(baseColor)) { discard; return; }");
        }
        const discardByAlpha = this.get(6 /* DiscardByAlpha */);
        if (undefined !== discardByAlpha) {
            prelude.addFunction("bool discardByAlpha(float alpha)", discardByAlpha);
            main.addline("  if (discardByAlpha(baseColor.a)) { discard; return; }");
        }
        if (undefined !== applyLighting) {
            prelude.addFunction("vec4 applyLighting(vec4 baseColor)", applyLighting);
            main.addline("  baseColor = applyLighting(baseColor);");
        }
        const applyMonochrome = this.get(8 /* ApplyMonochrome */);
        if (undefined !== applyMonochrome) {
            prelude.addFunction("vec4 applyMonochrome(vec4 baseColor)", applyMonochrome);
            main.addline("  baseColor = applyMonochrome(baseColor);");
        }
        const reverseWoW = this.get(9 /* ReverseWhiteOnWhite */);
        if (undefined !== reverseWoW) {
            prelude.addFunction("vec4 reverseWhiteOnWhite(vec4 baseColor)", reverseWoW);
            main.addline("  baseColor = reverseWhiteOnWhite(baseColor);");
        }
        const applyFlash = this.get(11 /* ApplyFlash */);
        if (undefined !== applyFlash) {
            prelude.addFunction("vec4 applyFlash(vec4 baseColor)", applyFlash);
            main.addline("  baseColor = applyFlash(baseColor);");
        }
        const applyDebug = this.get(14 /* ApplyDebugColor */);
        if (undefined !== applyDebug) {
            prelude.addFunction("vec4 applyDebugColor(vec4 baseColor)", applyDebug);
            main.addline("  baseColor = applyDebugColor(baseColor);");
        }
        const assignFragData = this.get(15 /* AssignFragData */);
        bentleyjs_core_1.assert(undefined !== assignFragData);
        if (undefined !== assignFragData) {
            prelude.addFunction("void assignFragData(vec4 baseColor)", assignFragData);
            main.addline("  assignFragData(baseColor);");
        }
        prelude.addMain(main.source);
        return prelude.source;
    }
    buildPrelude(isLit) {
        bentleyjs_core_1.assert(this.maxClippingPlanes === 0 || this.get(10 /* ApplyClipping */) !== undefined);
        return this.buildPreludeCommon(true, isLit, this.maxClippingPlanes);
    }
}
exports.FragmentShaderBuilder = FragmentShaderBuilder;
/** A collection of shader programs with clipping that vary based on the max number of clipping planes each supports.
 * @internal
 */
class ClippingShaders {
    constructor(prog, context) {
        this.shaders = [];
        this.builder = prog.clone();
        Clipping_1.addClipping(this.builder, TechniqueFlags_1.ClipDef.forPlanes(6));
        const maskBuilder = prog.clone();
        Clipping_1.addClipping(maskBuilder, TechniqueFlags_1.ClipDef.forMask());
        this.maskShader = maskBuilder.buildProgram(context);
        bentleyjs_core_1.assert(this.maskShader !== undefined);
    }
    compileShaders() {
        return undefined === this.maskShader || this.maskShader.compile();
    }
    static roundUpToNearestMultipleOf(value, factor) {
        const maxPlanes = Math.ceil(value / factor) * factor;
        bentleyjs_core_1.assert(maxPlanes >= value);
        return maxPlanes;
    }
    static roundNumPlanes(minPlanes) {
        // We want to avoid making the shader do too much extra work, but we also want to avoid creating separate clipping shaders for
        // every unique # of planes
        if (minPlanes <= 2)
            return minPlanes; // 1 or 2 planes fairly common (ex - section cut)
        else if (minPlanes <= 6)
            return 6; // cuboid volume
        else if (minPlanes <= 120)
            return this.roundUpToNearestMultipleOf(minPlanes, 20);
        else
            return this.roundUpToNearestMultipleOf(minPlanes, 50);
    }
    getProgram(clipDef) {
        if (clipDef.type === 1 /* Mask */) {
            return this.maskShader;
        }
        else if (clipDef.type === 2 /* Planes */) {
            bentleyjs_core_1.assert(clipDef.numberOfPlanes > 0);
            const numClips = ClippingShaders.roundNumPlanes(clipDef.numberOfPlanes);
            for (const shader of this.shaders)
                if (shader.maxClippingPlanes === numClips)
                    return shader;
            this.builder.frag.maxClippingPlanes = numClips;
            const newProgram = this.builder.buildProgram(System_1.System.instance.context);
            this.shaders.push(newProgram);
            return newProgram;
        }
        else {
            bentleyjs_core_1.assert(false);
            return undefined;
        }
    }
}
exports.ClippingShaders = ClippingShaders;
/**
 * Assembles vertex and fragment shaders from a set of modular components to produce a compiled ShaderProgram.
 * Be very careful with components which use samplers to ensure that no conflicts exist with texture units used by other components (see TextureUnit enum).
 * @internal
 */
class ProgramBuilder {
    constructor(flags = 0 /* None */) {
        this.vert = new VertexShaderBuilder(flags);
        this.frag = new FragmentShaderBuilder(flags);
        this._flags = flags; // only needed for clone - though could loook up from vert or frag shader.
    }
    addVariable(v, which) {
        if (which & 1 /* Fragment */) {
            this.frag.addVariable(v);
        }
        if (which & 2 /* Vertex */) {
            this.vert.addVariable(v);
        }
    }
    addUniform(name, type, binding, which = 3 /* Both */) {
        this.addVariable(ShaderVariable.create(name, type, 2 /* Uniform */, binding), which);
    }
    addAttribute(name, type, binding, which = 3 /* Both */) {
        this.addVariable(ShaderVariable.create(name, type, 3 /* Attribute */, binding), which);
    }
    addVarying(name, type) {
        this.addVariable(ShaderVariable.create(name, type, 1 /* Varying */), 3 /* Both */);
    }
    addGlobal(name, type, which = 3 /* Both */, value, isConst = false) {
        this.addVariable(ShaderVariable.createGlobal(name, type, value, isConst), which);
    }
    addInlineComputedVarying(name, type, inlineComputation) {
        this.frag.addVarying(name, type);
        this.vert.addComputedVarying(name, type, inlineComputation);
    }
    addFunctionComputedVarying(name, type, funcName, funcBody) {
        let funcDecl = "\n" + Convert.typeToString(type) + " " + funcName + "()";
        funcDecl = SourceBuilder.buildFunctionDefinition(funcDecl, funcBody);
        const funcCall = funcName + "()";
        this.addFunctionComputedVaryingWithArgs(name, type, funcCall, funcDecl);
    }
    addFunctionComputedVaryingWithArgs(name, type, funcCall, funcDef) {
        this.vert.addFunction(funcDef);
        const computation = name + " = " + funcCall + ";";
        this.addInlineComputedVarying(name, type, computation);
    }
    /** Assembles the vertex and fragment shader code and returns a ready-to-compile shader program */
    buildProgram(gl) {
        if (this.vert.exceedsMaxVaryingVectors())
            bentleyjs_core_1.assert(false, "GL_MAX_VARYING_VECTORS exceeded");
        const prog = new ShaderProgram_1.ShaderProgram(gl, this.vert.buildSource(), this.frag.buildSource(), this.vert.headerComment, this.frag.maxClippingPlanes);
        this.vert.addBindings(prog);
        this.frag.addBindings(prog, this.vert);
        return prog;
    }
    setDebugDescription(description) {
        this.vert.headerComment = ("//!V! " + description);
        this.frag.headerComment = ("//!F! " + description);
    }
    /** Returns a deep copy of this program builder. */
    clone() {
        const clone = new ProgramBuilder(this._flags);
        // Copy from vertex builder
        clone.vert.headerComment = this.vert.headerComment;
        for (let i = 0; i < this.vert.computedVarying.length; i++)
            clone.vert.computedVarying[i] = this.vert.computedVarying[i];
        for (let i = 0; i < this.vert.initializers.length; i++)
            clone.vert.initializers[i] = this.vert.initializers[i];
        for (let i = 0; i < this.vert.components.length; i++)
            clone.vert.components[i] = this.vert.components[i];
        for (let i = 0; i < this.vert.functions.length; i++)
            clone.vert.functions[i] = this.vert.functions[i];
        for (let i = 0; i < this.vert.extensions.length; i++)
            clone.vert.extensions[i] = this.vert.extensions[i];
        for (let i = 0; i < this.vert.list.length; i++)
            clone.vert.list[i] = this.vert.list[i];
        // Copy from fragment builder
        clone.frag.headerComment = this.frag.headerComment;
        clone.frag.maxClippingPlanes = this.frag.maxClippingPlanes;
        for (let i = 0; i < this.frag.components.length; i++)
            clone.frag.components[i] = this.frag.components[i];
        for (let i = 0; i < this.frag.functions.length; i++)
            clone.frag.functions[i] = this.frag.functions[i];
        for (let i = 0; i < this.frag.extensions.length; i++)
            clone.frag.extensions[i] = this.frag.extensions[i];
        for (let i = 0; i < this.frag.list.length; i++)
            clone.frag.list[i] = this.frag.list[i];
        return clone;
    }
}
exports.ProgramBuilder = ProgramBuilder;


/***/ }),

/***/ "./lib/render/webgl/ShaderProgram.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/ShaderProgram.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const Handle_1 = __webpack_require__(/*! ./Handle */ "./lib/render/webgl/Handle.js");
const DrawCommand_1 = __webpack_require__(/*! ./DrawCommand */ "./lib/render/webgl/DrawCommand.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const TechniqueFlags_1 = __webpack_require__(/*! ./TechniqueFlags */ "./lib/render/webgl/TechniqueFlags.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
/** Describes the location of a uniform variable within a shader program.
 * @internal
 */
class Uniform {
    constructor(name) { this._name = name; }
    compile(prog) {
        bentleyjs_core_1.assert(!this.isValid);
        if (undefined !== prog.glProgram) {
            this._handle = Handle_1.UniformHandle.create(prog.glProgram, this._name, true);
        }
        return this.isValid;
    }
    get isValid() { return undefined !== this._handle; }
}
exports.Uniform = Uniform;
/**
 * Describes the location of a uniform variable within a shader program, the value of which does not change while the program is active.
 * The supplied binding function will be invoked once each time the shader becomes active to set the value of the uniform.
 * @internal
 */
class ProgramUniform extends Uniform {
    constructor(name, bind) {
        super(name);
        this._bind = bind;
    }
    bind(params) {
        if (undefined !== this._handle) {
            this._bind(this._handle, params);
        }
    }
}
exports.ProgramUniform = ProgramUniform;
/**
 * Describes the location of a uniform variable within a shader program, the value of which is dependent upon the graphic primitive
 * currently being rendered by the program. The supplied binding function will be invoked once for each graphic primitive submitted
 * to the program to set the value of the uniform.
 * @internal
 */
class GraphicUniform extends Uniform {
    constructor(name, bind) {
        super(name);
        this._bind = bind;
    }
    bind(params) {
        if (undefined !== this._handle) {
            this._bind(this._handle, params);
        }
    }
}
exports.GraphicUniform = GraphicUniform;
/** Describes the location of an attribute within a shader program along with a function for binding the attribute's data
 * @internal
 */
class Attribute {
    constructor(name, bind) {
        this._name = name;
        this._bind = bind;
    }
    compile(prog) {
        bentleyjs_core_1.assert(!this.isValid);
        if (undefined !== prog.glProgram) {
            this._handle = Handle_1.AttributeHandle.create(prog.glProgram, this._name, true);
        }
        return this.isValid;
    }
    get isValid() { return undefined !== this._handle; }
    bind(params) {
        if (undefined !== this._handle) {
            this._bind(this._handle, params);
        }
    }
}
exports.Attribute = Attribute;
/** @internal */
class ShaderProgram {
    constructor(gl, vertSource, fragSource, description, maxClippingPlanes) {
        this._inUse = false;
        this._status = 2 /* Uncompiled */;
        this._programUniforms = new Array();
        this._graphicUniforms = new Array();
        this._attributes = new Array();
        this._description = description;
        this.vertSource = vertSource;
        this.fragSource = fragSource;
        this.maxClippingPlanes = maxClippingPlanes;
        const glProgram = gl.createProgram();
        this._glProgram = (null === glProgram) ? undefined : glProgram;
        this._preserveShaderSourceCode = true === System_1.System.instance.options.preserveShaderSourceCode;
        // Silencing 'unused variable' warnings temporarily...
        bentleyjs_core_1.assert(undefined !== this._description);
    }
    get isDisposed() { return this._glProgram === undefined; }
    dispose() {
        if (!this.isDisposed) {
            bentleyjs_core_1.assert(!this._inUse);
            System_1.System.instance.context.deleteProgram(this._glProgram);
            this._glProgram = undefined;
            this._status = 2 /* Uncompiled */;
        }
    }
    get glProgram() { return this._glProgram; }
    get isUncompiled() { return 2 /* Uncompiled */ === this._status; }
    compileShader(type) {
        const gl = System_1.System.instance.context;
        const shader = gl.createShader(type);
        if (null === shader) {
            return undefined;
        }
        const src = GL_1.GL.ShaderType.Vertex === type ? this.vertSource : this.fragSource;
        gl.shaderSource(shader, src);
        gl.compileShader(shader);
        const succeeded = gl.getShaderParameter(shader, GL_1.GL.ShaderParameter.CompileStatus);
        const compileLog = succeeded ? "" : (GL_1.GL.ShaderType.Vertex === type ? "Vertex" : "Fragment") + " compilation errors: " + gl.getShaderInfoLog(shader) + "\n" + src;
        if (this._preserveShaderSourceCode !== true) { // do not preserve shader source code
            if (GL_1.GL.ShaderType.Vertex === type)
                this.vertSource = "";
            else
                this.fragSource = "";
        }
        bentleyjs_core_1.assert(succeeded, compileLog);
        return succeeded ? shader : undefined;
    }
    linkProgram(vert, frag) {
        bentleyjs_core_1.assert(undefined !== this.glProgram);
        if (undefined === this._glProgram || null === this._glProgram) { // because WebGL APIs used Thing|null, not Thing|undefined...
            return false;
        }
        const gl = System_1.System.instance.context;
        gl.attachShader(this._glProgram, vert);
        gl.attachShader(this._glProgram, frag);
        gl.linkProgram(this._glProgram);
        const linkLog = gl.getProgramInfoLog(this._glProgram);
        gl.validateProgram(this._glProgram);
        const validateLog = gl.getProgramInfoLog(this._glProgram);
        const succeeded = gl.getProgramParameter(this._glProgram, GL_1.GL.ProgramParameter.LinkStatus);
        if (!succeeded)
            bentleyjs_core_1.assert(succeeded, "Link errors: " + linkLog + " Validate errors: " + validateLog);
        return succeeded;
    }
    compile() {
        switch (this._status) {
            case 1 /* Failure */: return false;
            case 0 /* Success */: return true;
            default: {
                if (this.isDisposed) {
                    this._status = 1 /* Failure */;
                    return false;
                }
                break;
            }
        }
        const vert = this.compileShader(GL_1.GL.ShaderType.Vertex);
        const frag = this.compileShader(GL_1.GL.ShaderType.Fragment);
        if (undefined !== vert && undefined !== frag) {
            if (this.linkProgram(vert, frag) && this.compileUniforms(this._programUniforms) && this.compileUniforms(this._graphicUniforms) && this.compileAttributes()) {
                this._status = 0 /* Success */;
                return true;
            }
        }
        this._status = 1 /* Failure */;
        return false;
    }
    use(params) {
        if (!this.compile()) {
            return false;
        }
        bentleyjs_core_1.assert(undefined !== this._glProgram);
        if (null === this._glProgram || undefined === this._glProgram) {
            return false;
        }
        bentleyjs_core_1.assert(!this._inUse);
        this._inUse = true;
        params.context.useProgram(this._glProgram);
        for (const uniform of this._programUniforms) {
            uniform.bind(params);
        }
        return true;
    }
    endUse() {
        bentleyjs_core_1.assert(this._inUse);
        this._inUse = false;
        System_1.System.instance.context.useProgram(null);
    }
    draw(params) {
        bentleyjs_core_1.assert(this._inUse);
        for (const uniform of this._graphicUniforms) {
            uniform.bind(params);
        }
        for (const attribute of this._attributes)
            attribute.bind(params);
        System_1.System.instance.updateVertexAttribArrays();
        params.geometry.draw();
    }
    addProgramUniform(name, binding) {
        bentleyjs_core_1.assert(this.isUncompiled);
        this._programUniforms.push(new ProgramUniform(name, binding));
    }
    addGraphicUniform(name, binding) {
        bentleyjs_core_1.assert(this.isUncompiled);
        this._graphicUniforms.push(new GraphicUniform(name, binding));
    }
    addAttribute(name, binding) {
        bentleyjs_core_1.assert(this.isUncompiled);
        this._attributes.push(new Attribute(name, binding));
    }
    compileUniforms(uniforms) {
        for (const uniform of uniforms) {
            if (!uniform.compile(this))
                return false;
        }
        return true;
    }
    compileAttributes() {
        for (const attribute of this._attributes) {
            if (!attribute.compile(this))
                return false;
        }
        return true;
    }
}
exports.ShaderProgram = ShaderProgram;
/** Context in which ShaderPrograms are executed. Avoids switching shaders unnecessarily.
 * Ensures shader programs are compiled before use and un-bound when scope is disposed.
 * This class must *only* be used inside a using() function!
 * @internal
 */
class ShaderProgramExecutor {
    constructor(target, pass, program) {
        this.params.init(target, pass);
        this.changeProgram(program);
    }
    /** Clears the current program to be executed. This does not free WebGL resources, since those are owned by Techniques. */
    dispose() { this.changeProgram(undefined); }
    setProgram(program) { return this.changeProgram(program); }
    get isValid() { return undefined !== this._program; }
    get target() { return this.params.target; }
    get renderPass() { return this.params.renderPass; }
    get params() {
        if (undefined === ShaderProgramExecutor._params)
            ShaderProgramExecutor._params = new DrawCommand_1.ShaderProgramParams();
        return ShaderProgramExecutor._params;
    }
    draw(params) {
        bentleyjs_core_1.assert(this.isValid);
        if (undefined !== this._program) {
            this._program.draw(params);
        }
    }
    drawInterrupt(params) {
        bentleyjs_core_1.assert(params.target === this.params.target);
        const tech = params.target.techniques.getTechnique(params.geometry.getTechniqueId(params.target));
        const program = tech.getShader(TechniqueFlags_1.TechniqueFlags.defaults);
        if (this.setProgram(program)) {
            this.draw(params);
        }
    }
    pushBranch(branch) { this.target.pushBranch(this, branch); }
    popBranch() { this.target.popBranch(); }
    pushBatch(batch) { this.target.pushBatch(batch); }
    popBatch() { this.target.popBatch(); }
    changeProgram(program) {
        if (this._program === program) {
            return true;
        }
        else if (undefined !== this._program) {
            this._program.endUse();
        }
        this._program = program;
        if (undefined !== program && !program.use(this.params)) {
            this._program = undefined;
            return false;
        }
        return true;
    }
}
exports.ShaderProgramExecutor = ShaderProgramExecutor;


/***/ }),

/***/ "./lib/render/webgl/SolarShadowMap.js":
/*!********************************************!*\
  !*** ./lib/render/webgl/SolarShadowMap.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/System.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const Matrix_1 = __webpack_require__(/*! ./Matrix */ "./lib/render/webgl/Matrix.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
const FrameBuffer_1 = __webpack_require__(/*! ./FrameBuffer */ "./lib/render/webgl/FrameBuffer.js");
const TileTree_1 = __webpack_require__(/*! ../../tile/TileTree */ "./lib/tile/TileTree.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const System_2 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "./lib/render/webgl/RenderState.js");
const BranchState_1 = __webpack_require__(/*! ./BranchState */ "./lib/render/webgl/BranchState.js");
const DrawCommand_1 = __webpack_require__(/*! ./DrawCommand */ "./lib/render/webgl/DrawCommand.js");
class SolarShadowMapDrawArgs extends TileTree_1.Tile.DrawArgs {
    constructor(_mapFrustumPlanes, _shadowMap, context, location, root, now, purgeOlderThan, clip) {
        super(context, location, root, now, purgeOlderThan, clip);
        this._mapFrustumPlanes = _mapFrustumPlanes;
        this._shadowMap = _shadowMap;
    }
    get frustumPlanes() { return this._mapFrustumPlanes; }
    drawGraphics() {
        if (!this.graphics.isEmpty) {
            this._shadowMap.addGraphic(this.context.createBranch(this.graphics, this.location));
        }
    }
    static create(context, shadowMap, tileTree, planes) {
        const now = bentleyjs_core_1.BeTimePoint.now();
        const purgeOlderThan = now.minus(tileTree.expirationTime);
        return new SolarShadowMapDrawArgs(planes, shadowMap, context, tileTree.location.clone(), tileTree, now, purgeOlderThan, tileTree.clipVolume);
    }
}
class SolarShadowMap extends System_1.RenderSolarShadowMap {
    constructor() {
        super();
        this._doFitToFrustum = true;
        this._projectionMatrix = new Matrix_1.Matrix4();
        this._graphics = [];
        this._shadowFrustum = new imodeljs_common_1.Frustum();
        this._viewFrustum = new imodeljs_common_1.Frustum();
        this._status = 1 /* OutOfSynch */;
        this._settings = new imodeljs_common_1.SolarShadows.Settings();
    }
    get isReady() { return this._status === 4 /* TextureReady */; }
    get projectionMatrix() { return this._projectionMatrix; }
    get depthTexture() { return this._depthTexture; }
    get settings() { return this._settings; }
    get direction() { return this._direction; }
    addGraphic(graphic) { this._graphics.push(graphic); }
    get requiresSynch() { return this._status === 1 /* OutOfSynch */; }
    collectStatistics(stats) {
        if (undefined !== this._depthTexture)
            stats.addShadowMap(this._depthTexture.bytesUsed);
    }
    dispose() {
        this._depthTexture = bentleyjs_core_1.dispose(this._depthTexture);
        this._fbo = bentleyjs_core_1.dispose(this._fbo);
        this.clearGraphics();
    }
    set(viewFrustum, direction, settings, models, categories) {
        const minimumHorizonDirection = -.01;
        this._settings = settings.clone();
        if (direction.z > minimumHorizonDirection) {
            this._status = 0 /* BelowHorizon */;
            return;
        }
        if (this._doFitToFrustum && !this._viewFrustum.equals(viewFrustum)) {
            this._status = 1 /* OutOfSynch */;
            this._viewFrustum.setFrom(viewFrustum);
        }
        if (undefined === this._direction ||
            !this._direction.isAlmostEqual(direction) ||
            undefined === this._models ||
            !this._models.equalState(models) ||
            undefined === this._categories ||
            !this._categories.equalState(categories)) {
            // The solar direction, models and categories have changed..
            this._direction = direction.clone();
            this._models = models.clone();
            this._categories = categories.clone();
            this._status = 1 /* OutOfSynch */;
        }
    }
    forEachTileTree(iModel, func) {
        if (this._models) {
            for (const modelId of this._models.models) {
                const model = iModel.models.getLoaded(modelId);
                const model3d = undefined !== model ? model.asGeometricModel3d : undefined;
                if (undefined !== model3d && undefined !== model3d.tileTree) {
                    func(model3d.tileTree);
                }
            }
        }
    }
    clearGraphics() {
        for (const graphic of this._graphics)
            graphic.dispose();
        this._graphics.length = 0;
    }
    collectGraphics(sceneContext) {
        if (this.isReady)
            return;
        const iModel = sceneContext.viewport.iModel;
        if (this._status === 0 /* BelowHorizon */)
            return;
        if (this._direction === undefined ||
            this._models === undefined ||
            this._categories === undefined) {
            bentleyjs_core_1.assert(false);
            return;
        }
        for (const modelId of this._models.models) {
            const model = iModel.models.getLoaded(modelId);
            const model3d = undefined !== model ? model.asGeometricModel3d : undefined;
            if (undefined !== model3d && model3d.loadStatus < TileTree_1.TileTree.LoadStatus.Loaded) {
                this._status = 2 /* WaitingForTiles */;
                return;
            }
        }
        const worldToMapTransform = geometry_core_1.Transform.createRefs(geometry_core_1.Point3d.createZero(), geometry_core_1.Matrix3d.createRigidHeadsUp(this._direction.negate()).inverse());
        const worldToMap = geometry_core_1.Matrix4d.createTransform(worldToMapTransform);
        const mapToWorld = worldToMap.createInverse();
        const backgroundOn = sceneContext.viewFlags.backgroundMap;
        let shadowRange;
        if (this._doFitToFrustum) {
            shadowRange = geometry_core_1.Range3d.createTransformedArray(worldToMapTransform, this._viewFrustum.points);
            // By fitting to the actual tiles we can reduce the shadowRange and make better use of the texture pixels.
            if (!backgroundOn) {
                const viewTileRange = geometry_core_1.Range3d.createNull();
                const viewPlanes = new imodeljs_common_1.FrustumPlanes(this._viewFrustum);
                this.forEachTileTree(iModel, (tileTree) => tileTree.accumlateTransformedRange(viewTileRange, worldToMap, viewPlanes));
                if (!viewTileRange.isNull)
                    shadowRange.intersect(viewTileRange, shadowRange);
            }
            const projectRange = worldToMapTransform.multiplyRange(iModel.projectExtents, SolarShadowMap._scratchRange);
            shadowRange.low.x = Math.max(shadowRange.low.x, projectRange.low.x);
            shadowRange.high.x = Math.min(shadowRange.high.x, projectRange.high.x);
            shadowRange.low.y = Math.max(shadowRange.low.y, projectRange.low.y);
            shadowRange.high.y = Math.min(shadowRange.high.y, projectRange.high.y);
            shadowRange.high.z = projectRange.high.z;
        }
        else {
            shadowRange = worldToMapTransform.multiplyRange(iModel.projectExtents);
        }
        if (shadowRange.isNull) {
            return;
        }
        this._shadowFrustum.initFromRange(shadowRange);
        mapToWorld.multiplyPoint3dArrayQuietNormalize(this._shadowFrustum.points);
        const tileRange = geometry_core_1.Range3d.createNull();
        const frustumPlanes = new imodeljs_common_1.FrustumPlanes(this._shadowFrustum);
        const originalMissingTileCount = sceneContext.missingTiles.entries.length;
        this.forEachTileTree(iModel, ((tileTree) => {
            const drawArgs = SolarShadowMapDrawArgs.create(sceneContext, this, tileTree, frustumPlanes);
            const tileToMapTransform = worldToMapTransform.multiplyTransformTransform(tileTree.location, SolarShadowMap._scratchTransform);
            const selectedTiles = tileTree.selectTiles(drawArgs);
            for (const selectedTile of selectedTiles) {
                tileRange.extendRange(tileToMapTransform.multiplyRange(selectedTile.range, SolarShadowMap._scratchRange));
                selectedTile.drawGraphics(drawArgs);
            }
            drawArgs.drawGraphics();
            sceneContext.viewport.numSelectedTiles += selectedTiles.length;
        }));
        if (tileRange.isNull || sceneContext.missingTiles.entries.length > originalMissingTileCount) {
            this._status = 2 /* WaitingForTiles */;
            this.clearGraphics();
        }
        else {
            this._status = 3 /* GraphicsReady */;
            if (!backgroundOn) {
                shadowRange.intersect(tileRange, shadowRange);
                this._shadowFrustum.initFromRange(shadowRange);
                mapToWorld.multiplyPoint3dArrayQuietNormalize(this._shadowFrustum.points);
            }
            const frustumMap = this._shadowFrustum.toMap4d();
            if (undefined === frustumMap) {
                bentleyjs_core_1.assert(false);
                return;
            }
            this._projectionMatrix.initFromMatrix4d(frustumMap.transform0);
        }
    }
    draw(target) {
        if (this._status !== 3 /* GraphicsReady */)
            return;
        const shadowMapWidth = 4096;
        const shadowMapHeight = shadowMapWidth; // TBD - Adjust for aspect ratio.
        if (undefined === this._fbo || undefined === this._depthTexture) {
            const depthTextureHandle = System_2.System.instance.createDepthBuffer(shadowMapWidth, shadowMapHeight);
            if (undefined === depthTextureHandle ||
                undefined === (this._fbo = FrameBuffer_1.FrameBuffer.create([], depthTextureHandle))) {
                bentleyjs_core_1.assert(false, "Failed to create shadow depth buffer");
                return;
            }
            this._depthTexture = new Texture_1.Texture(new imodeljs_common_1.RenderTexture.Params(undefined, 2 /* TileSection */, true), depthTextureHandle);
        }
        const prevState = System_2.System.instance.currentRenderState.clone();
        System_2.System.instance.context.viewport(0, 0, shadowMapWidth, shadowMapHeight);
        const state = new RenderState_1.RenderState();
        state.flags.depthMask = true;
        state.flags.blend = false;
        state.flags.depthTest = true;
        const viewFlags = target.currentViewFlags.clone();
        viewFlags.renderMode = imodeljs_common_1.RenderMode.SmoothShade;
        viewFlags.transparency = false;
        viewFlags.textures = false;
        viewFlags.sourceLights = false;
        viewFlags.cameraLights = false;
        viewFlags.solarLight = false;
        viewFlags.shadows = false;
        viewFlags.noGeometryMap = true;
        viewFlags.monochrome = false;
        viewFlags.materials = false;
        viewFlags.ambientOcclusion = false;
        viewFlags.visibleEdges = viewFlags.hiddenEdges = false;
        const batchState = new BranchState_1.BatchState();
        System_2.System.instance.applyRenderState(state);
        const prevPlan = target.plan;
        target.changeFrustum(this._shadowFrustum, this._shadowFrustum.getFraction(), true);
        target.branchStack.setViewFlags(viewFlags);
        const renderCommands = new DrawCommand_1.RenderCommands(target, new BranchState_1.BranchStack(), batchState);
        renderCommands.addGraphics(this._graphics);
        System_2.System.instance.frameBufferStack.execute(this._fbo, true, () => {
            System_2.System.instance.context.clearDepth(1.0);
            System_2.System.instance.context.clear(GL_1.GL.BufferBit.Depth);
            target.techniques.execute(target, renderCommands.getCommands(2 /* OpaquePlanar */), 15 /* PlanarClassification */); // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.
            target.techniques.execute(target, renderCommands.getCommands(3 /* OpaqueGeneral */), 15 /* PlanarClassification */); // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.
        });
        batchState.reset(); // Reset the batch Ids...
        if (prevPlan)
            target.changeRenderPlan(prevPlan);
        System_2.System.instance.applyRenderState(prevState);
        System_2.System.instance.context.viewport(0, 0, target.viewRect.width, target.viewRect.height); // Restore viewport
        this.clearGraphics();
        this._status = 4 /* TextureReady */;
    }
}
SolarShadowMap._scratchRange = geometry_core_1.Range3d.createNull();
SolarShadowMap._scratchTransform = geometry_core_1.Transform.createIdentity();
exports.SolarShadowMap = SolarShadowMap;


/***/ }),

/***/ "./lib/render/webgl/System.js":
/*!************************************!*\
  !*** ./lib/render/webgl/System.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/System.js");
const Target_1 = __webpack_require__(/*! ./Target */ "./lib/render/webgl/Target.js");
const GeometryListBuilder_1 = __webpack_require__(/*! ../primitives/geometry/GeometryListBuilder */ "./lib/render/primitives/geometry/GeometryListBuilder.js");
const MeshPrimitives_1 = __webpack_require__(/*! ../primitives/mesh/MeshPrimitives */ "./lib/render/primitives/mesh/MeshPrimitives.js");
const Graphic_1 = __webpack_require__(/*! ./Graphic */ "./lib/render/webgl/Graphic.js");
const IModelConnection_1 = __webpack_require__(/*! ../../IModelConnection */ "./lib/IModelConnection.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const Technique_1 = __webpack_require__(/*! ./Technique */ "./lib/render/webgl/Technique.js");
const IModelApp_1 = __webpack_require__(/*! ../../IModelApp */ "./lib/IModelApp.js");
const RenderCompatibility_1 = __webpack_require__(/*! ../../RenderCompatibility */ "./lib/RenderCompatibility.js");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "./lib/render/webgl/RenderState.js");
const FrameBuffer_1 = __webpack_require__(/*! ./FrameBuffer */ "./lib/render/webgl/FrameBuffer.js");
const RenderBuffer_1 = __webpack_require__(/*! ./RenderBuffer */ "./lib/render/webgl/RenderBuffer.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const Polyline_1 = __webpack_require__(/*! ./Polyline */ "./lib/render/webgl/Polyline.js");
const PointString_1 = __webpack_require__(/*! ./PointString */ "./lib/render/webgl/PointString.js");
const Mesh_1 = __webpack_require__(/*! ./Mesh */ "./lib/render/webgl/Mesh.js");
const PointCloud_1 = __webpack_require__(/*! ./PointCloud */ "./lib/render/webgl/PointCloud.js");
const EdgeOverrides_1 = __webpack_require__(/*! ./EdgeOverrides */ "./lib/render/webgl/EdgeOverrides.js");
const Material_1 = __webpack_require__(/*! ./Material */ "./lib/render/webgl/Material.js");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const Primitive_1 = __webpack_require__(/*! ./Primitive */ "./lib/render/webgl/Primitive.js");
const ClipVolume_1 = __webpack_require__(/*! ./ClipVolume */ "./lib/render/webgl/ClipVolume.js");
const SolarShadowMap_1 = __webpack_require__(/*! ./SolarShadowMap */ "./lib/render/webgl/SolarShadowMap.js");
const RenderFlags_1 = __webpack_require__(/*! ./RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Diagnostics_1 = __webpack_require__(/*! ./Diagnostics */ "./lib/render/webgl/Diagnostics.js");
const PlanarClassifier_1 = __webpack_require__(/*! ./PlanarClassifier */ "./lib/render/webgl/PlanarClassifier.js");
const knownExtensions = [
    "WEBGL_draw_buffers",
    "OES_element_index_uint",
    "OES_texture_float",
    "OES_texture_half_float",
    "WEBGL_depth_texture",
    "EXT_color_buffer_float",
    "EXT_shader_texture_lod",
    "ANGLE_instanced_arrays",
];
/** Describes the rendering capabilities of the host system.
 * @internal
 */
class Capabilities {
    constructor() {
        this._maxRenderType = 0 /* TextureUnsignedByte */;
        this._maxDepthType = 0 /* RenderBufferUnsignedShort16 */;
        this._maxTextureSize = 0;
        this._maxColorAttachments = 0;
        this._maxDrawBuffers = 0;
        this._maxFragTextureUnits = 0;
        this._maxVertTextureUnits = 0;
        this._maxVertAttribs = 0;
        this._maxVertUniformVectors = 0;
        this._maxVaryingVectors = 0;
        this._maxFragUniformVectors = 0;
        this._extensionMap = {}; // Use this map to store actual extension objects retrieved from GL.
        this._presentFeatures = []; // List of features the system can support (not necessarily dependent on extensions)
    }
    get maxRenderType() { return this._maxRenderType; }
    get maxDepthType() { return this._maxDepthType; }
    get maxTextureSize() { return this._maxTextureSize; }
    get maxColorAttachments() { return this._maxColorAttachments; }
    get maxDrawBuffers() { return this._maxDrawBuffers; }
    get maxFragTextureUnits() { return this._maxFragTextureUnits; }
    get maxVertTextureUnits() { return this._maxVertTextureUnits; }
    get maxVertAttribs() { return this._maxVertAttribs; }
    get maxVertUniformVectors() { return this._maxVertUniformVectors; }
    get maxVaryingVectors() { return this._maxVaryingVectors; }
    get maxFragUniformVectors() { return this._maxFragUniformVectors; }
    /** These getters check for existence of extension objects to determine availability of features.  In WebGL2, could just return true for some. */
    get supportsNonPowerOf2Textures() { return false; }
    get supportsDrawBuffers() { return this.queryExtensionObject("WEBGL_draw_buffers") !== undefined; }
    get supportsInstancing() { return this.queryExtensionObject("ANGLE_instanced_arrays") !== undefined; }
    get supports32BitElementIndex() { return this.queryExtensionObject("OES_element_index_uint") !== undefined; }
    get supportsTextureFloat() { return this.queryExtensionObject("OES_texture_float") !== undefined; }
    get supportsTextureHalfFloat() { return this.queryExtensionObject("OES_texture_half_float") !== undefined; }
    get supportsShaderTextureLOD() { return this.queryExtensionObject("EXT_shader_texture_lod") !== undefined; }
    get supportsMRTTransparency() { return this.maxColorAttachments >= 2; }
    get supportsMRTPickShaders() { return this.maxColorAttachments >= 3; }
    /** Queries an extension object if available.  This is necessary for other parts of the system to access some constants within extensions. */
    queryExtensionObject(ext) {
        const extObj = this._extensionMap[ext];
        return (null !== extObj) ? extObj : undefined;
    }
    get _hasRequiredTextureUnits() { return this.maxFragTextureUnits >= 4 && this.maxVertTextureUnits >= 5; }
    /** Return an array containing any features not supported by the system as compared to the input array. */
    _findMissingFeatures(featuresToSeek) {
        const missingFeatures = [];
        for (const featureName of featuresToSeek) {
            if (-1 === this._presentFeatures.indexOf(featureName))
                missingFeatures.push(featureName);
        }
        return missingFeatures;
    }
    /** Populate and return an array containing features that this system supports. */
    _gatherFeatures() {
        const features = [];
        // simply check for presence of various extensions if that gives enough information
        if (this._extensionMap["OES_element_index_uint"] !== undefined)
            features.push(RenderCompatibility_1.WebGLFeature.UintElementIndex);
        if (this._extensionMap["ANGLE_instanced_arrays"] !== undefined)
            features.push(RenderCompatibility_1.WebGLFeature.Instancing);
        if (this.supportsMRTTransparency)
            features.push(RenderCompatibility_1.WebGLFeature.MrtTransparency);
        if (this.supportsMRTPickShaders)
            features.push(RenderCompatibility_1.WebGLFeature.MrtPick);
        if (this._hasRequiredTextureUnits)
            features.push(RenderCompatibility_1.WebGLFeature.MinimalTextureUnits);
        if (1 /* TextureUnsignedInt24Stencil8 */ === this._maxDepthType)
            features.push(RenderCompatibility_1.WebGLFeature.DepthTexture);
        // check if full float rendering is available based on maximum discovered renderable target
        if (2 /* TextureFloat */ === this._maxRenderType)
            features.push(RenderCompatibility_1.WebGLFeature.FloatRendering);
        return features;
    }
    /** Retrieve compatibility status based on presence of various features. */
    _getCompatibilityStatus(missingRequiredFeatures, missingOptionalFeatures) {
        let status = RenderCompatibility_1.WebGLRenderCompatibilityStatus.AllOkay;
        if (missingOptionalFeatures.length > 0)
            status = RenderCompatibility_1.WebGLRenderCompatibilityStatus.MissingOptionalFeatures;
        if (missingRequiredFeatures.length > 0)
            status = RenderCompatibility_1.WebGLRenderCompatibilityStatus.MissingRequiredFeatures;
        return status;
    }
    /** Initializes the capabilities based on a GL context. Must be called first. */
    init(gl, disabledExtensions) {
        this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);
        this._maxFragTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);
        this._maxVertTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);
        this._maxVertAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);
        this._maxVertUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);
        this._maxVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS);
        this._maxFragUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);
        const extensions = gl.getSupportedExtensions(); // This just retrieves a list of available extensions (not necessarily enabled).
        if (extensions) {
            for (const extStr of extensions) {
                const ext = extStr;
                if (-1 === knownExtensions.indexOf(ext))
                    continue;
                else if (undefined !== disabledExtensions && -1 !== disabledExtensions.indexOf(ext))
                    continue;
                const extObj = gl.getExtension(ext); // This call enables the extension and returns a WebGLObject containing extension instance.
                if (null !== extObj)
                    this._extensionMap[ext] = extObj;
            }
        }
        const dbExt = this.queryExtensionObject("WEBGL_draw_buffers");
        this._maxColorAttachments = dbExt !== undefined ? gl.getParameter(dbExt.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;
        this._maxDrawBuffers = dbExt !== undefined ? gl.getParameter(dbExt.MAX_DRAW_BUFFERS_WEBGL) : 1;
        // Determine the maximum color-renderable attachment type.
        const allowFloatRender = undefined === disabledExtensions || -1 === disabledExtensions.indexOf("OES_texture_float");
        if (allowFloatRender && this.isTextureRenderable(gl, gl.FLOAT))
            this._maxRenderType = 2 /* TextureFloat */;
        else {
            const hfExt = this.queryExtensionObject("OES_texture_half_float");
            this._maxRenderType = (hfExt !== undefined && this.isTextureRenderable(gl, hfExt.HALF_FLOAT_OES)) ? 1 /* TextureHalfFloat */ : 0 /* TextureUnsignedByte */;
        }
        // Determine the maximum depth attachment type.
        // this._maxDepthType = this.queryExtensionObject("WEBGL_depth_texture") !== undefined ? DepthType.TextureUnsignedInt32 : DepthType.RenderBufferUnsignedShort16;
        this._maxDepthType = this.queryExtensionObject("WEBGL_depth_texture") !== undefined ? 1 /* TextureUnsignedInt24Stencil8 */ : 0 /* RenderBufferUnsignedShort16 */;
        this._presentFeatures = this._gatherFeatures();
        const missingRequiredFeatures = this._findMissingFeatures(Capabilities.requiredFeatures);
        const missingOptionalFeatures = this._findMissingFeatures(Capabilities.optionalFeatures);
        this.debugPrint(gl, missingRequiredFeatures, missingOptionalFeatures);
        return {
            status: this._getCompatibilityStatus(missingRequiredFeatures, missingOptionalFeatures),
            missingRequiredFeatures,
            missingOptionalFeatures,
        };
    }
    static create(gl, disabledExtensions) {
        const caps = new Capabilities();
        const compatibility = caps.init(gl, disabledExtensions);
        if (RenderCompatibility_1.WebGLRenderCompatibilityStatus.CannotCreateContext === compatibility.status || RenderCompatibility_1.WebGLRenderCompatibilityStatus.MissingRequiredFeatures === compatibility.status)
            return undefined;
        return caps;
    }
    /** Determines if a particular texture type is color-renderable on the host system. */
    isTextureRenderable(gl, texType) {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, texType, null);
        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);
        const fbStatus = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        gl.deleteFramebuffer(fb);
        gl.deleteTexture(tex);
        gl.getError(); // clear any errors
        return fbStatus === gl.FRAMEBUFFER_COMPLETE;
    }
    debugPrint(gl, missingRequiredFeatures, _missingOptionalFeatures) {
        if (!Diagnostics_1.Debug.printEnabled)
            return;
        Diagnostics_1.Debug.print(() => "GLES Capabilities Information:");
        Diagnostics_1.Debug.print(() => "     hasRequiredFeatures : " + (0 === missingRequiredFeatures.length ? "yes" : "no"));
        Diagnostics_1.Debug.print(() => " missingOptionalFeatures : " + (missingRequiredFeatures.length > 0 ? "yes" : "no"));
        Diagnostics_1.Debug.print(() => " hasRequiredTextureUnits : " + this._hasRequiredTextureUnits);
        Diagnostics_1.Debug.print(() => "              GL_VERSION : " + gl.getParameter(gl.VERSION));
        Diagnostics_1.Debug.print(() => "               GL_VENDOR : " + gl.getParameter(gl.VENDOR));
        Diagnostics_1.Debug.print(() => "             GL_RENDERER : " + gl.getParameter(gl.RENDERER));
        Diagnostics_1.Debug.print(() => "          maxTextureSize : " + this.maxTextureSize);
        Diagnostics_1.Debug.print(() => "     maxColorAttachments : " + this.maxColorAttachments);
        Diagnostics_1.Debug.print(() => "          maxDrawBuffers : " + this.maxDrawBuffers);
        Diagnostics_1.Debug.print(() => "     maxFragTextureUnits : " + this.maxFragTextureUnits);
        Diagnostics_1.Debug.print(() => "     maxVertTextureUnits : " + this.maxVertTextureUnits);
        Diagnostics_1.Debug.print(() => "     nonPowerOf2Textures : " + (this.supportsNonPowerOf2Textures ? "yes" : "no"));
        Diagnostics_1.Debug.print(() => "             drawBuffers : " + (this.supportsDrawBuffers ? "yes" : "no"));
        Diagnostics_1.Debug.print(() => "              instancing : " + (this.supportsInstancing ? "yes" : "no"));
        Diagnostics_1.Debug.print(() => "       32BitElementIndex : " + (this.supports32BitElementIndex ? "yes" : "no"));
        Diagnostics_1.Debug.print(() => "            textureFloat : " + (this.supportsTextureFloat ? "yes" : "no"));
        Diagnostics_1.Debug.print(() => "        textureHalfFloat : " + (this.supportsTextureHalfFloat ? "yes" : "no"));
        Diagnostics_1.Debug.print(() => "        shaderTextureLOD : " + (this.supportsShaderTextureLOD ? "yes" : "no"));
        switch (this.maxRenderType) {
            case 0 /* TextureUnsignedByte */:
                Diagnostics_1.Debug.print(() => "           maxRenderType : TextureUnsigedByte");
                break;
            case 1 /* TextureHalfFloat */:
                Diagnostics_1.Debug.print(() => "           maxRenderType : TextureHalfFloat");
                break;
            case 2 /* TextureFloat */:
                Diagnostics_1.Debug.print(() => "           maxRenderType : TextureFloat");
                break;
            default:
                Diagnostics_1.Debug.print(() => "           maxRenderType : Unknown");
        }
        switch (this.maxDepthType) {
            case 0 /* RenderBufferUnsignedShort16 */:
                Diagnostics_1.Debug.print(() => "            maxDepthType : RenderBufferUnsignedShort16");
                break;
            case 1 /* TextureUnsignedInt24Stencil8 */:
                Diagnostics_1.Debug.print(() => "            maxDepthType : TextureUnsignedInt24Stencil8");
                break;
            case 2 /* TextureUnsignedInt32 */:
                Diagnostics_1.Debug.print(() => "            maxDepthType : TextureUnsignedInt32");
                break;
            default:
                Diagnostics_1.Debug.print(() => "            maxDepthType : Unknown");
        }
    }
}
Capabilities.optionalFeatures = [RenderCompatibility_1.WebGLFeature.MrtTransparency, RenderCompatibility_1.WebGLFeature.MrtPick, RenderCompatibility_1.WebGLFeature.DepthTexture, RenderCompatibility_1.WebGLFeature.FloatRendering, RenderCompatibility_1.WebGLFeature.Instancing];
Capabilities.requiredFeatures = [RenderCompatibility_1.WebGLFeature.UintElementIndex, RenderCompatibility_1.WebGLFeature.MinimalTextureUnits];
exports.Capabilities = Capabilities;
/** Id map holds key value pairs for both materials and textures, useful for caching such objects.
 * @internal
 */
class IdMap {
    constructor() {
        this.materials = new Map();
        this.textures = new Map();
        this.gradients = new bentleyjs_core_1.Dictionary(imodeljs_common_1.Gradient.Symb.compareSymb);
        this.classifiers = new Map();
    }
    dispose() {
        const textureArr = Array.from(this.textures.values());
        const gradientArr = this.gradients.extractArrays().values;
        for (const texture of textureArr)
            bentleyjs_core_1.dispose(texture);
        for (const gradient of gradientArr)
            bentleyjs_core_1.dispose(gradient);
        this.textures.clear();
        this.gradients.clear();
    }
    /** Add a material to this IdMap, given that it has a valid key. */
    addMaterial(material) {
        if (material.key)
            this.materials.set(material.key, material);
    }
    /** Add a texture to this IdMap, given that it has a valid key. */
    addTexture(texture) {
        if (texture.key)
            this.textures.set(texture.key, texture);
    }
    /** Add a texture to this IdMap using gradient symbology. */
    addGradient(gradientSymb, texture) {
        this.gradients.set(gradientSymb, texture);
    }
    /** Find a cached material using its key. If not found, returns undefined. */
    findMaterial(key) {
        return this.materials.get(key);
    }
    /** Find a cached gradient using the gradient symbology. If not found, returns undefined. */
    findGradient(symb) {
        return this.gradients.get(symb);
    }
    /** Find or create a new material given material parameters. This will cache the material if its key is valid. */
    getMaterial(params) {
        if (!params.key)
            return new Material_1.Material(params);
        let material = this.materials.get(params.key);
        if (!material) {
            material = new Material_1.Material(params);
            this.materials.set(params.key, material);
        }
        return material;
    }
    createTexture(params, handle) {
        if (undefined === handle)
            return undefined;
        const texture = new Texture_1.Texture(params, handle);
        this.addTexture(texture);
        return texture;
    }
    /** Attempt to create and return a new texture from an ImageBuffer. This will cache the texture if its key is valid */
    createTextureFromImageBuffer(img, params) {
        return this.createTexture(params, Texture_1.TextureHandle.createForImageBuffer(img, params.type));
    }
    createTextureFromImage(image, hasAlpha, params) {
        return this.createTexture(params, Texture_1.TextureHandle.createForImage(image, hasAlpha, params.type));
    }
    createTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, params) {
        return this.createTexture(params, Texture_1.TextureHandle.createForCubeImages(posX, negX, posY, negY, posZ, negZ));
    }
    findTexture(key) { return undefined !== key ? this.textures.get(key) : undefined; }
    /** Find or attempt to create a new texture using an ImageBuffer. If a new texture was created, it will be cached provided its key is valid. */
    getTexture(img, params) {
        const tex = this.findTexture(params.key);
        return undefined !== tex ? tex : this.createTextureFromImageBuffer(img, params);
    }
    getTextureFromImage(image, hasAlpha, params) {
        const tex = this.findTexture(params.key);
        return undefined !== tex ? tex : this.createTextureFromImage(image, hasAlpha, params);
    }
    getTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, params) {
        return this.createTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, params);
    }
    /** Find or attempt to create a new texture using gradient symbology. If a new texture was created, it will be cached using the gradient. */
    getGradient(grad) {
        const existingGrad = this.gradients.get(grad);
        if (existingGrad)
            return existingGrad;
        const image = grad.getImage(0x100, 0x100);
        const textureHandle = Texture_1.TextureHandle.createForImageBuffer(image, 0 /* Normal */);
        if (!textureHandle)
            return undefined;
        const params = new Texture_1.Texture.Params(undefined, 0 /* Normal */, true); // gradient textures are unnamed, but owned by this IdMap.
        const texture = new Texture_1.Texture(params, textureHandle);
        this.addGradient(grad, texture);
        return texture;
    }
    /** Get a classifier model */
    getSpatialClassificationModel(modelId) { return this.classifiers.get(modelId); }
    /** @internal */
    /** Add a new classifier */
    addSpatialClassificationModel(modelId, classifier) { this.classifiers.set(modelId, classifier); }
    /** @internal */
    /** Get solar shadow map */
    getSolarShadowMap(frustum, direction, settings, models, categories) {
        if (undefined === this._solarShadowMap)
            this._solarShadowMap = new SolarShadowMap_1.SolarShadowMap();
        this._solarShadowMap.set(frustum, direction, settings, models, categories);
        return this._solarShadowMap;
    }
}
exports.IdMap = IdMap;
/** @internal */
class System extends System_1.RenderSystem {
    constructor(canvas, context, capabilities, options) {
        super(options);
        this.currentRenderState = new RenderState_1.RenderState();
        this.frameBufferStack = new FrameBuffer_1.FrameBufferStack(); // frame buffers are not owned by the system
        this._textureBindings = [];
        // NB: Increase the size of these arrays when the maximum number of attributes used by any one shader increases.
        this._curVertexAttribStates = [
            0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */,
            0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */,
            0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */,
        ];
        this._nextVertexAttribStates = [
            0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */,
            0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */,
            0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */, 0 /* Disabled */,
        ];
        this.canvas = canvas;
        this.context = context;
        this.capabilities = capabilities;
        this._drawBuffersExtension = capabilities.queryExtensionObject("WEBGL_draw_buffers");
        this._instancingExtension = capabilities.queryExtensionObject("ANGLE_instanced_arrays");
        this.resourceCache = new Map();
        this.enableOptimizedSurfaceShaders = undefined !== options && true === options.enableOptimizedSurfaceShaders;
        // Make this System a subscriber to the the IModelConnection onClose event
        IModelConnection_1.IModelConnection.onClose.addListener(this.removeIModelMap.bind(this));
    }
    static get instance() { return IModelApp_1.IModelApp.renderSystem; }
    get isValid() { return this.canvas !== undefined; }
    get lineCodeTexture() { return this._lineCodeTexture; }
    get noiseTexture() { return this._noiseTexture; }
    get techniques() { return this._techniques; }
    get maxTextureSize() { return this.capabilities.maxTextureSize; }
    get supportsInstancing() { return this.capabilities.supportsInstancing; }
    setDrawBuffers(attachments) {
        // NB: The WEBGL_draw_buffers member is not exported directly because that type name is not available in some contexts (e.g. test-imodel-service).
        if (undefined !== this._drawBuffersExtension)
            this._drawBuffersExtension.drawBuffersWEBGL(attachments);
    }
    /** Attempt to create a WebGLRenderingContext, returning undefined if unsuccessful. */
    static createContext(canvas, contextAttributes) {
        let context = canvas.getContext("webgl", contextAttributes);
        if (null === context) {
            context = canvas.getContext("experimental-webgl", contextAttributes); // IE, Edge...
            if (null === context) {
                return undefined;
            }
        }
        return context;
    }
    static queryRenderCompatibility() {
        const canvas = document.createElement("canvas");
        if (null === canvas)
            return { status: RenderCompatibility_1.WebGLRenderCompatibilityStatus.CannotCreateContext, missingOptionalFeatures: [], missingRequiredFeatures: [] };
        let errorMessage;
        canvas.addEventListener("webglcontextcreationerror", (event) => {
            errorMessage = event.statusMessage || "webglcontextcreationerror was triggered with no error provided";
        }, false);
        let hasMajorPerformanceCaveat = false;
        let context = System.createContext(canvas, { failIfMajorPerformanceCaveat: true });
        if (undefined === context) {
            hasMajorPerformanceCaveat = true;
            context = System.createContext(canvas); // try to create context without black-listed GPU
            if (undefined === context)
                return { status: RenderCompatibility_1.WebGLRenderCompatibilityStatus.CannotCreateContext, missingOptionalFeatures: [], missingRequiredFeatures: [] };
        }
        const capabilities = new Capabilities();
        const compatibility = capabilities.init(context);
        compatibility.contextErrorMessage = errorMessage;
        if (hasMajorPerformanceCaveat && compatibility.status !== RenderCompatibility_1.WebGLRenderCompatibilityStatus.MissingRequiredFeatures)
            compatibility.status = RenderCompatibility_1.WebGLRenderCompatibilityStatus.MajorPerformanceCaveat;
        return compatibility;
    }
    static create(optionsIn) {
        const options = undefined !== optionsIn ? optionsIn : {};
        const canvas = document.createElement("canvas");
        if (null === canvas)
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "Failed to obtain HTMLCanvasElement");
        const context = System.createContext(canvas);
        if (undefined === context) {
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "Failed to obtain WebGL context");
        }
        const capabilities = Capabilities.create(context, options.disabledExtensions);
        if (undefined === capabilities)
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "Failed to initialize rendering capabilities");
        // set actual gl state to match desired state defaults
        context.depthFunc(GL_1.GL.DepthFunc.Default); // LessOrEqual
        return new System(canvas, context, capabilities, options);
    }
    // Note: FrameBuffers inside of the FrameBufferStack are not owned by the System, and are only used as a central storage device
    dispose() {
        this._techniques = bentleyjs_core_1.dispose(this._techniques);
        this._lineCodeTexture = bentleyjs_core_1.dispose(this._lineCodeTexture);
        this._noiseTexture = bentleyjs_core_1.dispose(this._noiseTexture);
        // We must attempt to dispose of each idmap in the resourceCache (if idmap is already disposed, has no effect)
        this.resourceCache.forEach((idMap) => {
            bentleyjs_core_1.dispose(idMap);
        });
        this.resourceCache.clear();
        IModelConnection_1.IModelConnection.onClose.removeListener(this.removeIModelMap);
    }
    onInitialized() {
        this._techniques = Technique_1.Techniques.create(this.context);
        const noiseDim = 4;
        const noiseArr = new Uint8Array([152, 235, 94, 173, 219, 215, 115, 176, 73, 205, 43, 201, 10, 81, 205, 198]);
        this._noiseTexture = Texture_1.TextureHandle.createForData(noiseDim, noiseDim, noiseArr, false, GL_1.GL.Texture.WrapMode.Repeat, GL_1.GL.Texture.Format.Luminance);
        bentleyjs_core_1.assert(undefined !== this._noiseTexture, "System.noiseTexture not created.");
        this._lineCodeTexture = Texture_1.TextureHandle.createForData(EdgeOverrides_1.LineCode.size, EdgeOverrides_1.LineCode.count, new Uint8Array(EdgeOverrides_1.LineCode.lineCodeData), false, GL_1.GL.Texture.WrapMode.Repeat, GL_1.GL.Texture.Format.Luminance);
        bentleyjs_core_1.assert(undefined !== this._lineCodeTexture, "System.lineCodeTexture not created.");
    }
    createTarget(canvas) { return new Target_1.OnScreenTarget(canvas); }
    createOffscreenTarget(rect) { return new Target_1.OffScreenTarget(rect); }
    createGraphicBuilder(placement, type, viewport, pickableId) { return new GeometryListBuilder_1.PrimitiveBuilder(this, type, viewport, placement, pickableId); }
    createMesh(params, instances) { return Mesh_1.MeshGraphic.create(params, instances); }
    createPolyline(params, instances) { return Primitive_1.Primitive.create(() => Polyline_1.PolylineGeometry.create(params), instances); }
    createPointString(params, instances) { return Primitive_1.Primitive.create(() => PointString_1.PointStringGeometry.create(params), instances); }
    createPointCloud(args) { return Primitive_1.Primitive.create(() => new PointCloud_1.PointCloudGeometry(args)); }
    createGraphicList(primitives) { return new Graphic_1.GraphicsArray(primitives); }
    createGraphicBranch(branch, transform, clips, planarClassifier) { return new Graphic_1.Branch(branch, transform, clips, undefined, planarClassifier); }
    createBatch(graphic, features, range) { return new Graphic_1.Batch(graphic, features, range); }
    createSkyBox(params) {
        if (undefined !== params.cube) {
            return Primitive_1.SkyCubePrimitive.create(() => CachedGeometry_1.SkyBoxQuadsGeometry.create(params.cube));
        }
        else {
            bentleyjs_core_1.assert(undefined !== params.sphere || undefined !== params.gradient);
            return Primitive_1.SkySpherePrimitive.create(() => CachedGeometry_1.SkySphereViewportQuadGeometry.createGeometry(params));
        }
    }
    applyRenderState(newState) {
        newState.apply(this.currentRenderState);
        this.currentRenderState.copyFrom(newState);
    }
    createDepthBuffer(width, height) {
        // Note: The buffer/texture created here have ownership passed to the caller (system will not dispose of these)
        switch (this.capabilities.maxDepthType) {
            case 0 /* RenderBufferUnsignedShort16 */: {
                return RenderBuffer_1.RenderBuffer.create(width, height);
            }
            case 2 /* TextureUnsignedInt32 */: {
                return Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.DepthComponent, GL_1.GL.Texture.DataType.UnsignedInt);
            }
            case 1 /* TextureUnsignedInt24Stencil8 */: {
                const dtExt = this.capabilities.queryExtensionObject("WEBGL_depth_texture");
                return Texture_1.TextureHandle.createForAttachment(width, height, GL_1.GL.Texture.Format.DepthStencil, dtExt.UNSIGNED_INT_24_8_WEBGL);
            }
            default: {
                bentleyjs_core_1.assert(false);
                return undefined;
            }
        }
    }
    /** Returns the corresponding IdMap for an IModelConnection. Creates a new one if it doesn't exist. */
    createIModelMap(imodel) {
        let idMap = this.resourceCache.get(imodel);
        if (!idMap) {
            idMap = new IdMap();
            this.resourceCache.set(imodel, idMap);
        }
        return idMap;
    }
    /** Removes an IModelConnection-IdMap pairing from the system's resource cache. */
    removeIModelMap(imodel) {
        const idMap = this.resourceCache.get(imodel);
        if (idMap === undefined)
            return;
        bentleyjs_core_1.dispose(idMap);
        this.resourceCache.delete(imodel);
    }
    /** Attempt to create a material for the given iModel using a set of material parameters. */
    createMaterial(params, imodel) {
        const idMap = this.getIdMap(imodel);
        const material = idMap.getMaterial(params);
        return material;
    }
    /** Using its key, search for an existing material of an open iModel. */
    findMaterial(key, imodel) {
        const idMap = this.resourceCache.get(imodel);
        if (!idMap)
            return undefined;
        return idMap.findMaterial(key);
    }
    /** Attempt to create a texture for the given iModel using an ImageBuffer. */
    createTextureFromImageBuffer(image, imodel, params) {
        return this.getIdMap(imodel).getTexture(image, params);
    }
    /** Attempt to create a texture for the given iModel using an HTML image element. */
    createTextureFromImage(image, hasAlpha, imodel, params) {
        // if imodel is undefined, caller is responsible for disposing texture. It will not be associated with an IModelConnection
        if (undefined === imodel) {
            const textureHandle = Texture_1.TextureHandle.createForImage(image, hasAlpha, params.type);
            return undefined !== textureHandle ? new Texture_1.Texture(params, textureHandle) : undefined;
        }
        return this.getIdMap(imodel).getTextureFromImage(image, hasAlpha, params);
    }
    /** Attempt to create a texture from a cube of HTML images. */
    createTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, imodel, params) {
        return this.getIdMap(imodel).getTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, params);
    }
    /** Attempt to create a texture using gradient symbology. */
    getGradientTexture(symb, imodel) {
        const idMap = this.getIdMap(imodel);
        const texture = idMap.getGradient(symb);
        return texture;
    }
    /** Using its key, search for an existing texture of an open iModel. */
    findTexture(key, imodel) {
        const idMap = this.resourceCache.get(imodel);
        if (!idMap)
            return undefined;
        return idMap.findTexture(key);
    }
    createClipVolume(clipVector) {
        let clipVolume = ClipVolume_1.ClipMaskVolume.create(clipVector);
        if (undefined === clipVolume)
            clipVolume = ClipVolume_1.ClipPlanesVolume.create(clipVector);
        return clipVolume;
    }
    getSpatialClassificationModel(modelId, iModel) { return this.getIdMap(iModel).classifiers.get(modelId); }
    addSpatialClassificationModel(modelId, classifier, iModel) { this.getIdMap(iModel).classifiers.set(modelId, classifier); }
    createPlanarClassifier(properties, tileTree, classifiedModel, sceneContext) { return PlanarClassifier_1.PlanarClassifier.create(properties, tileTree, classifiedModel, sceneContext); }
    /** Solar Shadow Map */
    getSolarShadowMap(frustum, direction, settings, models, categories, iModel) { return this.getIdMap(iModel).getSolarShadowMap(frustum, direction, settings, models, categories); }
    getIdMap(imodel) {
        const map = this.resourceCache.get(imodel);
        return undefined !== map ? map : this.createIModelMap(imodel);
    }
    createSheetTilePolyfaces(corners, clip) {
        const sheetTilePolys = [];
        // Texture params for this sheet tile will always go from (0,0) to (1,1). However, we may be dealing with a tile that is a sub-division. Store the
        // lower-left corner to subtract from point values later to get UV params.
        const sheetTileRange = geometry_core_1.Range3d.createArray(corners);
        const sheetTileScale = 1 / (sheetTileRange.high.x - sheetTileRange.low.x);
        const sheetTileOrigin = sheetTileRange.low;
        let clippedPolygons;
        if (clip !== undefined)
            clippedPolygons = geometry_core_1.ClipUtilities.clipPolygonToClipShape(corners, clip.clips[0]); // ###TODO: Currently assume that there is only one shape...
        else
            clippedPolygons = [corners];
        if (clippedPolygons.length === 0)
            return sheetTilePolys; // return empty
        // The result of clipping will be several polygons, which may lie next to each other, or be detached, and can be of any length. Let's stitch these into a single polyface.
        const strokeOptions = new geometry_core_1.StrokeOptions();
        strokeOptions.needParams = true;
        strokeOptions.shouldTriangulate = true;
        const polyfaceBuilder = geometry_core_1.PolyfaceBuilder.create(strokeOptions);
        for (const polygon of clippedPolygons) {
            if (polygon.length < 3)
                continue;
            else if (polygon.length === 3) {
                const params = [];
                for (const point of polygon) {
                    const paramUnscaled = point.minus(sheetTileOrigin);
                    params.push(geometry_core_1.Point2d.create(paramUnscaled.x * sheetTileScale, paramUnscaled.y * sheetTileScale));
                }
                polyfaceBuilder.addTriangleFacet(polygon, params);
            }
            else if (polygon.length === 4) {
                const params = [];
                for (const point of polygon) {
                    const paramUnscaled = point.minus(sheetTileOrigin);
                    params.push(geometry_core_1.Point2d.create(paramUnscaled.x * sheetTileScale, paramUnscaled.y * sheetTileScale));
                }
                polyfaceBuilder.addQuadFacet(polygon, params);
            }
            else {
                // ### TODO: There are a lot of inefficiencies here (what if it is a simple convex polygon... we must adjust UV params ourselves afterwards, a PolyfaceVisitor....)
                // We are also assuming that when we use the polyface visitor, it will iterate over the points in order of the entire array
                const triangulatedPolygon = geometry_core_1.Triangulator.createTriangulatedGraphFromSingleLoop(polygon);
                geometry_core_1.Triangulator.flipTriangles(triangulatedPolygon);
                triangulatedPolygon.announceFaceLoops((_graph, edge) => {
                    if (!edge.isMaskSet(geometry_core_1.HalfEdgeMask.EXTERIOR)) {
                        const trianglePoints = [];
                        const params = [];
                        edge.collectAroundFace((node) => {
                            const point = geometry_core_1.Point3d.create(node.x, node.y, 0.5);
                            trianglePoints.push(point);
                            const paramUnscaled = point.minus(sheetTileOrigin);
                            params.push(geometry_core_1.Point2d.create(paramUnscaled.x * sheetTileScale, paramUnscaled.y * sheetTileScale));
                        });
                        bentleyjs_core_1.assert(trianglePoints.length === 3);
                        polyfaceBuilder.addTriangleFacet(trianglePoints, params);
                    }
                    return true;
                });
            }
        }
        sheetTilePolys.push(polyfaceBuilder.claimPolyface());
        return sheetTilePolys;
    }
    createSheetTile(tile, polyfaces, tileColor) {
        const sheetTileGraphics = [];
        for (const polyface of polyfaces) {
            const rawParams = polyface.data.param;
            if (rawParams === undefined)
                return sheetTileGraphics; // return empty
            const meshArgs = new MeshPrimitives_1.MeshArgs();
            const pts = polyface.data.point.getPoint3dArray();
            meshArgs.points = new imodeljs_common_1.QPoint3dList(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.createArray(pts))); // use these point params
            for (const point of pts)
                meshArgs.points.push(imodeljs_common_1.QPoint3d.create(point, meshArgs.points.params));
            const uvs = rawParams.getPoint2dArray();
            const pointIndices = [];
            const uvIndices = [];
            const visitor = geometry_core_1.IndexedPolyfaceVisitor.create(polyface, 0);
            while (visitor.moveToNextFacet()) {
                for (let i = 0; i < 3; i++) {
                    pointIndices.push(visitor.clientPointIndex(i));
                    uvIndices.push(visitor.clientParamIndex(i));
                }
            }
            // make uv arrangement and indices match that of points
            // this is necessary because MeshArgs assumes vertIndices refers to both points and UVs
            // output uvsOut to clippedTile
            let j = 0;
            const uvsOut = [];
            for (const pointIdx of pointIndices)
                uvsOut[pointIdx] = uvs[uvIndices[j++]]; // passing the reference should not matter
            meshArgs.textureUv = uvsOut;
            meshArgs.vertIndices = pointIndices;
            meshArgs.texture = tile;
            meshArgs.material = undefined;
            meshArgs.isPlanar = true;
            meshArgs.colors.initUniform(tileColor);
            const mesh = this.createTriMesh(meshArgs);
            if (mesh !== undefined)
                sheetTileGraphics.push(mesh);
        }
        return sheetTileGraphics;
    }
    bindTexture(unit, target, texture) {
        const index = unit - RenderFlags_1.TextureUnit.Zero;
        if (this._textureBindings[index] === texture)
            return;
        this._textureBindings[index] = texture;
        this.context.activeTexture(unit);
        this.context.bindTexture(target, undefined !== texture ? texture : null);
    }
    bindTexture2d(unit, texture) { this.bindTexture(unit, GL_1.GL.Texture.Target.TwoDee, texture); }
    bindTextureCubeMap(unit, texture) { this.bindTexture(unit, GL_1.GL.Texture.Target.CubeMap, texture); }
    // Ensure *something* is bound to suppress 'no texture assigned to unit x' warnings.
    ensureSamplerBound(uniform, unit) {
        this.lineCodeTexture.bindSampler(uniform, unit);
    }
    disposeTexture(texture) {
        System.instance.context.deleteTexture(texture);
        for (let i = 0; i < this._textureBindings.length; i++) {
            if (this._textureBindings[i] === texture) {
                this._textureBindings[i] = undefined;
                break;
            }
        }
    }
    // System keeps track of current enabled state of vertex attribute arrays.
    // This prevents errors caused by leaving a vertex attrib array enabled after disposing of the buffer bound to it;
    // also prevents unnecessarily 'updating' the enabled state of a vertex attrib array when it hasn't actually changed.
    enableVertexAttribArray(id, instanced) {
        bentleyjs_core_1.assert(id < this._nextVertexAttribStates.length, "if you add new vertex attributes you must update array length");
        bentleyjs_core_1.assert(id < this._curVertexAttribStates.length, "if you add new vertex attributes you must update array length");
        this._nextVertexAttribStates[id] = instanced ? 5 /* InstancedEnabled */ : 1 /* Enabled */;
    }
    updateVertexAttribArrays() {
        const cur = this._curVertexAttribStates;
        const next = this._nextVertexAttribStates;
        const context = this.context;
        for (let i = 0; i < next.length; i++) {
            const oldState = cur[i];
            const newState = next[i];
            if (oldState !== newState) {
                // Update the enabled state if it changed.
                const wasEnabled = 0 !== (1 /* Enabled */ & oldState);
                const nowEnabled = 0 !== (1 /* Enabled */ & newState);
                if (wasEnabled !== nowEnabled) {
                    if (nowEnabled) {
                        context.enableVertexAttribArray(i);
                    }
                    else {
                        context.disableVertexAttribArray(i);
                    }
                }
                // Only update the divisor if the attribute is enabled.
                if (nowEnabled) {
                    const wasInstanced = 0 !== (4 /* Instanced */ & oldState);
                    const nowInstanced = 0 !== (4 /* Instanced */ & newState);
                    if (wasInstanced !== nowInstanced) {
                        bentleyjs_core_1.assert(undefined !== this._instancingExtension);
                        this._instancingExtension.vertexAttribDivisorANGLE(i, nowInstanced ? 1 : 0);
                    }
                }
                cur[i] = newState;
            }
            // Set the attribute back to disabled, but preserve the divisor.
            next[i] &= ~1 /* Enabled */;
        }
    }
    drawArrays(type, first, count, numInstances) {
        if (0 !== numInstances) {
            if (undefined !== this._instancingExtension)
                this._instancingExtension.drawArraysInstancedANGLE(type, first, count, numInstances);
        }
        else {
            this.context.drawArrays(type, first, count);
        }
    }
    enableDiagnostics(enable) {
        Diagnostics_1.Debug.printEnabled = 0 /* None */ !== (enable & 2 /* DebugOutput */);
        Diagnostics_1.Debug.evaluateEnabled = 0 /* None */ !== (enable & 4 /* WebGL */);
    }
}
exports.System = System;


/***/ }),

/***/ "./lib/render/webgl/Target.js":
/*!************************************!*\
  !*** ./lib/render/webgl/Target.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/System.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const System_2 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const BranchState_1 = __webpack_require__(/*! ./BranchState */ "./lib/render/webgl/BranchState.js");
const Graphic_1 = __webpack_require__(/*! ./Graphic */ "./lib/render/webgl/Graphic.js");
const EdgeOverrides_1 = __webpack_require__(/*! ./EdgeOverrides */ "./lib/render/webgl/EdgeOverrides.js");
const Viewport_1 = __webpack_require__(/*! ../../Viewport */ "./lib/Viewport.js");
const DrawCommand_1 = __webpack_require__(/*! ./DrawCommand */ "./lib/render/webgl/DrawCommand.js");
const ColorInfo_1 = __webpack_require__(/*! ./ColorInfo */ "./lib/render/webgl/ColorInfo.js");
const RenderState_1 = __webpack_require__(/*! ./RenderState */ "./lib/render/webgl/RenderState.js");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const SceneCompositor_1 = __webpack_require__(/*! ./SceneCompositor */ "./lib/render/webgl/SceneCompositor.js");
const FrameBuffer_1 = __webpack_require__(/*! ./FrameBuffer */ "./lib/render/webgl/FrameBuffer.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
const CachedGeometry_1 = __webpack_require__(/*! ./CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const TechniqueFlags_1 = __webpack_require__(/*! ./TechniqueFlags */ "./lib/render/webgl/TechniqueFlags.js");
const FloatRGBA_1 = __webpack_require__(/*! ./FloatRGBA */ "./lib/render/webgl/FloatRGBA.js");
/** Represents the frustum for use in glsl as a pair of uniforms.
 * @internal
 */
class FrustumUniforms {
    constructor() {
        const pData = [];
        pData[0 /* kTop */] = 0.0;
        pData[1 /* kBottom */] = 0.0;
        pData[2 /* kLeft */] = 0.0;
        pData[3 /* kRight */] = 0.0;
        const fData = [];
        fData[0 /* kNear */] = 0.0;
        fData[1 /* kFar */] = 0.0;
        fData[2 /* kType */] = 0.0;
        this._planeData = new Float32Array(pData);
        this._frustumData = new Float32Array(fData);
    }
    get frustumPlanes() { return this._planeData; } // uniform vec4 u_frustumPlanes; // { top, bottom, left, right }
    get frustum() { return this._frustumData; } // uniform vec3 u_frustum; // { near, far, type }
    get nearPlane() { return this._frustumData[0 /* kNear */]; }
    get farPlane() { return this._frustumData[1 /* kFar */]; }
    get type() { return this.frustum[2 /* kType */]; }
    get is2d() { return 0 /* TwoDee */ === this.type; }
    setPlanes(top, bottom, left, right) {
        this._planeData[0 /* kTop */] = top;
        this._planeData[1 /* kBottom */] = bottom;
        this._planeData[2 /* kLeft */] = left;
        this._planeData[3 /* kRight */] = right;
    }
    setFrustum(nearPlane, farPlane, type) {
        this._frustumData[0 /* kNear */] = nearPlane;
        this._frustumData[1 /* kFar */] = farPlane;
        this._frustumData[2 /* kType */] = type;
    }
}
exports.FrustumUniforms = FrustumUniforms;
/** Interface for 3d GPU clipping.
 * @internal
 */
class Clips {
    constructor() {
        this._clipActive = 0; // count of SetActiveClip nesting (only outermost used)
        this._clipCount = 0;
    }
    get texture() { return this._texture; }
    get count() { return this._clipCount; }
    get isValid() { return this._clipCount > 0; }
    set(numPlanes, texture) {
        this._clipActive++;
        if (this._clipActive !== 1)
            return;
        this._clipCount = numPlanes;
        this._texture = texture;
    }
    clear() {
        if (this._clipActive === 1) {
            this._clipCount = 0;
            this._texture = undefined;
        }
        if (this._clipActive > 0)
            this._clipActive--;
    }
}
exports.Clips = Clips;
/** Active classifiers - only the innermost is used.
 * @internal
 */
class PlanarClassifiers {
    constructor() {
        this._classifiers = new Array();
    }
    get classifier() { return this._classifiers.length === 0 ? undefined : this._classifiers[this._classifiers.length - 1]; }
    get isValid() { return this._classifiers.length > 0; }
    push(texture) { this._classifiers.push(texture); }
    pop() { this._classifiers.pop(); }
}
exports.PlanarClassifiers = PlanarClassifiers;
/** @internal */
class PerformanceMetrics {
    constructor(gatherGlFinish = false, gatherCurPerformanceMetrics = false) {
        this._lastTimePoint = bentleyjs_core_1.BeTimePoint.now();
        this.frameTimings = new Map();
        this.gatherGlFinish = false;
        this.gatherCurPerformanceMetrics = false;
        this.curSpfTimeIndex = 0;
        this.spfTimes = [];
        this.spfSum = 0;
        this.renderSpfTimes = [];
        this.renderSpfSum = 0;
        this.loadTileTimes = [];
        this.loadTileSum = 0;
        this.fpsTimer = new bentleyjs_core_1.StopWatch(undefined, true);
        this.fpsTimerStart = 0;
        this.gatherGlFinish = gatherGlFinish;
        this.gatherCurPerformanceMetrics = gatherCurPerformanceMetrics;
    }
    startNewFrame(sceneTime = 0) {
        this.frameTimings = new Map();
        this.frameTimings.set("Scene Time", sceneTime);
        this._lastTimePoint = bentleyjs_core_1.BeTimePoint.now();
    }
    recordTime(operationName) {
        const newTimePoint = bentleyjs_core_1.BeTimePoint.now();
        this.frameTimings.set(operationName, (newTimePoint.milliseconds - this._lastTimePoint.milliseconds));
        this._lastTimePoint = bentleyjs_core_1.BeTimePoint.now();
    }
    endFrame(operationName) {
        const newTimePoint = bentleyjs_core_1.BeTimePoint.now();
        let sum = 0;
        let prevGPUTime = 0;
        this.frameTimings.forEach((value, key) => {
            if (key === "Finish GPU Queue")
                prevGPUTime = value;
            else
                sum += value;
        });
        this.frameTimings.set("Total Render Time", sum);
        const lastTiming = (newTimePoint.milliseconds - this._lastTimePoint.milliseconds);
        this.frameTimings.set(operationName ? operationName : "Finish GPU Queue", lastTiming);
        this.frameTimings.set("Total Time", sum + prevGPUTime + lastTiming);
        this._lastTimePoint = bentleyjs_core_1.BeTimePoint.now();
    }
}
exports.PerformanceMetrics = PerformanceMetrics;
function swapImageByte(image, i0, i1) {
    const tmp = image.data[i0];
    image.data[i0] = image.data[i1];
    image.data[i1] = tmp;
}
class EmptyHiliteSet {
    constructor() {
        this.isEmpty = true;
        this.elements = this.subcategories = this.models = new bentleyjs_core_1.Id64.Uint32Set();
    }
}
/** @internal */
class Target extends System_1.RenderTarget {
    constructor(rect) {
        super();
        this._stack = new BranchState_1.BranchStack();
        this._batchState = new BranchState_1.BatchState();
        this._scene = [];
        this._backgroundMap = [];
        this._overridesUpdateTime = bentleyjs_core_1.BeTimePoint.now();
        this._hilites = new EmptyHiliteSet();
        this._hiliteUpdateTime = bentleyjs_core_1.BeTimePoint.now();
        this._flashed = { lower: 0, upper: 0 };
        this._flashedId = bentleyjs_core_1.Id64.invalid;
        this._flashedUpdateTime = bentleyjs_core_1.BeTimePoint.now();
        this._flashIntensity = 0;
        this._transparencyThreshold = 0;
        this.clips = new Clips();
        this.planarClassifiers = new PlanarClassifiers();
        this._fStop = 0;
        this._ambientLight = new Float32Array(3);
        this._dcAssigned = false;
        this.decorationState = BranchState_1.BranchState.createForDecorations(); // Used when rendering view background and view/world overlays.
        this.frustumUniforms = new FrustumUniforms();
        this.bgColor = FloatRGBA_1.FloatRgba.fromColorDef(imodeljs_common_1.ColorDef.red);
        this.monoColor = FloatRGBA_1.FloatRgba.fromColorDef(imodeljs_common_1.ColorDef.white);
        this.hiliteSettings = new imodeljs_common_1.Hilite.Settings();
        this.hiliteColor = FloatRGBA_1.FloatRgba.fromColorDef(this.hiliteSettings.color);
        this.planFrustum = new imodeljs_common_1.Frustum();
        this.renderRect = new Viewport_1.ViewRect();
        this._planFraction = 0;
        this.nearPlaneCenter = new geometry_core_1.Point3d();
        this.viewMatrix = geometry_core_1.Transform.createIdentity();
        this.projectionMatrix = geometry_core_1.Matrix4d.createIdentity();
        this._visibleEdgeOverrides = new EdgeOverrides_1.EdgeOverrides();
        this._hiddenEdgeOverrides = new EdgeOverrides_1.EdgeOverrides();
        this.ambientOcclusionSettings = imodeljs_common_1.AmbientOcclusion.Settings.defaults;
        this._wantAmbientOcclusion = false;
        this._batches = [];
        this._isReadPixelsInProgress = false;
        this._readPixelsSelector = 0 /* None */;
        this._drawNonLocatable = true;
        this.isFadeOutActive = false;
        this.primitiveVisibility = 0 /* All */;
        this._scratchRangeCorners = [
            new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d(),
            new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d(),
        ];
        this._scratchRange = new geometry_core_1.Range3d();
        this._doDebugPaint = false;
        this._scratchTmpFrustum = new imodeljs_common_1.Frustum();
        this._scratchRectFrustum = new imodeljs_common_1.Frustum();
        this._scratchViewFlags = new imodeljs_common_1.ViewFlags();
        this._renderCommands = new DrawCommand_1.RenderCommands(this, this._stack, this._batchState);
        this._overlayRenderState = new RenderState_1.RenderState();
        this._overlayRenderState.flags.depthMask = false;
        this._overlayRenderState.flags.blend = true;
        this._overlayRenderState.blend.setBlendFunc(GL_1.GL.BlendFactor.One, GL_1.GL.BlendFactor.OneMinusSrcAlpha);
        this._compositor = SceneCompositor_1.SceneCompositor.create(this); // compositor is created but not yet initialized... we are still undisposed
        this.renderRect = rect ? rect : new Viewport_1.ViewRect(); // if the rect is undefined, expect that it will be updated dynamically in an OnScreenTarget
    }
    get compositor() { return this._compositor; }
    get isReadPixelsInProgress() { return this._isReadPixelsInProgress; }
    get readPixelsSelector() { return this._readPixelsSelector; }
    get drawNonLocatable() { return this._drawNonLocatable; }
    get currentOverrides() { return this._currentOverrides; }
    set currentOverrides(ovr) {
        // Don't bother setting up overrides if they don't actually override anything - wastes time doing texture lookups in shaders.
        this._currentOverrides = (undefined !== ovr && ovr.anyOverridden) ? ovr : undefined;
    }
    get transparencyThreshold() { return this._transparencyThreshold; }
    get techniques() { return System_2.System.instance.techniques; }
    get hilites() { return this._hilites; }
    get hiliteUpdateTime() { return this._hiliteUpdateTime; }
    get flashed() { return bentleyjs_core_1.Id64.isValid(this._flashedId) ? this._flashed : undefined; }
    get flashedId() { return this._flashedId; }
    get flashedUpdateTime() { return this._flashedUpdateTime; }
    get flashIntensity() { return this._flashIntensity; }
    get overridesUpdateTime() { return this._overridesUpdateTime; }
    get fStop() { return this._fStop; }
    get ambientLight() { return this._ambientLight; }
    get shaderLights() { return this._shaderLights; }
    get scene() { return this._scene; }
    get dynamics() { return this._dynamics; }
    get animationBranches() { return this._animationBranches; }
    set animationBranches(branches) { this._animationBranches = branches; }
    get branchStack() { return this._stack; }
    get solarShadowMap() { return this._solarShadowMap; }
    getWorldDecorations(decs) {
        if (undefined === this._worldDecorations) {
            // Don't allow flags like monochrome etc to affect world decorations. Allow lighting in 3d only.
            const vf = new imodeljs_common_1.ViewFlags();
            vf.renderMode = imodeljs_common_1.RenderMode.SmoothShade;
            vf.clipVolume = false;
            const showLights = !this.is2d;
            vf.sourceLights = showLights;
            vf.cameraLights = showLights;
            vf.solarLight = showLights;
            this._worldDecorations = new Graphic_1.WorldDecorations(vf);
        }
        this._worldDecorations.init(decs);
        return this._worldDecorations;
    }
    get currentViewFlags() { return this._stack.top.viewFlags; }
    get currentTransform() { return this._stack.top.transform; }
    get currentShaderFlags() { return this.currentViewFlags.monochrome ? 1 /* Monochrome */ : 0 /* None */; }
    get currentFeatureSymbologyOverrides() { return this._stack.top.symbologyOverrides; }
    get clipDef() {
        if (this.hasClipVolume)
            return new TechniqueFlags_1.ClipDef(2 /* Planes */, this.clips.count);
        else if (this.hasClipMask)
            return new TechniqueFlags_1.ClipDef(1 /* Mask */);
        else
            return new TechniqueFlags_1.ClipDef();
    }
    get hasClipVolume() { return this.clips.isValid && this._stack.top.showClipVolume; }
    get hasClipMask() { return undefined !== this.clipMask; }
    get clipMask() { return this._clipMask; }
    set clipMask(mask) {
        bentleyjs_core_1.assert((mask === undefined) === this.hasClipMask);
        bentleyjs_core_1.assert(this.is2d);
        this._clipMask = mask;
    }
    get is2d() { return this.frustumUniforms.is2d; }
    get is3d() { return !this.is2d; }
    dispose() {
        this.reset();
        bentleyjs_core_1.dispose(this._compositor);
        this._dcAssigned = false; // necessary to reassign to OnScreenTarget fbo member when re-validating render plan
    }
    pushBranch(exec, branch) {
        this._stack.pushBranch(branch);
        const clip = this._stack.top.clipVolume;
        if (undefined !== clip) {
            clip.pushToShaderExecutor(exec);
        }
        const planarClassifier = this._stack.top.planarClassifier;
        if (undefined !== planarClassifier)
            planarClassifier.push(exec);
    }
    pushState(state) {
        bentleyjs_core_1.assert(undefined === state.clipVolume);
        this._stack.pushState(state);
    }
    popBranch() {
        const clip = this._stack.top.clipVolume;
        if (undefined !== clip) {
            clip.pop(this);
        }
        const planarClassifier = this._stack.top.planarClassifier;
        if (undefined !== planarClassifier)
            planarClassifier.pop(this);
        this._stack.pop();
    }
    pushActiveVolume() {
        if (this._activeClipVolume !== undefined)
            this._activeClipVolume.pushToTarget(this);
    }
    popActiveVolume() {
        if (this._activeClipVolume !== undefined)
            this._activeClipVolume.pop(this);
    }
    updateActiveVolume(clip) {
        if (undefined === clip) {
            this._activeClipVolume = bentleyjs_core_1.dispose(this._activeClipVolume);
            return;
        }
        // ###TODO: Currently we assume the active view ClipVector is never mutated in place.
        // ###TODO: We may want to compare differing ClipVectors to determine if they are logically equivalent to avoid reallocating clip volume.
        if (undefined === this._activeClipVolume || this._activeClipVolume.clipVector !== clip) {
            this._activeClipVolume = bentleyjs_core_1.dispose(this._activeClipVolume);
            this._activeClipVolume = System_2.System.instance.createClipVolume(clip);
        }
    }
    _getRangeCorners(r) {
        const p = this._scratchRangeCorners;
        p[0].setFromPoint3d(r.low);
        p[1].set(r.high.x, r.low.y, r.low.z),
            p[2].set(r.low.x, r.high.y, r.low.z),
            p[3].set(r.high.x, r.high.y, r.low.z),
            p[4].set(r.low.x, r.low.y, r.high.z),
            p[5].set(r.high.x, r.low.y, r.high.z),
            p[6].set(r.low.x, r.high.y, r.high.z),
            p[7].setFromPoint3d(r.high);
        return p;
    }
    /** @internal */
    isRangeOutsideActiveVolume(range) {
        if (undefined === this._activeClipVolume || !this._stack.top.showClipVolume || !this.clips.isValid)
            return false;
        range = this.currentTransform.multiplyRange(range, range);
        const testIntersection = false;
        if (testIntersection) {
            // ###TODO: Avoid allocation of Range3d inside called function...
            // ###TODO: Use some not-yet-existent API which will return as soon as it determines ANY intersection (we don't care about the actual intersection range).
            const clippedRange = geometry_core_1.ClipUtilities.rangeOfClipperIntersectionWithRange(this._activeClipVolume.clipVector, range);
            return clippedRange.isNull;
        }
        else {
            // Do the cheap, imprecise check. The above is far too slow and allocates way too many objects, especially for clips produced from non-convex shapes.
            return geometry_core_1.ClipPlaneContainment.StronglyOutside === this._activeClipVolume.clipVector.classifyPointContainment(this._getRangeCorners(range));
        }
    }
    /** @internal */
    isGeometryOutsideActiveVolume(geom) {
        if (undefined === this._activeClipVolume || !this._stack.top.showClipVolume || !this.clips.isValid)
            return false;
        const range = geom.computeRange(this._scratchRange);
        return this.isRangeOutsideActiveVolume(range);
    }
    get batchState() { return this._batchState; }
    get currentBatchId() { return this._batchState.currentBatchId; }
    pushBatch(batch) {
        this._batchState.push(batch, false);
        this.currentOverrides = batch.getOverrides(this);
    }
    popBatch() {
        this.currentOverrides = undefined;
        this._batchState.pop();
    }
    addBatch(batch) {
        bentleyjs_core_1.assert(this._batches.indexOf(batch) < 0);
        this._batches.push(batch);
    }
    onBatchDisposed(batch) {
        const index = this._batches.indexOf(batch);
        bentleyjs_core_1.assert(index > -1);
        this._batches.splice(index, 1);
    }
    get wantAmbientOcclusion() {
        return this._wantAmbientOcclusion;
    }
    // ---- Implementation of RenderTarget interface ---- //
    get renderSystem() { return System_2.System.instance; }
    get cameraFrustumNearScaleLimit() {
        return 0; // ###TODO
    }
    get planFraction() { return this._planFraction; }
    changeDecorations(decs) {
        bentleyjs_core_1.dispose(this._decorations);
        this._decorations = decs;
    }
    changeScene(scene) {
        this._scene = scene;
    }
    changeBackgroundMap(backgroundMap) {
        this._backgroundMap = backgroundMap;
    }
    changePlanarClassifiers(planarClassifiers) {
        if (this._planarClassifiers)
            for (const planarClassifier of this._planarClassifiers)
                planarClassifier[1].dispose();
        this._planarClassifiers = planarClassifiers;
    }
    changeSolarShadowMap(solarShadowMap) {
        this._solarShadowMap = solarShadowMap;
    }
    changeDynamics(dynamics) {
        // ###TODO: set feature IDs into each graphic so that edge display works correctly...
        // See IModelConnection.transientIds
        bentleyjs_core_1.disposeArray(this._dynamics);
        this._dynamics = dynamics;
    }
    overrideFeatureSymbology(ovr) {
        this._stack.setSymbologyOverrides(ovr);
        this._overridesUpdateTime = bentleyjs_core_1.BeTimePoint.now();
    }
    setHiliteSet(hilite) {
        this._hilites = hilite;
        this._hiliteUpdateTime = bentleyjs_core_1.BeTimePoint.now();
    }
    setFlashed(id, intensity) {
        if (id !== this._flashedId) {
            this._flashedId = id;
            this._flashed = bentleyjs_core_1.Id64.getUint32Pair(id);
            this._flashedUpdateTime = bentleyjs_core_1.BeTimePoint.now();
        }
        this._flashIntensity = intensity;
    }
    changeFrustum(newFrustum, newFraction, is3d) {
        newFrustum.clone(this.planFrustum);
        const farLowerLeft = newFrustum.getCorner(imodeljs_common_1.Npc.LeftBottomRear);
        const farLowerRight = newFrustum.getCorner(imodeljs_common_1.Npc.RightBottomRear);
        const farUpperLeft = newFrustum.getCorner(imodeljs_common_1.Npc.LeftTopRear);
        const farUpperRight = newFrustum.getCorner(imodeljs_common_1.Npc.RightTopRear);
        const nearLowerLeft = newFrustum.getCorner(imodeljs_common_1.Npc.LeftBottomFront);
        const nearLowerRight = newFrustum.getCorner(imodeljs_common_1.Npc.RightBottomFront);
        const nearUpperLeft = newFrustum.getCorner(imodeljs_common_1.Npc.LeftTopFront);
        const nearUpperRight = newFrustum.getCorner(imodeljs_common_1.Npc.RightTopFront);
        const scratch = Target._scratch;
        const nearCenter = nearLowerLeft.interpolate(0.5, nearUpperRight, scratch.nearCenter);
        const viewX = normalizedDifference(nearLowerRight, nearLowerLeft, scratch.viewX);
        const viewY = normalizedDifference(nearUpperLeft, nearLowerLeft, scratch.viewY);
        const viewZ = viewX.crossProduct(viewY, scratch.viewZ).normalize();
        this._planFraction = newFraction;
        if (!is3d) {
            const halfWidth = geometry_core_1.Vector3d.createStartEnd(farLowerRight, farLowerLeft, scratch.vec3).magnitude() * 0.5;
            const halfHeight = geometry_core_1.Vector3d.createStartEnd(farLowerRight, farUpperRight).magnitude() * 0.5;
            const depth = 2 * System_1.RenderTarget.frustumDepth2d;
            this.nearPlaneCenter.set(nearCenter.x, nearCenter.y, System_1.RenderTarget.frustumDepth2d);
            lookIn(this.nearPlaneCenter, viewX, viewY, viewZ, this.viewMatrix);
            ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, 0, depth, this.projectionMatrix);
            this.frustumUniforms.setPlanes(halfHeight, -halfHeight, -halfWidth, halfWidth);
            this.frustumUniforms.setFrustum(0, depth, 0 /* TwoDee */);
        }
        else if (newFraction > 0.999) { // ortho
            const halfWidth = geometry_core_1.Vector3d.createStartEnd(farLowerRight, farLowerLeft, scratch.vec3).magnitude() * 0.5;
            const halfHeight = geometry_core_1.Vector3d.createStartEnd(farLowerRight, farUpperRight).magnitude() * 0.5;
            const depth = geometry_core_1.Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratch.vec3).magnitude();
            lookIn(nearCenter, viewX, viewY, viewZ, this.viewMatrix);
            ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, 0, depth, this.projectionMatrix);
            this.nearPlaneCenter.setFrom(nearLowerLeft);
            this.nearPlaneCenter.interpolate(0.5, nearUpperRight, this.nearPlaneCenter);
            this.frustumUniforms.setPlanes(halfHeight, -halfHeight, -halfWidth, halfWidth);
            this.frustumUniforms.setFrustum(0, depth, 1 /* Orthographic */);
        }
        else { // perspective
            const scale = 1.0 / (1.0 - newFraction);
            const zVec = geometry_core_1.Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratch.vec3);
            const cameraPosition = fromSumOf(farLowerLeft, zVec, scale, scratch.point3);
            const frustumLeft = dotDifference(farLowerLeft, cameraPosition, viewX) * newFraction;
            const frustumRight = dotDifference(farLowerRight, cameraPosition, viewX) * newFraction;
            const frustumBottom = dotDifference(farLowerLeft, cameraPosition, viewY) * newFraction;
            const frustumTop = dotDifference(farUpperLeft, cameraPosition, viewY) * newFraction;
            const frustumFront = -dotDifference(nearLowerLeft, cameraPosition, viewZ);
            const frustumBack = -dotDifference(farLowerLeft, cameraPosition, viewZ);
            lookIn(cameraPosition, viewX, viewY, viewZ, this.viewMatrix);
            frustum(frustumLeft, frustumRight, frustumBottom, frustumTop, frustumFront, frustumBack, this.projectionMatrix);
            this.nearPlaneCenter.setFrom(nearLowerLeft);
            this.nearPlaneCenter.interpolate(0.5, nearUpperRight, this.nearPlaneCenter);
            this.frustumUniforms.setPlanes(frustumTop, frustumBottom, frustumLeft, frustumRight);
            this.frustumUniforms.setFrustum(frustumFront, frustumBack, 2 /* Perspective */);
        }
    }
    changeRenderPlan(plan) {
        this.plan = plan;
        if (this._dcAssigned && plan.is3d !== this.is3d) {
            // changed the dimensionality of the Target. World decorations no longer valid.
            // (lighting is enabled or disabled based on 2d vs 3d).
            this._worldDecorations = bentleyjs_core_1.dispose(this._worldDecorations);
        }
        if (!this.assignDC()) {
            bentleyjs_core_1.assert(false);
            return;
        }
        this.bgColor.setFromColorDef(plan.bgColor);
        this.monoColor.setFromColorDef(plan.monoColor);
        this.hiliteSettings = plan.hiliteSettings;
        this.hiliteColor.setFromColorDef(this.hiliteSettings.color);
        this.isFadeOutActive = plan.isFadeOutActive;
        this._transparencyThreshold = 0.0;
        this.analysisStyle = plan.analysisStyle === undefined ? undefined : plan.analysisStyle.clone();
        this.analysisTexture = plan.analysisTexture;
        this.updateActiveVolume(plan.activeVolume);
        const scratch = Target._scratch;
        let visEdgeOvrs = undefined !== plan.hline ? plan.hline.visible : undefined;
        let hidEdgeOvrs = undefined !== plan.hline ? plan.hline.hidden : undefined;
        const vf = imodeljs_common_1.ViewFlags.createFrom(plan.viewFlags, scratch.viewFlags);
        let forceEdgesOpaque = true; // most render modes want edges to be opaque so don't allow overrides to their alpha
        switch (vf.renderMode) {
            case imodeljs_common_1.RenderMode.Wireframe: {
                // Edge overrides never apply in wireframe mode
                vf.visibleEdges = false;
                vf.hiddenEdges = false;
                forceEdgesOpaque = false;
                break;
            }
            case imodeljs_common_1.RenderMode.SmoothShade: {
                // Hidden edges require visible edges
                if (!vf.visibleEdges)
                    vf.hiddenEdges = false;
                break;
            }
            case imodeljs_common_1.RenderMode.SolidFill: {
                // In solid fill, if the edge color is not overridden, the edges do not use the element's line color
                if (undefined !== visEdgeOvrs && !visEdgeOvrs.ovrColor) {
                    // ###TODO? Probably supposed to be contrast with fill and/or background color...
                    bentleyjs_core_1.assert(undefined !== hidEdgeOvrs);
                    visEdgeOvrs = visEdgeOvrs.overrideColor(imodeljs_common_1.ColorDef.white);
                    hidEdgeOvrs = hidEdgeOvrs.overrideColor(imodeljs_common_1.ColorDef.white);
                }
            }
            /* falls through */
            case imodeljs_common_1.RenderMode.HiddenLine: {
                // In solid fill and hidden line mode, visible edges always rendered and edge overrides always apply
                vf.visibleEdges = true;
                bentleyjs_core_1.assert(undefined !== plan.hline); // these render modes only supported in 3d, in which case hline always initialized
                if (undefined !== plan.hline) {
                    // The threshold in HiddenLineParams ranges from 0.0 (hide anything that's not 100% opaque)
                    // to 1.0 (don't hide anything regardless of transparency). Convert it to an alpha value.
                    let threshold = plan.hline.transparencyThreshold;
                    threshold = Math.min(1.0, Math.max(0.0, threshold));
                    this._transparencyThreshold = 1.0 - threshold;
                }
                break;
            }
        }
        if (imodeljs_common_1.RenderMode.SmoothShade === vf.renderMode && plan.is3d && undefined !== plan.ao && vf.ambientOcclusion) {
            this._wantAmbientOcclusion = true;
            this.ambientOcclusionSettings = plan.ao;
        }
        else {
            this._wantAmbientOcclusion = vf.ambientOcclusion = false;
        }
        this._visibleEdgeOverrides.init(forceEdgesOpaque, visEdgeOvrs);
        this._hiddenEdgeOverrides.init(forceEdgesOpaque, hidEdgeOvrs);
        this._stack.setViewFlags(vf);
        this.changeFrustum(plan.frustum, plan.fraction, plan.is3d);
        // this.shaderlights.clear // ###TODO : Lighting
        this._fStop = 0.0;
        this._ambientLight[0] = 0.2;
        this._ambientLight[1] = 0.2;
        this._ambientLight[2] = 0.2;
        if (plan.is3d && undefined !== plan.lights) {
            // convertLights(...); // TODO: Lighting
            this._fStop = plan.lights.fstop;
        }
    }
    drawFrame(sceneMilSecElapsed) {
        bentleyjs_core_1.assert(System_2.System.instance.frameBufferStack.isEmpty);
        if (undefined === this._scene) {
            return;
        }
        this.paintScene(sceneMilSecElapsed);
        this.drawOverlayDecorations();
        bentleyjs_core_1.assert(System_2.System.instance.frameBufferStack.isEmpty);
    }
    drawOverlayDecorations() { }
    /*
     * Invoked via Viewport.changeView() when the owning Viewport is changed to look at a different view.
     * Invoked via dispose() when the target is being destroyed.
     * The primary difference is that in the former case we retain the SceneCompositor.
     */
    reset() {
        // Clear the scene
        this._scene.length = 0;
        // Clear decorations
        this._decorations = bentleyjs_core_1.dispose(this._decorations);
        this._dynamics = bentleyjs_core_1.disposeArray(this._dynamics);
        this._worldDecorations = bentleyjs_core_1.dispose(this._worldDecorations);
        // Clear render commands
        this._renderCommands.clear();
        // Clear FeatureOverrides for this Target.
        // This may not be strictly necessary as the Target may still be viewing some of these batches, but better to clean up and recreate
        // than to leave unused in memory.
        for (const batch of this._batches)
            batch.onTargetDisposed(this);
        this._batches = [];
        this._activeClipVolume = bentleyjs_core_1.dispose(this._activeClipVolume);
    }
    get wantInvertBlackBackground() { return false; }
    get visibleEdgeOverrides() { return this.getEdgeOverrides(1 /* OpaqueLinear */); }
    get hiddenEdgeOverrides() { return this.getEdgeOverrides(6 /* HiddenEdge */); }
    get isEdgeColorOverridden() {
        const ovrs = this.visibleEdgeOverrides;
        return undefined !== ovrs && ovrs.overridesColor;
    }
    get isEdgeWeightOverridden() {
        const ovrs = this.visibleEdgeOverrides;
        return undefined !== ovrs && ovrs.overridesWeight;
    }
    getEdgeOverrides(pass) {
        let ovrs;
        let enabled = false;
        if (6 /* HiddenEdge */ === pass) {
            ovrs = this._hiddenEdgeOverrides;
            enabled = this.currentViewFlags.hiddenEdges;
        }
        else {
            ovrs = this._visibleEdgeOverrides;
            enabled = this.currentViewFlags.visibleEdges;
        }
        return enabled ? ovrs : undefined;
    }
    getEdgeWeight(params, baseWeight) {
        const ovrs = this.getEdgeOverrides(params.renderPass);
        return undefined !== ovrs && undefined !== ovrs.weight ? ovrs.weight : baseWeight;
    }
    getEdgeLineCode(params, baseCode) {
        const ovrs = this.getEdgeOverrides(params.renderPass);
        return undefined !== ovrs && undefined !== ovrs.lineCode ? ovrs.lineCode : baseCode;
    }
    get edgeColor() {
        bentleyjs_core_1.assert(this.isEdgeColorOverridden);
        return ColorInfo_1.ColorInfo.createUniform(this._visibleEdgeOverrides.color);
    }
    debugPaint() { }
    recordPerformanceMetric(operation) {
        if (this.performanceMetrics)
            this.performanceMetrics.recordTime(operation);
    }
    paintScene(sceneMilSecElapsed) {
        if (this._doDebugPaint) {
            this.debugPaint();
            return;
        }
        if (!this._dcAssigned) {
            return;
        }
        if (this.performanceMetrics)
            this.performanceMetrics.startNewFrame(sceneMilSecElapsed);
        this._beginPaint();
        const gl = System_2.System.instance.context;
        const rect = this.viewRect;
        gl.viewport(0, 0, rect.width, rect.height);
        // Set this to true to visualize the output of readPixels()...useful for debugging pick.
        const drawForReadPixels = false;
        if (drawForReadPixels) {
            this._isReadPixelsInProgress = true;
            this._readPixelsSelector = 1 /* Feature */;
            this.recordPerformanceMetric("Begin Paint");
            const vf = this.currentViewFlags.clone(this._scratchViewFlags);
            vf.transparency = false;
            vf.textures = false;
            vf.sourceLights = false;
            vf.cameraLights = false;
            vf.solarLight = false;
            vf.shadows = false;
            vf.noGeometryMap = true;
            vf.acsTriad = false;
            vf.grid = false;
            vf.monochrome = false;
            vf.materials = false;
            const state = BranchState_1.BranchState.create(this._stack.top.symbologyOverrides, vf);
            this.pushState(state);
            this._renderCommands.init(this._scene, this._backgroundMap, this._decorations, this._dynamics, true);
            this.recordPerformanceMetric("Init Commands");
            this.compositor.drawForReadPixels(this._renderCommands);
            this._stack.pop();
            this._isReadPixelsInProgress = false;
        }
        else {
            this.recordPerformanceMetric("Begin Draw Planar Classifiers");
            this.drawPlanarClassifiers();
            this.recordPerformanceMetric("Begin Draw Shadow Maps");
            this.drawSolarShadowMap();
            this.recordPerformanceMetric("Begin Paint");
            this._renderCommands.init(this._scene, this._backgroundMap, this._decorations, this._dynamics);
            this.recordPerformanceMetric("Init Commands");
            this.compositor.draw(this._renderCommands); // scene compositor gets disposed and then re-initialized... target remains undisposed
            this._stack.pushState(this.decorationState);
            this.drawPass(8 /* WorldOverlay */);
            this.drawPass(9 /* ViewOverlay */);
            this._stack.pop();
            this.recordPerformanceMetric("Overlay Draws");
        }
        // Reset the batch IDs in all batches drawn for this call.
        this._batchState.reset();
        this._endPaint();
        this.recordPerformanceMetric("End Paint");
        if (this.performanceMetrics) {
            if (this.performanceMetrics.gatherCurPerformanceMetrics) {
                const perfMet = this.performanceMetrics;
                const fpsTimerElapsed = perfMet.fpsTimer.currentSeconds - perfMet.fpsTimerStart;
                if (perfMet.spfTimes[perfMet.curSpfTimeIndex])
                    perfMet.spfSum -= perfMet.spfTimes[perfMet.curSpfTimeIndex];
                perfMet.spfSum += fpsTimerElapsed;
                perfMet.spfTimes[perfMet.curSpfTimeIndex] = fpsTimerElapsed;
                let renderTimeElapsed = 0;
                perfMet.frameTimings.forEach((val) => {
                    renderTimeElapsed += val;
                });
                if (perfMet.renderSpfTimes[perfMet.curSpfTimeIndex])
                    perfMet.renderSpfSum -= perfMet.renderSpfTimes[perfMet.curSpfTimeIndex];
                perfMet.renderSpfSum += renderTimeElapsed;
                perfMet.renderSpfTimes[perfMet.curSpfTimeIndex] = renderTimeElapsed;
                if (sceneMilSecElapsed !== undefined) {
                    if (perfMet.loadTileTimes[perfMet.curSpfTimeIndex])
                        perfMet.loadTileSum -= perfMet.loadTileTimes[perfMet.curSpfTimeIndex];
                    perfMet.loadTileSum += sceneMilSecElapsed;
                    perfMet.loadTileTimes[perfMet.curSpfTimeIndex] = sceneMilSecElapsed;
                }
                perfMet.curSpfTimeIndex++;
                if (perfMet.curSpfTimeIndex >= 50)
                    perfMet.curSpfTimeIndex = 0;
                perfMet.fpsTimerStart = perfMet.fpsTimer.currentSeconds;
            }
            if (this.performanceMetrics.gatherGlFinish) {
                // Ensure all previously queued webgl commands are finished by reading back one pixel since gl.Finish didn't work
                const bytes = new Uint8Array(4);
                System_2.System.instance.frameBufferStack.execute(this._fbo, true, () => {
                    gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, bytes);
                });
                if (this.performanceMetrics)
                    this.performanceMetrics.endFrame("Finish GPU Queue");
            }
        }
    }
    drawPass(pass) {
        System_2.System.instance.applyRenderState(this.getRenderState(pass));
        this.techniques.execute(this, this._renderCommands.getCommands(pass), pass);
    }
    getRenderState(pass) {
        // the other passes are handled by SceneCompositor
        bentleyjs_core_1.assert(9 /* ViewOverlay */ === pass || 8 /* WorldOverlay */ === pass);
        return this._overlayRenderState;
    }
    assignDC() {
        if (!this._dcAssigned) {
            this._dcAssigned = this._assignDC();
        }
        bentleyjs_core_1.assert(this._dcAssigned);
        return this._dcAssigned;
    }
    readPixels(rect, selector, receiver, excludeNonLocatable) {
        if (this.performanceMetrics)
            this.performanceMetrics.startNewFrame();
        // We can't reuse the previous frame's data for a variety of reasons, chief among them that some types of geometry (surfaces, translucent stuff) don't write
        // to the pick buffers and others we don't want - such as non-pickable decorations - do.
        // Render to an offscreen buffer so that we don't destroy the current color buffer.
        const texture = Texture_1.TextureHandle.createForAttachment(rect.width, rect.height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        if (undefined === texture) {
            receiver(undefined);
            return;
        }
        let result;
        const fbo = FrameBuffer_1.FrameBuffer.create([texture]);
        if (undefined !== fbo) {
            System_2.System.instance.frameBufferStack.execute(fbo, true, () => {
                this._drawNonLocatable = !excludeNonLocatable;
                result = this.readPixelsFromFbo(rect, selector);
                this._drawNonLocatable = true;
            });
            bentleyjs_core_1.dispose(fbo);
        }
        bentleyjs_core_1.dispose(texture);
        receiver(result);
        // Reset the batch IDs in all batches drawn for this call.
        this._batchState.reset();
    }
    readPixelsFromFbo(rect, selector) {
        this._isReadPixelsInProgress = true;
        this._readPixelsSelector = selector;
        // Temporarily turn off lighting to speed things up.
        // ###TODO: Disable textures *unless* they contain transparency. If we turn them off unconditionally then readPixels() will locate fully-transparent pixels, which we don't want.
        const vf = this.currentViewFlags.clone(this._scratchViewFlags);
        vf.transparency = false;
        vf.textures = true; // false;
        vf.sourceLights = false;
        vf.cameraLights = false;
        vf.solarLight = false;
        vf.shadows = false;
        vf.noGeometryMap = true;
        vf.acsTriad = false;
        vf.grid = false;
        vf.monochrome = false;
        vf.materials = false;
        vf.ambientOcclusion = false;
        const state = BranchState_1.BranchState.create(this._stack.top.symbologyOverrides, vf);
        this.pushState(state);
        // Create a culling frustum based on the input rect.
        const viewRect = this.viewRect;
        const leftScale = (rect.left - viewRect.left) / (viewRect.right - viewRect.left);
        const rightScale = (viewRect.right - rect.right) / (viewRect.right - viewRect.left);
        const topScale = (rect.top - viewRect.top) / (viewRect.bottom - viewRect.top);
        const bottomScale = (viewRect.bottom - rect.bottom) / (viewRect.bottom - viewRect.top);
        const tmpFrust = this._scratchTmpFrustum;
        const planFrust = this.planFrustum;
        interpolateFrustumPoint(tmpFrust, planFrust, imodeljs_common_1.Npc._000, leftScale, imodeljs_common_1.Npc._100);
        interpolateFrustumPoint(tmpFrust, planFrust, imodeljs_common_1.Npc._100, rightScale, imodeljs_common_1.Npc._000);
        interpolateFrustumPoint(tmpFrust, planFrust, imodeljs_common_1.Npc._010, leftScale, imodeljs_common_1.Npc._110);
        interpolateFrustumPoint(tmpFrust, planFrust, imodeljs_common_1.Npc._110, rightScale, imodeljs_common_1.Npc._010);
        interpolateFrustumPoint(tmpFrust, planFrust, imodeljs_common_1.Npc._001, leftScale, imodeljs_common_1.Npc._101);
        interpolateFrustumPoint(tmpFrust, planFrust, imodeljs_common_1.Npc._101, rightScale, imodeljs_common_1.Npc._001);
        interpolateFrustumPoint(tmpFrust, planFrust, imodeljs_common_1.Npc._011, leftScale, imodeljs_common_1.Npc._111);
        interpolateFrustumPoint(tmpFrust, planFrust, imodeljs_common_1.Npc._111, rightScale, imodeljs_common_1.Npc._011);
        const rectFrust = this._scratchRectFrustum;
        interpolateFrustumPoint(rectFrust, tmpFrust, imodeljs_common_1.Npc._000, bottomScale, imodeljs_common_1.Npc._010);
        interpolateFrustumPoint(rectFrust, tmpFrust, imodeljs_common_1.Npc._100, bottomScale, imodeljs_common_1.Npc._110);
        interpolateFrustumPoint(rectFrust, tmpFrust, imodeljs_common_1.Npc._010, topScale, imodeljs_common_1.Npc._000);
        interpolateFrustumPoint(rectFrust, tmpFrust, imodeljs_common_1.Npc._110, topScale, imodeljs_common_1.Npc._100);
        interpolateFrustumPoint(rectFrust, tmpFrust, imodeljs_common_1.Npc._001, bottomScale, imodeljs_common_1.Npc._011);
        interpolateFrustumPoint(rectFrust, tmpFrust, imodeljs_common_1.Npc._101, bottomScale, imodeljs_common_1.Npc._111);
        interpolateFrustumPoint(rectFrust, tmpFrust, imodeljs_common_1.Npc._011, topScale, imodeljs_common_1.Npc._001);
        interpolateFrustumPoint(rectFrust, tmpFrust, imodeljs_common_1.Npc._111, topScale, imodeljs_common_1.Npc._101);
        // If a clip has been applied to the view, trivially do nothing if aperture does not intersect
        if (undefined !== this._activeClipVolume && this._stack.top.showClipVolume && this.clips.isValid)
            if (geometry_core_1.ClipPlaneContainment.StronglyOutside === this._activeClipVolume.clipVector.classifyPointContainment(rectFrust.points))
                return undefined;
        // Repopulate the command list, omitting non-pickable decorations and putting transparent stuff into the opaque passes.
        this._renderCommands.clear();
        this._renderCommands.setCheckRange(rectFrust);
        this._renderCommands.init(this._scene, this._backgroundMap, this._decorations, this._dynamics, true);
        this._renderCommands.clearCheckRange();
        this.recordPerformanceMetric("Init Commands");
        // Draw the scene
        this.compositor.drawForReadPixels(this._renderCommands, undefined !== this._decorations ? this._decorations.worldOverlay : undefined);
        if (this.performanceMetrics && this.performanceMetrics.gatherGlFinish) {
            // Ensure all previously queued webgl commands are finished by reading back one pixel since gl.Finish didn't work
            const gl = System_2.System.instance.context;
            const bytes = new Uint8Array(4);
            System_2.System.instance.frameBufferStack.execute(this._fbo, true, () => {
                gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, bytes);
            });
            this.recordPerformanceMetric("Finish GPU Queue");
        }
        // Restore the state
        this._stack.pop();
        const result = this.compositor.readPixels(rect, selector);
        if (this.performanceMetrics)
            this.performanceMetrics.endFrame("Read Pixels");
        this._isReadPixelsInProgress = false;
        return result;
    }
    /** Given a ViewRect, return a new rect that has been adjusted for the given aspect ratio. */
    adjustRectForAspectRatio(requestedRect, targetAspectRatio) {
        const rect = requestedRect.clone();
        if (targetAspectRatio >= 1) {
            const requestedWidth = rect.width;
            const requiredWidth = rect.height * targetAspectRatio;
            const adj = requiredWidth - requestedWidth;
            rect.inset(-adj / 2, 0);
        }
        else {
            const requestedHeight = rect.height;
            const requiredHeight = rect.width / targetAspectRatio;
            const adj = requiredHeight - requestedHeight;
            rect.inset(0, -adj / 2);
        }
        return rect;
    }
    readImagePixels(out, x, y, w, h) {
        bentleyjs_core_1.assert(this._fbo !== undefined);
        if (this._fbo === undefined)
            return false;
        const context = System_2.System.instance.context;
        let didSucceed = true;
        System_2.System.instance.frameBufferStack.execute(this._fbo, true, () => {
            try {
                context.readPixels(x, y, w, h, context.RGBA, context.UNSIGNED_BYTE, out);
            }
            catch (e) {
                didSucceed = false;
            }
        });
        if (!didSucceed)
            return false;
        return true;
    }
    readImage(wantRectIn, targetSizeIn, flipVertically) {
        // Determine capture rect and validate
        const actualViewRect = this.renderRect;
        const wantRect = wantRectIn.clone();
        if (wantRect.right === -1 || wantRect.bottom === -1) { // Indicates to get the entire view, no clipping
            wantRect.right = actualViewRect.right;
            wantRect.bottom = actualViewRect.bottom;
        }
        const targetSize = targetSizeIn.clone();
        if (targetSize.x === 0 || targetSize.y === 0) { // Indicates image should have same dimensions as rect (no scaling)
            targetSize.x = wantRect.width;
            targetSize.y = wantRect.height;
        }
        const lowerRight = geometry_core_1.Point2d.create(wantRect.right - 1, wantRect.bottom - 1); // in BSIRect, the right and bottom are actually *outside* of the rectangle
        if (!actualViewRect.containsPoint(geometry_core_1.Point2d.create(wantRect.left, wantRect.top)) || !actualViewRect.containsPoint(lowerRight))
            return undefined;
        let captureRect = this.adjustRectForAspectRatio(wantRect, targetSize.x / targetSize.y);
        captureRect = wantRect.clone();
        targetSize.x = captureRect.width;
        targetSize.y = captureRect.height;
        if (!actualViewRect.containsPoint(geometry_core_1.Point2d.create(wantRect.left, wantRect.top)) || !actualViewRect.containsPoint(lowerRight))
            return undefined; // ###TODO: additional logic to shrink requested rectangle to fit inside view
        this.assignDC();
        // Read pixels. Note ViewRect thinks (0,0) = top-left. gl.readPixels expects (0,0) = bottom-left.
        const bytesPerPixel = 4;
        const imageData = new Uint8Array(bytesPerPixel * captureRect.width * captureRect.height);
        const isValidImageData = this.readImagePixels(imageData, captureRect.left, actualViewRect.height - captureRect.bottom, captureRect.width, captureRect.height);
        if (!isValidImageData)
            return undefined;
        const image = imodeljs_common_1.ImageBuffer.create(imageData, imodeljs_common_1.ImageBufferFormat.Rgba, targetSize.x);
        if (!image)
            return undefined;
        // No need to scale image.
        // Some callers want background pixels to be treated as fully-transparent
        // They indicate this by supplying a background color with full transparency
        // Any other pixels are treated as fully-opaque as alpha has already been blended
        // ###TODO: This introduces a defect in that we are not preserving alpha of translucent pixels, and therefore the returned image cannot be blended
        const preserveBGAlpha = 0.0 === this.bgColor.alpha;
        // Optimization for view attachments: if image consists entirely of background pixels, return an undefined
        let isEmptyImage = true;
        for (let i = 3; i < image.data.length; i += 4) {
            const a = image.data[i];
            if (!preserveBGAlpha || 0 < a) {
                image.data[i] = 0xff;
                isEmptyImage = false;
            }
        }
        if (isEmptyImage)
            return undefined;
        if (flipVertically) {
            const halfHeight = Math.floor(image.height / 2);
            const numBytesPerRow = image.width * 4;
            for (let loY = 0; loY < halfHeight; loY++) {
                for (let x = 0; x < image.width; x++) {
                    const hiY = (image.height - 1) - loY;
                    const loIdx = loY * numBytesPerRow + x * 4;
                    const hiIdx = hiY * numBytesPerRow + x * 4;
                    swapImageByte(image, loIdx, hiIdx);
                    swapImageByte(image, loIdx + 1, hiIdx + 1);
                    swapImageByte(image, loIdx + 2, hiIdx + 2);
                    swapImageByte(image, loIdx + 3, hiIdx + 3);
                }
            }
        }
        return image;
    }
    drawPlanarClassifiers() {
        if (this._planarClassifiers)
            this._planarClassifiers.forEach((classifier) => classifier.draw(this));
    }
    drawSolarShadowMap() {
        if (this._solarShadowMap)
            this._solarShadowMap.draw(this);
    }
}
Target._scratch = {
    viewFlags: new imodeljs_common_1.ViewFlags(),
    nearCenter: new geometry_core_1.Point3d(),
    viewX: new geometry_core_1.Vector3d(),
    viewY: new geometry_core_1.Vector3d(),
    viewZ: new geometry_core_1.Vector3d(),
    vec3: new geometry_core_1.Vector3d(),
    point3: new geometry_core_1.Point3d(),
    //  visibleEdges: new HiddenLine.Style({}),
    // hiddenEdges: new HiddenLine.Style({ ovrColor: false, color: new ColorDef(ColorByName.white), width: 1, pattern: LinePixels.HiddenLine }),
    animationDisplay: undefined,
};
exports.Target = Target;
/** A Target that renders to a canvas on the screen
 * @internal
 */
class OnScreenTarget extends Target {
    constructor(canvas) {
        super();
        this._prevViewRect = new Viewport_1.ViewRect();
        this._animationFraction = 0;
        this._canvas = canvas;
    }
    dispose() {
        this._fbo = bentleyjs_core_1.dispose(this._fbo);
        this._blitGeom = bentleyjs_core_1.dispose(this._blitGeom);
        super.dispose();
    }
    get animationFraction() { return this._animationFraction; }
    set animationFraction(fraction) { this._animationFraction = fraction; }
    get viewRect() {
        bentleyjs_core_1.assert(0 < this.renderRect.width && 0 < this.renderRect.height, "Zero-size view rect");
        bentleyjs_core_1.assert(Math.floor(this.renderRect.width) === this.renderRect.width && Math.floor(this.renderRect.height) === this.renderRect.height, "fractional view rect dimensions");
        return this.renderRect;
    }
    setViewRect(_rect, _temporary) { bentleyjs_core_1.assert(false); }
    _assignDC() {
        bentleyjs_core_1.assert(undefined === this._fbo);
        const rect = this.viewRect; // updates the render rect to be the client width and height
        const color = Texture_1.TextureHandle.createForAttachment(rect.width, rect.height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        if (undefined === color) {
            return false;
        }
        this._fbo = FrameBuffer_1.FrameBuffer.create([color]);
        if (undefined === this._fbo) {
            return false;
        }
        const tx = this._fbo.getColor(0);
        bentleyjs_core_1.assert(undefined !== tx.getHandle());
        this._blitGeom = CachedGeometry_1.SingleTexturedViewportQuadGeometry.createGeometry(tx.getHandle(), 16 /* CopyColorNoAlpha */);
        return undefined !== this._blitGeom;
    }
    debugPaint() {
        const rect = this.viewRect;
        const canvas = System_2.System.instance.canvas;
        canvas.width = rect.width;
        canvas.height = rect.height;
        const gl = System_2.System.instance.context;
        gl.viewport(0, 0, rect.width, rect.height);
        gl.clearColor(1, 0, 1, 1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        const context = this._canvas.getContext("2d", { alpha: false });
        bentleyjs_core_1.assert(null !== context);
        context.drawImage(canvas, 0, 0);
    }
    updateViewRect() {
        this.renderRect.init(0, 0, this._canvas.clientWidth, this._canvas.clientHeight);
        const viewRect = this.renderRect;
        if (this._prevViewRect.width !== viewRect.width || this._prevViewRect.height !== viewRect.height) {
            // Must ensure internal bitmap grid dimensions of on-screen canvas match its own on-screen appearance
            this._canvas.width = viewRect.width;
            this._canvas.height = viewRect.height;
            this._prevViewRect.setFrom(viewRect);
            return true;
        }
        return false;
    }
    _beginPaint() {
        bentleyjs_core_1.assert(undefined !== this._fbo);
        // Render to our framebuffer
        const system = System_2.System.instance;
        system.frameBufferStack.push(this._fbo, true);
        const viewRect = this.viewRect;
        // Ensure off-screen canvas dimensions match on-screen canvas dimensions
        if (system.canvas.width !== viewRect.width)
            system.canvas.width = viewRect.width;
        if (system.canvas.height !== viewRect.height)
            system.canvas.height = viewRect.height;
        bentleyjs_core_1.assert(system.context.drawingBufferWidth === viewRect.width, "offscreen context dimensions don't match onscreen");
        bentleyjs_core_1.assert(system.context.drawingBufferHeight === viewRect.height, "offscreen context dimensions don't match onscreen");
    }
    static getDrawParams(target, geom) {
        if (undefined === this._progParams) {
            this._progParams = new DrawCommand_1.ShaderProgramParams();
            this._drawParams = new DrawCommand_1.DrawParams();
        }
        this._progParams.init(target);
        this._drawParams.init(this._progParams, geom);
        return this._drawParams;
    }
    _endPaint() {
        const onscreenContext = this._canvas.getContext("2d", { alpha: false });
        bentleyjs_core_1.assert(null !== onscreenContext);
        bentleyjs_core_1.assert(undefined !== this._blitGeom);
        if (undefined === this._blitGeom || null === onscreenContext) {
            return;
        }
        const system = System_2.System.instance;
        system.frameBufferStack.pop();
        // Copy framebuffer contents to off-screen canvas
        system.applyRenderState(RenderState_1.RenderState.defaults);
        const drawParams = OnScreenTarget.getDrawParams(this, this._blitGeom);
        system.techniques.draw(drawParams);
        // NB: Very early on we found that we needed to do a clearRect() on the 2d context to prevent artifacts in final image...
        // this turned out to be a significant performance issue in Firefox and removal produced no artifacts.
        // onscreenContext.clearRect(0, 0, this._canvas.clientWidth, this._canvas.clientHeight);
        // Copy off-screen canvas contents to on-screen canvas
        onscreenContext.drawImage(system.canvas, 0, 0);
    }
    drawOverlayDecorations() {
        if (undefined !== this._decorations && undefined !== this._decorations.canvasDecorations) {
            const ctx = this._canvas.getContext("2d", { alpha: false });
            for (const overlay of this._decorations.canvasDecorations) {
                ctx.save();
                if (overlay.position)
                    ctx.translate(overlay.position.x, overlay.position.y);
                overlay.drawDecoration(ctx);
                ctx.restore();
            }
        }
    }
    pickOverlayDecoration(pt) {
        let overlays;
        if (undefined === this._decorations || undefined === (overlays = this._decorations.canvasDecorations))
            return undefined;
        // loop over array backwards, because later entries are drawn on top.
        for (let i = overlays.length - 1; i >= 0; --i) {
            const overlay = overlays[i];
            if (undefined !== overlay.pick && overlay.pick(pt))
                return overlay;
        }
        return undefined;
    }
    onResized() {
        this._dcAssigned = false;
        this._fbo = bentleyjs_core_1.dispose(this._fbo);
    }
}
exports.OnScreenTarget = OnScreenTarget;
/** @internal */
class OffScreenTarget extends Target {
    constructor(rect) {
        super(rect);
        this._animationFraction = 0;
    }
    get animationFraction() { return this._animationFraction; }
    set animationFraction(fraction) { this._animationFraction = fraction; }
    get viewRect() { return this.renderRect; }
    onResized() { bentleyjs_core_1.assert(false); } // offscreen viewport's dimensions are set once, in constructor.
    updateViewRect() { return false; } // offscreen target does not dynamically resize the view rect
    setViewRect(rect, temporary) {
        if (this.renderRect.equals(rect))
            return;
        this.renderRect.setFrom(rect);
        if (temporary) {
            // Temporarily adjust view rect to create scene for a view attachment.
            // Will be reset before attachment is rendered - so don't blow away our framebuffers + textures
            return;
        }
        this._dcAssigned = false;
        this._fbo = bentleyjs_core_1.dispose(this._fbo);
        bentleyjs_core_1.dispose(this._compositor);
    }
    _assignDC() {
        if (!this.updateViewRect() && this._fbo !== undefined)
            return true;
        const rect = this.viewRect;
        const color = Texture_1.TextureHandle.createForAttachment(rect.width, rect.height, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte);
        if (color === undefined)
            return false;
        this._fbo = FrameBuffer_1.FrameBuffer.create([color]);
        bentleyjs_core_1.assert(this._fbo !== undefined);
        return this._fbo !== undefined;
    }
    _beginPaint() {
        bentleyjs_core_1.assert(this._fbo !== undefined);
        System_2.System.instance.frameBufferStack.push(this._fbo, true);
    }
    _endPaint() {
        System_2.System.instance.frameBufferStack.pop();
    }
}
exports.OffScreenTarget = OffScreenTarget;
function normalizedDifference(p0, p1, out) {
    const result = undefined !== out ? out : new geometry_core_1.Vector3d();
    result.x = p0.x - p1.x;
    result.y = p0.y - p1.y;
    result.z = p0.z - p1.z;
    result.normalizeInPlace();
    return result;
}
/** @internal */
function fromSumOf(p, v, scale, out) {
    const result = undefined !== out ? out : new geometry_core_1.Point3d();
    result.x = p.x + v.x * scale;
    result.y = p.y + v.y * scale;
    result.z = p.z + v.z * scale;
    return result;
}
exports.fromSumOf = fromSumOf;
function dotDifference(pt, origin, vec) {
    return (pt.x - origin.x) * vec.x + (pt.y - origin.y) * vec.y + (pt.z - origin.z) * vec.z;
}
function lookIn(eye, viewX, viewY, viewZ, result) {
    const rot = result.matrix.coffs;
    rot[0] = viewX.x;
    rot[1] = viewX.y;
    rot[2] = viewX.z;
    rot[3] = viewY.x;
    rot[4] = viewY.y;
    rot[5] = viewY.z;
    rot[6] = viewZ.x;
    rot[7] = viewZ.y;
    rot[8] = viewZ.z;
    result.origin.x = -viewX.dotProduct(eye);
    result.origin.y = -viewY.dotProduct(eye);
    result.origin.z = -viewZ.dotProduct(eye);
}
function ortho(left, right, bottom, top, near, far, result) {
    geometry_core_1.Matrix4d.createRowValues(2.0 / (right - left), 0.0, 0.0, -(right + left) / (right - left), 0.0, 2.0 / (top - bottom), 0.0, -(top + bottom) / (top - bottom), 0.0, 0.0, -2.0 / (far - near), -(far + near) / (far - near), 0.0, 0.0, 0.0, 1.0, result);
}
function frustum(left, right, bottom, top, near, far, result) {
    geometry_core_1.Matrix4d.createRowValues((2.0 * near) / (right - left), 0.0, (right + left) / (right - left), 0.0, 0.0, (2.0 * near) / (top - bottom), (top + bottom) / (top - bottom), 0.0, 0.0, 0.0, -(far + near) / (far - near), -(2.0 * far * near) / (far - near), 0.0, 0.0, -1.0, 0.0, result);
}
function interpolatePoint(p0, fraction, p1, out) {
    let x;
    let y;
    let z;
    if (fraction <= 0.5) {
        x = p0.x + fraction * (p1.x - p0.x);
        y = p0.y + fraction * (p1.y - p0.y);
        z = p0.z + fraction * (p1.z - p0.z);
    }
    else {
        const t = fraction - 1.0;
        x = p1.x + t * (p1.x - p0.x);
        y = p1.y + t * (p1.y - p0.y);
        z = p1.z + t * (p1.z - p0.z);
    }
    return geometry_core_1.Point3d.create(x, y, z, out);
}
function interpolateFrustumPoint(destFrust, srcFrust, destPoint, scale, srcPoint) {
    interpolatePoint(srcFrust.getCorner(destPoint), scale, srcFrust.getCorner(srcPoint), destFrust.points[destPoint]);
}


/***/ }),

/***/ "./lib/render/webgl/Technique.js":
/*!***************************************!*\
  !*** ./lib/render/webgl/Technique.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ShaderProgram_1 = __webpack_require__(/*! ./ShaderProgram */ "./lib/render/webgl/ShaderProgram.js");
const TechniqueId_1 = __webpack_require__(/*! ./TechniqueId */ "./lib/render/webgl/TechniqueId.js");
const TechniqueFlags_1 = __webpack_require__(/*! ./TechniqueFlags */ "./lib/render/webgl/TechniqueFlags.js");
const ShaderBuilder_1 = __webpack_require__(/*! ./ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const ClearTranslucent_1 = __webpack_require__(/*! ./glsl/ClearTranslucent */ "./lib/render/webgl/glsl/ClearTranslucent.js");
const ClearPickAndColor_1 = __webpack_require__(/*! ./glsl/ClearPickAndColor */ "./lib/render/webgl/glsl/ClearPickAndColor.js");
const CopyColor_1 = __webpack_require__(/*! ./glsl/CopyColor */ "./lib/render/webgl/glsl/CopyColor.js");
const CopyPickBuffers_1 = __webpack_require__(/*! ./glsl/CopyPickBuffers */ "./lib/render/webgl/glsl/CopyPickBuffers.js");
const CopyStencil_1 = __webpack_require__(/*! ./glsl/CopyStencil */ "./lib/render/webgl/glsl/CopyStencil.js");
const Composite_1 = __webpack_require__(/*! ./glsl/Composite */ "./lib/render/webgl/glsl/Composite.js");
const ClipMask_1 = __webpack_require__(/*! ./glsl/ClipMask */ "./lib/render/webgl/glsl/ClipMask.js");
const Translucency_1 = __webpack_require__(/*! ./glsl/Translucency */ "./lib/render/webgl/glsl/Translucency.js");
const Monochrome_1 = __webpack_require__(/*! ./glsl/Monochrome */ "./lib/render/webgl/glsl/Monochrome.js");
const Surface_1 = __webpack_require__(/*! ./glsl/Surface */ "./lib/render/webgl/glsl/Surface.js");
const PointString_1 = __webpack_require__(/*! ./glsl/PointString */ "./lib/render/webgl/glsl/PointString.js");
const PointCloud_1 = __webpack_require__(/*! ./glsl/PointCloud */ "./lib/render/webgl/glsl/PointCloud.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./glsl/FeatureSymbology */ "./lib/render/webgl/glsl/FeatureSymbology.js");
const Fragment_1 = __webpack_require__(/*! ./glsl/Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const Common_1 = __webpack_require__(/*! ./glsl/Common */ "./lib/render/webgl/glsl/Common.js");
const Vertex_1 = __webpack_require__(/*! ./glsl/Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Polyline_1 = __webpack_require__(/*! ./glsl/Polyline */ "./lib/render/webgl/glsl/Polyline.js");
const Edge_1 = __webpack_require__(/*! ./glsl/Edge */ "./lib/render/webgl/glsl/Edge.js");
const SkyBox_1 = __webpack_require__(/*! ./glsl/SkyBox */ "./lib/render/webgl/glsl/SkyBox.js");
const SkySphere_1 = __webpack_require__(/*! ./glsl/SkySphere */ "./lib/render/webgl/glsl/SkySphere.js");
const AmbientOcclusion_1 = __webpack_require__(/*! ./glsl/AmbientOcclusion */ "./lib/render/webgl/glsl/AmbientOcclusion.js");
const Blur_1 = __webpack_require__(/*! ./glsl/Blur */ "./lib/render/webgl/glsl/Blur.js");
const CombineTextures_1 = __webpack_require__(/*! ./glsl/CombineTextures */ "./lib/render/webgl/glsl/CombineTextures.js");
/** A rendering technique implemented using a single shader program, typically for some specialized purpose.
 * @internal
 */
class SingularTechnique {
    // Note: Technique assumes ownership of a program
    constructor(program) { this.program = program; }
    getShader(_flags) { return this.program; }
    compileShaders() { return this.program.compile(); }
    dispose() {
        bentleyjs_core_1.dispose(this.program);
    }
}
exports.SingularTechnique = SingularTechnique;
function numFeatureVariants(numBaseShaders) { return numBaseShaders * 3; }
const numHiliteVariants = 2; // instanced and non-instanced.
const featureModes = [0 /* None */, 1 /* Pick */, 2 /* Overrides */];
const scratchTechniqueFlags = new TechniqueFlags_1.TechniqueFlags();
const scratchHiliteFlags = new TechniqueFlags_1.TechniqueFlags();
/** A rendering technique implemented using multiple shader programs, selected based on TechniqueFlags.
 * @internal
 */
class VariedTechnique {
    constructor(numPrograms) {
        this._basicPrograms = [];
        this._clippingPrograms = [];
        this._basicPrograms.length = numPrograms;
    }
    compileShaders() {
        let allCompiled = true;
        for (const program of this._basicPrograms) {
            if (!program.compile())
                allCompiled = false;
        }
        for (const clipProg of this._clippingPrograms) {
            if (!clipProg.compileShaders())
                allCompiled = false;
        }
        return allCompiled;
    }
    verifyShadersContiguous() {
        let emptyShaderIndex = -1;
        bentleyjs_core_1.assert(-1 === (emptyShaderIndex = this._basicPrograms.findIndex((prog) => undefined === prog)), "Shader index " + emptyShaderIndex + " is undefined in " + this.constructor.name);
    }
    dispose() {
        for (const program of this._basicPrograms) {
            bentleyjs_core_1.assert(undefined !== program);
            bentleyjs_core_1.dispose(program);
        }
        this._basicPrograms.length = 0;
        for (const clipShaderObj of this._clippingPrograms) {
            bentleyjs_core_1.assert(undefined !== clipShaderObj);
            bentleyjs_core_1.assert(undefined !== clipShaderObj.maskShader);
            bentleyjs_core_1.dispose(clipShaderObj.maskShader);
            for (const clipShader of clipShaderObj.shaders) {
                bentleyjs_core_1.assert(undefined !== clipShader);
                bentleyjs_core_1.dispose(clipShader);
            }
            clipShaderObj.shaders.length = 0;
            clipShaderObj.maskShader = undefined;
        }
    }
    addShader(builder, flags, gl) {
        const descr = this._debugDescription + ": " + flags.buildDescription();
        builder.setDebugDescription(descr);
        const index = this.getShaderIndex(flags);
        bentleyjs_core_1.assert(this._basicPrograms[index] === undefined);
        this._basicPrograms[index] = builder.buildProgram(gl);
        bentleyjs_core_1.assert(this._basicPrograms[index] !== undefined);
        bentleyjs_core_1.assert(this._clippingPrograms[index] === undefined);
        this._clippingPrograms[index] = new ShaderBuilder_1.ClippingShaders(builder, gl);
        bentleyjs_core_1.assert(this._clippingPrograms[index] !== undefined);
    }
    addProgram(flags, program) {
        const index = this.getShaderIndex(flags);
        bentleyjs_core_1.assert(undefined === this._basicPrograms[index], "program already exists");
        this._basicPrograms[index] = program;
    }
    addHiliteShader(gl, instanced, classified, create) {
        const builder = create(instanced, classified);
        scratchHiliteFlags.initForHilite(new TechniqueFlags_1.ClipDef(), instanced, classified);
        this.addShader(builder, scratchHiliteFlags, gl);
    }
    addTranslucentShader(builder, flags, gl) {
        flags.isTranslucent = true;
        Translucency_1.addTranslucency(builder);
        this.addShader(builder, flags, gl);
    }
    addFeatureId(builder, feat) {
        const frag = builder.frag;
        if (0 /* None */ === feat)
            frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
        else {
            const vert = builder.vert;
            Common_1.addFrustum(builder);
            Common_1.addEyeSpace(builder);
            Vertex_1.addModelViewMatrix(vert);
            FeatureSymbology_1.addRenderOrder(frag);
            FeatureSymbology_1.addFeatureId(builder);
            Fragment_1.addPickBufferOutputs(frag);
        }
    }
    getShaderIndex(flags) {
        bentleyjs_core_1.assert(!flags.isHilite || (!flags.isTranslucent && (flags.isClassified === 1 /* Yes */ || flags.hasFeatures)), "invalid technique flags");
        const index = this.computeShaderIndex(flags);
        bentleyjs_core_1.assert(index < this._basicPrograms.length, "shader index out of bounds");
        return index;
    }
    getShader(flags) {
        const index = this.getShaderIndex(flags);
        let program;
        if (flags.hasClip) {
            const entry = this._clippingPrograms[index];
            bentleyjs_core_1.assert(undefined !== entry);
            program = entry.getProgram(flags.clip);
        }
        if (program === undefined)
            program = this._basicPrograms[index];
        return program;
    }
}
exports.VariedTechnique = VariedTechnique;
class SurfaceTechnique extends VariedTechnique {
    constructor(gl) {
        super(SurfaceTechnique._kClassified + numFeatureVariants(1) + 1);
        const flags = scratchTechniqueFlags;
        for (let instanced = 0 /* No */; instanced <= 1 /* Yes */; instanced++) {
            this.addHiliteShader(gl, instanced, 0 /* No */, Surface_1.createSurfaceHiliter);
            for (let hasAnimOrShadow = 0 /* Neither */; hasAnimOrShadow <= 2 /* Shadows */; hasAnimOrShadow++) {
                const iAnimate = 1 /* Animation */ === hasAnimOrShadow ? 1 /* Yes */ : 0 /* No */;
                const shadowable = 2 /* Shadows */ === hasAnimOrShadow ? 1 /* Yes */ : 0 /* No */;
                for (let edgeTestNeeded = 0 /* No */; edgeTestNeeded <= 1 /* Yes */; edgeTestNeeded++) {
                    for (const featureMode of featureModes) {
                        if (0 /* None */ !== featureMode || 0 /* No */ === edgeTestNeeded) {
                            flags.reset(featureMode, instanced, shadowable);
                            flags.isAnimated = iAnimate;
                            flags.isEdgeTestNeeded = edgeTestNeeded;
                            const builder = Surface_1.createSurfaceBuilder(featureMode, flags.isInstanced, flags.isAnimated, 0 /* No */, flags.isShadowable, flags.isEdgeTestNeeded);
                            Monochrome_1.addMonochrome(builder.frag);
                            Surface_1.addMaterial(builder.frag);
                            Surface_1.addSurfaceDiscardByAlpha(builder.frag);
                            this.addShader(builder, flags, gl);
                            builder.frag.unset(6 /* DiscardByAlpha */);
                            this.addTranslucentShader(builder, flags, gl);
                        }
                    }
                }
            }
        }
        this.addHiliteShader(gl, 0 /* No */, 1 /* Yes */, Surface_1.createSurfaceHiliter);
        for (const featureMode of featureModes) {
            flags.reset(featureMode, 0 /* No */, 0 /* No */);
            flags.isClassified = 1 /* Yes */;
            const builder = Surface_1.createSurfaceBuilder(featureMode, 0 /* No */, 0 /* No */, 1 /* Yes */, 0 /* No */, flags.isEdgeTestNeeded);
            Monochrome_1.addMonochrome(builder.frag);
            Surface_1.addMaterial(builder.frag);
            Surface_1.addSurfaceDiscardByAlpha(builder.frag);
            this.addShader(builder, flags, gl);
        }
        this.verifyShadersContiguous();
    }
    get _debugDescription() { return "Surface"; }
    computeShaderIndex(flags) {
        if (flags.isClassified) {
            bentleyjs_core_1.assert(!flags.isAnimated);
            bentleyjs_core_1.assert(!flags.isTranslucent);
            bentleyjs_core_1.assert(!flags.isInstanced);
            bentleyjs_core_1.assert(!flags.isShadowable);
            bentleyjs_core_1.assert(!flags.isEdgeTestNeeded);
            const baseIndex = SurfaceTechnique._kClassified;
            return flags.isHilite ? baseIndex + numFeatureVariants(1) : baseIndex + flags.featureMode;
        }
        else if (flags.isHilite) {
            bentleyjs_core_1.assert(flags.hasFeatures);
            return SurfaceTechnique._kHilite + flags.isInstanced;
        }
        bentleyjs_core_1.assert(flags.hasFeatures || flags.isEdgeTestNeeded === 0 /* No */);
        let index = flags.isTranslucent ? SurfaceTechnique._kTranslucent : SurfaceTechnique._kOpaque;
        if (flags.isInstanced)
            index += SurfaceTechnique._kInstanced;
        index += SurfaceTechnique._kFeature * flags.featureMode;
        if (flags.isEdgeTestNeeded)
            index += SurfaceTechnique._kEdgeTestNeeded;
        if (flags.isAnimated)
            index += SurfaceTechnique._kAnimated;
        if (flags.isShadowable)
            index += SurfaceTechnique._kShadowable;
        return index;
    }
}
SurfaceTechnique._kOpaque = 0;
SurfaceTechnique._kTranslucent = 1;
SurfaceTechnique._kInstanced = 2;
SurfaceTechnique._kFeature = 4;
SurfaceTechnique._kEdgeTestNeeded = 8; // only when hasFeatures
SurfaceTechnique._kAnimated = numFeatureVariants(SurfaceTechnique._kFeature) + SurfaceTechnique._kEdgeTestNeeded;
SurfaceTechnique._kShadowable = SurfaceTechnique._kAnimated + numFeatureVariants(SurfaceTechnique._kFeature) + SurfaceTechnique._kEdgeTestNeeded;
SurfaceTechnique._kHilite = SurfaceTechnique._kShadowable + numFeatureVariants(SurfaceTechnique._kFeature) + SurfaceTechnique._kEdgeTestNeeded;
// Classifiers are a special case - they are never translucent, animated, or instanced. We have 4 variants: 1 for each of the 3 feature modes, plus 1 for hilite.
SurfaceTechnique._kClassified = SurfaceTechnique._kHilite + numHiliteVariants;
class PolylineTechnique extends VariedTechnique {
    constructor(gl) {
        super(PolylineTechnique._kHilite + numHiliteVariants);
        const flags = scratchTechniqueFlags;
        for (let instanced = 0 /* No */; instanced <= 1 /* Yes */; instanced++) {
            this.addHiliteShader(gl, instanced, 0 /* No */, Polyline_1.createPolylineHiliter);
            for (const featureMode of featureModes) {
                flags.reset(featureMode, instanced, 0 /* No */);
                const builder = Polyline_1.createPolylineBuilder(instanced);
                Monochrome_1.addMonochrome(builder.frag);
                // The translucent shaders do not need the element IDs.
                const builderTrans = Polyline_1.createPolylineBuilder(instanced);
                Monochrome_1.addMonochrome(builderTrans.frag);
                if (2 /* Overrides */ === featureMode) {
                    FeatureSymbology_1.addFeatureSymbology(builderTrans, featureMode, 31 /* Linear */);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 31 /* Linear */);
                    this.addTranslucentShader(builderTrans, flags, gl);
                }
                else {
                    this.addTranslucentShader(builderTrans, flags, gl);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 0 /* None */);
                }
                this.addFeatureId(builder, featureMode);
                flags.reset(featureMode, instanced, 0 /* No */);
                this.addShader(builder, flags, gl);
            }
        }
        this.verifyShadersContiguous();
    }
    get _debugDescription() { return "Polyline"; }
    computeShaderIndex(flags) {
        if (flags.isHilite) {
            bentleyjs_core_1.assert(flags.hasFeatures);
            return PolylineTechnique._kHilite + flags.isInstanced;
        }
        let index = flags.isTranslucent ? PolylineTechnique._kTranslucent : PolylineTechnique._kOpaque;
        index += PolylineTechnique._kFeature * flags.featureMode;
        index += PolylineTechnique._kInstanced * flags.isInstanced;
        return index;
    }
}
PolylineTechnique._kOpaque = 0;
PolylineTechnique._kTranslucent = 1;
PolylineTechnique._kInstanced = 2;
PolylineTechnique._kFeature = 4;
PolylineTechnique._kHilite = numFeatureVariants(PolylineTechnique._kFeature);
class EdgeTechnique extends VariedTechnique {
    constructor(gl, isSilhouette = false) {
        super(numFeatureVariants(EdgeTechnique._kFeature));
        this._isSilhouette = isSilhouette;
        const flags = scratchTechniqueFlags;
        for (let instanced = 0 /* No */; instanced <= 1 /* Yes */; instanced++) {
            for (let iAnimate = 0 /* No */; iAnimate <= 1 /* Yes */; iAnimate++) {
                for (const featureMode of featureModes) {
                    flags.reset(featureMode, instanced, 0 /* No */);
                    flags.isAnimated = iAnimate;
                    const builder = Edge_1.createEdgeBuilder(isSilhouette, flags.isInstanced, flags.isAnimated);
                    Monochrome_1.addMonochrome(builder.frag);
                    // The translucent shaders do not need the element IDs.
                    const builderTrans = Edge_1.createEdgeBuilder(isSilhouette, flags.isInstanced, flags.isAnimated);
                    Monochrome_1.addMonochrome(builderTrans.frag);
                    if (2 /* Overrides */ === featureMode) {
                        FeatureSymbology_1.addFeatureSymbology(builderTrans, featureMode, 31 /* Linear */);
                        FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 31 /* Linear */);
                        this.addTranslucentShader(builderTrans, flags, gl);
                    }
                    else {
                        this.addTranslucentShader(builderTrans, flags, gl);
                        FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 0 /* None */);
                    }
                    this.addFeatureId(builder, featureMode);
                    flags.reset(featureMode, instanced, 0 /* No */);
                    flags.isAnimated = iAnimate;
                    this.addShader(builder, flags, gl);
                }
            }
        }
        this.verifyShadersContiguous();
    }
    get _debugDescription() { return this._isSilhouette ? "Silhouette" : "Edge"; }
    computeShaderIndex(flags) {
        let index = flags.isTranslucent ? EdgeTechnique._kTranslucent : EdgeTechnique._kOpaque;
        index += EdgeTechnique._kFeature * flags.featureMode;
        if (flags.isAnimated)
            index += EdgeTechnique._kAnimated;
        if (flags.isInstanced)
            index += EdgeTechnique._kInstanced;
        return index;
    }
}
EdgeTechnique._kOpaque = 0;
EdgeTechnique._kTranslucent = 1;
EdgeTechnique._kAnimated = 2;
EdgeTechnique._kInstanced = 4;
EdgeTechnique._kFeature = 8;
class PointStringTechnique extends VariedTechnique {
    constructor(gl) {
        super((PointStringTechnique._kHilite + numHiliteVariants));
        const flags = scratchTechniqueFlags;
        for (let instanced = 0 /* No */; instanced <= 1 /* Yes */; instanced++) {
            this.addHiliteShader(gl, instanced, 0 /* No */, PointString_1.createPointStringHiliter);
            for (const featureMode of featureModes) {
                flags.reset(featureMode, instanced, 0 /* No */);
                const builder = PointString_1.createPointStringBuilder(instanced);
                Monochrome_1.addMonochrome(builder.frag);
                // The translucent shaders do not need the element IDs.
                const builderTrans = PointString_1.createPointStringBuilder(instanced);
                Monochrome_1.addMonochrome(builderTrans.frag);
                if (2 /* Overrides */ === featureMode) {
                    FeatureSymbology_1.addFeatureSymbology(builderTrans, featureMode, 29 /* Point */);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 29 /* Point */);
                    this.addTranslucentShader(builderTrans, flags, gl);
                }
                else {
                    this.addTranslucentShader(builderTrans, flags, gl);
                    FeatureSymbology_1.addFeatureSymbology(builder, featureMode, 0 /* None */);
                }
                this.addFeatureId(builder, featureMode);
                flags.reset(featureMode, instanced, 0 /* No */);
                this.addShader(builder, flags, gl);
            }
        }
        this.verifyShadersContiguous();
    }
    get _debugDescription() { return "PointString"; }
    computeShaderIndex(flags) {
        if (flags.isHilite) {
            bentleyjs_core_1.assert(flags.hasFeatures);
            return PointStringTechnique._kHilite + flags.isInstanced;
        }
        let index = flags.isTranslucent ? PointStringTechnique._kTranslucent : PointStringTechnique._kOpaque;
        index += PointStringTechnique._kFeature * flags.featureMode;
        index += PointStringTechnique._kInstanced * flags.isInstanced;
        return index;
    }
}
PointStringTechnique._kOpaque = 0;
PointStringTechnique._kTranslucent = 1;
PointStringTechnique._kInstanced = 2;
PointStringTechnique._kFeature = 4;
PointStringTechnique._kHilite = numFeatureVariants(PointStringTechnique._kFeature);
class PointCloudTechnique extends VariedTechnique {
    constructor(gl) {
        super(PointCloudTechnique._kHilite + 2);
        for (let iClassified = 0 /* No */; iClassified <= 1 /* Yes */; iClassified++) {
            this.addHiliteShader(gl, 0 /* No */, iClassified, () => PointCloud_1.createPointCloudHiliter(iClassified));
            const flags = scratchTechniqueFlags;
            const pointCloudFeatureModes = [0 /* None */, 2 /* Overrides */];
            for (const featureMode of pointCloudFeatureModes) {
                flags.reset(featureMode, 0 /* No */, 0 /* No */);
                flags.isClassified = iClassified;
                const builder = PointCloud_1.createPointCloudBuilder(flags.isClassified, featureMode);
                if (2 /* Overrides */ === featureMode)
                    FeatureSymbology_1.addUniformFeatureSymbology(builder);
                this.addFeatureId(builder, featureMode);
                this.addShader(builder, flags, gl);
            }
        }
        this.verifyShadersContiguous();
    }
    get _debugDescription() { return "PointCloud"; }
    computeShaderIndex(flags) {
        if (flags.isHilite)
            return PointCloudTechnique._kHilite + flags.isClassified;
        else
            return 2 * flags.isClassified + ((flags.featureMode === 0 /* None */) ? 0 : 1);
    }
}
PointCloudTechnique._kHilite = 4;
/** A collection of rendering techniques accessed by ID.
 * @internal
 */
class Techniques {
    constructor() {
        this._list = new Array(); // indexed by TechniqueId, which may exceed TechniqueId.NumBuiltIn for dynamic techniques.
        this._dynamicTechniqueIds = new Array(); // technique ID = (index in this array) + TechniqueId.NumBuiltIn
        this._scratchTechniqueFlags = new TechniqueFlags_1.TechniqueFlags();
    }
    static create(gl) {
        const techs = new Techniques();
        techs.initializeBuiltIns(gl);
        return techs;
    }
    getTechnique(id) {
        bentleyjs_core_1.assert(id < this._list.length, "technique index out of bounds");
        return this._list[id];
    }
    addDynamicTechnique(technique, name) {
        for (let i = 0; i < this._dynamicTechniqueIds.length; i++) {
            if (this._dynamicTechniqueIds[i] === name) {
                return 26 /* NumBuiltIn */ + i;
            }
        }
        this._dynamicTechniqueIds.push(name);
        this._list.push(technique);
        return 26 /* NumBuiltIn */ + this._dynamicTechniqueIds.length - 1;
    }
    /** Execute each command in the list */
    execute(target, commands, renderPass) {
        bentleyjs_core_1.assert(255 /* None */ !== renderPass, "invalid render pass");
        const flags = this._scratchTechniqueFlags;
        bentleyjs_core_1.using(new ShaderProgram_1.ShaderProgramExecutor(target, renderPass), (executor) => {
            let omitCounter = 0;
            for (const command of commands) {
                const omitStatus = command.getOmitStatus(target);
                if ((omitCounter += omitStatus) !== 0 || omitStatus !== 0 /* Neutral */)
                    continue;
                command.preExecute(executor);
                const techniqueId = command.getTechniqueId(target);
                if (-1 /* Invalid */ !== techniqueId) {
                    // A primitive command.
                    bentleyjs_core_1.assert(command.isPrimitiveCommand, "expected primitive command");
                    const shadowable = techniqueId === 0 /* Surface */ && target.solarShadowMap !== undefined && target.solarShadowMap.isReady; // TBD - Avoid shadows for pick?
                    flags.init(target, renderPass, 0 /* No */, 0 /* No */, target.planarClassifiers.isValid ? 1 /* Yes */ : 0 /* No */, shadowable ? 1 /* Yes */ : 0 /* No */);
                    flags.setAnimated(command.hasAnimation);
                    flags.setInstanced(command.isInstanced);
                    const tech = this.getTechnique(techniqueId);
                    const program = tech.getShader(flags);
                    if (executor.setProgram(program)) {
                        command.execute(executor);
                    }
                }
                else {
                    // A branch command.
                    bentleyjs_core_1.assert(!command.isPrimitiveCommand, "expected non-primitive command");
                    command.execute(executor);
                }
                command.postExecute(executor);
            }
        });
    }
    /** Execute the commands for a single given classification primitive */
    executeForIndexedClassifier(target, cmdsByIndex, renderPass, index, techId) {
        bentleyjs_core_1.assert(255 /* None */ !== renderPass, "invalid render pass");
        // There should be 3 commands per classifier in the cmdsByIndex array.
        index *= 3;
        if (index < 0 || index > cmdsByIndex.length - 3)
            return; // index out of range
        const pushCmd = cmdsByIndex[index];
        const primCmd = cmdsByIndex[index + 1];
        const popCmd = cmdsByIndex[index + 2];
        const flags = this._scratchTechniqueFlags;
        bentleyjs_core_1.using(new ShaderProgram_1.ShaderProgramExecutor(target, renderPass), (executor) => {
            // First execute the push.
            pushCmd.preExecute(executor);
            let techniqueId = pushCmd.getTechniqueId(target);
            bentleyjs_core_1.assert(-1 /* Invalid */ === techniqueId);
            bentleyjs_core_1.assert(!pushCmd.isPrimitiveCommand, "expected non-primitive command");
            pushCmd.execute(executor);
            pushCmd.postExecute(executor);
            // Execute the command for the given classification primitive.
            primCmd.preExecute(executor);
            techniqueId = primCmd.getTechniqueId(target);
            bentleyjs_core_1.assert(-1 /* Invalid */ !== techniqueId);
            // A primitive command.
            bentleyjs_core_1.assert(primCmd.isPrimitiveCommand, "expected primitive command");
            flags.init(target, renderPass, 0 /* No */);
            flags.setAnimated(primCmd.hasAnimation);
            const tech = this.getTechnique(undefined !== techId ? techId : techniqueId);
            const program = tech.getShader(flags);
            if (executor.setProgram(program)) {
                primCmd.execute(executor);
            }
            primCmd.postExecute(executor);
            // Execute the batch pop.
            popCmd.preExecute(executor);
            techniqueId = popCmd.getTechniqueId(target);
            bentleyjs_core_1.assert(-1 /* Invalid */ === techniqueId);
            bentleyjs_core_1.assert(!popCmd.isPrimitiveCommand, "expected non-primitive command");
            popCmd.execute(executor);
            popCmd.postExecute(executor);
        });
    }
    /** Draw a single primitive. Usually used for special-purpose rendering techniques. */
    draw(params) {
        const tech = this.getTechnique(params.geometry.getTechniqueId(params.target));
        const program = tech.getShader(TechniqueFlags_1.TechniqueFlags.defaults);
        bentleyjs_core_1.using(new ShaderProgram_1.ShaderProgramExecutor(params.target, params.renderPass, program), (executor) => {
            bentleyjs_core_1.assert(executor.isValid);
            if (executor.isValid) {
                executor.draw(params);
            }
        });
    }
    dispose() {
        for (const tech of this._list)
            bentleyjs_core_1.dispose(tech);
        this._list.length = 0;
    }
    // Chiefly for tests - compiles all shader programs - more generally programs are compiled on demand.
    compileShaders() {
        let allCompiled = true;
        for (const tech of this._list) {
            if (!tech.compileShaders()) {
                allCompiled = false;
            }
        }
        return allCompiled;
    }
    initializeBuiltIns(gl) {
        this._list[13 /* OITClearTranslucent */] = new SingularTechnique(ClearTranslucent_1.createClearTranslucentProgram(gl));
        this._list[18 /* ClearPickAndColor */] = new SingularTechnique(ClearPickAndColor_1.createClearPickAndColorProgram(gl));
        this._list[15 /* CopyColor */] = new SingularTechnique(CopyColor_1.createCopyColorProgram(gl));
        this._list[16 /* CopyColorNoAlpha */] = new SingularTechnique(CopyColor_1.createCopyColorProgram(gl, false));
        this._list[14 /* CopyPickBuffers */] = new SingularTechnique(CopyPickBuffers_1.createCopyPickBuffersProgram(gl));
        this._list[17 /* CopyStencil */] = new SingularTechnique(CopyStencil_1.createCopyStencilProgram(gl));
        this._list[19 /* ClipMask */] = new SingularTechnique(ClipMask_1.createClipMaskProgram(gl));
        this._list[20 /* SkyBox */] = new SingularTechnique(SkyBox_1.createSkyBoxProgram(gl));
        this._list[21 /* SkySphereGradient */] = new SingularTechnique(SkySphere_1.createSkySphereProgram(gl, true));
        this._list[22 /* SkySphereTexture */] = new SingularTechnique(SkySphere_1.createSkySphereProgram(gl, false));
        this._list[23 /* AmbientOcclusion */] = new SingularTechnique(AmbientOcclusion_1.createAmbientOcclusionProgram(gl));
        this._list[24 /* Blur */] = new SingularTechnique(Blur_1.createBlurProgram(gl));
        this._list[25 /* CombineTextures */] = new SingularTechnique(CombineTextures_1.createCombineTexturesProgram(gl));
        this._list[0 /* Surface */] = new SurfaceTechnique(gl);
        this._list[4 /* Edge */] = new EdgeTechnique(gl, false);
        this._list[5 /* SilhouetteEdge */] = new EdgeTechnique(gl, true);
        this._list[1 /* Polyline */] = new PolylineTechnique(gl);
        this._list[3 /* PointString */] = new PointStringTechnique(gl);
        this._list[2 /* PointCloud */] = new PointCloudTechnique(gl);
        for (let compositeFlags = 1; compositeFlags <= 7; compositeFlags++) {
            const techId = TechniqueId_1.computeCompositeTechniqueId(compositeFlags);
            this._list[techId] = new SingularTechnique(Composite_1.createCompositeProgram(compositeFlags, gl));
        }
        bentleyjs_core_1.assert(this._list.length === 26 /* NumBuiltIn */, "unexpected number of built-in techniques");
    }
}
exports.Techniques = Techniques;


/***/ }),

/***/ "./lib/render/webgl/TechniqueFlags.js":
/*!********************************************!*\
  !*** ./lib/render/webgl/TechniqueFlags.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
/** Meta data for what type of clip volume is being stored (mask or planes).
 * @internal
 */
class ClipDef {
    constructor(type = 0 /* None */, numberOfPlanes = 0) { this.type = type; this.numberOfPlanes = numberOfPlanes; }
    static forMask() { return new ClipDef(1 /* Mask */); }
    static forPlanes(numPlanes) { return new ClipDef(2 /* Planes */, numPlanes); }
}
exports.ClipDef = ClipDef;
/** Flags used to control which shader program is used by a rendering Technique.
 * @internal
 */
class TechniqueFlags {
    constructor(translucent = false) {
        this.clip = new ClipDef();
        this.featureMode = 0 /* None */;
        this.isEdgeTestNeeded = 0 /* No */;
        this.isAnimated = 0 /* No */;
        this.isInstanced = 0 /* No */;
        this.isClassified = 0 /* No */;
        this.isShadowable = 0 /* No */;
        this._isHilite = false;
        this.isTranslucent = translucent;
    }
    get hasClip() { return this.clip.type !== 0 /* None */; }
    init(target, pass, instanced, animated = 0 /* No */, classified = 0 /* No */, shadowable = 0 /* No */) {
        if (7 /* Hilite */ === pass || 12 /* HiliteClassification */ === pass || 14 /* HilitePlanarClassification */ === pass) {
            this.initForHilite(target.clipDef, instanced, (classified === 1 /* Yes */ && 14 /* HilitePlanarClassification */ === pass) ? 1 /* Yes */ : 0 /* No */);
        }
        else {
            this._isHilite = false;
            this.isTranslucent = 5 /* Translucent */ === pass;
            this.clip = target.clipDef;
            this.isAnimated = shadowable ? 0 /* No */ : animated; // no animation with shadows (they share texture unit).
            this.isInstanced = instanced;
            this.isClassified = classified;
            this.isShadowable = shadowable;
            if (undefined !== target.currentOverrides)
                this.featureMode = 2 /* Overrides */;
            else if (0 !== target.currentBatchId)
                this.featureMode = 1 /* Pick */;
            else
                this.featureMode = 0 /* None */;
            // Determine if we should use the shaders which support discarding surfaces in favor of their edges (and discarding non-planar surfaces in favor of coincident planar surfaces).
            // These are only useful if the geometry defines feature Ids.
            // In 3d, if we're only displaying surfaces or edges, not both, don't bother, unless forceSurfaceDiscard is true.
            this.isEdgeTestNeeded = this.hasFeatures ? (this.isClassified ? 0 /* No */ : 1 /* Yes */) : 0 /* No */;
            if (!target.currentViewFlags.forceSurfaceDiscard && target.is3d && !target.isReadPixelsInProgress && System_1.System.instance.enableOptimizedSurfaceShaders && this.isEdgeTestNeeded) {
                switch (target.currentViewFlags.renderMode) {
                    case imodeljs_common_1.RenderMode.Wireframe:
                        // We're only displaying edges (ignoring filled planar regions)
                        this.isEdgeTestNeeded = 0 /* No */;
                        break;
                    case imodeljs_common_1.RenderMode.SmoothShade:
                        if (!target.currentViewFlags.visibleEdges && !target.wantAmbientOcclusion) {
                            // We're only display surfaces (ignoring filled planar regions). NB: Filled text with outline is handled by gl.polygonOffset().
                            this.isEdgeTestNeeded = 0 /* No */;
                        }
                        break;
                    default:
                        // SolidFill and HiddenLine always display edges and surfaces.
                        break;
                }
            }
        }
    }
    reset(mode, instanced = 0 /* No */, shadowable) {
        this._isHilite = false;
        this.featureMode = mode;
        this.isTranslucent = false;
        this.isEdgeTestNeeded = 0 /* No */;
        this.isAnimated = 0 /* No */;
        this.isClassified = 0 /* No */;
        this.isInstanced = instanced;
        this.isShadowable = shadowable;
        this.clip.type = 0 /* None */;
        this.clip.numberOfPlanes = 0;
    }
    get hasFeatures() { return 0 /* None */ !== this.featureMode; }
    setAnimated(animated) { this.isAnimated = animated ? 1 /* Yes */ : 0 /* No */; }
    setInstanced(instanced) { this.isInstanced = instanced ? 1 /* Yes */ : 0 /* No */; }
    setClassified(classified) {
        this.isClassified = classified ? 1 /* Yes */ : 0 /* No */;
    }
    get isHilite() { return this._isHilite; }
    initForHilite(clip, instanced, classified) {
        this.featureMode = classified ? 0 /* None */ : 2 /* Overrides */;
        this._isHilite = true;
        this.isTranslucent = false;
        this.isEdgeTestNeeded = 0 /* No */;
        this.isAnimated = 0 /* No */;
        this.isInstanced = instanced;
        this.isClassified = classified;
        this.clip = clip;
    }
    buildDescription() {
        const parts = [this.isTranslucent ? "Translucent" : "Opaque"];
        if (this.isInstanced)
            parts.push("instanced");
        if (this.isEdgeTestNeeded)
            parts.push("edgeTestNeeded");
        if (this.isAnimated)
            parts.push("animated");
        if (this.isHilite)
            parts.push("hilite");
        if (this.isClassified)
            parts.push("classified");
        if (this.hasClip)
            parts.push("clip");
        if (this.isShadowable)
            parts.push("shadowable");
        if (this.hasFeatures)
            parts.push(1 /* Pick */ === this.featureMode ? "pick" : "overrides");
        return parts.join("; ");
    }
}
TechniqueFlags.defaults = new TechniqueFlags();
exports.TechniqueFlags = TechniqueFlags;


/***/ }),

/***/ "./lib/render/webgl/TechniqueId.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/TechniqueId.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const compositeTechniqueIds = [
    -1 /* Invalid */,
    7 /* CompositeTranslucent */,
    6 /* CompositeHilite */,
    8 /* CompositeHiliteAndTranslucent */,
    9 /* CompositeOcclusion */,
    10 /* CompositeTranslucentAndOcclusion */,
    11 /* CompositeHiliteAndOcclusion */,
    12 /* CompositeAll */,
];
/** @internal */
function computeCompositeTechniqueId(flags) {
    bentleyjs_core_1.assert(flags >= 0 && flags <= 7);
    return compositeTechniqueIds[flags];
}
exports.computeCompositeTechniqueId = computeCompositeTechniqueId;


/***/ }),

/***/ "./lib/render/webgl/Texture.js":
/*!*************************************!*\
  !*** ./lib/render/webgl/Texture.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const GL_1 = __webpack_require__(/*! ./GL */ "./lib/render/webgl/GL.js");
const System_1 = __webpack_require__(/*! ./System */ "./lib/render/webgl/System.js");
const RenderFlags_1 = __webpack_require__(/*! ./RenderFlags */ "./lib/render/webgl/RenderFlags.js");
function computeBytesUsed(width, height, format, dataType) {
    const bytesPerComponent = GL_1.GL.Texture.DataType.UnsignedByte === dataType ? 1 : 4;
    let componentsPerPixel = 1;
    switch (format) {
        case GL_1.GL.Texture.Format.Rgb:
            componentsPerPixel = 3;
            break;
        case GL_1.GL.Texture.Format.Rgba:
            componentsPerPixel = 4;
            break;
    }
    return width * height * componentsPerPixel * bytesPerComponent;
}
/** Associate texture data with a WebGLTexture from a canvas, image, OR a bitmap. */
function loadTexture2DImageData(handle, params, bytes, element) {
    handle.bytesUsed = undefined !== bytes ? bytes.byteLength : computeBytesUsed(params.width, params.height, params.format, params.dataType);
    const tex = handle.getHandle();
    const gl = System_1.System.instance.context;
    // Use tightly packed data
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    // Bind the texture object; make sure we do not interfere with other active textures
    System_1.System.instance.bindTexture2d(RenderFlags_1.TextureUnit.Zero, tex);
    // send the texture data
    if (undefined !== element) {
        gl.texImage2D(gl.TEXTURE_2D, 0, params.format, params.format, params.dataType, element);
    }
    else {
        const pixelData = undefined !== bytes ? bytes : null;
        gl.texImage2D(gl.TEXTURE_2D, 0, params.format, params.width, params.height, 0, params.format, params.dataType, pixelData);
    }
    if (params.useMipMaps) {
        gl.generateMipmap(gl.TEXTURE_2D);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    }
    else {
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.interpolate ? gl.LINEAR : gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.interpolate ? gl.LINEAR : gl.NEAREST);
    }
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapMode);
    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapMode);
    System_1.System.instance.bindTexture2d(RenderFlags_1.TextureUnit.Zero, undefined);
}
function loadTextureFromBytes(handle, params, bytes) { loadTexture2DImageData(handle, params, bytes); }
/** Associate cube texture data with a WebGLTexture from an image. */
function loadTextureCubeImageData(handle, params, images) {
    handle.bytesUsed = computeBytesUsed(params.dim * 6, params.dim, params.format, params.dataType);
    const tex = handle.getHandle();
    const gl = System_1.System.instance.context;
    // Use tightly packed data
    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
    // Bind the texture object; make sure we do not interfere with other active textures
    System_1.System.instance.bindTextureCubeMap(RenderFlags_1.TextureUnit.Zero, tex);
    const cubeTargets = [GL_1.GL.Texture.Target.CubeMapPositiveX, GL_1.GL.Texture.Target.CubeMapNegativeX, GL_1.GL.Texture.Target.CubeMapPositiveY, GL_1.GL.Texture.Target.CubeMapNegativeY, GL_1.GL.Texture.Target.CubeMapPositiveZ, GL_1.GL.Texture.Target.CubeMapNegativeZ];
    for (let i = 0; i < 6; i++) {
        gl.texImage2D(cubeTargets[i], 0, params.format, params.format, params.dataType, images[i]);
    }
    gl.texParameteri(GL_1.GL.Texture.Target.CubeMap, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
    gl.texParameteri(GL_1.GL.Texture.Target.CubeMap, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
    gl.texParameteri(GL_1.GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_S, params.wrapMode);
    gl.texParameteri(GL_1.GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_T, params.wrapMode);
    // gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_R, params.wrapMode); // Unavailable in GLES2
    System_1.System.instance.bindTextureCubeMap(RenderFlags_1.TextureUnit.Zero, undefined);
}
/** Wrapper class for a WebGL texture handle and parameters specific to an individual texture.
 * @internal
 */
class Texture extends imodeljs_common_1.RenderTexture {
    get bytesUsed() { return this.texture.bytesUsed; }
    constructor(params, texture) {
        super(params);
        this.texture = texture;
    }
    /** Free this object in the WebGL wrapper. */
    dispose() {
        bentleyjs_core_1.dispose(this.texture);
    }
    get hasTranslucency() { return GL_1.GL.Texture.Format.Rgba === this.texture.format; }
}
exports.Texture = Texture;
function getDataType(data) {
    return data instanceof Float32Array ? GL_1.GL.Texture.DataType.Float : GL_1.GL.Texture.DataType.UnsignedByte;
}
/** Parameters used internally to define how to create a texture for use with WebGL. */
class Texture2DCreateParams {
    constructor(width, height, format, dataType, wrapMode, loadImageData, useMipMaps, interpolate, dataBytes) {
        this.width = width;
        this.height = height;
        this.format = format;
        this.dataType = dataType;
        this.wrapMode = wrapMode;
        this.loadImageData = loadImageData;
        this.useMipMaps = useMipMaps;
        this.interpolate = interpolate;
        this.dataBytes = dataBytes;
    }
    static createForData(width, height, data, preserveData = false, wrapMode = GL_1.GL.Texture.WrapMode.ClampToEdge, format = GL_1.GL.Texture.Format.Rgba) {
        const bytes = (preserveData && data instanceof Uint8Array) ? data : undefined;
        return new Texture2DCreateParams(width, height, format, getDataType(data), wrapMode, (tex, params) => loadTextureFromBytes(tex, params, data), undefined, undefined, bytes);
    }
    static createForImageBuffer(image, type) {
        const props = this.getImageProperties(imodeljs_common_1.ImageBufferFormat.Rgba === image.format, type);
        return new Texture2DCreateParams(image.width, image.height, props.format, GL_1.GL.Texture.DataType.UnsignedByte, props.wrapMode, (tex, params) => loadTextureFromBytes(tex, params, image.data), props.useMipMaps, props.interpolate);
    }
    static createForAttachment(width, height, format, dataType) {
        return new Texture2DCreateParams(width, height, format, dataType, GL_1.GL.Texture.WrapMode.ClampToEdge, (tex, params) => loadTextureFromBytes(tex, params), undefined, undefined);
    }
    static createForImage(image, hasAlpha, type) {
        const props = this.getImageProperties(hasAlpha, type);
        let targetWidth = image.naturalWidth;
        let targetHeight = image.naturalHeight;
        const caps = System_1.System.instance.capabilities;
        if (1 /* Glyph */ === type) {
            targetWidth = imodeljs_common_1.nextHighestPowerOfTwo(targetWidth);
            targetHeight = imodeljs_common_1.nextHighestPowerOfTwo(targetHeight);
        }
        else if (!caps.supportsNonPowerOf2Textures && (!imodeljs_common_1.isPowerOfTwo(targetWidth) || !imodeljs_common_1.isPowerOfTwo(targetHeight))) {
            if (GL_1.GL.Texture.WrapMode.ClampToEdge === props.wrapMode) {
                // NPOT are supported but not mipmaps
                // Probably on poor hardware so I choose to disable mipmaps for lower memory usage over quality. If quality is required we need to resize the image to a pow of 2.
                // Above comment is not necessarily true - WebGL doesn't support NPOT mipmapping, only supporting base NPOT caps
                props.useMipMaps = undefined;
            }
            else if (GL_1.GL.Texture.WrapMode.Repeat === props.wrapMode) {
                targetWidth = imodeljs_common_1.nextHighestPowerOfTwo(targetWidth);
                targetHeight = imodeljs_common_1.nextHighestPowerOfTwo(targetHeight);
            }
        }
        // Cap texture dimensions to system WebGL capabilities
        const maxTexSize = System_1.System.instance.capabilities.maxTextureSize;
        targetWidth = Math.min(targetWidth, maxTexSize);
        targetHeight = Math.min(targetHeight, maxTexSize);
        let element = image;
        if (targetWidth !== image.naturalWidth || targetHeight !== image.naturalHeight) {
            // Resize so dimensions are powers-of-two
            const canvas = document.createElement("canvas");
            canvas.width = targetWidth;
            canvas.height = targetHeight;
            const context = canvas.getContext("2d");
            context.drawImage(image, 0, 0, canvas.width, canvas.height);
            element = canvas;
        }
        return new Texture2DCreateParams(targetWidth, targetHeight, props.format, GL_1.GL.Texture.DataType.UnsignedByte, props.wrapMode, (tex, params) => loadTexture2DImageData(tex, params, undefined, element), props.useMipMaps, props.interpolate);
    }
    static getImageProperties(isTranslucent, type) {
        const isSky = 3 /* SkyBox */ === type;
        const isTile = 2 /* TileSection */ === type;
        const wrapMode = 0 /* Normal */ === type ? GL_1.GL.Texture.WrapMode.Repeat : GL_1.GL.Texture.WrapMode.ClampToEdge;
        const useMipMaps = (!isSky && !isTile) ? true : undefined;
        const interpolate = true;
        const format = isTranslucent ? GL_1.GL.Texture.Format.Rgba : GL_1.GL.Texture.Format.Rgb;
        return { format, wrapMode, useMipMaps, interpolate };
    }
}
Texture2DCreateParams.placeholderParams = new Texture2DCreateParams(1, 1, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte, GL_1.GL.Texture.WrapMode.ClampToEdge, (_tex, _params) => undefined);
class TextureCubeCreateParams {
    constructor(dim, format, dataType, wrapMode, loadImageData) {
        this.dim = dim;
        this.format = format;
        this.dataType = dataType;
        this.wrapMode = wrapMode;
        this.loadImageData = loadImageData;
    }
    static createForCubeImages(posX, negX, posY, negY, posZ, negZ) {
        const targetDim = posX.naturalWidth;
        if (posX.naturalHeight !== targetDim) // Cube texture dimensions must match (width must equal height)
            return undefined;
        const images = [posX, negX, posY, negY, posZ, negZ];
        for (let i = 1; i < images.length; i++) { // Dimensions of all six sides must match each other
            if (images[i].naturalWidth !== targetDim || images[i].naturalHeight !== targetDim)
                return undefined;
        }
        return new TextureCubeCreateParams(targetDim, GL_1.GL.Texture.Format.Rgba, GL_1.GL.Texture.DataType.UnsignedByte, GL_1.GL.Texture.WrapMode.ClampToEdge, (tex, params) => loadTextureCubeImageData(tex, params, images));
    }
}
/** Wraps a WebGLTextureHandle
 * @internal
 */
class TextureHandle {
    constructor(glTexture) {
        this._bytesUsed = 0;
        this._glTexture = glTexture;
    }
    get bytesUsed() { return this._bytesUsed; }
    set bytesUsed(bytesUsed) {
        bentleyjs_core_1.assert(0 === this.bytesUsed);
        this._bytesUsed = bytesUsed;
    }
    /** Get the WebGLTexture for this TextureHandle. */
    getHandle() { return this._glTexture; }
    get isDisposed() { return this._glTexture === undefined; }
    dispose() {
        if (!this.isDisposed) {
            System_1.System.instance.disposeTexture(this._glTexture);
            this._glTexture = undefined;
        }
    }
    /** Create a 2D texture for use as a color attachment for rendering */
    static createForAttachment(width, height, format, dataType) {
        return Texture2DHandle.createForAttachment(width, height, format, dataType);
    }
    /** Create a 2D texture to hold non-image data */
    static createForData(width, height, data, wantPreserveData = false, wrapMode = GL_1.GL.Texture.WrapMode.ClampToEdge, format = GL_1.GL.Texture.Format.Rgba) {
        return Texture2DHandle.createForData(width, height, data, wantPreserveData, wrapMode, format);
    }
    /** Create a 2D texture from a bitmap */
    static createForImageBuffer(image, type) {
        return Texture2DHandle.createForImageBuffer(image, type);
    }
    /** Create a 2D texture from an HTMLImageElement. */
    static createForImage(image, hasAlpha, type) {
        return Texture2DHandle.createForImage(image, hasAlpha, type);
    }
    /** Create a cube map texture from six HTMLImageElement objects. */
    static createForCubeImages(posX, negX, posY, negY, posZ, negZ) {
        return TextureCubeHandle.createForCubeImages(posX, negX, posY, negY, posZ, negZ);
    }
}
exports.TextureHandle = TextureHandle;
/** @internal */
class Texture2DHandle extends TextureHandle {
    get width() { return this._width; }
    get height() { return this._height; }
    get format() { return this._format; }
    get dataType() { return this._dataType; }
    get dataBytes() { return this._dataBytes; }
    /** Bind specified texture handle to specified texture unit. */
    static bindTexture(texUnit, glTex) {
        bentleyjs_core_1.assert(!(glTex instanceof TextureHandle));
        System_1.System.instance.bindTexture2d(texUnit, glTex);
    }
    /** Bind the specified texture to a uniform sampler2D */
    static bindSampler(uniform, tex, unit) {
        bentleyjs_core_1.assert(!(tex instanceof TextureHandle));
        this.bindTexture(unit, tex);
        uniform.setUniform1i(unit - RenderFlags_1.TextureUnit.Zero);
    }
    /** Bind texture handle (if available) associated with an instantiation of this class to specified texture unit. */
    bind(texUnit) {
        if (undefined === this._glTexture)
            return false;
        Texture2DHandle.bindTexture(texUnit, this._glTexture);
        return true;
    }
    /** Bind this texture to a uniform sampler2D */
    bindSampler(uniform, unit) {
        if (undefined !== this._glTexture)
            Texture2DHandle.bindSampler(uniform, this._glTexture, unit);
    }
    /** Update the 2D texture contents. */
    update(updater) {
        if (0 === this.width || 0 === this.height || undefined === this._dataBytes || 0 === this._dataBytes.length) {
            bentleyjs_core_1.assert(false);
            return false;
        }
        if (!updater.modified)
            return false;
        return this.replaceTextureData(this._dataBytes);
    }
    /** Replace the 2D texture contents. */
    replaceTextureData(data) {
        bentleyjs_core_1.assert((GL_1.GL.Texture.DataType.Float === this._dataType) === (data instanceof Float32Array));
        const tex = this.getHandle();
        if (undefined === tex)
            return false;
        const gl = System_1.System.instance.context;
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
        // Go through System to ensure we don't interfere with currently-bound textures!
        System_1.System.instance.bindTexture2d(RenderFlags_1.TextureUnit.Zero, tex);
        gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, this._format, this._dataType, data);
        System_1.System.instance.bindTexture2d(RenderFlags_1.TextureUnit.Zero, undefined);
        return true;
    }
    static create(params) {
        const glTex = System_1.System.instance.context.createTexture();
        return null !== glTex ? new Texture2DHandle(glTex, params) : undefined;
    }
    /** Create a texture for use as a color attachment for rendering */
    static createForAttachment(width, height, format, dataType) {
        return this.create(Texture2DCreateParams.createForAttachment(width, height, format, dataType));
    }
    /** Create a texture to hold non-image data */
    static createForData(width, height, data, wantPreserveData = false, wrapMode = GL_1.GL.Texture.WrapMode.ClampToEdge, format = GL_1.GL.Texture.Format.Rgba) {
        return this.create(Texture2DCreateParams.createForData(width, height, data, wantPreserveData, wrapMode, format));
    }
    /** Create a texture from a bitmap */
    static createForImageBuffer(image, type) {
        bentleyjs_core_1.assert(imodeljs_common_1.isPowerOfTwo(image.width) && imodeljs_common_1.isPowerOfTwo(image.height), "###TODO: Resize image dimensions to powers-of-two if necessary");
        return this.create(Texture2DCreateParams.createForImageBuffer(image, type));
    }
    /** Create a 2D texture from an HTMLImageElement. */
    static createForImage(image, hasAlpha, type) {
        return this.create(Texture2DCreateParams.createForImage(image, hasAlpha, type));
    }
    constructor(glTexture, params) {
        super(glTexture);
        this._width = params.width;
        this._height = params.height;
        this._format = params.format;
        this._dataType = params.dataType;
        this._dataBytes = params.dataBytes;
        params.loadImageData(this, params);
    }
}
exports.Texture2DHandle = Texture2DHandle;
/** @internal */
class TextureCubeHandle extends TextureHandle {
    get width() { return this._dim; }
    get height() { return this._dim; }
    get format() { return this._format; }
    get dataType() { return this._dataType; }
    get dataBytes() { return undefined; }
    /** Bind specified cubemap texture handle to specified texture unit. */
    static bindTexture(texUnit, glTex) {
        bentleyjs_core_1.assert(!(glTex instanceof TextureHandle));
        System_1.System.instance.bindTextureCubeMap(texUnit, glTex);
    }
    /** Bind the specified texture to a uniform sampler2D */
    static bindSampler(uniform, tex, unit) {
        bentleyjs_core_1.assert(!(tex instanceof TextureHandle));
        this.bindTexture(unit, tex);
        uniform.setUniform1i(unit - RenderFlags_1.TextureUnit.Zero);
    }
    /** Bind texture handle (if available) associated with an instantiation of this class to specified texture unit. */
    bind(texUnit) {
        if (undefined === this._glTexture)
            return false;
        TextureCubeHandle.bindTexture(texUnit, this._glTexture);
        return true;
    }
    /** Bind this texture to a uniform sampler2D */
    bindSampler(uniform, unit) {
        if (undefined !== this._glTexture)
            TextureCubeHandle.bindSampler(uniform, this._glTexture, unit);
    }
    static create(params) {
        const glTex = System_1.System.instance.context.createTexture();
        return null !== glTex ? new TextureCubeHandle(glTex, params) : undefined;
    }
    /** Create a cube map texture from six HTMLImageElement objects. */
    static createForCubeImages(posX, negX, posY, negY, posZ, negZ) {
        const params = TextureCubeCreateParams.createForCubeImages(posX, negX, posY, negY, posZ, negZ);
        return params !== undefined ? this.create(params) : undefined;
    }
    constructor(glTexture, params) {
        super(glTexture);
        this._dim = params.dim;
        this._format = params.format;
        this._dataType = params.dataType;
        params.loadImageData(this, params);
    }
}
exports.TextureCubeHandle = TextureCubeHandle;
/** @internal */
class Texture2DDataUpdater {
    constructor(data) {
        this.modified = false;
        this.data = data;
    }
    setByteAtIndex(index, byte) {
        bentleyjs_core_1.assert(index < this.data.length);
        if (byte !== this.data[index]) {
            this.data[index] = byte;
            this.modified = true;
        }
    }
    setOvrFlagsAtIndex(index, value) {
        bentleyjs_core_1.assert(index < this.data.length);
        if (value !== this.data[index]) {
            this.data[index] = value;
            this.modified = true;
        }
    }
    getByteAtIndex(index) { bentleyjs_core_1.assert(index < this.data.length); return this.data[index]; }
    getFlagsAtIndex(index) { return this.getByteAtIndex(index); }
}
exports.Texture2DDataUpdater = Texture2DDataUpdater;


/***/ }),

/***/ "./lib/render/webgl/VertexLUT.js":
/*!***************************************!*\
  !*** ./lib/render/webgl/VertexLUT.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const ColorInfo_1 = __webpack_require__(/*! ./ColorInfo */ "./lib/render/webgl/ColorInfo.js");
const Texture_1 = __webpack_require__(/*! ./Texture */ "./lib/render/webgl/Texture.js");
const Handle_1 = __webpack_require__(/*! ./Handle */ "./lib/render/webgl/Handle.js");
/** @internal */
class AuxChannelLUT {
    constructor(texture, table) {
        this.texture = texture;
        this.numVertices = table.numVertices;
        this.numBytesPerVertex = table.numBytesPerVertex;
        this.initChannels(table, "displacements");
        this.initChannels(table, "normals");
        this.initChannels(table, "params");
    }
    initChannels(table, name) {
        const channels = table[name];
        if (undefined === channels)
            return;
        const map = (this[name] = new Map());
        for (const channel of channels) {
            // Compiler doesn't appear to deduce specific T here? 'as any' to work around...
            // error TS2345: Argument of type 'AuxChannel | AuxDisplacementChannel | AuxParamChannel' is not assignable to parameter of type 'T'.
            map.set(channel.name, channel);
        }
    }
    get bytesUsed() { return this.texture.bytesUsed; }
    get hasScalarAnimation() { return undefined !== this.params; }
    dispose() {
        bentleyjs_core_1.dispose(this.texture);
    }
    static create(table) {
        const texture = Texture_1.TextureHandle.createForData(table.width, table.height, table.data);
        return undefined !== texture ? new AuxChannelLUT(texture, table) : undefined;
    }
}
exports.AuxChannelLUT = AuxChannelLUT;
/** Represents the finished lookup table ready for submittal to GPU.
 * @internal
 */
class VertexLUT {
    get hasAnimation() { return undefined !== this.auxChannels; }
    get hasScalarAnimation() { return undefined !== this.auxChannels && this.auxChannels.hasScalarAnimation; }
    get bytesUsed() {
        let bytesUsed = this.texture.bytesUsed;
        if (undefined !== this.auxChannels)
            bytesUsed += this.auxChannels.bytesUsed;
        return bytesUsed;
    }
    static createFromVertexTable(vt, aux) {
        const texture = Texture_1.TextureHandle.createForData(vt.width, vt.height, vt.data);
        if (undefined === texture)
            return undefined;
        const auxLUT = undefined !== aux ? AuxChannelLUT.create(aux) : undefined;
        return new VertexLUT(texture, vt, ColorInfo_1.ColorInfo.createFromVertexTable(vt), vt.qparams, vt.uvParams, auxLUT);
    }
    constructor(texture, table, colorInfo, qparams, uvParams, auxChannels) {
        this.texture = texture;
        this.numVertices = table.numVertices;
        this.numRgbaPerVertex = table.numRgbaPerVertex;
        this.colorInfo = colorInfo;
        this.qOrigin = Handle_1.qorigin3dToArray(qparams.origin);
        this.qScale = Handle_1.qscale3dToArray(qparams.scale);
        this.auxChannels = auxChannels;
        if (undefined !== uvParams)
            this.uvQParams = Handle_1.qparams2dToArray(uvParams);
    }
    dispose() {
        bentleyjs_core_1.dispose(this.texture);
    }
}
exports.VertexLUT = VertexLUT;


/***/ }),

/***/ "./lib/render/webgl/glsl/AmbientOcclusion.js":
/*!***************************************************!*\
  !*** ./lib/render/webgl/glsl/AmbientOcclusion.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
// portions adapted from Cesium.js Copyright 2011 - 2017 Cesium Contributors
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const Texture_1 = __webpack_require__(/*! ../Texture */ "./lib/render/webgl/Texture.js");
const Decode_1 = __webpack_require__(/*! ./Decode */ "./lib/render/webgl/glsl/Decode.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./FeatureSymbology */ "./lib/render/webgl/glsl/FeatureSymbology.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/render/webgl/glsl/Viewport.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const computeAmbientOcclusion = `
  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);
  float linearDepth = readDepthAndOrder(tc).y;
  float nonLinearDepth = computeNonLinearDepth(linearDepth);
  vec3 viewPos = computePositionFromDepth(tc, nonLinearDepth).xyz;

  vec2 pixelSize = 1.0 / u_viewport.zw; // could use uniform for this
  vec3 viewNormal = computeNormalFromDepth(viewPos, tc, pixelSize);

  vec2 sampleDirection = vec2(1.0, 0.0);
  float gapAngle = 90.0 * 0.017453292519943295; // radians per degree

  // Grab some random noise
  // Multiply screen UV (range 0..1) with size of viewport divided by 4 in order to tile the 4x4 noise texture across the screen.
  // Multiply the random 0..1 vec3 by 2 and then substract 1.  This puts the components of the vec3 in the range -1..1.
  vec3 noiseVec = (TEXTURE(u_noise, tc * vec2(u_viewport.z / 4.0, u_viewport.w / 4.0)).rgb + 1.0) / 2.0;

  // Potential ###TODO: frustumLength (If the current fragment has a distance from the camera greater than this value, ambient occlusion is not computed for the fragment.)

  float bias = u_hbaoSettings.x; // Represents an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value, sampling stops in the current direction. This is used to remove shadows from near planar edges.
  float zLengthCap = u_hbaoSettings.y; // If the distance in linear Z from the current sample to first sample is greater than this value, sampling stops in the current direction.
  float intensity = u_hbaoSettings.z; // Raise the final occlusion to the power of this value.  Larger values make the ambient shadows darker.
  float texelStepSize = u_hbaoSettings.w; // Indicates the distance to step toward the next texel sample in the current direction.

  float tOcclusion = 0.0;

  // loop for each direction
  for (int i = 0; i < 4; i++) {
    float newGapAngle = gapAngle * (float(i) + noiseVec.x);
    float cosVal = cos(newGapAngle);
    float sinVal = sin(newGapAngle);

    // rotate sampling direction
    vec2 rotatedSampleDirection = vec2(cosVal * sampleDirection.x - sinVal * sampleDirection.y, sinVal * sampleDirection.x + cosVal * sampleDirection.y);
    float curOcclusion = 0.0;
    float curStepSize = texelStepSize; // 1.0 = stepsize, StepSize should be specified by uniform - what are good values?

    // loop for each step
    for (int j = 0; j < 6; j++) {
      vec2 directionWithStep = vec2(rotatedSampleDirection.x * curStepSize * pixelSize.x, rotatedSampleDirection.y * curStepSize * pixelSize.y);
      vec2 newCoords = directionWithStep + tc;

      // do not repeat around the depth texture
      if(newCoords.x > 1.0 || newCoords.y > 1.0 || newCoords.x < 0.0 || newCoords.y < 0.0) {
          break;
      }

      float curLinearDepth = readDepthAndOrder(newCoords).y;
      float curNonLinearDepth = computeNonLinearDepth(curLinearDepth);
      vec3 curViewPos = computePositionFromDepth(newCoords, curNonLinearDepth).xyz;
      vec3 diffVec = curViewPos.xyz - viewPos.xyz;
      float zLength = abs(curLinearDepth - linearDepth);

      float dotVal = clamp(dot(viewNormal, normalize(diffVec)), 0.0, 1.0);
      float weight = smoothstep(0.0, 1.0, zLengthCap / zLength);

      if (dotVal < bias) {
          dotVal = 0.0;
      }

      curOcclusion = max(curOcclusion, dotVal * weight);
      curStepSize += texelStepSize;
    }
    tOcclusion += curOcclusion;
  }

  tOcclusion /= 4.0;
  tOcclusion = 1.0 - clamp(tOcclusion, 0.0, 1.0);
  tOcclusion = pow(tOcclusion, intensity);

  return vec4(tOcclusion, tOcclusion, tOcclusion, 1.0);
`;
const computeNonLinearDepth = `
float computeNonLinearDepth(float linearDepth) {
  return mix(u_frustum.y, u_frustum.x, linearDepth);
}
`;
const computePositionFromDepth = `
vec4 computePositionFromDepth(vec2 tc, float nonLinearDepth) {
  if (kFrustumType_Perspective == u_frustum.z) {
    vec2 xy = vec2((tc.x * 2.0 - 1.0), ((1.0 - tc.y) * 2.0 - 1.0));
    vec4 posEC = u_invProj * vec4(xy, nonLinearDepth, 1.0);
    posEC = posEC / posEC.w;
    return posEC;
  } else {
    float top = u_frustumPlanes.x;
    float bottom = u_frustumPlanes.y;
    float left = u_frustumPlanes.z;
    float right = u_frustumPlanes.w;
    return vec4(mix(left, right, tc.x), mix(bottom, top, tc.y), nonLinearDepth, 1.0);
  }
}
`;
const computeNormalFromDepth = `
vec3 computeNormalFromDepth(vec3 viewPos, vec2 tc, vec2 pixelSize) {
  float nonLinearDepthU = computeNonLinearDepth(readDepthAndOrder(tc - vec2(0.0, pixelSize.y)).y);
  float nonLinearDepthD = computeNonLinearDepth(readDepthAndOrder(tc + vec2(0.0, pixelSize.y)).y);
  float nonLinearDepthL = computeNonLinearDepth(readDepthAndOrder(tc - vec2(pixelSize.x, 0.0)).y);
  float nonLinearDepthR = computeNonLinearDepth(readDepthAndOrder(tc + vec2(pixelSize.x, 0.0)).y);

  vec3 viewPosUp = computePositionFromDepth(tc - vec2(0.0, pixelSize.y), nonLinearDepthU).xyz;
  vec3 viewPosDown = computePositionFromDepth(tc + vec2(0.0, pixelSize.y), nonLinearDepthD).xyz;
  vec3 viewPosLeft = computePositionFromDepth(tc - vec2(pixelSize.x, 0.0), nonLinearDepthL).xyz;
  vec3 viewPosRight = computePositionFromDepth(tc + vec2(pixelSize.x, 0.0), nonLinearDepthR).xyz;

  vec3 up = viewPos.xyz - viewPosUp.xyz;
  vec3 down = viewPosDown.xyz - viewPos.xyz;
  vec3 left = viewPos.xyz - viewPosLeft.xyz;
  vec3 right = viewPosRight.xyz - viewPos.xyz;

  vec3 dx = length(left) < length(right) ? left : right;
  vec3 dy = length(up) < length(down) ? up : down;

  return normalize(cross(dy, dx));
}
`;
/** @internal */
function createAmbientOcclusionProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    Fragment_1.addWindowToTexCoords(frag);
    frag.addFunction(Decode_1.GLSLDecode.depthRgb);
    frag.addFunction(FeatureSymbology_1.readDepthAndOrder);
    frag.addFunction(computeNonLinearDepth);
    frag.addFunction(computePositionFromDepth);
    frag.addFunction(computeNormalFromDepth);
    frag.addFunction(Fragment_1.GLSLFragment.computeLinearDepth);
    frag.set(1 /* ComputeBaseColor */, computeAmbientOcclusion);
    frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    frag.addUniform("u_pickDepthAndOrder", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_pickDepthAndOrder", (uniform, params) => {
            const geom = params.geometry;
            Texture_1.Texture2DHandle.bindSampler(uniform, geom.depthAndOrder, RenderFlags_1.TextureUnit.Zero);
        });
    });
    frag.addUniform("u_noise", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_noise", (uniform, params) => {
            const geom = params.geometry;
            Texture_1.Texture2DHandle.bindSampler(uniform, geom.noise, RenderFlags_1.TextureUnit.One);
        });
    });
    Common_1.addFrustum(builder);
    Viewport_1.addViewport(frag);
    frag.addUniform("u_invProj", 7 /* Mat4 */, (prog) => {
        prog.addProgramUniform("u_invProj", (uniform, params) => {
            const invProj = params.projectionMatrix.clone();
            invProj.invert();
            uniform.setMatrix4(invProj);
        });
    });
    frag.addUniform("u_frustumPlanes", 5 /* Vec4 */, (prog) => {
        prog.addProgramUniform("u_frustumPlanes", (uniform, params) => {
            uniform.setUniform4fv(params.target.frustumUniforms.frustumPlanes);
        });
    });
    frag.addUniform("u_hbaoSettings", 5 /* Vec4 */, (prog) => {
        prog.addProgramUniform("u_hbaoSettings", (uniform, params) => {
            const hbaoSettings = new Float32Array([
                params.target.ambientOcclusionSettings.bias,
                params.target.ambientOcclusionSettings.zLengthCap,
                params.target.ambientOcclusionSettings.intensity,
                params.target.ambientOcclusionSettings.texelStepSize
            ]);
            uniform.setUniform4fv(hbaoSettings);
        });
    }, 3 /* High */);
    return builder.buildProgram(context);
}
exports.createAmbientOcclusionProgram = createAmbientOcclusionProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/Animation.js":
/*!********************************************!*\
  !*** ./lib/render/webgl/glsl/Animation.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Surface_1 = __webpack_require__(/*! ./Surface */ "./lib/render/webgl/glsl/Surface.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const initialize = `
  g_anim_step = vec2(1.0) / u_animLUTParams.xy;
  g_anim_center = g_anim_step * 0.5;
`;
// The vertex index is an integer in [0..numVertices].
// The frame index is an integer in [0..numBytesPerVertex/2].
// Therefore each frame index points at 2 bytes within the texture.
// The third component of the return value is 0.0 if the input index points to the first 2 bytes of the texel, or 1.0 if pointing to the second 2 bytes
const computeAnimLUTCoords = `
vec3 computeAnimLUTCoords(float vertIndex, float frameIndex) {
  // float baseIndex = (vertIndex * 2.0) + frameIndex;
  float baseIndex = (vertIndex * u_animLUTParams.z) + frameIndex;
  float halfIndex = baseIndex * 0.5;
  float index = floor(halfIndex);

  float epsilon = 0.5 / u_animLUTParams.x;
  float yId = floor(index / u_animLUTParams.x + epsilon);
  float xId = index - u_animLUTParams.x * yId;

  vec2 texCoord = g_anim_center + vec2(xId / u_animLUTParams.x, yId / u_animLUTParams.y);
  return vec3(texCoord, 2.0 * (halfIndex - index));
}`;
// Sample 2 bytes at the specified index.
const sampleAnimVec2 = `
vec2 sampleAnimVec2(float vertIndex, float frameIndex) {
  vec3 tc = computeAnimLUTCoords(vertIndex, frameIndex);
  vec4 texel = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);
  return texel.xy * (1.0 - tc.z) + texel.zw * tc.z;
}`;
// Position is quantized to 6 bytes (2 bytes per component). So we always must sample two adjacent texels. We discard two bytes based on whether the index is even or odd.
const computeAnimationFrameDisplacement = `
vec3 computeAnimationFrameDisplacement(float vertIndex, float frameIndex, vec3 origin, vec3 scale) {
  vec3 tc = computeAnimLUTCoords(vertIndex, frameIndex);
  vec4 enc1 = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);
  tc.x += g_anim_step.x;
  vec4 enc2 = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);

  vec2 ex = enc1.xy * (1.0 - tc.z) + enc1.zw * tc.z;
  vec2 ey = enc1.zw * (1.0 - tc.z) + enc2.xy * tc.z;
  vec2 ez = enc2.xy * (1.0 - tc.z) + enc2.zw * tc.z;

  vec3 qpos = vec3(decodeUInt16(ex), decodeUInt16(ey), decodeUInt16(ez));
  return unquantizePosition(qpos, origin, scale).xyz;
}`;
const computeAnimationDisplacement = `
vec3 computeAnimationDisplacement(float vertIndex, float frameIndex0, float frameIndex1, float fraction, vec3 origin, vec3 scale) {
  if (frameIndex0 < 0.0)
    return vec3(0.0, 0.0, 0.0);

  vec3 displacement = computeAnimationFrameDisplacement(vertIndex, frameIndex0, origin, scale);
  if (fraction > 0.0) {
    vec3 displacement1 = computeAnimationFrameDisplacement(vertIndex, frameIndex1, origin, scale);
    displacement += fraction * (displacement1 - displacement);
    }

  return displacement;
}`;
const adjustRawPosition = `
  rawPos.xyz += computeAnimationDisplacement(g_vertexLUTIndex, u_animDispParams.x, u_animDispParams.y, u_animDispParams.z, u_qAnimDispOrigin, u_qAnimDispScale);
  return rawPos;
`;
const computeAnimationFrameNormal = `
vec3 computeAnimationFrameNormal(float frameIndex) {
  vec2 enc = sampleAnimVec2(g_vertexLUTIndex, frameIndex);
  return octDecodeNormal(enc);
}`;
const computeAnimationNormal = `
vec3 computeAnimationNormal(float frameIndex0, float frameIndex1, float fraction) {
vec3 normal = computeAnimationFrameNormal(frameIndex0);
if (fraction > 0.0) {
  vec3 normal1 = computeAnimationFrameNormal(frameIndex1);
  normal += fraction * (normal1 - normal);
  }

return normal;
}`;
const computeAnimationFrameParam = `
float computeAnimationFrameParam(float frameIndex, float origin, float scale) {
  vec2 enc = sampleAnimVec2(g_vertexLUTIndex, frameIndex);
  return clamp((origin + scale * decodeUInt16(enc)), 0.0, 1.0);
}`;
const computeAnimationParam = `
vec2 computeAnimationParam(float frameIndex0, float frameIndex1, float fraction, float origin, float scale) {
float param = computeAnimationFrameParam(frameIndex0, origin, scale);
if (fraction > 0.0) {
  float param1 = computeAnimationFrameParam(frameIndex1, origin, scale);
  param += fraction * (param1 - param);
  }

  return vec2(.5, param);
}`;
const scratchAnimParams = [
    undefined,
    undefined,
    new Float32Array(2),
    new Float32Array(3),
];
function getAnimParams(size, initialValue) {
    const array = scratchAnimParams[size];
    if (undefined !== initialValue)
        for (let i = 0; i < array.length; i++)
            array[i] = initialValue;
    return array;
}
function getDisplacementChannel(params) {
    const style = params.target.analysisStyle;
    if (undefined === style || undefined === style.displacementChannelName)
        return undefined;
    const lutGeom = params.geometry.asLUT;
    const displacements = undefined !== lutGeom.lut.auxChannels ? lutGeom.lut.auxChannels.displacements : undefined;
    const channel = undefined !== displacements ? displacements.get(style.displacementChannelName) : undefined;
    return undefined !== channel ? { channel, style } : undefined;
}
function getNormalChannel(params) {
    const style = params.target.analysisStyle;
    if (undefined === style || undefined === style.normalChannelName)
        return undefined;
    const lutGeom = params.geometry.asLUT;
    const normals = undefined !== lutGeom.lut.auxChannels ? lutGeom.lut.auxChannels.normals : undefined;
    return undefined !== normals ? normals.get(style.normalChannelName) : undefined;
}
function getScalarChannel(params) {
    const style = params.target.analysisStyle;
    if (undefined === style || undefined === style.scalarChannelName)
        return undefined;
    const geom = params.geometry.asMesh;
    const scalars = undefined !== geom.lut.auxChannels ? geom.lut.auxChannels.params : undefined;
    const channel = undefined !== scalars ? scalars.get(style.scalarChannelName) : undefined;
    return undefined !== channel ? { channel, style } : undefined;
}
function computeAnimParams(params, channel, fraction) {
    const { inputs, indices } = channel;
    const inputValue = fraction * inputs[inputs.length - 1];
    for (let i = 0; i < inputs.length - 1; i++) {
        if (inputValue >= inputs[i] && inputValue < inputs[i + 1]) {
            params[0] = indices[i];
            params[1] = indices[i + 1];
            params[2] = inputValue - inputs[i] / (inputs[i + 1] - inputs[i]);
            return;
        }
    }
    params[0] = params[1] = indices[inputs.length - 1];
    params[2] = 0.0;
}
/** @internal */
function addAnimation(vert, isSurface) {
    // Lookup table
    vert.addGlobal("g_anim_step", 3 /* Vec2 */);
    vert.addGlobal("g_anim_center", 3 /* Vec2 */);
    vert.addInitializer(initialize);
    vert.addUniform("u_animLUT", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_animLUT", (uniform, params) => {
            const channels = (params.geometry.asLUT).lut.auxChannels;
            bentleyjs_core_1.assert(undefined !== channels);
            channels.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.AuxChannelLUT);
        });
    });
    vert.addUniform("u_animLUTParams", 4 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_animLUTParams", (uniform, params) => {
            const geom = params.geometry.asLUT;
            bentleyjs_core_1.assert(undefined !== geom && undefined !== geom.lut.auxChannels);
            const tex = geom.lut.auxChannels.texture;
            const array = getAnimParams(3);
            array[0] = tex.width;
            array[1] = tex.height;
            array[2] = geom.lut.auxChannels.numBytesPerVertex / 2;
            uniform.setUniform3fv(array);
        });
    });
    vert.addFunction(computeAnimLUTCoords);
    vert.addFunction(sampleAnimVec2);
    // Displacement
    vert.addFunction(computeAnimationFrameDisplacement);
    vert.addFunction(computeAnimationDisplacement);
    vert.set(0 /* AdjustRawPosition */, adjustRawPosition);
    vert.addUniform("u_animDispParams", 4 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_animDispParams", (uniform, params) => {
            const animParams = getAnimParams(3, 0.0);
            const disp = getDisplacementChannel(params);
            if (undefined !== disp)
                computeAnimParams(animParams, disp.channel, params.target.animationFraction);
            uniform.setUniform3fv(animParams);
        });
    });
    vert.addUniform("u_qAnimDispScale", 4 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_qAnimDispScale", (uniform, params) => {
            const animParams = getAnimParams(3, 0.0);
            const disp = getDisplacementChannel(params);
            if (undefined !== disp) {
                const displacementScale = disp.style.displacementScale ? disp.style.displacementScale : 1.0;
                for (let i = 0; i < 3; i++)
                    animParams[i] = disp.channel.qScale[i] * displacementScale; // Apply displacement scale.
            }
            uniform.setUniform3fv(animParams);
        });
    });
    vert.addUniform("u_qAnimDispOrigin", 4 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_qAnimDispOrigin", (uniform, params) => {
            const animParams = getAnimParams(3, 0.0);
            const disp = getDisplacementChannel(params);
            if (undefined !== disp) {
                const displacementScale = disp.style.displacementScale ? disp.style.displacementScale : 1.0;
                for (let i = 0; i < 3; i++)
                    animParams[i] = disp.channel.qOrigin[i] * displacementScale; // Apply displacement scale
            }
            uniform.setUniform3fv(animParams);
        });
    });
    // Normal and param
    if (isSurface) {
        vert.addFunction(Surface_1.octDecodeNormal);
        vert.addFunction(computeAnimationFrameNormal);
        vert.addFunction(computeAnimationNormal);
        vert.addFunction(computeAnimationFrameParam);
        vert.addFunction(computeAnimationParam);
        vert.addUniform("u_animNormalParams", 4 /* Vec3 */, (prog) => {
            prog.addGraphicUniform("u_animNormalParams", (uniform, params) => {
                const animParams = getAnimParams(3, -1.0);
                const channel = getNormalChannel(params);
                if (undefined !== channel)
                    computeAnimParams(animParams, channel, params.target.animationFraction);
                uniform.setUniform3fv(animParams);
            });
        });
        vert.addUniform("u_animScalarParams", 4 /* Vec3 */, (prog) => {
            prog.addGraphicUniform("u_animScalarParams", (uniform, params) => {
                const scalars = getScalarChannel(params);
                const animParams = getAnimParams(3, -1.0);
                if (undefined !== scalars)
                    computeAnimParams(animParams, scalars.channel, params.target.animationFraction);
                uniform.setUniform3fv(animParams);
            });
        });
        vert.addUniform("u_animScalarQParams", 3 /* Vec2 */, (prog) => {
            prog.addGraphicUniform("u_animScalarQParams", (uniform, params) => {
                const scalars = getScalarChannel(params);
                const animParams = getAnimParams(2, 1.0);
                if (undefined !== scalars) {
                    const rangeScale = scalars.style.scalarRange.high - scalars.style.scalarRange.low;
                    animParams[0] = imodeljs_common_1.Gradient.ThematicSettings.margin + (scalars.channel.qOrigin - scalars.style.scalarRange.low) / rangeScale;
                    animParams[1] = imodeljs_common_1.Gradient.ThematicSettings.contentRange * scalars.channel.qScale / rangeScale;
                }
                uniform.setUniform2fv(animParams);
            });
        });
    }
}
exports.addAnimation = addAnimation;


/***/ }),

/***/ "./lib/render/webgl/glsl/Blur.js":
/*!***************************************!*\
  !*** ./lib/render/webgl/glsl/Blur.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const Texture_1 = __webpack_require__(/*! ../Texture */ "./lib/render/webgl/Texture.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/render/webgl/glsl/Viewport.js");
const Decode_1 = __webpack_require__(/*! ./Decode */ "./lib/render/webgl/glsl/Decode.js");
// This shader applies a Gaussian blur in one dimension.
const computeBlur = `
  float delta = u_blurSettings.x;
  float sigma = u_blurSettings.y;
  float texelStepSize = u_blurSettings.z;

  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);
  vec2 step = texelStepSize / u_viewport.zw;

  vec3 gaussian;
  const float twoPi = 6.283185307179586;
  gaussian.x = 1.0 / (sqrt(twoPi) * sigma);
  gaussian.y = exp((-0.5 * delta * delta) / (sigma * sigma));
  gaussian.z = gaussian.y * gaussian.y;

  vec4 origColor = TEXTURE(u_textureToBlur, tc);
  vec4 result = origColor * gaussian.x;
  for (int i = 1; i < 8; i++) {
    gaussian.xy *= gaussian.yz;

    vec2 offset = float(i) * u_blurDir * step;
    vec2 tcMinusOffset = tc - offset;
    vec2 tcPlusOffset = tc + offset;

    result += TEXTURE(u_textureToBlur, tcMinusOffset) * gaussian.x;
    result += TEXTURE(u_textureToBlur, tcPlusOffset) * gaussian.x;
  }

  return result;
`;
/** @internal */
function createBlurProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    Fragment_1.addWindowToTexCoords(frag);
    frag.addFunction(Decode_1.GLSLDecode.depthRgb);
    frag.set(1 /* ComputeBaseColor */, computeBlur);
    frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    Viewport_1.addViewport(frag);
    frag.addUniform("u_textureToBlur", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_textureToBlur", (uniform, params) => {
            const geom = params.geometry;
            Texture_1.Texture2DHandle.bindSampler(uniform, geom.textureToBlur, RenderFlags_1.TextureUnit.Zero);
        });
    });
    frag.addUniform("u_blurDir", 3 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("u_blurDir", (uniform, params) => {
            const geom = params.geometry;
            uniform.setUniform2fv(new Float32Array([geom.blurDir.x, geom.blurDir.y]));
        });
    });
    frag.addUniform("u_blurSettings", 4 /* Vec3 */, (prog) => {
        prog.addProgramUniform("u_blurSettings", (uniform, params) => {
            const hbaoSettings = new Float32Array([
                // ###TODO: If we want to apply this blur shader to situations other than AO, we should move these settings away from the ambient occlusion params.
                params.target.ambientOcclusionSettings.blurDelta,
                params.target.ambientOcclusionSettings.blurSigma,
                params.target.ambientOcclusionSettings.blurTexelStepSize
            ]);
            uniform.setUniform3fv(hbaoSettings);
        });
    }, 3 /* High */);
    return builder.buildProgram(context);
}
exports.createBlurProgram = createBlurProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/ClearPickAndColor.js":
/*!****************************************************!*\
  !*** ./lib/render/webgl/glsl/ClearPickAndColor.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const computeBaseColor = "return u_bgColor;";
const assignFragData = `
  FragColor0 = baseColor;
  FragColor1 = vec4(0.0);
  FragColor2 = vec4(0.0);
`;
/** @internal */
function createClearPickAndColorProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(false);
    const frag = builder.frag;
    frag.addUniform("u_bgColor", 5 /* Vec4 */, (prog) => {
        prog.addProgramUniform("u_bgColor", (uniform, params) => {
            params.target.bgColor.bind(uniform);
        });
    });
    frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    if (!System_1.System.instance.capabilities.supportsMRTPickShaders) {
        // NB: This shader is never used - we gl.clear() directly
        frag.set(15 /* AssignFragData */, "FragColor = baseColor;");
    }
    else {
        frag.addDrawBuffersExtension();
        frag.set(15 /* AssignFragData */, assignFragData);
    }
    return builder.buildProgram(context);
}
exports.createClearPickAndColorProgram = createClearPickAndColorProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/ClearTranslucent.js":
/*!***************************************************!*\
  !*** ./lib/render/webgl/glsl/ClearTranslucent.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const computeBaseColor = "return vec4(0.0);";
const assignFragData = `
  FragColor0 = vec4(0.0, 0.0, 0.0, 1.0);
  FragColor1 = vec4(1.0, 0.0, 0.0, 1.0);
`;
const assignFragColor = `FragColor = vec4(0.0, 0.0, 0.0, 1.0);`;
/** @internal */
function createClearTranslucentProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(false);
    const frag = builder.frag;
    frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    if (System_1.System.instance.capabilities.supportsMRTTransparency) {
        frag.addDrawBuffersExtension();
        frag.set(15 /* AssignFragData */, assignFragData);
    }
    else {
        // NB: This shader is never used - we just gl.clear() directly
        frag.set(15 /* AssignFragData */, assignFragColor);
    }
    return builder.buildProgram(context);
}
exports.createClearTranslucentProgram = createClearTranslucentProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/ClipMask.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/glsl/ClipMask.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const computePosition = "return MAT_MVP * rawPos;";
const computeBaseColor = "return vec4(1.0);";
/** @internal */
function createClipMaskProgram(context) {
    const builder = new ShaderBuilder_1.ProgramBuilder();
    Vertex_1.addModelViewProjectionMatrix(builder.vert);
    builder.vert.set(4 /* ComputePosition */, computePosition);
    builder.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    builder.frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    return builder.buildProgram(context);
}
exports.createClipMaskProgram = createClipMaskProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/Clipping.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/glsl/Clipping.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const getClipPlaneFloat = `
  vec4 getClipPlane(int index) {
    float x = 0.5;
    float y = (float(index) + 0.5) / float(u_numClips);
    return TEXTURE(s_clipSampler, vec2(x, y));
  }
`;
const unpackFloat = `
  float unpackFloat(vec4 v) {
    const float bias = 38.0;
    v *= 255.0;
    float temp = v.w / 2.0;
    float exponent = floor(temp);
    float sign = (temp - exponent) * 2.0;
    exponent = exponent - bias;
    sign = -(sign * 2.0 - 1.0);
    float unpacked = sign * v.x * (1.0 / 256.0); // shift right 8
    unpacked += sign * v.y * (1.0 / 65536.0); // shift right 16
    unpacked += sign * v.z * (1.0 / 16777216.0); // shift right 24
    return unpacked * pow(10.0, exponent);
  }
`;
// ###TODO: oct-encode the normal to reduce # of samples from 4 to 2
const unpackClipPlane = `
  vec4 getClipPlane(int index) {
    float y = (float(index) + 0.5) / float(u_numClips);
    float sx = 0.25;
    vec2 tc = vec2(0.125, y);
    float nx = unpackFloat(TEXTURE(s_clipSampler, tc));
    tc.x += sx;
    float ny = unpackFloat(TEXTURE(s_clipSampler, tc));
    tc.x += sx;
    float nz = unpackFloat(TEXTURE(s_clipSampler, tc));
    tc.x += sx;
    float dist = unpackFloat(TEXTURE(s_clipSampler, tc));
    return vec4(nx, ny, nz, dist);
  }
`;
const calcClipPlaneDist = `
  float calcClipPlaneDist(vec4 camPos, vec4 plane) {
    return dot(camPos, plane);
  }
`;
const applyClipPlanes = `
  int numPlaneSets = 1;
  int numSetsClippedBy = 0;
  bool clippedByCurrentPlaneSet = false;
  for (int i = 0; i < MAX_CLIPPING_PLANES; i++)
      {
      if (i >= u_numClips)
          break;

      vec4 plane = getClipPlane(i);
      if (plane.xyz == vec3(0.0)) // indicates start of new clip plane set
          {
          numPlaneSets = numPlaneSets + 1;
          numSetsClippedBy += int(clippedByCurrentPlaneSet);
          clippedByCurrentPlaneSet = false;
          }
      else if (!clippedByCurrentPlaneSet && calcClipPlaneDist(v_eyeSpace, plane) < 0.0)
          clippedByCurrentPlaneSet = true;
      }

  numSetsClippedBy += int(clippedByCurrentPlaneSet);
  if (numSetsClippedBy == numPlaneSets)
      discard;
`;
const applyClipMask = `
  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);
  vec4 texel = TEXTURE(s_clipSampler, tc);
  if (texel.r < 0.5)
    discard;
`;
/** @internal */
function addClipping(prog, clipDef) {
    if (clipDef.type === 1 /* Mask */)
        addClippingMask(prog);
    else if (clipDef.type === 2 /* Planes */)
        addClippingPlanes(prog, clipDef.numberOfPlanes);
}
exports.addClipping = addClipping;
function addClippingPlanes(prog, maxClipPlanes) {
    bentleyjs_core_1.assert(maxClipPlanes > 0);
    const frag = prog.frag;
    const vert = prog.vert;
    Common_1.addEyeSpace(prog);
    prog.addUniform("u_numClips", 1 /* Int */, (program) => {
        program.addGraphicUniform("u_numClips", (uniform, params) => {
            const doClipping = true; // set to false to visualize pre-shader culling of geometry...
            const numClips = (doClipping && params.target.hasClipVolume) ? params.target.clips.count : 0;
            bentleyjs_core_1.assert(numClips > 0 || !doClipping);
            uniform.setUniform1i(numClips);
        });
    });
    Vertex_1.addModelViewMatrix(vert);
    if (System_1.System.instance.capabilities.supportsTextureFloat) {
        frag.addFunction(getClipPlaneFloat);
    }
    else {
        frag.addFunction(unpackFloat);
        frag.addFunction(unpackClipPlane);
    }
    frag.addFunction(calcClipPlaneDist);
    frag.maxClippingPlanes = maxClipPlanes;
    frag.addUniform("s_clipSampler", 8 /* Sampler2D */, (program) => {
        program.addGraphicUniform("s_clipSampler", (uniform, params) => {
            const texture = params.target.clips.texture;
            bentleyjs_core_1.assert(texture !== undefined);
            if (texture !== undefined)
                texture.bindSampler(uniform, RenderFlags_1.TextureUnit.ClipVolume);
        });
    }, 3 /* High */);
    frag.set(10 /* ApplyClipping */, applyClipPlanes);
}
function addClippingMask(prog) {
    prog.frag.addUniform("s_clipSampler", 8 /* Sampler2D */, (program) => {
        program.addGraphicUniform("s_clipSampler", (uniform, params) => {
            const texture = params.target.clipMask;
            bentleyjs_core_1.assert(texture !== undefined);
            if (texture !== undefined)
                texture.bindSampler(uniform, RenderFlags_1.TextureUnit.ClipVolume);
        });
    }, 3 /* High */);
    Fragment_1.addWindowToTexCoords(prog.frag);
    prog.frag.set(10 /* ApplyClipping */, applyClipMask);
}


/***/ }),

/***/ "./lib/render/webgl/glsl/Color.js":
/*!****************************************!*\
  !*** ./lib/render/webgl/glsl/Color.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Rendering */
Object.defineProperty(exports, "__esModule", { value: true });
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const RenderPass_1 = __webpack_require__(/*! ./RenderPass */ "./lib/render/webgl/glsl/RenderPass.js");
const Instancing_1 = __webpack_require__(/*! ./Instancing */ "./lib/render/webgl/glsl/Instancing.js");
// Vertex
// Color table is appended to vertex data. Compute the index of the vertex one-past-the-end of the vertex data
const computeElementColor = `
  float colorTableStart = u_vertParams.z * u_vertParams.w; // num rgba per-vertex times num vertices
  float colorIndex = decodeUInt16(g_vertexData2);
  vec2 tc = computeLUTCoords(colorTableStart+colorIndex, u_vertParams.xy, g_vert_center, 1.0);
  vec4 color = mix(u_color, TEXTURE(u_vertLUT, tc), extractShaderBit(kShaderBit_NonUniformColor));
`;
const computeBaseAlpha = `
  g_baseAlpha = color.a;
`;
// If in opaque pass, un-premultiply any alpha
const adjustAndReturnColor = `
  float inOpaquePass = float(kRenderPass_OpaqueLinear <= u_renderPass && kRenderPass_OpaqueGeneral >= u_renderPass);
  color = mix(color, adjustPreMultipliedAlpha(color, 1.0), inOpaquePass);
  return color;
`;
const applyInstanceColor = `
  color.rgb /= max(0.0001, color.a); // revert pre-multiplied alpha
  color.rgb = mix(color.rgb, a_instanceRgba.rgb / 255.0, extractInstanceBit(kOvrBit_Rgb));
  color.a = mix(color.a, a_instanceRgba.a / 255.0, extractInstanceBit(kOvrBit_Alpha));
  color.rgb *= color.a; // pre-multiply alpha
`;
const computeInstancedElementColor = computeElementColor + applyInstanceColor;
const computeColor = computeElementColor + adjustAndReturnColor;
const computeInstancedColor = computeInstancedElementColor + adjustAndReturnColor;
const computeSurfaceColor = computeElementColor + computeBaseAlpha + adjustAndReturnColor;
const computeInstancedSurfaceColor = computeInstancedElementColor + computeBaseAlpha + adjustAndReturnColor;
function getComputeColor(vert, forwardBaseAlpha) {
    if (vert.usesInstancedGeometry) {
        Instancing_1.addInstanceColor(vert);
        return forwardBaseAlpha ? computeInstancedSurfaceColor : computeInstancedColor;
    }
    else {
        return forwardBaseAlpha ? computeSurfaceColor : computeColor;
    }
}
// Fragment
const computeBaseColor = "return v_color;";
/** @internal */
function addColor(builder, forwardBaseAlpha = false) {
    // ShaderSource::AddRenderPass
    builder.vert.addUniform("u_color", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_color", (uniform, params) => {
            const lutGeom = params.geometry.asLUT;
            const color = lutGeom.getColor(params.target);
            if (color.isUniform) {
                color.uniform.bind(uniform);
            }
        });
    });
    builder.vert.addFunction(Fragment_1.GLSLFragment.adjustPreMultipliedAlpha);
    if (forwardBaseAlpha)
        builder.addGlobal("g_baseAlpha", 2 /* Float */);
    RenderPass_1.addRenderPass(builder.vert);
    builder.addFunctionComputedVarying("v_color", 5 /* Vec4 */, "computeColor", getComputeColor(builder.vert, forwardBaseAlpha));
    builder.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
}
exports.addColor = addColor;


/***/ }),

/***/ "./lib/render/webgl/glsl/CombineTextures.js":
/*!**************************************************!*\
  !*** ./lib/render/webgl/glsl/CombineTextures.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Texture_1 = __webpack_require__(/*! ../Texture */ "./lib/render/webgl/Texture.js");
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const computeBaseColor = "return vec4(1.0);";
const assignFragData = `
  if (v_texCoord.y < .5)
   FragColor0 = TEXTURE(u_texture0, vec2(v_texCoord.x, v_texCoord.y * 2.0));
  else
   FragColor0 = TEXTURE(u_texture1, vec2(v_texCoord.x, v_texCoord.y * 2.0 - 1.0));
`;
/** @internal */
function createCombineTexturesProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    frag.addUniform("u_texture0", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_texture0", (uniform, params) => {
            Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.texture0, RenderFlags_1.TextureUnit.Zero);
        });
    }, 3 /* High */);
    frag.addUniform("u_texture1", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_texture1", (uniform, params) => {
            Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.texture1, RenderFlags_1.TextureUnit.One);
        });
    }, 3 /* High */);
    frag.addDrawBuffersExtension();
    frag.set(15 /* AssignFragData */, assignFragData);
    return builder.buildProgram(context);
}
exports.createCombineTexturesProgram = createCombineTexturesProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/Common.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/glsl/Common.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const extractShaderBit = `
  float extractShaderBit(float flag) { return extractNthBit(floor(u_shaderFlags + 0.5), flag); }
`;
const isShaderBitSet = `
bool isShaderBitSet(float flag) { return 0.0 != extractShaderBit(flag); }
`;
function addShaderFlagsLookup(shader) {
    shader.addConstant("kShaderBit_Monochrome", 2 /* Float */, "0.0");
    shader.addConstant("kShaderBit_NonUniformColor", 2 /* Float */, "1.0");
    shader.addConstant("kShaderBit_OITFlatAlphaWeight", 2 /* Float */, "2.0");
    shader.addConstant("kShaderBit_OITScaleOutput", 2 /* Float */, "3.0");
    shader.addConstant("kShaderBit_IgnoreNonLocatable", 2 /* Float */, "4.0");
    shader.addFunction(GLSLCommon.extractNthBit);
    shader.addFunction(extractShaderBit);
    shader.addFunction(isShaderBitSet);
}
/** @internal */
function addViewMatrix(vert) {
    vert.addUniform("u_viewMatrix", 7 /* Mat4 */, (prog) => {
        prog.addGraphicUniform("u_viewMatrix", (uniform, params) => {
            uniform.setMatrix4(params.viewMatrix);
        });
    });
}
exports.addViewMatrix = addViewMatrix;
function setShaderFlags(uniform, params) {
    bentleyjs_core_1.assert(params.geometry.asLUT !== undefined);
    const geom = params.geometry.asLUT;
    let flags = params.target.currentShaderFlags;
    const color = geom.getColor(params.target);
    if (color.isNonUniform)
        flags |= 2 /* NonUniformColor */;
    // Certain textures render in the translucent pass but we actually want to maintain true opacity for opaque pixels.
    // For these, use a constant Z to calculate alpha weight.  Otherwise, the opaque things in the texture are weighted by their Z due
    // to the nature of the OIT algorithm.  In this case, we set OITFlatAlphaWeight.
    // Since RGBA8 rendering is very low precision, if we are using that kind of output, we also want to flatten alpha weight.
    // Otherwise, the very tiny Z range makes things fade to black as the precision limit is encountered.  This workaround disregards Z
    // in calculating the color, so it means that transparency is less accurate based on Z-ordering, but it is the best we can do with
    // this algorithm on low-end hardware.
    // Finally, the application can put the viewport into "fadeout mode", which explicitly enables flat alpha weight in order to de-emphasize transparent geometry.
    const maxRenderType = System_1.System.instance.capabilities.maxRenderType;
    let flatAlphaWeight = 0 /* TextureUnsignedByte */ === maxRenderType || params.target.isFadeOutActive;
    if (!flatAlphaWeight) {
        const surface = params.geometry.asSurface;
        flatAlphaWeight = undefined !== surface && (surface.isGlyph || surface.isTileSection);
    }
    if (flatAlphaWeight)
        flags |= 4 /* OITFlatAlphaWeight */;
    // If Cesium-style transparency is being used with non-float texture targets, we must scale the output in the shaders to 0-1 range.
    // Otherwise, it will get implicitly clamped to that range and we'll lose any semblance our desired precision (even though it is low).
    if (maxRenderType < 1 /* TextureHalfFloat */)
        flags |= 8 /* OITScaleOutput */;
    if (!params.target.drawNonLocatable)
        flags |= 16 /* IgnoreNonLocatable */;
    uniform.setUniform1f(flags);
}
/** @internal */
function addShaderFlags(builder) {
    addShaderFlagsLookup(builder.vert);
    addShaderFlagsLookup(builder.frag);
    builder.addUniform("u_shaderFlags", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_shaderFlags", (uniform, params) => { setShaderFlags(uniform, params); });
    });
}
exports.addShaderFlags = addShaderFlags;
/** @internal */
function addFrustum(builder) {
    builder.addUniform("u_frustum", 4 /* Vec3 */, (prog) => {
        prog.addProgramUniform("u_frustum", (uniform, params) => {
            uniform.setUniform3fv(params.target.frustumUniforms.frustum);
        });
    });
    builder.addGlobal("kFrustumType_Ortho2d", 2 /* Float */, 3 /* Both */, "0.0", true);
    builder.addGlobal("kFrustumType_Ortho3d", 2 /* Float */, 3 /* Both */, "1.0", true);
    builder.addGlobal("kFrustumType_Perspective", 2 /* Float */, 3 /* Both */, "2.0", true);
}
exports.addFrustum = addFrustum;
const computeEyeSpace = "v_eyeSpace = (MAT_MV * rawPosition);";
/** @internal */
function addEyeSpace(builder) {
    builder.addInlineComputedVarying("v_eyeSpace", 5 /* Vec4 */, computeEyeSpace);
}
exports.addEyeSpace = addEyeSpace;
/** @internal */
exports.addUInt32s = `
  vec4 addUInt32s(vec4 a, vec4 b)
      {
      vec4 c = a + b;
      if (c.x > 255.0) { c.x -= 256.0; c.y += 1.0; }
      if (c.y > 255.0) { c.y -= 256.0; c.z += 1.0; }
      if (c.z > 255.0) { c.z -= 256.0; c.w += 1.0; }
      return c;
      }
`;
/** @internal */
var GLSLCommon;
(function (GLSLCommon) {
    // Expects flags in range [0...256] with no fraction; and bit is [0..31] with no fraction.
    // Returns 1.0 if the nth bit is set, 0.0 otherwise.
    // dividing flags by 2^(n+1) yields #.5##... if the nth bit is set, #.0##... otherwise
    // Taking the fractional part yields 0.5##...
    // Multiplying by 2.0 and taking the floor yields 1.0 or 0.0
    GLSLCommon.extractNthBit = `
float extractNthBit(float flags, float n) {
  float denom = pow(2.0, n+1.0);
  return floor(fract(flags/denom)*2.0);
}
`;
})(GLSLCommon = exports.GLSLCommon || (exports.GLSLCommon = {}));


/***/ }),

/***/ "./lib/render/webgl/glsl/Composite.js":
/*!********************************************!*\
  !*** ./lib/render/webgl/glsl/Composite.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Texture_1 = __webpack_require__(/*! ../Texture */ "./lib/render/webgl/Texture.js");
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./FeatureSymbology */ "./lib/render/webgl/glsl/FeatureSymbology.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const isEdgePixel = `
bool isEdgePixel(float xOffset, float yOffset) {
  vec2 t = windowCoordsToTexCoords(gl_FragCoord.xy + vec2(xOffset, yOffset));
  vec4 texel = TEXTURE(u_hilite, t);
  return 0.0 != texel.r;
}
`;
const isOutlined = `
bool isOutlined() {
  float width = u_hilite_settings.z;
  if (0.0 == width)
    return false;

  // 1-pixel-wide outline requires max 9 samples. 2-pixel-wide requires max 25 samples.
  if (isEdgePixel(0.0, 1.0) || isEdgePixel(1.0, 0.0) || isEdgePixel(1.0, 1.0)
      || isEdgePixel(0.0, -1.0) || isEdgePixel(-1.0, 0.0) || isEdgePixel(-1.0, -1.0)
      || isEdgePixel(1.0, -1.0) || isEdgePixel(-1.0, 1.0))
    return true;

  if (1.0 == width)
    return false;

  return isEdgePixel(-2.0, -2.0) || isEdgePixel(-1.0, -2.0) || isEdgePixel(0.0, -2.0) || isEdgePixel(1.0, -2.0) || isEdgePixel(2.0, -2.0)
    || isEdgePixel(-2.0, -1.0) || isEdgePixel(2.0, -1.0)
    || isEdgePixel(-2.0, 0.0) || isEdgePixel(2.0, 0.0)
    || isEdgePixel(-2.0, 1.0) || isEdgePixel(2.0, 1.0)
    || isEdgePixel(-2.0, 2.0) || isEdgePixel(-1.0, 2.0) || isEdgePixel(0.0, 2.0) || isEdgePixel(1.0, 2.0) || isEdgePixel(2.0, 2.0);
}
`;
const computeOpaqueColor = `
vec4 computeOpaqueColor() {
  vec4 opaque = TEXTURE(u_opaque, v_texCoord);
  opaque.rgb *= computeAmbientOcclusion();
  return opaque;
}
`;
const computeDefaultAmbientOcclusion = `\nfloat computeAmbientOcclusion() { return 1.0; }\n`;
const computeAmbientOcclusion = `\nfloat computeAmbientOcclusion() { return TEXTURE(u_occlusion, v_texCoord).r; }\n`;
const computeHiliteColor = "\nvec4 computeColor() { return computeOpaqueColor(); }\n";
const computeHiliteBaseColor = `
  float isHilite = floor(TEXTURE(u_hilite, v_texCoord).r + 0.5);
  float ratio = u_hilite_settings.y * isHilite;
  vec4 baseColor = computeColor();
  baseColor.rgb = mix(baseColor.rgb, u_hilite_color.rgb, ratio);
  // If outlined, use hilite color for boundaries, else use base color, mixed with hilite color if inside hilite region.
  return mix(vec4(u_hilite_color.rgb, 1.0), baseColor, max(isHilite, 1.0 - float(isOutlined())));
`;
const computeTranslucentColor = `
vec4 computeColor() {
  vec4 opaque = computeOpaqueColor();
  vec4 accum = TEXTURE(u_accumulation, v_texCoord);
  float r = TEXTURE(u_revealage, v_texCoord).r;

  vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);
  vec4 col = (1.0 - transparent.a) * transparent + transparent.a * opaque;
  return col;
}
`;
const computeTranslucentBaseColor = "return computeColor();";
const computeAmbientOcclusionBaseColor = `\nreturn computeOpaqueColor();\n`;
/** @internal */
function createCompositeProgram(flags, context) {
    bentleyjs_core_1.assert(0 /* None */ !== flags);
    const wantHilite = 0 /* None */ !== (flags & 2 /* Hilite */);
    const wantTranslucent = 0 /* None */ !== (flags & 1 /* Translucent */);
    const wantOcclusion = 0 /* None */ !== (flags & 4 /* AmbientOcclusion */);
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    frag.addFunction(wantOcclusion ? computeAmbientOcclusion : computeDefaultAmbientOcclusion);
    frag.addFunction(computeOpaqueColor);
    frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    frag.addUniform("u_opaque", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_opaque", (uniform, params) => {
            Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.opaque, RenderFlags_1.TextureUnit.Zero);
        });
    });
    if (wantHilite) {
        FeatureSymbology_1.addHiliteSettings(frag);
        Fragment_1.addWindowToTexCoords(frag);
        frag.addFunction(isEdgePixel);
        frag.addFunction(isOutlined);
        frag.addUniform("u_hilite", 8 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_hilite", (uniform, params) => {
                Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.hilite, RenderFlags_1.TextureUnit.Three);
            });
        });
        frag.set(1 /* ComputeBaseColor */, computeHiliteBaseColor);
        if (!wantTranslucent) {
            frag.addFunction(computeHiliteColor);
        }
    }
    if (wantTranslucent) {
        frag.addUniform("u_accumulation", 8 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_accumulation", (uniform, params) => {
                Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.accum, RenderFlags_1.TextureUnit.One);
            });
        });
        frag.addUniform("u_revealage", 8 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_revealage", (uniform, params) => {
                Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.reveal, RenderFlags_1.TextureUnit.Two);
            });
        });
        frag.addFunction(computeTranslucentColor);
        if (!wantHilite) {
            frag.set(1 /* ComputeBaseColor */, computeTranslucentBaseColor);
        }
    }
    if (wantOcclusion) {
        frag.addUniform("u_occlusion", 8 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_occlusion", (uniform, params) => {
                Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.occlusion, RenderFlags_1.TextureUnit.Four);
            });
        });
        if (!wantHilite && !wantTranslucent)
            frag.set(1 /* ComputeBaseColor */, computeAmbientOcclusionBaseColor);
    }
    return builder.buildProgram(context);
}
exports.createCompositeProgram = createCompositeProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/CopyColor.js":
/*!********************************************!*\
  !*** ./lib/render/webgl/glsl/CopyColor.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Texture_1 = __webpack_require__(/*! ../Texture */ "./lib/render/webgl/Texture.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const computeColor = "return TEXTURE(u_color, v_texCoord);";
const computeColorNoAlpha = "return vec4(TEXTURE(u_color, v_texCoord).rgb, 1.0);";
/** @internal */
function createCopyColorProgram(context, copyAlpha = true) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    frag.set(1 /* ComputeBaseColor */, copyAlpha ? computeColor : computeColorNoAlpha);
    frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    frag.addUniform("u_color", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_color", (uniform, params) => {
            const geom = params.geometry;
            Texture_1.Texture2DHandle.bindSampler(uniform, geom.texture, RenderFlags_1.TextureUnit.Zero);
        });
    });
    return builder.buildProgram(context);
}
exports.createCopyColorProgram = createCopyColorProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/CopyPickBuffers.js":
/*!**************************************************!*\
  !*** ./lib/render/webgl/glsl/CopyPickBuffers.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Texture_1 = __webpack_require__(/*! ../Texture */ "./lib/render/webgl/Texture.js");
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const computeBaseColor = "return vec4(1.0);";
const assignFragData = `
  FragColor0 = TEXTURE(u_pickFeatureId, v_texCoord);
  FragColor1 = TEXTURE(u_pickDepthAndOrder, v_texCoord);
`;
/** @internal */
function createCopyPickBuffersProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    if (System_1.System.instance.capabilities.maxColorAttachments < 3) {
        // NB: Never used - we gl.clear() each attachment directly.
        frag.set(15 /* AssignFragData */, "FragColor = vec4(0.0);");
    }
    else {
        frag.addUniform("u_pickFeatureId", 8 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_pickFeatureId", (uniform, params) => {
                Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.featureId, RenderFlags_1.TextureUnit.Zero);
            });
        }, 3 /* High */);
        frag.addUniform("u_pickDepthAndOrder", 8 /* Sampler2D */, (prog) => {
            prog.addGraphicUniform("u_pickDepthAndOrder", (uniform, params) => {
                Texture_1.Texture2DHandle.bindSampler(uniform, params.geometry.depthAndOrder, RenderFlags_1.TextureUnit.One);
            });
        }, 3 /* High */);
        frag.addDrawBuffersExtension();
        frag.set(15 /* AssignFragData */, assignFragData);
    }
    return builder.buildProgram(context);
}
exports.createCopyPickBuffersProgram = createCopyPickBuffersProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/CopyStencil.js":
/*!**********************************************!*\
  !*** ./lib/render/webgl/glsl/CopyStencil.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const FloatRGBA_1 = __webpack_require__(/*! ../FloatRGBA */ "./lib/render/webgl/FloatRGBA.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const computeColor = "return vec4(u_hilite_color.rgb, 1.0);";
const scratchHiliteColor = FloatRGBA_1.MutableFloatRgba.fromColorDef(imodeljs_common_1.ColorDef.white);
/** @internal */
function createCopyStencilProgram(context) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(true);
    const frag = builder.frag;
    frag.set(1 /* ComputeBaseColor */, computeColor);
    frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    frag.addUniform("u_hilite_color", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_hilite_color", (uniform, params) => {
            const vf = params.target.currentViewFlags;
            const useLighting = params.geometry.wantMixHiliteColorForFlash(vf, params.target);
            const hiliteColor = params.target.hiliteColor;
            scratchHiliteColor.setRgbaValues(hiliteColor.red, hiliteColor.green, hiliteColor.blue, useLighting ? 1.0 : 0.0);
            scratchHiliteColor.bind(uniform);
        });
    });
    return builder.buildProgram(context);
}
exports.createCopyStencilProgram = createCopyStencilProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/Decode.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/glsl/Decode.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
/** GLSLDecode
 * @internal
 */
var GLSLDecode;
(function (GLSLDecode) {
    GLSLDecode.uint16 = `
float decodeUInt16(vec2 v) {
  v = v * vec2(1.0, 256.0); // v.y <<= 8
  return dot(v, vec2(1.0)); // v.x+v.y => v.x | v.y
}
`;
    GLSLDecode.uint32 = `
float decodeUInt32(vec3 v) {
  v = v * vec3(1.0, 256.0, 256.0*256.0); // v.y <<= 8; v.z <<= 16
  return dot(v, vec3(1.0)); // v.x+v.y+v.z => v.x | v.y | v.z
}
`;
    GLSLDecode.unquantize3d = `
vec3 unquantize3d(vec3 qpos, vec3 origin, vec3 scale) { return origin + scale * qpos; }
`;
    GLSLDecode.unquantize2d = `
// params.xy = origin. params.zw = scale.
vec2 unquantize2d(vec2 qpos, vec4 params) { return params.xy + params.zw * qpos; }
`;
    GLSLDecode.depthRgb = `
float decodeDepthRgb(vec3 rgb) { return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0)); }
`;
    GLSLDecode.encodeDepthRgb = `
vec3 encodeDepthRgb(float depth) {
  // 1.0 must be reduced slightly; otherwise decoding will produce zero. It's the far plane, so we don't care (and decoding produces 1.0 anyway).
  depth = min(depth, 16777215.0/16777216.0);

  vec3 enc = vec3(1.0, 255.0, 65025.0) * depth;
  enc = fract(enc);
  enc.xy -= enc.yz / 255.0;
  return enc;
}
`;
})(GLSLDecode = exports.GLSLDecode || (exports.GLSLDecode = {}));


/***/ }),

/***/ "./lib/render/webgl/glsl/Edge.js":
/*!***************************************!*\
  !*** ./lib/render/webgl/glsl/Edge.js ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Animation_1 = __webpack_require__(/*! ./Animation */ "./lib/render/webgl/glsl/Animation.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/render/webgl/glsl/Viewport.js");
const GL_1 = __webpack_require__(/*! ../GL */ "./lib/render/webgl/GL.js");
const Color_1 = __webpack_require__(/*! ./Color */ "./lib/render/webgl/glsl/Color.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const Polyline_1 = __webpack_require__(/*! ./Polyline */ "./lib/render/webgl/glsl/Polyline.js");
const Surface_1 = __webpack_require__(/*! ./Surface */ "./lib/render/webgl/glsl/Surface.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const decodeEndPointAndQuadIndices = `
  g_otherIndex = decodeUInt32(a_endPointAndQuadIndices.xyz);
  vec2 tc = computeLUTCoords(g_otherIndex, u_vertParams.xy, g_vert_center, u_vertParams.z);
  vec4 enc1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  tc.x += g_vert_stepX;
  vec4 enc2 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  vec3 qpos = vec3(decodeUInt16(enc1.xy), decodeUInt16(enc1.zw), decodeUInt16(enc2.xy));
  g_otherPos = unquantizePosition(qpos, u_qOrigin, u_qScale);
  g_quadIndex = a_endPointAndQuadIndices.w;
`;
const animateEndPoint = `g_otherPos.xyz += computeAnimationDisplacement(g_otherIndex, u_animDispParams.x, u_animDispParams.y, u_animDispParams.z, u_qAnimDispOrigin, u_qAnimDispScale);
`;
const checkForSilhouetteDiscard = `
  vec3 n0 = MAT_NORM * octDecodeNormal(a_normals.xy);
  vec3 n1 = MAT_NORM * octDecodeNormal(a_normals.zw);

  if (0.0 == MAT_MVP[0].w) {
    return n0.z * n1.z > 0.0;           // orthographic.
  } else {
    vec4  viewPos = MAT_MV * rawPos;     // perspective
    vec3  toEye = normalize(viewPos.xyz);
    float dot0 = dot(n0, toEye);
    float dot1 = dot(n1, toEye);

    if (dot0 * dot1 > 0.0)
      return true;

    // Need to discard if either is non-silhouette.
    vec4 otherPosition = g_otherPos;
    viewPos = MAT_MV * otherPosition;
    toEye = normalize(viewPos.xyz);
    dot0 = dot(n0, toEye);
    dot1 = dot(n1, toEye);

    return dot0 * dot1 > 0.0;
  }
`;
const computePosition = `
  v_lnInfo = vec4(0.0, 0.0, 0.0, 0.0);  // init and set flag to false
  vec4  pos = MAT_MVP * rawPos;
  vec4  other = g_otherPos;
  vec3  modelDir = other.xyz - pos.xyz;
  float miterAdjust = 0.0;
  float weight = computeLineWeight();

  g_windowPos = modelToWindowCoordinates(rawPos, other);

  if (g_windowPos.w == 0.0) // Clipped out.
    return g_windowPos;

  vec4 projOther = modelToWindowCoordinates(other, rawPos);

  g_windowDir = projOther.xy - g_windowPos.xy;

  adjustWidth(weight, g_windowDir, g_windowPos.xy);
  g_windowDir = normalize(g_windowDir);

  vec2  perp = vec2(-g_windowDir.y, g_windowDir.x);
  float perpDist = weight / 2.0;
  float alongDist = 0.0;

  perpDist *= sign(0.5 - float(g_quadIndex == 0.0 || g_quadIndex == 3.0)); // negate for index 0 and 3
  alongDist += distance(rawPos, other) * float(g_quadIndex >= 2.0); // index 2 and 3 correspond to 'far' endpoint of segment

  pos.x += perp.x * perpDist * 2.0 * pos.w / u_viewport.z;
  pos.y += perp.y * perpDist * 2.0 * pos.w / u_viewport.w;

  lineCodeEyePos = .5 * (rawPos + other);
  lineCodeDist = alongDist;

  return pos;
`;
const lineCodeArgs = "g_windowDir, g_windowPos, 0.0";
function createBase(isSilhouette, instanced, isAnimated) {
    const builder = new ShaderBuilder_1.ProgramBuilder(instanced ? 3 /* InstancedVertexTable */ : 1 /* VertexTable */);
    const vert = builder.vert;
    vert.addGlobal("g_otherPos", 5 /* Vec4 */);
    vert.addGlobal("g_quadIndex", 2 /* Float */);
    vert.addGlobal("g_windowPos", 5 /* Vec4 */);
    vert.addGlobal("g_windowDir", 3 /* Vec2 */);
    vert.addGlobal("g_otherIndex", 2 /* Float */);
    vert.addInitializer(decodeEndPointAndQuadIndices);
    if (isAnimated) {
        Animation_1.addAnimation(vert, false);
        vert.addInitializer(animateEndPoint);
    }
    vert.addGlobal("lineCodeEyePos", 5 /* Vec4 */);
    vert.addGlobal("lineCodeDist", 2 /* Float */, "0.0");
    Viewport_1.addModelToWindowCoordinates(vert); // adds u_mvp, u_viewportTransformation
    Vertex_1.addProjectionMatrix(vert);
    Polyline_1.addLineCode(builder, lineCodeArgs);
    vert.set(4 /* ComputePosition */, computePosition);
    builder.addVarying("v_lnInfo", 5 /* Vec4 */);
    vert.addFunction(Polyline_1.adjustWidth);
    Viewport_1.addViewport(vert);
    Vertex_1.addModelViewMatrix(vert);
    vert.addAttribute("a_endPointAndQuadIndices", 5 /* Vec4 */, (shaderProg) => {
        shaderProg.addAttribute("a_endPointAndQuadIndices", (attr, params) => {
            const geom = params.geometry;
            bentleyjs_core_1.assert(undefined !== geom.asEdge);
            const edgeGeom = geom.asEdge;
            attr.enableArray(edgeGeom.endPointAndQuadIndices, 4, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
        });
    });
    Vertex_1.addLineWeight(vert);
    if (isSilhouette) {
        Vertex_1.addNormalMatrix(vert);
        vert.set(1 /* CheckForEarlyDiscard */, checkForSilhouetteDiscard);
        vert.addFunction(Surface_1.octDecodeNormal);
        vert.addAttribute("a_normals", 5 /* Vec4 */, (shaderProg) => {
            shaderProg.addAttribute("a_normals", (attr, params) => {
                const geom = params.geometry;
                bentleyjs_core_1.assert(undefined !== geom.asSilhouette);
                const silhouetteGeom = geom.asSilhouette;
                attr.enableArray(silhouetteGeom.normalPairs, 4, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
            });
        });
    }
    return builder;
}
/** @internal */
function createEdgeBuilder(isSilhouette, instanced, isAnimated) {
    const builder = createBase(isSilhouette, instanced, isAnimated);
    Common_1.addShaderFlags(builder);
    Color_1.addColor(builder);
    Fragment_1.addWhiteOnWhiteReversal(builder.frag);
    return builder;
}
exports.createEdgeBuilder = createEdgeBuilder;


/***/ }),

/***/ "./lib/render/webgl/glsl/FeatureSymbology.js":
/*!***************************************************!*\
  !*** ./lib/render/webgl/glsl/FeatureSymbology.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const Decode_1 = __webpack_require__(/*! ./Decode */ "./lib/render/webgl/glsl/Decode.js");
const LookupTable_1 = __webpack_require__(/*! ./LookupTable */ "./lib/render/webgl/glsl/LookupTable.js");
const RenderPass_1 = __webpack_require__(/*! ./RenderPass */ "./lib/render/webgl/glsl/RenderPass.js");
const GL_1 = __webpack_require__(/*! ../GL */ "./lib/render/webgl/GL.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const FloatRGBA_1 = __webpack_require__(/*! ../FloatRGBA */ "./lib/render/webgl/FloatRGBA.js");
/** @internal */
function addOvrFlagConstants(builder) {
    // NB: These are the bit positions of each flag in OvrFlags enum - not the flag values
    builder.addConstant("kOvrBit_Visibility", 2 /* Float */, "0.0");
    builder.addConstant("kOvrBit_Rgb", 2 /* Float */, "1.0");
    builder.addConstant("kOvrBit_Alpha", 2 /* Float */, "2.0");
    builder.addConstant("kOvrBit_Weight", 2 /* Float */, "3.0");
    builder.addConstant("kOvrBit_Flashed", 2 /* Float */, "4.0");
    builder.addConstant("kOvrBit_Hilited", 2 /* Float */, "5.0");
    builder.addConstant("kOvrBit_LineCode", 2 /* Float */, "6.0");
    builder.addConstant("kOvrBit_IgnoreMaterial", 2 /* Float */, "7.0");
}
exports.addOvrFlagConstants = addOvrFlagConstants;
const computeLUTFeatureIndex = `floor(TEXTURE(u_vertLUT, g_featureIndexCoords) * 255.0 + 0.5)`;
const computeInstanceFeatureIndex = `vec4(a_featureId, 0.0)`;
function computeFeatureIndex(instanced) {
    return `g_featureIndex = ` + (instanced ? computeInstanceFeatureIndex : computeLUTFeatureIndex) + `;`;
}
function getFeatureIndex(instanced) {
    return `
  float getFeatureIndex() {
    g_featureIndex = ` + computeFeatureIndex(instanced) + `;
    return decodeUInt32(g_featureIndex.xyz);
  }`;
}
// Returns 1.0 if the specified flag is not globally overridden and is set in flags
const extractNthFeatureBit = `
float extractNthFeatureBit(float flags, float n) {
  return (1.0 - extractNthBit(u_globalOvrFlags, n)) * extractNthBit(flags, n);
}
`;
const computeFeatureTextureCoords = `
vec2 computeFeatureTextureCoords() { return compute_feature_coords(getFeatureIndex()); }
`;
const getFirstFeatureRgba = `
vec4 getFirstFeatureRgba() {
  feature_texCoord = computeFeatureTextureCoords();
  return TEXTURE(u_featureLUT, feature_texCoord);
}
`;
const getSecondFeatureRgba = `
vec4 getSecondFeatureRgba() {
  vec2 coord = feature_texCoord;
  coord.x += g_feature_stepX;
  return TEXTURE(u_featureLUT, coord);
}
`;
const computeLineWeight = `
float computeLineWeight() {
  return mix(g_lineWeight, linear_feature_overrides.y, linear_feature_overrides.x);
}
`;
const computeLineCode = `
float computeLineCode() {
  return mix(g_lineCode, linear_feature_overrides.w, linear_feature_overrides.z);
}
`;
function addFeatureIndex(vert) {
    vert.addGlobal("g_featureIndex", 5 /* Vec4 */);
    vert.addFunction(getFeatureIndex(vert.usesInstancedGeometry));
    if (vert.usesInstancedGeometry) {
        vert.addAttribute("a_featureId", 4 /* Vec3 */, (prog) => {
            prog.addAttribute("a_featureId", (attr, params) => {
                const geom = params.geometry.asInstanced;
                bentleyjs_core_1.assert(undefined !== geom);
                bentleyjs_core_1.assert(undefined !== geom.featureIds, "Cannot use feature shaders if no features");
                if (undefined !== geom.featureIds)
                    attr.enableArray(geom.featureIds, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0, true);
            });
        });
    }
}
// Discards vertex if feature is invisible; or rendering opaque during translucent pass or vice-versa
// (The latter occurs when some translucent feature is overridden to be opaque, or vice-versa)
const checkVertexDiscard = `
  if (feature_invisible)
    return true;

  bool hasAlpha = 1.0 == u_hasAlpha;
  if (v_feature_alpha_flashed.x > 0.0) {
    const float s_minTransparency = 15.0; // NB: See DisplayParams.getMinTransparency() - this must match!
    const float s_maxAlpha = (255.0 - s_minTransparency) / 255.0;
    hasAlpha = v_feature_alpha_flashed.x < s_maxAlpha;
  }

  bool isOpaquePass = (kRenderPass_OpaqueLinear <= u_renderPass && kRenderPass_OpaqueGeneral >= u_renderPass);
  bool isTranslucentPass = kRenderPass_Translucent == u_renderPass;
  return (isOpaquePass && hasAlpha) || (isTranslucentPass && !hasAlpha);
`;
function addCommon(builder, mode, opts) {
    if (0 /* None */ === mode)
        return false;
    const vert = builder.vert;
    addFeatureIndex(vert);
    const haveOverrides = 0 /* None */ !== (opts & 4 /* HasOverrides */);
    if (!haveOverrides) {
        // For pick output we must compute g_featureIndex...
        if (1 /* Pick */ === mode)
            vert.set(2 /* ComputeFeatureOverrides */, computeFeatureIndex(vert.usesInstancedGeometry));
        return true;
    }
    const wantWeight = 0 /* None */ !== (opts & 1 /* Weight */);
    const wantLineCode = 0 /* None */ !== (opts & 2 /* LineCode */);
    const wantColor = 0 /* None */ !== (opts & 8 /* Color */);
    const wantAlpha = 0 /* None */ !== (opts & 16 /* Alpha */);
    bentleyjs_core_1.assert(wantColor || !wantAlpha);
    vert.addGlobal("feature_invisible", 0 /* Boolean */, "false");
    vert.addFunction(Common_1.GLSLCommon.extractNthBit);
    addOvrFlagConstants(vert);
    vert.addGlobal("linear_feature_overrides", 5 /* Vec4 */, "vec4(0.0)");
    vert.addGlobal("feature_ignore_material", 0 /* Boolean */, "false");
    vert.addFunction(extractNthFeatureBit);
    if (wantWeight || wantLineCode) {
        if (wantLineCode)
            Vertex_1.replaceLineCode(vert, computeLineCode);
        if (wantWeight) {
            Vertex_1.replaceLineWeight(vert, computeLineWeight);
            vert.addUniform("u_globalOvrFlags", 2 /* Float */, (prog) => {
                prog.addGraphicUniform("u_globalOvrFlags", (uniform, params) => {
                    let flags = 0.0;
                    if (params.geometry.isEdge) {
                        const edgeOvrs = params.target.getEdgeOverrides(params.renderPass);
                        if (undefined !== edgeOvrs)
                            flags = edgeOvrs.computeOvrFlags();
                    }
                    uniform.setUniform1f(flags);
                });
            });
        }
    }
    else {
        vert.addUniform("u_globalOvrFlags", 2 /* Float */, (prog) => {
            prog.addGraphicUniform("u_globalOvrFlags", (uniform, params) => {
                // If transparency view flag is off, do not allow features to override transparency.
                // This is particularly important for Target.readPixels(), which draws everything opaque - otherwise we cannot locate elements with transparent overrides.
                const flags = params.target.currentViewFlags.transparency ? 0.0 : 4 /* Alpha */;
                uniform.setUniform1f(flags);
            });
        });
    }
    LookupTable_1.addLookupTable(vert, "feature", "2.0");
    vert.addGlobal("feature_texCoord", 3 /* Vec2 */);
    vert.addFunction(computeFeatureTextureCoords);
    vert.addFunction(getFirstFeatureRgba);
    vert.addUniform("u_featureLUT", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_featureLUT", (uniform, params) => {
            const ovr = params.target.currentOverrides;
            bentleyjs_core_1.assert(undefined !== ovr);
            ovr.lut.bindSampler(uniform, RenderFlags_1.TextureUnit.FeatureSymbology);
        });
    });
    vert.addUniform("u_featureParams", 3 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("u_featureParams", (uniform, params) => {
            const ovr = params.target.currentOverrides;
            uniform.setUniform2fv([ovr.lut.width, ovr.lut.height]);
        });
    });
    if (wantColor) {
        vert.addFunction(getSecondFeatureRgba);
        if (wantAlpha) {
            Vertex_1.addAlpha(vert);
            vert.set(3 /* CheckForDiscard */, checkVertexDiscard);
        }
    }
    return true;
}
const scratchHiliteColor = FloatRGBA_1.MutableFloatRgba.fromColorDef(imodeljs_common_1.ColorDef.white);
/** @internal */
function addHiliteSettings(frag) {
    frag.addUniform("u_hilite_color", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_hilite_color", (uniform, params) => {
            const vf = params.target.currentViewFlags;
            const useLighting = params.geometry.wantMixHiliteColorForFlash(vf, params.target);
            const hiliteColor = params.target.hiliteColor;
            scratchHiliteColor.setRgbaValues(hiliteColor.red, hiliteColor.green, hiliteColor.blue, useLighting ? 1.0 : 0.0);
            scratchHiliteColor.bind(uniform);
        });
    });
    frag.addUniform("u_hilite_settings", 4 /* Vec3 */, (prog) => {
        prog.addProgramUniform("u_hilite_settings", (uniform, params) => {
            const hilite = params.target.hiliteSettings;
            let silhouette = 2.0;
            switch (hilite.silhouette) {
                case imodeljs_common_1.Hilite.Silhouette.None:
                    silhouette = 0.0;
                    break;
                case imodeljs_common_1.Hilite.Silhouette.Thin:
                    silhouette = 1.0;
                    break;
            }
            // During the normal pass (with depth testing), we mix the hilite color with the element color.
            // During the compositing pass, we mix the hilite color with the fragment color.
            // We have no idea if we're hiliting an occluded or visible portion of the hilited element.
            const hidden = hilite.hiddenRatio;
            const visible = Math.max(0, hilite.visibleRatio - hidden);
            uniform.setUniform3fv([visible, hidden, silhouette]);
        });
    });
}
exports.addHiliteSettings = addHiliteSettings;
// If feature is not hilited, discard it.
const checkVertexHiliteDiscard = "return 0.0 == v_feature_hilited;";
// The result is a mask in which each highlighted pixel is white, all other pixels are black.
const computeHiliteColor = "return vec4(ceil(v_feature_hilited));";
const computeSurfaceHiliteColor = `
if (ceil(v_feature_hilited) >= 1.0 && isSurfaceBitSet(kSurfaceBit_HasTexture))
  return vec4(TEXTURE(s_texture, v_texCoord).a > 0.15 ? 1.0 : 0.0);
else
  return vec4(ceil(v_feature_hilited));
`;
const computeHiliteOverrides = `
  vec4 value = getFirstFeatureRgba();
  float flags = value.r * 256.0;
  feature_invisible = 1.0 == extractNthFeatureBit(flags, kOvrBit_Visibility);
  v_feature_hilited = extractNthFeatureBit(flags, kOvrBit_Hilited);
`;
const computeHiliteOverridesWithWeight = computeHiliteOverrides + `
  linear_feature_overrides = vec4(1.0 == extractNthFeatureBit(flags, kOvrBit_Weight),
  value.g * 256.0,
  1.0 == extractNthFeatureBit(flags, kOvrBit_LineCode),
  value.b * 256.0);
`;
/** @internal */
function addSurfaceHiliter(builder, wantWeight = false) {
    addHiliter(builder, wantWeight);
    builder.frag.set(1 /* ComputeBaseColor */, computeSurfaceHiliteColor);
}
exports.addSurfaceHiliter = addSurfaceHiliter;
/** @internal */
function addHiliter(builder, wantWeight = false) {
    let opts = 4 /* HasOverrides */;
    if (wantWeight)
        opts |= 1 /* Weight */; // hiliter never needs line code or color...
    if (!addCommon(builder, 2 /* Overrides */, opts))
        return;
    builder.addVarying("v_feature_hilited", 2 /* Float */);
    builder.vert.set(2 /* ComputeFeatureOverrides */, wantWeight ? computeHiliteOverridesWithWeight : computeHiliteOverrides);
    builder.vert.set(3 /* CheckForDiscard */, checkVertexHiliteDiscard);
    builder.frag.set(1 /* ComputeBaseColor */, computeHiliteColor);
    builder.frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
}
exports.addHiliter = addHiliter;
function addSamplers(frag, testFeatureId) {
    if (testFeatureId) {
        frag.addUniform("u_pickFeatureId", 8 /* Sampler2D */, (prog) => {
            prog.addProgramUniform("u_pickFeatureId", (uniform, params) => {
                params.target.compositor.featureIds.bindSampler(uniform, RenderFlags_1.TextureUnit.PickFeatureId);
            });
        }, 3 /* High */);
    }
    frag.addUniform("u_pickDepthAndOrder", 8 /* Sampler2D */, (prog) => {
        prog.addProgramUniform("u_pickDepthAndOrder", (uniform, params) => {
            params.target.compositor.depthAndOrder.bindSampler(uniform, RenderFlags_1.TextureUnit.PickDepthAndOrder);
        });
    }, 3 /* High */);
}
/** @internal */
exports.readDepthAndOrder = `
vec2 readDepthAndOrder(vec2 tc) {
  vec4 pdo = TEXTURE(u_pickDepthAndOrder, tc);
  float order = floor(pdo.x * 16.0 + 0.5);
  return vec2(order, decodeDepthRgb(pdo.yzw));
}
`;
// ####TODO vertex shader already tests transparency threshold...native renderer tests here as well?
const checkForEarlySurfaceDiscard = `
  float factor = float(u_renderPass <= kRenderPass_Translucent); // never discard during specific passes
  float term = 0.0; // float(isBelowTransparencyThreshold()); // else always discard if alpha < transparency threshold

  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);
  vec2 depthAndOrder = readDepthAndOrder(tc);
  float surfaceDepth = computeLinearDepth(v_eyeSpace.z);
  term += float(depthAndOrder.x > u_renderOrder && abs(depthAndOrder.y - surfaceDepth) < 4.0e-5);
  return factor * term > 0.0;
`;
// ####TODO vertex shader already tests transparency threshold...native renderer tests here as well?
const checkForEarlySurfaceDiscardWithFeatureID = `
  // No normals => unlt => reality model => no edges.
  bool neverDiscard = u_renderPass > kRenderPass_Translucent || !isSurfaceBitSet(kSurfaceBit_HasNormals);
  bool alwaysDiscard = false; // !neverDiscard && isBelowTransparencyThreshold();

  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);
  vec2 depthAndOrder = readDepthAndOrder(tc);
  bool discardByOrder = depthAndOrder.x > u_renderOrder;

  // Calculate depthTolerance for letting edges show through their own surfaces
  float perspectiveFrustum = step(kFrustumType_Perspective, u_frustum.z);
  vec4 eyeDirAndWidthFactor = mix(vec4(0.0, 0.0, 1.0, u_pixelWidthFactor), vec4(normalize(-v_eyeSpace.xyz), -v_eyeSpace.z * u_pixelWidthFactor), perspectiveFrustum);
  vec3 eyeDir = eyeDirAndWidthFactor.xyz;
  float dtWidthFactor = eyeDirAndWidthFactor.w;

  // Compute depth tolerance based on angle of triangle to screen
  float isSilhouette = float(depthAndOrder.x == kRenderOrder_Silhouette);
  float dSq = dot(eyeDir, v_n);
  dSq *= 0.5 + 0.4 * (1.0 - isSilhouette);
  dSq = dSq * dSq;
  dSq = max(dSq, 0.0001);
  dSq = min(dSq, 0.999);

  float depthTolerance = dtWidthFactor * v_lineWeight * sqrt((1.0 - dSq) / dSq);
  depthTolerance *= 1.0 + .333 * isSilhouette;

  // Make sure stuff behind camera doesn't get pushed in front of it
  depthTolerance = max(depthTolerance, 0.0);

  // Convert depthTolerance from eye space to linear depth
  depthTolerance /= (u_frustum.y - u_frustum.x);

  float surfaceDepth = computeLinearDepth(v_eyeSpace.z);
  float depthDelta = abs(depthAndOrder.y - surfaceDepth);
  bool withinDepthTolerance = depthDelta <= depthTolerance;

  // Does pick buffer contain same feature?
  vec4 featId = TEXTURE(u_pickFeatureId, tc);

  // Converting to ints to test since varying floats can be interpolated incorrectly
  ivec4 featId_i = ivec4(featId * 255.0 + 0.5);
  ivec4 v_feature_id_i = ivec4(v_feature_id * 255.0 + 0.5);
  bool isSameFeature = featId_i == v_feature_id_i;

  // If what was in the pick buffer is a planar line/edge/silhouette then we've already tested the depth so return true to discard.
  // If it was a planar surface then use a tighter and constant tolerance to see if we want to let it show through since we're only fighting roundoff error.
  return alwaysDiscard || (!neverDiscard && discardByOrder && withinDepthTolerance && (isSameFeature || ((depthAndOrder.x > kRenderOrder_PlanarSurface) || ((depthAndOrder.x == kRenderOrder_PlanarSurface) && (depthDelta <= 4.0e-5)))));
`;
/** @internal */
exports.computeFeatureId = `v_feature_id = addUInt32s(u_batch_id, g_featureIndex) / 255.0;`;
function addRenderOrderConstants(builder) {
    builder.addConstant("kRenderOrder_None", 2 /* Float */, "0.0");
    builder.addConstant("kRenderOrder_BlankingRegion", 2 /* Float */, "1.0");
    builder.addConstant("kRenderOrder_Surface", 2 /* Float */, "2.0");
    builder.addConstant("kRenderOrder_Linear", 2 /* Float */, "3.0");
    builder.addConstant("kRenderOrder_Edge", 2 /* Float */, "4.0");
    builder.addConstant("kRenderOrder_Silhouette", 2 /* Float */, "5.0");
    builder.addConstant("kRenderOrder_PlanarSurface", 2 /* Float */, "10.0");
    builder.addConstant("kRenderOrder_PlanarLinear", 2 /* Float */, "11.0");
    builder.addConstant("kRenderOrder_PlanarEdge", 2 /* Float */, "12.0");
    builder.addConstant("kRenderOrder_PlanarSilhouette", 2 /* Float */, "13.0");
}
/** @internal */
function addRenderOrder(builder) {
    builder.addUniform("u_renderOrder", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_renderOrder", (uniform, params) => {
            uniform.setUniform1f(params.geometry.renderOrder);
        });
    });
}
exports.addRenderOrder = addRenderOrder;
function setPixelWidthFactor(uniform, params) {
    const rect = params.target.viewRect;
    const width = rect.width;
    const height = rect.height;
    const frustumPlanes = params.target.frustumUniforms.frustumPlanes;
    const top = frustumPlanes[0];
    const bottom = frustumPlanes[1];
    const left = frustumPlanes[2];
    const right = frustumPlanes[3];
    let halfPixelWidth;
    let halfPixelHeight;
    const frustum = params.target.frustumUniforms.frustum;
    if (2.0 === frustum[2]) { // perspective
        const inverseNear = 1.0 / frustum[0];
        const tanTheta = top * inverseNear;
        halfPixelHeight = tanTheta / height;
        halfPixelWidth = tanTheta / width;
    }
    else {
        halfPixelWidth = 0.5 * (right - left) / width;
        halfPixelHeight = 0.5 * (top - bottom) / height;
    }
    const pixelWidthFactor = Math.sqrt(halfPixelWidth * halfPixelWidth + halfPixelHeight * halfPixelHeight);
    uniform.setUniform1f(pixelWidthFactor);
}
function addPixelWidthFactor(builder) {
    builder.addUniform("u_pixelWidthFactor", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_pixelWidthFactor", (uniform, params) => { setPixelWidthFactor(uniform, params); });
    });
}
const scratchBytes = new Uint8Array(4);
const scratchBatchId = new Uint32Array(scratchBytes.buffer);
const scratchBatchComponents = [0, 0, 0, 0];
function addBatchId(vert) {
    vert.addUniform("u_batch_id", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_batch_id", (uniform, params) => {
            const batchId = params.target.currentBatchId;
            scratchBatchId[0] = batchId;
            scratchBatchComponents[0] = scratchBytes[0];
            scratchBatchComponents[1] = scratchBytes[1];
            scratchBatchComponents[2] = scratchBytes[2];
            scratchBatchComponents[3] = scratchBytes[3];
            uniform.setUniform4fv(scratchBatchComponents);
        });
    }, 3 /* High */);
}
/** @internal */
function addFeatureId(builder) {
    const vert = builder.vert;
    vert.addFunction(Common_1.addUInt32s);
    builder.addInlineComputedVarying("v_feature_id", 5 /* Vec4 */, exports.computeFeatureId);
    addBatchId(vert);
}
exports.addFeatureId = addFeatureId;
// For hidden line + solid fill modes...translucent + opaque passes only.
// Note the test is based on the element color's alpha, ignoring any feature overrides etc.
const isBelowTransparencyThreshold = `
  return g_baseAlpha < u_transparencyThreshold && isSurfaceBitSet(kSurfaceBit_TransparencyThreshold);
`;
/** @internal */
function addSurfaceDiscard(builder, feat, isEdgeTestNeeded, isClassified) {
    const frag = builder.frag;
    const vert = builder.vert;
    vert.set(5 /* CheckForLateDiscard */, isBelowTransparencyThreshold);
    vert.addUniform("u_transparencyThreshold", 2 /* Float */, (prog) => {
        prog.addProgramUniform("u_transparencyThreshold", (uniform, params) => {
            uniform.setUniform1f(params.target.transparencyThreshold);
        });
    });
    if (isEdgeTestNeeded) {
        Fragment_1.addWindowToTexCoords(frag);
        if (0 /* None */ === feat) {
            addSamplers(frag, false);
            frag.addFunction(Fragment_1.GLSLFragment.computeLinearDepth);
            frag.addFunction(Decode_1.GLSLDecode.depthRgb);
            frag.addFunction(exports.readDepthAndOrder);
            Common_1.addEyeSpace(builder);
            frag.set(0 /* CheckForEarlyDiscard */, checkForEarlySurfaceDiscard);
        }
        else {
            addFeatureIndex(vert);
            Vertex_1.addLineWeight(vert);
            addSamplers(frag, true);
            addRenderOrderConstants(frag);
            addPixelWidthFactor(frag);
            frag.addFunction(Fragment_1.GLSLFragment.computeLinearDepth);
            frag.addFunction(Decode_1.GLSLDecode.depthRgb);
            frag.addFunction(exports.readDepthAndOrder);
            frag.set(0 /* CheckForEarlyDiscard */, checkForEarlySurfaceDiscardWithFeatureID);
            Common_1.addEyeSpace(builder);
            builder.addInlineComputedVarying("v_lineWeight", 2 /* Float */, "v_lineWeight = computeLineWeight();");
            addFeatureId(builder);
        }
        addRenderOrder(frag);
        RenderPass_1.addRenderPass(frag);
    }
    else if (isClassified && 0 /* None */ !== feat) {
        addFeatureIndex(vert);
        Common_1.addEyeSpace(builder);
        addFeatureId(builder);
        addRenderOrder(frag);
    }
}
exports.addSurfaceDiscard = addSurfaceDiscard;
// bool feature_invisible = false;
// varying vec3 v_feature_rgb; // if not overridden, .r < 0; else rgb color override
// varying vec4 v_feature_alpha_flashed; // x = alpha if overridden, else < 0; y = 1 if flashed, 2 if hilited, 3 if both, 0 if neither
// varying vec4 v_feature_alpha_flashed; // y > 0.0 if overridden. z > 0.0 if flashed. w > 0.0 if hilited.
// vec4 linear_feature_overrides; // x: weight overridden y: weight z: line code overridden w: line code
const computeFeatureOverrides = `
  v_feature_rgb = vec3(-1.0);
  v_feature_alpha_flashed = vec2(-1.0, 0.0);
  vec4 value = getFirstFeatureRgba();

  // 2 RGBA values per feature - first R is override flags mask, first A is 1.0 for non-locatable feature.
  // The latter makes the feature invisible only if the "ignore non-locatable" shader flag is set.
  float nonLocatable = value.a * extractShaderBit(kShaderBit_IgnoreNonLocatable);
  if (0.0 == value.r + nonLocatable)
    return; // nothing overridden for this feature

  float flags = value.r * 256.0;
  float invisible = extractNthFeatureBit(flags, kOvrBit_Visibility);
  feature_invisible = 0.0 != (invisible + nonLocatable);
  if (feature_invisible)
    return;

  bool rgbOverridden = extractNthFeatureBit(flags, kOvrBit_Rgb) > 0.0;
  bool alphaOverridden = extractNthFeatureBit(flags, kOvrBit_Alpha) > 0.0;
  if (alphaOverridden || rgbOverridden) {
    vec4 rgba = getSecondFeatureRgba();
    if (rgbOverridden)
      v_feature_rgb = rgba.rgb;

    if (alphaOverridden)
      v_feature_alpha_flashed.x = rgba.a;
  }

  linear_feature_overrides = vec4(1.0 == extractNthFeatureBit(flags, kOvrBit_Weight),
                                  value.g * 256.0,
                                  1.0 == extractNthFeatureBit(flags, kOvrBit_LineCode),
                                  value.b * 256.0);

  feature_ignore_material = 0.0 != extractNthFeatureBit(flags, kOvrBit_IgnoreMaterial);
  v_feature_alpha_flashed.y = extractNthFeatureBit(flags, kOvrBit_Flashed);
  v_feature_alpha_flashed.y += 2.0 * extractNthFeatureBit(flags, kOvrBit_Hilited);
`;
// v_feature_rgb.r = -1.0 if rgb color not overridden for feature.
// v_feature_alpha_flashed.x = -1.0 if alpha not overridden for feature.
const applyFeatureColor = `
  vec4 color = mix(baseColor, vec4(v_feature_rgb.rgb * baseColor.a, baseColor.a), step(0.0, v_feature_rgb.r));
  return mix(color, adjustPreMultipliedAlpha(color, v_feature_alpha_flashed.x), step(0.0, v_feature_alpha_flashed.x));
`;
const applyFlash = `
  float flashHilite = floor(v_feature_alpha_flashed.y + 0.5);
  return doApplyFlash(flashHilite, baseColor);
`;
// u_hilite_color.a is 1.0 for lit geometry, 0.0 for unlit. Lit gets brightened; unlit gets tweened.
const doApplyFlash = `
vec4 doApplyFlash(float flashHilite, vec4 baseColor) {
  float isFlashed = (flashHilite == 1.0 || flashHilite == 3.0) ? 1.0 : 0.0;
  float isHilited = (flashHilite >= 2.0) ? 1.0 : 0.0;

  float hiliteRatio = u_hilite_settings.x * isHilited;
  baseColor = revertPreMultipliedAlpha(baseColor);
  baseColor.rgb = mix(baseColor.rgb, u_hilite_color.rgb, hiliteRatio);

  const float maxBrighten = 0.2;
  float brighten = u_flash_intensity * maxBrighten;
  vec3 brightRgb = baseColor.rgb + isFlashed * brighten;

  const float maxTween = 0.75;
  float hiliteFraction = u_flash_intensity * isFlashed * maxTween;
  vec3 tweenRgb = baseColor.rgb * (1.0 - hiliteFraction);
  tweenRgb += u_hilite_color.rgb * hiliteFraction;

  vec4 color = vec4(mix(tweenRgb, brightRgb, u_hilite_color.a), baseColor.a);
  return applyPreMultipliedAlpha(color);
}
`;
function addApplyFlash(frag) {
    addHiliteSettings(frag);
    frag.addFunction(Fragment_1.GLSLFragment.revertPreMultipliedAlpha);
    frag.addFunction(Fragment_1.GLSLFragment.applyPreMultipliedAlpha);
    frag.addFunction(Fragment_1.GLSLFragment.adjustPreMultipliedAlpha);
    frag.addFunction(doApplyFlash);
    frag.set(11 /* ApplyFlash */, applyFlash);
    frag.addUniform("u_flash_intensity", 2 /* Float */, (prog) => {
        prog.addProgramUniform("u_flash_intensity", (uniform, params) => {
            uniform.setUniform1f(params.target.flashIntensity);
        });
    });
}
/** @internal */
function addFeatureSymbology(builder, feat, opts) {
    if (!addCommon(builder, feat, opts) || 0 /* None */ === opts)
        return;
    bentleyjs_core_1.assert((4 /* HasOverrides */ | 8 /* Color */) === (opts & (4 /* HasOverrides */ | 8 /* Color */)));
    builder.addVarying("v_feature_rgb", 4 /* Vec3 */);
    builder.addVarying("v_feature_alpha_flashed", 3 /* Vec2 */);
    const vert = builder.vert;
    vert.set(2 /* ComputeFeatureOverrides */, computeFeatureOverrides);
    const frag = builder.frag;
    addApplyFlash(frag);
    frag.set(3 /* ApplyFeatureColor */, applyFeatureColor);
}
exports.addFeatureSymbology = addFeatureSymbology;
/** If we're running the hilite shader for a uniform feature, it follows that the feature must be hilited.
 * So the hilite shader simply needs to output '1' for every fragment.
 * @internal
 */
function addUniformHiliter(builder) {
    builder.frag.set(1 /* ComputeBaseColor */, `return vec4(1.0);`);
    builder.frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
}
exports.addUniformHiliter = addUniformHiliter;
/** For a uniform feature table, the feature ID output to pick buffers is equal to the batch ID.
 * The following symbology overrides are supported:
 *  - Visibility - implcitly, because if the feature is invisible its geometry will never be drawn.
 *  - Flash
 *  - Hilite
 * In future we may find a reason to support color and/or transparency.
 * This shader could be simplified, but want to share code with the non-uniform versions...hence uniforms/globals with "v_" prefix typically used for varyings...
 * @internal
 */
function addUniformFeatureSymbology(builder) {
    // addFeatureIndex()
    builder.vert.addGlobal("g_featureIndex", 5 /* Vec4 */, "vec4(0.0)", true);
    // addFeatureSymbology()
    builder.frag.addUniform("v_feature_alpha_flashed", 3 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("v_feature_alpha_flashed", (uniform, params) => {
            // only the 'y' component is used. first bit = flashed, second = hilited.
            let value = 0;
            const ovr = params.target.currentOverrides;
            if (undefined !== ovr) {
                if (ovr.anyHilited) // any hilited implies all hilited.
                    value = 2;
                if (ovr.isUniformFlashed)
                    value += 1;
            }
            uniform.setUniform2fv([0.0, value]);
        });
    });
    addApplyFlash(builder.frag);
}
exports.addUniformFeatureSymbology = addUniformFeatureSymbology;


/***/ }),

/***/ "./lib/render/webgl/glsl/Fragment.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/glsl/Fragment.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const Decode_1 = __webpack_require__(/*! ./Decode */ "./lib/render/webgl/glsl/Decode.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
/** @internal */
function addWindowToTexCoords(frag) {
    const windowCoordsToTexCoords = `\nvec2 windowCoordsToTexCoords(vec2 wc) { return wc * u_invScreenSize; }\n`;
    frag.addFunction(windowCoordsToTexCoords);
    frag.addUniform("u_invScreenSize", 3 /* Vec2 */, (prog) => {
        prog.addProgramUniform("u_invScreenSize", (uniform, params) => {
            const rect = params.target.viewRect;
            const invScreenSize = [1.0 / rect.width, 1.0 / rect.height];
            uniform.setUniform2fv(invScreenSize);
        });
    });
}
exports.addWindowToTexCoords = addWindowToTexCoords;
/** @internal */
function addWhiteOnWhiteReversal(frag) {
    frag.addUniform("u_reverseWhiteOnWhite", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_reverseWhiteOnWhite", (uniform, params) => {
            const bgColor = params.target.bgColor;
            const doReversal = (bgColor.isWhite && params.geometry.wantWoWReversal(params.programParams)) ? 1.0 : 0.0;
            uniform.setUniform1f(doReversal);
        });
    });
    frag.set(9 /* ReverseWhiteOnWhite */, reverseWhiteOnWhite);
}
exports.addWhiteOnWhiteReversal = addWhiteOnWhiteReversal;
/** For techniques which by default use MRT, on devices which don't support MRT we fall back to
 * multi-pass rendering. The same shader is used each pass, with a uniform supplied indicating
 * which value to output to gl_FragColor. It's specified as an index - the same one that would be
 * used to index into gl_FragData[] in MRT context.
 * @internal
 */
function addRenderTargetIndex(frag) {
    frag.addUniform("u_renderTargetIndex", 1 /* Int */, (prog) => {
        prog.addProgramUniform("u_renderTargetIndex", (uniform, params) => {
            uniform.setUniform1i(params.target.compositor.currentRenderTargetIndex);
        });
    });
}
exports.addRenderTargetIndex = addRenderTargetIndex;
const reverseWhiteOnWhite = `
  const vec3 white = vec3(1.0);
  const vec3 epsilon = vec3(0.0001);
  vec3 color = baseColor.rgb / max(0.0001, baseColor.a); // revert premultiplied alpha
  vec3 delta = (color + epsilon) - white;
  vec4 wowColor = vec4(baseColor.rgb * vec3(float(delta.x <= 0.0 || delta.y <= 0.0 || delta.z <= 0.0)), baseColor.a); // set to black if almost white
  wowColor.rgb *= wowColor.a; // reapply premultiplied alpha
  return mix(baseColor, wowColor, floor(u_reverseWhiteOnWhite + 0.5));
`;
const computePickBufferOutputs = `
  vec4 output0 = baseColor;

  // Fix interpolation errors despite all vertices sending exact same v_feature_id...
  ivec4 v_feature_id_i = ivec4(v_feature_id * 255.0 + 0.5);
  vec4 output1 = vec4(v_feature_id_i) / 255.0;
  float linearDepth = computeLinearDepth(v_eyeSpace.z);
  vec4 output2 = vec4(u_renderOrder * 0.0625, encodeDepthRgb(linearDepth)); // near=1, far=0
`;
const computeAltPickBufferOutputs = `
  vec4 output0 = baseColor;
  vec4 output1 = vec4(0.0);
  vec4 output2 = vec4(0.0);
`;
const assignPickBufferOutputsMRT = `
  FragColor0 = output0;
  FragColor1 = output1;
  FragColor2 = output2;
`;
const assignPickBufferOutputsMP = `
  if (0 == u_renderTargetIndex)
    FragColor = output0;
  else if (1 == u_renderTargetIndex)
    FragColor = output1;
  else
    FragColor = output2;
`;
const reassignFeatureId = "output1 = overrideFeatureId(output1);";
/** @internal */
function addPickBufferOutputs(frag) {
    frag.addFunction(Decode_1.GLSLDecode.encodeDepthRgb);
    frag.addFunction(GLSLFragment.computeLinearDepth);
    const prelude = new ShaderBuilder_1.SourceBuilder();
    const overrideFeatureId = frag.get(16 /* OverrideFeatureId */);
    if (undefined !== overrideFeatureId) {
        frag.addFunction("vec4 overrideFeatureId(vec4 currentId)", overrideFeatureId);
        prelude.add(computePickBufferOutputs);
        prelude.addline(reassignFeatureId);
    }
    else
        prelude.add(computePickBufferOutputs);
    if (System_1.System.instance.capabilities.supportsMRTPickShaders) {
        frag.addDrawBuffersExtension();
        frag.set(15 /* AssignFragData */, prelude.source + assignPickBufferOutputsMRT);
    }
    else {
        addRenderTargetIndex(frag);
        frag.set(15 /* AssignFragData */, prelude.source + assignPickBufferOutputsMP);
    }
}
exports.addPickBufferOutputs = addPickBufferOutputs;
/** @internal */
function addAltPickBufferOutputs(frag) {
    const prelude = new ShaderBuilder_1.SourceBuilder();
    prelude.add(computeAltPickBufferOutputs);
    if (System_1.System.instance.capabilities.supportsMRTPickShaders) {
        frag.addDrawBuffersExtension();
        frag.set(15 /* AssignFragData */, prelude.source + assignPickBufferOutputsMRT);
    }
    else {
        addRenderTargetIndex(frag);
        frag.set(15 /* AssignFragData */, prelude.source + assignPickBufferOutputsMP);
    }
}
exports.addAltPickBufferOutputs = addAltPickBufferOutputs;
/** @internal */
var GLSLFragment;
(function (GLSLFragment) {
    GLSLFragment.assignFragColor = "FragColor = baseColor;";
    GLSLFragment.assignFragColorNoAlpha = "FragColor = vec4(baseColor.rgb, 1.0);";
    GLSLFragment.revertPreMultipliedAlpha = `
vec4 revertPreMultipliedAlpha(vec4 rgba) {
  rgba.rgb /= max(0.0001, rgba.a);
  return rgba;
}
`;
    GLSLFragment.applyPreMultipliedAlpha = `
vec4 applyPreMultipliedAlpha(vec4 rgba) {
  rgba.rgb *= rgba.a;
  return rgba;
}
`;
    GLSLFragment.adjustPreMultipliedAlpha = `
vec4 adjustPreMultipliedAlpha(vec4 rgba, float newAlpha) {
  float oldAlpha = rgba.a;
  rgba.rgb /= max(0.0001, oldAlpha);
  rgba.rgb *= newAlpha;
  rgba.a = newAlpha;
  return rgba;
}
`;
    GLSLFragment.computeLinearDepth = `
float computeLinearDepth(float eyeSpaceZ) {
  float eyeZ = -eyeSpaceZ;
  float near = u_frustum.x, far = u_frustum.y;
  float depthRange = far - near;
  float linearDepth = (eyeZ - near) / depthRange;
  return 1.0 - linearDepth;
}
`;
})(GLSLFragment = exports.GLSLFragment || (exports.GLSLFragment = {}));


/***/ }),

/***/ "./lib/render/webgl/glsl/Instancing.js":
/*!*********************************************!*\
  !*** ./lib/render/webgl/glsl/Instancing.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const GL_1 = __webpack_require__(/*! ../GL */ "./lib/render/webgl/GL.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./FeatureSymbology */ "./lib/render/webgl/glsl/FeatureSymbology.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const extractInstanceBit = `
  float extractInstanceBit(float flag) { return extractNthBit(a_instanceOverrides.r, flag); }
`;
const computeInstancedModelMatrixRTC = `
  g_modelMatrixRTC = mat4(
    a_instanceMatrixRow0.x, a_instanceMatrixRow1.x, a_instanceMatrixRow2.x, 0.0,
    a_instanceMatrixRow0.y, a_instanceMatrixRow1.y, a_instanceMatrixRow2.y, 0.0,
    a_instanceMatrixRow0.z, a_instanceMatrixRow1.z, a_instanceMatrixRow2.z, 0.0,
    a_instanceMatrixRow0.w, a_instanceMatrixRow1.w, a_instanceMatrixRow2.w, 1.0);
`;
function addInstanceMatrixRow(vert, row) {
    // 3 rows per instance; 4 floats per row; 4 bytes per float.
    const floatsPerRow = 4;
    const bytesPerVertex = floatsPerRow * 4;
    const offset = row * bytesPerVertex;
    const stride = 3 * bytesPerVertex;
    const name = "a_instanceMatrixRow" + row;
    vert.addAttribute(name, 5 /* Vec4 */, (prog) => {
        prog.addAttribute(name, (attr, params) => {
            const geom = params.geometry.asInstanced;
            bentleyjs_core_1.assert(undefined !== geom);
            attr.enableArray(geom.transforms, floatsPerRow, GL_1.GL.DataType.Float, false, stride, offset, true);
        });
    });
}
/** @internal */
function addInstancedModelMatrixRTC(vert) {
    bentleyjs_core_1.assert(vert.usesInstancedGeometry);
    addInstanceMatrixRow(vert, 0);
    addInstanceMatrixRow(vert, 1);
    addInstanceMatrixRow(vert, 2);
    vert.addGlobal("g_modelMatrixRTC", 7 /* Mat4 */);
    vert.addInitializer(computeInstancedModelMatrixRTC);
}
exports.addInstancedModelMatrixRTC = addInstancedModelMatrixRTC;
/** @internal */
function addInstanceOverrides(vert) {
    if (undefined !== vert.find("a_instanceOverrides"))
        return;
    FeatureSymbology_1.addOvrFlagConstants(vert);
    vert.addFunction(Common_1.GLSLCommon.extractNthBit);
    vert.addFunction(extractInstanceBit);
    vert.addAttribute("a_instanceOverrides", 5 /* Vec4 */, (prog) => {
        prog.addAttribute("a_instanceOverrides", (attr, params) => {
            const geom = params.geometry.asInstanced;
            bentleyjs_core_1.assert(undefined !== geom);
            // NB: If none defined, attribute access returns constant values.
            // This is *context* state. Apparently it defaults to (0, 0, 0, 1). Which is fine for us since r=0 means nothing overridden.
            if (undefined !== geom.symbology)
                attr.enableArray(geom.symbology, 4, GL_1.GL.DataType.UnsignedByte, false, 8, 0, true);
        });
    });
}
exports.addInstanceOverrides = addInstanceOverrides;
/** @internal */
function addInstanceColor(vert) {
    addInstanceOverrides(vert);
    vert.addAttribute("a_instanceRgba", 5 /* Vec4 */, (prog) => {
        prog.addAttribute("a_instanceRgba", (attr, params) => {
            const geom = params.geometry.asInstanced;
            if (undefined !== geom.symbology)
                attr.enableArray(geom.symbology, 4, GL_1.GL.DataType.UnsignedByte, false, 8, 4, true);
        });
    });
}
exports.addInstanceColor = addInstanceColor;


/***/ }),

/***/ "./lib/render/webgl/glsl/Lighting.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/glsl/Lighting.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const Material_1 = __webpack_require__(/*! ../Material */ "./lib/render/webgl/Material.js");
const computeSimpleLighting = `
void computeSimpleLight (inout float diffuse, inout float specular, vec3 normal, vec3 toEye, vec3 lightDir, float lightIntensity, float specularExponent) {
  diffuse += lightIntensity * max(dot(normal, lightDir), 0.0);
  vec3 toReflectedLight = normalize(reflect(lightDir, normal));
  float specularDot = max(dot(toReflectedLight, toEye), 0.0);
  specular += lightIntensity * pow(specularDot, specularExponent);
}
`;
const applyLighting = `
  if (isSurfaceBitSet(kSurfaceBit_ApplyLighting) && baseColor.a > 0.0) {
    // Lighting algorithms written in terms of non-pre-multiplied alpha...
    float alpha = baseColor.a;
    baseColor.rgb /= alpha;

    // negate normal if not front-facing
    vec3 normal = normalize(v_n.xyz);
    normal *= 2.0 * float(gl_FrontFacing) - 1.0;
    vec3 toEye = mix(vec3(0.0, 0.0, -1.0), normalize(v_pos.xyz), float(kFrustumType_Perspective == u_frustum.z));

    float useDefaults = extractSurfaceBit(kSurfaceBit_IgnoreMaterial);
    const vec4 defaultSpecular = vec4(1.0, 1.0, 1.0, 43.2); // rgb, exponent
    vec4 specular = mix(u_specular, defaultSpecular, useDefaults);
    vec3 specularColor = specular.rgb;
    float specularExp = specular.a;

    const vec2 defaultWeights = vec2(.6, .4); // diffuse, specular
    vec2 weights = mix(u_material.rg, defaultWeights, useDefaults);
    float diffuseWeight = weights.r;
    float specularWeight = weights.g;

    vec3 litColor = vec3(0.0);

    float diffuseIntensity = 0.0, specularIntensity = 0.0;

    // Use a pair of lights that is something in-between portrait lighting & something more out-doorsy with a slightly more overhead main light.
    // This will make more sense in a wider variety of scenes since this is the only lighting currently supported.
    computeSimpleLight (diffuseIntensity, specularIntensity, normal, toEye, normalize(vec3(0.2, 0.5, 0.5)), 1.0, specularExp);
    computeSimpleLight (diffuseIntensity, specularIntensity, normal, toEye, normalize(vec3(-0.3, 0.0, 0.3)), .30, specularExp);

    const float directionalIntensity = 0.92;
    const float ambientIntensity = 0.2;
    litColor += directionalIntensity * diffuseWeight * diffuseIntensity * baseColor.rgb + specularIntensity * specularWeight * specularColor;
    litColor.rgb += ambientIntensity * baseColor.rgb;

    // Clamp while preserving hue.
    float maxIntensity = max(litColor.r, max(litColor.g, litColor.b));

    baseColor.rgb = litColor / max(1.0, maxIntensity);

    // Restore pre-multiplied alpha...
    baseColor.rgb *= alpha;
  }

  return baseColor;
`;
/** @internal */
function addLighting(builder) {
    Common_1.addFrustum(builder);
    const frag = builder.frag;
    frag.addUniform("u_material", 4 /* Vec3 */, (shader) => {
        shader.addGraphicUniform("u_material", (uniform, params) => {
            const material = params.target.currentViewFlags.materials ? params.geometry.material : undefined;
            const weights = undefined !== material ? material.weights : Material_1.Material.default.weights;
            uniform.setUniform3fv(weights);
        });
    });
    frag.addUniform("u_specular", 5 /* Vec4 */, (shader) => {
        shader.addGraphicUniform("u_specular", (uniform, params) => {
            let mat = params.target.currentViewFlags.materials ? params.geometry.material : undefined;
            if (undefined === mat)
                mat = Material_1.Material.default;
            uniform.setUniform4fv(mat.specular);
        });
    });
    frag.addFunction(computeSimpleLighting);
    frag.set(7 /* ApplyLighting */, applyLighting);
}
exports.addLighting = addLighting;


/***/ }),

/***/ "./lib/render/webgl/glsl/LookupTable.js":
/*!**********************************************!*\
  !*** ./lib/render/webgl/glsl/LookupTable.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const computeLUTCoords = `
vec2 computeLUTCoords(float index, vec2 dimensions, vec2 center, float mult) {
  float baseIndex = index*mult;

  // Fix precision issues wherein mod(x,y) => y instead of 0 when x is multiple of y...
  float epsilon = 0.5 / dimensions.x;
  float yId = floor(baseIndex / dimensions.x + epsilon);
  float xId = baseIndex - dimensions.x * yId; // replaces mod()...

  return center + vec2(xId/dimensions.x, yId/dimensions.y);
}
`;
const computeCoordsTemplate = `
vec2 compute_{LUTNAME}_coords(float index) {
  return computeLUTCoords(index, u_{LUTNAME}Params.xy, g_{LUTNAME}_center, {MULT});
}
`;
const initializerTemplate = `
  {LUTSTEPX} = 1.0 / {LUTPARAMS}.x;
  float {LUTSTEPY} = 1.0 / {LUTPARAMS}.y;
  {LUTCENTER} = vec2(0.5*{LUTSTEPX}, 0.5*{LUTSTEPY});
`;
/** @internal */
function addLookupTable(sb, lutName, mult = "1.0") {
    sb.addFunction(computeLUTCoords);
    const lutStepX = "g_" + lutName + "_stepX";
    const lutStepY = lutName + "_stepY";
    const lutCenter = "g_" + lutName + "_center";
    const lutParams = "u_" + lutName + "Params";
    sb.addGlobal(lutStepX, 2 /* Float */);
    sb.addGlobal(lutCenter, 3 /* Vec2 */);
    let initializerSpecific = initializerTemplate;
    initializerSpecific = initializerSpecific.replace(/{LUTSTEPX}/g, lutStepX);
    initializerSpecific = initializerSpecific.replace(/{LUTSTEPY}/g, lutStepY);
    initializerSpecific = initializerSpecific.replace(/{LUTCENTER}/g, lutCenter);
    initializerSpecific = initializerSpecific.replace(/{LUTPARAMS}/g, lutParams);
    sb.addInitializer(initializerSpecific);
    let computeCoordsSpecific = computeCoordsTemplate;
    computeCoordsSpecific = computeCoordsSpecific.replace(/{LUTNAME}/g, lutName);
    computeCoordsSpecific = computeCoordsSpecific.replace(/{MULT}/g, mult);
    sb.addFunction(computeCoordsSpecific);
}
exports.addLookupTable = addLookupTable;


/***/ }),

/***/ "./lib/render/webgl/glsl/Monochrome.js":
/*!*********************************************!*\
  !*** ./lib/render/webgl/glsl/Monochrome.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const FloatRGBA_1 = __webpack_require__(/*! ../FloatRGBA */ "./lib/render/webgl/FloatRGBA.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
// The alpha component of the mono color is 1.0 if lit, 0.0 if unlit.
// Unlit stuff (edges, polylines) uses the mono color directly in order for white-on-white reversal to work correctly.
const applyMonochromeColor = `
  // Compute lit monochrome color
  vec3 litRgb = baseColor.rgb;
  litRgb /= max(0.0001, baseColor.a); // un-premultiply alpha
  litRgb = vec3(dot(litRgb, vec3(.222, .707, .071)));
  litRgb *= u_monoRgb.rgb;

  // Select lit or unlit based on u_monoColor.a
  vec4 monoColor = vec4(mix(u_monoRgb.rgb, litRgb, u_monoRgb.a), baseColor.a);
  monoColor.rgb *= monoColor.a;

  // Select monochrome or element color based on shader flag
  return mix(baseColor, monoColor, extractShaderBit(kShaderBit_Monochrome));
`;
const scratchMonoColor = FloatRGBA_1.MutableFloatRgba.fromColorDef(imodeljs_common_1.ColorDef.white);
/** @internal */
function addMonochrome(frag) {
    frag.set(8 /* ApplyMonochrome */, applyMonochromeColor);
    frag.addUniform("u_monoRgb", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_monoRgb", (uniform, params) => {
            const color = params.target.monoColor;
            scratchMonoColor.setRgbaValues(color.red, color.green, color.blue, params.geometry.isLitSurface ? 1.0 : 0.0);
            scratchMonoColor.bind(uniform);
        });
    });
}
exports.addMonochrome = addMonochrome;


/***/ }),

/***/ "./lib/render/webgl/glsl/PlanarClassification.js":
/*!*******************************************************!*\
  !*** ./lib/render/webgl/glsl/PlanarClassification.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const applyPlanarClassificationColor = `
  vec4 colorTexel = TEXTURE(s_pClassSampler, vec2(v_pClassPos.x, v_pClassPos.y / 2.0));
  if (colorTexel.a < .5) {
    if (s_pClassColorParams.y == 0.0)
      return vec4(0);                          // Unclassifed, Off.
   else if (s_pClassColorParams.y == 1.0)
      return baseColor;                        // Unclassified, On.
    else
      return baseColor * .6;                   // Unclassified, Dimmed.
   } else {
     if (s_pClassColorParams.x == 0.0)
       return vec4(0);                        // Classified, off.
       else if (s_pClassColorParams.x == 1.0)
       return baseColor;
      else if (s_pClassColorParams.x == 2.0)
        return baseColor * .6;                // Classified, dimmed.
      else if (s_pClassColorParams.x == 3.0)
        return baseColor * vec4(.8, .8, 1.0, 1.0);  // Classified, hilite.  TBD - make color configurable.
      else
        return baseColor * colorTexel;
    // TBD -- mode 1.  Return baseColor unless flash or hilite
   }
`;
const overrideFeatureId = `
  vec4 featureTexel = TEXTURE(s_pClassSampler, vec2(v_pClassPos.x, (1.0 + v_pClassPos.y) / 2.0));
  return (featureTexel == vec4(0)) ? currentId : addUInt32s(u_batchBase, featureTexel * 255.0) / 255.0;
  `;
const computeClassifiedSurfaceHiliteColor = `
  vec4 hiliteTexel = TEXTURE(s_pClassHiliteSampler, v_pClassPos.xy);
  if (hiliteTexel.a > 0.5 && isSurfaceBitSet(kSurfaceBit_HasTexture))
    return vec4(TEXTURE(s_texture, v_texCoord).a > 0.15 ? 1.0 : 0.0);
  else
  return vec4(hiliteTexel.a > 0.5 ? 1.0 : 0.0);
`;
const computeClassifiedSurfaceHiliteColorNoTexture = `
  vec4 hiliteTexel = TEXTURE(s_pClassHiliteSampler, v_pClassPos.xy);
  return vec4(hiliteTexel.a > 0.5 ? 1.0 : 0.0);
`;
const computeClassifierPos = "vec4 proj = u_pClassProj * MAT_MODEL * rawPosition; v_pClassPos = proj.xyz/proj.w;";
const scratchBytes = new Uint8Array(4);
const scratchBatchBaseId = new Uint32Array(scratchBytes.buffer);
const scratchBatchBaseComponents = [0, 0, 0, 0];
const scratchColorParams = new Float32Array(2); // Unclassified scale, classified base scale, classified classifier scale.
function addPlanarClassifierCommon(builder) {
    const vert = builder.vert;
    vert.addUniform("u_pClassProj", 7 /* Mat4 */, (prog) => {
        prog.addGraphicUniform("u_pClassProj", (uniform, params) => {
            const classifier = params.target.planarClassifiers.classifier;
            bentleyjs_core_1.assert(undefined !== classifier);
            uniform.setMatrix4(classifier.projectionMatrix);
        });
    });
    Vertex_1.addModelMatrix(vert);
    builder.addInlineComputedVarying("v_pClassPos", 4 /* Vec3 */, computeClassifierPos);
}
/** @internal */
function addColorPlanarClassifier(builder) {
    addPlanarClassifierCommon(builder);
    const frag = builder.frag;
    const vert = builder.vert;
    frag.addUniform("s_pClassSampler", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("s_pClassSampler", (uniform, params) => {
            const classifier = params.target.planarClassifiers.classifier;
            bentleyjs_core_1.assert(undefined !== classifier && undefined !== classifier.combinedTexture);
            classifier.combinedTexture.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.PlanarClassification);
        });
    });
    frag.addUniform("s_pClassColorParams", 3 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("s_pClassColorParams", (uniform, params) => {
            const classifier = params.target.planarClassifiers.classifier;
            bentleyjs_core_1.assert(undefined !== classifier);
            scratchColorParams[0] = classifier.insideDisplay;
            scratchColorParams[1] = classifier.outsideDisplay;
            uniform.setUniform2fv(scratchColorParams);
        });
    });
    vert.addUniform("u_pClassProj", 7 /* Mat4 */, (prog) => {
        prog.addGraphicUniform("u_pClassProj", (uniform, params) => {
            const classifier = params.target.planarClassifiers.classifier;
            bentleyjs_core_1.assert(undefined !== classifier);
            uniform.setMatrix4(classifier.projectionMatrix);
        });
    });
    Vertex_1.addModelMatrix(vert);
    frag.set(12 /* ApplyPlanarClassifier */, applyPlanarClassificationColor);
}
exports.addColorPlanarClassifier = addColorPlanarClassifier;
/** @internal */
function addFeaturePlanarClassifier(builder) {
    const frag = builder.frag;
    frag.addUniform("u_batchBase", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_batchBase", (uniform, params) => {
            const classifier = params.target.planarClassifiers.classifier;
            bentleyjs_core_1.assert(undefined !== classifier);
            scratchBatchBaseId[0] = classifier.baseBatchId;
            scratchBatchBaseComponents[0] = scratchBytes[0];
            scratchBatchBaseComponents[1] = scratchBytes[1];
            scratchBatchBaseComponents[2] = scratchBytes[2];
            scratchBatchBaseComponents[3] = scratchBytes[3];
            uniform.setUniform4fv(scratchBatchBaseComponents);
        });
    });
    frag.set(16 /* OverrideFeatureId */, overrideFeatureId);
    frag.addFunction(Common_1.addUInt32s);
}
exports.addFeaturePlanarClassifier = addFeaturePlanarClassifier;
/** @internal */
function addHilitePlanarClassifier(builder, supportTextures = true) {
    const frag = builder.frag;
    frag.addUniform("s_pClassHiliteSampler", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("s_pClassHiliteSampler", (uniform, params) => {
            const classifier = params.target.planarClassifiers.classifier;
            bentleyjs_core_1.assert(undefined !== classifier && undefined !== classifier.hiliteTexture);
            classifier.hiliteTexture.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.PlanarClassificationHilite);
        });
    });
    frag.set(1 /* ComputeBaseColor */, supportTextures ? computeClassifiedSurfaceHiliteColor : computeClassifiedSurfaceHiliteColorNoTexture);
}
exports.addHilitePlanarClassifier = addHilitePlanarClassifier;


/***/ }),

/***/ "./lib/render/webgl/glsl/PointCloud.js":
/*!*********************************************!*\
  !*** ./lib/render/webgl/glsl/PointCloud.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./FeatureSymbology */ "./lib/render/webgl/glsl/FeatureSymbology.js");
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const GL_1 = __webpack_require__(/*! ../GL */ "./lib/render/webgl/GL.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const PlanarClassification_1 = __webpack_require__(/*! ./PlanarClassification */ "./lib/render/webgl/glsl/PlanarClassification.js");
const computePosition = "gl_PointSize = 1.0; return MAT_MVP * rawPos;";
const computeColor = "return vec4(a_color, 1.0);";
const computeBaseColor = "return v_color;";
function createBuilder() {
    const builder = new ShaderBuilder_1.ProgramBuilder();
    const vert = builder.vert;
    vert.set(4 /* ComputePosition */, computePosition);
    Vertex_1.addModelViewProjectionMatrix(vert);
    return builder;
}
/** @internal */
function createPointCloudBuilder(classified, featureMode) {
    const builder = createBuilder();
    builder.vert.addAttribute("a_color", 4 /* Vec3 */, (shaderProg) => {
        shaderProg.addAttribute("a_color", (attr, params) => {
            const pointCloudGeom = params.geometry;
            bentleyjs_core_1.assert(pointCloudGeom !== undefined);
            if (undefined !== pointCloudGeom && undefined !== pointCloudGeom.colors)
                attr.enableArray(pointCloudGeom.colors, 3, GL_1.GL.DataType.UnsignedByte, true, 0, 0);
        });
    });
    builder.addFunctionComputedVarying("v_color", 5 /* Vec4 */, "computeNonUniformColor", computeColor);
    builder.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    if (classified) {
        PlanarClassification_1.addColorPlanarClassifier(builder);
        if (0 /* None */ !== featureMode)
            PlanarClassification_1.addFeaturePlanarClassifier(builder);
    }
    return builder;
}
exports.createPointCloudBuilder = createPointCloudBuilder;
/** @internal */
function createPointCloudHiliter(classified) {
    const builder = createBuilder();
    FeatureSymbology_1.addUniformHiliter(builder);
    if (classified) {
        PlanarClassification_1.addColorPlanarClassifier(builder);
        PlanarClassification_1.addHilitePlanarClassifier(builder, false);
    }
    return builder;
}
exports.createPointCloudHiliter = createPointCloudHiliter;


/***/ }),

/***/ "./lib/render/webgl/glsl/PointString.js":
/*!**********************************************!*\
  !*** ./lib/render/webgl/glsl/PointString.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const FeatureSymbology_1 = __webpack_require__(/*! ./FeatureSymbology */ "./lib/render/webgl/glsl/FeatureSymbology.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const Color_1 = __webpack_require__(/*! ./Color */ "./lib/render/webgl/glsl/Color.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const computePosition = `
  float lineWeight = computeLineWeight();
  lineWeight += 0.5 * float(lineWeight > 4.0); // fudge factor for rounding fat points...
  gl_PointSize = lineWeight;
  return MAT_MVP * rawPos;
`;
// gl_PointSize specifies coordinates of this fragment within the point in range [0,1].
// This should be the most precise of the many approaches we've tried, but it still yields some asymmetry...
// Discarding if it meets radius precisely seems to reduce that slightly...
// ###TODO try point sprites?
const roundCorners = `
  const vec2 center = vec2(0.5, 0.5);
  vec2 vt = gl_PointCoord - center;
  return dot(vt, vt) * v_roundCorners >= 0.25; // meets or exceeds radius of circle
`;
const computeRoundCorners = "  v_roundCorners = gl_PointSize > 4.0 ? 1.0 : 0.0;";
function createBase(instanced) {
    const builder = new ShaderBuilder_1.ProgramBuilder(instanced ? 3 /* InstancedVertexTable */ : 1 /* VertexTable */);
    const vert = builder.vert;
    vert.set(4 /* ComputePosition */, computePosition);
    Vertex_1.addModelViewProjectionMatrix(vert);
    Vertex_1.addLineWeight(vert);
    builder.addInlineComputedVarying("v_roundCorners", 2 /* Float */, computeRoundCorners);
    builder.frag.set(0 /* CheckForEarlyDiscard */, roundCorners);
    return builder;
}
/** @internal */
function createPointStringHiliter(instanced) {
    const builder = createBase(instanced);
    FeatureSymbology_1.addHiliter(builder, true);
    return builder;
}
exports.createPointStringHiliter = createPointStringHiliter;
/** @internal */
function createPointStringBuilder(instanced) {
    const builder = createBase(instanced);
    Common_1.addShaderFlags(builder);
    Color_1.addColor(builder);
    Fragment_1.addWhiteOnWhiteReversal(builder.frag);
    return builder;
}
exports.createPointStringBuilder = createPointStringBuilder;


/***/ }),

/***/ "./lib/render/webgl/glsl/Polyline.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/glsl/Polyline.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const Viewport_1 = __webpack_require__(/*! ./Viewport */ "./lib/render/webgl/glsl/Viewport.js");
const GL_1 = __webpack_require__(/*! ../GL */ "./lib/render/webgl/GL.js");
const Decode_1 = __webpack_require__(/*! ./Decode */ "./lib/render/webgl/glsl/Decode.js");
const Color_1 = __webpack_require__(/*! ./Color */ "./lib/render/webgl/glsl/Color.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./FeatureSymbology */ "./lib/render/webgl/glsl/FeatureSymbology.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const checkForDiscard = "return discardByLineCode;";
const applyLineCode = `
  if (v_texc.x >= 0.0) { // v_texc = (-1,-1) for solid lines - don't bother with any of this
    vec4 texColor = TEXTURE(u_lineCodeTexture, v_texc);
    discardByLineCode = (0.0 == texColor.r);
  }

  if (v_lnInfo.w > 0.5) { // line needs pixel trimming
    // calculate pixel distance from pixel center to expected line center, opposite dir from major
    vec2 dxy = gl_FragCoord.xy - v_lnInfo.xy;
    if (v_lnInfo.w < 1.5)  // not x-major
      dxy = dxy.yx;

    float dist = v_lnInfo.z * dxy.x - dxy.y;
    float distA = abs(dist);
    if (distA > 0.5 || (distA == 0.5 && dist < 0.0))
      discardByLineCode = true;  // borrow this flag to force discard
  }

  return baseColor;
`;
const computeTextureCoord = `
vec2 computeLineCodeTextureCoords(vec2 windowDir, vec4 projPos, float adjust) {
  vec2 texc;
  float lineCode = computeLineCode();
  if (0.0 == lineCode) {
    // Solid line - tell frag shader not to bother.
    texc = vec2(-1.0, -1.0);
  } else {
    const float imagesPerPixel = 1.0/32.0;
    const float textureCoordinateBase = 8192.0; // Temp workardound for clipping problem in perspective views (negative values don't seem to interpolate correctly).

    if (abs(windowDir.x) > abs(windowDir.y))
      texc.x = textureCoordinateBase + imagesPerPixel * (projPos.x + adjust * windowDir.x);
    else
      texc.x = textureCoordinateBase + imagesPerPixel * (projPos.y + adjust * windowDir.y);

    const float numLineCodes = 16.0; // NB: Actually only 10, but texture is 16px tall because it needs to be a power of 2.
    const float rowsPerCode = 1.0;
    const float numRows = numLineCodes*rowsPerCode;
    const float centerY = 0.5/numRows;
    const float stepY = rowsPerCode/numRows;
    texc.y = stepY * lineCode + centerY;
  }

  return texc;
}
`;
/** @internal */
exports.adjustWidth = `
void adjustWidth(inout float width, vec2 d2, vec2 org) {
  // calculate slope based width adjustment for non-AA lines, widths 1 to 4
  vec2 d2A = abs(d2);
  const float s_myFltEpsilon = 0.0001;  // limit test resolution to 4 digits in case 24 bit (s16e7) is used in hardware
  if (d2A.y > s_myFltEpsilon && width < 4.5) {
    float len = length(d2A);
    float tan = d2A.x / d2A.y;

    if (width < 1.5) { // width 1
      if (tan <= 1.0)
        width = d2A.y / len;
      else
        width = d2A.x / len;
      // width 1 requires additional adjustment plus trimming in frag shader using v_lnInfo
      width *= 1.01;
      v_lnInfo.xy = org;
      v_lnInfo.w = 1.0; // set flag to do trimming
      // set slope in v_lnInfo.z
      if (d2A.x - d2A.y > s_myFltEpsilon) {
        v_lnInfo.z = d2.y / d2.x;
        v_lnInfo.w += 2.0; // add in x-major flag
      } else
        v_lnInfo.z = d2.x / d2.y;

    } else if (width < 2.5) { // width 2
      if (tan <= 0.5)
        width = 2.0 * d2A.y / len;
      else
        width = (d2A.y + 2.0 * d2A.x) / len;

    } else if (width < 3.5) { // width 3
        if (tan <= 1.0)
            width = (3.0 * d2A.y + d2A.x) / len;
        else
            width = (d2A.y + 3.0 * d2A.x) / len;

    } else { // if (width < 4.5) // width 4
      if (tan <= 0.5)
        width = (4.0 * d2A.y + d2A.x) / len;
      else if (tan <= 2.0)
        width = (3.0 * d2A.y + 3.0 * d2A.x) / len;
      else
        width = (d2A.y + 4.0 * d2A.x) / len;
    }
  }
}
`;
/** @internal */
function addLineCodeTexture(frag) {
    frag.addUniform("u_lineCodeTexture", 8 /* Sampler2D */, (prog) => {
        prog.addProgramUniform("u_lineCodeTexture", (uniform) => {
            const lct = System_1.System.instance.lineCodeTexture;
            bentleyjs_core_1.assert(undefined !== lct);
            if (undefined !== lct)
                lct.bindSampler(uniform, RenderFlags_1.TextureUnit.LineCode);
        });
    });
}
exports.addLineCodeTexture = addLineCodeTexture;
/** @internal */
function addLineCode(prog, args) {
    const vert = prog.vert;
    const frag = prog.frag;
    Vertex_1.addLineCode(vert);
    const funcCall = "computeLineCodeTextureCoords(" + args + ")";
    prog.addFunctionComputedVaryingWithArgs("v_texc", 3 /* Vec2 */, funcCall, computeTextureCoord);
    Common_1.addFrustum(prog);
    addLineCodeTexture(prog.frag);
    frag.set(4 /* FinalizeBaseColor */, applyLineCode);
    frag.set(5 /* CheckForDiscard */, checkForDiscard);
    frag.addGlobal("discardByLineCode", 0 /* Boolean */, "false");
}
exports.addLineCode = addLineCode;
function polylineAddLineCode(prog) {
    addLineCode(prog, lineCodeArgs);
    Vertex_1.addModelViewMatrix(prog.vert);
}
function addCommon(prog) {
    const vert = prog.vert;
    Viewport_1.addModelToWindowCoordinates(vert); // adds u_mvp, u_viewportTransformation
    Vertex_1.addProjectionMatrix(vert);
    Vertex_1.addModelViewMatrix(vert);
    Viewport_1.addViewport(vert);
    vert.addGlobal("g_windowPos", 5 /* Vec4 */);
    vert.addGlobal("g_prevPos", 5 /* Vec4 */);
    vert.addGlobal("g_nextPos", 5 /* Vec4 */);
    vert.addGlobal("g_windowDir", 3 /* Vec2 */);
    vert.addInitializer(decodeAdjacentPositions);
    vert.addAttribute("a_prevIndex", 4 /* Vec3 */, (shaderProg) => {
        shaderProg.addAttribute("a_prevIndex", (attr, params) => {
            const buffs = params.geometry.polylineBuffers;
            if (undefined !== buffs)
                attr.enableArray(buffs.prevIndices, 3, GL_1.GL.DataType.UnsignedByte, false, 0, 0);
        });
    });
    vert.addAttribute("a_nextIndex", 4 /* Vec3 */, (shaderProg) => {
        shaderProg.addAttribute("a_nextIndex", (attr, params) => {
            const buffs = params.geometry.polylineBuffers;
            if (undefined !== buffs)
                attr.enableArray(buffs.nextIndicesAndParams, 3, GL_1.GL.DataType.UnsignedByte, false, 4, 0);
        });
    });
    vert.addFunction(Decode_1.GLSLDecode.unquantize2d);
    vert.addAttribute("a_param", 2 /* Float */, (shaderProg) => {
        shaderProg.addAttribute("a_param", (attr, params) => {
            const buffs = params.geometry.polylineBuffers;
            if (undefined !== buffs)
                attr.enableArray(buffs.nextIndicesAndParams, 1, GL_1.GL.DataType.UnsignedByte, false, 4, 3);
        });
    });
    Vertex_1.addLineWeight(vert);
    vert.addGlobal("miterAdjust", 2 /* Float */, "0.0");
    vert.set(4 /* ComputePosition */, computePosition);
    prog.addVarying("v_lnInfo", 5 /* Vec4 */);
    vert.addFunction(exports.adjustWidth);
    vert.addFunction(decodePosition);
}
const decodePosition = `
vec4 decodePosition(vec3 baseIndex) {
  float index = decodeUInt32(baseIndex);
  vec2 tc = compute_vert_coords(index);
  vec4 e0 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  tc.x += g_vert_stepX;
  vec4 e1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  vec3 qpos = vec3(decodeUInt16(e0.xy), decodeUInt16(e0.zw), decodeUInt16(e1.xy));
  return unquantizePosition(qpos, u_qOrigin, u_qScale);
}`;
const decodeAdjacentPositions = `
  g_prevPos = decodePosition(a_prevIndex);
  g_nextPos = decodePosition(a_nextIndex);
`;
const computePosition = `
  const float kNone = 0.0,
              kSquare = 1.0*3.0,
              kMiter = 2.0*3.0,
              kMiterInsideOnly = 3.0*3.0,
              kJointBase = 4.0*3.0,
              kNegatePerp = 8.0*3.0,
              kNegateAlong = 16.0*3.0,
              kNoneAdjWt = 32.0*3.0;

  v_lnInfo = vec4(0.0, 0.0, 0.0, 0.0);  // init and set flag to false

  vec4 pos = MAT_MVP * rawPos;

  vec4 next = g_nextPos;
  g_windowPos = modelToWindowCoordinates(rawPos, next);

  if (g_windowPos.w == 0.0)
    return g_windowPos;

  float param = a_param;
  float weight = computeLineWeight();
  float scale = 1.0, directionScale = 1.0;

  if (param >= kNoneAdjWt)
    param -= kNoneAdjWt;

  if (param >= kNegateAlong) {
    directionScale = -directionScale;
    param -= kNegateAlong;
  }

  if (param >= kNegatePerp) {
    scale = -1.0;
    param -= kNegatePerp;
  }

  vec4 projNext = modelToWindowCoordinates(next, rawPos);
  g_windowDir = projNext.xy - g_windowPos.xy;

  if (param < kJointBase) {
    vec2 dir = (directionScale > 0.0) ? g_windowDir : -g_windowDir;
    vec2 pos = (directionScale > 0.0) ? g_windowPos.xy : projNext.xy;
    adjustWidth(weight, dir, pos);
  }

  if (kNone != param) {
    vec2 delta = vec2(0.0);
    vec4 prev   = g_prevPos;
    vec4 projPrev = modelToWindowCoordinates(prev, rawPos);
    vec2 prevDir   = g_windowPos.xy - projPrev.xy;
    float thisLength = sqrt(g_windowDir.x * g_windowDir.x + g_windowDir.y * g_windowDir.y);
    const float s_minNormalizeLength = 1.0E-5;  // avoid normalizing zero length vectors.
    float dist = weight / 2.0;

    if (thisLength > s_minNormalizeLength) {
      g_windowDir /= thisLength;

      float prevLength = sqrt(prevDir.x * prevDir.x + prevDir.y * prevDir.y);

      if (prevLength > s_minNormalizeLength) {
        prevDir /= prevLength;
        const float     s_minParallelDot= -.9999, s_maxParallelDot = .9999;
        float           prevNextDot  = dot(prevDir, g_windowDir);

        if (prevNextDot < s_minParallelDot || prevNextDot > s_maxParallelDot)    // No miter if parallel or antiparallel.
          param = kSquare;
      } else
        param = kSquare;
    } else {
      g_windowDir = -normalize(prevDir);
      param = kSquare;
    }

    vec2 perp = scale * vec2(-g_windowDir.y, g_windowDir.x);

    if (param == kSquare) {
      delta = perp;
    } else {
      vec2 bisector = normalize(prevDir - g_windowDir);
      float dotP = dot (bisector, perp);

      if (dotP != 0.0) { // Should never occur - but avoid divide by zero.
        const float maxMiter = 3.0;
        float miterDistance = 1.0/dotP;

        if (param == kMiter) { // Straight miter.
          delta = (abs(miterDistance) > maxMiter) ? perp : bisector * miterDistance;

        } else if (param == kMiterInsideOnly) { // Miter at inside, square at outside (to make room for joint).
          delta = (dotP  > 0.0 || abs(miterDistance) > maxMiter) ? perp : bisector * miterDistance;

        } else {
          const float jointTriangleCount = 3.0;
          float ratio = (param - kJointBase) / jointTriangleCount; // 3 triangles per half-joint as defined in Graphics.cpp
          delta = normalize((1.0 - ratio) * bisector + (dotP < 0.0 ? -ratio : ratio) * perp); // Miter/Straight combination.
        }
      }
    }

    miterAdjust = dot(g_windowDir, delta) * dist; // Not actually used for hilite shader but meh.
    pos.x += dist * delta.x * 2.0 * pos.w / u_viewport.z;
    pos.y += dist * delta.y * 2.0 * pos.w / u_viewport.w;
  }

  return pos;
`;
const lineCodeArgs = "g_windowDir, g_windowPos, miterAdjust";
/** @internal */
function createPolylineBuilder(instanced) {
    const builder = new ShaderBuilder_1.ProgramBuilder(instanced ? 3 /* InstancedVertexTable */ : 1 /* VertexTable */);
    Common_1.addShaderFlags(builder);
    addCommon(builder);
    polylineAddLineCode(builder);
    Color_1.addColor(builder);
    Fragment_1.addWhiteOnWhiteReversal(builder.frag);
    return builder;
}
exports.createPolylineBuilder = createPolylineBuilder;
/** @internal */
function createPolylineHiliter(instanced) {
    const builder = new ShaderBuilder_1.ProgramBuilder(instanced ? 3 /* InstancedVertexTable */ : 1 /* VertexTable */);
    addCommon(builder);
    Common_1.addFrustum(builder);
    FeatureSymbology_1.addHiliter(builder);
    return builder;
}
exports.createPolylineHiliter = createPolylineHiliter;


/***/ }),

/***/ "./lib/render/webgl/glsl/RenderPass.js":
/*!*********************************************!*\
  !*** ./lib/render/webgl/glsl/RenderPass.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Adds a uniform holding the current render pass and a set of kRenderPass_* constants
 * uniform float u_renderPass
 * @internal
 */
function addRenderPass(builder) {
    builder.addUniform("u_renderPass", 2 /* Float */, (prog) => {
        prog.addProgramUniform("u_renderPass", (uniform, params) => {
            let renderPass = params.renderPass;
            if (6 /* HiddenEdge */ === renderPass) {
                renderPass = 3 /* OpaqueGeneral */; // no distinction from shader POV...
            }
            uniform.setUniform1f(renderPass);
        });
    });
    builder.addGlobal("kRenderPass_Background", 2 /* Float */, "0.0", true);
    builder.addGlobal("kRenderPass_OpaqueLinear", 2 /* Float */, "1.0", true);
    builder.addGlobal("kRenderPass_OpaquePlanar", 2 /* Float */, "2.0", true);
    builder.addGlobal("kRenderPass_OpaqueGeneral", 2 /* Float */, "3.0", true);
    builder.addGlobal("kRenderPass_Classification", 2 /* Float */, "4.0", true);
    builder.addGlobal("kRenderPass_Translucent", 2 /* Float */, "5.0", true);
    builder.addGlobal("kRenderPass_HiddenEdge", 2 /* Float */, "6.0", true);
    builder.addGlobal("kRenderPass_Hilite", 2 /* Float */, "7.0", true);
    builder.addGlobal("kRenderPass_WorldOverlay", 2 /* Float */, "8.0", true);
    builder.addGlobal("kRenderPass_ViewOverlay", 2 /* Float */, "9.0", true);
}
exports.addRenderPass = addRenderPass;


/***/ }),

/***/ "./lib/render/webgl/glsl/SkyBox.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/glsl/SkyBox.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Matrix_1 = __webpack_require__(/*! ../Matrix */ "./lib/render/webgl/Matrix.js");
const computeBaseColor = `return vec4(0, 0, 0, 0);`;
const assignFragData = `FragColor = TEXTURE_CUBE(s_cube, v_texDir);`;
const computePosition = `vec3 pos = u_rot * vec3(rawPos.x, rawPos.z, -rawPos.y); return pos.xyzz;`; // rawPos swizzling accounts for iModel rotation.
const computeTexDir = `v_texDir = rawPosition.xyz;`;
/** @internal */
function createSkyBoxProgram(context) {
    const prog = new ShaderBuilder_1.ProgramBuilder();
    prog.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    prog.frag.set(15 /* AssignFragData */, assignFragData);
    prog.vert.set(4 /* ComputePosition */, computePosition);
    prog.vert.addUniform("u_rot", 6 /* Mat3 */, (prg) => {
        prg.addGraphicUniform("u_rot", (uniform, params) => {
            const rot = params.viewMatrix.getRotation();
            const mat3 = new Matrix_1.Matrix3();
            mat3.m00 = -rot.m00;
            mat3.m01 = -rot.m01;
            mat3.m02 = -rot.m02;
            mat3.m10 = -rot.m10;
            mat3.m11 = -rot.m11;
            mat3.m12 = -rot.m12;
            mat3.m20 = rot.m20;
            mat3.m21 = rot.m21;
            mat3.m22 = rot.m22;
            uniform.setMatrix3(mat3);
        });
    });
    prog.frag.addUniform("s_cube", 9 /* SamplerCube */, (prg) => {
        prg.addGraphicUniform("s_cube", (uniform, params) => {
            const geom = params.geometry;
            geom.cube.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.Zero);
        });
    });
    prog.addInlineComputedVarying("v_texDir", 4 /* Vec3 */, computeTexDir);
    return prog.buildProgram(context);
}
exports.createSkyBoxProgram = createSkyBoxProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/SkySphere.js":
/*!********************************************!*\
  !*** ./lib/render/webgl/glsl/SkySphere.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const ViewportQuad_1 = __webpack_require__(/*! ./ViewportQuad */ "./lib/render/webgl/glsl/ViewportQuad.js");
const Target_1 = __webpack_require__(/*! ../Target */ "./lib/render/webgl/Target.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const CachedGeometry_1 = __webpack_require__(/*! ../CachedGeometry */ "./lib/render/webgl/CachedGeometry.js");
const GL_1 = __webpack_require__(/*! ../GL */ "./lib/render/webgl/GL.js");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const computeGradientValue = `
  // For the gradient sky it's good enough to calculate these in the vertex shader.
  vec3 eyeToVert = a_worldPos - u_worldEye;
  float radius = sqrt(eyeToVert.x * eyeToVert.x + eyeToVert.y * eyeToVert.y);
  float zValue = eyeToVert.z - radius * u_zOffset;
  float d = atan(zValue, radius);
  if (u_skyParams.x < 0.0) { // 2-color gradient
    d = 0.5 - d / 3.14159265359;
    return vec4(d, 0.0, 0.0, 0.0);
  }
  d = d / 1.570796326795;
  return vec4(d, 1.0 - (d - horizonSize) / (1.0 - horizonSize), 1.0 - (-d - horizonSize) / (1.0 - horizonSize), (d + horizonSize) / (horizonSize * 2.0));
`;
const computeSkySphereColorGradient = `
  if (u_skyParams.x < 0.0) // 2-color
    return vec4(mix(u_zenithColor, u_nadirColor, v_gradientValue.x), 1.0);

  if (v_gradientValue.x > horizonSize) // above horizon
    return vec4(mix(u_zenithColor, u_skyColor, pow(v_gradientValue.y, u_skyParams.y)), 1.0);
  else if (v_gradientValue.x < -horizonSize) // below horizon
    return vec4(mix(u_nadirColor, u_groundColor, pow(v_gradientValue.z, u_skyParams.z)), 1.0);

  return vec4(mix(u_groundColor, u_skyColor, v_gradientValue.w), 1.0);
`;
const computeEyeToVert = "v_eyeToVert = a_worldPos - u_worldEye;";
const computeSkySphereColorTexture = `
  // For the texture we must calculate these per pixel.  Alternatively we could use a finer mesh.
  float radius = sqrt(v_eyeToVert.x * v_eyeToVert.x + v_eyeToVert.y * v_eyeToVert.y);
  float zValue = v_eyeToVert.z - radius * u_zOffset;
  float u = 0.25 - (atan(v_eyeToVert.y, v_eyeToVert.x) + u_rotation) / 6.28318530718;
  float v = 0.5 - atan(zValue, radius) / 3.14159265359;
  if (u < 0.0)
    u += 1.0;
  if (v < 0.0)
    v += 1.0;
  return TEXTURE(s_skyTxtr, vec2(u, v));
`;
const scratch3Floats = new Float32Array(3);
const scratchVec3 = new geometry_core_1.Vector3d();
const scratchPoint3 = new geometry_core_1.Point3d();
function setPointsFromFrustum(skyGeometry, frustum) {
    const wp = skyGeometry.worldPos;
    let mid = frustum.getCorner(imodeljs_common_1.Npc.LeftBottomRear).interpolate(0.5, frustum.getCorner(imodeljs_common_1.Npc.LeftBottomFront), scratchPoint3);
    wp[0] = mid.x;
    wp[1] = mid.y;
    wp[2] = mid.z;
    mid = frustum.getCorner(imodeljs_common_1.Npc.RightBottomRear).interpolate(0.5, frustum.getCorner(imodeljs_common_1.Npc.RightBottomFront), scratchPoint3);
    wp[3] = mid.x;
    wp[4] = mid.y;
    wp[5] = mid.z;
    mid = frustum.getCorner(imodeljs_common_1.Npc.RightTopRear).interpolate(0.5, frustum.getCorner(imodeljs_common_1.Npc.RightTopFront), scratchPoint3);
    wp[6] = mid.x;
    wp[7] = mid.y;
    wp[8] = mid.z;
    mid = frustum.getCorner(imodeljs_common_1.Npc.LeftTopRear).interpolate(0.5, frustum.getCorner(imodeljs_common_1.Npc.LeftTopFront), scratchPoint3);
    wp[9] = mid.x;
    wp[10] = mid.y;
    wp[11] = mid.z;
}
/** @internal */
function createSkySphereProgram(context, isGradient) {
    const builder = ViewportQuad_1.createViewportQuadBuilder(false);
    if (isGradient) {
        builder.addFunctionComputedVarying("v_gradientValue", 5 /* Vec4 */, "computeGradientValue", computeGradientValue);
        builder.addGlobal("horizonSize", 2 /* Float */, 3 /* Both */, "0.0015", true);
    }
    else
        builder.addInlineComputedVarying("v_eyeToVert", 4 /* Vec3 */, computeEyeToVert);
    const vert = builder.vert;
    vert.addAttribute("a_worldPos", 4 /* Vec3 */, (shaderProg) => {
        shaderProg.addAttribute("a_worldPos", (attr, params) => {
            // Send in the corners of the view in world space.
            const geom = params.geometry;
            bentleyjs_core_1.assert(geom instanceof CachedGeometry_1.SkySphereViewportQuadGeometry);
            const skyGeometry = geom;
            setPointsFromFrustum(skyGeometry, params.target.planFrustum);
            skyGeometry.bind();
            attr.enableArray(skyGeometry.worldPosBuff, 3, GL_1.GL.DataType.Float, false, 0, 0);
        });
    });
    vert.addUniform("u_worldEye", 4 /* Vec3 */, (shader) => {
        shader.addGraphicUniform("u_worldEye", (uniform, params) => {
            const frustum = params.target.planFrustum;
            if (2 /* Perspective */ === params.target.frustumUniforms.type) {
                // compute eye point from frustum.
                const farLowerLeft = frustum.getCorner(imodeljs_common_1.Npc.LeftBottomRear);
                const nearLowerLeft = frustum.getCorner(imodeljs_common_1.Npc.LeftBottomFront);
                const scale = 1.0 / (1.0 - params.target.planFraction);
                const zVec = geometry_core_1.Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratchVec3);
                const cameraPosition = Target_1.fromSumOf(farLowerLeft, zVec, scale, scratchPoint3);
                scratch3Floats[0] = cameraPosition.x;
                scratch3Floats[1] = cameraPosition.y;
                scratch3Floats[2] = cameraPosition.z;
                uniform.setUniform3fv(scratch3Floats);
            }
            else {
                const delta = geometry_core_1.Vector3d.createStartEnd(frustum.getCorner(imodeljs_common_1.Npc.LeftBottomRear), frustum.getCorner(imodeljs_common_1.Npc.LeftBottomFront));
                const pseudoCameraHalfAngle = 22.5;
                const diagonal = frustum.getCorner(imodeljs_common_1.Npc.LeftBottomRear).distance(frustum.getCorner(imodeljs_common_1.Npc.RightTopRear));
                const focalLength = diagonal / (2 * Math.atan(pseudoCameraHalfAngle * geometry_core_1.Angle.radiansPerDegree));
                const worldEye = geometry_core_1.Point3d.createAdd3Scaled(frustum.getCorner(imodeljs_common_1.Npc.LeftBottomRear), .5, frustum.getCorner(imodeljs_common_1.Npc.RightTopRear), .5, delta, focalLength / delta.magnitude());
                scratch3Floats[0] = worldEye.x;
                scratch3Floats[1] = worldEye.y;
                scratch3Floats[2] = worldEye.z;
                uniform.setUniform3fv(scratch3Floats);
            }
        });
    });
    if (isGradient) {
        vert.addUniform("u_skyParams", 4 /* Vec3 */, (shader) => {
            shader.addGraphicUniform("u_skyParams", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform3fv(geom.typeAndExponents);
            });
        });
        vert.addUniform("u_zOffset", 2 /* Float */, (shader) => {
            shader.addGraphicUniform("u_zOffset", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform1f(geom.zOffset);
            });
        });
    }
    const frag = builder.frag;
    if (isGradient) {
        frag.addUniform("u_skyParams", 4 /* Vec3 */, (shader) => {
            shader.addGraphicUniform("u_skyParams", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform3fv(geom.typeAndExponents);
            });
        });
        frag.addUniform("u_zenithColor", 4 /* Vec3 */, (shader) => {
            shader.addGraphicUniform("u_zenithColor", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform3fv(geom.zenithColor);
            });
        });
        frag.addUniform("u_skyColor", 4 /* Vec3 */, (shader) => {
            shader.addGraphicUniform("u_skyColor", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform3fv(geom.skyColor);
            });
        });
        frag.addUniform("u_groundColor", 4 /* Vec3 */, (shader) => {
            shader.addGraphicUniform("u_groundColor", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform3fv(geom.groundColor);
            });
        });
        frag.addUniform("u_nadirColor", 4 /* Vec3 */, (shader) => {
            shader.addGraphicUniform("u_nadirColor", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform3fv(geom.nadirColor);
            });
        });
        frag.set(1 /* ComputeBaseColor */, computeSkySphereColorGradient);
    }
    else {
        frag.addUniform("s_skyTxtr", 8 /* Sampler2D */, (shader) => {
            shader.addGraphicUniform("s_skyTxtr", (uniform, params) => {
                const geom = params.geometry;
                if (undefined !== geom.skyTexture)
                    geom.skyTexture.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.Zero);
                else
                    System_1.System.instance.ensureSamplerBound(uniform, RenderFlags_1.TextureUnit.FeatureSymbology);
            });
        });
        frag.addUniform("u_zOffset", 2 /* Float */, (shader) => {
            shader.addGraphicUniform("u_zOffset", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform1f(geom.zOffset);
            });
        });
        frag.addUniform("u_rotation", 2 /* Float */, (shader) => {
            shader.addGraphicUniform("u_rotation", (uniform, params) => {
                const geom = params.geometry;
                uniform.setUniform1f(geom.rotation);
            });
        });
        frag.set(1 /* ComputeBaseColor */, computeSkySphereColorTexture);
    }
    frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    builder.vert.headerComment = "// ----- SkySphere -----";
    builder.frag.headerComment = "// ----- SkySphere -----";
    return builder.buildProgram(context);
}
exports.createSkySphereProgram = createSkySphereProgram;


/***/ }),

/***/ "./lib/render/webgl/glsl/SolarShadowMapping.js":
/*!*****************************************************!*\
  !*** ./lib/render/webgl/glsl/SolarShadowMapping.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const computeShadowPos = "vec4 proj = u_shadowProj * MAT_MODEL * rawPosition; v_shadowPos = proj.xyz/proj.w;";
const scratchShadowParams = new Float32Array(4); // Color RGB, Shadow bias.
const scratchShadowDir = new Float32Array(3);
const scratchDirection = new geometry_core_1.Vector3d();
const applySolarShadowMap = `
  if (v_shadowPos.x < 0.0 || v_shadowPos.x > 1.0 || v_shadowPos.y < 0.0 || v_shadowPos.y > 1.0 || v_shadowPos.x < 0.0 || v_shadowPos.z < 0.0)
    return baseColor;

  float cosTheta = clamp(abs(dot(normalize(v_n), u_shadowDir)), 0.0, 1.0);
  float biasScale = isSurfaceBitSet(kSurfaceBit_HasNormals) ? (.1 + max(tan(acos(cosTheta)), 10.0)) : 1.0;

  float shadowDepth = 1.0 - biasScale * u_shadowParams.w  - TEXTURE(s_shadowSampler, v_shadowPos.xy).r;
  return (v_shadowPos.z > shadowDepth) ?  baseColor : vec4(u_shadowParams.rgb * baseColor.rgb, baseColor.a);
  `;
/** @internal */
function addSolarShadowMap(builder) {
    const frag = builder.frag;
    const vert = builder.vert;
    frag.addUniform("s_shadowSampler", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("s_shadowSampler", (uniform, params) => {
            const shadowMap = params.target.solarShadowMap;
            bentleyjs_core_1.assert(undefined !== shadowMap && undefined !== shadowMap.depthTexture);
            shadowMap.depthTexture.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.ShadowMap);
        });
    });
    frag.addUniform("u_shadowParams", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_shadowParams", (uniform, params) => {
            const shadowMap = params.target.solarShadowMap;
            bentleyjs_core_1.assert(undefined !== shadowMap);
            const colors = shadowMap.settings.color.colors;
            scratchShadowParams[0] = colors.r / 255.0;
            scratchShadowParams[1] = colors.g / 255.0;
            scratchShadowParams[2] = colors.b / 255.0;
            scratchShadowParams[3] = shadowMap.settings.bias;
            uniform.setUniform4fv(scratchShadowParams);
        });
    });
    frag.addUniform("u_shadowDir", 4 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_shadowDir", (uniform, params) => {
            const shadowMap = params.target.solarShadowMap;
            const mv = params.modelViewMatrix;
            const worldDirection = shadowMap.direction;
            scratchDirection.x = mv.m00 * worldDirection.x + mv.m01 * worldDirection.y + mv.m02 * worldDirection.z;
            scratchDirection.y = mv.m10 * worldDirection.x + mv.m11 * worldDirection.y + mv.m12 * worldDirection.z;
            scratchDirection.z = mv.m20 * worldDirection.x + mv.m21 * worldDirection.y + mv.m22 * worldDirection.z;
            scratchDirection.normalizeInPlace();
            scratchShadowDir[0] = scratchDirection.x;
            scratchShadowDir[1] = scratchDirection.y;
            scratchShadowDir[2] = scratchDirection.z;
            uniform.setUniform3fv(scratchShadowDir);
        });
    });
    vert.addUniform("u_shadowProj", 7 /* Mat4 */, (prog) => {
        prog.addGraphicUniform("u_shadowProj", (uniform, params) => {
            const shadowMap = params.target.solarShadowMap;
            bentleyjs_core_1.assert(undefined !== shadowMap);
            uniform.setMatrix4(shadowMap.projectionMatrix);
        });
    });
    Vertex_1.addModelMatrix(vert);
    builder.addInlineComputedVarying("v_shadowPos", 4 /* Vec3 */, computeShadowPos);
    frag.set(13 /* ApplySolarShadowMap */, applySolarShadowMap);
}
exports.addSolarShadowMap = addSolarShadowMap;


/***/ }),

/***/ "./lib/render/webgl/glsl/Surface.js":
/*!******************************************!*\
  !*** ./lib/render/webgl/glsl/Surface.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Animation_1 = __webpack_require__(/*! ./Animation */ "./lib/render/webgl/glsl/Animation.js");
const Decode_1 = __webpack_require__(/*! ./Decode */ "./lib/render/webgl/glsl/Decode.js");
const Color_1 = __webpack_require__(/*! ./Color */ "./lib/render/webgl/glsl/Color.js");
const Lighting_1 = __webpack_require__(/*! ./Lighting */ "./lib/render/webgl/glsl/Lighting.js");
const FeatureSymbology_1 = __webpack_require__(/*! ./FeatureSymbology */ "./lib/render/webgl/glsl/FeatureSymbology.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Material_1 = __webpack_require__(/*! ../Material */ "./lib/render/webgl/Material.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const PlanarClassification_1 = __webpack_require__(/*! ./PlanarClassification */ "./lib/render/webgl/glsl/PlanarClassification.js");
const SolarShadowMapping_1 = __webpack_require__(/*! ./SolarShadowMapping */ "./lib/render/webgl/glsl/SolarShadowMapping.js");
const FloatRGBA_1 = __webpack_require__(/*! ../FloatRGBA */ "./lib/render/webgl/FloatRGBA.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const sampleSurfaceTexture = `
  vec4 sampleSurfaceTexture() {
    // Textures do NOT contain premultiplied alpha. Multiply in shader.
    vec4 texColor = TEXTURE(s_texture, v_texCoord);
    return applyPreMultipliedAlpha(texColor);
  }
`;
// u_matRgb.a = 1.0 if color overridden by material, 0.0 otherwise.
// u_matAlpha.y = 1.0 if alpha overridden by material.
// if this is a raster glyph, the sampled color has already been modified - do not modify further.
const applyMaterialOverrides = `
  float useMatColor = 1.0 - extractSurfaceBit(kSurfaceBit_IgnoreMaterial);
  vec4 matColor = mix(baseColor, vec4(u_matRgb.rgb * baseColor.a, baseColor.a), useMatColor * u_matRgb.a);
  matColor = mix(matColor, adjustPreMultipliedAlpha(matColor, u_matAlpha.x), useMatColor * u_matAlpha.y);
  float textureWeight = u_textureWeight * extractSurfaceBit(kSurfaceBit_HasTexture) * (1.0 - u_applyGlyphTex);
  return mix(matColor, g_surfaceTexel, textureWeight);
`;
/** @internal */
function addMaterial(frag) {
    // ###TODO: We could pack rgb, alpha, and override flags into two floats.
    frag.addFunction(Fragment_1.GLSLFragment.revertPreMultipliedAlpha);
    frag.addFunction(Fragment_1.GLSLFragment.adjustPreMultipliedAlpha);
    frag.set(2 /* ApplyMaterialOverrides */, applyMaterialOverrides);
    frag.addUniform("u_matRgb", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_matRgb", (uniform, params) => {
            const mat = params.target.currentViewFlags.materials && params.geometry.material ? params.geometry.material : Material_1.Material.default;
            uniform.setUniform4fv(mat.diffuseUniform);
        });
    });
    frag.addUniform("u_matAlpha", 3 /* Vec2 */, (prog) => {
        prog.addGraphicUniform("u_matAlpha", (uniform, params) => {
            const mat = params.target.currentViewFlags.materials && params.geometry.material ? params.geometry.material : Material_1.Material.default;
            uniform.setUniform2fv(mat.alphaUniform);
        });
    });
    frag.addUniform("u_textureWeight", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_textureWeight", (uniform, params) => {
            const mat = params.target.currentViewFlags.materials && params.geometry.material ? params.geometry.material : Material_1.Material.default;
            uniform.setUniform1f(mat.textureWeight);
        });
    });
}
exports.addMaterial = addMaterial;
const computePosition = `
  vec4 pos = MAT_MV * rawPos;
  v_pos = pos.xyz;
  return u_proj * pos;
`;
function createCommon(instanced, animated, classified, shadowable) {
    const builder = new ShaderBuilder_1.ProgramBuilder(instanced ? 3 /* InstancedVertexTable */ : 1 /* VertexTable */);
    const vert = builder.vert;
    if (animated)
        Animation_1.addAnimation(vert, true);
    if (classified)
        PlanarClassification_1.addColorPlanarClassifier(builder);
    if (shadowable)
        SolarShadowMapping_1.addSolarShadowMap(builder);
    Vertex_1.addProjectionMatrix(vert);
    Vertex_1.addModelViewMatrix(vert);
    builder.addVarying("v_pos", 4 /* Vec3 */);
    vert.set(4 /* ComputePosition */, computePosition);
    return builder;
}
/** @internal */
function createSurfaceHiliter(instanced, classified) {
    const builder = createCommon(instanced, 0 /* No */, classified, 0 /* No */);
    addSurfaceFlags(builder, true);
    addTexture(builder, 0 /* No */);
    if (classified) {
        PlanarClassification_1.addHilitePlanarClassifier(builder);
        builder.vert.addGlobal("feature_ignore_material", 0 /* Boolean */, "false");
        builder.frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    }
    else
        FeatureSymbology_1.addSurfaceHiliter(builder);
    return builder;
}
exports.createSurfaceHiliter = createSurfaceHiliter;
// nvidia hardware incorrectly interpolates varying floats when we send the same exact value for every vertex...
const extractSurfaceBit = `
float extractSurfaceBit(float flag) { return extractNthBit(floor(v_surfaceFlags + 0.5), flag); }
`;
const isSurfaceBitSet = `
bool isSurfaceBitSet(float flag) { return 0.0 != extractSurfaceBit(flag); }
`;
function addSurfaceFlagsLookup(builder) {
    builder.addConstant("kSurfaceBit_HasTexture", 2 /* Float */, "0.0");
    builder.addConstant("kSurfaceBit_ApplyLighting", 2 /* Float */, "1.0");
    builder.addConstant("kSurfaceBit_HasNormals", 2 /* Float */, "2.0");
    builder.addConstant("kSurfaceBit_IgnoreMaterial", 2 /* Float */, "3.0");
    builder.addConstant("kSurfaceBit_TransparencyThreshold", 2 /* Float */, "4.0");
    builder.addConstant("kSurfaceBit_BackgroundFill", 2 /* Float */, "5.0");
    builder.addConstant("kSurfaceBit_HasColorAndNormal", 2 /* Float */, "6.0");
    builder.addConstant("kSurfaceMask_None", 2 /* Float */, "0.0");
    builder.addConstant("kSurfaceMask_HasTexture", 2 /* Float */, "1.0");
    builder.addConstant("kSurfaceMask_ApplyLighting", 2 /* Float */, "2.0");
    builder.addConstant("kSurfaceMask_HasNormals", 2 /* Float */, "4.0");
    builder.addConstant("kSurfaceMask_IgnoreMaterial", 2 /* Float */, "8.0");
    builder.addConstant("kSurfaceMask_TransparencyThreshold", 2 /* Float */, "16.0");
    builder.addConstant("kSurfaceMask_BackgroundFill", 2 /* Float */, "32.0");
    builder.addConstant("kSurfaceMask_HasColorAndNormal", 2 /* Float */, "64.0");
    builder.addFunction(Common_1.GLSLCommon.extractNthBit);
    builder.addFunction(extractSurfaceBit);
    builder.addFunction(isSurfaceBitSet);
}
const getSurfaceFlags = "return u_surfaceFlags;";
const computeSurfaceFlags = `
  float flags = u_surfaceFlags;
  if (feature_ignore_material) {
    bool hasTexture = 0.0 != fract(flags / 2.0); // kSurfaceMask_HasTexture = 1.0...
    if (hasTexture)
      flags -= kSurfaceMask_HasTexture;

    flags += kSurfaceMask_IgnoreMaterial;
  }

  return flags;
`;
/** @internal */
exports.octDecodeNormal = `
vec3 octDecodeNormal(vec2 e) {
  e = e / 255.0 * 2.0 - 1.0;
  vec3 n = vec3(e.x, e.y, 1.0 - abs(e.x) - abs(e.y));
  if (n.z < 0.0) {
    vec2 signNotZero = vec2(n.x >= 0.0 ? 1.0 : -1.0, n.y >= 0.0 ? 1.0 : -1.0);
    n.xy = (1.0 - abs(n.yx)) * signNotZero;
  }

  return normalize(n);
}
`;
const computeNormal = `
  vec2 tc = g_vertexBaseCoords;
  tc.x += 3.0 * g_vert_stepX;
  vec4 enc = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  vec2 normal = mix(g_vertexData2, enc.xy, extractSurfaceBit(kSurfaceBit_HasColorAndNormal));
  return mix(vec3(0.0), normalize(MAT_NORM * octDecodeNormal(normal)), extractSurfaceBit(kSurfaceBit_HasNormals));
`;
const computeAnimatedNormal = `
  if (u_animNormalParams.x >= 0.0)
    return normalize(MAT_NORM * computeAnimationNormal(u_animNormalParams.x, u_animNormalParams.y, u_animNormalParams.z));
` + computeNormal;
const applyBackgroundColor = `
  return mix(baseColor, vec4(u_bgColor.rgb, 1.0), extractSurfaceBit(kSurfaceBit_BackgroundFill));
`;
const computeTexCoord = `
  vec2 tc = g_vertexBaseCoords;
  tc.x += 3.0 * g_vert_stepX;  vec4 rgba = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  vec2 qcoords = vec2(decodeUInt16(rgba.xy), decodeUInt16(rgba.zw));
  return mix(vec2(0.0), unquantize2d(qcoords, u_qTexCoordParams), extractSurfaceBit(kSurfaceBit_HasTexture));
`;
const computeAnimatedTexCoord = `
  if (u_animScalarQParams.x >= 0.0)
    return computeAnimationParam(u_animScalarParams.x, u_animScalarParams.y, u_animScalarParams.z, u_animScalarQParams.x, u_animScalarQParams.y);
` + computeTexCoord;
const getSurfaceColor = `
vec4 getSurfaceColor() { return v_color; }
`;
// If we have texture weight < 1.0 we must compute the element/material color first then mix with texture color
// in ApplyMaterialOverrides(). Do the sample once, here, and store in a global variable for possible later use.
// If a glyph texture, must mix getSurfaceColor() with texture color so texture color alpha is applied 100% and
// surface color rgb is scaled by texture color rgb (latter is full white originally but stretched via mipmapping).
const computeBaseColor = `
  g_surfaceTexel = sampleSurfaceTexture();
  vec4 surfaceColor = getSurfaceColor();

  // Compute color for raster glyph.
  vec4 glyphColor = surfaceColor;
  const vec3 white = vec3(1.0);
  const vec3 epsilon = vec3(0.0001);
  vec3 color = glyphColor.rgb / max(0.0001, glyphColor.a); // revert premultiplied alpha
  vec3 delta = (color + epsilon) - white;

  // set to black if almost white
  glyphColor.rgb *= float(u_reverseWhiteOnWhite <= 0.5 || delta.x <= 0.0 || delta.y <= 0.0 || delta.z <= 0.0);
  glyphColor = vec4(glyphColor.rgb * g_surfaceTexel.rgb, g_surfaceTexel.a);

  // Choose glyph color or unmodified texture sample
  vec4 texColor = mix(g_surfaceTexel, glyphColor, u_applyGlyphTex);

  // If untextured, or textureWeight < 1.0, choose surface color.
  return mix(surfaceColor, texColor, extractSurfaceBit(kSurfaceBit_HasTexture) * floor(u_textureWeight));
`;
function addSurfaceFlags(builder, withFeatureOverrides) {
    builder.addFunctionComputedVarying("v_surfaceFlags", 2 /* Float */, "computeSurfaceFlags", withFeatureOverrides ? computeSurfaceFlags : getSurfaceFlags);
    addSurfaceFlagsLookup(builder.vert);
    addSurfaceFlagsLookup(builder.frag);
    builder.addUniform("u_surfaceFlags", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_surfaceFlags", (uniform, params) => {
            bentleyjs_core_1.assert(undefined !== params.geometry.asSurface);
            const mesh = params.geometry.asSurface;
            const surfFlags = mesh.computeSurfaceFlags(params.programParams);
            uniform.setUniform1f(surfFlags);
        });
    });
}
function addNormal(builder, animated) {
    Vertex_1.addNormalMatrix(builder.vert);
    builder.vert.addFunction(exports.octDecodeNormal);
    builder.addFunctionComputedVarying("v_n", 4 /* Vec3 */, "computeLightingNormal", animated ? computeAnimatedNormal : computeNormal);
}
function addTexture(builder, animated) {
    builder.vert.addFunction(Decode_1.GLSLDecode.unquantize2d);
    builder.addFunctionComputedVarying("v_texCoord", 3 /* Vec2 */, "computeTexCoord", animated ? computeAnimatedTexCoord : computeTexCoord);
    builder.vert.addUniform("u_qTexCoordParams", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_qTexCoordParams", (uniform, params) => {
            const surfGeom = params.geometry.asSurface;
            const surfFlags = surfGeom.computeSurfaceFlags(params.programParams);
            if (0 /* None */ !== (1 /* HasTexture */ & surfFlags)) {
                const uvQParams = surfGeom.lut.uvQParams;
                if (undefined !== uvQParams) {
                    uniform.setUniform4fv(uvQParams);
                }
            }
        });
    });
    builder.frag.addFunction(Fragment_1.GLSLFragment.applyPreMultipliedAlpha);
    builder.frag.addFunction(sampleSurfaceTexture);
    builder.frag.addUniform("s_texture", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("s_texture", (uniform, params) => {
            const surfGeom = params.geometry.asSurface;
            const surfFlags = surfGeom.computeSurfaceFlags(params.programParams);
            if (0 /* None */ !== (1 /* HasTexture */ & surfFlags)) {
                const texture = (params.target.analysisTexture ? params.target.analysisTexture : surfGeom.texture);
                bentleyjs_core_1.assert(undefined !== texture);
                texture.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.SurfaceTexture);
            }
            else {
                System_1.System.instance.ensureSamplerBound(uniform, RenderFlags_1.TextureUnit.SurfaceTexture);
            }
        });
    });
}
const scratchBgColor = FloatRGBA_1.MutableFloatRgb.fromColorDef(imodeljs_common_1.ColorDef.white);
const blackColor = FloatRGBA_1.FloatRgba.fromColorDef(imodeljs_common_1.ColorDef.black);
/** @internal */
function createSurfaceBuilder(feat, isInstanced, isAnimated, isClassified, isShadowable, isEdgeTestNeeded) {
    const builder = createCommon(isInstanced, isAnimated, isClassified, isShadowable);
    Common_1.addShaderFlags(builder);
    FeatureSymbology_1.addFeatureSymbology(builder, feat, 2 /* Overrides */ === feat ? 28 /* Surface */ : 0 /* None */);
    addSurfaceFlags(builder, 2 /* Overrides */ === feat);
    FeatureSymbology_1.addSurfaceDiscard(builder, feat, isEdgeTestNeeded, isClassified);
    addNormal(builder, isAnimated);
    // In HiddenLine mode, we must compute the base color (plus feature overrides etc) in order to get the alpha, then replace with background color (preserving alpha for the transparency threshold test).
    builder.frag.set(4 /* FinalizeBaseColor */, applyBackgroundColor);
    builder.frag.addUniform("u_bgColor", 4 /* Vec3 */, (prog) => {
        prog.addProgramUniform("u_bgColor", (uniform, params) => {
            const bgColor = params.target.bgColor.alpha === 0.0 ? blackColor : params.target.bgColor;
            scratchBgColor.setRgbValues(bgColor.red, bgColor.green, bgColor.blue);
            scratchBgColor.bind(uniform);
        });
    });
    addTexture(builder, isAnimated);
    builder.frag.addUniform("u_applyGlyphTex", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_applyGlyphTex", (uniform, params) => {
            const surfGeom = params.geometry.asSurface;
            const surfFlags = surfGeom.computeSurfaceFlags(params.programParams);
            let isGlyph = false;
            if (0 /* None */ !== (1 /* HasTexture */ & surfFlags))
                isGlyph = surfGeom.isGlyph;
            uniform.setUniform1f(isGlyph ? 1 : 0);
        });
    });
    // Fragment and Vertex
    Color_1.addColor(builder, true);
    // Fragment
    builder.frag.addFunction(getSurfaceColor);
    Lighting_1.addLighting(builder);
    Fragment_1.addWhiteOnWhiteReversal(builder.frag);
    if (0 /* None */ === feat) {
        builder.frag.set(15 /* AssignFragData */, Fragment_1.GLSLFragment.assignFragColor);
    }
    else {
        if (isClassified)
            PlanarClassification_1.addFeaturePlanarClassifier(builder);
        builder.frag.addFunction(Decode_1.GLSLDecode.depthRgb);
        if (isEdgeTestNeeded || isClassified)
            Fragment_1.addPickBufferOutputs(builder.frag);
        else
            Fragment_1.addAltPickBufferOutputs(builder.frag);
    }
    builder.frag.addGlobal("g_surfaceTexel", 5 /* Vec4 */);
    builder.frag.set(1 /* ComputeBaseColor */, computeBaseColor);
    return builder;
}
exports.createSurfaceBuilder = createSurfaceBuilder;
// Target.readPixels() renders everything in opaque pass. It turns off textures for normal surfaces but keeps them for things like 3d view attachment tiles.
// We want to discard fully-transparent pixels of those things during readPixels() so that we don't locate the attachment unless the cursor is over a
// non-transparent pixel of it.
const discardTransparentTexel = `return isSurfaceBitSet(kSurfaceBit_HasTexture) && alpha == 0.0;`;
/** @internal */
function addSurfaceDiscardByAlpha(frag) {
    frag.set(6 /* DiscardByAlpha */, discardTransparentTexel);
}
exports.addSurfaceDiscardByAlpha = addSurfaceDiscardByAlpha;


/***/ }),

/***/ "./lib/render/webgl/glsl/Translucency.js":
/*!***********************************************!*\
  !*** ./lib/render/webgl/glsl/Translucency.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Fragment_1 = __webpack_require__(/*! ./Fragment */ "./lib/render/webgl/glsl/Fragment.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const Common_1 = __webpack_require__(/*! ./Common */ "./lib/render/webgl/glsl/Common.js");
const System_1 = __webpack_require__(/*! ../System */ "./lib/render/webgl/System.js");
const computeAlphaWeight = `
float computeAlphaWeight(float a, float flatAlpha) {
  // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:
  // http://jcgt.org/published/0002/02/09/
  // We are using Equation 10 from the above paper.  Equation 10 directly uses screen-space gl_FragCoord.z.

  // flatAlphaWeight bit is set if we want to apply OIT transparency using a constant Z value of 1.
  // computeLinearDepth() removes the perspective and puts z in linear [0..1]
  float z = mix(computeLinearDepth(v_eyeSpace.z), 1.0, flatAlpha);
  return pow(a + 0.01, 4.0) + max(1e-2, 3.0 * 1e3 * pow(z, 3.0));
}
`;
const computeOutputs = `
  float flatAlpha = extractShaderBit(kShaderBit_OITFlatAlphaWeight);
  float scaleOutput = extractShaderBit(kShaderBit_OITScaleOutput);
  vec3 Ci = baseColor.rgb;
  float ai = min(0.99, baseColor.a); // OIT algorithm does not nicely handle a=1
  float wzi = computeAlphaWeight(ai, flatAlpha);

  // If we are scaling output into the 0 to 1 range, we use the maximum output of the alpha weight function.
  float outputScale = mix(1.0, 1.0 / 3001.040604, scaleOutput);

  vec4 output0 = vec4(Ci * wzi * outputScale, ai);
  vec4 output1 = vec4(ai * wzi * outputScale);
`;
const assignFragData = computeOutputs + `
  FragColor0 = output0;
  FragColor1 = output1;
`;
const assignFragColor = computeOutputs + `
  FragColor = (0 == u_renderTargetIndex) ? output0 : output1;
`;
/** @internal */
function addTranslucency(prog) {
    const frag = prog.frag;
    Common_1.addEyeSpace(prog);
    Common_1.addFrustum(prog);
    Vertex_1.addModelViewMatrix(prog.vert);
    frag.addFunction(Fragment_1.GLSLFragment.computeLinearDepth);
    frag.addFunction(computeAlphaWeight);
    if (System_1.System.instance.capabilities.supportsMRTTransparency) {
        frag.addDrawBuffersExtension();
        frag.set(15 /* AssignFragData */, assignFragData);
    }
    else {
        Fragment_1.addRenderTargetIndex(frag);
        frag.set(15 /* AssignFragData */, assignFragColor);
    }
}
exports.addTranslucency = addTranslucency;


/***/ }),

/***/ "./lib/render/webgl/glsl/Vertex.js":
/*!*****************************************!*\
  !*** ./lib/render/webgl/glsl/Vertex.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const Matrix_1 = __webpack_require__(/*! ../Matrix */ "./lib/render/webgl/Matrix.js");
const RenderFlags_1 = __webpack_require__(/*! ../RenderFlags */ "./lib/render/webgl/RenderFlags.js");
const Decode_1 = __webpack_require__(/*! ./Decode */ "./lib/render/webgl/glsl/Decode.js");
const LookupTable_1 = __webpack_require__(/*! ./LookupTable */ "./lib/render/webgl/glsl/LookupTable.js");
const Instancing_1 = __webpack_require__(/*! ./Instancing */ "./lib/render/webgl/glsl/Instancing.js");
const initializeVertLUTCoords = `
  g_vertexLUTIndex = decodeUInt32(a_pos);
  g_vertexBaseCoords = compute_vert_coords(g_vertexLUTIndex);
`;
const unquantizePosition = `
vec4 unquantizePosition(vec3 pos, vec3 origin, vec3 scale) { return vec4(origin + scale * pos, 1.0); }
`;
const unquantizeVertexPosition = `
vec4 unquantizeVertexPosition(vec3 pos, vec3 origin, vec3 scale) { return unquantizePosition(pos, origin, scale); }
`;
// Need to read 2 rgba values to obtain 6 16-bit integers for position
const unquantizeVertexPositionFromLUTPrelude = `
vec4 unquantizeVertexPosition(vec3 encodedIndex, vec3 origin, vec3 scale) {
  vec2 tc = g_vertexBaseCoords;
  vec4 enc1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
  tc.x += g_vert_stepX;
  vec4 enc2 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);
`;
const computeFeatureIndexCoords = `
  tc.x += g_vert_stepX;
  g_featureIndexCoords = tc;
`;
const unquantizeVertexPositionFromLUTPostlude = `
  vec3 qpos = vec3(decodeUInt16(enc1.xy), decodeUInt16(enc1.zw), decodeUInt16(enc2.xy));
  g_vertexData2 = enc2.zw;
  return unquantizePosition(qpos, origin, scale);
}
`;
const computeLineWeight = "\nfloat computeLineWeight() { return g_lineWeight; }\n";
const computeLineCode = "\nfloat computeLineCode() { return g_lineCode; }\n";
const scratchMVPMatrix = new Matrix_1.Matrix4();
/** @internal */
function addModelViewProjectionMatrix(vert) {
    if (vert.usesInstancedGeometry) {
        addModelViewMatrix(vert);
        addProjectionMatrix(vert);
        vert.addGlobal("g_mvp", 7 /* Mat4 */);
        vert.addInitializer("g_mvp = u_proj * g_mv;");
    }
    else {
        vert.addUniform("u_mvp", 7 /* Mat4 */, (prog) => {
            prog.addGraphicUniform("u_mvp", (uniform, params) => {
                const mvp = params.projectionMatrix.clone(scratchMVPMatrix);
                mvp.multiplyBy(params.modelViewMatrix);
                uniform.setMatrix4(mvp);
            });
        });
    }
}
exports.addModelViewProjectionMatrix = addModelViewProjectionMatrix;
/** @internal */
function addProjectionMatrix(vert) {
    vert.addUniform("u_proj", 7 /* Mat4 */, (prog) => {
        prog.addProgramUniform("u_proj", (uniform, params) => {
            uniform.setMatrix4(params.projectionMatrix);
        });
    });
}
exports.addProjectionMatrix = addProjectionMatrix;
const scratchRTC = new Float32Array(3);
const computeInstancedModelMatrix = `
  g_instancedModelMatrix = g_modelMatrixRTC;
  g_instancedModelMatrix[3].xyz = u_instancedRTC;
`;
/** @internal */
function addModelMatrix(vert) {
    if (vert.usesInstancedGeometry) {
        bentleyjs_core_1.assert(undefined !== vert.find("g_modelMatrixRTC")); // set up in VertexShaderBuilder constructor...
        if (undefined === vert.find("g_instancedModelMatrix")) {
            vert.addUniform("u_instancedRTC", 4 /* Vec3 */, (prog) => {
                prog.addGraphicUniform("u_instancedRTC", (uniform, params) => {
                    const rtc = params.geometry.asInstanced.rtcCenter;
                    scratchRTC[0] = rtc.x;
                    scratchRTC[1] = rtc.y;
                    scratchRTC[2] = rtc.z;
                    uniform.setUniform3fv(scratchRTC);
                });
            });
            vert.addGlobal("g_instancedModelMatrix", 7 /* Mat4 */);
            vert.addInitializer(computeInstancedModelMatrix);
        }
    }
    else if (undefined === vert.find("u_modelMatrix")) {
        vert.addUniform("u_modelMatrix", 7 /* Mat4 */, (prog) => {
            // ###TODO: We only need 3 rows, not 4...
            prog.addGraphicUniform("u_modelMatrix", (uniform, params) => {
                uniform.setMatrix4(params.modelMatrix);
            });
        });
    }
}
exports.addModelMatrix = addModelMatrix;
/** @internal */
function addModelViewMatrix(vert) {
    if (vert.usesInstancedGeometry) {
        vert.addUniform("u_instanced_modelView", 7 /* Mat4 */, (prog) => {
            prog.addGraphicUniform("u_instanced_modelView", (uniform, params) => {
                uniform.setMatrix4(params.modelViewMatrix);
            });
        });
        vert.addGlobal("g_mv", 7 /* Mat4 */);
        vert.addInitializer("g_mv = u_instanced_modelView * g_modelMatrixRTC;");
    }
    else {
        vert.addUniform("u_mv", 7 /* Mat4 */, (prog) => {
            // ###TODO: We only need 3 rows, not 4...
            prog.addGraphicUniform("u_mv", (uniform, params) => {
                uniform.setMatrix4(params.modelViewMatrix);
            });
        });
    }
}
exports.addModelViewMatrix = addModelViewMatrix;
/** @internal */
function addNormalMatrix(vert) {
    vert.addGlobal("g_nmx", 6 /* Mat3 */);
    vert.addInitializer("g_nmx = mat3(MAT_MV);");
}
exports.addNormalMatrix = addNormalMatrix;
const scratchLutParams = new Float32Array(4);
function addPositionFromLUT(vert) {
    vert.addGlobal("g_vertexLUTIndex", 2 /* Float */);
    vert.addGlobal("g_vertexBaseCoords", 3 /* Vec2 */);
    vert.addGlobal("g_vertexData2", 3 /* Vec2 */);
    vert.addFunction(Decode_1.GLSLDecode.uint32);
    vert.addFunction(Decode_1.GLSLDecode.uint16);
    if (vert.usesInstancedGeometry) {
        vert.addFunction(unquantizeVertexPositionFromLUTPrelude + unquantizeVertexPositionFromLUTPostlude);
    }
    else {
        vert.addGlobal("g_featureIndexCoords", 3 /* Vec2 */);
        vert.addFunction(unquantizeVertexPositionFromLUTPrelude + computeFeatureIndexCoords + unquantizeVertexPositionFromLUTPostlude);
    }
    vert.addUniform("u_vertLUT", 8 /* Sampler2D */, (prog) => {
        prog.addGraphicUniform("u_vertLUT", (uniform, params) => {
            (params.geometry.asLUT).lut.texture.bindSampler(uniform, RenderFlags_1.TextureUnit.VertexLUT);
        });
    });
    vert.addUniform("u_vertParams", 5 /* Vec4 */, (prog) => {
        prog.addGraphicUniform("u_vertParams", (uniform, params) => {
            bentleyjs_core_1.assert(undefined !== params.geometry.asLUT);
            const lut = params.geometry.asLUT.lut;
            const lutParams = scratchLutParams;
            lutParams[0] = lut.texture.width;
            lutParams[1] = lut.texture.height;
            lutParams[2] = lut.numRgbaPerVertex;
            lutParams[3] = lut.numVertices;
            uniform.setUniform4fv(lutParams);
        });
    });
    LookupTable_1.addLookupTable(vert, "vert", "u_vertParams.z");
    vert.addInitializer(initializeVertLUTCoords);
}
/** @internal */
function addPosition(vert, fromLUT) {
    vert.addFunction(unquantizePosition);
    vert.addAttribute("a_pos", 4 /* Vec3 */, (prog) => {
        prog.addAttribute("a_pos", (attr, params) => { params.geometry.bindVertexArray(attr); });
    });
    vert.addUniform("u_qScale", 4 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_qScale", (uniform, params) => {
            uniform.setUniform3fv(params.geometry.qScale);
        });
    });
    vert.addUniform("u_qOrigin", 4 /* Vec3 */, (prog) => {
        prog.addGraphicUniform("u_qOrigin", (uniform, params) => {
            uniform.setUniform3fv(params.geometry.qOrigin);
        });
    });
    if (!fromLUT) {
        vert.addFunction(unquantizeVertexPosition);
    }
    else {
        addPositionFromLUT(vert);
    }
}
exports.addPosition = addPosition;
/** @internal */
function addAlpha(vert) {
    vert.addUniform("u_hasAlpha", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_hasAlpha", (uniform, params) => {
            uniform.setUniform1f(5 /* Translucent */ === params.geometry.getRenderPass(params.target) ? 1.0 : 0.0);
        });
    });
}
exports.addAlpha = addAlpha;
/** @internal */
function addLineWeight(vert) {
    vert.addUniform("u_lineWeight", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_lineWeight", (attr, params) => {
            attr.setUniform1f(params.geometry.getLineWeight(params.programParams));
        });
    });
    vert.addGlobal("g_lineWeight", 2 /* Float */);
    if (vert.usesInstancedGeometry) {
        Instancing_1.addInstanceOverrides(vert);
        vert.addInitializer("g_lineWeight = mix(u_lineWeight, a_instanceOverrides.g, extractInstanceBit(kOvrBit_Weight));");
    }
    else {
        vert.addInitializer("g_lineWeight = u_lineWeight;");
    }
    vert.addFunction(computeLineWeight);
}
exports.addLineWeight = addLineWeight;
/** @internal */
function replaceLineWeight(vert, func) {
    vert.replaceFunction(computeLineWeight, func);
}
exports.replaceLineWeight = replaceLineWeight;
/** @internal */
function addLineCode(vert) {
    vert.addUniform("u_lineCode", 2 /* Float */, (prog) => {
        prog.addGraphicUniform("u_lineCode", (attr, params) => {
            attr.setUniform1f(params.geometry.getLineCode(params.programParams));
        });
    });
    vert.addGlobal("g_lineCode", 2 /* Float */);
    if (vert.usesInstancedGeometry) {
        Instancing_1.addInstanceOverrides(vert);
        vert.addInitializer("g_lineCode = mix(u_lineCode, a_instanceOverrides.b, extractInstanceBit(kOvrBit_LineCode));");
    }
    else {
        vert.addInitializer("g_lineCode = u_lineCode;");
    }
    vert.addFunction(computeLineCode);
}
exports.addLineCode = addLineCode;
/** @internal */
function replaceLineCode(vert, func) {
    vert.replaceFunction(computeLineCode, func);
}
exports.replaceLineCode = replaceLineCode;
/** @internal */
var GLSLVertex;
(function (GLSLVertex) {
    // This vertex belongs to a triangle which should not be rendered. Produce a degenerate triangle.
    // Also place it outside NDC range (for GL_POINTS)
    const discardVertex = `
{
  gl_Position = vec4(2.0, 2.0, 2.0, 1.0);
  return;
}
`;
    GLSLVertex.earlyDiscard = `  if (checkForEarlyDiscard(rawPosition))` + discardVertex;
    GLSLVertex.discard = `  if (checkForDiscard())` + discardVertex;
    GLSLVertex.lateDiscard = `  if (checkForLateDiscard())` + discardVertex;
})(GLSLVertex = exports.GLSLVertex || (exports.GLSLVertex = {}));


/***/ }),

/***/ "./lib/render/webgl/glsl/Viewport.js":
/*!*******************************************!*\
  !*** ./lib/render/webgl/glsl/Viewport.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const Matrix_1 = __webpack_require__(/*! ../Matrix */ "./lib/render/webgl/Matrix.js");
const Viewport_1 = __webpack_require__(/*! ../../../Viewport */ "./lib/Viewport.js");
const Vertex_1 = __webpack_require__(/*! ./Vertex */ "./lib/render/webgl/glsl/Vertex.js");
const RenderPass_1 = __webpack_require__(/*! ./RenderPass */ "./lib/render/webgl/glsl/RenderPass.js");
/** @internal */
function addViewport(shader) {
    shader.addUniform("u_viewport", 5 /* Vec4 */, (prog) => {
        prog.addProgramUniform("u_viewport", (uniform, params) => {
            const rect = params.target.viewRect;
            const vp = [rect.left, rect.bottom, rect.width, rect.height];
            uniform.setUniform4fv(vp);
        });
    });
}
exports.addViewport = addViewport;
const viewportMatrix = new Matrix_1.Matrix4();
const prevViewRect = new Viewport_1.ViewRect();
const nearDepthRange = 0.0;
const farDepthRange = 1.0;
function computeViewportTransformation(viewRect) {
    if (viewRect.equals(prevViewRect))
        return viewportMatrix;
    prevViewRect.setFrom(viewRect);
    const x = viewRect.left;
    const y = viewRect.top;
    const width = viewRect.width;
    const height = viewRect.height;
    const halfWidth = width * 0.5;
    const halfHeight = height * 0.5;
    const halfDepth = (farDepthRange - nearDepthRange) * 0.5;
    const column0Row0 = halfWidth;
    const column1Row1 = halfHeight;
    const column2Row2 = halfDepth;
    const column3Row0 = x + halfWidth;
    const column3Row1 = y + halfHeight;
    const column3Row2 = nearDepthRange + halfDepth;
    const column3Row3 = 1.0;
    const mat = Matrix_1.Matrix4.fromValues(column0Row0, 0.0, 0.0, column3Row0, 0.0, column1Row1, 0.0, column3Row1, 0.0, 0.0, column2Row2, column3Row2, 0.0, 0.0, 0.0, column3Row3, viewportMatrix);
    return mat;
}
/** @internal */
function addViewportTransformation(shader) {
    shader.addUniform("u_viewportTransformation", 7 /* Mat4 */, (prog) => {
        prog.addProgramUniform("u_viewportTransformation", (uniform, params) => {
            uniform.setMatrix4(computeViewportTransformation(params.target.viewRect));
        });
    });
}
exports.addViewportTransformation = addViewportTransformation;
const modelToWindowCoordinates = `
vec4 modelToWindowCoordinates(vec4 position, vec4 next) {
  if (kRenderPass_ViewOverlay == u_renderPass || kRenderPass_Background == u_renderPass) {
    vec4 q = MAT_MVP * position;
    q.xyz /= q.w;
    q.xyz = (u_viewportTransformation * vec4(q.xyz, 1.0)).xyz;
    return q;
  }

  // Negative values are in front of the camera (visible).
  float s_maxZ = -u_frustum.x;            // use -near (front) plane for segment drop test since u_frustum's near & far are pos.
  vec4  q = MAT_MV * position;              // eye coordinates.
  vec4  n = MAT_MV * next;

  if (q.z > s_maxZ) {
    if (n.z > s_maxZ)
      return vec4(0.0, 0.0,  1.0, 0.0);   // Entire segment behind eye.

    float t = (s_maxZ - q.z) / (n.z - q.z);

    q.x += t * (n.x - q.x);
    q.y += t * (n.y - q.y);
    q.z = s_maxZ;                       // q.z + (s_maxZ - q.z) * (s_maxZ - q.z) / n.z - q.z
  }
  q = u_proj * q;
  q.xyz /= q.w;                           // normalized device coords
  q.xyz = (u_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coords
  return q;
  }
`;
/** @internal */
function addModelToWindowCoordinates(vert) {
    Vertex_1.addModelViewProjectionMatrix(vert);
    addViewportTransformation(vert);
    RenderPass_1.addRenderPass(vert);
    vert.addFunction(modelToWindowCoordinates);
}
exports.addModelToWindowCoordinates = addModelToWindowCoordinates;


/***/ }),

/***/ "./lib/render/webgl/glsl/ViewportQuad.js":
/*!***********************************************!*\
  !*** ./lib/render/webgl/glsl/ViewportQuad.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module WebGL */
Object.defineProperty(exports, "__esModule", { value: true });
const ShaderBuilder_1 = __webpack_require__(/*! ../ShaderBuilder */ "./lib/render/webgl/ShaderBuilder.js");
// Positions are in NDC [-1..1]. Compute UV params in [0..1]
const computeTexCoord = "v_texCoord = (rawPosition.xy + 1.0) * 0.5;";
const computePosition = "return rawPos;";
function addTexture(prog) {
    prog.addInlineComputedVarying("v_texCoord", 3 /* Vec2 */, computeTexCoord);
}
/** @internal */
function createViewportQuadBuilder(textured) {
    const prog = new ShaderBuilder_1.ProgramBuilder();
    prog.vert.set(4 /* ComputePosition */, computePosition);
    if (textured) {
        addTexture(prog);
    }
    return prog;
}
exports.createViewportQuadBuilder = createViewportQuadBuilder;


/***/ }),

/***/ "./lib/rendering.js":
/*!**************************!*\
  !*** ./lib/rendering.js ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
__export(__webpack_require__(/*! ./render/primitives/geometry/GeometryPrimitives */ "./lib/render/primitives/geometry/GeometryPrimitives.js"));
__export(__webpack_require__(/*! ./render/primitives/geometry/GeometryList */ "./lib/render/primitives/geometry/GeometryList.js"));
__export(__webpack_require__(/*! ./render/primitives/geometry/GeometryListBuilder */ "./lib/render/primitives/geometry/GeometryListBuilder.js"));
__export(__webpack_require__(/*! ./render/primitives/geometry/GeometryAccumulator */ "./lib/render/primitives/geometry/GeometryAccumulator.js"));
__export(__webpack_require__(/*! ./render/primitives/mesh/MeshBuilder */ "./lib/render/primitives/mesh/MeshBuilder.js"));
__export(__webpack_require__(/*! ./render/primitives/mesh/MeshBuilderMap */ "./lib/render/primitives/mesh/MeshBuilderMap.js"));
__export(__webpack_require__(/*! ./render/primitives/mesh/MeshPrimitives */ "./lib/render/primitives/mesh/MeshPrimitives.js"));
__export(__webpack_require__(/*! ./render/primitives/ColorMap */ "./lib/render/primitives/ColorMap.js"));
__export(__webpack_require__(/*! ./render/primitives/DisplayParams */ "./lib/render/primitives/DisplayParams.js"));
__export(__webpack_require__(/*! ./render/primitives/PointCloudPrimitive */ "./lib/render/primitives/PointCloudPrimitive.js"));
__export(__webpack_require__(/*! ./render/primitives/Primitives */ "./lib/render/primitives/Primitives.js"));
__export(__webpack_require__(/*! ./render/primitives/Strokes */ "./lib/render/primitives/Strokes.js"));
__export(__webpack_require__(/*! ./render/primitives/Polyface */ "./lib/render/primitives/Polyface.js"));
__export(__webpack_require__(/*! ./render/primitives/VertexKey */ "./lib/render/primitives/VertexKey.js"));
__export(__webpack_require__(/*! ./render/primitives/VertexTable */ "./lib/render/primitives/VertexTable.js"));
__export(__webpack_require__(/*! ./render/FeatureSymbology */ "./lib/render/FeatureSymbology.js"));
__export(__webpack_require__(/*! ./render/GraphicBuilder */ "./lib/render/GraphicBuilder.js"));
__export(__webpack_require__(/*! ./render/System */ "./lib/render/System.js"));


/***/ }),

/***/ "./lib/tile/B3dmTileIO.js":
/*!********************************!*\
  !*** ./lib/tile/B3dmTileIO.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
const TileIO_1 = __webpack_require__(/*! ./TileIO */ "./lib/tile/TileIO.js");
const GltfTileIO_1 = __webpack_require__(/*! ./GltfTileIO */ "./lib/tile/GltfTileIO.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
/**
 * Provides facilities for deserializing Batched 3D Model (B3dm) tiles.
 * @internal
 */
var B3dmTileIO;
(function (B3dmTileIO) {
    /** @internal */
    class Header extends TileIO_1.TileIO.Header {
        constructor(stream) {
            super(stream);
            this.length = stream.nextUint32;
            this.featureTableJsonLength = stream.nextUint32;
            this.featureTableBinaryLength = stream.nextUint32;
            this.batchTableJsonLength = stream.nextUint32;
            this.batchTableBinaryLength = stream.nextUint32;
            // Keep this legacy check in for now since a lot of tilesets are still using the old header.
            // Legacy header #1: [batchLength] [batchTableByteLength]
            // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]
            // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]
            // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.
            // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table Json will exceed this length.
            // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead
            if (this.batchTableJsonLength >= 570425344) {
                // First legacy check
                stream.curPos = 20;
                // batchLength = this.featureTableJsonLength;
                this.batchTableJsonLength = this.featureTableBinaryLength;
                this.batchTableBinaryLength = 0;
                this.featureTableJsonLength = 0;
                this.featureTableBinaryLength = 0;
            }
            else if (this.batchTableBinaryLength >= 570425344) {
                // Second legacy check
                stream.curPos = 24;
                this.batchTableJsonLength = this.featureTableJsonLength;
                this.batchTableBinaryLength = this.featureTableBinaryLength;
                this.featureTableJsonLength = 0;
                this.featureTableBinaryLength = 0;
            }
            if (0 !== this.featureTableJsonLength) {
                const sceneStrData = stream.nextBytes(this.featureTableJsonLength);
                const sceneStr = bentleyjs_core_1.utf8ToString(sceneStrData);
                if (sceneStr)
                    this.featureTableJson = JSON.parse(sceneStr);
            }
            stream.advance(this.featureTableBinaryLength);
            stream.advance(this.batchTableJsonLength);
            stream.advance(this.batchTableBinaryLength);
            if (stream.isPastTheEnd)
                this.invalidate();
        }
        get isValid() { return 1835283298 /* B3dm */ === this.format; }
    }
    B3dmTileIO.Header = Header;
    /**
     * Deserializes a B3DM tile.
     * @internal
     */
    class Reader extends GltfTileIO_1.GltfTileIO.Reader {
        constructor(props, iModel, modelId, is3d, system, _range, _isLeaf, _transformToRoot, isCanceled) {
            super(props, iModel, modelId, is3d, system, imodeljs_common_1.BatchType.Primary, isCanceled);
            this._range = _range;
            this._isLeaf = _isLeaf;
            this._transformToRoot = _transformToRoot;
        }
        static create(stream, iModel, modelId, is3d, range, system, yAxisUp, isLeaf, transformToRoot, isCanceled) {
            const header = new Header(stream);
            if (!header.isValid)
                return undefined;
            if (header.featureTableJson && Array.isArray(header.featureTableJson.RTC_CENTER)) {
                const returnToCenterTransform = geometry_core_1.Transform.createTranslationXYZ(header.featureTableJson.RTC_CENTER[0], header.featureTableJson.RTC_CENTER[1], header.featureTableJson.RTC_CENTER[2]);
                transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(returnToCenterTransform) : returnToCenterTransform;
            }
            const props = GltfTileIO_1.GltfTileIO.ReaderProps.create(stream, yAxisUp);
            return undefined !== props ? new Reader(props, iModel, modelId, is3d, system, range, isLeaf, transformToRoot, isCanceled) : undefined;
        }
        async read() {
            // TBD... Create an actual feature table if one exists.  For now we are only reading tiles from scalable mesh which have no features.
            // NB: For reality models with no batch table, we want the model ID in the feature table
            const featureTable = new imodeljs_common_1.FeatureTable(1, this._modelId, this._type);
            const feature = new imodeljs_common_1.Feature(this._modelId);
            featureTable.insert(feature);
            await this.loadTextures();
            if (this._isCanceled)
                return Promise.resolve({ readStatus: 7 /* Canceled */, isLeaf: this._isLeaf });
            return Promise.resolve(this.readGltfAndCreateGraphics(this._isLeaf, featureTable, this._range, this._transformToRoot));
        }
        readFeatures(features, _json) {
            const feature = new imodeljs_common_1.Feature(this._modelId);
            features.add(feature, 1);
            return true;
        }
    }
    B3dmTileIO.Reader = Reader;
})(B3dmTileIO = exports.B3dmTileIO || (exports.B3dmTileIO = {}));


/***/ }),

/***/ "./lib/tile/CompositeTileIO.js":
/*!*************************************!*\
  !*** ./lib/tile/CompositeTileIO.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
const TileIO_1 = __webpack_require__(/*! ./TileIO */ "./lib/tile/TileIO.js");
/**
 * Provides facilities for deserializing Composite (cmpt) tiles.
 * @internal
 */
var CompositeTileIO;
(function (CompositeTileIO) {
    /** @internal */
    class Header extends TileIO_1.TileIO.Header {
        constructor(stream) {
            super(stream);
            this.length = stream.nextUint32;
            this.tileCount = stream.nextUint32;
            this.tilePosition = stream.curPos;
            if (stream.isPastTheEnd)
                this.invalidate();
        }
        get isValid() { return 1953525091 /* Cmpt */ === this.format; }
    }
    CompositeTileIO.Header = Header;
})(CompositeTileIO = exports.CompositeTileIO || (exports.CompositeTileIO = {}));


/***/ }),

/***/ "./lib/tile/GltfTileIO.js":
/*!********************************!*\
  !*** ./lib/tile/GltfTileIO.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const TileIO_1 = __webpack_require__(/*! ./TileIO */ "./lib/tile/TileIO.js");
const DisplayParams_1 = __webpack_require__(/*! ../render/primitives/DisplayParams */ "./lib/render/primitives/DisplayParams.js");
const Primitives_1 = __webpack_require__(/*! ../render/primitives/Primitives */ "./lib/render/primitives/Primitives.js");
const MeshPrimitives_1 = __webpack_require__(/*! ../render/primitives/mesh/MeshPrimitives */ "./lib/render/primitives/mesh/MeshPrimitives.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const System_1 = __webpack_require__(/*! ../render/System */ "./lib/render/System.js");
const ImageUtil_1 = __webpack_require__(/*! ../ImageUtil */ "./lib/ImageUtil.js");
// tslint:disable:no-const-enum
/* -----------------------------------
 * To restore the use of web workers to decode jpeg, locate and uncomment the three sections by searching for "webworker".
  import { WorkerOperation, WebWorkerManager } from "../WebWorkerManager";
  ------------------------------------ */
// Defer Draco for now.   import { DracoDecoder } from "./DracoDecoder";
/** Provides facilities for deserializing tiles in the [glTF tile format](https://www.khronos.org/gltf/).
 * @internal
 */
var GltfTileIO;
(function (GltfTileIO) {
    /** Header preceding glTF tile data.
     * @internal
     */
    class Header extends TileIO_1.TileIO.Header {
        constructor(stream) {
            super(stream);
            this.scenePosition = 0;
            this.sceneStrLength = 0;
            this.binaryPosition = 0;
            this.gltfLength = stream.nextUint32;
            this.sceneStrLength = stream.nextUint32;
            const value5 = stream.nextUint32;
            // Early versions of the reality data tile publisher incorrectly put version 2 into header - handle these old tiles
            // validating the chunk type.
            if (this.version === 2 /* Version2 */ && value5 === 0 /* Gltf1SceneFormat */)
                this.version = 1 /* Version1 */;
            if (this.version === 1 /* Version1 */) {
                const gltfSceneFormat = value5;
                if (0 /* Gltf1SceneFormat */ !== gltfSceneFormat) {
                    this.invalidate();
                    return;
                }
                this.scenePosition = stream.curPos;
                this.binaryPosition = stream.curPos + this.sceneStrLength;
            }
            else if (this.version === 2 /* Version2 */) {
                const sceneChunkType = value5;
                this.scenePosition = stream.curPos;
                stream.curPos = stream.curPos + this.sceneStrLength;
                const binaryLength = stream.nextUint32;
                const binaryChunkType = stream.nextUint32;
                if (1313821514 /* JSON */ !== sceneChunkType || 5130562 /* Binary */ !== binaryChunkType || 0 === binaryLength) {
                    this.invalidate();
                    return;
                }
                this.binaryPosition = stream.curPos;
            }
            else {
                this.invalidate();
            }
        }
        get isValid() { return 1179937895 /* Gltf */ === this.format; }
    }
    GltfTileIO.Header = Header;
    /**
     * A chunk of binary data exposed as a typed array.
     * The count member indicates how many elements exist. This may be less than this.buffer.length due to padding added to the
     * binary stream to ensure correct alignment.
     * @internal
     */
    class BufferData {
        constructor(buffer, count) {
            this.buffer = buffer;
            this.count = count;
        }
        /**
         * Create a BufferData of the desired type. The actual type may differ from the desired type - for example, small 32-bit integers
         * may be represented as 8-bit or 16-bit integers instead.
         * If the actual data type is not convertible to the desired type, this function returns undefined.
         */
        static create(bytes, actualType, expectedType, count) {
            if (expectedType !== actualType) {
                // Some data is stored in smaller data types to save space if no values exceed the maximum of the smaller type.
                switch (expectedType) {
                    case 5126 /* Float */:
                    case 5121 /* UnsignedByte */:
                        return undefined;
                    case 5123 /* UnsignedShort */:
                        if (5121 /* UnsignedByte */ !== actualType)
                            return undefined;
                        break;
                    case 5125 /* UInt32 */:
                        if (5121 /* UnsignedByte */ !== actualType && 5123 /* UnsignedShort */ !== actualType)
                            return undefined;
                        break;
                }
            }
            const data = this.createDataBuffer(bytes, actualType);
            return undefined !== data ? new BufferData(data, count) : undefined;
        }
        static createDataBuffer(bytes, actualType) {
            // NB: Endianness of typed array data is determined by the 'platform byte order'. Actual data is always little-endian.
            // We are assuming little-endian platform. If we find a big-endian platform, we'll need to use a DataView instead.
            switch (actualType) {
                case 5121 /* UnsignedByte */:
                    return bytes;
                case 5123 /* UnsignedShort */:
                    return new Uint16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2);
                case 5125 /* UInt32 */:
                    return new Uint32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4);
                case 5126 /* Float */:
                    return new Float32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4);
                default:
                    return undefined;
            }
        }
    }
    GltfTileIO.BufferData = BufferData;
    /**
     * A view of a chunk of a tile's binary data containing an array of elements of a specific data type.
     * The count member indicates how many elements exist; this may be smaller than this.data.length.
     * The count member may also indicate the number of elements of a type containing more than one value of the
     * underlying type. For example, a buffer of 4 32-bit floating point 'vec2' elements will have a count of 4,
     * but its data member will contain 8 32-bit floating point values (2 per vec2).
     * The accessor member may contain additional JSON data specific to a particular buffer.
     * @internal
     */
    class BufferView {
        constructor(data, count, type, accessor) {
            this.data = data;
            this.count = count;
            this.type = type;
            this.accessor = accessor;
        }
        get byteLength() { return this.data.length; }
        toBufferData(desiredType) {
            return BufferData.create(this.data, this.type, desiredType, this.count);
        }
    }
    GltfTileIO.BufferView = BufferView;
    /** Data required for creating a Reader capable of deserializing [glTF tile data](https://www.khronos.org/gltf/).
     * @internal
     */
    class ReaderProps {
        constructor(buffer, binaryData, accessors, bufferViews, scene, nodes, meshes, materials, extensions, samplers, techniques, yAxisUp) {
            this.buffer = buffer;
            this.binaryData = binaryData;
            this.accessors = accessors;
            this.bufferViews = bufferViews;
            this.scene = scene;
            this.nodes = nodes;
            this.meshes = meshes;
            this.materials = materials;
            this.extensions = extensions;
            this.samplers = samplers;
            this.techniques = techniques;
            this.yAxisUp = yAxisUp;
        }
        /** Attempt to construct a new ReaderProps from the binary data beginning at the supplied stream's current read position. */
        static create(buffer, yAxisUp = false) {
            const header = new Header(buffer);
            if (!header.isValid)
                return undefined;
            const binaryData = new Uint8Array(buffer.arrayBuffer, header.binaryPosition);
            buffer.curPos = header.scenePosition;
            const sceneStrData = buffer.nextBytes(header.sceneStrLength);
            const sceneStr = bentleyjs_core_1.utf8ToString(sceneStrData);
            if (undefined === sceneStr)
                return undefined;
            try {
                const sceneValue = JSON.parse(sceneStr);
                const nodes = bentleyjs_core_1.JsonUtils.asObject(sceneValue.nodes);
                const meshes = bentleyjs_core_1.JsonUtils.asObject(sceneValue.meshes);
                const materialValues = bentleyjs_core_1.JsonUtils.asObject(sceneValue.materials);
                const accessors = bentleyjs_core_1.JsonUtils.asObject(sceneValue.accessors);
                const bufferViews = bentleyjs_core_1.JsonUtils.asObject(sceneValue.bufferViews);
                const extensions = bentleyjs_core_1.JsonUtils.asObject(sceneValue.extensions);
                const samplers = bentleyjs_core_1.JsonUtils.asObject(sceneValue.samplers);
                const techniques = bentleyjs_core_1.JsonUtils.asObject(sceneValue.techniques);
                if (undefined === meshes)
                    return undefined;
                return new ReaderProps(buffer, binaryData, accessors, bufferViews, sceneValue, nodes, meshes, materialValues, extensions, samplers, techniques, yAxisUp);
            }
            catch (e) {
                return undefined;
            }
        }
    }
    GltfTileIO.ReaderProps = ReaderProps;
    /* -----------------------------------
       This is part of the webworker option.
  
      // input is Uint8Array, the result is an ImageBitMap.
      class ImageDecodeWorkerOperation extends WorkerOperation {
        constructor(imageBytes: ArrayBuffer, imageMimeType: string) {
          super("imageBytesToImageBitmap", [imageBytes, imageMimeType], [imageBytes]);
        }
      }
  
      declare var BUILD_SEMVER: string;
    -------------------------------------- */
    /** Deserializes [(glTF tile data](https://www.khronos.org/gltf/).
     * @internal
     */
    class Reader {
        constructor(props, iModel, modelId, is3d, system, type = imodeljs_common_1.BatchType.Primary, isCanceled) {
            this._buffer = props.buffer;
            this._scene = props.scene;
            this._binaryData = props.binaryData;
            this._accessors = props.accessors;
            this._bufferViews = props.bufferViews;
            this._meshes = props.meshes;
            this._nodes = props.nodes;
            this._materialValues = props.materials;
            this._samplers = props.samplers;
            this._techniques = props.techniques;
            this._yAxisUp = props.yAxisUp;
            this._returnToCenter = this.extractReturnToCenter(props.extensions);
            this._textures = props.scene.textures;
            this._images = props.scene.images;
            this._renderMaterials = props.scene.renderMaterials;
            this._namedTextures = props.scene.namedTextures;
            this._iModel = iModel;
            this._modelId = modelId;
            this._is3d = is3d;
            this._system = system;
            this._type = type;
            this._canceled = isCanceled;
        }
        get _isCanceled() { return undefined !== this._canceled && this._canceled(this); }
        get _isVolumeClassifier() { return imodeljs_common_1.BatchType.VolumeClassifier === this._type; }
        readGltfAndCreateGraphics(isLeaf, featureTable, contentRange, transformToRoot, sizeMultiplier, instances) {
            if (this._isCanceled)
                return { readStatus: 7 /* Canceled */, isLeaf, sizeMultiplier };
            const childNodes = new Set();
            for (const key of Object.keys(this._nodes)) {
                const node = this._nodes[key];
                if (node.children)
                    for (const child of node.children)
                        childNodes.add(child.toString());
            }
            const renderGraphicList = [];
            let readStatus = 1 /* InvalidTileData */;
            for (const nodeKey of Object.keys(this._nodes))
                if (!childNodes.has(nodeKey))
                    if (0 /* Success */ !== (readStatus = this.readNodeAndCreateGraphics(renderGraphicList, this._nodes[nodeKey], featureTable, undefined, instances)))
                        return { readStatus, isLeaf };
            if (0 === renderGraphicList.length)
                return { readStatus: 1 /* InvalidTileData */, isLeaf };
            let renderGraphic;
            if (1 === renderGraphicList.length)
                renderGraphic = renderGraphicList[0];
            else
                renderGraphic = this._system.createGraphicList(renderGraphicList);
            const range = contentRange.clone();
            if (undefined !== this._returnToCenter) {
                range.low.plusXYZ(-this._returnToCenter[0], -this._returnToCenter[1], -this._returnToCenter[2], range.low);
                range.high.plusXYZ(-this._returnToCenter[0], -this._returnToCenter[1], -this._returnToCenter[2], range.high);
            }
            renderGraphic = this._system.createBatch(renderGraphic, System_1.PackedFeatureTable.pack(featureTable), range);
            if (undefined !== this._returnToCenter || this._yAxisUp || undefined !== transformToRoot) {
                const branch = new System_1.GraphicBranch();
                branch.add(renderGraphic);
                let transform = (undefined === this._returnToCenter) ? geometry_core_1.Transform.createIdentity() : geometry_core_1.Transform.createTranslationXYZ(this._returnToCenter[0], this._returnToCenter[1], this._returnToCenter[2]);
                if (this._yAxisUp)
                    transform = transform.multiplyTransformMatrix3d(geometry_core_1.Matrix3d.createRotationAroundVector(geometry_core_1.Vector3d.create(1.0, 0.0, 0.0), geometry_core_1.Angle.createRadians(geometry_core_1.Angle.piOver2Radians)));
                if (undefined !== transformToRoot)
                    transform = transformToRoot.multiplyTransformTransform(transform);
                renderGraphic = this._system.createBranch(branch, transform);
            }
            return {
                readStatus,
                isLeaf,
                sizeMultiplier,
                contentRange,
                graphic: renderGraphic,
            };
        }
        readNodeAndCreateGraphics(renderGraphicList, node, featureTable, parentTransform, instances) {
            if (undefined === node)
                return 1 /* InvalidTileData */;
            let thisTransform = parentTransform;
            if (Array.isArray(node.matrix)) {
                const jTrans = node.matrix;
                const nodeTransform = geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.create(jTrans[12], jTrans[13], jTrans[14]), geometry_core_1.Matrix3d.createRowValues(jTrans[0], jTrans[4], jTrans[8], jTrans[1], jTrans[5], jTrans[9], jTrans[2], jTrans[6], jTrans[10]));
                thisTransform = thisTransform ? thisTransform.multiplyTransformTransform(nodeTransform) : nodeTransform;
            }
            const meshKey = node.meshes ? node.meshes : node.mesh;
            if (undefined !== meshKey) {
                const nodeMesh = this._meshes[meshKey];
                if (nodeMesh) {
                    const meshGraphicArgs = new MeshPrimitives_1.MeshGraphicArgs();
                    const geometryCollection = new TileIO_1.TileIO.GeometryCollection(new MeshPrimitives_1.MeshList(featureTable), true, false);
                    for (const primitive of nodeMesh.primitives) {
                        const geometry = this.readMeshPrimitive(primitive, featureTable);
                        if (undefined !== geometry)
                            geometryCollection.meshes.push(geometry);
                    }
                    let renderGraphic;
                    if (!geometryCollection.isEmpty) {
                        if (1 === geometryCollection.meshes.length) {
                            renderGraphic = geometryCollection.meshes[0].getGraphics(meshGraphicArgs, this._system, instances);
                        }
                        else {
                            const thisList = [];
                            for (const mesh of geometryCollection.meshes) {
                                renderGraphic = mesh.getGraphics(meshGraphicArgs, this._system, instances);
                                if (undefined !== renderGraphic)
                                    thisList.push(renderGraphic);
                            }
                            if (0 !== thisList.length)
                                renderGraphic = this._system.createGraphicList(thisList);
                        }
                        if (renderGraphic) {
                            if (thisTransform && !thisTransform.isIdentity) {
                                const branch = new System_1.GraphicBranch();
                                branch.add(renderGraphic);
                                renderGraphic = this._system.createBranch(branch, thisTransform);
                            }
                            renderGraphicList.push(renderGraphic);
                        }
                    }
                }
            }
            if (node.children) {
                for (const child of node.children)
                    this.readNodeAndCreateGraphics(renderGraphicList, this._nodes[child], featureTable, thisTransform, instances);
            }
            return 0 /* Success */;
        }
        getBufferView(json, accessorName) {
            try {
                const accessorValue = bentleyjs_core_1.JsonUtils.asString(json[accessorName]);
                const accessor = 0 < accessorValue.length ? bentleyjs_core_1.JsonUtils.asObject(this._accessors[accessorValue]) : undefined;
                const bufferViewAccessorValue = undefined !== accessor ? bentleyjs_core_1.JsonUtils.asString(accessor.bufferView) : "";
                const bufferView = 0 < bufferViewAccessorValue.length ? bentleyjs_core_1.JsonUtils.asObject(this._bufferViews[bufferViewAccessorValue]) : undefined;
                if (undefined === accessor)
                    return undefined;
                const type = accessor.componentType;
                let dataSize = 0;
                switch (type) {
                    case 5121 /* UnsignedByte */:
                        dataSize = 1;
                        break;
                    case 5123 /* UnsignedShort */:
                        dataSize = 2;
                        break;
                    case 5125 /* UInt32 */:
                    case 5126 /* Float */:
                        dataSize = 4;
                        break;
                    default:
                        return undefined;
                }
                let componentCount = 1;
                switch (accessor.type) {
                    case "VEC3":
                        componentCount = 3;
                        break;
                    case "VEC2":
                        componentCount = 2;
                        break;
                }
                const offset = ((bufferView && bufferView.byteOffset) ? bufferView.byteOffset : 0) + (accessor.byteOffset ? accessor.byteOffset : 0);
                const length = componentCount * dataSize * accessor.count;
                // If the data is misaligned (Scalable mesh tile publisher) use slice to copy -- else use subarray.
                // assert(0 === offset % dataSize);
                const bytes = (0 === (this._binaryData.byteOffset + offset) % dataSize) ? this._binaryData.subarray(offset, offset + length) : this._binaryData.slice(offset, offset + length);
                return new BufferView(bytes, accessor.count, type, accessor);
            }
            catch (e) {
                return undefined;
            }
        }
        readBufferData32(json, accessorName) { return this.readBufferData(json, accessorName, 5125 /* UInt32 */); }
        readBufferData16(json, accessorName) { return this.readBufferData(json, accessorName, 5123 /* UnsignedShort */); }
        readBufferData8(json, accessorName) { return this.readBufferData(json, accessorName, 5121 /* UnsignedByte */); }
        readBufferDataFloat(json, accessorName) { return this.readBufferData(json, accessorName, 5126 /* Float */); }
        readBufferData(json, accessorName, type) {
            const view = this.getBufferView(json, accessorName);
            return undefined !== view ? view.toBufferData(type) : undefined;
        }
        readFeatureIndices(_json) { return undefined; }
        colorFromJson(values) { return imodeljs_common_1.ColorDef.from(values[0] * 255, values[1] * 255, values[2] * 255, (1.0 - values[3]) * 255); }
        colorFromMaterial(materialJson) {
            if (materialJson) {
                if (materialJson.values && Array.isArray(materialJson.values.color))
                    return this.colorFromJson(materialJson.values.color);
                else if (materialJson.pbrMetallicRoughness && Array.isArray(materialJson.pbrMetallicRoughness.baseColorFactor))
                    return this.colorFromJson(materialJson.pbrMetallicRoughness.baseColorFactor);
                else if (materialJson.extensions && materialJson.extensions.KHR_techniques_webgl && materialJson.extensions.KHR_techniques_webgl.values && materialJson.extensions.KHR_techniques_webgl.values.u_color)
                    return this.colorFromJson(materialJson.extensions.KHR_techniques_webgl.values.u_color);
            }
            return imodeljs_common_1.ColorDef.white.clone();
        }
        createDisplayParams(materialJson, hasBakedLighting) {
            let textureMapping;
            if (undefined !== materialJson) {
                if (materialJson.values && materialJson.values.tex)
                    textureMapping = this.findTextureMapping(materialJson.values.tex); // Bimiums shader value.
                else if (materialJson.extensions && materialJson.extensions.KHR_techniques_webgl && materialJson.extensions.KHR_techniques_webgl.values && materialJson.extensions.KHR_techniques_webgl.values.u_tex)
                    textureMapping = this.findTextureMapping(materialJson.extensions.KHR_techniques_webgl.values.u_tex.index); // Bimiums colorIndex.
                else if (materialJson.diffuseTexture)
                    textureMapping = this.findTextureMapping(materialJson.diffuseTexture.index); // TBD -- real map support with PBR
                else if (materialJson.emissiveTexture)
                    textureMapping = this.findTextureMapping(materialJson.emissiveTexture.index); // TBD -- real map support with PBR
            }
            const color = this.colorFromMaterial(materialJson);
            return new DisplayParams_1.DisplayParams(DisplayParams_1.DisplayParams.Type.Mesh, color, color, 1, imodeljs_common_1.LinePixels.Solid, imodeljs_common_1.FillFlags.Always, undefined, undefined, hasBakedLighting, textureMapping);
        }
        extractReturnToCenter(extensions) {
            if (extensions === undefined) {
                return undefined;
            }
            const cesiumRtc = bentleyjs_core_1.JsonUtils.asObject(extensions.CESIUM_RTC);
            if (cesiumRtc === undefined)
                return undefined;
            const rtc = bentleyjs_core_1.JsonUtils.asArray(cesiumRtc.center);
            return (rtc[0] === 0.0 && rtc[1] === 0.0 && rtc[2] === 0.0) ? undefined : rtc;
        }
        readMeshPrimitive(primitive, featureTable) {
            const materialName = bentleyjs_core_1.JsonUtils.asString(primitive.material);
            const hasBakedLighting = undefined === primitive.attributes.NORMAL;
            const materialValue = 0 < materialName.length ? bentleyjs_core_1.JsonUtils.asObject(this._materialValues[materialName]) : undefined;
            const displayParams = undefined !== materialValue ? this.createDisplayParams(materialValue, hasBakedLighting) : undefined;
            if (undefined === displayParams)
                return undefined;
            let primitiveType = -1;
            const meshMode = bentleyjs_core_1.JsonUtils.asInt(primitive.mode, 4 /* Triangles */);
            switch (meshMode) {
                case 1 /* Lines */:
                    primitiveType = 1 /* Polyline */;
                    return undefined; // Needs work...
                    break;
                case 4 /* Triangles */:
                    primitiveType = 0 /* Mesh */;
                    break;
                default:
                    bentleyjs_core_1.assert(false);
                    return undefined;
            }
            const isPlanar = bentleyjs_core_1.JsonUtils.asBool(primitive.isPlanar);
            const isVolumeClassifier = this._isVolumeClassifier;
            const mesh = MeshPrimitives_1.Mesh.create({
                displayParams,
                features: undefined !== featureTable ? new MeshPrimitives_1.Mesh.Features(featureTable) : undefined,
                type: primitiveType,
                range: geometry_core_1.Range3d.createNull(),
                is2d: !this._is3d,
                isPlanar,
                hasBakedLighting,
                isVolumeClassifier,
            });
            // We don't have real colormap - just load material color.  This will be used if non-Bentley
            // tile or fit the color table is uniform. For a non-Bentley, non-Uniform, we'll set the
            // uv parameters to pick the colors out of the color map texture.
            mesh.colorMap.insert(displayParams.fillColor.tbgr); // White...
            const colorIndices = this.readBufferData16(primitive.attributes, "_COLORINDEX");
            if (undefined !== colorIndices) {
                let texStep;
                if (materialValue.values !== undefined && Array.isArray(materialValue.values.texStep))
                    texStep = materialValue.values.texStep;
                else if (materialValue.extensions && materialValue.extensions.KHR_techniques_webgl && materialValue.extensions.KHR_techniques_webgl.values && Array.isArray(materialValue.extensions.KHR_techniques_webgl.values.u_texStep))
                    texStep = materialValue.extensions.KHR_techniques_webgl.values.u_texStep;
                if (texStep)
                    for (let i = 0; i < colorIndices.count; i++)
                        mesh.uvParams.push(new geometry_core_1.Point2d(texStep[1] + texStep[0] * colorIndices.buffer[i], .5));
            }
            if (undefined !== mesh.features && !this.readFeatures(mesh.features, primitive))
                return undefined;
            if (primitive.extensions && primitive.extensions.KHR_draco_mesh_compression) {
                return undefined; // Defer Draco support until moved to web worker.
                /*
                const dracoExtension = primitive.extensions.KHR_draco_mesh_compression;
                const bufferView = this._bufferViews[dracoExtension.bufferView];
                if (undefined === bufferView) return undefined;
                const bufferData = this._binaryData.subarray(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);
        
                return  DracoDecoder.readDracoMesh(mesh, primitive, bufferData); */
            }
            if (!this.readVertices(mesh.points, primitive))
                return undefined;
            switch (primitiveType) {
                case 0 /* Mesh */: {
                    if (!this.readMeshIndices(mesh, primitive))
                        return undefined;
                    if (!displayParams.ignoreLighting && !this.readNormals(mesh.normals, primitive.attributes, "NORMAL"))
                        return undefined;
                    if (0 === mesh.uvParams.length)
                        this.readUVParams(mesh.uvParams, primitive.attributes, "TEXCOORD_0");
                    break;
                }
                case 1 /* Polyline */:
                case 2 /* Point */: {
                    if (undefined !== mesh.polylines && !this.readPolylines(mesh.polylines, primitive, "indices", 2 /* Point */ === primitiveType))
                        return undefined;
                    break;
                }
                default: {
                    bentleyjs_core_1.assert(false, "unhandled primitive type");
                    return undefined;
                }
            }
            if (displayParams.textureMapping && 0 === mesh.uvParams.length)
                return undefined;
            return mesh;
        }
        readVertices(positions, primitive) {
            const view = this.getBufferView(primitive.attributes, "POSITION");
            if (undefined === view)
                return false;
            if (5126 /* Float */ === view.type) {
                const buffer = view.toBufferData(5126 /* Float */);
                if (undefined === buffer)
                    return false;
                const range = geometry_core_1.Range3d.createNull();
                for (let i = 0; i < buffer.buffer.length;)
                    range.extendXYZ(buffer.buffer[i++], buffer.buffer[i++], buffer.buffer[i++]);
                positions.reset(imodeljs_common_1.QParams3d.fromRange(range));
                const scratchPoint = new geometry_core_1.Point3d();
                for (let i = 0, j = 0; i < buffer.count; i++) {
                    scratchPoint.set(buffer.buffer[j++], buffer.buffer[j++], buffer.buffer[j++]);
                    positions.add(scratchPoint);
                }
            }
            else {
                if (5123 /* UnsignedShort */ !== view.type)
                    return false;
                const extensions = bentleyjs_core_1.JsonUtils.asObject(view.accessor.extensions);
                const quantized = undefined !== extensions ? bentleyjs_core_1.JsonUtils.asObject(extensions.WEB3D_quantized_attributes) : undefined;
                if (undefined === quantized)
                    return false;
                const rangeMin = bentleyjs_core_1.JsonUtils.asArray(quantized.decodedMin);
                const rangeMax = bentleyjs_core_1.JsonUtils.asArray(quantized.decodedMax);
                if (undefined === rangeMin || undefined === rangeMax)
                    return false;
                const buffer = view.toBufferData(5123 /* UnsignedShort */);
                if (undefined === buffer)
                    return false;
                const qpt = imodeljs_common_1.QPoint3d.fromScalars(0, 0, 0);
                positions.reset(imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.create(geometry_core_1.Point3d.create(rangeMin[0], rangeMin[1], rangeMin[2]), geometry_core_1.Point3d.create(rangeMax[0], rangeMax[1], rangeMax[2]))));
                for (let i = 0; i < view.count; i++) {
                    const index = i * 3; // 3 uint16 per QPoint3d...
                    qpt.setFromScalars(buffer.buffer[index], buffer.buffer[index + 1], buffer.buffer[index + 2]);
                    positions.push(qpt);
                }
            }
            return true;
        }
        readIndices(json, accessorName) {
            const data = this.readBufferData32(json, accessorName);
            if (undefined === data)
                return undefined;
            const indices = [];
            for (let i = 0; i < data.count; i++)
                indices.push(data.buffer[i]);
            return indices;
        }
        readFeatures(features, json) {
            const indices = this.readFeatureIndices(json);
            if (undefined === indices)
                return false;
            features.setIndices(indices);
            return true;
        }
        readMeshIndices(mesh, json) {
            const data = this.readBufferData32(json, "indices");
            if (undefined === data)
                return false;
            bentleyjs_core_1.assert(0 === data.count % 3);
            const triangle = new Primitives_1.Triangle(false);
            for (let i = 0; i < data.count; i += 3) {
                triangle.setIndices(data.buffer[i], data.buffer[i + 1], data.buffer[i + 2]);
                mesh.addTriangle(triangle);
            }
            return true;
        }
        readNormals(normals, json, accessorName) {
            const view = this.getBufferView(json, accessorName);
            if (undefined === view)
                return false;
            switch (view.type) {
                case 5126 /* Float */: {
                    const data = view.toBufferData(5126 /* Float */);
                    if (undefined === data)
                        return false;
                    const scratchNormal = new geometry_core_1.Vector3d();
                    for (let i = 0, j = 0; i < data.count; i++) {
                        scratchNormal.set(data.buffer[j++], data.buffer[j++], data.buffer[j++]);
                        normals.push(imodeljs_common_1.OctEncodedNormal.fromVector(scratchNormal));
                    }
                    return true;
                }
                case 5121 /* UnsignedByte */: {
                    const data = view.toBufferData(5121 /* UnsignedByte */);
                    if (undefined === data)
                        return false;
                    // ###TODO: we shouldn't have to allocate OctEncodedNormal objects...just use uint16s / numbers...
                    for (let i = 0; i < data.count; i++) {
                        // ###TODO? not clear why ray writes these as pairs of uint8...
                        const index = i * 2;
                        const normal = data.buffer[index] | (data.buffer[index + 1] << 8);
                        normals.push(new imodeljs_common_1.OctEncodedNormal(normal));
                    }
                    return true;
                }
                default:
                    return false;
            }
        }
        readUVParams(params, json, accessorName) {
            const view = this.getBufferView(json, accessorName);
            let data;
            if (view === undefined) {
                return false;
            }
            switch (view.type) {
                case 5126 /* Float */: {
                    data = this.readBufferDataFloat(json, accessorName);
                    for (let i = 0; i < data.count; i++) {
                        const index = 2 * i; // 2 float per param...
                        params.push(new geometry_core_1.Point2d(data.buffer[index], data.buffer[index + 1]));
                    }
                    break;
                }
                case 5123 /* UnsignedShort */: {
                    // TBD.   Support quantized UVParams in shaders rather than expanding here.
                    const extensions = bentleyjs_core_1.JsonUtils.asObject(view.accessor.extensions);
                    const quantized = undefined !== extensions ? bentleyjs_core_1.JsonUtils.asObject(extensions.WEB3D_quantized_attributes) : undefined;
                    if (undefined === quantized)
                        return false;
                    const decodeMatrix = bentleyjs_core_1.JsonUtils.asArray(quantized.decodeMatrix);
                    if (undefined === decodeMatrix) {
                        return false;
                    }
                    const qData = view.toBufferData(5123 /* UnsignedShort */);
                    if (undefined === qData) {
                        return false;
                    }
                    for (let i = 0; i < view.count; i++) {
                        const index = 2 * i; // 3 uint16 per QPoint3d...
                        params.push(new geometry_core_1.Point2d(qData.buffer[index] * decodeMatrix[0] + decodeMatrix[6], qData.buffer[index + 1] * decodeMatrix[4] + decodeMatrix[7]));
                    }
                    break;
                }
            }
            return true;
        }
        readPolylines(polylines, json, accessorName, disjoint) {
            const view = this.getBufferView(json, accessorName);
            if (undefined === view)
                return false;
            const numIndices = new Uint32Array(1);
            const niBytes = new Uint8Array(numIndices.buffer);
            const index16 = new Uint16Array(1);
            const i16Bytes = new Uint8Array(index16.buffer);
            const index32 = new Uint32Array(1);
            const i32Bytes = new Uint8Array(index32.buffer);
            let ndx = 0;
            for (let p = 0; p < view.count; ++p) {
                for (let b = 0; b < 4; ++b)
                    niBytes[b] = view.data[ndx++];
                if (!disjoint && numIndices[0] < 2)
                    continue;
                const indices = new Array(numIndices[0]);
                if (5123 /* UnsignedShort */ === view.type) {
                    for (let i = 0; i < numIndices[0]; ++i) {
                        for (let b = 0; b < 2; ++b)
                            i16Bytes[b] = view.data[ndx++];
                        indices[i] = index16[0];
                    }
                    // Need to skip padding if we had an odd number of 16-bit indices.
                    if (0 !== numIndices[0] % 2)
                        ndx += 2;
                }
                else if (5125 /* UInt32 */ === view.type) {
                    for (let i = 0; i < numIndices[0]; ++i) {
                        for (let b = 0; b < 4; ++b)
                            i32Bytes[b] = view.data[ndx++];
                        indices[i] = index32[0];
                    }
                }
                polylines.push(new imodeljs_common_1.MeshPolyline(indices));
            }
            return true;
        }
        async loadTextures() {
            if (undefined === this._textures)
                return Promise.resolve();
            const transparentTextures = new Set();
            for (const name of Object.keys(this._materialValues)) {
                const materialValue = this._materialValues[name];
                let technique;
                if (undefined !== materialValue.values &&
                    undefined !== materialValue.values.tex &&
                    undefined !== materialValue.technique &&
                    undefined !== (technique = this._techniques[materialValue.technique]) &&
                    undefined !== technique.states &&
                    Array.isArray(technique.states.enable)) {
                    for (const enable of technique.states.enable)
                        if (enable === 3042)
                            transparentTextures.add(materialValue.values.tex);
                }
            }
            const promises = new Array();
            for (const name of Object.keys(this._textures))
                promises.push(this.loadTexture(name, transparentTextures.has(name)));
            return promises.length > 0 ? Promise.all(promises).then((_) => undefined) : Promise.resolve();
        }
        async loadTextureImage(imageJson, samplerJson, isTransparent) {
            try {
                const binaryImageJson = (imageJson.extensions && imageJson.extensions.KHR_binary_glTF) ? bentleyjs_core_1.JsonUtils.asObject(imageJson.extensions.KHR_binary_glTF) : imageJson;
                const bufferView = this._bufferViews[binaryImageJson.bufferView];
                const mimeType = bentleyjs_core_1.JsonUtils.asString(binaryImageJson.mimeType);
                const format = ImageUtil_1.getImageSourceFormatForMimeType(mimeType);
                if (undefined === format)
                    return undefined;
                let textureType = 0 /* Normal */;
                if (undefined !== samplerJson &&
                    (undefined !== samplerJson.wrapS || undefined !== samplerJson.wrapS))
                    textureType = 2 /* TileSection */;
                const textureParams = new imodeljs_common_1.RenderTexture.Params(undefined, textureType);
                const offset = bufferView.byteOffset;
                /* -----------------------------------
                    const jpegArray = this._binaryData.slice(offset, offset + bufferView.byteLength);
                    const jpegArrayBuffer = jpegArray.buffer;
                    const workerOp = new ImageDecodeWorkerOperation(jpegArrayBuffer, mimeType);
                    return Reader.webWorkerManager.queueOperation(workerOp)
                      .then((imageBitmap) => this._isCanceled ? undefined : this._system.createTextureFromImage(imageBitmap, isTransparent && ImageSourceFormat.Png === format, this._iModel, textureParams))
                      .catch((_) => undefined);
                  ------------------------------------- */
                const bytes = this._binaryData.subarray(offset, offset + bufferView.byteLength);
                const imageSource = new imodeljs_common_1.ImageSource(bytes, format);
                return ImageUtil_1.imageElementFromImageSource(imageSource)
                    .then((image) => this._isCanceled ? undefined : this._system.createTextureFromImage(image, isTransparent && imodeljs_common_1.ImageSourceFormat.Png === format, this._iModel, textureParams))
                    .catch((_) => undefined);
            }
            catch (e) {
                return undefined;
            }
        }
        async loadTexture(textureId, isTransparent) {
            const textureJson = bentleyjs_core_1.JsonUtils.asObject(this._textures[textureId]);
            if (undefined === textureJson)
                return Promise.resolve();
            return this.loadTextureImage(this._images[textureJson.source], undefined === this._samplers ? undefined : this._samplers[textureJson.sampler], isTransparent).then((texture) => {
                textureJson.renderTexture = texture;
            });
        }
        findTextureMapping(textureId) {
            const textureJson = bentleyjs_core_1.JsonUtils.asObject(this._textures[textureId]);
            const texture = undefined !== textureJson ? textureJson.renderTexture : undefined;
            return undefined !== texture ? new imodeljs_common_1.TextureMapping(texture, new imodeljs_common_1.TextureMapping.Params()) : undefined;
        }
    }
    GltfTileIO.Reader = Reader;
})(GltfTileIO = exports.GltfTileIO || (exports.GltfTileIO = {}));


/***/ }),

/***/ "./lib/tile/I3dmTileIO.js":
/*!********************************!*\
  !*** ./lib/tile/I3dmTileIO.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
const TileIO_1 = __webpack_require__(/*! ./TileIO */ "./lib/tile/TileIO.js");
const GltfTileIO_1 = __webpack_require__(/*! ./GltfTileIO */ "./lib/tile/GltfTileIO.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
function setTransform(transforms, index, rotation, origin) {
    const i = index * 12;
    let rot = rotation.coffs;
    const ignoreRotation = false;
    if (ignoreRotation)
        rot = new Float64Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);
    const ignoreOrigin = false;
    if (ignoreOrigin)
        origin.x = origin.y = origin.z = 0;
    transforms[i + 0] = rot[0];
    transforms[i + 1] = rot[1];
    transforms[i + 2] = rot[2];
    transforms[i + 3] = origin.x;
    transforms[i + 4] = rot[3];
    transforms[i + 5] = rot[4];
    transforms[i + 6] = rot[5];
    transforms[i + 7] = origin.y;
    transforms[i + 8] = rot[6];
    transforms[i + 9] = rot[7];
    transforms[i + 10] = rot[8];
    transforms[i + 11] = origin.z;
}
/**
 * Provides facilities for deserializing Batched 3D Model (B3dm) tiles.
 * @internal
 */
var I3dmTileIO;
(function (I3dmTileIO) {
    /** @internal */
    class Header extends TileIO_1.TileIO.Header {
        constructor(stream) {
            super(stream);
            this.length = stream.nextUint32;
            this.featureTableJsonLength = stream.nextUint32;
            this.featureTableBinaryLength = stream.nextUint32;
            this.batchTableJsonLength = stream.nextUint32;
            this.batchTableBinaryLength = stream.nextUint32;
            this.gltfVersion = stream.nextUint32;
            this.featureTableJsonPosition = stream.curPos;
            stream.advance(this.featureTableJsonLength);
            stream.advance(this.featureTableBinaryLength);
            stream.advance(this.batchTableJsonLength);
            stream.advance(this.batchTableBinaryLength);
            if (stream.isPastTheEnd)
                this.invalidate();
        }
        get isValid() { return 1835283305 /* I3dm */ === this.format; }
    }
    I3dmTileIO.Header = Header;
    /**
     * Deserializes a I3DM tile.
     * @internal
     */
    class Reader extends GltfTileIO_1.GltfTileIO.Reader {
        constructor(_featureBinary, _featureJson, props, iModel, modelId, is3d, system, _range, _isLeaf, isCanceled) {
            super(props, iModel, modelId, is3d, system, imodeljs_common_1.BatchType.Primary, isCanceled);
            this._featureBinary = _featureBinary;
            this._featureJson = _featureJson;
            this._range = _range;
            this._isLeaf = _isLeaf;
        }
        static create(stream, iModel, modelId, is3d, range, system, yAxisUp, isLeaf, isCanceled) {
            const header = new Header(stream);
            if (!header.isValid)
                return undefined;
            const props = GltfTileIO_1.GltfTileIO.ReaderProps.create(stream, yAxisUp);
            stream.curPos = header.featureTableJsonPosition;
            const featureStr = bentleyjs_core_1.utf8ToString(stream.nextBytes(header.featureTableJsonLength));
            if (undefined === featureStr)
                return undefined;
            const featureBinary = new Uint8Array(stream.arrayBuffer, header.featureTableJsonPosition + header.featureTableJsonLength, header.featureTableBinaryLength);
            return undefined !== props ? new Reader(featureBinary, JSON.parse(featureStr), props, iModel, modelId, is3d, system, range, isLeaf, isCanceled) : undefined;
        }
        async read() {
            const skipI3dm = false; // for debugging
            if (skipI3dm)
                return Promise.resolve({ readStatus: 7 /* Canceled */, isLeaf: this._isLeaf });
            // TBD... Create an actual feature table if one exists.  For now we are only reading tiles from scalable mesh which have no features.
            // NB: For reality models with no batch table, we want the model ID in the feature table
            const featureTable = new imodeljs_common_1.FeatureTable(1, this._modelId, this._type);
            const feature = new imodeljs_common_1.Feature(this._modelId);
            featureTable.insert(feature);
            await this.loadTextures();
            if (this._isCanceled)
                return Promise.resolve({ readStatus: 7 /* Canceled */, isLeaf: this._isLeaf });
            const instances = this.readInstances();
            if (undefined === instances)
                return Promise.resolve({ readStatus: 1 /* InvalidTileData */, isLeaf: this._isLeaf });
            return this.readGltfAndCreateGraphics(this._isLeaf, featureTable, this._range, undefined, undefined, instances);
        }
        readFeatures(features, _json) {
            const feature = new imodeljs_common_1.Feature(this._modelId);
            features.add(feature, 1);
            return true;
        }
        readInstances() {
            const count = bentleyjs_core_1.JsonUtils.asInt(this._featureJson.INSTANCES_LENGTH, 0);
            if (count <= 0)
                return undefined;
            const json = this._featureJson;
            const binary = this._featureBinary;
            const positions = json.POSITION ? new Float32Array(binary.buffer, binary.byteOffset + json.POSITION.byteOffset, count * 3) : undefined;
            const upNormals = json.NORMAL_UP ? new Float32Array(binary.buffer, binary.byteOffset + json.NORMAL_UP.byteOffset, count * 3) : undefined;
            const rightNormals = json.NORMAL_RIGHT ? new Float32Array(binary.buffer, binary.byteOffset + json.NORMAL_RIGHT.byteOffset, count * 3) : undefined;
            const scales = json.SCALE ? new Float32Array(binary.buffer, binary.byteOffset + json.SCALE.byteOffset, count) : undefined;
            const nonUniformScales = json.SCALE_NON_UNIFORM ? new Float32Array(binary.buffer, binary.byteOffset + json.SCALE_NON_UNIFORM.byteOffset, count * 3) : undefined;
            const matrix = geometry_core_1.Matrix3d.createIdentity();
            const position = geometry_core_1.Point3d.createZero();
            const upNormal = geometry_core_1.Vector3d.create(0, 0, 1);
            const rightNormal = geometry_core_1.Vector3d.create(1, 0, 0);
            const scale = geometry_core_1.Vector3d.create(1, 1, 1);
            const transformCenter = this._range.center;
            const transforms = new Float32Array(12 * count);
            for (let i = 0; i < count; i++) {
                const index = i * 3;
                if (positions)
                    position.set(positions[index] - transformCenter.x, positions[index + 1] - transformCenter.y, positions[index + 2] - transformCenter.z);
                if (upNormals || rightNormals) {
                    if (upNormals)
                        upNormal.set(upNormals[index], upNormals[index + 1], upNormals[index + 2]);
                    if (rightNormals)
                        rightNormal.set(rightNormals[index], rightNormals[index + 1], rightNormals[index + 2]);
                    if (scales)
                        scale.x = scale.y = scale.z = scales[i];
                    if (nonUniformScales) {
                        scale.x *= nonUniformScales[index + 0];
                        scale.y *= nonUniformScales[index + 1];
                        scale.z *= nonUniformScales[index + 2];
                    }
                    geometry_core_1.Matrix3d.createRigidFromColumns(rightNormal, upNormal, geometry_core_1.AxisOrder.XYZ, matrix);
                    if (scales || nonUniformScales)
                        matrix.scaleColumnsInPlace(scale.x, scale.y, scale.z);
                    setTransform(transforms, i, matrix, position);
                }
            }
            // ###TODO_INSTANCING: Use actual feature IDs if feature table exists
            const featureIds = undefined;
            const symbologyOverrides = undefined;
            return { count, transforms, symbologyOverrides, featureIds, transformCenter };
        }
    }
    I3dmTileIO.Reader = Reader;
})(I3dmTileIO = exports.I3dmTileIO || (exports.I3dmTileIO = {}));


/***/ }),

/***/ "./lib/tile/IModelTile.js":
/*!********************************!*\
  !*** ./lib/tile/IModelTile.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const TileTree_1 = __webpack_require__(/*! ./TileTree */ "./lib/tile/TileTree.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
/** Contains facilities for deserializing tiles in iMdl format - Bentley's internal format for representing 3d tiles
 * generated by the backend from the contents of geometric models. iMdl shares some similarities with glTF, but a quite
 * different representation of geometry and materials.
 * @internal
 */
var IModelTile;
(function (IModelTile) {
    /** Contains logic for working with tile content Ids according to a specific content Id scheme. Which scheme is used depends on
     * the major version of the tile format.
     * @internal
     */
    class ContentIdProvider {
        get rootContentId() {
            return this.computeId(0, 0, 0, 0, 1);
        }
        idFromParentAndMultiplier(parentId, multiplier) {
            const lastSepPos = parentId.lastIndexOf(this._separator);
            bentleyjs_core_1.assert(-1 !== lastSepPos);
            return parentId.substring(0, lastSepPos + 1) + multiplier.toString(16);
        }
        specFromId(id) {
            const parts = id.split(this._separator);
            const len = parts.length;
            bentleyjs_core_1.assert(len >= 5);
            return {
                depth: parseInt(parts[len - 5], 16),
                i: parseInt(parts[len - 4], 16),
                j: parseInt(parts[len - 3], 16),
                k: parseInt(parts[len - 2], 16),
                multiplier: parseInt(parts[len - 1], 16),
            };
        }
        idFromSpec(spec) {
            return this.computeId(spec.depth, spec.i, spec.j, spec.k, spec.multiplier);
        }
        join(depth, i, j, k, mult) {
            const sep = this._separator;
            return depth.toString(16) + sep + i.toString(16) + sep + j.toString(16) + sep + k.toString(16) + sep + mult.toString(16);
        }
        /** formatVersion is the maximum major version supported by the back-end supplying the tile tree.
         * Must ensure front-end does not request tiles of a format the back-end cannot supply, and back-end does
         * not supply tiles of a format the front-end doesn't recognize.
         */
        static create(allowInstancing, formatVersion) {
            const majorVersion = IModelApp_1.IModelApp.tileAdmin.getMaximumMajorTileFormatVersion(formatVersion);
            bentleyjs_core_1.assert(majorVersion > 0);
            bentleyjs_core_1.assert(Math.floor(majorVersion) === majorVersion);
            switch (majorVersion) {
                case 0:
                case 1:
                    return new ContentIdV1Provider();
                case 2:
                case 3:
                    return new ContentIdV2Provider(majorVersion, allowInstancing);
                default:
                    return new ContentIdV4Provider(allowInstancing);
            }
        }
    }
    /** The original (major version 1) tile format used a content Id scheme of the format
     * `depth/i/j/k/multiplier`.
     * @internal
     */
    class ContentIdV1Provider extends ContentIdProvider {
        get _separator() { return "/"; }
        computeId(depth, i, j, k, mult) {
            return this.join(depth, i, j, k, mult);
        }
    }
    /** Tile formats 2 and 3 use a content Id scheme encoding styling flags and the major format version
     * into the content Id, of the format `_majorVersion_flags_depth_i_j_k_multiplier`.
     * @internal
     */
    class ContentIdV2Provider extends ContentIdProvider {
        constructor(majorVersion, allowInstancing) {
            super();
            const flags = (allowInstancing && IModelApp_1.IModelApp.tileAdmin.enableInstancing) ? 1 /* AllowInstancing */ : 0 /* None */;
            this._prefix = this._separator + majorVersion.toString(16) + this._separator + flags.toString(16) + this._separator;
        }
        get _separator() { return "_"; }
        computeId(depth, i, j, k, mult) {
            return this._prefix + this.join(depth, i, j, k, mult);
        }
    }
    /** Tile formats 4+ encode styling flags but not major format version. (The version is specified by the tile tree's Id).
     * Format: `-flags-depth-i-j-k-multiplier`.
     * @internal
     */
    class ContentIdV4Provider extends ContentIdProvider {
        constructor(allowInstancing) {
            super();
            const flags = (allowInstancing && IModelApp_1.IModelApp.tileAdmin.enableInstancing) ? 1 /* AllowInstancing */ : 0 /* None */;
            this._prefix = this._separator + flags.toString(16) + this._separator;
        }
        get _separator() { return "-"; }
        computeId(depth, i, j, k, mult) {
            return this._prefix + this.join(depth, i, j, k, mult);
        }
    }
    /** @internal */
    function treeIdToString(modelId, treeId) {
        let idStr = "";
        const admin = IModelApp_1.IModelApp.tileAdmin;
        const version = admin.getMaximumMajorTileFormatVersion();
        if (version >= 4) {
            const useProjectExtents = admin.useProjectExtents || imodeljs_common_1.BatchType.VolumeClassifier === treeId.type;
            const flags = useProjectExtents ? "_1-" : "_0-";
            idStr = version.toString() + flags;
        }
        if (imodeljs_common_1.BatchType.Primary === treeId.type) {
            if (undefined !== treeId.animationId)
                idStr = idStr + "A:" + treeId.animationId + "_";
            if (!treeId.edgesRequired) {
                // Tell backend not to bother generating+returning edges - we would just discard them anyway
                idStr = idStr + "E:0_";
            }
        }
        else {
            const typeStr = imodeljs_common_1.BatchType.PlanarClassifier === treeId.type ? "CP" : "C";
            idStr = idStr + typeStr + ":" + treeId.expansion.toFixed(6) + "_";
        }
        return idStr + modelId;
    }
    IModelTile.treeIdToString = treeIdToString;
    /** @internal */
    class Loader extends TileTree_1.TileLoader {
        constructor(iModel, formatVersion, batchType, edgesRequired, allowInstancing) {
            super();
            this._iModel = iModel;
            this._type = batchType;
            this._edgesRequired = edgesRequired;
            this._contentIdProvider = ContentIdProvider.create(allowInstancing, formatVersion);
        }
        get _batchType() { return this._type; }
        get _loadEdges() { return this._edgesRequired; }
        get maxDepth() { return 32; } // Can be removed when element tile selector is working.
        get priority() { return (imodeljs_common_1.BatchType.VolumeClassifier === this._batchType || imodeljs_common_1.BatchType.PlanarClassifier === this._batchType) ? 2 /* Classifier */ : 0 /* Primary */; }
        tileRequiresLoading(params) { return 0 !== params.maximumSize; }
        get rootContentId() { return this._contentIdProvider.rootContentId; }
        get viewFlagOverrides() { return Loader._viewFlagOverrides; }
        async getChildrenProps(parent) {
            const kids = [];
            // Leaf nodes have no children.
            if (parent.isLeaf)
                return kids;
            // One child, same range as parent, higher-resolution.
            if (parent.hasSizeMultiplier) {
                const sizeMultiplier = parent.sizeMultiplier * 2;
                const contentId = this._contentIdProvider.idFromParentAndMultiplier(parent.contentId, sizeMultiplier);
                kids.push({
                    contentId,
                    range: parent.range,
                    contentRange: parent.contentRange,
                    sizeMultiplier,
                    isLeaf: false,
                    maximumSize: 512,
                });
                return kids;
            }
            // Sub-divide parent's range into 4 (for 2d trees) or 8 (for 3d trees) child tiles.
            const parentSpec = this._contentIdProvider.specFromId(parent.contentId);
            bentleyjs_core_1.assert(parent.depth === parentSpec.depth);
            const childSpec = Object.assign({}, parentSpec);
            childSpec.depth = parent.depth + 1;
            // This mask is a bitfield in which an 'on' bit indicates sub-volume containing no geometry.
            // Don't bother creating children or requesting content for such empty volumes.
            const admin = IModelApp_1.IModelApp.tileAdmin;
            const emptyMask = parent.emptySubRangeMask;
            // Spatial tree range == project extents; content range == model range.
            // Trivially reject children whose ranges are entirely outside model range.
            let treeContentRange = parent.root.contentRange;
            if (undefined !== treeContentRange && treeContentRange.containsRange(parent.range)) {
                // Parent is wholly within model range - don't bother testing child ranges against it.
                treeContentRange = undefined;
            }
            const is2d = parent.root.is2d;
            const bisectRange = is2d ? TileTree_1.bisectRange2d : TileTree_1.bisectRange3d;
            for (let i = 0; i < 2; i++) {
                for (let j = 0; j < 2; j++) {
                    for (let k = 0; k < (is2d ? 1 : 2); k++) {
                        const emptyBit = 1 << (i + j * 2 + k * 4);
                        if (0 !== (emptyMask & emptyBit)) {
                            // volume is known to contain no geometry.
                            admin.onTileElided();
                            continue;
                        }
                        const range = parent.range.clone();
                        bisectRange(range, 0 === i);
                        bisectRange(range, 0 === j);
                        if (!is2d)
                            bisectRange(range, 0 === k);
                        if (undefined !== treeContentRange && !range.intersectsRange(treeContentRange)) {
                            // volume is within project extents but entirely outside model range
                            admin.onTileElided();
                            continue;
                        }
                        childSpec.i = parentSpec.i * 2 + i;
                        childSpec.j = parentSpec.j * 2 + j;
                        childSpec.k = parentSpec.k * 2 + k;
                        const childId = this._contentIdProvider.idFromSpec(childSpec);
                        kids.push({ contentId: childId, range, maximumSize: 512 });
                    }
                }
            }
            return kids;
        }
        async requestTileContent(tile) {
            return this._iModel.tiles.getTileContent(tile.root.id, tile.contentId);
        }
        adjustContentIdSizeMultiplier(contentId, sizeMultiplier) {
            return this._contentIdProvider.idFromParentAndMultiplier(contentId, sizeMultiplier);
        }
    }
    Loader._viewFlagOverrides = new imodeljs_common_1.ViewFlag.Overrides();
    IModelTile.Loader = Loader;
})(IModelTile = exports.IModelTile || (exports.IModelTile = {}));


/***/ }),

/***/ "./lib/tile/IModelTileIO.js":
/*!**********************************!*\
  !*** ./lib/tile/IModelTileIO.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const TileIO_1 = __webpack_require__(/*! ./TileIO */ "./lib/tile/TileIO.js");
const GltfTileIO_1 = __webpack_require__(/*! ./GltfTileIO */ "./lib/tile/GltfTileIO.js");
const DisplayParams_1 = __webpack_require__(/*! ../render/primitives/DisplayParams */ "./lib/render/primitives/DisplayParams.js");
const VertexTable_1 = __webpack_require__(/*! ../render/primitives/VertexTable */ "./lib/render/primitives/VertexTable.js");
const AuxChannelTable_1 = __webpack_require__(/*! ../render/primitives/AuxChannelTable */ "./lib/render/primitives/AuxChannelTable.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const System_1 = __webpack_require__(/*! ../render/System */ "./lib/render/System.js");
const ImageUtil_1 = __webpack_require__(/*! ../ImageUtil */ "./lib/ImageUtil.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
// tslint:disable:no-const-enum
/** Provides facilities for deserializing tiles in 'imodel' format. These tiles contain element geometry encoded into a format optimized for the imodeljs webgl renderer.
 * @internal
 */
var IModelTileIO;
(function (IModelTileIO) {
    /** Header embedded at the beginning of the binary tile data describing its contents.
     * @internal
     */
    class Header extends TileIO_1.TileIO.Header {
        /** Deserialize a header from the binary data at the stream's current position.
         * If the binary data does not contain a valid header, the Header will be marked 'invalid'.
         */
        constructor(stream) {
            super(stream);
            this.headerLength = stream.nextUint32;
            this.flags = stream.nextUint32;
            // NB: Cannot use any of the static create*() functions because they all want to compute a range to contain the supplied points.
            // (If contentRange is null, this will produce maximum range).
            this.contentRange = new geometry_core_1.Range3d();
            this.contentRange.low = stream.nextPoint3d64;
            this.contentRange.high = stream.nextPoint3d64;
            this.tolerance = stream.nextFloat64;
            this.numElementsIncluded = stream.nextUint32;
            this.numElementsExcluded = stream.nextUint32;
            this.tileLength = stream.nextUint32;
            // empty sub-volume bit field introduced in format v02.00
            this.emptySubRanges = this.versionMajor >= 2 ? stream.nextUint32 : 0;
            // Skip any unprocessed bytes in header
            const remainingHeaderBytes = this.headerLength - stream.curPos;
            bentleyjs_core_1.assert(remainingHeaderBytes >= 0);
            stream.advance(remainingHeaderBytes);
            if (stream.isPastTheEnd)
                this.invalidate();
        }
        get versionMajor() { return this.version >>> 0x10; }
        get versionMinor() { return (this.version & 0xffff) >>> 0; }
        get isValid() { return 1818512745 /* IModel */ === this.format; }
        get isReadableVersion() { return this.versionMajor <= 4 /* Major */; }
    }
    IModelTileIO.Header = Header;
    /** @internal */
    class FeatureTableHeader {
        constructor(length, maxFeatures, count) {
            this.length = length;
            this.maxFeatures = maxFeatures;
            this.count = count;
        }
        static readFrom(stream) {
            const length = stream.nextUint32;
            const maxFeatures = stream.nextUint32;
            const count = stream.nextUint32;
            return stream.isPastTheEnd ? undefined : new FeatureTableHeader(length, maxFeatures, count);
        }
    }
    FeatureTableHeader.sizeInBytes = 12;
    const maxLeafTolerance = 1.0;
    const minElementsPerTile = 100;
    /** Deserializes an iModel tile.
     * @internal
     */
    class Reader extends GltfTileIO_1.GltfTileIO.Reader {
        constructor(props, iModel, modelId, is3d, system, type, loadEdges, isCanceled, sizeMultiplier) {
            super(props, iModel, modelId, is3d, system, type, isCanceled);
            this._sizeMultiplier = sizeMultiplier;
            this._loadEdges = loadEdges;
        }
        /** Attempt to initialize a Reader to deserialize iModel tile data beginning at the stream's current position. */
        static create(stream, iModel, modelId, is3d, system, type = imodeljs_common_1.BatchType.Primary, loadEdges = true, isCanceled, sizeMultiplier) {
            const header = new Header(stream);
            if (!header.isValid || !header.isReadableVersion)
                return undefined;
            // The feature table follows the iMdl header
            if (!this.skipFeatureTable(stream))
                return undefined;
            // A glTF header follows the feature table
            const props = GltfTileIO_1.GltfTileIO.ReaderProps.create(stream, false);
            return undefined !== props ? new Reader(props, iModel, modelId, is3d, system, type, loadEdges, isCanceled, sizeMultiplier) : undefined;
        }
        /** Attempt to deserialize the tile data */
        async read() {
            this._buffer.reset();
            const header = new Header(this._buffer);
            let isLeaf = true;
            if (!header.isValid)
                return { readStatus: 2 /* InvalidHeader */, isLeaf };
            else if (!header.isReadableVersion)
                return { readStatus: 6 /* NewerMajorVersion */, isLeaf };
            const featureTable = this.readFeatureTable();
            if (undefined === featureTable)
                return { readStatus: 5 /* InvalidFeatureTable */, isLeaf };
            // Textures must be loaded asynchronously first...
            await this.loadNamedTextures();
            if (this._isCanceled)
                return Promise.resolve({ readStatus: 7 /* Canceled */, isLeaf });
            // Determine subdivision based on header data
            isLeaf = false;
            let sizeMultiplier = this._sizeMultiplier;
            const completeTile = 0 === (header.flags & 4 /* Incomplete */);
            const emptyTile = completeTile && 0 === header.numElementsIncluded && 0 === header.numElementsExcluded;
            if (emptyTile || this._isVolumeClassifier) { // Classifier algorithm currently supports only a single tile.
                isLeaf = true;
            }
            else {
                // Non-spatial (2d) models are of arbitrary scale and contain geometry like line work and especially text which
                // can be adversely affected by quantization issues when zooming in closely.
                const canSkipSubdivision = this._is3d && header.tolerance <= maxLeafTolerance;
                if (canSkipSubdivision) {
                    if (completeTile && 0 === header.numElementsExcluded && header.numElementsIncluded <= minElementsPerTile) {
                        const containsCurves = 0 !== (header.flags & 1 /* ContainsCurves */);
                        if (!containsCurves)
                            isLeaf = true;
                        else if (undefined === sizeMultiplier)
                            sizeMultiplier = 1.0;
                    }
                    else if (undefined === sizeMultiplier && header.numElementsIncluded + header.numElementsExcluded <= minElementsPerTile) {
                        sizeMultiplier = 1.0;
                    }
                }
            }
            return Promise.resolve(this.finishRead(isLeaf, featureTable, header.contentRange, header.emptySubRanges, sizeMultiplier));
        }
        /** @internal */
        extractReturnToCenter(_extensions) { return undefined; }
        /** @internal */
        createDisplayParams(json) {
            const type = bentleyjs_core_1.JsonUtils.asInt(json.type, DisplayParams_1.DisplayParams.Type.Mesh);
            const lineColor = new imodeljs_common_1.ColorDef(bentleyjs_core_1.JsonUtils.asInt(json.lineColor));
            const fillColor = new imodeljs_common_1.ColorDef(bentleyjs_core_1.JsonUtils.asInt(json.fillColor));
            const width = bentleyjs_core_1.JsonUtils.asInt(json.lineWidth);
            const linePixels = bentleyjs_core_1.JsonUtils.asInt(json.linePixels, imodeljs_common_1.LinePixels.Solid);
            const fillFlags = bentleyjs_core_1.JsonUtils.asInt(json.fillFlags, imodeljs_common_1.FillFlags.None);
            const ignoreLighting = bentleyjs_core_1.JsonUtils.asBool(json.ignoreLighting);
            // Material will always contain its own texture if it has one
            const materialKey = json.materialId;
            const material = undefined !== materialKey ? this.materialFromJson(materialKey) : undefined;
            // We will only attempt to include the texture if material is undefined
            let textureMapping;
            if (!material) {
                const textureJson = json.texture;
                textureMapping = undefined !== textureJson ? this.textureMappingFromJson(textureJson) : undefined;
                if (undefined === textureMapping) {
                    // Look for a gradient. If defined, create a texture mapping. No reason to pass the Gradient.Symb to the DisplayParams once we have the texture.
                    const gradientProps = json.gradient;
                    const gradient = undefined !== gradientProps ? imodeljs_common_1.Gradient.Symb.fromJSON(gradientProps) : undefined;
                    if (undefined !== gradient) {
                        const texture = this._system.getGradientTexture(gradient, this._iModel);
                        if (undefined !== texture) {
                            // ###TODO: would be better if DisplayParams created the TextureMapping - but that requires an IModelConnection and a RenderSystem...
                            textureMapping = new imodeljs_common_1.TextureMapping(texture, new imodeljs_common_1.TextureMapping.Params({ textureMat2x3: new imodeljs_common_1.TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0) }));
                        }
                    }
                }
            }
            return new DisplayParams_1.DisplayParams(type, lineColor, fillColor, width, linePixels, fillFlags, material, undefined, ignoreLighting, textureMapping);
        }
        /** @internal */
        colorDefFromMaterialJson(json) {
            return undefined !== json ? imodeljs_common_1.ColorDef.from(json[0] * 255 + 0.5, json[1] * 255 + 0.5, json[2] * 255 + 0.5) : undefined;
        }
        /** @internal */
        materialFromJson(key) {
            if (this._renderMaterials === undefined || this._renderMaterials[key] === undefined)
                return undefined;
            let material = this._system.findMaterial(key, this._iModel);
            if (!material) {
                const materialJson = this._renderMaterials[key];
                const materialParams = new imodeljs_common_1.RenderMaterial.Params(key);
                materialParams.diffuseColor = this.colorDefFromMaterialJson(materialJson.diffuseColor);
                if (materialJson.diffuse !== undefined)
                    materialParams.diffuse = bentleyjs_core_1.JsonUtils.asDouble(materialJson.diffuse);
                materialParams.specularColor = this.colorDefFromMaterialJson(materialJson.specularColor);
                if (materialJson.specular !== undefined)
                    materialParams.specular = bentleyjs_core_1.JsonUtils.asDouble(materialJson.specular);
                materialParams.reflectColor = this.colorDefFromMaterialJson(materialJson.reflectColor);
                if (materialJson.reflect !== undefined)
                    materialParams.reflect = bentleyjs_core_1.JsonUtils.asDouble(materialJson.reflect);
                if (materialJson.specularExponent !== undefined)
                    materialParams.specularExponent = materialJson.specularExponent;
                if (materialJson.transparency !== undefined)
                    materialParams.transparency = materialJson.transparency;
                materialParams.refract = bentleyjs_core_1.JsonUtils.asDouble(materialJson.refract);
                materialParams.shadows = bentleyjs_core_1.JsonUtils.asBool(materialJson.shadows);
                materialParams.ambient = bentleyjs_core_1.JsonUtils.asDouble(materialJson.ambient);
                if (undefined !== materialJson.textureMapping)
                    materialParams.textureMapping = this.textureMappingFromJson(materialJson.textureMapping.texture);
                material = this._system.createMaterial(materialParams, this._iModel);
            }
            return material;
        }
        textureMappingFromJson(json) {
            if (undefined === json)
                return undefined;
            const name = bentleyjs_core_1.JsonUtils.asString(json.name);
            const namedTex = 0 !== name.length ? this._namedTextures[name] : undefined;
            const texture = undefined !== namedTex ? namedTex.renderTexture : undefined;
            if (undefined === texture) {
                bentleyjs_core_1.assert(false, "bad texture mapping json");
                return undefined;
            }
            const paramsJson = json.params;
            const tf = paramsJson.transform;
            const paramProps = {
                textureMat2x3: new imodeljs_common_1.TextureMapping.Trans2x3(tf[0][0], tf[0][1], tf[0][2], tf[1][0], tf[1][1], tf[1][2]),
                textureWeight: bentleyjs_core_1.JsonUtils.asDouble(paramsJson.weight, 1.0),
                mapMode: bentleyjs_core_1.JsonUtils.asInt(paramsJson.mode),
                worldMapping: bentleyjs_core_1.JsonUtils.asBool(paramsJson.worldMapping),
            };
            return new imodeljs_common_1.TextureMapping(texture, new imodeljs_common_1.TextureMapping.Params(paramProps));
        }
        async loadNamedTextures() {
            if (undefined === this._namedTextures)
                return Promise.resolve();
            const promises = new Array();
            for (const name of Object.keys(this._namedTextures))
                promises.push(this.loadNamedTexture(name));
            return promises.length > 0 ? Promise.all(promises).then((_) => undefined) : Promise.resolve();
        }
        async loadNamedTexture(name) {
            if (this._isCanceled)
                return Promise.resolve();
            const namedTex = this._namedTextures[name];
            bentleyjs_core_1.assert(undefined !== namedTex); // we got here by iterating the keys of this.namedTextures...
            if (undefined === namedTex)
                return Promise.resolve();
            const texture = this._system.findTexture(name, this._iModel);
            if (undefined !== texture) {
                namedTex.renderTexture = texture;
                return Promise.resolve();
            }
            return this.readNamedTexture(namedTex, name).then((result) => { namedTex.renderTexture = result; });
        }
        async readNamedTexture(namedTex, name) {
            const bufferViewId = bentleyjs_core_1.JsonUtils.asString(namedTex.bufferView);
            const bufferViewJson = 0 !== bufferViewId.length ? this._bufferViews[bufferViewId] : undefined;
            if (undefined === bufferViewJson)
                return Promise.resolve(undefined);
            const byteOffset = bentleyjs_core_1.JsonUtils.asInt(bufferViewJson.byteOffset);
            const byteLength = bentleyjs_core_1.JsonUtils.asInt(bufferViewJson.byteLength);
            if (0 === byteLength)
                return Promise.resolve(undefined);
            const bytes = this._binaryData.subarray(byteOffset, byteOffset + byteLength);
            const format = namedTex.format;
            const imageSource = new imodeljs_common_1.ImageSource(bytes, format);
            return ImageUtil_1.imageElementFromImageSource(imageSource).then((image) => {
                if (this._isCanceled)
                    return undefined;
                let textureType = 0 /* Normal */;
                if (bentleyjs_core_1.JsonUtils.asBool(namedTex.isGlyph))
                    textureType = 1 /* Glyph */;
                else if (bentleyjs_core_1.JsonUtils.asBool(namedTex.isTileSection))
                    textureType = 2 /* TileSection */;
                const params = new imodeljs_common_1.RenderTexture.Params(namedTex.isGlyph ? undefined : name, textureType);
                return this._system.createTextureFromImage(image, imodeljs_common_1.ImageSourceFormat.Png === format, this._iModel, params);
            });
        }
        /** @internal */
        readFeatureTable() {
            const startPos = this._buffer.curPos;
            const header = FeatureTableHeader.readFrom(this._buffer);
            if (undefined === header || 0 !== header.length % 4)
                return undefined;
            // NB: We make a copy of the sub-array because we don't want to pin the entire data array in memory.
            const numUint32s = (header.length - FeatureTableHeader.sizeInBytes) / 4;
            const packedFeatureArray = new Uint32Array(this._buffer.nextUint32s(numUint32s));
            if (this._buffer.isPastTheEnd)
                return undefined;
            let animNodesArray;
            const animationNodes = bentleyjs_core_1.JsonUtils.asObject(this._scene.animationNodes);
            if (undefined !== animationNodes) {
                const bytesPerId = bentleyjs_core_1.JsonUtils.asInt(animationNodes.bytesPerId);
                const bufferViewId = bentleyjs_core_1.JsonUtils.asString(animationNodes.bufferView);
                const bufferViewJson = this._bufferViews[bufferViewId];
                if (undefined !== bufferViewJson) {
                    const byteOffset = bentleyjs_core_1.JsonUtils.asInt(bufferViewJson.byteOffset);
                    const byteLength = bentleyjs_core_1.JsonUtils.asInt(bufferViewJson.byteLength);
                    const bytes = this._binaryData.subarray(byteOffset, byteOffset + byteLength);
                    switch (bytesPerId) {
                        case 1:
                            animNodesArray = new Uint8Array(bytes);
                            break;
                        case 2:
                            // NB: A *copy* of the subarray.
                            animNodesArray = Uint16Array.from(new Uint16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2));
                            break;
                        case 4:
                            // NB: A *copy* of the subarray.
                            animNodesArray = Uint32Array.from(new Uint32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4));
                            break;
                    }
                }
            }
            this._buffer.curPos = startPos + header.length;
            return new System_1.PackedFeatureTable(packedFeatureArray, this._modelId, header.count, header.maxFeatures, this._type, animNodesArray);
        }
        static skipFeatureTable(stream) {
            const startPos = stream.curPos;
            const header = FeatureTableHeader.readFrom(stream);
            if (undefined !== header)
                stream.curPos = startPos + header.length;
            return undefined !== header;
        }
        readMeshGraphic(primitive) {
            const materialName = bentleyjs_core_1.JsonUtils.asString(primitive.material);
            const materialValue = 0 < materialName.length ? bentleyjs_core_1.JsonUtils.asObject(this._materialValues[materialName]) : undefined;
            const displayParams = undefined !== materialValue ? this.createDisplayParams(materialValue) : undefined;
            if (undefined === displayParams)
                return undefined;
            const vertices = this.readVertexTable(primitive);
            if (undefined === vertices) {
                bentleyjs_core_1.assert(false, "bad vertex table in tile data.");
                return undefined;
            }
            const isPlanar = bentleyjs_core_1.JsonUtils.asBool(primitive.isPlanar);
            const primitiveType = bentleyjs_core_1.JsonUtils.asInt(primitive.type, 0 /* Mesh */);
            const instances = this.readInstances(primitive);
            switch (primitiveType) {
                case 0 /* Mesh */:
                    return this.createMeshGraphic(primitive, displayParams, vertices, isPlanar, this.readAuxChannelTable(primitive), instances);
                case 1 /* Polyline */:
                    return this.createPolylineGraphic(primitive, displayParams, vertices, isPlanar, instances);
                case 2 /* Point */:
                    return this.createPointStringGraphic(primitive, displayParams, vertices, instances);
            }
            bentleyjs_core_1.assert(false, "unhandled primitive type");
            return undefined;
        }
        findBuffer(bufferViewId) {
            if (typeof bufferViewId !== "string" || 0 === bufferViewId.length)
                return undefined;
            const bufferViewJson = this._bufferViews[bufferViewId];
            if (undefined === bufferViewJson)
                return undefined;
            const byteOffset = bentleyjs_core_1.JsonUtils.asInt(bufferViewJson.byteOffset);
            const byteLength = bentleyjs_core_1.JsonUtils.asInt(bufferViewJson.byteLength);
            if (0 === byteLength)
                return undefined;
            return this._binaryData.subarray(byteOffset, byteOffset + byteLength);
        }
        readVertexTable(primitive) {
            const json = primitive.vertices;
            if (undefined === json)
                return undefined;
            const bytes = this.findBuffer(bentleyjs_core_1.JsonUtils.asString(json.bufferView));
            if (undefined === bytes)
                return undefined;
            const uniformFeatureID = undefined !== json.featureID ? bentleyjs_core_1.JsonUtils.asInt(json.featureID) : undefined;
            const rangeMin = bentleyjs_core_1.JsonUtils.asArray(json.params.decodedMin);
            const rangeMax = bentleyjs_core_1.JsonUtils.asArray(json.params.decodedMax);
            if (undefined === rangeMin || undefined === rangeMax)
                return undefined;
            const qparams = imodeljs_common_1.QParams3d.fromRange(geometry_core_1.Range3d.create(geometry_core_1.Point3d.create(rangeMin[0], rangeMin[1], rangeMin[2]), geometry_core_1.Point3d.create(rangeMax[0], rangeMax[1], rangeMax[2])));
            const uniformColor = undefined !== json.uniformColor ? imodeljs_common_1.ColorDef.fromJSON(json.uniformColor) : undefined;
            let uvParams;
            if (undefined !== primitive.surface && undefined !== primitive.surface.uvParams) {
                const uvMin = bentleyjs_core_1.JsonUtils.asArray(primitive.surface.uvParams.decodedMin);
                const uvMax = bentleyjs_core_1.JsonUtils.asArray(primitive.surface.uvParams.decodedMax);
                if (undefined === uvMin || undefined === uvMax)
                    return undefined;
                const uvRange = new geometry_core_1.Range2d(uvMin[0], uvMin[1], uvMax[0], uvMax[1]);
                uvParams = imodeljs_common_1.QParams2d.fromRange(uvRange);
            }
            return new VertexTable_1.VertexTable({
                data: bytes,
                qparams,
                width: json.width,
                height: json.height,
                hasTranslucency: json.hasTranslucency,
                uniformColor,
                featureIndexType: json.featureIndexType,
                uniformFeatureID,
                numVertices: json.count,
                numRgbaPerVertex: json.numRgbaPerVertex,
                uvParams,
            });
        }
        readAuxChannelTable(primitive) {
            const json = primitive.auxChannels;
            if (undefined === json)
                return undefined;
            const bytes = this.findBuffer(bentleyjs_core_1.JsonUtils.asString(json.bufferView));
            if (undefined === bytes)
                return undefined;
            const props = {
                data: bytes,
                width: json.width,
                height: json.height,
                count: json.count,
                numBytesPerVertex: json.numBytesPerVertex,
                displacements: json.displacements,
                normals: json.normals,
                params: json.params,
            };
            return AuxChannelTable_1.AuxChannelTable.fromJSON(props);
        }
        readInstances(primitive) {
            const json = primitive.instances;
            if (undefined === json)
                return undefined;
            const count = bentleyjs_core_1.JsonUtils.asInt(json.count, 0);
            if (count <= 0)
                return undefined;
            const centerComponents = bentleyjs_core_1.JsonUtils.asArray(json.transformCenter);
            if (undefined === centerComponents || 3 !== centerComponents.length)
                return undefined;
            const transformCenter = geometry_core_1.Point3d.create(centerComponents[0], centerComponents[1], centerComponents[2]);
            const featureIds = this.findBuffer(bentleyjs_core_1.JsonUtils.asString(json.featureIds));
            if (undefined === featureIds)
                return undefined;
            const transformBytes = this.findBuffer(bentleyjs_core_1.JsonUtils.asString(json.transforms));
            if (undefined === transformBytes)
                return undefined;
            // 1 transform = 3 rows of 4 floats = 12 floats per instance
            const numFloats = transformBytes.byteLength / 4;
            bentleyjs_core_1.assert(Math.floor(numFloats) === numFloats);
            bentleyjs_core_1.assert(0 === numFloats % 12);
            const transforms = new Float32Array(transformBytes.buffer, transformBytes.byteOffset, numFloats);
            let symbologyOverrides;
            if (undefined !== json.symbologyOverrides)
                symbologyOverrides = this.findBuffer(bentleyjs_core_1.JsonUtils.asString(json.symbologyOverrides));
            return { count, transforms, transformCenter, featureIds, symbologyOverrides };
        }
        readVertexIndices(json) {
            const bytes = this.findBuffer(json);
            return undefined !== bytes ? new VertexTable_1.VertexIndices(bytes) : undefined;
        }
        createPointStringGraphic(primitive, displayParams, vertices, instances) {
            const indices = this.readVertexIndices(primitive.indices);
            if (undefined === indices)
                return undefined;
            const params = new VertexTable_1.PointStringParams(vertices, indices, displayParams.width);
            return this._system.createPointString(params, instances);
        }
        readTesselatedPolyline(json) {
            const indices = this.readVertexIndices(json.indices);
            const prevIndices = this.readVertexIndices(json.prevIndices);
            const nextIndicesAndParams = this.findBuffer(json.nextIndicesAndParams);
            if (undefined === indices || undefined === prevIndices || undefined === nextIndicesAndParams)
                return undefined;
            return {
                indices,
                prevIndices,
                nextIndicesAndParams,
            };
        }
        createPolylineGraphic(primitive, displayParams, vertices, isPlanar, instances) {
            const polyline = this.readTesselatedPolyline(primitive);
            if (undefined === polyline)
                return undefined;
            let flags = imodeljs_common_1.PolylineTypeFlags.Normal;
            if (DisplayParams_1.DisplayParams.RegionEdgeType.Outline === displayParams.regionEdgeType)
                flags = (undefined === displayParams.gradient || displayParams.gradient.isOutlined) ? imodeljs_common_1.PolylineTypeFlags.Edge : imodeljs_common_1.PolylineTypeFlags.Outline;
            const params = new VertexTable_1.PolylineParams(vertices, polyline, displayParams.width, displayParams.linePixels, isPlanar, flags);
            return this._system.createPolyline(params, instances);
        }
        readSurface(mesh, displayParams) {
            const surf = mesh.surface;
            if (undefined === surf)
                return undefined;
            const indices = this.readVertexIndices(surf.indices);
            if (undefined === indices)
                return undefined;
            const type = bentleyjs_core_1.JsonUtils.asInt(surf.type, -1);
            if (!VertexTable_1.isValidSurfaceType(type))
                return undefined;
            const texture = undefined !== displayParams.textureMapping ? displayParams.textureMapping.texture : undefined;
            return {
                type,
                indices,
                fillFlags: displayParams.fillFlags,
                hasBakedLighting: false,
                material: displayParams.material,
                texture,
            };
        }
        readSegmentEdges(json) {
            const indices = this.readVertexIndices(json.indices);
            const endPointAndQuadIndices = this.findBuffer(json.endPointAndQuadIndices);
            return undefined !== indices && undefined !== endPointAndQuadIndices ? { indices, endPointAndQuadIndices } : undefined;
        }
        readSilhouettes(json) {
            const segments = this.readSegmentEdges(json);
            const normalPairs = this.findBuffer(json.normalPairs);
            return undefined !== segments && undefined !== normalPairs ? { normalPairs, indices: segments.indices, endPointAndQuadIndices: segments.endPointAndQuadIndices } : undefined;
        }
        readEdges(json, displayParams) {
            let segments;
            let silhouettes;
            let polylines;
            let succeeded = false;
            if (undefined !== json.segments && undefined === (segments = this.readSegmentEdges(json.segments)))
                return { succeeded };
            if (undefined !== json.silhouettes && undefined === (silhouettes = this.readSilhouettes(json.silhouettes)))
                return { succeeded };
            if (undefined !== json.polylines && undefined === (polylines = this.readTesselatedPolyline(json.polylines)))
                return { succeeded };
            succeeded = true;
            let params;
            if (undefined !== segments || undefined !== silhouettes || undefined !== polylines) {
                params = {
                    segments,
                    silhouettes,
                    polylines,
                    weight: displayParams.width,
                    linePixels: displayParams.linePixels,
                };
            }
            return { succeeded, params };
        }
        createMeshGraphic(primitive, displayParams, vertices, isPlanar, auxChannels, instances) {
            const surface = this.readSurface(primitive, displayParams);
            if (undefined === surface)
                return undefined;
            // ###TODO: Tile generator shouldn't bother producing edges for classification meshes in the first place...
            let edgeParams;
            if (this._loadEdges && undefined !== primitive.edges && 4 /* VolumeClassifier */ !== surface.type) {
                const edgeResult = this.readEdges(primitive.edges, displayParams);
                if (!edgeResult.succeeded)
                    return undefined;
                else
                    edgeParams = edgeResult.params;
            }
            const params = new VertexTable_1.MeshParams(vertices, surface, edgeParams, isPlanar, auxChannels);
            return this._system.createMesh(params, instances);
        }
        finishRead(isLeaf, featureTable, contentRange, emptySubRangeMask, sizeMultiplier) {
            const graphics = [];
            if (undefined === this._nodes.Node_Root) {
                // Unstructured -- prior to animation support....
                for (const meshKey of Object.keys(this._meshes)) {
                    const meshValue = this._meshes[meshKey];
                    const primitives = bentleyjs_core_1.JsonUtils.asArray(meshValue.primitives);
                    if (undefined === primitives)
                        continue;
                    for (const primitive of primitives) {
                        const graphic = this.readMeshGraphic(primitive);
                        if (undefined !== graphic)
                            graphics.push(graphic);
                    }
                }
            }
            else {
                for (const nodeKey of Object.keys(this._nodes)) {
                    const meshValue = this._meshes[this._nodes[nodeKey]];
                    const primitives = bentleyjs_core_1.JsonUtils.asArray(meshValue.primitives);
                    if (undefined === primitives)
                        continue;
                    if ("Node_Root" === nodeKey) {
                        for (const primitive of primitives) {
                            const graphic = this.readMeshGraphic(primitive);
                            if (undefined !== graphic)
                                graphics.push(graphic);
                        }
                    }
                    else {
                        const branch = new System_1.GraphicBranch(true);
                        branch.animationId = this._modelId + "_" + nodeKey;
                        for (const primitive of primitives) {
                            const graphic = this.readMeshGraphic(primitive);
                            if (undefined !== graphic)
                                branch.add(graphic);
                        }
                        if (!branch.isEmpty)
                            graphics.push(this._system.createBranch(branch, geometry_core_1.Transform.createIdentity()));
                    }
                }
            }
            let tileGraphic;
            switch (graphics.length) {
                case 0:
                    break;
                case 1:
                    tileGraphic = graphics[0];
                    break;
                default:
                    tileGraphic = this._system.createGraphicList(graphics);
                    break;
            }
            if (undefined !== tileGraphic)
                tileGraphic = this._system.createBatch(tileGraphic, featureTable, contentRange);
            return {
                readStatus: 0 /* Success */,
                isLeaf,
                sizeMultiplier,
                contentRange: contentRange.isNull ? undefined : contentRange,
                graphic: tileGraphic,
                emptySubRangeMask,
            };
        }
    }
    IModelTileIO.Reader = Reader;
})(IModelTileIO = exports.IModelTileIO || (exports.IModelTileIO = {}));


/***/ }),

/***/ "./lib/tile/PntsTileIO.js":
/*!********************************!*\
  !*** ./lib/tile/PntsTileIO.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
const TileIO_1 = __webpack_require__(/*! ./TileIO */ "./lib/tile/TileIO.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const System_1 = __webpack_require__(/*! ../render/System */ "./lib/render/System.js");
const PointCloudPrimitive_1 = __webpack_require__(/*! ../render/primitives/PointCloudPrimitive */ "./lib/render/primitives/PointCloudPrimitive.js");
const MeshPrimitives_1 = __webpack_require__(/*! ../render/primitives/mesh/MeshPrimitives */ "./lib/render/primitives/mesh/MeshPrimitives.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
/** Deserializes a Pnts tile.
 * @internal
 */
var PntsTileIO;
(function (PntsTileIO) {
    /** @internal */
    class Header extends TileIO_1.TileIO.Header {
        get isValid() { return 1937010288 /* Pnts */ === this.format; }
        constructor(stream) {
            super(stream);
            this.length = stream.nextUint32;
            this.featureTableJsonLength = stream.nextUint32;
            this.featureTableBinaryLength = stream.nextUint32;
            this.batchTableJsonLength = stream.nextUint32;
            this.batchTableBinaryLength = stream.nextUint32;
        }
    }
    /** Deserialize a point cloud tile and return it as a RenderGraphic.
     * @internal
     */
    function readPointCloud(stream, iModel, modelId, _is3d, range, system, yAxisUp) {
        const header = new Header(stream);
        if (!header.isValid)
            return undefined;
        const featureTableJsonOffset = stream.curPos;
        const featureStrData = stream.nextBytes(header.featureTableJsonLength);
        const featureStr = bentleyjs_core_1.utf8ToString(featureStrData);
        const featureValue = JSON.parse(featureStr);
        if (undefined === featureValue) { }
        if (undefined === featureValue.POSITION_QUANTIZED ||
            undefined === featureValue.QUANTIZED_VOLUME_OFFSET ||
            undefined === featureValue.QUANTIZED_VOLUME_SCALE ||
            undefined === featureValue.POINTS_LENGTH ||
            undefined === featureValue.POSITION_QUANTIZED) {
            bentleyjs_core_1.assert(false, "quantized point cloud points not found");
            return undefined;
        }
        const qOrigin = new geometry_core_1.Point3d(featureValue.QUANTIZED_VOLUME_OFFSET[0], featureValue.QUANTIZED_VOLUME_OFFSET[1], featureValue.QUANTIZED_VOLUME_OFFSET[2]);
        const qScale = new geometry_core_1.Point3d(imodeljs_common_1.Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[0]), imodeljs_common_1.Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[1]), imodeljs_common_1.Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[2]));
        const qParams = imodeljs_common_1.QParams3d.fromOriginAndScale(qOrigin, qScale);
        const qPoints = new Uint16Array(stream.arrayBuffer, featureTableJsonOffset + header.featureTableJsonLength + featureValue.POSITION_QUANTIZED.byteOffset, 3 * featureValue.POINTS_LENGTH);
        let colors;
        if (undefined !== featureValue.RGB) {
            colors = new Uint8Array(stream.arrayBuffer, featureTableJsonOffset + header.featureTableJsonLength + featureValue.RGB.byteOffset, 3 * featureValue.POINTS_LENGTH);
        }
        else {
            colors = new Uint8Array(3 * featureValue.POINTS_LENGTH);
            colors.fill(0xff, 0, colors.length); // TBD... Default color?
        }
        // ###TODO? Do we expect a batch table? not currently handled...
        const featureTable = new imodeljs_common_1.FeatureTable(1, modelId, imodeljs_common_1.BatchType.Primary);
        const features = new MeshPrimitives_1.Mesh.Features(featureTable);
        features.add(new imodeljs_common_1.Feature(modelId), 1);
        let renderGraphic = system.createPointCloud(new PointCloudPrimitive_1.PointCloudArgs(qPoints, qParams, colors, features), iModel);
        renderGraphic = system.createBatch(renderGraphic, System_1.PackedFeatureTable.pack(featureTable), range);
        if (yAxisUp) {
            const branch = new System_1.GraphicBranch();
            branch.add(renderGraphic);
            const transform = geometry_core_1.Transform.createOriginAndMatrix(undefined, geometry_core_1.Matrix3d.createRotationAroundVector(geometry_core_1.Vector3d.create(1.0, 0.0, 0.0), geometry_core_1.Angle.createRadians(geometry_core_1.Angle.piOver2Radians)));
            renderGraphic = system.createBranch(branch, transform);
        }
        return renderGraphic;
    }
    PntsTileIO.readPointCloud = readPointCloud;
})(PntsTileIO = exports.PntsTileIO || (exports.PntsTileIO = {}));


/***/ }),

/***/ "./lib/tile/RealityModelTileTree.js":
/*!******************************************!*\
  !*** ./lib/tile/RealityModelTileTree.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_clients_1 = __webpack_require__(/*! @bentley/imodeljs-clients */ "@bentley/imodeljs-clients");
const TileTree_1 = __webpack_require__(/*! ./TileTree */ "./lib/tile/TileTree.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const FrontendRequestContext_1 = __webpack_require__(/*! ../FrontendRequestContext */ "./lib/FrontendRequestContext.js");
function getUrl(content) {
    return content ? (content.url ? content.url : content.uri) : undefined;
}
/** @internal */
class RealityModelTileUtils {
    static rangeFromBoundingVolume(boundingVolume) {
        if (undefined === boundingVolume)
            return undefined;
        if (undefined !== boundingVolume.box) {
            const box = boundingVolume.box;
            const center = geometry_core_1.Point3d.create(box[0], box[1], box[2]);
            const ux = geometry_core_1.Vector3d.create(box[3], box[4], box[5]);
            const uy = geometry_core_1.Vector3d.create(box[6], box[7], box[8]);
            const uz = geometry_core_1.Vector3d.create(box[9], box[10], box[11]);
            const corners = [];
            for (let j = 0; j < 2; j++) {
                for (let k = 0; k < 2; k++) {
                    for (let l = 0; l < 2; l++) {
                        corners.push(center.plus3Scaled(ux, (j ? -1.0 : 1.0), uy, (k ? -1.0 : 1.0), uz, (l ? -1.0 : 1.0)));
                    }
                }
            }
            return geometry_core_1.Range3d.createArray(corners);
        }
        else if (Array.isArray(boundingVolume.sphere)) {
            const sphere = boundingVolume.sphere;
            const center = geometry_core_1.Point3d.create(sphere[0], sphere[1], sphere[2]);
            const radius = sphere[3];
            return geometry_core_1.Range3d.createXYZXYZ(center.x - radius, center.y - radius, center.z - radius, center.x + radius, center.y + radius, center.z + radius);
        }
        else if (Array.isArray(boundingVolume.region)) {
            const ecefLow = (new imodeljs_common_1.Cartographic(boundingVolume.region[0], boundingVolume.region[1], boundingVolume.region[4])).toEcef();
            const ecefHigh = (new imodeljs_common_1.Cartographic(boundingVolume.region[2], boundingVolume.region[3], boundingVolume.region[5])).toEcef();
            return geometry_core_1.Range3d.create(ecefLow, ecefHigh);
        }
        else
            return undefined;
    }
    static maximumSizeFromGeometricTolerance(range, geometricError) {
        const minToleranceRatio = 1.0; // Nominally the error on screen size of a tile.  Increasing generally increases performance (fewer draw calls) at expense of higher load times.
        return minToleranceRatio * range.diagonal().magnitude() / geometricError;
    }
    static transformFromJson(jTrans) {
        return (jTrans === undefined) ? geometry_core_1.Transform.createIdentity() : geometry_core_1.Transform.createOriginAndMatrix(geometry_core_1.Point3d.create(jTrans[12], jTrans[13], jTrans[14]), geometry_core_1.Matrix3d.createRowValues(jTrans[0], jTrans[4], jTrans[8], jTrans[1], jTrans[5], jTrans[9], jTrans[2], jTrans[6], jTrans[10]));
    }
}
exports.RealityModelTileUtils = RealityModelTileUtils;
/** @internal */
class RealityModelTileTreeProps {
    constructor(json, client, tilesetTransform) {
        this.client = client;
        this.id = "";
        this.yAxisUp = false;
        this.maxTilesToSkip = 1; // Skip only one level in HLOD tree -- This matches the BIM tiles.  If our tiles loaded faster we could increase this.
        this.tilesetJson = json.root;
        this.rootTile = new RealityModelTileProps(json.root, "");
        this.location = tilesetTransform.toJSON();
        if (json.asset.gltfUpAxis === undefined || json.asset.gltfUpAxis === "y" || json.asset.gltfUpAxis === "Y")
            this.yAxisUp = true;
    }
}
/** @internal */
class RealityModelTileProps {
    constructor(json, thisId, transformToRoot) {
        this.contentId = thisId;
        this.range = RealityModelTileUtils.rangeFromBoundingVolume(json.boundingVolume);
        this.isLeaf = !Array.isArray(json.children) || 0 === json.children.length;
        this.hasContents = undefined !== getUrl(json.content);
        this.transformToRoot = transformToRoot;
        if (this.hasContents) {
            this.contentRange = RealityModelTileUtils.rangeFromBoundingVolume(json.content.boundingVolume);
            this.maximumSize = RealityModelTileUtils.maximumSizeFromGeometricTolerance(geometry_core_1.Range3d.fromJSON(this.range), json.geometricError);
        }
        else {
            this.maximumSize = 0.0;
        }
    }
}
/** @internal */
class FindChildResult {
    constructor(id, json, transformToRoot) {
        this.id = id;
        this.json = json;
        this.transformToRoot = transformToRoot;
    }
}
/** @internal */
class RealityModelTileLoader extends TileTree_1.TileLoader {
    constructor(_tree) {
        super();
        this._tree = _tree;
    }
    get maxDepth() { return 32; } // Can be removed when element tile selector is working.
    get priority() { return 1 /* Context */; }
    tileRequiresLoading(params) { return 0.0 !== params.maximumSize; }
    get viewFlagOverrides() { return RealityModelTileLoader._viewFlagOverrides; }
    async getChildrenProps(parent) {
        const props = [];
        const thisId = parent.contentId;
        const prefix = thisId.length ? thisId + "_" : "";
        const findResult = await this.findTileInJson(this._tree.tilesetJson, thisId, "", undefined, true);
        if (undefined !== findResult && Array.isArray(findResult.json.children)) {
            for (let i = 0; i < findResult.json.children.length; i++) {
                const childId = prefix + i;
                const foundChild = await this.findTileInJson(this._tree.tilesetJson, childId, "", undefined, true);
                if (undefined !== foundChild)
                    props.push(new RealityModelTileProps(foundChild.json, foundChild.id, foundChild.transformToRoot));
            }
        }
        return props;
    }
    async requestTileContent(tile) {
        const foundChild = await this.findTileInJson(this._tree.tilesetJson, tile.contentId, "");
        if (undefined === foundChild)
            return undefined;
        return this._tree.client.getTileContent(getUrl(foundChild.json.content));
    }
    addUrlPrefix(subTree, prefix) {
        if (undefined === subTree)
            return;
        if (undefined !== subTree.content && undefined !== subTree.content.url)
            subTree.content.url = prefix + subTree.content.url;
        if (undefined !== subTree.children)
            for (const child of subTree.children)
                this.addUrlPrefix(child, prefix);
    }
    async findTileInJson(tilesetJson, id, parentId, transformToRoot, isRoot = false) {
        if (!isRoot && tilesetJson.transform) { // Child tiles may have their own transform.
            const thisTransform = RealityModelTileUtils.transformFromJson(tilesetJson.transform);
            transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(thisTransform) : thisTransform;
        }
        if (id.length === 0)
            return new FindChildResult(id, tilesetJson, transformToRoot); // Root.
        const separatorIndex = id.indexOf("_");
        const childId = (separatorIndex < 0) ? id : id.substring(0, separatorIndex);
        const childIndex = parseInt(childId, 10);
        if (isNaN(childIndex) || tilesetJson === undefined || tilesetJson.children === undefined || childIndex >= tilesetJson.children.length) {
            bentleyjs_core_1.assert(false, "scalable mesh child not found.");
            return undefined;
        }
        let foundChild = tilesetJson.children[childIndex];
        const thisParentId = parentId.length ? (parentId + "_" + childId) : childId;
        if (foundChild.transform) {
            const thisTransform = RealityModelTileUtils.transformFromJson(foundChild.transform);
            transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(thisTransform) : thisTransform;
        }
        if (separatorIndex >= 0) {
            return this.findTileInJson(foundChild, id.substring(separatorIndex + 1), thisParentId, transformToRoot);
        }
        const childUrl = getUrl(foundChild.content);
        if (undefined !== childUrl && childUrl.endsWith("json")) { // A child may contain a subTree...
            const subTree = await this._tree.client.getTileJson(childUrl);
            const prefixIndex = childUrl.lastIndexOf("/");
            if (prefixIndex > 0)
                this.addUrlPrefix(subTree.root, childUrl.substring(0, prefixIndex + 1));
            foundChild = subTree.root;
            tilesetJson.children[childIndex] = subTree.root;
        }
        return new FindChildResult(thisParentId, foundChild, transformToRoot);
    }
}
RealityModelTileLoader._viewFlagOverrides = new imodeljs_common_1.ViewFlag.Overrides(imodeljs_common_1.ViewFlags.fromJSON({ renderMode: imodeljs_common_1.RenderMode.SmoothShade }));
/** @internal */
class RealityModelTileTree {
    static loadRealityModelTileTree(url, tilesetToDb, tileTreeState) {
        this.getTileTreeProps(url, tilesetToDb, tileTreeState.iModel).then((tileTreeProps) => {
            tileTreeState.setTileTree(tileTreeProps, new RealityModelTileLoader(tileTreeProps));
            IModelApp_1.IModelApp.viewManager.onNewTilesReady();
        }).catch((_err) => tileTreeState.loadStatus = TileTree_1.TileTree.LoadStatus.NotFound);
    }
    static async getAccessToken() {
        if (!IModelApp_1.IModelApp.authorizationClient || !IModelApp_1.IModelApp.authorizationClient.hasSignedIn)
            return undefined; // Not signed in
        let accessToken;
        try {
            accessToken = await IModelApp_1.IModelApp.authorizationClient.getAccessToken();
        }
        catch (error) {
            return undefined;
        }
        return accessToken;
    }
    static async getTileTreeProps(url, tilesetToDbJson, iModel) {
        if (!url)
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "Unable to read reality data");
        const accessToken = await this.getAccessToken();
        const tileClient = new RealityModelTileClient(url, accessToken);
        const json = await tileClient.getRootDocument(url);
        const ecefLocation = iModel.ecefLocation;
        let rootTransform = ecefLocation ? ecefLocation.getTransform().inverse() : geometry_core_1.Transform.createIdentity();
        if (json.root.transform)
            rootTransform = rootTransform.multiplyTransformTransform(RealityModelTileUtils.transformFromJson(json.root.transform));
        else if (json.root.boundingVolume && Array.isArray(json.root.boundingVolume.region))
            rootTransform = geometry_core_1.Transform.createTranslationXYZ(0, 0, (json.root.boundingVolume.region[4] + json.root.boundingVolume.region[5]) / 2.0).multiplyTransformTransform(rootTransform);
        if (undefined !== tilesetToDbJson)
            rootTransform = geometry_core_1.Transform.fromJSON(tilesetToDbJson).multiplyTransformTransform(rootTransform);
        return new RealityModelTileTreeProps(json, tileClient, rootTransform);
    }
}
exports.RealityModelTileTree = RealityModelTileTree;
/**
 * ###TODO temporarly here for testing, needs to be moved to the clients repo
 * @internal
 * This class encapsulates access to a reality data wether it be from local access, http or RDS
 * The url provided at the creation is parsed to determine if this is a RDS (ProjectWise Context Share) reference.
 * If not then it is considered local (ex: C:\temp\TileRoot.json) or plain http access (http://someserver.com/data/TileRoot.json)
 * There is a one to one relationship between a reality data and the instances of present class.
 */
class RealityModelTileClient {
    // ###TODO we should be able to pass the projectId / tileId directly, instead of parsing the url
    // But if the present can also be used by non PW Context Share stored data then the url is required and token is not. Possibly two classes inheriting from common interface.
    constructor(url, accessToken) {
        this._baseUrl = ""; // For use by all Reality Data. For RD stored on PW Context Share, represents the portion from the root of the Azure Blob Container
        this.rdsProps = this.parseUrl(url); // Note that returned is undefined if url does not refer to a PW Context Share reality data.
        this._token = accessToken;
    }
    async initializeRDSRealityData(requestContext) {
        requestContext.enter();
        if (undefined !== this.rdsProps) {
            if (!this._realityData) {
                // TODO Temporary fix ... the root document may not be located at the root. We need to set the base URL even for RD stored on server
                // though this base URL is only the part relative to the root of the blob contining the data.
                this._realityData = await RealityModelTileClient._client.getRealityData(requestContext, this.rdsProps.projectId, this.rdsProps.tilesId);
                requestContext.enter();
                // A reality data that has not root document set should not be considered.
                const rootDocument = (this._realityData.rootDocument ? this._realityData.rootDocument : "");
                this.setBaseUrl(rootDocument);
            }
        }
    }
    // ###TODO temporary means of extracting the tileId and projectId from the given url
    // This is the method that determines if the url refers to Reality Data stored on PW Context Share. If not then undefined is returned.
    parseUrl(url) {
        const urlParts = url.split("/").map((entry) => entry.replace(/%2D/g, "-"));
        const tilesId = urlParts.find(bentleyjs_core_1.Guid.isGuid);
        let props;
        if (undefined !== tilesId) {
            let projectId = urlParts.find((val) => val.includes("--")).split("--")[1];
            // ###TODO This is a temporary workaround for accessing the reality meshes with a test account
            // The hardcoded project id corresponds to a project setup to yied access to the test account which is linked to the tileId
            if (projectId === "Server")
                projectId = "fb1696c8-c074-4c76-a539-a5546e048cc6";
            props = { projectId, tilesId };
        }
        return props;
    }
    // This is to set the root url fromt he provided root document path.
    // If the root document is stored on PW Context Share then the root document property of the Reality Data is provided,
    // otherwise the full path to root document is given.
    // The base URL contains the base URL from which tile relative path are constructed.
    // The tile's path root will need to be reinserted for child tiles to return a 200
    setBaseUrl(url) {
        const urlParts = url.split("/");
        urlParts.pop();
        if (urlParts.length === 0)
            this._baseUrl = "";
        else
            this._baseUrl = urlParts.join("/") + "/";
    }
    // ### TODO. Technically the url should not be required. If the reality data encapsulated is stored on PW Context Share then
    // the relative path to root document is extracted from the reality data. Otherwise the full url to root document should have been provided at
    // the construction of the instance.
    async getRootDocument(url) {
        if (this.rdsProps && this._token) {
            const authRequestContext = new FrontendRequestContext_1.AuthorizedFrontendRequestContext(this._token);
            authRequestContext.enter();
            await this.initializeRDSRealityData(authRequestContext); // Only needed for PW Context Share data ... return immediately otherwise.
            authRequestContext.enter();
            return this._realityData.getRootDocumentJson(authRequestContext);
        }
        // The following is only if the reality data is not stored on PW Context Share.
        this.setBaseUrl(url);
        const requestContext = new FrontendRequestContext_1.FrontendRequestContext();
        return imodeljs_clients_1.getJson(requestContext, url);
    }
    /**
     * Returns the tile content. The path to the tile is relative to the base url of present reality data whatever the type.
     */
    async getTileContent(url) {
        const requestContext = this._token ? new FrontendRequestContext_1.AuthorizedFrontendRequestContext(this._token) : new FrontendRequestContext_1.FrontendRequestContext();
        requestContext.enter();
        if (this.rdsProps && this._token) {
            await this.initializeRDSRealityData(requestContext); // Only needed for PW Context Share data ... return immediately otherwise.
            requestContext.enter();
        }
        let tileUrl = url;
        if (undefined !== this._baseUrl) {
            tileUrl = this._baseUrl + url;
            if (undefined !== this.rdsProps && undefined !== this._token)
                return this._realityData.getTileContent(requestContext, tileUrl);
            return imodeljs_clients_1.getArrayBuffer(requestContext, tileUrl);
        }
        throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "Unable to determine reality data content url");
    }
    /**
     * Returns the tile content in json format. The path to the tile is relative to the base url of present reality data whatever the type.
     */
    async getTileJson(url) {
        const requestContext = this._token ? new FrontendRequestContext_1.AuthorizedFrontendRequestContext(this._token) : new FrontendRequestContext_1.FrontendRequestContext();
        requestContext.enter();
        if (this.rdsProps && this._token) {
            await this.initializeRDSRealityData(requestContext); // Only needed for PW Context Share data ... return immediately otherwise.
            requestContext.enter();
        }
        let tileUrl = url;
        if (undefined !== this._baseUrl) {
            tileUrl = this._baseUrl + url;
            if (undefined !== this.rdsProps && undefined !== this._token)
                return this._realityData.getTileJson(requestContext, tileUrl);
            return imodeljs_clients_1.getJson(requestContext, tileUrl);
        }
        throw new imodeljs_common_1.IModelError(bentleyjs_core_1.BentleyStatus.ERROR, "Unable to determine reality data json url");
    }
}
RealityModelTileClient._client = new imodeljs_clients_1.RealityDataServicesClient(); // WSG Client for accessing Reality Data on PW Context Share
exports.RealityModelTileClient = RealityModelTileClient;


/***/ }),

/***/ "./lib/tile/TileAdmin.js":
/*!*******************************!*\
  !*** ./lib/tile/TileAdmin.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const IModelConnection_1 = __webpack_require__(/*! ../IModelConnection */ "./lib/IModelConnection.js");
const TileRequest_1 = __webpack_require__(/*! ./TileRequest */ "./lib/tile/TileRequest.js");
/** Provides functionality associated with [[Tile]]s, mostly in the area of scheduling requests for tile content.
 * The TileAdmin tracks [[Viewport]]s which have requested tile content, maintaining a priority queue of pending requests and
 * a set of active requests. On each update it identifies previously-requested tiles whose content no viewport is interested in any longer and
 * cancels them. It then pulls pending requests off the queue and dispatches them into the active set until either the maximum number of
 * simultaneously-active requests is reached or the queue becomes empty.
 * @alpha
 */
class TileAdmin {
    /** Create a TileAdmin. Chiefly intended for use by subclasses of [[IModelApp]] to customize the behavior of the TileAdmin.
     * @param props Options for customizing the behavior of the TileAdmin.
     * @returns the TileAdmin
     * @beta
     */
    static create(props) {
        return new Admin(props);
    }
}
exports.TileAdmin = TileAdmin;
/** @alpha */
(function (TileAdmin) {
    /** A set of [[Viewport]]s.
     * ViewportSets are managed and cached by [[TileAdmin]] such that any number of [[TileRequest]]s associated with the same set of viewports will
     * use the same ViewportSet object.
     * @internal
     */
    class ViewportSet extends bentleyjs_core_1.SortedArray {
        constructor(vp) {
            super((lhs, rhs) => lhs.viewportId - rhs.viewportId);
            if (undefined !== vp)
                this.insert(vp);
        }
        clone(out) {
            if (undefined === out)
                out = new ViewportSet();
            else
                out.clear();
            for (let i = 0; i < this.length; i++)
                out._array.push(this._array[i]);
            return out;
        }
    }
    TileAdmin.ViewportSet = ViewportSet;
})(TileAdmin = exports.TileAdmin || (exports.TileAdmin = {}));
function compareTilePriorities(lhs, rhs) {
    let diff = lhs.loader.priority - rhs.loader.priority;
    if (0 === diff) {
        diff = lhs.loader.compareTilePriorities(lhs, rhs);
    }
    return diff;
}
class Queue extends bentleyjs_core_1.PriorityQueue {
    constructor() {
        super((lhs, rhs) => compareTilePriorities(lhs.tile, rhs.tile));
    }
    has(request) {
        return this._array.indexOf(request) >= 0;
    }
}
function compareViewportSets(lhs, rhs) {
    if (lhs === rhs)
        return 0;
    let diff = lhs.length - rhs.length;
    if (0 === diff) {
        for (let i = 0; i < lhs.length; i++) {
            const lhvp = lhs.get(i);
            const rhvp = rhs.get(i);
            diff = lhvp.viewportId - rhvp.viewportId;
            if (0 !== diff)
                break;
        }
    }
    return diff;
}
// The scheduler needs to know about all viewports which have tile requests.
// Each request needs to know the set of viewports for which it has been requested.
// We don't want to duplicate the latter per-Request - in addition to wasting memory, that would
// also require us to traverse all requests whenever a viewport becomes un-tracked in order to remove it from their sets.
// This class holds unique sets of viewports and doles them out to Requests.
class UniqueViewportSets extends bentleyjs_core_1.SortedArray {
    constructor() {
        super((lhs, rhs) => compareViewportSets(lhs, rhs));
        this.emptySet = new TileAdmin.ViewportSet();
        this._scratchSet = new TileAdmin.ViewportSet();
        Object.freeze(this.emptySet);
    }
    eraseAt(index) {
        bentleyjs_core_1.assert(index < this.length && index >= 0);
        this._array.splice(index, 1);
    }
    getForViewport(vp) {
        for (let i = 0; i < this.length; i++) {
            const set = this._array[i];
            if (1 === set.length && set.get(0) === vp)
                return set;
        }
        const newSet = new TileAdmin.ViewportSet(vp);
        this.insert(newSet);
        return newSet;
    }
    getViewportSet(vp, vps) {
        if (undefined === vps || vps.isEmpty)
            return this.getForViewport(vp);
        // Use the scratch set for equality comparison - only allocate if no equivalent set already exists.
        const toFind = vps.clone(this._scratchSet);
        toFind.insert(vp);
        const found = this.findEqual(toFind);
        if (undefined !== found) {
            toFind.clear();
            return found;
        }
        const newSet = toFind.clone();
        toFind.clear();
        this.insert(newSet);
        return newSet;
    }
    clearAll() {
        this.forEach((set) => set.clear());
        this.clear();
    }
}
class RequestsPerViewport extends bentleyjs_core_1.Dictionary {
    constructor() {
        super((lhs, rhs) => lhs.viewportId - rhs.viewportId);
    }
}
class Admin extends TileAdmin {
    constructor(options) {
        super();
        this._requestsPerViewport = new RequestsPerViewport();
        this._uniqueViewportSets = new UniqueViewportSets();
        this._activeRequests = new Set();
        this._swapActiveRequests = new Set();
        this._pendingRequests = new Queue();
        this._swapPendingRequests = new Queue();
        this._numCanceled = 0;
        this._totalCompleted = 0;
        this._totalFailed = 0;
        this._totalTimedOut = 0;
        this._totalEmpty = 0;
        this._totalUndisplayable = 0;
        this._totalElided = 0;
        this._rpcInitialized = false;
        if (undefined === options)
            options = {};
        this._throttle = !options.disableThrottling;
        this._maxActiveRequests = undefined !== options.maxActiveRequests ? options.maxActiveRequests : 10;
        this._retryInterval = undefined !== options.retryInterval ? options.retryInterval : 1000;
        this._enableInstancing = undefined !== options.enableInstancing ? options.enableInstancing : true;
        this._maxMajorVersion = undefined !== options.maximumMajorTileFormatVersion ? options.maximumMajorTileFormatVersion : 4 /* Major */;
        this._useProjectExtents = !!options.useProjectExtents;
        let expiration = undefined !== options.tileExpirationTime ? options.tileExpirationTime : 20;
        expiration = Math.max(expiration, 60);
        expiration = Math.min(expiration, 5);
        this._expirationTime = bentleyjs_core_1.BeDuration.fromSeconds(expiration);
        this._removeIModelConnectionOnCloseListener = IModelConnection_1.IModelConnection.onClose.addListener((iModel) => this.onIModelClosed(iModel));
    }
    get emptyViewportSet() { return this._uniqueViewportSets.emptySet; }
    get statistics() {
        return {
            numPendingRequests: this._pendingRequests.length,
            numActiveRequests: this._activeRequests.size,
            numCanceled: this._numCanceled,
            totalCompletedRequests: this._totalCompleted,
            totalFailedRequests: this._totalFailed,
            totalTimedOutRequests: this._totalTimedOut,
            totalEmptyTiles: this._totalEmpty,
            totalUndisplayableTiles: this._totalUndisplayable,
            totalElidedTiles: this._totalElided,
        };
    }
    resetStatistics() {
        this._totalCompleted = this._totalFailed = this._totalTimedOut = this._totalEmpty = this._totalUndisplayable = this._totalElided = 0;
    }
    get enableInstancing() { return this._enableInstancing && IModelApp_1.IModelApp.renderSystem.supportsInstancing; }
    get useProjectExtents() { return this._useProjectExtents; }
    get tileExpirationTime() { return this._expirationTime; }
    getMaximumMajorTileFormatVersion(formatVersion) {
        // The input is from the backend, telling us precisely the maximum major+minor version it can produce.
        // Ensure front-end does not request tiles of a newer major version than backend can supply or it can read; and also limit major version
        // to that optionally configured by the app.
        let majorVersion = this._maxMajorVersion;
        if (undefined !== formatVersion)
            majorVersion = Math.min((formatVersion >>> 0x10), majorVersion);
        // Version number less than 1 is invalid - ignore
        majorVersion = Math.max(majorVersion, 1);
        // Version number greater than current known version ignored
        majorVersion = Math.min(majorVersion, 4 /* Major */);
        // Version numbers are integers - round down
        return Math.max(Math.floor(majorVersion), 1);
    }
    get maxActiveRequests() { return this._maxActiveRequests; }
    set maxActiveRequests(max) {
        if (max > 0)
            this._maxActiveRequests = max;
    }
    process() {
        this._numCanceled = 0;
        // Mark all requests as being associated with no Viewports, indicating they are no longer needed.
        this._uniqueViewportSets.clearAll();
        // Process all requests, enqueueing on new queue.
        const previouslyPending = this._pendingRequests;
        this._pendingRequests = this._swapPendingRequests;
        this._swapPendingRequests = previouslyPending;
        const previouslyActive = this._activeRequests;
        this._activeRequests = this._swapActiveRequests;
        this._requestsPerViewport.forEach((key, value) => this.processRequests(key, value));
        if (!this._throttle)
            return;
        // Cancel any previously pending requests which are no longer needed.
        for (const queued of previouslyPending)
            if (queued.viewports.isEmpty)
                this.cancel(queued);
        previouslyPending.clear();
        // Cancel any active requests which are no longer needed.
        for (const active of previouslyActive) {
            if (active.viewports.isEmpty)
                this.cancel(active);
            else
                this._activeRequests.add(active);
        }
        previouslyActive.clear();
        this._swapActiveRequests = previouslyActive;
        // Fill up the active requests from the queue.
        while (this._activeRequests.size < this._maxActiveRequests) {
            const request = this._pendingRequests.pop();
            if (undefined === request)
                break;
            else
                this.dispatch(request);
        }
    }
    processRequests(vp, tiles) {
        for (const tile of tiles) {
            if (undefined === tile.request) {
                // ###TODO: This assertion triggers for AttachmentViewports used for rendering 3d sheet attachments.
                // Determine why and fix.
                // assert(tile.loadStatus === Tile.LoadStatus.NotLoaded);
                if (0 /* NotLoaded */ === tile.loadStatus) {
                    const request = new TileRequest_1.TileRequest(tile, vp);
                    tile.request = request;
                    if (this._throttle)
                        this._pendingRequests.push(request);
                    else
                        this.dispatch(request);
                }
            }
            else {
                const req = tile.request;
                bentleyjs_core_1.assert(undefined !== req);
                if (undefined !== req) {
                    // Request may already be dispatched (in this._activeRequests) - if so do not re-enqueue!
                    if (req.isQueued && 0 === req.viewports.length)
                        this._pendingRequests.push(req);
                    req.addViewport(vp);
                    bentleyjs_core_1.assert(0 < req.viewports.length);
                }
            }
        }
    }
    getNumRequestsForViewport(vp) {
        const requests = this._requestsPerViewport.get(vp);
        return undefined !== requests ? requests.size : 0;
    }
    requestTiles(vp, tiles) {
        this._requestsPerViewport.set(vp, tiles);
    }
    forgetViewport(vp) {
        // NB: vp will be removed from ViewportSets in process() - but if we can establish that only this vp wants a given tile, cancel its request immediately.
        const tiles = this._requestsPerViewport.get(vp);
        if (undefined !== tiles) {
            for (const tile of tiles) {
                const request = tile.request;
                if (undefined !== request && 1 === request.viewports.length)
                    request.cancel();
            }
            this._requestsPerViewport.delete(vp);
        }
    }
    onIModelClosed(iModel) {
        this._requestsPerViewport.forEach((vp, _req) => {
            if (vp.iModel === iModel)
                this.forgetViewport(vp);
        });
    }
    onShutDown() {
        this._removeIModelConnectionOnCloseListener();
        for (const request of this._activeRequests)
            request.cancel();
        this._activeRequests.clear();
        for (const queued of this._pendingRequests)
            queued.cancel();
        this._requestsPerViewport.clear();
        this._uniqueViewportSets.clear();
    }
    dispatch(req) {
        this._activeRequests.add(req);
        req.dispatch().then(() => this.dropActiveRequest(req)) // tslint:disable-line no-floating-promises
            .catch(() => this.dropActiveRequest(req));
    }
    cancel(req) {
        req.cancel();
        ++this._numCanceled;
    }
    dropActiveRequest(req) {
        bentleyjs_core_1.assert(this._activeRequests.has(req) || req.isCanceled);
        this._activeRequests.delete(req);
    }
    getViewportSet(vp, vps) {
        return this._uniqueViewportSets.getViewportSet(vp, vps);
    }
    async requestTileTreeProps(iModel, treeId) {
        this.initializeRpc();
        const intfc = imodeljs_common_1.IModelTileRpcInterface.getClient();
        return intfc.requestTileTreeProps(iModel.iModelToken.toJSON(), treeId);
    }
    async requestTileContent(iModel, treeId, contentId) {
        this.initializeRpc();
        const intfc = imodeljs_common_1.IModelTileRpcInterface.getClient();
        return intfc.requestTileContent(iModel.iModelToken.toJSON(), treeId, contentId);
    }
    initializeRpc() {
        // Would prefer to do this in constructor - but nothing enforces that the app initializes the rpc interfaces before it creates the TileAdmin (via IModelApp.startup()) - so do it on first request instead.
        if (this._rpcInitialized)
            return;
        this._rpcInitialized = true;
        const retryInterval = this._retryInterval;
        imodeljs_common_1.RpcOperation.lookup(imodeljs_common_1.IModelTileRpcInterface, "requestTileTreeProps").policy.retryInterval = () => retryInterval;
        const policy = imodeljs_common_1.RpcOperation.lookup(imodeljs_common_1.IModelTileRpcInterface, "requestTileContent").policy;
        policy.retryInterval = () => retryInterval;
        policy.allowResponseCaching = () => imodeljs_common_1.RpcResponseCacheControl.Immutable;
    }
    onTileFailed(_tile) { ++this._totalFailed; }
    onTileTimedOut(_tile) { ++this._totalTimedOut; }
    onTileElided() { ++this._totalElided; }
    onTileCompleted(tile) {
        ++this._totalCompleted;
        if (tile.isEmpty)
            ++this._totalEmpty;
        else if (!tile.isDisplayable)
            ++this._totalUndisplayable;
    }
}


/***/ }),

/***/ "./lib/tile/TileIO.js":
/*!****************************!*\
  !*** ./lib/tile/TileIO.js ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
// tslint:disable:no-const-enum
/** Provides facilities for deserializing 3d tiles.
 * @internal
 */
var TileIO;
(function (TileIO) {
    /** Given a magic number, return whether it identifies a known tile format. */
    function isValidFormat(format) {
        switch (format) {
            case 0 /* Unknown */:
            case 1835283298 /* B3dm */:
            case 1179937895 /* Gltf */:
            case 1818512745 /* IModel */:
            case 1937010288 /* Pnts */:
            case 1953525091 /* Cmpt */:
            case 1835283305 /* I3dm */:
                return true;
            default:
                return false;
        }
    }
    /** Given a magic number, attempt to convert it to a known tile Format. */
    function formatFromNumber(formatNumber) {
        const format = formatNumber;
        return isValidFormat(format) ? format : 0 /* Unknown */;
    }
    /**
     * Wraps a binary stream along with a current read position. The position can be adjusted by the caller.
     * Methods and properties beginning with 'next' consume data at the current read position and advance it
     * by the size of the data read.
     * @internal
     */
    class StreamBuffer {
        constructor(buffer) {
            this._curPos = 0;
            this._view = new DataView(buffer);
        }
        /** The number of bytes in this stream */
        get length() { return this._view.byteLength; }
        /** Returns true if the current read position has been advanced past the end of the stream */
        get isPastTheEnd() { return this.curPos > this.length; }
        /** Returns the current read position as an index into the stream of bytes */
        get curPos() { return this._curPos; }
        /** Sets the current read position to the specified index into the stream of bytes */
        set curPos(pos) { this._curPos = pos; bentleyjs_core_1.assert(!this.isPastTheEnd); }
        /** Add the specified number of bytes to the current read position */
        advance(numBytes) { this.curPos = (this.curPos + numBytes); return !this.isPastTheEnd; }
        /** Subtracts the specified number of bytes from the current read position */
        rewind(numBytes) { if (this.curPos - numBytes < 0)
            return false; this.curPos = this.curPos - numBytes; return true; }
        /** Resets the current read position to the beginning of the stream */
        reset() { this.curPos = 0; }
        /** Read a uint8 at the current read position and advance by 1 byte. */
        get nextUint8() { return this.read(1, (view) => view.getUint8(this.curPos)); }
        /** Read a uint16 at the current read position and advance by 2 bytes. */
        get nextUint16() { return this.read(2, (view) => view.getUint16(this.curPos, true)); }
        /** Read a uint32 at the current read position and advance by 4 bytes. */
        get nextUint32() { return this.read(4, (view) => view.getUint32(this.curPos, true)); }
        /** Read a 32-bit floating point number at the current read position and advance by 4 bytes. */
        get nextFloat32() { return this.read(4, (view) => view.getFloat32(this.curPos, true)); }
        /** Read a 64-bit floating point number at the current read position and advance by 8 bytes. */
        get nextFloat64() { return this.read(8, (view) => view.getFloat64(this.curPos, true)); }
        /** Read 3 64-bit floating point numbers at the current read position, advance by 24 bytes, and return a Point3d constructed from the 3 numbers. */
        get nextPoint3d64() { return new geometry_core_1.Point3d(this.nextFloat64, this.nextFloat64, this.nextFloat64); }
        /** Read a uint64 at the current read position, advance by 8 bytes, and return the uint64 value as an Id64String. */
        get nextId64() { return bentleyjs_core_1.Id64.fromUint32Pair(this.nextUint32, this.nextUint32); }
        /** Read the next numBytes bytes into a Uint8Array and advance by numBytes. */
        nextBytes(numBytes) {
            const bytes = new Uint8Array(this.arrayBuffer, this.curPos, numBytes);
            this.advance(numBytes);
            return bytes;
        }
        nextUint32s(numUint32s) {
            const numBytes = numUint32s * 4;
            const uint32s = new Uint32Array(this.arrayBuffer, this.curPos, numUint32s);
            this.advance(numBytes);
            return uint32s;
        }
        /** Returns the underlying array buffer */
        get arrayBuffer() { return this._view.buffer; }
        read(numBytes, read) {
            const result = read(this._view);
            this.advance(numBytes);
            return result;
        }
    }
    TileIO.StreamBuffer = StreamBuffer;
    /**
     * The base header preceding tile data, identifying the tile format and version of that format.
     * Specific tile formats may define their own headers as sub-types of this Header, appending
     * additional format-specific data.
     * @internal
     */
    class Header {
        /** Construct a Header from the binary data at the supplied stream's current read position */
        constructor(stream) {
            this._format = formatFromNumber(stream.nextUint32);
            this.version = stream.nextUint32;
        }
        get format() { return this._format; }
        /** Mark the header as representing invalid data */
        invalidate() { this._format = 0 /* Unknown */; }
    }
    TileIO.Header = Header;
    /** @internal */
    class GeometryCollection {
        constructor(meshes, isComplete, isCurved) {
            this.meshes = meshes;
            this.isComplete = isComplete;
            this.isCurved = isCurved;
        }
        get isEmpty() { return 0 === this.meshes.length; }
    }
    TileIO.GeometryCollection = GeometryCollection;
})(TileIO = exports.TileIO || (exports.TileIO = {}));


/***/ }),

/***/ "./lib/tile/TileRequest.js":
/*!*********************************!*\
  !*** ./lib/tile/TileRequest.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
/** Represents a pending or active request to load the contents of a [[Tile]]. The request coordinates with a [[TileLoader]] to execute the request for tile content and
 * convert the result into a renderable graphic.
 * @internal
 */
class TileRequest {
    constructor(tile, vp) {
        this._state = 0 /* Queued */;
        this.tile = tile;
        this.viewports = IModelApp_1.IModelApp.tileAdmin.getViewportSet(vp);
    }
    get state() { return this._state; }
    get isQueued() { return 0 /* Queued */ === this._state; }
    get isCanceled() { return this.viewports.isEmpty; } // ###TODO: check if IModelConnection closed etc.
    get tree() { return this.tile.root; }
    get loader() { return this.tree.loader; }
    addViewport(vp) {
        this.viewports = IModelApp_1.IModelApp.tileAdmin.getViewportSet(vp, this.viewports);
    }
    /** Transition the request from "queued" to "active", kicking off a series of asynchronous operations usually beginning with an http request, and -
     * if the request is not subsequently canceled - resulting in either a successfully-loaded Tile, or a failed ("not found") Tile.
     */
    async dispatch() {
        try {
            if (this.isCanceled)
                return Promise.resolve();
            bentleyjs_core_1.assert(this._state === 0 /* Queued */);
            this._state = 1 /* Dispatched */;
            const response = await this.loader.requestTileContent(this.tile);
            if (this.isCanceled)
                return Promise.resolve();
            return this.handleResponse(response);
        }
        catch (_err) {
            if (_err.errorNumber && _err.errorNumber === bentleyjs_core_1.IModelStatus.ServerTimeout) {
                // Invalidate scene - if tile is re-selected, it will be re-requested.
                this.notifyAndClear();
                this._state = 4 /* Failed */;
                IModelApp_1.IModelApp.tileAdmin.onTileTimedOut(this.tile);
            }
            else {
                // Unknown error - not retryable.
                this.setFailed();
            }
            return Promise.resolve();
        }
    }
    /** Cancels this request. This leaves the associated Tile's state untouched. */
    cancel() {
        this.notifyAndClear();
        this._state = 4 /* Failed */;
    }
    /** Invalidates the scene of each [[Viewport]] interested in this request - typically because the request succeeded, failed, or was canceled. */
    notify() {
        this.viewports.forEach((vp) => vp.invalidateScene());
    }
    /** Invalidates the scene of each [[Viewport]] interested in this request and clears the set of interested viewports. */
    notifyAndClear() {
        this.notify();
        this.viewports = IModelApp_1.IModelApp.tileAdmin.emptyViewportSet;
        this.tile.request = undefined;
    }
    setFailed() {
        this.notifyAndClear();
        this._state = 4 /* Failed */;
        this.tile.setNotFound();
        IModelApp_1.IModelApp.tileAdmin.onTileFailed(this.tile);
    }
    /** Invoked when the raw tile content becomes available, to convert it into a tile graphic. */
    async handleResponse(response) {
        let data;
        if (undefined !== response) {
            if (typeof response === "string")
                data = bentleyjs_core_1.base64StringToUint8Array(response);
            else if (response instanceof Uint8Array || response instanceof imodeljs_common_1.ImageSource)
                data = response;
            else if (response instanceof ArrayBuffer)
                data = new Uint8Array(response);
        }
        if (undefined === data) {
            this.setFailed();
            return Promise.resolve();
        }
        this._state = 2 /* Loading */;
        try {
            const content = await this.loader.loadTileContent(this.tile, data);
            if (this.isCanceled)
                return Promise.resolve();
            this._state = 3 /* Completed */;
            this.tile.setContent(content);
            this.notifyAndClear();
            IModelApp_1.IModelApp.tileAdmin.onTileCompleted(this.tile);
        }
        catch (_err) {
            this.setFailed();
        }
        return Promise.resolve();
    }
}
exports.TileRequest = TileRequest;


/***/ }),

/***/ "./lib/tile/TileTree.js":
/*!******************************!*\
  !*** ./lib/tile/TileTree.js ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const System_1 = __webpack_require__(/*! ../render/System */ "./lib/render/System.js");
const B3dmTileIO_1 = __webpack_require__(/*! ./B3dmTileIO */ "./lib/tile/B3dmTileIO.js");
const CompositeTileIO_1 = __webpack_require__(/*! ./CompositeTileIO */ "./lib/tile/CompositeTileIO.js");
const I3dmTileIO_1 = __webpack_require__(/*! ./I3dmTileIO */ "./lib/tile/I3dmTileIO.js");
const IModelTileIO_1 = __webpack_require__(/*! ./IModelTileIO */ "./lib/tile/IModelTileIO.js");
const PntsTileIO_1 = __webpack_require__(/*! ./PntsTileIO */ "./lib/tile/PntsTileIO.js");
const TileIO_1 = __webpack_require__(/*! ./TileIO */ "./lib/tile/TileIO.js");
const scratchRange2d = [new geometry_core_1.Point2d(), new geometry_core_1.Point2d(), new geometry_core_1.Point2d(), new geometry_core_1.Point2d()];
function addRangeGraphic(builder, range, is2d) {
    if (!is2d) {
        builder.addRangeBox(range);
        return;
    }
    // 3d box is useless in 2d and will be clipped by near/far planes anyway
    const pts = scratchRange2d;
    pts[0].set(range.low.x, range.low.y);
    pts[1].set(range.high.x, range.low.y);
    pts[2].set(range.high.x, range.high.y);
    pts[3].set(range.low.x, range.high.y);
    builder.addLineString2d(pts, 0);
}
/** A 3d tile within a [[TileTree]].
 * @internal
 */
class Tile {
    constructor(props) {
        this._rangeGraphicType = 0 /* None */;
        this.root = props.root;
        this.range = props.range;
        this.parent = props.parent;
        this.depth = undefined !== this.parent ? this.parent.depth + 1 : 0;
        this._state = 0 /* NotReady */;
        this.contentId = props.contentId;
        this._maximumSize = props.maximumSize;
        this._isLeaf = (true === props.isLeaf);
        this._childrenLastUsed = bentleyjs_core_1.BeTimePoint.now();
        this._contentRange = props.contentRange;
        this._sizeMultiplier = props.sizeMultiplier;
        if (undefined !== (this.transformToRoot = props.transformToRoot)) {
            this.transformToRoot.multiplyRange(props.range, this.range);
            this._localRange = this.range;
            if (undefined !== props.contentRange) {
                this.transformToRoot.multiplyRange(props.contentRange, this._contentRange);
                this._localContentRange = props.contentRange;
            }
        }
        if (!this.root.loader.tileRequiresLoading(props)) {
            this.setIsReady(); // If no contents, this node is for structure only and no content loading is required.
        }
        this.center = this.range.low.interpolate(0.5, this.range.high);
        this.radius = 0.5 * this.range.low.distance(this.range.high);
        this._childrenLoadStatus = this.hasChildren && this.depth < this.root.loader.maxDepth ? TileTree.LoadStatus.NotLoaded : TileTree.LoadStatus.Loaded;
    }
    dispose() {
        this._graphic = bentleyjs_core_1.dispose(this._graphic);
        this._rangeGraphic = bentleyjs_core_1.dispose(this._rangeGraphic);
        this._rangeGraphicType = 0 /* None */;
        if (this._children)
            for (const child of this._children)
                bentleyjs_core_1.dispose(child);
        this._children = undefined;
        this._state = 5 /* Abandoned */;
    }
    collectStatistics(stats) {
        if (undefined !== this._graphic)
            this._graphic.collectStatistics(stats);
        if (undefined !== this._children)
            for (const child of this._children)
                child.collectStatistics(stats);
    }
    /* ###TODO
    public cancelAllLoads(): void {
      if (this.isLoading) {
        this.loadStatus = Tile.LoadStatus.NotLoaded;
        if (this._children !== undefined) {
          for (const child of this._children)
            child.cancelAllLoads();
        }
      }
    }
    */
    get loadStatus() {
        switch (this._state) {
            case 0 /* NotReady */: {
                if (undefined === this.request)
                    return 0 /* NotLoaded */;
                else if (2 /* Loading */ === this.request.state)
                    return 2 /* Loading */;
                bentleyjs_core_1.assert(3 /* Completed */ !== this.request.state && 4 /* Failed */ !== this.request.state); // this.request should be undefined in these cases...
                return 1 /* Queued */;
            }
            case 3 /* Ready */: {
                bentleyjs_core_1.assert(undefined === this.request);
                return 3 /* Ready */;
            }
            case 4 /* NotFound */: {
                bentleyjs_core_1.assert(undefined === this.request);
                return 4 /* NotFound */;
            }
            default: {
                bentleyjs_core_1.assert(5 /* Abandoned */ === this._state);
                return 5 /* Abandoned */;
            }
        }
    }
    get isLoading() { return 2 /* Loading */ === this.loadStatus; }
    get isNotFound() { return 4 /* NotFound */ === this.loadStatus; }
    get isReady() { return 3 /* Ready */ === this.loadStatus; }
    setContent(content) {
        const { graphic, isLeaf, contentRange, sizeMultiplier } = content;
        this._graphic = graphic;
        // NB: If this tile has no graphics, it may or may not have children - but we don't want to load the children until
        // this tile is too coarse for view based on its size in pixels.
        // That is different than an "undisplayable" tile (maximumSize=0) whose children should be loaded immediately.
        if (undefined !== graphic && 0 === this._maximumSize)
            this._maximumSize = 512;
        if (undefined !== isLeaf && isLeaf !== this._isLeaf) {
            this._isLeaf = isLeaf;
            this.unloadChildren();
        }
        if (undefined !== sizeMultiplier && (undefined === this._sizeMultiplier || sizeMultiplier > this._sizeMultiplier)) {
            this._sizeMultiplier = sizeMultiplier;
            this.contentId = this.loader.adjustContentIdSizeMultiplier(this.contentId, sizeMultiplier);
            if (undefined !== this._children && this._children.length > 1)
                this.unloadChildren();
        }
        if (undefined !== contentRange)
            this._contentRange = contentRange;
        this._emptySubRangeMask = content.emptySubRangeMask;
        this.setIsReady();
    }
    setIsReady() { this._state = 3 /* Ready */; IModelApp_1.IModelApp.viewManager.onNewTilesReady(); }
    setNotFound() { this._state = 4 /* NotFound */; }
    setAbandoned() {
        const children = this.children;
        if (undefined !== children)
            for (const child of children)
                child.setAbandoned();
        this._state = 5 /* Abandoned */;
    }
    get maximumSize() { return this._maximumSize * this.sizeMultiplier; }
    get isEmpty() { return this.isReady && !this.hasGraphics && !this.hasChildren; }
    get hasChildren() { return !this.isLeaf; }
    get contentRange() {
        if (undefined !== this._contentRange)
            return this._contentRange;
        else if (undefined === this.parent && undefined !== this.root.contentRange)
            return this.root.contentRange;
        else
            return this.range;
    }
    get isLeaf() { return this._isLeaf; }
    get isDisplayable() { return this.maximumSize > 0; }
    get isParentDisplayable() { return undefined !== this.parent && this.parent.isDisplayable; }
    get isUndisplayableRootTile() { return undefined === this.parent && !this.isDisplayable; }
    get emptySubRangeMask() { return undefined !== this._emptySubRangeMask ? this._emptySubRangeMask : 0; }
    get graphics() { return this._graphic; }
    get hasGraphics() { return undefined !== this.graphics; }
    get sizeMultiplier() { return undefined !== this._sizeMultiplier ? this._sizeMultiplier : 1.0; }
    get hasSizeMultiplier() { return undefined !== this._sizeMultiplier; }
    get children() { return this._children; }
    get iModel() { return this.root.iModel; }
    get yAxisUp() { return this.root.yAxisUp; }
    get loader() { return this.root.loader; }
    get hasContentRange() { return undefined !== this._contentRange; }
    isRegionCulled(args) { return Tile._scratchRootSphere.init(this.center, this.radius), this.isCulled(this.range, args, Tile._scratchRootSphere); }
    isContentCulled(args) { return this.isCulled(this.contentRange, args); }
    getRangeGraphic(context) {
        const type = context.viewport.debugBoundingBoxes;
        if (type === this._rangeGraphicType)
            return this._rangeGraphic;
        this._rangeGraphicType = type;
        this._rangeGraphic = bentleyjs_core_1.dispose(this._rangeGraphic);
        if (0 /* None */ !== type) {
            const builder = context.createSceneGraphicBuilder();
            if (3 /* Both */ === type) {
                builder.setSymbology(imodeljs_common_1.ColorDef.blue, imodeljs_common_1.ColorDef.blue, 1);
                addRangeGraphic(builder, this.range, this.root.is2d);
                if (this.hasContentRange) {
                    builder.setSymbology(imodeljs_common_1.ColorDef.red, imodeljs_common_1.ColorDef.red, 1);
                    addRangeGraphic(builder, this.contentRange, this.root.is2d);
                }
            }
            else if (4 /* ChildVolumes */ === type) {
                const ranges = computeChildRanges(this);
                for (const range of ranges) {
                    const color = range.isEmpty ? imodeljs_common_1.ColorDef.blue : imodeljs_common_1.ColorDef.green;
                    builder.setSymbology(color, color, 1);
                    addRangeGraphic(builder, range.range, this.root.is2d);
                }
            }
            else if (5 /* Sphere */ === type) {
                builder.setSymbology(imodeljs_common_1.ColorDef.green, imodeljs_common_1.ColorDef.green, 1);
                const x = new geometry_core_1.Vector3d(this.radius, 0, 0);
                const y = new geometry_core_1.Vector3d(0, this.radius, 0);
                const z = new geometry_core_1.Vector3d(0, 0, this.radius);
                builder.addArc(geometry_core_1.Arc3d.create(this.center, x, y), false, false);
                builder.addArc(geometry_core_1.Arc3d.create(this.center, x, z), false, false);
                builder.addArc(geometry_core_1.Arc3d.create(this.center, y, z), false, false);
            }
            else {
                const color = this.hasSizeMultiplier ? imodeljs_common_1.ColorDef.red : (this.isLeaf ? imodeljs_common_1.ColorDef.blue : imodeljs_common_1.ColorDef.green);
                builder.setSymbology(color, color, 1);
                const range = 2 /* Content */ === type ? this.contentRange : this.range;
                addRangeGraphic(builder, range, this.root.is2d);
            }
            this._rangeGraphic = builder.finish();
        }
        return this._rangeGraphic;
    }
    /** Returns the range of this tile's contents in world coordinates. */
    computeWorldContentRange() {
        const range = new geometry_core_1.Range3d();
        if (!this.contentRange.isNull)
            this.root.location.multiplyRange(this.contentRange, range);
        return range;
    }
    computeVisibility(args) {
        const forcedDepth = this.root.debugForcedDepth;
        if (undefined !== forcedDepth) {
            if (this.depth === forcedDepth)
                return 2 /* Visible */;
            else
                return 1 /* TooCoarse */;
        }
        // NB: We test for region culling before isDisplayable - otherwise we will never unload children of undisplayed tiles when
        // they are outside frustum
        if (this.isEmpty || this.isRegionCulled(args))
            return 0 /* OutsideFrustum */;
        // some nodes are merely for structure and don't have any geometry
        if (!this.isDisplayable)
            return 1 /* TooCoarse */;
        const hasContentRange = this.hasContentRange;
        if (!this.hasChildren) {
            if (hasContentRange && this.isContentCulled(args))
                return 0 /* OutsideFrustum */;
            else
                return 2 /* Visible */; // it's a leaf node
        }
        const radius = args.getTileRadius(this); // use a sphere to test pixel size. We don't know the orientation of the image within the bounding box.
        const center = args.getTileCenter(this);
        const pixelSizeAtPt = args.getPixelSizeAtPoint(center);
        const pixelSize = 0 !== pixelSizeAtPt ? radius / pixelSizeAtPt : 1.0e-3;
        if (pixelSize > this.maximumSize * args.tileSizeModifier)
            return 1 /* TooCoarse */;
        else if (hasContentRange && this.isContentCulled(args))
            return 0 /* OutsideFrustum */;
        else
            return 2 /* Visible */;
    }
    selectTiles(selected, args, numSkipped = 0) {
        const vis = this.computeVisibility(args);
        if (0 /* OutsideFrustum */ === vis) {
            this.unloadChildren(args.purgeOlderThan);
            return 0 /* No */;
        }
        if (2 /* Visible */ === vis) {
            // This tile is of appropriate resolution to draw. If need loading or refinement, enqueue.
            if (!this.isReady) {
                args.insertMissing(this);
            }
            if (this.hasGraphics) {
                // It can be drawn - select it
                ++args.context.viewport.numReadyTiles;
                selected.push(this);
                this.unloadChildren(args.purgeOlderThan);
            }
            else if (!this.isReady) {
                // It can't be drawn. If direct children are drawable, draw them in this tile's place; otherwise draw the parent.
                // Do not load/request the children for this purpose.
                const initialSize = selected.length;
                const kids = this.children;
                if (undefined === kids)
                    return 1 /* Yes */;
                for (const kid of kids) {
                    if (0 /* OutsideFrustum */ !== kid.computeVisibility(args)) {
                        if (!kid.hasGraphics) {
                            selected.length = initialSize;
                            return 1 /* Yes */;
                        }
                        else {
                            selected.push(kid);
                        }
                    }
                }
                this._childrenLastUsed = args.now;
            }
            // We're drawing either this tile, or its direct children.
            return 0 /* No */;
        }
        // This tile is too coarse to draw. Try to draw something more appropriate.
        // If it is not ready to draw, we may want to skip loading in favor of loading its descendants.
        let canSkipThisTile = this.isReady || this.isParentDisplayable;
        if (canSkipThisTile && this.isDisplayable) { // skipping an undisplayable tile doesn't count toward the maximum
            // Some tiles do not sub-divide - they only facet the same geometry to a higher resolution. We can skip directly to the correct resolution.
            const isNotReady = !this.isReady && !this.hasGraphics && !this.hasSizeMultiplier;
            if (isNotReady) {
                if (numSkipped >= this.root.maxTilesToSkip)
                    canSkipThisTile = false;
                else
                    numSkipped += 1;
            }
        }
        const childrenLoadStatus = this.loadChildren(); // NB: asynchronous
        const children = canSkipThisTile ? this.children : undefined;
        if (canSkipThisTile && TileTree.LoadStatus.Loading === childrenLoadStatus)
            args.markChildrenLoading();
        if (undefined !== children) {
            // If we are the root tile and we are not displayable, then we want to draw *any* currently available children in our place, or else we would draw nothing.
            // Otherwise, if we want to draw children in our place, we should wait for *all* of them to load, or else we would show missing chunks where not-yet-loaded children belong.
            const isUndisplayableRootTile = this.isUndisplayableRootTile;
            this._childrenLastUsed = args.now;
            let drawChildren = true;
            const initialSize = selected.length;
            for (const child of children) {
                // NB: We must continue iterating children so that they can be requested if missing.
                if (1 /* Yes */ === child.selectTiles(selected, args, numSkipped)) {
                    if (child.loadStatus === 4 /* NotFound */) {
                        // At least one child we want to draw failed to load. e.g., we reached max depth of map tile tree. Draw parent instead.
                        drawChildren = canSkipThisTile = false;
                    }
                    else {
                        // At least one child we want to draw is not yet loaded. Wait for it to load before drawing it and its siblings, unless we have nothing to draw in their place.
                        drawChildren = isUndisplayableRootTile;
                    }
                }
            }
            if (drawChildren)
                return 0 /* No */;
            // Some types of tiles (like maps) allow the ready children to be drawn on top of the parent while other children are not yet loaded.
            if (this.root.loader.parentsAndChildrenExclusive)
                selected.length = initialSize;
        }
        if (this.isReady) {
            if (this.hasGraphics) {
                selected.push(this);
                if (!canSkipThisTile) {
                    // This tile is too coarse, but we require loading it before we can start loading higher-res children.
                    ++args.context.viewport.numReadyTiles;
                }
            }
            return 0 /* No */;
        }
        // This tile is not ready to be drawn. Request it *only* if we cannot skip it.
        if (!canSkipThisTile)
            args.insertMissing(this);
        return this.isParentDisplayable ? 1 /* Yes */ : 0 /* No */;
    }
    drawGraphics(args) {
        if (undefined !== this.graphics) {
            args.graphics.add(this.graphics);
            const rangeGraphics = this.getRangeGraphic(args.context);
            if (undefined !== rangeGraphics)
                args.graphics.add(rangeGraphics);
        }
    }
    unloadChildren(olderThan) {
        const children = this.children;
        if (undefined === children) {
            return;
        }
        if (undefined !== olderThan && (this.isUndisplayableRootTile || this._childrenLastUsed.milliseconds > olderThan.milliseconds)) {
            // this node has been used recently, or should never be unloaded based on expiration time. Keep it, but potentially unload its grandchildren.
            for (const child of children)
                child.unloadChildren(olderThan);
        }
        else {
            for (const child of children) {
                child.setAbandoned();
                child.dispose();
            }
            this._children = undefined;
            this._childrenLoadStatus = TileTree.LoadStatus.NotLoaded;
        }
    }
    isCulled(range, args, sphere) {
        const box = imodeljs_common_1.Frustum.fromRange(range, Tile._scratchRootFrustum);
        const worldBox = box.transformBy(args.location, Tile._scratchWorldFrustum);
        const worldSphere = sphere ? sphere.transformBy(args.location, Tile._scratchWorldSphere) : undefined;
        // Test against frustum.
        if (0 /* Outside */ === args.frustumPlanes.computeFrustumContainment(worldBox, worldSphere))
            return true;
        // Test against TileTree's own clip volume, if any.
        if (undefined !== args.clip && geometry_core_1.ClipPlaneContainment.StronglyOutside === args.clip.classifyPointContainment(box.points))
            return true;
        // Test against view clip, if any (will be undefined if TileTree does not want view clip applied to it).
        if (undefined !== args.viewClip && geometry_core_1.ClipPlaneContainment.StronglyOutside === args.viewClip.classifyPointContainment(worldBox.points))
            return true;
        return false;
    }
    loadChildren() {
        if (TileTree.LoadStatus.NotLoaded === this._childrenLoadStatus) {
            this._childrenLoadStatus = TileTree.LoadStatus.Loading;
            this.root.loader.getChildrenProps(this).then((props) => {
                this._children = [];
                this._childrenLoadStatus = TileTree.LoadStatus.Loaded;
                if (undefined !== props) {
                    // If this tile is undisplayable, update its content range based on children's content ranges.
                    const parentRange = this.hasContentRange ? undefined : new geometry_core_1.Range3d();
                    for (const prop of props) {
                        const child = new Tile(Tile.paramsFromJSON(prop, this.root, this));
                        // stick the corners on the Tile (used only by WebMercator Tiles)
                        if (prop.corners)
                            child.corners = prop.corners;
                        this._children.push(child);
                        if (undefined !== parentRange && !child.isEmpty)
                            parentRange.extendRange(child.contentRange);
                    }
                    if (undefined !== parentRange)
                        this._contentRange = parentRange;
                }
                if (0 === this._children.length) {
                    this._children = undefined;
                    this._isLeaf = true;
                }
                else {
                    IModelApp_1.IModelApp.viewManager.onNewTilesReady();
                }
            }).catch((_err) => {
                this._childrenLoadStatus = TileTree.LoadStatus.NotFound;
                this._children = undefined;
                this._isLeaf = true;
            });
        }
        return this._childrenLoadStatus;
    }
    debugDump() {
        let str = "  ".repeat(this.depth);
        str += this.contentId;
        if (undefined !== this._children) {
            str += " " + this._children.length + "\n";
            for (const child of this._children)
                str += child.debugDump();
        }
        else {
            str += "\n";
        }
        return str;
    }
    get request() { return this._request; }
    set request(request) {
        bentleyjs_core_1.assert(undefined === request || undefined === this.request);
        this._request = request;
    }
}
Tile._scratchWorldFrustum = new imodeljs_common_1.Frustum();
Tile._scratchRootFrustum = new imodeljs_common_1.Frustum();
Tile._scratchWorldSphere = new imodeljs_common_1.BoundingSphere();
Tile._scratchRootSphere = new imodeljs_common_1.BoundingSphere();
exports.Tile = Tile;
// tslint:disable:no-const-enum
/** @internal */
(function (Tile) {
    /**
     * Arguments used when selecting and drawing tiles
     * @internal
     */
    class DrawArgs {
        constructor(context, location, root, now, purgeOlderThan, clip) {
            this.graphics = new System_1.GraphicBranch();
            this.location = location;
            this.root = root;
            this.clipVolume = clip;
            this.context = context;
            this.now = now;
            this.purgeOlderThan = purgeOlderThan;
            this.graphics.setViewFlagOverrides(root.viewFlagOverrides);
            this.viewFrustum = context.viewFrustum;
            if (this.viewFrustum !== undefined)
                this._frustumPlanes = new imodeljs_common_1.FrustumPlanes(this.viewFrustum.getFrustum());
            this.planarClassifier = context.getPlanarClassifierForModel(root.modelId);
            // NB: Culling is currently feature-gated - ignore view clip if feature not enabled.
            if (IModelApp_1.IModelApp.renderSystem.options.cullAgainstActiveVolume && context.viewFlags.clipVolume && false !== root.viewFlagOverrides.clipVolumeOverride)
                this.viewClip = context.viewport.view.getViewClip();
        }
        getPixelSizeAtPoint(inPoint) {
            return this.viewFrustum !== undefined ? this.viewFrustum.getPixelSizeAtPoint(inPoint) : this.context.getPixelSizeAtPoint();
        }
        get frustumPlanes() {
            return this._frustumPlanes !== undefined ? this._frustumPlanes : this.context.frustumPlanes;
        }
        get tileSizeModifier() { return 1.0; } // ###TODO? may adjust for performance, or device pixel density, etc
        getTileCenter(tile) { return this.location.multiplyPoint3d(tile.center); }
        getTileRadius(tile) {
            let range = tile.range.clone(DrawArgs._scratchRange);
            range = this.location.multiplyRange(range, range);
            return 0.5 * (tile.root.is3d ? range.low.distance(range.high) : range.low.distanceXY(range.high));
        }
        get clip() { return undefined !== this.clipVolume ? this.clipVolume.clipVector : undefined; }
        drawGraphics() {
            if (this.graphics.isEmpty)
                return;
            const branch = this.context.createGraphicBranch(this.graphics, this.location, this.clipVolume, this.planarClassifier);
            this.context.outputGraphic(branch);
        }
        insertMissing(tile) {
            this.context.insertMissingTile(tile);
        }
        markChildrenLoading() { this.context.hasMissingTiles = true; }
    }
    DrawArgs._scratchRange = new geometry_core_1.Range3d();
    Tile.DrawArgs = DrawArgs;
    /** @internal */
    function paramsFromJSON(props, root, parent) {
        const contentRange = undefined !== props.contentRange ? geometry_core_1.Range3d.fromJSON(props.contentRange) : undefined;
        const transformToRoot = undefined !== props.transformToRoot ? geometry_core_1.Transform.fromJSON(props.transformToRoot) : undefined;
        return {
            root,
            contentId: props.contentId,
            range: geometry_core_1.Range3d.fromJSON(props.range),
            maximumSize: props.maximumSize,
            isLeaf: props.isLeaf,
            parent,
            contentRange,
            transformToRoot,
            sizeMultiplier: props.sizeMultiplier,
        };
    }
    Tile.paramsFromJSON = paramsFromJSON;
})(Tile = exports.Tile || (exports.Tile = {}));
/** A hierarchical level-of-detail tree of 3d [[Tile]]s to be rendered in a [[Viewport]].
 * @internal
 */
class TileTree {
    constructor(props) {
        this.iModel = props.iModel;
        this.is3d = props.is3d;
        this.id = props.id;
        this.modelId = bentleyjs_core_1.Id64.fromJSON(props.modelId);
        this.location = props.location;
        this.expirationTime = IModelApp_1.IModelApp.tileAdmin.tileExpirationTime;
        if (undefined !== props.clipVector)
            this.clipVolume = IModelApp_1.IModelApp.renderSystem.createClipVolume(props.clipVector);
        this.maxTilesToSkip = bentleyjs_core_1.JsonUtils.asInt(props.maxTilesToSkip, 100);
        this.loader = props.loader;
        this._rootTile = new Tile(Tile.paramsFromJSON(props.rootTile, this)); // causes TileTree to no longer be disposed (assuming the Tile loaded a graphic and/or its children)
        this.viewFlagOverrides = this.loader.viewFlagOverrides;
        this.yAxisUp = props.yAxisUp ? props.yAxisUp : false;
        this.contentRange = props.contentRange;
    }
    get rootTile() { return this._rootTile; }
    get clipVector() { return undefined !== this.clipVolume ? this.clipVolume.clipVector : undefined; }
    dispose() {
        bentleyjs_core_1.dispose(this._rootTile);
        this.clipVolume = bentleyjs_core_1.dispose(this.clipVolume);
    }
    collectStatistics(stats) {
        this._rootTile.collectStatistics(stats);
        if (undefined !== this.clipVolume)
            this.clipVolume.collectStatistics(stats);
    }
    get is2d() { return !this.is3d; }
    get range() { return this._rootTile !== undefined ? this._rootTile.range : new geometry_core_1.Range3d(); }
    selectTilesForScene(context) { return this.selectTiles(this.createDrawArgs(context)); }
    selectTiles(args) {
        const selected = [];
        if (undefined !== this._rootTile)
            this._rootTile.selectTiles(selected, args);
        return this.loader.processSelectedTiles(selected, args);
    }
    drawScene(context) { this.draw(this.createDrawArgs(context)); }
    draw(args) {
        const selectedTiles = this.selectTiles(args);
        for (const selectedTile of selectedTiles)
            selectedTile.drawGraphics(args);
        args.drawGraphics();
        args.context.viewport.numSelectedTiles += selectedTiles.length;
    }
    createDrawArgs(context) {
        const now = bentleyjs_core_1.BeTimePoint.now();
        const purgeOlderThan = now.minus(this.expirationTime);
        return new Tile.DrawArgs(context, this.location.clone(), this, now, purgeOlderThan, this.clipVolume);
    }
    extendRangeForTile(range, tile, matrix, treeTransform, frustumPlanes) {
        const box = imodeljs_common_1.Frustum.fromRange(tile.range, TileTree._scratchFrustum);
        box.transformBy(treeTransform, box);
        if (frustumPlanes !== undefined && 0 /* Outside */ === frustumPlanes.computeFrustumContainment(box))
            return;
        if (tile.children === undefined) {
            for (const boxPoint of box.points) {
                matrix.multiplyPoint3d(boxPoint, 1, TileTree._scratchPoint4d);
                if (TileTree._scratchPoint4d.w > .0001)
                    range.extendXYZW(TileTree._scratchPoint4d.x, TileTree._scratchPoint4d.y, TileTree._scratchPoint4d.z, TileTree._scratchPoint4d.w);
            }
        }
        else {
            for (const child of tile.children)
                this.extendRangeForTile(range, child, matrix, treeTransform, frustumPlanes);
        }
    }
    /* extend range to include transformed range of this tile tree */
    accumlateTransformedRange(range, matrix, frustumPlanes) {
        this.extendRangeForTile(range, this.rootTile, matrix, this.location, frustumPlanes);
    }
}
TileTree._scratchFrustum = new imodeljs_common_1.Frustum();
TileTree._scratchPoint4d = geometry_core_1.Point4d.createZero();
exports.TileTree = TileTree;
const defaultViewFlagOverrides = new imodeljs_common_1.ViewFlag.Overrides(imodeljs_common_1.ViewFlags.fromJSON({
    renderMode: imodeljs_common_1.RenderMode.SmoothShade,
    noCameraLights: true,
    noSourceLights: true,
    noSolarLight: true,
}));
/** Serves as a "handler" for a specific type of [[TileTree]]. Its primary responsibilities involve loading tile content.
 * @internal
 */
class TileLoader {
    get _batchType() { return imodeljs_common_1.BatchType.Primary; }
    get _loadEdges() { return true; }
    /** Given two tiles of the same [[Tile.LoadPriority]], determine which should be prioritized.
     * A negative value indicates lhs should load first, positive indicates rhs should load first, and zero indicates no distinction in priority.
     */
    compareTilePriorities(lhs, rhs) { return lhs.depth - rhs.depth; }
    get parentsAndChildrenExclusive() { return true; }
    processSelectedTiles(selected, _args) { return selected; }
    // NB: The isCanceled arg is chiefly for tests...in usual case it just returns false if the tile is no longer in 'loading' state.
    async loadTileContent(tile, data, isCanceled) {
        bentleyjs_core_1.assert(data instanceof Uint8Array);
        const blob = data;
        const streamBuffer = new TileIO_1.TileIO.StreamBuffer(blob.buffer);
        return this.loadTileContentFromStream(tile, streamBuffer, isCanceled);
    }
    async loadTileContentFromStream(tile, streamBuffer, isCanceled) {
        const position = streamBuffer.curPos;
        const format = streamBuffer.nextUint32;
        streamBuffer.curPos = position;
        if (undefined === isCanceled)
            isCanceled = () => !tile.isLoading;
        let reader;
        switch (format) {
            case 1937010288 /* Pnts */:
                return { graphic: PntsTileIO_1.PntsTileIO.readPointCloud(streamBuffer, tile.root.iModel, tile.root.modelId, tile.root.is3d, tile.range, IModelApp_1.IModelApp.renderSystem, tile.yAxisUp) };
            case 1835283298 /* B3dm */:
                reader = B3dmTileIO_1.B3dmTileIO.Reader.create(streamBuffer, tile.root.iModel, tile.root.modelId, tile.root.is3d, tile.range, IModelApp_1.IModelApp.renderSystem, tile.yAxisUp, tile.isLeaf, tile.transformToRoot, isCanceled);
                break;
            case 1818512745 /* IModel */:
                reader = IModelTileIO_1.IModelTileIO.Reader.create(streamBuffer, tile.root.iModel, tile.root.modelId, tile.root.is3d, IModelApp_1.IModelApp.renderSystem, this._batchType, this._loadEdges, isCanceled, tile.hasSizeMultiplier ? tile.sizeMultiplier : undefined);
                break;
            case 1835283305 /* I3dm */:
                reader = I3dmTileIO_1.I3dmTileIO.Reader.create(streamBuffer, tile.root.iModel, tile.root.modelId, tile.root.is3d, tile.range, IModelApp_1.IModelApp.renderSystem, tile.yAxisUp, tile.isLeaf, isCanceled);
                break;
            case 1953525091 /* Cmpt */:
                const header = new CompositeTileIO_1.CompositeTileIO.Header(streamBuffer);
                if (!header.isValid)
                    return {};
                const branch = new System_1.GraphicBranch();
                for (let i = 0; i < header.tileCount; i++) {
                    const tilePosition = streamBuffer.curPos;
                    streamBuffer.advance(8); // Skip magic and version.
                    const tileBytes = streamBuffer.nextUint32;
                    streamBuffer.curPos = tilePosition;
                    const result = await this.loadTileContentFromStream(tile, streamBuffer, isCanceled);
                    if (result.graphic)
                        branch.add(result.graphic);
                    streamBuffer.curPos = tilePosition + tileBytes;
                }
                return { graphic: branch.isEmpty ? undefined : IModelApp_1.IModelApp.renderSystem.createBranch(branch, geometry_core_1.Transform.createIdentity()), isLeaf: tile.isLeaf, sizeMultiplier: tile.sizeMultiplier };
            default:
                bentleyjs_core_1.assert(false, "unknown tile format " + format);
                break;
        }
        let content = {};
        if (undefined !== reader) {
            try {
                content = await reader.read();
            }
            catch (_err) {
                // Failure to load should prevent us from trying to load children
                content.isLeaf = true;
            }
        }
        return content;
    }
    get viewFlagOverrides() { return defaultViewFlagOverrides; }
    adjustContentIdSizeMultiplier(contentId, _sizeMultiplier) { return contentId; }
}
exports.TileLoader = TileLoader;
/** A hierarchical level-of-detail tree of 3d [[Tile]]s to be rendered in a [[Viewport]].
 * @internal
 */
(function (TileTree) {
    /** Create TileTree.Params from JSON and context.
     * @internal
     */
    function paramsFromJSON(props, iModel, is3d, loader, modelId) {
        const contentRange = undefined !== props.contentRange ? geometry_core_1.Range3d.fromJSON(props.contentRange) : undefined;
        return {
            id: props.id,
            rootTile: props.rootTile,
            iModel,
            is3d,
            loader,
            location: geometry_core_1.Transform.fromJSON(props.location),
            modelId,
            maxTilesToSkip: props.maxTilesToSkip,
            yAxisUp: props.yAxisUp,
            isBackgroundMap: props.isBackgroundMap,
            contentRange,
        };
    }
    TileTree.paramsFromJSON = paramsFromJSON;
    /** @internal */
    let LoadStatus;
    (function (LoadStatus) {
        LoadStatus[LoadStatus["NotLoaded"] = 0] = "NotLoaded";
        LoadStatus[LoadStatus["Loading"] = 1] = "Loading";
        LoadStatus[LoadStatus["Loaded"] = 2] = "Loaded";
        LoadStatus[LoadStatus["NotFound"] = 3] = "NotFound";
    })(LoadStatus = TileTree.LoadStatus || (TileTree.LoadStatus = {}));
})(TileTree = exports.TileTree || (exports.TileTree = {}));
/** @internal */
class TileTreeState {
    constructor(_iModel, _is3d, _modelId) {
        this._iModel = _iModel;
        this._is3d = _is3d;
        this._modelId = _modelId;
        this.loadStatus = TileTree.LoadStatus.NotLoaded;
        this.edgesOmitted = false;
        this.classifierExpansion = 0;
    }
    get iModel() { return this._iModel; }
    get modelId() { return this._modelId; }
    setTileTree(props, loader) {
        const tileTree = new TileTree(TileTree.paramsFromJSON(props, this._iModel, this._is3d, loader, this._modelId));
        if (tileTree.rootTile.contentRange.isNull) {
            // No elements within model's range - don't create a TileTree for this model.
            bentleyjs_core_1.assert(tileTree.rootTile.isLeaf);
            this.loadStatus = TileTree.LoadStatus.NotFound;
        }
        else {
            this.tileTree = tileTree;
            this.loadStatus = TileTree.LoadStatus.Loaded;
        }
    }
    clearTileTree() {
        this.tileTree = bentleyjs_core_1.dispose(this.tileTree);
        this.loadStatus = TileTree.LoadStatus.NotLoaded;
    }
}
exports.TileTreeState = TileTreeState;
/** @internal */
function bisectRange3d(range, takeUpper) {
    const diag = range.diagonal();
    const pt = takeUpper ? range.high : range.low;
    if (diag.x > diag.y && diag.x > diag.z)
        pt.x = (range.low.x + range.high.x) / 2.0;
    else if (diag.y > diag.z)
        pt.y = (range.low.y + range.high.y) / 2.0;
    else
        pt.z = (range.low.z + range.high.z) / 2.0;
}
exports.bisectRange3d = bisectRange3d;
/** @internal */
function bisectRange2d(range, takeUpper) {
    const diag = range.diagonal();
    const pt = takeUpper ? range.high : range.low;
    if (diag.x > diag.y)
        pt.x = (range.low.x + range.high.x) / 2.0;
    else
        pt.y = (range.low.y + range.high.y) / 2.0;
}
exports.bisectRange2d = bisectRange2d;
/**
 * Given a Tile, compute the ranges which would result from sub-dividing its range a la IModelTile.getChildrenProps().
 * This function exists strictly for debugging purposes.
 */
function computeChildRanges(tile) {
    const emptyMask = tile.emptySubRangeMask;
    const is2d = tile.root.is2d;
    const bisectRange = is2d ? bisectRange2d : bisectRange3d;
    const ranges = [];
    for (let i = 0; i < 2; i++) {
        for (let j = 0; j < 2; j++) {
            for (let k = 0; k < (is2d ? 1 : 2); k++) {
                const emptyBit = 1 << (i + j * 2 + k * 4);
                const isEmpty = 0 !== (emptyMask & emptyBit);
                const range = tile.range.clone();
                bisectRange(range, 0 === i);
                bisectRange(range, 0 === j);
                if (!is2d)
                    bisectRange(range, 0 === k);
                ranges.push({ range, isEmpty });
            }
        }
    }
    return ranges;
}


/***/ }),

/***/ "./lib/tile/WebMapTileTree.js":
/*!************************************!*\
  !*** ./lib/tile/WebMapTileTree.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tile */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const TileTree_1 = __webpack_require__(/*! ./TileTree */ "./lib/tile/TileTree.js");
const imodeljs_clients_1 = __webpack_require__(/*! @bentley/imodeljs-clients */ "@bentley/imodeljs-clients");
const ImageUtil_1 = __webpack_require__(/*! ../ImageUtil */ "./lib/ImageUtil.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const NotificationManager_1 = __webpack_require__(/*! ../NotificationManager */ "./lib/NotificationManager.js");
// this is the simple version that is appropriate when the iModel covers a small area.
class LinearTransformChildCreator {
    constructor(_iModel, groundBias) {
        // calculate mercatorToDb.
        const ecefLocation = _iModel.ecefLocation;
        const dbToEcef = ecefLocation.getTransform();
        const projectCenter = geometry_core_1.Point3d.create(_iModel.projectExtents.center.x, _iModel.projectExtents.center.y, groundBias);
        const projectEast = geometry_core_1.Point3d.create(projectCenter.x + 1.0, projectCenter.y, groundBias);
        const projectNorth = geometry_core_1.Point3d.create(projectCenter.x, projectCenter.y + 1.0, groundBias);
        const mercatorOrigin = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectCenter));
        const mercatorX = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectEast));
        const mercatorY = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectNorth));
        const deltaX = geometry_core_1.Vector3d.createStartEnd(mercatorOrigin, mercatorX);
        const deltaY = geometry_core_1.Vector3d.createStartEnd(mercatorOrigin, mercatorY);
        const dbToMercator = geometry_core_1.Transform.createOriginAndMatrixColumns(mercatorOrigin, deltaX, deltaY, geometry_core_1.Vector3d.create(0.0, 0.0, 1.0)).multiplyTransformTransform(geometry_core_1.Transform.createTranslationXYZ(-projectCenter.x, -projectCenter.y, -groundBias));
        this.mercatorToDb = dbToMercator.inverse();
    }
    // gets longitude in a number between 0 and 1, corresponding to the coordinate system of the tiles.
    longitudeToPixelFraction(longitude) {
        return (longitude + geometry_core_1.Angle.piRadians) / geometry_core_1.Angle.pi2Radians;
    }
    // gets latitude in a number between 0 and 1, corresponding to the coordinate system of the tiles.
    latitudeToPixelFraction(latitude) {
        const sinLatitude = Math.sin(latitude);
        return (0.5 - Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude)) / (4.0 * geometry_core_1.Angle.piRadians)); // https://msdn.microsoft.com/en-us/library/bb259689.aspx
    }
    // gets the longitude and latitude into a point with coordinates between 0 and 1
    ecefToPixelFraction(point) {
        const cartoGraphic = imodeljs_common_1.Cartographic.fromEcef(point);
        return geometry_core_1.Point3d.create(this.longitudeToPixelFraction(cartoGraphic.longitude), this.latitudeToPixelFraction(cartoGraphic.latitude), 0.0);
    }
    // gets the corners of the tile in a number between 0 and 1.
    getTileCorners(level, column, row) {
        const nTiles = (1 << level);
        const scale = 1.0 / nTiles;
        const corners = []; //    ----x----->
        corners.push(geometry_core_1.Point3d.create(scale * column, scale * row, 0.0)); //  | [0]     [1]
        corners.push(geometry_core_1.Point3d.create(scale * (column + 1), scale * row, 0.0)); //  y
        corners.push(geometry_core_1.Point3d.create(scale * column, scale * (row + 1), 0.0)); //  | [2]     [3]
        corners.push(geometry_core_1.Point3d.create(scale * (column + 1), scale * (row + 1), 0.0)); //  v
        return corners;
    }
    // Note: although there are only nine unique points, we don't bother with the optimization used in the
    // GeoTransformChildCreator because the calculation for each point is fast.
    async getChildren(quadId) {
        const level = quadId.level + 1;
        const column = quadId.column * 2;
        const row = quadId.row * 2;
        const tileProps = [];
        for (let i = 0; i < 2; i++) {
            for (let j = 0; j < 2; j++) {
                // get them as LatLong
                const corners = this.getTileCorners(level, column + i, row + j);
                // use the linear transform to get them into iModel Coordinates.
                this.mercatorToDb.multiplyPoint3dArrayInPlace(corners);
                const childId = level + "_" + (column + i) + "_" + (row + j);
                tileProps.push(new WebMapTileProps(childId, level, corners));
            }
        }
        return Promise.resolve(tileProps);
    }
    onTilesSelected() { }
}
function compareXYZ(lhs, rhs) {
    let cmp = bentleyjs_core_1.compareNumbers(lhs.x, rhs.x);
    if (0 === cmp) {
        cmp = bentleyjs_core_1.compareNumbers(lhs.y, rhs.y);
        if (0 === cmp)
            cmp = bentleyjs_core_1.compareNumbers(lhs.z, rhs.z);
    }
    return cmp;
}
// this is the simple version that is appropriate when the iModel covers a small area.
class GeoTransformChildCreator {
    constructor(_iModel, groundBias) {
        this._converter = _iModel.geoServices.getConverter("WGS84");
        this._groundBias = groundBias;
        // a geographic transform doesn't work well outside a reasonable range, so use the linearChildCreator for the large-range tiles.
        this._linearChildCreator = new LinearTransformChildCreator(_iModel, groundBias);
    }
    async getChildren(parentQuad) {
        const parentLevel = parentQuad.level;
        const parentColumn = parentQuad.column;
        const parentRow = parentQuad.row;
        // calculate the lat/long of the nine unique points:
        if (parentLevel < 6)
            return this._linearChildCreator.getChildren(parentQuad);
        const requestProps = new Array(9);
        // we are passed the child level, and the top left corner column and row.
        const mapSize = 256 << parentLevel;
        const left = 256 * parentColumn;
        const top = 256 * parentRow;
        for (let iPoint = 0; iPoint < GeoTransformChildCreator._uniquePointPixels.length; ++iPoint) {
            const x = ((left + GeoTransformChildCreator._uniquePointPixels[iPoint][0]) / mapSize) - .5;
            const y = 0.5 - ((top + GeoTransformChildCreator._uniquePointPixels[iPoint][1]) / mapSize);
            requestProps[iPoint] = [
                360.0 * x,
                90.0 - 360.0 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI,
                this._groundBias,
            ];
        }
        let cached = this._converter.getCachedIModelCoordinatesFromGeoCoordinates(requestProps);
        if (undefined !== cached.missing) {
            // Batch our missing points in with any others which may be needed during tile selection.
            // This promise will request the points needed by all tiles simultaneously and resolve when they are all available in the cache.
            await this.getPromise(cached.missing);
            // The points we need should all now be available in the cache.
            // ###TODO this is lazy - use the cached results from above; only query the converter for missing points
            cached = this._converter.getCachedIModelCoordinatesFromGeoCoordinates(requestProps);
            bentleyjs_core_1.assert(undefined === cached.missing);
        }
        const iModelCoords = cached.result;
        // get the tileProps now that we have their geoCoords.
        const tileProps = [];
        const level = parentLevel + 1;
        const column = parentColumn * 2;
        const row = parentRow * 2;
        for (let iCol = 0; iCol < 2; ++iCol) {
            for (let iRow = 0; iRow < 2; ++iRow) {
                const corners = new Array(4);
                for (let iPoint = 0; iPoint < 4; ++iPoint) {
                    const pointNum = GeoTransformChildCreator._cornerList[iCol][iRow][iPoint];
                    const iModelCoord = iModelCoords[pointNum];
                    bentleyjs_core_1.assert(undefined !== iModelCoord);
                    corners[iPoint] = geometry_core_1.Point3d.fromJSON(iModelCoord.p);
                }
                const childId = level + "_" + (column + iCol) + "_" + (row + iRow);
                tileProps.push(new WebMapTileProps(childId, level, corners));
            }
        }
        return tileProps;
    }
    async getPromise(geoPoints) {
        if (undefined === this._promise) {
            bentleyjs_core_1.assert(undefined === this._request);
            const req = new bentleyjs_core_1.SortedArray(compareXYZ);
            this._request = req;
            this._promise = Promise.resolve().then(async () => {
                // NB: At this point this._request and this._promise are undefined, or possibly pointing to different objects.
                await this._converter.getIModelCoordinatesFromGeoCoordinates(req.extractArray());
            });
        }
        bentleyjs_core_1.assert(undefined !== this._request);
        for (const point of geoPoints)
            this._request.insert(geometry_core_1.Point3d.fromJSON(point));
        return this._promise;
    }
    onTilesSelected() {
        if (undefined === this._promise)
            return;
        bentleyjs_core_1.assert(undefined !== this._request);
        this._promise = undefined;
        this._request = undefined;
    }
}
// we are creating four children, so 16 corners, but only nine are unique:
//   0       1       2
//   +-------+-------+
//   |      4|       |
//  3+-------+-------+5
//   |       |       |
//   +-------+-------+
//   6       7       8
// (Also, we probably already have 0,2,6, and 8 in the cache.)
GeoTransformChildCreator._cornerList = [[[0, 1, 3, 4], [3, 4, 6, 7]], [[1, 2, 4, 5], [4, 5, 7, 8]]];
GeoTransformChildCreator._uniquePointPixels = [[0, 0], [128, 0], [256, 0], [0, 128], [128, 128], [256, 128], [0, 256], [128, 256], [256, 256]];
class QuadId {
    get isValid() { return this.level >= 0; }
    constructor(stringId) {
        const idParts = stringId.split("_");
        if (3 !== idParts.length) {
            bentleyjs_core_1.assert(false, "Invalid quadtree ID");
            this.level = this.row = this.column = -1;
            return;
        }
        this.level = parseInt(idParts[0], 10);
        this.column = parseInt(idParts[1], 10);
        this.row = parseInt(idParts[2], 10);
    }
    // get the lat long for pixels within this quadId.
    pixelXYToLatLong(pixelX, pixelY) {
        const mapSize = 256 << this.level;
        const left = 256 * this.column;
        const top = 256 * this.row;
        const x = ((left + pixelX) / mapSize) - .5;
        const y = 0.5 - ((top + pixelY) / mapSize);
        const outPoint = new geometry_core_1.Point2d(360.0 * x, 90.0 - 360.0 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI);
        return outPoint;
    }
    // Not used in display - used only to tell whether this tile overlaps the range provided by a tile provider for attribution.
    getLatLongRange() {
        const lowerLeft = this.pixelXYToLatLong(0, 256);
        const upperRight = this.pixelXYToLatLong(256, 0);
        const range = new geometry_core_1.Range2d();
        range.low = lowerLeft;
        range.high = upperRight;
        return range;
    }
}
class WebMapTileTreeProps {
    constructor(groundBias) {
        /** The unique identifier of this TileTree within the iModel */
        this.id = "";
        this.yAxisUp = true;
        this.isBackgroundMap = true;
        this.maxTilesToSkip = 4;
        const corners = [];
        corners[0] = new geometry_core_1.Point3d(-10000000, -10000000, groundBias);
        corners[1] = new geometry_core_1.Point3d(-10000000, 10000000, groundBias);
        corners[2] = new geometry_core_1.Point3d(10000000, -10000000, groundBias);
        corners[3] = new geometry_core_1.Point3d(10000000, 10000000, groundBias);
        this.rootTile = new WebMapTileProps("0_0_0", 0, corners);
        this.location = geometry_core_1.Transform.createIdentity();
    }
}
class WebMapTileProps {
    constructor(thisId, level, corners) {
        this.sizeMultiplier = 1.0;
        this.isLeaf = false;
        this.corners = corners;
        this.range = geometry_core_1.Range3d.createArray(corners);
        this.contentId = thisId;
        this.maximumSize = (0 === level) ? 0.0 : 256;
    }
}
class WebMapTileLoader extends TileTree_1.TileLoader {
    constructor(_imageryProvider, _iModel, groundBias, gcsConverterAvailable) {
        super();
        this._imageryProvider = _imageryProvider;
        this._iModel = _iModel;
        this._providerInitialized = false;
        const useLinearTransform = !gcsConverterAvailable || WebMapTileLoader.selectLinearChildCreator(_iModel);
        if (useLinearTransform) {
            this._childTileCreator = new LinearTransformChildCreator(_iModel, groundBias);
        }
        else {
            this._childTileCreator = new GeoTransformChildCreator(_iModel, groundBias);
        }
    }
    static selectLinearChildCreator(_iModel) {
        const linearRangeSquared = _iModel.projectExtents.diagonal().magnitudeSquared();
        return linearRangeSquared < 1000.0 * 1000.00; // if the range is greater than a kilometer, use the more exact but slower GCS method of generating the WebMap tile corners.
    }
    tileRequiresLoading(params) {
        return 0.0 !== params.maximumSize;
    }
    async getChildrenProps(parent) {
        const quadId = new QuadId(parent.contentId);
        return this._childTileCreator.getChildren(quadId);
    }
    async requestTileContent(tile) {
        if (!this._providerInitialized) {
            if (undefined === this._providerInitializing)
                this._providerInitializing = this._imageryProvider.initialize();
            await this._providerInitializing;
            this._providerInitialized = true;
            this._providerInitializing = undefined;
        }
        const quadId = new QuadId(tile.contentId);
        return this._imageryProvider.loadTile(quadId.row, quadId.column, quadId.level);
    }
    async loadTileContent(tile, data, isCanceled) {
        if (undefined === isCanceled)
            isCanceled = () => !tile.isLoading;
        bentleyjs_core_1.assert(data instanceof imodeljs_common_1.ImageSource);
        const content = {};
        const system = IModelApp_1.IModelApp.renderSystem;
        const texture = await this.loadTextureImage(data, this._iModel, system, isCanceled);
        if (undefined !== texture) {
            // we put the corners property on WebMapTiles
            const corners = tile.corners;
            content.graphic = system.createTile(texture, corners);
        }
        return content;
    }
    async loadTextureImage(imageSource, iModel, system, isCanceled) {
        try {
            const textureParams = new imodeljs_common_1.RenderTexture.Params(undefined, 2 /* TileSection */);
            return ImageUtil_1.imageElementFromImageSource(imageSource)
                .then((image) => isCanceled() ? undefined : system.createTextureFromImage(image, imodeljs_common_1.ImageSourceFormat.Png === imageSource.format, iModel, textureParams))
                .catch((_) => undefined);
        }
        catch (e) {
            return undefined;
        }
    }
    get maxDepth() { return this._providerInitialized ? this._imageryProvider.maximumZoomLevel : 32; }
    get parentsAndChildrenExclusive() { return false; }
    get priority() { return 3 /* Background */; }
    processSelectedTiles(selected, _args) {
        // Dispatch any requests for child tiles props (geo-coordination)
        this._childTileCreator.onTilesSelected();
        // Ensure lo-res tiles drawn before (therefore behind) hi-res tiles.
        // NB: Array.sort() sorts in-place and returns the input array - we're not making a copy.
        return selected.sort((lhs, rhs) => lhs.depth - rhs.depth);
    }
    compareTilePriorities(lhs, rhs) {
        // The default implementation prioritizes lower-resolution tiles. For maps, we want tiles closest to the camera to load first.
        // When the camera is ON, those will be the higher-resolution tiles - so invert the default behavior.
        // ###TODO: Compute actual distance from camera when camera is OFF.
        // NB: We never load higher-res children until the first displayable lowest-res tile is available - so we always have *something* to draw while awaiting hi-res tiles.
        return rhs.depth - lhs.depth;
    }
}
/** @internal */
// Represents the service that is providing map tiles for Web Mercator models (background maps).
class ImageryProvider {
    constructor(mapType) {
        this._requestContext = new bentleyjs_core_1.ClientRequestContext("");
        this.mapType = mapType;
    }
    // returns true if the tile data matches the tile data of a "missing tile". See BingImageryProvider.initialize.
    matchesMissingTile(_tileData) {
        return false;
    }
    // returns a Uint8Array with the contents of the tile.
    async loadTile(row, column, zoomLevel) {
        let tileUrl = this.constructUrl(row, column, zoomLevel);
        if (!tileUrl.includes("https"))
            tileUrl = tileUrl.replace("http", "https");
        const tileRequestOptions = { method: "GET", responseType: "arraybuffer" };
        try {
            const tileResponse = await imodeljs_clients_1.request(this._requestContext, tileUrl, tileRequestOptions);
            const byteArray = new Uint8Array(tileResponse.body);
            if (!byteArray || (byteArray.length === 0))
                return undefined;
            if (this.matchesMissingTile(byteArray))
                return undefined;
            let imageFormat;
            switch (tileResponse.header["content-type"]) {
                case "image/jpeg":
                    imageFormat = imodeljs_common_1.ImageSourceFormat.Jpeg;
                    break;
                case "image/png":
                    imageFormat = imodeljs_common_1.ImageSourceFormat.Png;
                    break;
                default:
                    bentleyjs_core_1.assert(false, "Unknown image type");
                    return undefined;
            }
            return new imodeljs_common_1.ImageSource(byteArray, imageFormat);
        }
        catch (error) {
            return undefined;
        }
    }
}
exports.ImageryProvider = ImageryProvider;
/** @internal */
// this class provides a method for converting the tile row, column, and zoom level to the EPSG3857 cartesian coordinates that some
// tile servers require. The getEPSG3857Extent method is usually used in the constructUrl method.
class ImageryProviderEPSG3857 extends ImageryProvider {
    // calculates the projected x cartesian coordinate in EPSG:3857from the longitude in EPSG:4326 (WGS84)
    getEPSG3857X(longitude) {
        return longitude * 20037508.34 / 180.0;
    }
    // calculates the projected y cartesian coordinate in EPSG:3857from the latitude in EPSG:4326 (WGS84)
    getEPSG3857Y(latitude) {
        const y = Math.log(Math.tan((90.0 + latitude) * Math.PI / 360.0)) / (Math.PI / 180.0);
        return y * 20037508.34 / 180.0;
    }
    // Map tile providers like Bing and Mapbox allow the URL to be constructed directory from the zoomlevel and tile coordinates.
    // However, WMS-based servers take a bounding box instead. This method can help get that bounding box from a tile.
    getEPSG3857Extent(row, column, zoomLevel) {
        const mapSize = 256 << zoomLevel;
        const leftGrid = 256 * column;
        const topGrid = 256 * row;
        const longitudeLeft = 360 * ((leftGrid / mapSize) - 0.5);
        const y0 = 0.5 - ((topGrid + 256) / mapSize);
        const latitudeBottom = 90.0 - 360.0 * Math.atan(Math.exp(-y0 * 2 * Math.PI)) / Math.PI;
        const longitudeRight = 360 * (((leftGrid + 256) / mapSize) - 0.5);
        const y1 = 0.5 - (topGrid / mapSize);
        const latitudeTop = 90.0 - 360.0 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI;
        const left = this.getEPSG3857X(longitudeLeft);
        const right = this.getEPSG3857X(longitudeRight);
        const bottom = this.getEPSG3857Y(latitudeBottom);
        const top = this.getEPSG3857Y(latitudeTop);
        return { left, right, bottom, top };
    }
}
exports.ImageryProviderEPSG3857 = ImageryProviderEPSG3857;
// ------------------------------------------------------------------------------
// Classes for the Bing Imagery Provider
// ------------------------------------------------------------------------------
// Represents one range of geography and tile zoom levels for a bing data provider
class Coverage {
    constructor(_lowerLeftLongitude, _lowerLeftLatitude, _upperRightLongitude, _upperRightLatitude, _minimumZoomLevel, _maximumZoomLevel) {
        this._lowerLeftLongitude = _lowerLeftLongitude;
        this._lowerLeftLatitude = _lowerLeftLatitude;
        this._upperRightLongitude = _upperRightLongitude;
        this._upperRightLatitude = _upperRightLatitude;
        this._minimumZoomLevel = _minimumZoomLevel;
        this._maximumZoomLevel = _maximumZoomLevel;
    }
    overlaps(quadId) {
        const range = quadId.getLatLongRange();
        if (quadId.level < this._minimumZoomLevel)
            return false;
        if (quadId.level > this._maximumZoomLevel)
            return false;
        if (range.low.x > this._upperRightLongitude)
            return false;
        if (range.low.y > this._upperRightLatitude)
            return false;
        if (range.high.x < this._lowerLeftLongitude)
            return false;
        if (range.high.y < this._lowerLeftLatitude)
            return false;
        return true;
    }
}
// Represents the copyright message and an array of coverage data for one of bing's data providers (HERE for example).
class BingAttribution {
    constructor(copyrightMessage, _coverages) {
        this.copyrightMessage = copyrightMessage;
        this._coverages = _coverages;
    }
    matchesTile(tile) {
        const quadId = new QuadId(tile.contentId);
        for (const coverage of this._coverages) {
            if (coverage.overlaps(quadId))
                return true;
        }
        return false;
    }
}
// Our ImageryProvider for Bing Maps.
class BingImageryProvider extends ImageryProvider {
    constructor(mapType) {
        super(mapType);
        this._zoomMin = this._zoomMax = 0;
        this._tileHeight = this._tileWidth = 0;
    }
    get tileWidth() { return this._tileWidth; }
    get tileHeight() { return this._tileHeight; }
    get minimumZoomLevel() { return this._zoomMin; }
    get maximumZoomLevel() { return this._zoomMax; }
    tileXYToQuadKey(tileX, tileY, zoomLevel) {
        // from C# example in bing documentation https://msdn.microsoft.com/en-us/library/bb259689.aspx
        let quadKey = "";
        // Root tile is not displayable. Returns 0 for _GetMaximumSize(). Should not end up here.
        bentleyjs_core_1.assert(0 !== zoomLevel);
        for (let i = zoomLevel; i > 0; i--) {
            let digit = 0x30; // '0'
            const mask = 1 << (i - 1);
            if ((tileX & mask) !== 0) {
                digit++;
            }
            if ((tileY & mask) !== 0) {
                digit++;
                digit++;
            }
            quadKey = quadKey.concat(String.fromCharCode(digit));
        }
        return quadKey;
    }
    // construct the Url from the desired Tile
    constructUrl(row, column, zoomLevel) {
        // From the tile, get a "quadKey" the Microsoft way.
        const quadKey = this.tileXYToQuadKey(column, row, zoomLevel);
        const subdomain = this._urlSubdomains[(row + column) % this._urlSubdomains.length];
        // from the template url, construct the tile url.
        let url = this._urlTemplate.replace("{subdomain}", subdomain);
        url = url.replace("{quadkey}", quadKey);
        return url;
    }
    // gets the attributions that match the tile set.
    getMatchingAttributions(tiles) {
        const matchingAttributions = new Array();
        if (!this._attributions)
            return matchingAttributions;
        const unmatchedSet = this._attributions.slice();
        for (const tile of tiles) {
            // compare to the set of Bing attributions that we have not yet matched.
            for (let iAttr = 0; iAttr < unmatchedSet.length; iAttr++) {
                const attribution = unmatchedSet[iAttr];
                if (attribution && attribution.matchesTile(tile)) {
                    matchingAttributions.push(attribution);
                    delete unmatchedSet[iAttr];
                }
            }
        }
        return matchingAttributions;
    }
    showAttributions(tileProvider, viewport) {
        // our "this" is the BingImageryProvider for which we want to show the data provider attribution.
        // We need to get the tiles that are used in the view.
        const tiles = tileProvider.getTilesForView(viewport);
        const matchingAttributions = this.getMatchingAttributions(tiles);
        let dataString = IModelApp_1.IModelApp.i18n.translate("iModelJs:BackgroundMap.BingDataAttribution");
        for (const match of matchingAttributions) {
            dataString = dataString.concat("<li>", match.copyrightMessage, "</li>");
        }
        IModelApp_1.IModelApp.notifications.openMessageBox(NotificationManager_1.MessageBoxType.LargeOk, dataString, NotificationManager_1.MessageBoxIconType.Information); // tslint:disable-line:no-floating-promises
    }
    getCopyrightImage(_tileProvider) { return this._logoImage; }
    getCopyrightMessage(tileProvider, viewport) {
        const copyrightElement = document.createElement("span");
        copyrightElement.className = "bgmap-copyright";
        copyrightElement.onclick = this.showAttributions.bind(this, tileProvider, viewport);
        copyrightElement.innerText = IModelApp_1.IModelApp.i18n.translate("iModelJs:BackgroundMap.BingDataClickTarget");
        copyrightElement.style.textDecoration = "underline";
        copyrightElement.style.cursor = "pointer";
        return copyrightElement;
    }
    matchesMissingTile(tileData) {
        if (!this._missingTileData)
            return false;
        if (tileData.length !== this._missingTileData.length)
            return false;
        for (let i = 0; i < tileData.length; i += 10) {
            if (this._missingTileData[i] !== tileData[i]) {
                return false;
            }
        }
        return true;
    }
    // initializes the BingImageryProvider by reading the templateUrl, logo image, and attribution list.
    async initialize() {
        // get the template url
        // NEEDSWORK - should get bing key from server.
        const bingKey = "AtaeI3QDNG7Bpv1L53cSfDBgBKXIgLq3q-xmn_Y2UyzvF-68rdVxwAuje49syGZt";
        let imagerySet = "Road";
        if (imodeljs_common_1.BackgroundMapType.Aerial === this.mapType)
            imagerySet = "Aerial";
        else if (imodeljs_common_1.BackgroundMapType.Hybrid === this.mapType)
            imagerySet = "AerialWithLabels";
        let bingRequestUrl = "https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}?o=json&incl=ImageryProviders&key={bingKey}";
        bingRequestUrl = bingRequestUrl.replace("{imagerySet}", imagerySet);
        bingRequestUrl = bingRequestUrl.replace("{bingKey}", bingKey);
        const requestOptions = {
            method: "GET",
        };
        try {
            const response = await imodeljs_clients_1.request(this._requestContext, bingRequestUrl, requestOptions);
            const bingResponseProps = response.body;
            this._logoUrl = bingResponseProps.brandLogoUri;
            const thisResourceSetProps = bingResponseProps.resourceSets[0];
            const thisResourceProps = thisResourceSetProps.resources[0];
            this._zoomMin = thisResourceProps.zoomMin;
            this._zoomMax = thisResourceProps.zoomMax;
            this._tileHeight = thisResourceProps.imageHeight;
            this._tileWidth = thisResourceProps.imageWidth;
            this._urlTemplate = thisResourceProps.imageUrl.replace("{culture}", "en-US"); // NEEDSWORK - get locale from somewhere.
            this._urlSubdomains = thisResourceProps.imageUrlSubdomains;
            // read the list of Bing's data suppliers and the range of data they provide. Used in calculation of copyright message.
            this.readAttributions(thisResourceProps.imageryProviders);
            // read the Bing logo data, used in getCopyrightImage
            if (undefined !== this._logoUrl && 0 < this._logoUrl.length) {
                this._logoImage = new Image();
                if (!this._logoUrl.includes("https"))
                    this._logoUrl = this._logoUrl.replace("http", "https");
                this._logoImage.src = this._logoUrl;
            }
            // Bing sometimes provides tiles that have nothing but a stupid camera icon in the middle of them when you ask
            // for tiles at zoom levels where they don't have data. Their application stops you from zooming in when that's the
            // case, but we can't stop - the user might want to look at design data a closer zoom. So we intentionally load such
            // a tile, and then compare other tiles to it, rejecting them if they match.
            this.loadTile(0, 0, this._zoomMax - 1).then((tileData) => {
                if (tileData !== undefined)
                    this._missingTileData = tileData.data;
            });
        }
        catch (error) {
            throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.IModelStatus.BadModel, "Error in Bing Server communications");
        }
    }
    // reads the list of Bing data providers and the map range for which they each provide data.
    readAttributions(attributionProps) {
        for (const thisAttributionProps of attributionProps) {
            const copyrightMessage = thisAttributionProps.attribution;
            const coverages = new Array();
            for (const thisCoverageProps of thisAttributionProps.coverageAreas) {
                const thisCoverage = new Coverage(thisCoverageProps.bbox[0], thisCoverageProps.bbox[1], thisCoverageProps.bbox[2], thisCoverageProps.bbox[3], thisCoverageProps.zoomMin, thisCoverageProps.zoomMax);
                coverages.push(thisCoverage);
            }
            const thisAttribution = new BingAttribution(copyrightMessage, coverages);
            if (!this._attributions)
                this._attributions = new Array();
            this._attributions.push(thisAttribution);
        }
    }
}
// ------------------------------------------------------------------------------
// Classes for the Mapbox Imagery Provider
// ------------------------------------------------------------------------------
class MapBoxImageryProvider extends ImageryProvider {
    constructor(mapType) {
        super(mapType);
        this._zoomMin = 1;
        this._zoomMax = 20;
        switch (mapType) {
            case imodeljs_common_1.BackgroundMapType.Street:
                this._baseUrl = "https://api.mapbox.com/v4/mapbox.streets/";
                break;
            case imodeljs_common_1.BackgroundMapType.Aerial:
                this._baseUrl = "https://api.mapbox.com/v4/mapbox.satellite/";
                break;
            case imodeljs_common_1.BackgroundMapType.Hybrid:
                this._baseUrl = "https://api.mapbox.com/v4/mapbox.streets-satellite/";
                break;
            default:
                this._baseUrl = "";
                bentleyjs_core_1.assert(false);
        }
    }
    get tileWidth() { return 256; }
    get tileHeight() { return 256; }
    get minimumZoomLevel() { return this._zoomMin; }
    get maximumZoomLevel() { return this._zoomMax; }
    // construct the Url from the desired Tile
    constructUrl(row, column, zoomLevel) {
        // from the template url, construct the tile url.
        let url = this._baseUrl.concat(zoomLevel.toString());
        url = url.concat("/").concat(column.toString()).concat("/").concat(row.toString());
        url = url.concat(".jpg80?access_token=pk%2EeyJ1IjoibWFwYm94YmVudGxleSIsImEiOiJjaWZvN2xpcW00ZWN2czZrcXdreGg2eTJ0In0%2Ef7c9GAxz6j10kZvL%5F2DBHg");
        return url;
    }
    getCopyrightImage(_tileProvider) { return undefined; }
    getCopyrightMessage(_tileProvider, _viewport) {
        const copyrightElement = document.createElement("span");
        copyrightElement.innerText = IModelApp_1.IModelApp.i18n.translate("IModelJs:BackgroundMap.MapBoxCopyright");
        copyrightElement.className = "bgmap-copyright";
        return copyrightElement;
    }
    // no initialization needed for MapBoxImageryProvider.
    async initialize() { }
}
/** Methods and properties common to both BackgroundMapProviders and OverlayMapProviders
 * @internal
 */
class BaseTiledMapProvider {
    constructor(iModel, groundBias) {
        this._loadStatus = TileTree_1.TileTree.LoadStatus.NotLoaded;
        this._gcsConverterStatus = 0 /* Uninitialized */;
        this._groundBias = groundBias;
        this._iModel = iModel;
    }
    setTileTree(props, loader) {
        this._tileTree = new TileTree_1.TileTree(TileTree_1.TileTree.paramsFromJSON(props, this._iModel, true, loader, ""));
        this._loadStatus = TileTree_1.TileTree.LoadStatus.Loaded;
    }
    getPlane() {
        return geometry_core_1.Plane3dByOriginAndUnitNormal.createXYPlane(new geometry_core_1.Point3d(0.0, 0.0, this._groundBias)); // TBD.... use this.groundBias when clone problem is sorted for Point3d
    }
    getTilesForView(viewport) {
        let displayTiles = [];
        if (this._tileTree) {
            const sceneContext = viewport.createSceneContext();
            sceneContext.extendedFrustumPlane = this.getPlane();
            displayTiles = this._tileTree.selectTilesForScene(sceneContext);
        }
        return displayTiles;
    }
    testGcsConverter() {
        this._gcsConverterStatus = 1 /* Pending */;
        const converter = this._iModel.geoServices.getConverter("WGS84");
        const requestProps = new Array(1);
        requestProps[0] = { x: 0, y: 0, z: 0 };
        converter.getIModelCoordinatesFromGeoCoordinates(requestProps).then((responseProps) => {
            this._gcsConverterStatus = (responseProps.iModelCoords.length !== 1 || responseProps.iModelCoords[0].s === imodeljs_common_1.GeoCoordStatus.NoGCSDefined) ? 2 /* NotAvailable */ : 3 /* Available */;
            IModelApp_1.IModelApp.viewManager.onNewTilesReady();
        }).catch((_) => {
            this._gcsConverterStatus = 2 /* NotAvailable */;
            IModelApp_1.IModelApp.viewManager.onNewTilesReady();
        });
    }
    loadTileTree() {
        if (TileTree_1.TileTree.LoadStatus.NotLoaded !== this._loadStatus)
            return this._loadStatus;
        if (this._iModel.ecefLocation === undefined) {
            return this._loadStatus;
        }
        if (0 /* Uninitialized */ === this._gcsConverterStatus)
            this.testGcsConverter();
        if (1 /* Pending */ === this._gcsConverterStatus)
            return this._loadStatus;
        const loader = new WebMapTileLoader(this._imageryProvider, this._iModel, this._groundBias, this._gcsConverterStatus === 3 /* Available */);
        const tileTreeProps = new WebMapTileTreeProps(this._groundBias);
        this.setTileTree(tileTreeProps, loader);
        return this._loadStatus;
    }
    decorate(context) {
        if (!this._imageryProvider)
            return;
        const copyrightImage = this._imageryProvider.getCopyrightImage(this);
        if (copyrightImage && 0 !== copyrightImage.naturalWidth && 0 !== copyrightImage.naturalHeight) {
            const position = new geometry_core_1.Point2d(0, (context.viewport.viewRect.height - copyrightImage.height));
            const drawDecoration = (ctx) => {
                ctx.drawImage(copyrightImage, 0, 0, copyrightImage.width, copyrightImage.height);
            };
            context.addCanvasDecoration({ position, drawDecoration });
        }
        const copyrightMessage = this._imageryProvider.getCopyrightMessage(this, context.screenViewport);
        if (copyrightMessage) {
            const decorationDiv = context.decorationDiv;
            decorationDiv.appendChild(copyrightMessage);
            const boundingRect = copyrightMessage.getBoundingClientRect();
            const style = copyrightMessage.style;
            style.display = "block";
            style.position = "absolute";
            style.left = (decorationDiv.clientWidth - (boundingRect.width + 15)) + "px";
            style.top = (decorationDiv.clientHeight - (boundingRect.height + 5)) + "px";
            style.color = "silver";
            style.backgroundColor = "transparent";
            style.pointerEvents = "initial";
        }
    }
}
exports.BaseTiledMapProvider = BaseTiledMapProvider;
/** This class is the specialization of BasedTiledMapProvider used for Background Maps. In that case, the ImageryProvider is constructed
 * internally using the BackgroundMapProps persisted to the iModel.
 * @internal
 */
class BackgroundMapProvider extends BaseTiledMapProvider {
    // constructs the BackgroundMapProvider from the props persisted in the iModel.
    constructor(json, iModel) {
        super(iModel, bentleyjs_core_1.JsonUtils.asDouble(json.groundBias, 0.0));
        this.providerName = bentleyjs_core_1.JsonUtils.asString(json.providerName, "BingProvider");
        this.mapType = json.providerData ? bentleyjs_core_1.JsonUtils.asInt(json.providerData.mapType, imodeljs_common_1.BackgroundMapType.Hybrid) : imodeljs_common_1.BackgroundMapType.Hybrid;
        // JSON may specify MapType.None (0) which is not defined in enum and is not meaningful.
        // (May also specify any other arbitrary meaningless integer value).
        // If so, use default
        switch (this.mapType) {
            case imodeljs_common_1.BackgroundMapType.Street:
            case imodeljs_common_1.BackgroundMapType.Aerial:
            case imodeljs_common_1.BackgroundMapType.Hybrid:
                break;
            default:
                this.mapType = imodeljs_common_1.BackgroundMapType.Hybrid;
                break;
        }
        // get the map provider.
        if ("BingProvider" === this.providerName) {
            this._imageryProvider = new BingImageryProvider(this.mapType);
        }
        else if ("MapBoxProvider" === this.providerName) {
            this._imageryProvider = new MapBoxImageryProvider(this.mapType);
        }
        if (this._imageryProvider === undefined)
            throw new bentleyjs_core_1.BentleyError(bentleyjs_core_1.IModelStatus.BadModel, "WebMap provider invalid");
    }
    getTileTree(viewport) {
        if (!viewport.viewFlags.backgroundMap || undefined === viewport.displayStyle.backgroundMapPlane)
            return undefined;
        this.loadTileTree();
        return (undefined === this._tileTree) ? undefined : { tileTree: this._tileTree, plane: this.getPlane() };
    }
    equalsProps(props) {
        const providerName = bentleyjs_core_1.JsonUtils.asString(props.providerName, "BingProvider");
        const groundBias = bentleyjs_core_1.JsonUtils.asDouble(props.groundBias, 0.0);
        const mapType = undefined !== props.providerData ? bentleyjs_core_1.JsonUtils.asInt(props.providerData.mapType, imodeljs_common_1.BackgroundMapType.Hybrid) : imodeljs_common_1.BackgroundMapType.Hybrid;
        return providerName === this.providerName && groundBias === this._groundBias && mapType === this.mapType;
    }
}
exports.BackgroundMapProvider = BackgroundMapProvider;
/** @internal */
// this class is the specialization of BasedTiledMapProvider used for Overlay layers. In this case the
// creator of the Overlay must specify the ImageryProvider.
class OverlayMapProvider extends BaseTiledMapProvider {
    constructor(imageryProvider, groundBias, iModel) {
        super(iModel, groundBias);
        this._imageryProvider = imageryProvider;
    }
    getTileTree(_viewport) {
        this.loadTileTree();
        return (undefined === this._tileTree) ? undefined : { tileTree: this._tileTree, plane: this.getPlane() };
    }
}
exports.OverlayMapProvider = OverlayMapProvider;


/***/ }),

/***/ "./lib/tools/AccuDrawTool.js":
/*!***********************************!*\
  !*** ./lib/tools/AccuDrawTool.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const AccuDraw_1 = __webpack_require__(/*! ../AccuDraw */ "./lib/AccuDraw.js");
const AccuSnap_1 = __webpack_require__(/*! ../AccuSnap */ "./lib/AccuSnap.js");
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const AuxCoordSys_1 = __webpack_require__(/*! ../AuxCoordSys */ "./lib/AuxCoordSys.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const HitDetail_1 = __webpack_require__(/*! ../HitDetail */ "./lib/HitDetail.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
function normalizedDifference(point1, point2, out) { return point2.vectorTo(point1).normalizeWithLength(out).mag; }
function normalizedCrossProduct(vec1, vec2, out) { return vec1.crossProduct(vec2, out).normalizeWithLength(out).mag; }
/**
 * A shortcut may require no user input (immediate) or it may install a tool to collect the needed input. AccuDrawShortcuts are how users control AccuDraw.
 * A tool implementor should not use this class to setup AccuDraw, instead use AccuDrawHintBuilder to provide hints.
 * @alpha
 */
class AccuDrawShortcuts {
    static rotateAxesByPoint(isSnapped, aboutCurrentZ) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return false;
        const vp = accudraw.currentView;
        if (!vp)
            return false;
        const point = accudraw.point;
        if (!vp.view.is3d())
            point.z = 0.0;
        if (aboutCurrentZ)
            accudraw.hardConstructionPlane(point, point, accudraw.planePt, accudraw.axes.z, vp, isSnapped);
        else
            accudraw.softConstructionPlane(point, point, accudraw.planePt, accudraw.axes.z, vp, isSnapped);
        // Snap point and compass origin coincide...
        const xVec = new geometry_core_1.Vector3d();
        if (normalizedDifference(point, accudraw.planePt, xVec) < geometry_core_1.Geometry.smallAngleRadians)
            return false;
        accudraw.axes.x.setFrom(xVec);
        if (AccuDraw_1.RotationMode.Context !== accudraw.rotationMode)
            accudraw.setRotationMode(AccuDraw_1.RotationMode.Context);
        accudraw.flags.contextRotMode = AccuDraw_1.ContextMode.XAxis;
        accudraw.flags.lockedRotation = false;
        accudraw.updateRotation();
        // Always want index line to display for x-Axis...changing rotation clears this...so it flashes...
        accudraw.indexed |= AccuDraw_1.LockedStates.X_BM;
        return true;
    }
    static updateACSByPoints(acs, vp, points, isDynamics) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return false;
        let accept = false;
        const vec = [new geometry_core_1.Vector3d(), new geometry_core_1.Vector3d(), new geometry_core_1.Vector3d()];
        acs.setOrigin(points[0]);
        switch (points.length) {
            case 1:
                acs.setRotation(vp.rotation);
                if (!isDynamics) {
                    accudraw.published.origin.setFrom(points[0]);
                    accudraw.published.flags = AccuDraw_1.AccuDrawFlags.SetOrigin;
                    accudraw.flags.fixedOrg = true;
                }
                break;
            case 2:
                if (normalizedDifference(points[1], points[0], vec[0]) < 0.00001) {
                    accept = true;
                    break;
                }
                if (vp.view.is3d()) {
                    if (normalizedCrossProduct(accudraw.axes.y, vec[0], vec[1]) < 0.00001) {
                        vec[2].set(0.0, 0.0, 1.0);
                        if (normalizedCrossProduct(vec[2], vec[0], vec[1]) < 0.00001) {
                            vec[2].set(0.0, 1.0, 0.0);
                            normalizedCrossProduct(vec[2], vec[0], vec[1]);
                        }
                    }
                    normalizedCrossProduct(vec[0], vec[1], vec[2]);
                    acs.setRotation(geometry_core_1.Matrix3d.createRows(vec[0], vec[1], vec[2]));
                    if (!isDynamics) {
                        accudraw.published.origin.setFrom(points[0]);
                        accudraw.published.flags = AccuDraw_1.AccuDrawFlags.SetOrigin | AccuDraw_1.AccuDrawFlags.SetNormal;
                        accudraw.published.vector.setFrom(vec[0]);
                    }
                    break;
                }
                vec[2].set(0.0, 0.0, 1.0);
                normalizedCrossProduct(vec[2], vec[0], vec[1]);
                acs.setRotation(geometry_core_1.Matrix3d.createRows(vec[0], vec[1], vec[2]));
                accept = true;
                break;
            case 3:
                if (normalizedDifference(points[1], points[0], vec[0]) < 0.00001 ||
                    normalizedDifference(points[2], points[0], vec[1]) < 0.00001 ||
                    normalizedCrossProduct(vec[0], vec[1], vec[2]) < 0.00001) {
                    accept = true;
                    break;
                }
                normalizedCrossProduct(vec[2], vec[0], vec[1]);
                acs.setRotation(geometry_core_1.Matrix3d.createRows(vec[0], vec[1], vec[2]));
                accept = true;
                break;
        }
        return accept;
    }
    static processPendingHints() { IModelApp_1.IModelApp.accuDraw.processHints(); }
    static requestInputFocus() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        accudraw.grabInputFocus();
        accudraw.refreshDecorationsAndDynamics();
    }
    // Helper method for GUI implementation...
    static async itemFieldNavigate(index, str, forward) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        if (accudraw.getFieldLock(index))
            accudraw.saveCoordinate(index, accudraw.getValueByIndex(index));
        if (!accudraw.isActive && AccuDraw_1.KeyinStatus.Partial === accudraw.getKeyinStatus(index)) {
            await accudraw.processFieldInput(index, str, true);
        }
        else {
            accudraw.setKeyinStatus(index, AccuDraw_1.KeyinStatus.Dynamic);
            accudraw.onFieldValueChange(index);
        }
        const vp = accudraw.currentView;
        const is3d = vp ? vp.view.is3d() : false;
        const isPolar = (AccuDraw_1.CompassMode.Polar === accudraw.compassMode);
        switch (index) {
            case AccuDraw_1.ItemField.DIST_Item:
                index = ((is3d && !forward) ? AccuDraw_1.ItemField.Z_Item : AccuDraw_1.ItemField.ANGLE_Item);
                break;
            case AccuDraw_1.ItemField.ANGLE_Item:
                index = ((is3d && forward) ? AccuDraw_1.ItemField.Z_Item : AccuDraw_1.ItemField.DIST_Item);
                break;
            case AccuDraw_1.ItemField.X_Item:
                index = ((is3d && !forward) ? AccuDraw_1.ItemField.Z_Item : AccuDraw_1.ItemField.Y_Item);
                break;
            case AccuDraw_1.ItemField.Y_Item:
                index = ((is3d && forward) ? AccuDraw_1.ItemField.Z_Item : AccuDraw_1.ItemField.X_Item);
                break;
            case AccuDraw_1.ItemField.Z_Item:
                index = (forward ? (isPolar ? AccuDraw_1.ItemField.DIST_Item : AccuDraw_1.ItemField.X_Item) : (isPolar ? AccuDraw_1.ItemField.ANGLE_Item : AccuDraw_1.ItemField.Y_Item));
                break;
        }
        accudraw.setKeyinStatus(index, AccuDraw_1.KeyinStatus.Partial);
        accudraw.setFocusItem(index);
        accudraw.dontMoveFocus = true;
    }
    static itemFieldNewInput(index) { IModelApp_1.IModelApp.accuDraw.setKeyinStatus(index, AccuDraw_1.KeyinStatus.Partial); }
    static async itemFieldAcceptInput(index, str) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        await accudraw.processFieldInput(index, str, true);
        accudraw.setKeyinStatus(index, AccuDraw_1.KeyinStatus.Dynamic);
        if (accudraw.getFieldLock(index))
            accudraw.saveCoordinate(index, accudraw.getValueByIndex(index));
        const vp = accudraw.currentView;
        if (accudraw.isActive) {
            if (!vp)
                return;
            if (AccuDraw_1.CompassMode.Polar === accudraw.compassMode)
                accudraw.fixPointPolar(vp);
            else
                accudraw.fixPointRectangular(vp);
            accudraw.flags.dialogNeedsUpdate = true;
            return;
        }
        const is3d = vp ? vp.view.is3d() : false;
        const isPolar = (AccuDraw_1.CompassMode.Polar === accudraw.compassMode);
        switch (index) {
            case AccuDraw_1.ItemField.DIST_Item:
                index = AccuDraw_1.ItemField.ANGLE_Item;
                break;
            case AccuDraw_1.ItemField.ANGLE_Item:
                index = (is3d ? AccuDraw_1.ItemField.Z_Item : AccuDraw_1.ItemField.DIST_Item);
                break;
            case AccuDraw_1.ItemField.X_Item:
                index = AccuDraw_1.ItemField.Y_Item;
                break;
            case AccuDraw_1.ItemField.Y_Item:
                index = (is3d ? AccuDraw_1.ItemField.Z_Item : AccuDraw_1.ItemField.X_Item);
                break;
            case AccuDraw_1.ItemField.Z_Item:
                index = (isPolar ? AccuDraw_1.ItemField.DIST_Item : AccuDraw_1.ItemField.X_Item);
                break;
        }
        accudraw.setFocusItem(index);
    }
    static itemFieldLockToggle(index) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        if (accudraw.getFieldLock(index)) {
            switch (index) {
                case AccuDraw_1.ItemField.DIST_Item:
                    accudraw.distanceLock(true, false);
                    break;
                case AccuDraw_1.ItemField.ANGLE_Item:
                    accudraw.angleLock();
                    break;
                case AccuDraw_1.ItemField.X_Item:
                    accudraw.clearTentative();
                    accudraw.locked |= AccuDraw_1.LockedStates.X_BM;
                    break;
                case AccuDraw_1.ItemField.Y_Item:
                    accudraw.clearTentative();
                    accudraw.locked |= AccuDraw_1.LockedStates.Y_BM;
                    break;
                case AccuDraw_1.ItemField.Z_Item:
                    accudraw.clearTentative();
                    break;
            }
            return;
        }
        switch (index) {
            case AccuDraw_1.ItemField.DIST_Item:
                accudraw.locked &= ~AccuDraw_1.LockedStates.DIST_BM;
                break;
            case AccuDraw_1.ItemField.ANGLE_Item:
                accudraw.locked &= ~AccuDraw_1.LockedStates.ANGLE_BM;
                break;
            case AccuDraw_1.ItemField.X_Item:
                accudraw.locked &= ~AccuDraw_1.LockedStates.X_BM;
                break;
            case AccuDraw_1.ItemField.Y_Item:
                accudraw.locked &= ~AccuDraw_1.LockedStates.Y_BM;
                break;
            case AccuDraw_1.ItemField.Z_Item:
                break;
        }
        accudraw.dontMoveFocus = false;
        accudraw.clearTentative();
    }
    static itemRotationModeChange(rotation) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        const vp = accudraw.currentView;
        const is3d = vp ? vp.view.is3d() : true;
        if (!is3d && (AccuDraw_1.RotationMode.Front === rotation || AccuDraw_1.RotationMode.Side === rotation))
            accudraw.setRotationMode(AccuDraw_1.RotationMode.Top);
        accudraw.flags.baseRotation = rotation;
        accudraw.updateRotation(true);
    }
    // Shortcut implementations for GUI entry points...
    static setOrigin(explicitOrigin) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        if (explicitOrigin) {
            accudraw.published.origin.setFrom(explicitOrigin);
            accudraw.flags.haveValidOrigin = true;
        }
        else if (accudraw.isInactive || accudraw.isDeactivated) {
            // If AccuSnap is active use adjusted snap point, otherwise use last data point...
            const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
            if (undefined !== snap) {
                accudraw.published.origin.setFrom(snap.isPointAdjusted ? snap.adjustedPoint : snap.getPoint());
                accudraw.flags.haveValidOrigin = true;
            }
            else {
                const ev = new Tool_1.BeButtonEvent();
                IModelApp_1.IModelApp.toolAdmin.fillEventFromLastDataButton(ev);
                if (ev.viewport) {
                    accudraw.published.origin.setFrom(ev.point);
                    accudraw.flags.haveValidOrigin = true;
                }
                else {
                    // NOTE: If current point isn't valid setDefaultOrigin will be called...
                    accudraw.published.origin.setFrom(accudraw.point);
                }
            }
        }
        else {
            accudraw.published.origin.setFrom(accudraw.point);
            accudraw.flags.haveValidOrigin = true;
            accudraw.setLastPoint(accudraw.published.origin);
        }
        accudraw.clearTentative();
        const vp = accudraw.currentView;
        // NOTE: _AdjustPoint should have been called to have setup currentView...
        if (vp && !vp.view.is3d())
            accudraw.published.origin.z = 0.0;
        accudraw.origin.setFrom(accudraw.published.origin);
        accudraw.point.setFrom(accudraw.published.origin);
        accudraw.planePt.setFrom(accudraw.published.origin);
        accudraw.published.flags |= AccuDraw_1.AccuDrawFlags.SetOrigin;
        accudraw.activate();
        accudraw.refreshDecorationsAndDynamics();
    }
    static changeCompassMode() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        let axisLockStatus = accudraw.locked & AccuDraw_1.LockedStates.XY_BM;
        if (axisLockStatus) {
            if (AccuDraw_1.CompassMode.Rectangular === accudraw.compassMode) {
                if (axisLockStatus & AccuDraw_1.LockedStates.X_BM && accudraw.delta.x !== 0.0)
                    axisLockStatus &= ~AccuDraw_1.LockedStates.X_BM;
                if (axisLockStatus & AccuDraw_1.LockedStates.Y_BM && accudraw.delta.y !== 0.0)
                    axisLockStatus &= ~AccuDraw_1.LockedStates.Y_BM;
            }
        }
        accudraw.changeCompassMode(true);
        if (axisLockStatus) {
            if (AccuDraw_1.CompassMode.Rectangular === accudraw.compassMode) {
                accudraw.delta.x = accudraw.delta.y = 0.0;
                if (axisLockStatus & AccuDraw_1.LockedStates.X_BM)
                    accudraw.setFieldLock(AccuDraw_1.ItemField.X_Item, true);
                else if (axisLockStatus & AccuDraw_1.LockedStates.Y_BM)
                    accudraw.setFieldLock(AccuDraw_1.ItemField.Y_Item, true);
            }
            else {
                accudraw.setFieldLock(AccuDraw_1.ItemField.ANGLE_Item, true);
            }
            accudraw.locked = axisLockStatus;
        }
        accudraw.flags.baseMode = accudraw.compassMode;
        accudraw.refreshDecorationsAndDynamics();
    }
    static lockSmart() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        const accuSnap = IModelApp_1.IModelApp.accuSnap;
        // Don't want AccuSnap to influence axis or Z...
        if (accuSnap.isHot) {
            accuSnap.clear();
            const vp = accudraw.currentView;
            if (vp) {
                if (AccuDraw_1.CompassMode.Polar === accudraw.compassMode)
                    accudraw.fixPointPolar(vp);
                else
                    accudraw.fixPointRectangular(vp);
            }
        }
        if (AccuDraw_1.CompassMode.Polar === accudraw.compassMode) {
            const isSnapped = accudraw.clearTentative();
            if (accudraw.locked & AccuDraw_1.LockedStates.ANGLE_BM) { // angle locked (unlock it)
                accudraw.setFieldLock(AccuDraw_1.ItemField.ANGLE_Item, false);
                accudraw.locked &= ~AccuDraw_1.LockedStates.ANGLE_BM;
            }
            else if (accudraw.getFieldLock(AccuDraw_1.ItemField.DIST_Item)) { // distance locked (unlock it)
                accudraw.setFieldLock(AccuDraw_1.ItemField.DIST_Item, false);
                accudraw.locked &= ~AccuDraw_1.LockedStates.DIST_BM;
            }
            else if (isSnapped) {
                accudraw.doLockAngle(isSnapped);
            }
            else if (accudraw.indexed & AccuDraw_1.LockedStates.ANGLE_BM) { // angle indexed (lock it)
                accudraw.angleLock();
            }
            else {
                if (Math.abs(accudraw.vector.dotProduct(accudraw.axes.x)) > Math.abs(accudraw.vector.dotProduct(accudraw.axes.y)))
                    accudraw.indexed |= AccuDraw_1.LockedStates.Y_BM;
                else
                    accudraw.indexed |= AccuDraw_1.LockedStates.X_BM;
                accudraw.angleLock();
            }
            accudraw.refreshDecorationsAndDynamics();
            return;
        }
        if (accudraw.locked) { // if locked, unlock
            accudraw.clearTentative();
            accudraw.locked &= ~AccuDraw_1.LockedStates.XY_BM;
            accudraw.setFieldLock(AccuDraw_1.ItemField.X_Item, false);
            accudraw.setFieldLock(AccuDraw_1.ItemField.Y_Item, false);
            if (accudraw.getFieldLock(AccuDraw_1.ItemField.Z_Item) && accudraw.delta.z === 0.0 && !accudraw.stickyZLock)
                accudraw.setFieldLock(AccuDraw_1.ItemField.Z_Item, false);
        }
        else { // lock to nearest axis
            if (accudraw.clearTentative()) {
                if (Math.abs(accudraw.delta.x) >= geometry_core_1.Geometry.smallAngleRadians && Math.abs(accudraw.delta.y) >= geometry_core_1.Geometry.smallAngleRadians) {
                    accudraw.doLockAngle(false);
                    return;
                }
            }
            const vp = accudraw.currentView;
            if (Math.abs(accudraw.delta.x) > Math.abs(accudraw.delta.y)) {
                accudraw.delta.y = 0.0;
                accudraw.onFieldValueChange(AccuDraw_1.ItemField.Y_Item);
                accudraw.locked |= AccuDraw_1.LockedStates.Y_BM;
                accudraw.locked &= ~AccuDraw_1.LockedStates.X_BM;
                accudraw.setFieldLock(AccuDraw_1.ItemField.X_Item, false);
                accudraw.setFieldLock(AccuDraw_1.ItemField.Y_Item, true);
                accudraw.setFieldLock(AccuDraw_1.ItemField.Z_Item, vp ? vp.view.is3d() : false);
            }
            else {
                accudraw.delta.x = 0.0;
                accudraw.onFieldValueChange(AccuDraw_1.ItemField.X_Item);
                accudraw.locked |= AccuDraw_1.LockedStates.X_BM;
                accudraw.locked &= ~AccuDraw_1.LockedStates.Y_BM;
                accudraw.setFieldLock(AccuDraw_1.ItemField.Y_Item, false);
                accudraw.setFieldLock(AccuDraw_1.ItemField.X_Item, true);
                accudraw.setFieldLock(AccuDraw_1.ItemField.Z_Item, vp ? vp.view.is3d() : false);
            }
            if (!accudraw.flags.lockedRotation) {
                accudraw.flags.lockedRotation = true;
                accudraw.flags.contextRotMode = AccuDraw_1.ContextMode.Locked;
                accudraw.setRotationMode(AccuDraw_1.RotationMode.Context);
            }
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    static lockX() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        accudraw.clearTentative();
        if (AccuDraw_1.CompassMode.Rectangular !== accudraw.compassMode) {
            const vp = accudraw.currentView;
            if (!vp)
                return;
            accudraw.fixPointRectangular(vp);
            accudraw.changeCompassMode(true);
        }
        if (accudraw.getFieldLock(AccuDraw_1.ItemField.X_Item)) {
            accudraw.setFieldLock(AccuDraw_1.ItemField.X_Item, false);
            accudraw.locked = accudraw.locked & ~AccuDraw_1.LockedStates.X_BM;
        }
        else {
            accudraw.saveCoordinate(AccuDraw_1.ItemField.X_Item, accudraw.delta.x);
            accudraw.setFieldLock(AccuDraw_1.ItemField.X_Item, true);
            accudraw.locked = accudraw.locked | AccuDraw_1.LockedStates.X_BM;
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    static lockY() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        accudraw.clearTentative();
        if (AccuDraw_1.CompassMode.Rectangular !== accudraw.compassMode) {
            const vp = accudraw.currentView;
            if (!vp)
                return;
            accudraw.fixPointRectangular(vp);
            accudraw.changeCompassMode(true);
        }
        if (accudraw.getFieldLock(AccuDraw_1.ItemField.Y_Item)) {
            accudraw.setFieldLock(AccuDraw_1.ItemField.Y_Item, false);
            accudraw.locked = accudraw.locked & ~AccuDraw_1.LockedStates.Y_BM;
        }
        else {
            accudraw.saveCoordinate(AccuDraw_1.ItemField.Y_Item, accudraw.delta.y);
            accudraw.setFieldLock(AccuDraw_1.ItemField.Y_Item, true);
            accudraw.locked = accudraw.locked | AccuDraw_1.LockedStates.Y_BM;
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    static lockZ() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        const vp = accudraw.currentView;
        if (!vp || !vp.view.is3d())
            return;
        const isSnapped = accudraw.clearTentative();
        if (accudraw.getFieldLock(AccuDraw_1.ItemField.Z_Item)) {
            accudraw.setFieldLock(AccuDraw_1.ItemField.Z_Item, false);
        }
        else {
            // Move focus to Z field...
            if (!isSnapped && accudraw.autoFocusFields) {
                accudraw.setFocusItem(AccuDraw_1.ItemField.Z_Item);
                accudraw.dontMoveFocus = true;
            }
            accudraw.setFieldLock(AccuDraw_1.ItemField.Z_Item, true);
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    static lockDistance() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        const isSnapped = accudraw.clearTentative();
        if (AccuDraw_1.CompassMode.Polar !== accudraw.compassMode) {
            const vp = accudraw.currentView;
            if (!vp)
                return;
            accudraw.locked = 0;
            accudraw.fixPointPolar(vp);
            accudraw.changeCompassMode(true);
        }
        if (accudraw.getFieldLock(AccuDraw_1.ItemField.DIST_Item)) {
            accudraw.setFieldLock(AccuDraw_1.ItemField.DIST_Item, false);
            accudraw.locked &= ~AccuDraw_1.LockedStates.DIST_BM;
            accudraw.setKeyinStatus(AccuDraw_1.ItemField.DIST_Item, AccuDraw_1.KeyinStatus.Dynamic); // Need to clear partial status if locked by entering distance since focus stays in distance field...
        }
        else {
            // Move focus to distance field...
            if (!isSnapped && accudraw.autoFocusFields)
                accudraw.setFocusItem(AccuDraw_1.ItemField.DIST_Item);
            accudraw.distanceLock(true, true);
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    static lockAngle() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        accudraw.doLockAngle(accudraw.clearTentative());
        accudraw.refreshDecorationsAndDynamics();
    }
    lockIndex() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        if (accudraw.flags.indexLocked) {
            if (accudraw.locked)
                AccuDrawShortcuts.lockSmart();
            accudraw.flags.indexLocked = false;
        }
        else {
            if (AccuDraw_1.CompassMode.Polar === accudraw.compassMode) {
                if (accudraw.indexed & AccuDraw_1.LockedStates.XY_BM) {
                    accudraw.setFieldLock(AccuDraw_1.ItemField.ANGLE_Item, true);
                    accudraw.angleLock();
                }
                if (accudraw.indexed & AccuDraw_1.LockedStates.DIST_BM)
                    AccuDrawShortcuts.lockDistance();
            }
            else {
                if (accudraw.indexed & AccuDraw_1.LockedStates.X_BM) {
                    AccuDrawShortcuts.lockX();
                    if (accudraw.indexed & AccuDraw_1.LockedStates.DIST_BM)
                        AccuDrawShortcuts.lockY();
                }
                if (accudraw.indexed & AccuDraw_1.LockedStates.Y_BM) {
                    AccuDrawShortcuts.lockY();
                    if (accudraw.indexed & AccuDraw_1.LockedStates.DIST_BM)
                        AccuDrawShortcuts.lockX();
                }
                if (accudraw.indexed & AccuDraw_1.LockedStates.DIST_BM && !(accudraw.indexed & AccuDraw_1.LockedStates.XY_BM)) {
                    if (accudraw.locked & AccuDraw_1.LockedStates.X_BM)
                        AccuDrawShortcuts.lockY();
                    else
                        AccuDrawShortcuts.lockX();
                }
            }
            accudraw.flags.indexLocked = true;
        }
        accudraw.refreshDecorationsAndDynamics();
    }
    static setStandardRotation(rotation) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        if (AccuDraw_1.RotationMode.Context === rotation) {
            const axes = accudraw.baseAxes.clone();
            accudraw.accountForAuxRotationPlane(axes, accudraw.flags.auxRotationPlane);
            accudraw.setContextRotation(axes.toMatrix3d(), false, true);
            accudraw.refreshDecorationsAndDynamics();
            return;
        }
        else {
            accudraw.flags.baseRotation = rotation;
            accudraw.setRotationMode(rotation);
        }
        accudraw.updateRotation(true);
        accudraw.refreshDecorationsAndDynamics();
    }
    static alignView() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        const vp = accudraw.currentView;
        if (!vp)
            return;
        const newMatrix = accudraw.getRotation();
        if (newMatrix.isExactEqual(vp.rotation))
            return;
        const targetMatrix = newMatrix.multiplyMatrixMatrix(vp.rotation);
        const rotateTransform = geometry_core_1.Transform.createFixedPointAndMatrix(vp.view.getTargetPoint(), targetMatrix);
        const startFrustum = vp.getFrustum();
        const newFrustum = startFrustum.clone();
        newFrustum.multiply(rotateTransform);
        vp.animateFrustumChange(startFrustum, newFrustum);
        vp.view.setupFromFrustum(newFrustum);
        vp.synchWithView(true);
        accudraw.refreshDecorationsAndDynamics();
    }
    static rotateToBase() { this.setStandardRotation(IModelApp_1.IModelApp.accuDraw.flags.baseRotation); }
    static rotateToACS() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        // NOTE: Match current ACS orientation..reset auxRotationPlane to top!
        accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Top;
        this.setStandardRotation(AccuDraw_1.RotationMode.ACS);
    }
    static rotateCycle(updateCurrentACS) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        const vp = accudraw.currentView;
        if (!vp || !vp.view.is3d())
            return;
        let rotation;
        switch (accudraw.rotationMode) {
            case AccuDraw_1.RotationMode.View:
            case AccuDraw_1.RotationMode.Side:
                rotation = AccuDraw_1.RotationMode.Top;
                break;
            case AccuDraw_1.RotationMode.Top:
                rotation = AccuDraw_1.RotationMode.Front;
                break;
            case AccuDraw_1.RotationMode.Front:
                rotation = AccuDraw_1.RotationMode.Side;
                break;
            case AccuDraw_1.RotationMode.Context:
                if (!updateCurrentACS) {
                    rotation = AccuDraw_1.RotationMode.Context;
                    if (rotation !== accudraw.flags.baseRotation) {
                        accudraw.baseAxes.setFrom(accudraw.axes);
                        accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Top;
                        accudraw.flags.baseRotation = rotation;
                    }
                    else {
                        const axes = accudraw.baseAxes.clone();
                        accudraw.accountForAuxRotationPlane(axes, accudraw.flags.auxRotationPlane);
                        if (!accudraw.axes.equals(axes))
                            accudraw.changeBaseRotationMode(rotation);
                    }
                    switch (accudraw.flags.auxRotationPlane) {
                        case AccuDraw_1.RotationMode.Front:
                            accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Side;
                            break;
                        case AccuDraw_1.RotationMode.Side:
                            accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Top;
                            break;
                        case AccuDraw_1.RotationMode.Top:
                            accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Front;
                            break;
                    }
                    break;
                }
                // copy it to an ACS
                accudraw.updateRotation();
                accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Top;
                const currentACS = vp.view.auxiliaryCoordinateSystem;
                const acs = currentACS.clone();
                acs.setRotation(accudraw.getRotation());
                AccuDraw_1.AccuDraw.updateAuxCoordinateSystem(acs, vp);
            /* falls through */
            case AccuDraw_1.RotationMode.ACS:
                rotation = AccuDraw_1.RotationMode.ACS;
                switch (accudraw.flags.auxRotationPlane) {
                    case AccuDraw_1.RotationMode.Front:
                        accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Side;
                        break;
                    case AccuDraw_1.RotationMode.Side:
                        accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Top;
                        break;
                    case AccuDraw_1.RotationMode.Top:
                        accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Front;
                        break;
                }
                break;
            default:
                return;
        }
        this.setStandardRotation(rotation);
    }
    static rotate90(axis) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        const newRotation = new AccuDraw_1.ThreeAxes();
        accudraw.locked = accudraw.indexed = 0;
        accudraw.unlockAllFields();
        switch (axis) {
            case 0:
                newRotation.x.setFrom(accudraw.axes.x);
                newRotation.z.setFrom(accudraw.axes.y);
                newRotation.z.crossProduct(newRotation.x, newRotation.y);
                break;
            case 1:
                newRotation.x.setFrom(accudraw.axes.z);
                newRotation.y.setFrom(accudraw.axes.y);
                newRotation.x.crossProduct(newRotation.y, newRotation.z);
                break;
            case 2:
                newRotation.x.setFrom(accudraw.axes.y);
                newRotation.z.setFrom(accudraw.axes.z);
                newRotation.z.crossProduct(newRotation.x, newRotation.y);
                break;
        }
        accudraw.setContextRotation(newRotation.toMatrix3d(), true, true);
        accudraw.refreshDecorationsAndDynamics();
    }
    static rotateAxes(aboutCurrentZ) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isActive)
            return; // Require compass to already be active for this shortcut...
        if (aboutCurrentZ)
            accudraw.changeBaseRotationMode(AccuDraw_1.RotationMode.Context); // Establish current orientation as base; base Z is used when defining compass rotation by x axis...
        if (accudraw.clearTentative() || IModelApp_1.IModelApp.accuSnap.isHot ||
            (AccuDraw_1.CompassMode.Polar === accudraw.compassMode && accudraw.getFieldLock(AccuDraw_1.ItemField.ANGLE_Item)) ||
            (AccuDraw_1.CompassMode.Polar !== accudraw.compassMode && accudraw.getFieldLock(AccuDraw_1.ItemField.X_Item) && accudraw.getFieldLock(AccuDraw_1.ItemField.Y_Item))) {
            if (AccuDrawShortcuts.rotateAxesByPoint(true, aboutCurrentZ)) {
                AccuDrawShortcuts.itemFieldUnlockAll();
                accudraw.refreshDecorationsAndDynamics();
                return;
            }
        }
        AccuDrawTool.installTool(new RotateAxesTool(aboutCurrentZ));
    }
    static rotateToElement(updateCurrentACS) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return;
        const moveOrigin = !accudraw.isActive; // Leave current origin if AccuDraw is already enabled...
        AccuDrawTool.installTool(new RotateElementTool(moveOrigin, updateCurrentACS, false));
    }
    static defineACSByElement() {
        AccuDrawTool.installTool(new RotateElementTool(true, true, true));
    }
    static defineACSByPoints() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (accudraw.isEnabled)
            AccuDrawTool.installTool(new DefineACSByPointsTool());
    }
    static getACS(acsName, useOrigin, useRotation) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return bentleyjs_core_1.BentleyStatus.ERROR;
        const vp = accudraw.currentView;
        if (!vp)
            return bentleyjs_core_1.BentleyStatus.ERROR;
        let currRotation = 0, currBaseRotation = 0;
        const axes = new AccuDraw_1.ThreeAxes();
        if (!useRotation) {
            // Save current rotation, event listener on ACS change will orient AccuDraw to ACS...
            currRotation = accudraw.rotationMode;
            currBaseRotation = accudraw.flags.baseRotation;
            axes.setFrom(accudraw.axes);
        }
        if (acsName && "" !== acsName) {
            //   // See if this ACS already exists...
            //   DgnCode acsCode = AuxCoordSystem:: CreateCode(vp -> GetViewControllerR().GetViewDefinition(), acsName);
            //   DgnElementId acsId = vp -> GetViewController().GetDgnDb().Elements().QueryElementIdByCode(acsCode);
            //   if (!acsId.IsValid())
            //     return ERROR;
            //   AuxCoordSystemCPtr auxElm = vp -> GetViewController().GetDgnDb().Elements().Get<AuxCoordSystem>(acsId);
            //   if (!auxElm.IsValid())
            //     return ERROR;
            //   AuxCoordSystemPtr acsPtr = auxElm -> MakeCopy<AuxCoordSystem>();
            //   if (!acsPtr.IsValid())
            //     return ERROR;
            //   AuxCoordSystemCR oldACS = vp -> GetViewController().GetAuxCoordinateSystem();
            //   if (!useOrigin)
            //     acsPtr -> SetOrigin(oldACS.GetOrigin());
            //   if (!useRotation)
            //     acsPtr -> SetRotation(oldACS.GetRotation());
            //   AccuDraw:: UpdateAuxCoordinateSystem(* acsPtr, * vp);
        }
        const currentACS = vp.view.auxiliaryCoordinateSystem;
        if (useOrigin) {
            accudraw.origin.setFrom(currentACS.getOrigin());
            accudraw.point.setFrom(accudraw.origin);
            accudraw.planePt.setFrom(accudraw.origin);
        }
        if (useRotation) {
            accudraw.flags.auxRotationPlane = AccuDraw_1.RotationMode.Top;
            this.setStandardRotation(AccuDraw_1.RotationMode.ACS);
        }
        else {
            this.itemFieldUnlockAll();
            accudraw.setRotationMode(currRotation);
            accudraw.flags.baseRotation = currBaseRotation;
            accudraw.axes.setFrom(axes);
            if (AccuDraw_1.RotationMode.ACS === accudraw.flags.baseRotation) {
                const acs = currentACS.clone();
                const rMatrix = accudraw.getRotation();
                acs.setRotation(rMatrix);
                AccuDraw_1.AccuDraw.updateAuxCoordinateSystem(acs, vp);
            }
            accudraw.published.flags &= ~AccuDraw_1.AccuDrawFlags.OrientACS;
        }
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    static writeACS(_acsName) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (!accudraw.isEnabled)
            return bentleyjs_core_1.BentleyStatus.ERROR;
        const vp = accudraw.currentView;
        if (!vp)
            return bentleyjs_core_1.BentleyStatus.ERROR;
        // const origin = accudraw.origin;
        // const rMatrix = accudraw.getRotation();
        // AuxCoordSystemPtr acsPtr = AuxCoordSystem:: CreateFrom(vp -> GetViewController().GetAuxCoordinateSystem());
        // acsPtr -> SetOrigin(origin);
        // acsPtr -> SetRotation(rMatrix);
        // acsPtr -> SetType(CompassMode.Polar == accudraw.getCompassMode() ? ACSType :: Cylindrical : ACSType:: Rectangular);
        // acsPtr -> SetCode(AuxCoordSystem:: CreateCode(vp -> GetViewControllerR().GetViewDefinition(), nullptr != acsName ? acsName : ""));
        // acsPtr -> SetDescription("");
        // if (acsName && '\0' != acsName[0]) {
        //   DgnDbStatus status;
        //   acsPtr -> Insert(& status);
        //   if (DgnDbStatus:: Success != status)
        //   return BentleyStatus.ERROR;
        // }
        // AccuDraw:: UpdateAuxCoordinateSystem(* acsPtr, * vp);
        // accudraw.flags.baseRotation = RotationMode.ACS;
        // accudraw.SetRotationMode(RotationMode.ACS);
        return bentleyjs_core_1.BentleyStatus.SUCCESS;
    }
    static itemFieldUnlockAll() {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (accudraw.isEnabled)
            accudraw.unlockAllFields();
    }
    /** @internal Temporary keyboard shortcuts. */
    static processShortcutKey(keyEvent) {
        switch (keyEvent.key.toLowerCase()) {
            case "enter":
                AccuDrawShortcuts.lockSmart();
                return true;
            case "x":
                AccuDrawShortcuts.lockX();
                return true;
            case "y":
                AccuDrawShortcuts.lockY();
                return true;
            case "z":
                AccuDrawShortcuts.lockZ();
                return true;
            case "a":
                AccuDrawShortcuts.lockAngle();
                return true;
            case "d":
                AccuDrawShortcuts.lockDistance();
                return true;
            case "m":
                AccuDrawShortcuts.changeCompassMode();
                return true;
            case "t":
                AccuDrawShortcuts.setStandardRotation(AccuDraw_1.RotationMode.Top);
                return true;
            case "f":
                AccuDrawShortcuts.setStandardRotation(AccuDraw_1.RotationMode.Front);
                return true;
            case "s":
                AccuDrawShortcuts.setStandardRotation(AccuDraw_1.RotationMode.Side);
                return true;
            case "v":
                AccuDrawShortcuts.setStandardRotation(AccuDraw_1.RotationMode.View);
                return true;
            case "o":
                AccuDrawShortcuts.setOrigin();
                return true;
            case "c":
                AccuDrawShortcuts.rotateCycle(false);
                return true;
            case "q":
                AccuDrawShortcuts.rotateAxes(true);
                return true;
            case "e":
                AccuDrawShortcuts.rotateToElement(false);
                return true;
            case "r":
                AccuDrawShortcuts.defineACSByPoints();
                return true;
            default:
                return false;
        }
    }
}
exports.AccuDrawShortcuts = AccuDrawShortcuts;
class AccuDrawShortcutsTool extends Tool_1.InputCollector {
    constructor(shortcut) { super(); this._shortcut = shortcut; this._cancel = true; }
    onPostInstall() { super.onPostInstall(); this.initLocateElements(false, true, undefined, Tool_1.CoordinateLockOverrides.None); this._shortcut.doManipulationStart(); } // NOTE: InputCollector inherits suspended primitive's state, set everything...
    onCleanup() { this._shortcut.doManipulationStop(this._cancel); }
    async onDataButtonDown(ev) { if (await this._shortcut.doManipulation(ev, false)) {
        this._cancel = false;
        this.exitTool();
    } return Tool_1.EventHandled.No; }
    async onMouseMotion(ev) { this._shortcut.doManipulation(ev, true); } // tslint:disable-line:no-floating-promises
    decorate(context) { this._shortcut.onDecorate(context); }
    exitTool() { super.exitTool(); AccuDrawShortcuts.requestInputFocus(); } // re-grab focus when auto-focus tool setting set...
}
AccuDrawShortcutsTool.toolId = "View.AccuDraw";
/** @internal */
class AccuDrawTool {
    doManipulationStart() {
        if (this.activateAccuDrawOnStart())
            IModelApp_1.IModelApp.accuDraw.activate();
        this.doManipulation(undefined, true); // tslint:disable-line:no-floating-promises
    }
    doManipulationStop(cancel) {
        if (!cancel)
            IModelApp_1.IModelApp.accuDraw.savedStateInputCollector.ignoreFlags = this.onManipulationComplete();
    }
    activateAccuDrawOnStart() { return true; }
    onManipulationComplete() { return 0; }
    onDecorate(_context) { }
    static installTool(shortcut) { return new AccuDrawShortcutsTool(shortcut).run(); }
    static outputPrompt(messageKey) { IModelApp_1.IModelApp.notifications.outputPromptByKey("AccuDraw.Prompt." + messageKey); }
}
exports.AccuDrawTool = AccuDrawTool;
class RotateAxesTool extends AccuDrawTool {
    constructor(_aboutCurrentZ) {
        super();
        this._aboutCurrentZ = _aboutCurrentZ;
    }
    onManipulationComplete() { return AccuDraw_1.AccuDrawFlags.SetRMatrix; }
    doManipulationStart() {
        super.doManipulationStart();
        AccuDrawTool.outputPrompt("DefineXAxis");
    }
    async doManipulation(ev, isMotion) {
        const vp = ev ? ev.viewport : IModelApp_1.IModelApp.accuDraw.currentView;
        if (!vp)
            return true;
        AccuDrawShortcuts.rotateAxesByPoint(AccuSnap_1.TentativeOrAccuSnap.isHot, this._aboutCurrentZ);
        vp.invalidateDecorations();
        if (!isMotion)
            AccuDrawShortcuts.itemFieldUnlockAll();
        return true;
    }
}
class RotateElementTool extends AccuDrawTool {
    constructor(_moveOrigin, _updateCurrentACS, _updateDynamicACS) {
        super();
        this._moveOrigin = _moveOrigin;
        this._updateCurrentACS = _updateCurrentACS;
        this._updateDynamicACS = _updateDynamicACS;
    }
    activateAccuDrawOnStart() { return !this._updateDynamicACS; }
    onManipulationComplete() {
        let ignoreFlags = AccuDraw_1.AccuDrawFlags.SetRMatrix;
        if (this._moveOrigin)
            ignoreFlags |= AccuDraw_1.AccuDrawFlags.SetOrigin;
        if (!this._updateDynamicACS)
            ignoreFlags |= AccuDraw_1.AccuDrawFlags.Disable; // If AccuDraw wasn't active when the shortcut started, let it remain active for suspended tool when shortcut completes...
        return ignoreFlags;
    }
    doManipulationStart() {
        super.doManipulationStart();
        AccuDrawTool.outputPrompt("DefineElem");
        const accuSnap = IModelApp_1.IModelApp.accuSnap;
        if (!accuSnap.isSnapEnabledByUser)
            accuSnap.enableLocate(true); // If user doesn't want AccuSnap, tool can work with just auto-locate...
    }
    updateOrientation(snap, vp) {
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        const rMatrix = AccuDraw_1.AccuDraw.getSnapRotation(snap, vp);
        if (undefined === rMatrix)
            return false;
        const origin = this._moveOrigin ? snap.snapPoint : accudraw.origin;
        accudraw.setContext(AccuDraw_1.AccuDrawFlags.AlwaysSetOrigin | AccuDraw_1.AccuDrawFlags.SetRMatrix, origin, rMatrix);
        return true;
    }
    async doManipulation(ev, isMotion) {
        const vp = ev ? ev.viewport : IModelApp_1.IModelApp.accuDraw.currentView;
        if (!vp)
            return true;
        let snapDetail = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
        if (undefined === snapDetail) {
            const accuSnap = IModelApp_1.IModelApp.accuSnap;
            const hitDetail = accuSnap.currHit;
            // Turn hit into nearest snap when shortcut was started without AccuSnap being user enabled...
            if (undefined !== hitDetail)
                snapDetail = await AccuSnap_1.AccuSnap.requestSnap(hitDetail, [HitDetail_1.SnapMode.Nearest], IModelApp_1.IModelApp.locateManager.apertureInches, 1);
        }
        if (undefined !== snapDetail && !this.updateOrientation(snapDetail, vp))
            return true;
        if (this._updateDynamicACS)
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        else if (undefined === ev)
            AccuDrawShortcuts.processPendingHints();
        if (isMotion)
            return true;
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        if (this._updateCurrentACS) {
            AccuDrawShortcuts.processPendingHints();
            const currentACS = vp.view.auxiliaryCoordinateSystem;
            const acs = currentACS.clone();
            acs.setOrigin(accudraw.origin);
            acs.setRotation(accudraw.getRotation());
            AccuDraw_1.AccuDraw.updateAuxCoordinateSystem(acs, vp);
        }
        else {
            accudraw.changeBaseRotationMode(AccuDraw_1.RotationMode.Context); // Hold temporary rotation for tool duration when not updating ACS...
        }
        return true;
    }
    onDecorate(context) {
        if (!this._updateDynamicACS)
            return;
        const accudraw = IModelApp_1.IModelApp.accuDraw;
        const origin = accudraw.origin;
        const rMatrix = accudraw.getRotation();
        const acs = context.viewport.view.auxiliaryCoordinateSystem.clone();
        acs.setOrigin(origin);
        acs.setRotation(rMatrix);
        acs.display(context, AuxCoordSys_1.ACSDisplayOptions.Active | AuxCoordSys_1.ACSDisplayOptions.Dynamics);
    }
}
class DefineACSByPointsTool extends AccuDrawTool {
    constructor() {
        super(...arguments);
        this._points = [];
    }
    activateAccuDrawOnStart() { return false; }
    onManipulationComplete() { return AccuDraw_1.AccuDrawFlags.SetRMatrix; }
    doManipulationStart() {
        super.doManipulationStart();
        const tentativePoint = IModelApp_1.IModelApp.tentativePoint;
        if (!tentativePoint.isActive) {
            AccuDrawTool.outputPrompt("DefineOrigin");
            return;
        }
        const origin = tentativePoint.getPoint().clone();
        AccuDrawTool.outputPrompt("DefineXAxis");
        IModelApp_1.IModelApp.accuDraw.setContext(AccuDraw_1.AccuDrawFlags.SetOrigin | AccuDraw_1.AccuDrawFlags.FixedOrigin, origin);
        this._points.push(origin);
        tentativePoint.clear(true);
    }
    async doManipulation(ev, isMotion) {
        if (!ev || !ev.viewport)
            return true;
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        if (isMotion)
            return false;
        IModelApp_1.IModelApp.accuDraw.activate();
        this._points.push(ev.point.clone());
        const vp = ev.viewport;
        if (!this._acs)
            this._acs = vp.view.auxiliaryCoordinateSystem.clone();
        if (AccuDrawShortcuts.updateACSByPoints(this._acs, vp, this._points, false)) {
            AccuDraw_1.AccuDraw.updateAuxCoordinateSystem(this._acs, vp);
            AccuDrawShortcuts.rotateToACS();
            return true;
        }
        AccuDrawTool.outputPrompt(1 === this._points.length ? "DefineXAxis" : "DefineYDir");
        return false;
    }
    onDecorate(context) {
        const tmpPoints = [];
        this._points.forEach((pt) => tmpPoints.push(pt));
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        tmpPoints.push(ev.point);
        const vp = context.viewport;
        if (!this._acs)
            this._acs = vp.view.auxiliaryCoordinateSystem.clone();
        AccuDrawShortcuts.updateACSByPoints(this._acs, vp, tmpPoints, true);
        this._acs.display(context, AuxCoordSys_1.ACSDisplayOptions.Active | AuxCoordSys_1.ACSDisplayOptions.Dynamics);
    }
}


/***/ }),

/***/ "./lib/tools/ClipViewTool.js":
/*!***********************************!*\
  !*** ./lib/tools/ClipViewTool.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const ElementLocateManager_1 = __webpack_require__(/*! ../ElementLocateManager */ "./lib/ElementLocateManager.js");
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const AccuSnap_1 = __webpack_require__(/*! ../AccuSnap */ "./lib/AccuSnap.js");
const PrimitiveTool_1 = __webpack_require__(/*! ./PrimitiveTool */ "./lib/tools/PrimitiveTool.js");
const EditManipulator_1 = __webpack_require__(/*! ./EditManipulator */ "./lib/tools/EditManipulator.js");
const AccuDraw_1 = __webpack_require__(/*! ../AccuDraw */ "./lib/AccuDraw.js");
const StandardView_1 = __webpack_require__(/*! ../StandardView */ "./lib/StandardView.js");
const rendering_1 = __webpack_require__(/*! ../rendering */ "./lib/rendering.js");
const ToolSettingsValue_1 = __webpack_require__(/*! ../properties/ToolSettingsValue */ "./lib/properties/ToolSettingsValue.js");
const AccuDrawTool_1 = __webpack_require__(/*! ./AccuDrawTool */ "./lib/tools/AccuDrawTool.js");
const imodeljs_frontend_1 = __webpack_require__(/*! ../imodeljs-frontend */ "./lib/imodeljs-frontend.js");
const imodeljs_clients_1 = __webpack_require__(/*! @bentley/imodeljs-clients */ "@bentley/imodeljs-clients");
/** @alpha The orientation to use to define the view clip volume */
var ClipOrientation;
(function (ClipOrientation) {
    ClipOrientation[ClipOrientation["Top"] = 0] = "Top";
    ClipOrientation[ClipOrientation["Front"] = 1] = "Front";
    ClipOrientation[ClipOrientation["Left"] = 2] = "Left";
    ClipOrientation[ClipOrientation["Bottom"] = 3] = "Bottom";
    ClipOrientation[ClipOrientation["Back"] = 4] = "Back";
    ClipOrientation[ClipOrientation["Right"] = 5] = "Right";
    ClipOrientation[ClipOrientation["View"] = 6] = "View";
    ClipOrientation[ClipOrientation["Face"] = 7] = "Face";
})(ClipOrientation = exports.ClipOrientation || (exports.ClipOrientation = {}));
/** @alpha A tool to define a clip volume for a view */
class ViewClipTool extends PrimitiveTool_1.PrimitiveTool {
    constructor(_clipEventHandler) {
        super();
        this._clipEventHandler = _clipEventHandler;
    }
    static enumAsOrientationMessage(str) { return IModelApp_1.IModelApp.i18n.translate("CoreTools:tools.ViewClip.Settings.Orientation." + str); }
    requireWriteableTarget() { return false; }
    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.allow3dManipulations()); }
    onPostInstall() { super.onPostInstall(); this.setupAndPromptForNextAction(); }
    onUnsuspend() { this.showPrompt(); }
    onRestartTool() { this.exitTool(); }
    outputPrompt(prompt) { IModelApp_1.IModelApp.notifications.outputPromptByKey("CoreTools:tools.ViewClip." + prompt); }
    showPrompt() { }
    setupAndPromptForNextAction() { this.showPrompt(); }
    async onResetButtonUp(_ev) { this.onReinitialize(); return Tool_1.EventHandled.No; }
    static getPlaneInwardNormal(orientation, viewport) {
        const matrix = ViewClipTool.getClipOrientation(orientation, viewport);
        if (undefined === matrix)
            return undefined;
        return matrix.getColumn(2).negate();
    }
    static getClipOrientation(orientation, viewport) {
        switch (orientation) {
            case ClipOrientation.Top:
                return AccuDraw_1.AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Top, viewport, viewport.isContextRotationRequired).inverse();
            case ClipOrientation.Front:
                return AccuDraw_1.AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Front, viewport, viewport.isContextRotationRequired).inverse();
            case ClipOrientation.Left:
                return AccuDraw_1.AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Left, viewport, viewport.isContextRotationRequired).inverse();
            case ClipOrientation.Bottom:
                return AccuDraw_1.AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Bottom, viewport, viewport.isContextRotationRequired).inverse();
            case ClipOrientation.Back:
                return AccuDraw_1.AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Back, viewport, viewport.isContextRotationRequired).inverse();
            case ClipOrientation.Right:
                return AccuDraw_1.AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Right, viewport, viewport.isContextRotationRequired).inverse();
            case ClipOrientation.View:
                return viewport.view.getRotation().inverse();
            case ClipOrientation.Face:
                const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
                if (undefined === snap || undefined === snap.normal)
                    return undefined;
                const normal = geometry_core_1.Vector3d.createZero();
                const boresite = EditManipulator_1.EditManipulator.HandleUtils.getBoresite(snap.hitPoint, viewport);
                if (snap.normal.dotProduct(boresite.direction) < 0.0)
                    normal.setFrom(snap.normal);
                else
                    snap.normal.negate(normal);
                return geometry_core_1.Matrix3d.createRigidHeadsUp(normal);
        }
        return undefined;
    }
    static enableClipVolume(viewport) {
        if (viewport.viewFlags.clipVolume)
            return false;
        const viewFlags = viewport.viewFlags.clone();
        viewFlags.clipVolume = true;
        viewport.viewFlags = viewFlags;
        return true;
    }
    static setViewClip(viewport, clip) {
        viewport.view.setViewClip(clip);
        viewport.setupFromView();
        return true;
    }
    static doClipToConvexClipPlaneSet(viewport, planes) {
        const prim = geometry_core_1.ClipPrimitive.createCapture(planes);
        const clip = geometry_core_1.ClipVector.createEmpty();
        clip.appendReference(prim);
        return this.setViewClip(viewport, clip);
    }
    static doClipToPlane(viewport, origin, normal, clearExistingPlanes) {
        const plane = geometry_core_1.Plane3dByOriginAndUnitNormal.create(origin, normal);
        if (undefined === plane)
            return false;
        let planeSet;
        if (!clearExistingPlanes) {
            const existingClip = viewport.view.getViewClip();
            if (undefined !== existingClip && 1 === existingClip.clips.length) {
                const existingPrim = existingClip.clips[0];
                if (!(existingPrim instanceof geometry_core_1.ClipShape)) {
                    const existingPlaneSets = existingPrim.fetchClipPlanesRef();
                    if (undefined !== existingPlaneSets && 1 === existingPlaneSets.convexSets.length)
                        planeSet = existingPlaneSets.convexSets[0];
                }
            }
        }
        if (undefined === planeSet)
            planeSet = geometry_core_1.ConvexClipPlaneSet.createEmpty();
        planeSet.addPlaneToConvexSet(geometry_core_1.ClipPlane.createPlane(plane));
        return this.doClipToConvexClipPlaneSet(viewport, planeSet);
    }
    static doClipToShape(viewport, xyPoints, transform, zLow, zHigh) {
        const clip = geometry_core_1.ClipVector.createEmpty();
        clip.appendShape(xyPoints, zLow, zHigh, transform);
        return this.setViewClip(viewport, clip);
    }
    static doClipToRange(viewport, range, transform) {
        if (range.isNull || range.isAlmostZeroX || range.isAlmostZeroY)
            return false;
        const clip = geometry_core_1.ClipVector.createEmpty();
        const block = geometry_core_1.ClipShape.createBlock(range, range.isAlmostZeroZ ? geometry_core_1.ClipMaskXYZRangePlanes.XAndY : geometry_core_1.ClipMaskXYZRangePlanes.All, false, false, transform);
        clip.appendReference(block);
        return this.setViewClip(viewport, clip);
    }
    static doClipClear(viewport) {
        if (!ViewClipTool.hasClip(viewport))
            return false;
        return this.setViewClip(viewport);
    }
    static getClipRayTransformed(origin, direction, transform) {
        const facePt = origin.clone();
        const faceDir = direction.clone();
        if (undefined !== transform) {
            transform.multiplyPoint3d(facePt, facePt);
            transform.multiplyVector(faceDir, faceDir);
            faceDir.normalizeInPlace();
        }
        return geometry_core_1.Ray3d.createCapture(facePt, faceDir);
    }
    static getOffsetValueTransformed(offset, transform) {
        if (undefined === transform)
            return offset;
        const lengthVec = geometry_core_1.Vector3d.create(offset);
        transform.multiplyVector(lengthVec, lengthVec);
        const localOffset = lengthVec.magnitude();
        return (offset < 0 ? -localOffset : localOffset);
    }
    static drawClipShape(context, shape, extents, color, weight, id) {
        const shapePtsLo = ViewClipTool.getClipShapePoints(shape, extents.low);
        const shapePtsHi = ViewClipTool.getClipShapePoints(shape, extents.high);
        const builder = context.createGraphicBuilder(rendering_1.GraphicType.WorldDecoration, shape.transformFromClip, id); // Use WorldDecoration not WorldOverlay to make sure handles have priority...
        builder.setSymbology(color, imodeljs_common_1.ColorDef.black, weight);
        for (let i = 0; i < shapePtsLo.length; i++)
            builder.addLineString([shapePtsLo[i].clone(), shapePtsHi[i].clone()]);
        builder.addLineString(shapePtsLo);
        builder.addLineString(shapePtsHi);
        context.addDecorationFromBuilder(builder);
    }
    static getClipShapePoints(shape, z) {
        const points = [];
        for (const pt of shape.polygon)
            points.push(geometry_core_1.Point3d.create(pt.x, pt.y, z));
        return points;
    }
    static getClipShapeExtents(shape, viewRange) {
        let zLow = shape.zLow;
        let zHigh = shape.zHigh;
        if (undefined === zLow || undefined === zHigh) {
            const zVec = geometry_core_1.Vector3d.unitZ();
            const origin = shape.polygon[0];
            const corners = viewRange.corners();
            if (undefined !== shape.transformToClip)
                shape.transformToClip.multiplyPoint3dArrayInPlace(corners);
            for (const corner of corners) {
                const delta = geometry_core_1.Vector3d.createStartEnd(origin, corner);
                const projection = delta.dotProduct(zVec);
                if (undefined === shape.zLow && (undefined === zLow || projection < zLow))
                    zLow = projection;
                if (undefined === shape.zHigh && (undefined === zHigh || projection > zHigh))
                    zHigh = projection;
            }
        }
        return geometry_core_1.Range1d.createXX(zLow, zHigh);
    }
    static isSingleClipShape(clip) {
        if (1 !== clip.clips.length)
            return undefined;
        const prim = clip.clips[0];
        if (!(prim instanceof geometry_core_1.ClipShape))
            return undefined;
        if (!prim.isValidPolygon)
            return undefined;
        return prim;
    }
    static drawClipPlanesLoops(context, loops, color, weight, dashed, fill, id) {
        if (loops.length < 1)
            return;
        const builderEdge = context.createGraphicBuilder(rendering_1.GraphicType.WorldDecoration, undefined, id); // Use WorldDecoration not WorldOverlay to make sure handles have priority...
        builderEdge.setSymbology(color, imodeljs_common_1.ColorDef.black, weight, dashed ? imodeljs_common_1.LinePixels.Code2 : undefined);
        for (const geom of loops) {
            if (!(geom instanceof geometry_core_1.Loop))
                continue;
            builderEdge.addPath(geometry_core_1.Path.createArray(geom.children));
        }
        context.addDecorationFromBuilder(builderEdge);
        if (undefined === fill)
            return;
        const builderFace = context.createGraphicBuilder(rendering_1.GraphicType.WorldDecoration, undefined);
        builderFace.setSymbology(fill, fill, 0);
        for (const geom of loops) {
            if (!(geom instanceof geometry_core_1.Loop))
                continue;
            builderFace.addLoop(geom);
        }
        context.addDecorationFromBuilder(builderFace);
    }
    static isSingleConvexClipPlaneSet(clip) {
        if (1 !== clip.clips.length)
            return undefined;
        const prim = clip.clips[0];
        if (prim instanceof geometry_core_1.ClipShape)
            return undefined;
        const planeSets = prim.fetchClipPlanesRef();
        return (undefined !== planeSets && 1 === planeSets.convexSets.length) ? planeSets.convexSets[0] : undefined;
    }
    static isSingleClipPlane(clip) {
        const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);
        if (undefined === clipPlanes || 1 !== clipPlanes.planes.length)
            return undefined;
        return clipPlanes.planes[0];
    }
    static areClipsEqual(clipA, clipB) {
        if (clipA === clipB)
            return true;
        if (clipA.clips.length !== clipB.clips.length)
            return false;
        for (let iPrim = 0; iPrim < clipA.clips.length; iPrim++) {
            const primA = clipA.clips[iPrim];
            const primB = clipB.clips[iPrim];
            const planesA = primA.fetchClipPlanesRef();
            const planesB = primB.fetchClipPlanesRef();
            if (undefined !== planesA && undefined !== planesB) {
                if (planesA.convexSets.length !== planesB.convexSets.length)
                    return false;
                for (let iPlane = 0; iPlane < planesA.convexSets.length; iPlane++) {
                    const planeSetA = planesA.convexSets[iPlane];
                    const planeSetB = planesB.convexSets[iPlane];
                    if (planeSetA.planes.length !== planeSetB.planes.length)
                        return false;
                    for (let iClipPlane = 0; iClipPlane < planeSetA.planes.length; iClipPlane++) {
                        const planeA = planeSetA.planes[iClipPlane];
                        const planeB = planeSetB.planes[iClipPlane];
                        if (!planeA.isAlmostEqual(planeB))
                            return false;
                    }
                }
            }
            else if (undefined === planesA && undefined === planesB) {
                continue;
            }
            else {
                return false;
            }
        }
        return true;
    }
    static hasClip(viewport) {
        return (undefined !== viewport.view.getViewClip());
    }
}
ViewClipTool._orientationName = "enumAsOrientation";
ViewClipTool._getEnumAsOrientationDescription = () => {
    return {
        name: ViewClipTool._orientationName,
        displayLabel: IModelApp_1.IModelApp.i18n.translate("CoreTools:tools.ViewClip.Settings.Orientation.Label"),
        typename: "enum",
        enum: {
            choices: [
                { label: ViewClipTool.enumAsOrientationMessage("Top"), value: ClipOrientation.Top },
                { label: ViewClipTool.enumAsOrientationMessage("Front"), value: ClipOrientation.Front },
                { label: ViewClipTool.enumAsOrientationMessage("Left"), value: ClipOrientation.Left },
                { label: ViewClipTool.enumAsOrientationMessage("Bottom"), value: ClipOrientation.Bottom },
                { label: ViewClipTool.enumAsOrientationMessage("Back"), value: ClipOrientation.Back },
                { label: ViewClipTool.enumAsOrientationMessage("Right"), value: ClipOrientation.Right },
                { label: ViewClipTool.enumAsOrientationMessage("View"), value: ClipOrientation.View },
                { label: ViewClipTool.enumAsOrientationMessage("Face"), value: ClipOrientation.Face },
            ],
        },
    };
};
exports.ViewClipTool = ViewClipTool;
/** @alpha A tool to remove a clip volume for a view */
class ViewClipClearTool extends ViewClipTool {
    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && ViewClipTool.hasClip(vp)); }
    showPrompt() { this.outputPrompt("Clear.Prompts.FirstPoint"); }
    doClipClear(viewport) {
        if (!ViewClipTool.doClipClear(viewport))
            return false;
        if (undefined !== this._clipEventHandler)
            this._clipEventHandler.onClearClip(viewport);
        this.onReinitialize();
        return true;
    }
    onPostInstall() {
        super.onPostInstall();
        if (undefined !== this.targetView)
            this.doClipClear(this.targetView);
    }
    async onDataButtonDown(_ev) {
        if (undefined === this.targetView)
            return Tool_1.EventHandled.No;
        return this.doClipClear(this.targetView) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
}
ViewClipClearTool.toolId = "ViewClip.Clear";
exports.ViewClipClearTool = ViewClipClearTool;
/** @alpha A tool to define a clip volume for a view by specifying a plane */
class ViewClipByPlaneTool extends ViewClipTool {
    constructor(clipEventHandler, _clearExistingPlanes = false) {
        super(clipEventHandler);
        this._clearExistingPlanes = _clearExistingPlanes;
        this._orientationValue = new ToolSettingsValue_1.ToolSettingsValue(ClipOrientation.Face);
    }
    get orientation() { return this._orientationValue.value; }
    set orientation(option) { this._orientationValue.value = option; }
    supplyToolSettingsProperties() {
        IModelApp_1.IModelApp.toolAdmin.toolSettingsState.initializeToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });
        const toolSettings = new Array();
        toolSettings.push(new ToolSettingsValue_1.ToolSettingsPropertyRecord(this._orientationValue.clone(), ViewClipTool._getEnumAsOrientationDescription(), { rowPriority: 0, columnIndex: 2 }));
        return toolSettings;
    }
    applyToolSettingPropertyChange(updatedValue) {
        if (updatedValue.propertyName === ViewClipTool._orientationName) {
            if (this._orientationValue.update(updatedValue.value)) {
                IModelApp_1.IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });
                return true;
            }
        }
        return false;
    }
    showPrompt() { this.outputPrompt("ByPlane.Prompts.FirstPoint"); }
    setupAndPromptForNextAction() {
        super.setupAndPromptForNextAction();
        IModelApp_1.IModelApp.accuSnap.enableSnap(true);
    }
    async onDataButtonDown(ev) {
        if (undefined === this.targetView)
            return Tool_1.EventHandled.No;
        const normal = ViewClipTool.getPlaneInwardNormal(this.orientation, this.targetView);
        if (undefined === normal)
            return Tool_1.EventHandled.No;
        ViewClipTool.enableClipVolume(this.targetView);
        if (!ViewClipTool.doClipToPlane(this.targetView, ev.point, normal, this._clearExistingPlanes))
            return Tool_1.EventHandled.No;
        if (undefined !== this._clipEventHandler)
            this._clipEventHandler.onNewClipPlane(this.targetView);
        this.onReinitialize();
        return Tool_1.EventHandled.Yes;
    }
}
ViewClipByPlaneTool.toolId = "ViewClip.ByPlane";
exports.ViewClipByPlaneTool = ViewClipByPlaneTool;
/** @alpha A tool to define a clip volume for a view by specifying a shape */
class ViewClipByShapeTool extends ViewClipTool {
    constructor() {
        super(...arguments);
        this._orientationValue = new ToolSettingsValue_1.ToolSettingsValue(ClipOrientation.Top);
        this._points = [];
    }
    get orientation() { return this._orientationValue.value; }
    set orientation(option) { this._orientationValue.value = option; }
    supplyToolSettingsProperties() {
        IModelApp_1.IModelApp.toolAdmin.toolSettingsState.initializeToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });
        const toolSettings = new Array();
        toolSettings.push(new ToolSettingsValue_1.ToolSettingsPropertyRecord(this._orientationValue.clone(), ViewClipTool._getEnumAsOrientationDescription(), { rowPriority: 0, columnIndex: 2 }));
        return toolSettings;
    }
    applyToolSettingPropertyChange(updatedValue) {
        if (updatedValue.propertyName === ViewClipTool._orientationName) {
            if (!this._orientationValue.update(updatedValue.value))
                return false;
            this._points.length = 0;
            this._matrix = undefined;
            AccuDraw_1.AccuDrawHintBuilder.deactivate();
            this.setupAndPromptForNextAction();
            IModelApp_1.IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });
            return true;
        }
        return false;
    }
    showPrompt() {
        switch (this._points.length) {
            case 0:
                this.outputPrompt("ByShape.Prompts.FirstPoint");
                break;
            case 1:
                this.outputPrompt("ByShape.Prompts.SecondPoint");
                break;
            case 2:
                this.outputPrompt("ByShape.Prompts.ThirdPoint");
                break;
            default:
                this.outputPrompt("ByShape.Prompts.NextPoint");
                break;
        }
    }
    setupAndPromptForNextAction() {
        super.setupAndPromptForNextAction();
        IModelApp_1.IModelApp.accuSnap.enableSnap(true);
        if (0 === this._points.length)
            return;
        const hints = new AccuDraw_1.AccuDrawHintBuilder();
        hints.setOrigin(this._points[this._points.length - 1]);
        if (1 === this._points.length) {
            hints.setRotation(this._matrix.inverse());
            hints.setModeRectangular();
        }
        hints.setLockZ = true;
        hints.sendHints();
    }
    getClipPoints(ev) {
        const points = [];
        if (undefined === this.targetView || this._points.length < 1)
            return points;
        for (const pt of this._points)
            points.push(pt.clone());
        const normal = this._matrix.getColumn(2);
        let currentPt = EditManipulator_1.EditManipulator.HandleUtils.projectPointToPlaneInView(ev.point, points[0], normal, ev.viewport, true);
        if (undefined === currentPt)
            currentPt = ev.point.clone();
        if (2 === points.length && !ev.isControlKey) {
            const xDir = geometry_core_1.Vector3d.createStartEnd(points[0], points[1]);
            const xLen = xDir.magnitude();
            xDir.normalizeInPlace();
            const yDir = xDir.crossProduct(normal);
            yDir.normalizeInPlace();
            const cornerPt = EditManipulator_1.EditManipulator.HandleUtils.projectPointToLineInView(currentPt, points[1], yDir, ev.viewport, true);
            if (undefined !== cornerPt) {
                points.push(cornerPt);
                cornerPt.plusScaled(xDir, -xLen, currentPt);
            }
        }
        points.push(currentPt);
        if (points.length > 2)
            points.push(points[0].clone());
        return points;
    }
    isValidLocation(ev, isButtonEvent) {
        return (this._points.length > 0 ? true : super.isValidLocation(ev, isButtonEvent));
    }
    decorate(context) {
        if (context.viewport !== this.targetView)
            return;
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        const points = this.getClipPoints(ev);
        if (points.length < 2)
            return;
        const builderAccVis = context.createGraphicBuilder(rendering_1.GraphicType.WorldDecoration);
        const builderAccHid = context.createGraphicBuilder(rendering_1.GraphicType.WorldOverlay);
        const colorAccVis = imodeljs_common_1.ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);
        const colorAccHid = colorAccVis.clone();
        colorAccHid.setAlpha(100);
        const fillAccVis = context.viewport.hilite.color.clone();
        fillAccVis.setAlpha(25);
        builderAccVis.setSymbology(colorAccVis, fillAccVis, 3);
        builderAccHid.setSymbology(colorAccHid, fillAccVis, 1);
        if (points.length > 2)
            builderAccHid.addShape(points);
        builderAccVis.addLineString(points);
        builderAccHid.addLineString(points);
        context.addDecorationFromBuilder(builderAccVis);
        context.addDecorationFromBuilder(builderAccHid);
    }
    decorateSuspended(context) { this.decorate(context); }
    async onMouseMotion(ev) { if (this._points.length > 0 && undefined !== ev.viewport)
        ev.viewport.invalidateDecorations(); }
    async onDataButtonDown(ev) {
        if (undefined === this.targetView)
            return Tool_1.EventHandled.No;
        if (this._points.length > 1 && !ev.isControlKey) {
            const points = this.getClipPoints(ev);
            if (points.length < 3)
                return Tool_1.EventHandled.No;
            const transform = geometry_core_1.Transform.createOriginAndMatrix(points[0], this._matrix);
            transform.multiplyInversePoint3dArrayInPlace(points);
            ViewClipTool.enableClipVolume(this.targetView);
            if (!ViewClipTool.doClipToShape(this.targetView, points, transform, this._zLow, this._zHigh))
                return Tool_1.EventHandled.No;
            if (undefined !== this._clipEventHandler)
                this._clipEventHandler.onNewClip(this.targetView);
            this.onReinitialize();
            return Tool_1.EventHandled.Yes;
        }
        if (undefined === this._matrix && undefined === (this._matrix = ViewClipTool.getClipOrientation(this.orientation, this.targetView)))
            return Tool_1.EventHandled.No;
        const currPt = ev.point.clone();
        if (this._points.length > 0) {
            const planePt = EditManipulator_1.EditManipulator.HandleUtils.projectPointToPlaneInView(currPt, this._points[0], this._matrix.getColumn(2), ev.viewport, true);
            if (undefined !== planePt)
                currPt.setFrom(planePt);
        }
        this._points.push(currPt);
        this.setupAndPromptForNextAction();
        return Tool_1.EventHandled.No;
    }
    async onUndoPreviousStep() {
        if (0 === this._points.length)
            return false;
        this._points.pop();
        if (0 === this._points.length)
            this.onReinitialize();
        else
            this.setupAndPromptForNextAction();
        return true;
    }
    async onKeyTransition(wentDown, keyEvent) {
        if (Tool_1.EventHandled.Yes === await super.onKeyTransition(wentDown, keyEvent))
            return Tool_1.EventHandled.Yes;
        return (wentDown && AccuDrawTool_1.AccuDrawShortcuts.processShortcutKey(keyEvent)) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
}
ViewClipByShapeTool.toolId = "ViewClip.ByShape";
exports.ViewClipByShapeTool = ViewClipByShapeTool;
/** @alpha A tool to define a clip volume for a view by specifying range corners */
class ViewClipByRangeTool extends ViewClipTool {
    showPrompt() { this.outputPrompt(undefined === this._corner ? "ByRange.Prompts.FirstPoint" : "ByRange.Prompts.NextPoint"); }
    setupAndPromptForNextAction() {
        super.setupAndPromptForNextAction();
        IModelApp_1.IModelApp.accuSnap.enableSnap(true);
    }
    getClipRange(range, transform, ev) {
        if (undefined === this.targetView || undefined === this._corner)
            return false;
        // Creating clip aligned with ACS when ACS context lock is enabled...
        const matrix = ViewClipTool.getClipOrientation(ClipOrientation.Top, this.targetView);
        geometry_core_1.Transform.createOriginAndMatrix(this._corner, matrix, transform);
        const pt1 = transform.multiplyInversePoint3d(this._corner);
        const pt2 = transform.multiplyInversePoint3d(ev.point);
        if (undefined === pt1 || undefined === pt2)
            return false;
        range.setFrom(geometry_core_1.Range3d.create(pt1, pt2));
        return true;
    }
    decorate(context) {
        if (context.viewport !== this.targetView || undefined === this._corner)
            return;
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        const range = geometry_core_1.Range3d.create();
        const transform = geometry_core_1.Transform.createIdentity();
        if (!this.getClipRange(range, transform, ev))
            return;
        const builderAccVis = context.createGraphicBuilder(rendering_1.GraphicType.WorldDecoration, transform);
        const builderAccHid = context.createGraphicBuilder(rendering_1.GraphicType.WorldOverlay, transform);
        const colorAccVis = imodeljs_common_1.ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);
        const colorAccHid = colorAccVis.clone();
        colorAccHid.setAlpha(100);
        builderAccVis.setSymbology(colorAccVis, imodeljs_common_1.ColorDef.black, 3);
        builderAccHid.setSymbology(colorAccHid, imodeljs_common_1.ColorDef.black, 1);
        builderAccVis.addRangeBox(range);
        builderAccHid.addRangeBox(range);
        context.addDecorationFromBuilder(builderAccVis);
        context.addDecorationFromBuilder(builderAccHid);
    }
    decorateSuspended(context) { this.decorate(context); }
    async onMouseMotion(ev) { if (undefined !== this._corner && undefined !== ev.viewport)
        ev.viewport.invalidateDecorations(); }
    async onDataButtonDown(ev) {
        if (undefined === this.targetView)
            return Tool_1.EventHandled.No;
        if (undefined !== this._corner) {
            const range = geometry_core_1.Range3d.create();
            const transform = geometry_core_1.Transform.createIdentity();
            if (!this.getClipRange(range, transform, ev))
                return Tool_1.EventHandled.No;
            ViewClipTool.enableClipVolume(this.targetView);
            if (!ViewClipTool.doClipToRange(this.targetView, range, transform))
                return Tool_1.EventHandled.No;
            if (undefined !== this._clipEventHandler)
                this._clipEventHandler.onNewClip(this.targetView);
            this.onReinitialize();
            return Tool_1.EventHandled.Yes;
        }
        this._corner = ev.point.clone();
        this.setupAndPromptForNextAction();
        return Tool_1.EventHandled.No;
    }
    async onUndoPreviousStep() {
        if (undefined === this._corner)
            return false;
        this.onReinitialize();
        return true;
    }
}
ViewClipByRangeTool.toolId = "ViewClip.ByRange";
exports.ViewClipByRangeTool = ViewClipByRangeTool;
/** @alpha A tool to define a clip volume for a view by element(s) */
class ViewClipByElementTool extends ViewClipTool {
    constructor(clipEventHandler, _alwaysUseRange = false) {
        super(clipEventHandler);
        this._alwaysUseRange = _alwaysUseRange;
    }
    showPrompt() { this.outputPrompt("ByElement.Prompts.FirstPoint"); }
    onPostInstall() {
        super.onPostInstall();
        if (undefined !== this.targetView && this.targetView.iModel.selectionSet.isActive) {
            let useSelection = true;
            this.targetView.iModel.selectionSet.elements.forEach((val) => { if (bentleyjs_core_1.Id64.isInvalid(val) || bentleyjs_core_1.Id64.isTransient(val))
                useSelection = false; });
            if (useSelection) {
                this.doClipToSelectedElements(this.targetView); // tslint:disable-line:no-floating-promises
                return;
            }
        }
        this.initLocateElements(true, false, "default", Tool_1.CoordinateLockOverrides.All);
    }
    async doClipToSelectedElements(viewport) {
        if (await this.doClipToElements(viewport, viewport.iModel.selectionSet.elements, this._alwaysUseRange))
            return true;
        this.exitTool();
        return false;
    }
    async doClipToElements(viewport, ids, alwaysUseRange = false) {
        try {
            const elementProps = await viewport.iModel.elements.getProps(ids);
            if (0 === elementProps.length)
                return false;
            const range = new geometry_core_1.Range3d();
            const transform = geometry_core_1.Transform.createIdentity();
            for (const props of elementProps) {
                if (undefined === props.placement)
                    continue;
                const hasAngle = (arg) => arg.angle !== undefined;
                const placement = hasAngle(props.placement) ? imodeljs_common_1.Placement2d.fromJSON(props.placement) : imodeljs_common_1.Placement3d.fromJSON(props.placement);
                if (!alwaysUseRange && 1 === elementProps.length) {
                    range.setFrom(placement instanceof imodeljs_common_1.Placement2d ? geometry_core_1.Range3d.createRange2d(placement.bbox, 0) : placement.bbox);
                    transform.setFrom(placement.transform); // Use ElementAlignedBox for single selection...
                }
                else {
                    range.extendRange(placement.calculateRange());
                }
            }
            ViewClipTool.enableClipVolume(viewport);
            if (!ViewClipTool.doClipToRange(viewport, range, transform))
                return false;
            if (undefined !== this._clipEventHandler)
                this._clipEventHandler.onNewClip(viewport);
            this.onReinitialize();
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    async onDataButtonDown(ev) {
        if (undefined === this.targetView)
            return Tool_1.EventHandled.No;
        const hit = await IModelApp_1.IModelApp.locateManager.doLocate(new ElementLocateManager_1.LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);
        if (undefined === hit || !hit.isElementHit)
            return Tool_1.EventHandled.No;
        return await this.doClipToElements(this.targetView, hit.sourceId, this._alwaysUseRange) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
}
ViewClipByElementTool.toolId = "ViewClip.ByElement";
exports.ViewClipByElementTool = ViewClipByElementTool;
/** @alpha Interactive tool base class to modify a view's clip */
class ViewClipModifyTool extends EditManipulator_1.EditManipulator.HandleTool {
    constructor(manipulator, clip, vp, hitId, ids, controls) {
        super(manipulator);
        this._restoreClip = true;
        this._currentDistance = 0.0;
        this._anchorIndex = ids.indexOf(hitId);
        this._ids = ids;
        this._controls = controls;
        this._clipView = vp;
        this._clip = clip;
        this._viewRange = vp.computeViewRange();
    }
    init() {
        this.receivedDownEvent = true;
        this.initLocateElements(false, false, undefined, Tool_1.CoordinateLockOverrides.All); // Disable locate/snap/locks for control modification; overrides state inherited from suspended primitive...
        AccuDraw_1.AccuDrawHintBuilder.deactivate();
    }
    getOffsetValue(ev, transformFromClip) {
        if (-1 === this._anchorIndex || undefined === ev.viewport || ev.viewport !== this._clipView)
            return undefined;
        // NOTE: Use AccuDraw z instead of view z if AccuDraw is explicitly enabled...
        const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[this._anchorIndex].origin, this._controls[this._anchorIndex].direction, transformFromClip);
        const projectedPt = EditManipulator_1.EditManipulator.HandleUtils.projectPointToLineInView(ev.point, anchorRay.origin, anchorRay.direction, ev.viewport, true);
        if (undefined === projectedPt)
            return undefined;
        const offsetVec = geometry_core_1.Vector3d.createStartEnd(anchorRay.origin, projectedPt);
        let offset = offsetVec.normalizeWithLength(offsetVec).mag;
        if (offset < geometry_core_1.Geometry.smallMetricDistance)
            return undefined;
        if (offsetVec.dotProduct(anchorRay.direction) < 0.0)
            offset *= -1.0;
        this._currentDistance = offset;
        return offset;
    }
    drawAnchorOffset(context, color, weight, transformFromClip) {
        if (-1 === this._anchorIndex || Math.abs(this._currentDistance) < geometry_core_1.Geometry.smallMetricDistance)
            return;
        const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[this._anchorIndex].origin, this._controls[this._anchorIndex].direction, transformFromClip);
        anchorRay.direction.scaleToLength(this._currentDistance, anchorRay.direction);
        const pt1 = anchorRay.fractionToPoint(0.0);
        const pt2 = anchorRay.fractionToPoint(1.0);
        const builder = context.createGraphicBuilder(rendering_1.GraphicType.ViewOverlay);
        context.viewport.worldToView(pt1, pt1);
        pt1.z = 0.0;
        context.viewport.worldToView(pt2, pt2);
        pt2.z = 0.0;
        builder.setSymbology(color, imodeljs_common_1.ColorDef.black, weight, imodeljs_common_1.LinePixels.Code5);
        builder.addLineString([pt1, pt2]);
        builder.setSymbology(color, imodeljs_common_1.ColorDef.black, weight + 7);
        builder.addPointString([pt1, pt2]);
        context.addDecorationFromBuilder(builder);
    }
    decorate(context) {
        if (-1 === this._anchorIndex || context.viewport !== this._clipView)
            return;
        this.drawViewClip(context);
    }
    async onMouseMotion(ev) {
        if (!this.updateViewClip(ev, false))
            return;
        this._clipView.invalidateDecorations();
    }
    accept(ev) {
        if (!this.updateViewClip(ev, true))
            return false;
        this._restoreClip = false;
        return true;
    }
    onCleanup() {
        if (this._restoreClip && ViewClipTool.hasClip(this._clipView))
            ViewClipTool.setViewClip(this._clipView, this._clip);
    }
}
exports.ViewClipModifyTool = ViewClipModifyTool;
/** @alpha Interactive tool to modify a view's clip defined by a ClipShape */
class ViewClipShapeModifyTool extends ViewClipModifyTool {
    updateViewClip(ev, _isAccept) {
        const clipShape = ViewClipTool.isSingleClipShape(this._clip);
        if (undefined === clipShape)
            return false;
        const offset = this.getOffsetValue(ev, clipShape.transformFromClip);
        if (undefined === offset)
            return false;
        const offsetAll = ev.isShiftKey;
        const localOffset = ViewClipTool.getOffsetValueTransformed(offset, clipShape.transformToClip);
        const shapePts = ViewClipTool.getClipShapePoints(clipShape, 0.0);
        const adjustedPts = [];
        for (let i = 0; i < shapePts.length; i++) {
            const prevFace = (0 === i ? shapePts.length - 2 : i - 1);
            const nextFace = (shapePts.length - 1 === i ? 0 : i);
            const prevSelected = offsetAll || (prevFace === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[prevFace]));
            const nextSelected = offsetAll || (nextFace === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[nextFace]));
            if (prevSelected && nextSelected) {
                const prevPt = shapePts[i].plusScaled(this._controls[prevFace].direction, localOffset);
                const nextPt = shapePts[i].plusScaled(this._controls[nextFace].direction, localOffset);
                const prevRay = geometry_core_1.Ray3d.create(prevPt, geometry_core_1.Vector3d.createStartEnd(shapePts[i === 0 ? shapePts.length - 2 : i - 1], shapePts[i]));
                const nextPlane = geometry_core_1.Plane3dByOriginAndUnitNormal.create(nextPt, this._controls[nextFace].direction);
                if (undefined === nextPlane || undefined === prevRay.intersectionWithPlane(nextPlane, prevPt))
                    return false;
                adjustedPts[i] = prevPt;
            }
            else if (prevSelected) {
                adjustedPts[i] = shapePts[i].plusScaled(this._controls[prevFace].direction, localOffset);
            }
            else if (nextSelected) {
                adjustedPts[i] = shapePts[i].plusScaled(this._controls[nextFace].direction, localOffset);
            }
            else {
                adjustedPts[i] = shapePts[i];
            }
        }
        let zLow = clipShape.zLow;
        let zHigh = clipShape.zHigh;
        const zLowIndex = this._controls.length - 2;
        const zHighIndex = this._controls.length - 1;
        const zLowSelected = offsetAll || (zLowIndex === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[zLowIndex]));
        const zHighSelected = offsetAll || (zHighIndex === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[zHighIndex]));
        if (zLowSelected || zHighSelected) {
            const clipExtents = ViewClipTool.getClipShapeExtents(clipShape, this._viewRange);
            if (zLowSelected)
                zLow = clipExtents.low - localOffset;
            if (zHighSelected)
                zHigh = clipExtents.high + localOffset;
            const realZLow = (undefined === zLow ? clipExtents.low : zLow);
            const realZHigh = (undefined === zHigh ? clipExtents.high : zHigh);
            if (realZLow > realZHigh) {
                zLow = realZHigh;
                zHigh = realZLow;
            }
        }
        return ViewClipTool.doClipToShape(this._clipView, adjustedPts, clipShape.transformFromClip, zLow, zHigh);
    }
    drawViewClip(context) {
        const clip = this._clipView.view.getViewClip();
        if (undefined === clip)
            return;
        const clipShape = ViewClipTool.isSingleClipShape(clip);
        if (undefined === clipShape)
            return;
        const clipExtents = ViewClipTool.getClipShapeExtents(clipShape, this._viewRange);
        const color = imodeljs_common_1.ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);
        ViewClipTool.drawClipShape(context, clipShape, clipExtents, color, 1);
        this.drawAnchorOffset(context, color, 1, clipShape.transformFromClip);
    }
}
exports.ViewClipShapeModifyTool = ViewClipShapeModifyTool;
/** @alpha Interactive tool to modify a view's clip defined by a ConvexClipPlaneSet */
class ViewClipPlanesModifyTool extends ViewClipModifyTool {
    updateViewClip(ev, _isAccept) {
        const offset = this.getOffsetValue(ev);
        if (undefined === offset)
            return false;
        const offsetAll = ev.isShiftKey;
        const planeSet = geometry_core_1.ConvexClipPlaneSet.createEmpty();
        for (let i = 0; i < this._controls.length; i++) {
            const selected = offsetAll || (i === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[i]));
            const origin = this._controls[i].origin.clone();
            const direction = this._controls[i].direction;
            if (selected)
                origin.plusScaled(direction, offset, origin);
            planeSet.addPlaneToConvexSet(geometry_core_1.ClipPlane.createNormalAndPoint(direction.negate(), origin));
        }
        return ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet);
    }
    drawViewClip(context) {
        const clip = this._clipView.view.getViewClip();
        if (undefined === clip)
            return;
        const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);
        if (undefined === clipPlanes)
            return;
        const clipPlanesLoops = geometry_core_1.ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(clipPlanes, this._viewRange, true, false, true);
        if (undefined === clipPlanesLoops)
            return;
        const color = imodeljs_common_1.ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);
        ViewClipTool.drawClipPlanesLoops(context, clipPlanesLoops, color, 1);
        this.drawAnchorOffset(context, color, 1);
    }
}
exports.ViewClipPlanesModifyTool = ViewClipPlanesModifyTool;
/** @alpha Modify handle data to modify a view's clip */
class ViewClipControlArrow {
    constructor(origin, direction, sizeInches, fill, outline, name) {
        this.origin = origin;
        this.direction = direction;
        this.sizeInches = sizeInches;
        this.fill = fill;
        this.outline = outline;
        this.name = name;
    }
}
exports.ViewClipControlArrow = ViewClipControlArrow;
/** @alpha Controls to modify a view's clip */
class ViewClipDecoration extends EditManipulator_1.EditManipulator.HandleProvider {
    constructor(_clipView, _clipEventHandler) {
        super(_clipView.iModel);
        this._clipView = _clipView;
        this._clipEventHandler = _clipEventHandler;
        this._controlIds = [];
        this._controls = [];
        this._suspendDecorator = false;
        if (!this.getClipData())
            return;
        this._clipId = this.iModel.transientIds.next;
        this.updateDecorationListener(true);
        this._removeViewCloseListener = IModelApp_1.IModelApp.viewManager.onViewClose.addListener(this.onViewClose, this);
        if (undefined !== this._clipEventHandler && this._clipEventHandler.selectOnCreate())
            this.iModel.selectionSet.replace(this._clipId);
    }
    get clipId() { return this._clipId; }
    get clipShape() { return this._clipShape; }
    get clipPlaneSet() { return this._clipPlanes; }
    getControlIndex(id) { return this._controlIds.indexOf(id); }
    stop() {
        const selectedId = (undefined !== this._clipId && this.iModel.selectionSet.has(this._clipId)) ? this._clipId : undefined;
        this._clipId = undefined; // Invalidate id so that decorator will be dropped...
        super.stop();
        if (undefined !== selectedId)
            this.iModel.selectionSet.remove(selectedId); // Don't leave decorator id in selection set...
        if (undefined !== this._removeViewCloseListener) {
            this._removeViewCloseListener();
            this._removeViewCloseListener = undefined;
        }
    }
    onViewClose(vp) {
        if (this._clipView === vp)
            ViewClipDecoration.clear();
    }
    getClipData() {
        this._clip = this._clipShape = this._clipShapeExtents = this._clipPlanes = this._clipPlanesLoops = this._clipPlanesLoopsNoncontributing = undefined;
        const clip = this._clipView.view.getViewClip();
        if (undefined === clip)
            return false;
        const clipShape = ViewClipTool.isSingleClipShape(clip);
        if (undefined !== clipShape) {
            this._clipShapeExtents = ViewClipTool.getClipShapeExtents(clipShape, this._clipView.computeViewRange());
            this._clipShape = clipShape;
        }
        else {
            const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);
            if (undefined === clipPlanes || clipPlanes.planes.length > 12)
                return false;
            const clipPlanesLoops = geometry_core_1.ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(clipPlanes, this._clipView.computeViewRange(), true, false, true);
            if (undefined !== clipPlanesLoops && clipPlanesLoops.length > clipPlanes.planes.length)
                return false;
            this._clipPlanesLoops = clipPlanesLoops;
            this._clipPlanes = clipPlanes;
        }
        this._clip = clip;
        return true;
    }
    ensureNumControls(numReqControls) {
        const numCurrent = this._controlIds.length;
        if (numCurrent < numReqControls) {
            const transientIds = this.iModel.transientIds;
            for (let i = numCurrent; i < numReqControls; i++)
                this._controlIds[i] = transientIds.next;
        }
        else if (numCurrent > numReqControls) {
            this._controlIds.length = numReqControls;
        }
    }
    createClipShapeControls() {
        if (undefined === this._clipShape)
            return false;
        const shapePtsLo = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.low);
        const shapePtsHi = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents.high);
        const shapeArea = geometry_core_1.PolygonOps.centroidAreaNormal(shapePtsLo);
        if (undefined === shapeArea)
            return false;
        const numControls = shapePtsLo.length + 1; // Number of edge midpoints plus zLow and zHigh...
        this.ensureNumControls(numControls);
        for (let i = 0; i < numControls - 2; i++) {
            const midPtLo = shapePtsLo[i].interpolate(0.5, shapePtsLo[i + 1]);
            const midPtHi = shapePtsHi[i].interpolate(0.5, shapePtsHi[i + 1]);
            const faceCenter = midPtLo.interpolate(0.5, midPtHi);
            const edgeTangent = geometry_core_1.Vector3d.createStartEnd(shapePtsLo[i], shapePtsLo[i + 1]);
            const faceNormal = edgeTangent.crossProduct(shapeArea.direction);
            faceNormal.normalizeInPlace();
            this._controls[i] = new ViewClipControlArrow(faceCenter, faceNormal, shapePtsLo.length > 5 ? 0.5 : 0.75);
        }
        const zFillColor = imodeljs_common_1.ColorDef.from(150, 150, 250);
        this._controls[numControls - 2] = new ViewClipControlArrow(shapeArea.origin, geometry_core_1.Vector3d.unitZ(-1.0), 0.75, zFillColor, undefined, "zLow");
        this._controls[numControls - 1] = new ViewClipControlArrow(shapeArea.origin.plusScaled(geometry_core_1.Vector3d.unitZ(), shapePtsLo[0].distance(shapePtsHi[0])), geometry_core_1.Vector3d.unitZ(), 0.75, zFillColor, undefined, "zHigh");
        return true;
    }
    getLoopCentroidAreaNormal(geom) {
        if (!(geom instanceof geometry_core_1.Loop) || geom.children.length > 1)
            return undefined;
        const child = geom.getChild(0);
        if (!(child instanceof geometry_core_1.LineString3d))
            return undefined;
        return geometry_core_1.PolygonOps.centroidAreaNormal(child.points);
    }
    createClipPlanesControls() {
        if (undefined === this._clipPlanes)
            return false;
        const loopData = [];
        if (undefined !== this._clipPlanesLoops) {
            for (const geom of this._clipPlanesLoops) {
                const loopArea = this.getLoopCentroidAreaNormal(geom);
                if (undefined !== loopArea)
                    loopData.push(loopArea);
            }
        }
        const numControls = this._clipPlanes.planes.length;
        this.ensureNumControls(numControls);
        let viewRange;
        let iLoop = 0;
        for (let i = 0; i < this._clipPlanes.planes.length; i++) {
            const plane = this._clipPlanes.planes[i].getPlane3d();
            if (iLoop < loopData.length) {
                if (Math.abs(loopData[iLoop].direction.dotProduct(plane.getNormalRef())) > 0.9999 && plane.isPointInPlane(loopData[iLoop].origin)) {
                    const outwardNormal = loopData[iLoop].direction.negate();
                    this._controls[i] = new ViewClipControlArrow(loopData[iLoop].origin, outwardNormal, 0.75);
                    iLoop++;
                    continue;
                }
            }
            if (undefined === viewRange)
                viewRange = this._clipView.computeViewRange();
            const defaultOrigin = plane.projectPointToPlane(viewRange.center);
            const defaultOutwardNormal = plane.getNormalRef().negate();
            const expandedRange = viewRange.clone();
            expandedRange.extend(defaultOrigin);
            const nonContribLoops = geometry_core_1.ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(geometry_core_1.ConvexClipPlaneSet.createPlanes([this._clipPlanes.planes[i]]), expandedRange, true, false, true);
            const nonContribColor = imodeljs_common_1.ColorDef.from(250, 100, 100);
            if (undefined !== nonContribLoops && nonContribLoops.length > 0) {
                if (undefined === this._clipPlanesLoopsNoncontributing)
                    this._clipPlanesLoopsNoncontributing = nonContribLoops;
                else
                    this._clipPlanesLoopsNoncontributing = this._clipPlanesLoopsNoncontributing.concat(nonContribLoops);
                const loopArea = this.getLoopCentroidAreaNormal(nonContribLoops[0]);
                if (undefined !== loopArea) {
                    const outwardNormal = loopArea.direction.negate();
                    this._controls[i] = new ViewClipControlArrow(loopArea.origin, outwardNormal, 0.5, nonContribColor);
                    continue;
                }
            }
            this._controls[i] = new ViewClipControlArrow(defaultOrigin, defaultOutwardNormal, 0.5, nonContribColor); // Just show arrow for right-click menu options...
        }
        return true;
    }
    async createControls() {
        // Always update to current view clip to handle post-modify, etc.
        if (undefined === this._clipId || !this.getClipData())
            return false;
        // Show controls if only range box and it's controls are selected, selection set doesn't include any other elements...
        let showControls = false;
        if (this.iModel.selectionSet.size <= this._controlIds.length + 1 && this.iModel.selectionSet.has(this._clipId)) {
            showControls = true;
            if (this.iModel.selectionSet.size > 1) {
                this.iModel.selectionSet.elements.forEach((val) => {
                    if (this._clipId !== val && !this._controlIds.includes(val))
                        showControls = false;
                });
            }
        }
        if (!showControls) {
            if (undefined !== this._clipEventHandler && this._clipEventHandler.clearOnDeselect())
                ViewClipDecoration.clear();
            return false;
        }
        if (undefined !== this._clipShape)
            return this.createClipShapeControls();
        else if (undefined !== this._clipPlanes)
            return this.createClipPlanesControls();
        return false;
    }
    clearControls() {
        this.iModel.selectionSet.remove(this._controlIds); // Remove any selected controls as they won't continue to be displayed...
        super.clearControls();
    }
    modifyControls(hit, _ev) {
        if (undefined === this._clip || hit.sourceId === this._clipId)
            return false;
        const saveQualifiers = IModelApp_1.IModelApp.toolAdmin.currentInputState.qualifiers;
        if (undefined !== this._clipShape) {
            const clipShapeModifyTool = new ViewClipShapeModifyTool(this, this._clip, this._clipView, hit.sourceId, this._controlIds, this._controls);
            this._suspendDecorator = clipShapeModifyTool.run();
        }
        else if (undefined !== this._clipPlanes) {
            const clipPlanesModifyTool = new ViewClipPlanesModifyTool(this, this._clip, this._clipView, hit.sourceId, this._controlIds, this._controls);
            this._suspendDecorator = clipPlanesModifyTool.run();
        }
        if (this._suspendDecorator)
            IModelApp_1.IModelApp.toolAdmin.currentInputState.qualifiers = saveQualifiers; // onInstallTool cleared qualifiers, preserve for "modify all" behavior when shift was held and drag started...
        return this._suspendDecorator;
    }
    doClipPlaneNegate(index) {
        if (undefined === this._clipPlanes)
            return false;
        if (index < 0 || index >= this._clipPlanes.planes.length)
            return false;
        const planeSet = geometry_core_1.ConvexClipPlaneSet.createEmpty();
        for (let i = 0; i < this._clipPlanes.planes.length; i++) {
            const plane = (i === index ? this._clipPlanes.planes[i].cloneNegated() : this._clipPlanes.planes[i]);
            planeSet.addPlaneToConvexSet(plane);
        }
        if (!ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet))
            return false;
        this.onManipulatorEvent(EditManipulator_1.EditManipulator.EventType.Accept);
        return true;
    }
    doClipPlaneClear(index) {
        if (undefined === this._clipPlanes)
            return false;
        if (index < 0 || index >= this._clipPlanes.planes.length)
            return false;
        if (1 === this._clipPlanes.planes.length) {
            if (!ViewClipTool.doClipClear(this._clipView))
                return false;
            if (undefined !== this._clipEventHandler)
                this._clipEventHandler.onClearClip(this._clipView);
            ViewClipDecoration.clear();
            return true;
        }
        const planeSet = geometry_core_1.ConvexClipPlaneSet.createEmpty();
        for (let i = 0; i < this._clipPlanes.planes.length; i++) {
            if (i === index)
                continue;
            const plane = this._clipPlanes.planes[i];
            planeSet.addPlaneToConvexSet(plane);
        }
        if (!ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet))
            return false;
        this.onManipulatorEvent(EditManipulator_1.EditManipulator.EventType.Accept);
        return true;
    }
    doClipPlaneOrientView(index) {
        if (index < 0 || index >= this._controlIds.length)
            return false;
        const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[index].origin, this._controls[index].direction, undefined !== this._clipShape ? this._clipShape.transformFromClip : undefined);
        const matrix = geometry_core_1.Matrix3d.createRigidHeadsUp(anchorRay.direction);
        const targetMatrix = matrix.multiplyMatrixMatrix(this._clipView.rotation);
        const rotateTransform = geometry_core_1.Transform.createFixedPointAndMatrix(anchorRay.origin, targetMatrix);
        const startFrustum = this._clipView.getFrustum();
        const newFrustum = startFrustum.clone();
        newFrustum.multiply(rotateTransform);
        this._clipView.animateFrustumChange(startFrustum, newFrustum);
        this._clipView.view.setupFromFrustum(newFrustum);
        this._clipView.synchWithView(true);
        return true;
    }
    getWorldUpPlane(viewport) {
        const matrix = AccuDraw_1.AccuDraw.getStandardRotation(StandardView_1.StandardViewId.Top, viewport, viewport.isContextRotationRequired).inverse();
        if (undefined === matrix)
            return undefined;
        const worldUp = matrix.getColumn(2);
        const planePt = (viewport.isContextRotationRequired ? viewport.getAuxCoordOrigin() : (viewport.view.isSpatialView ? viewport.view.iModel.globalOrigin : geometry_core_1.Point3d.createZero()));
        return geometry_core_1.Plane3dByOriginAndUnitNormal.create(planePt, worldUp);
    }
    isAlignedToWorldUpPlane(plane, transformFromClip) {
        const normal = (undefined !== transformFromClip ? transformFromClip.multiplyVector(geometry_core_1.Vector3d.unitZ()) : geometry_core_1.Vector3d.unitZ());
        return plane.getNormalRef().isParallelTo(normal, true);
    }
    isClipShapeAlignedWithWorldUp(extents) {
        if (undefined === this._clipShape)
            return false;
        const plane = this.getWorldUpPlane(this._clipView);
        if (undefined === plane || !this.isAlignedToWorldUpPlane(plane, this._clipShape.transformFromClip))
            return false;
        if (undefined === extents)
            return true;
        const zLow = geometry_core_1.Point3d.create(0.0, 0.0, this._clipShapeExtents.low);
        const zHigh = geometry_core_1.Point3d.create(0.0, 0.0, this._clipShapeExtents.high);
        if (undefined !== this._clipShape.transformFromClip) {
            this._clipShape.transformFromClip.multiplyPoint3d(zLow, zLow);
            this._clipShape.transformFromClip.multiplyPoint3d(zHigh, zHigh);
        }
        const lowDir = geometry_core_1.Vector3d.createStartEnd(plane.projectPointToPlane(zLow), zLow);
        const highDir = geometry_core_1.Vector3d.createStartEnd(plane.projectPointToPlane(zHigh), zHigh);
        let zLowWorld = lowDir.magnitude();
        let zHighWorld = highDir.magnitude();
        if (lowDir.dotProduct(plane.getNormalRef()) < 0.0)
            zLowWorld = -zLowWorld;
        if (highDir.dotProduct(plane.getNormalRef()) < 0.0)
            zHighWorld = -zHighWorld;
        geometry_core_1.Range1d.createXX(zLowWorld, zHighWorld, extents);
        return true;
    }
    doClipShapeSetZExtents(extents) {
        if (extents.low > extents.high)
            return false;
        if (undefined === this._clipShape)
            return false;
        const plane = this.getWorldUpPlane(this._clipView);
        if (undefined === plane || !this.isAlignedToWorldUpPlane(plane, this._clipShape.transformFromClip))
            return false;
        const zLow = plane.getOriginRef().plusScaled(plane.getNormalRef(), extents.low);
        const zHigh = plane.getOriginRef().plusScaled(plane.getNormalRef(), extents.high);
        if (undefined !== this._clipShape.transformToClip) {
            this._clipShape.transformToClip.multiplyPoint3d(zLow, zLow);
            this._clipShape.transformToClip.multiplyPoint3d(zHigh, zHigh);
        }
        const reversed = (zLow.z > zHigh.z);
        const shape = geometry_core_1.ClipShape.createFrom(this._clipShape);
        shape.initSecondaryProps(shape.isMask, reversed ? zHigh.z : zLow.z, reversed ? zLow.z : zHigh.z, this._clipShape.transformFromClip);
        const clip = geometry_core_1.ClipVector.createEmpty();
        clip.appendReference(shape);
        if (!ViewClipTool.setViewClip(this._clipView, clip))
            return false;
        this.onManipulatorEvent(EditManipulator_1.EditManipulator.EventType.Accept);
        return true;
    }
    async onRightClick(hit, ev) {
        if (undefined === this._clipEventHandler)
            return Tool_1.EventHandled.No;
        return (this._clipEventHandler.onRightClick(hit, ev) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No);
    }
    async onTouchTap(hit, ev) { return (hit.sourceId === this._clipId ? Tool_1.EventHandled.No : super.onTouchTap(hit, ev)); }
    onManipulatorEvent(eventType) {
        this._suspendDecorator = false;
        super.onManipulatorEvent(eventType);
        if (EditManipulator_1.EditManipulator.EventType.Accept === eventType && undefined !== this._clipEventHandler)
            this._clipEventHandler.onModifyClip(this._clipView);
    }
    testDecorationHit(id) { return (id === this._clipId || this._controlIds.includes(id)); }
    async getDecorationToolTip(hit) { return (hit.sourceId === this._clipId ? "View Clip" : "Modify View Clip"); }
    updateDecorationListener(_add) { super.updateDecorationListener(undefined !== this._clipId); } // Decorator isn't just for resize controls...
    decorate(context) {
        if (this._suspendDecorator)
            return;
        if (undefined === this._clipId || undefined === this._clip)
            return;
        const vp = context.viewport;
        if (this._clipView !== vp)
            return;
        if (undefined !== this._clipShape) {
            ViewClipTool.drawClipShape(context, this._clipShape, this._clipShapeExtents, imodeljs_common_1.ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor), 3, this._clipId);
        }
        else if (undefined !== this._clipPlanes) {
            if (undefined !== this._clipPlanesLoops)
                ViewClipTool.drawClipPlanesLoops(context, this._clipPlanesLoops, imodeljs_common_1.ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor), 3, false, imodeljs_common_1.ColorDef.from(0, 255, 255, 225).adjustForContrast(context.viewport.view.backgroundColor), this._clipId);
            if (undefined !== this._clipPlanesLoopsNoncontributing)
                ViewClipTool.drawClipPlanesLoops(context, this._clipPlanesLoopsNoncontributing, imodeljs_common_1.ColorDef.red.adjustForContrast(context.viewport.view.backgroundColor), 1, true);
        }
        if (!this._isActive)
            return;
        const outlineColor = imodeljs_common_1.ColorDef.from(0, 0, 0, 50).adjustForContrast(vp.view.backgroundColor);
        const fillVisColor = imodeljs_common_1.ColorDef.from(150, 250, 200, 225).adjustForContrast(vp.view.backgroundColor);
        const fillHidColor = fillVisColor.clone();
        fillHidColor.setAlpha(200);
        const fillSelColor = fillVisColor.invert();
        fillSelColor.setAlpha(75);
        const shapePts = EditManipulator_1.EditManipulator.HandleUtils.getArrowShape(0.0, 0.15, 0.55, 1.0, 0.3, 0.5, 0.1);
        for (let iFace = 0; iFace < this._controlIds.length; iFace++) {
            const sizeInches = this._controls[iFace].sizeInches;
            if (0.0 === sizeInches)
                continue;
            const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[iFace].origin, this._controls[iFace].direction, undefined !== this._clipShape ? this._clipShape.transformFromClip : undefined);
            const transform = EditManipulator_1.EditManipulator.HandleUtils.getArrowTransform(vp, anchorRay.origin, anchorRay.direction, sizeInches);
            if (undefined === transform)
                continue;
            const visPts = [];
            for (const pt of shapePts)
                visPts.push(pt.clone()); // deep copy because we're using a builder transform w/addLineString...
            const hidPts = [];
            for (const pt of shapePts)
                hidPts.push(pt.clone());
            const arrowVisBuilder = context.createGraphicBuilder(rendering_1.GraphicType.WorldOverlay, transform, this._controlIds[iFace]);
            const arrowHidBuilder = context.createGraphicBuilder(rendering_1.GraphicType.WorldDecoration, transform);
            const isSelected = this.iModel.selectionSet.has(this._controlIds[iFace]);
            let outlineColorOvr = this._controls[iFace].outline;
            if (undefined !== outlineColorOvr) {
                outlineColorOvr = outlineColorOvr.adjustForContrast(vp.view.backgroundColor);
                outlineColorOvr.setAlpha(outlineColor.getAlpha());
            }
            else {
                outlineColorOvr = outlineColor;
            }
            let fillVisColorOvr = this._controls[iFace].fill;
            let fillHidColorOvr = fillHidColor;
            let fillSelColorOvr = fillSelColor;
            if (undefined !== fillVisColorOvr) {
                fillVisColorOvr = fillVisColorOvr.adjustForContrast(vp.view.backgroundColor);
                fillVisColorOvr.setAlpha(fillVisColor.getAlpha());
                fillHidColorOvr = fillVisColorOvr.clone();
                fillHidColorOvr.setAlpha(fillHidColor.getAlpha());
                fillSelColorOvr = fillVisColorOvr.invert();
                fillSelColorOvr.setAlpha(fillSelColor.getAlpha());
            }
            else {
                fillVisColorOvr = fillVisColor;
            }
            arrowVisBuilder.setSymbology(outlineColorOvr, outlineColorOvr, isSelected ? 4 : 2);
            arrowVisBuilder.addLineString(visPts);
            arrowVisBuilder.setBlankingFill(isSelected ? fillSelColorOvr : fillVisColorOvr);
            arrowVisBuilder.addShape(visPts);
            context.addDecorationFromBuilder(arrowVisBuilder);
            arrowHidBuilder.setSymbology(fillHidColorOvr, fillHidColorOvr, 1);
            arrowHidBuilder.addShape(hidPts);
            context.addDecorationFromBuilder(arrowHidBuilder);
        }
    }
    static get(vp) {
        if (undefined === ViewClipDecoration._decorator || vp !== ViewClipDecoration._decorator._clipView)
            return undefined;
        return ViewClipDecoration._decorator;
    }
    static create(vp, clipEventHandler) {
        if (undefined !== ViewClipDecoration._decorator)
            ViewClipDecoration.clear();
        if (!ViewClipTool.hasClip(vp))
            return undefined;
        ViewClipDecoration._decorator = new ViewClipDecoration(vp, clipEventHandler);
        return ViewClipDecoration._decorator.clipId;
    }
    static clear() {
        if (undefined === ViewClipDecoration._decorator)
            return;
        ViewClipDecoration._decorator.stop();
        ViewClipDecoration._decorator = undefined;
    }
    static toggle(vp, clipEventHandler) {
        let clipId;
        if (undefined === ViewClipDecoration._decorator)
            clipId = ViewClipDecoration.create(vp, clipEventHandler);
        else
            ViewClipDecoration.clear();
        IModelApp_1.IModelApp.toolAdmin.startDefaultTool();
        return clipId;
    }
}
exports.ViewClipDecoration = ViewClipDecoration;
/** @alpha */
var ActiveClipStatus;
(function (ActiveClipStatus) {
    ActiveClipStatus[ActiveClipStatus["None"] = 0] = "None";
    ActiveClipStatus[ActiveClipStatus["Unsaved"] = 1] = "Unsaved";
    ActiveClipStatus[ActiveClipStatus["Saved"] = 2] = "Saved";
    ActiveClipStatus[ActiveClipStatus["Modified"] = 3] = "Modified";
})(ActiveClipStatus = exports.ActiveClipStatus || (exports.ActiveClipStatus = {}));
/** @alpha Support for saving clip information as user or project settings */
class ViewClipSettingsProvider {
    constructor(_clipEventHandler) {
        this._clipEventHandler = _clipEventHandler;
        this._activeClips = new Map(); // Map of viewportId to saved clip id...
        this._cachedClips = new Map(); // Map of clip id to clip data + status
        this.namespace = "imodeljs-NamedClipVectors";
        this.appSpecific = false;
    }
    async getRequestContext() { return imodeljs_frontend_1.AuthorizedFrontendRequestContext.create(); }
    getProjectId(iModel) { return iModel.iModelToken.contextId; }
    getiModelId(iModel) { return iModel.iModelToken.iModelId; }
    /** @internal */
    async getAllSettings(iModel, shared) {
        const projectId = this.getProjectId(iModel);
        const modelId = this.getiModelId(iModel);
        if (undefined === projectId || undefined === modelId)
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.IModelStatus.MissingId, "Required project id and model id are not specified");
        const requestContext = await this.getRequestContext();
        if (shared)
            return IModelApp_1.IModelApp.settings.getSharedSettingsByNamespace(requestContext, this.namespace, this.appSpecific, projectId, modelId);
        return IModelApp_1.IModelApp.settings.getUserSettingsByNamespace(requestContext, this.namespace, this.appSpecific, projectId, modelId);
    }
    /** @internal */
    async getSetting(iModel, shared, existingId) {
        const projectId = this.getProjectId(iModel);
        const modelId = this.getiModelId(iModel);
        if (undefined === projectId || undefined === modelId)
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.IModelStatus.MissingId, "Required project id and model id are not specified");
        const requestContext = await this.getRequestContext();
        if (shared)
            return IModelApp_1.IModelApp.settings.getSharedSetting(requestContext, this.namespace, existingId, this.appSpecific, projectId, modelId);
        return IModelApp_1.IModelApp.settings.getUserSetting(requestContext, this.namespace, existingId, this.appSpecific, projectId, modelId);
    }
    /** @internal */
    async saveSetting(iModel, shared, existingId, settings) {
        const projectId = this.getProjectId(iModel);
        const modelId = this.getiModelId(iModel);
        if (undefined === projectId || undefined === modelId)
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.IModelStatus.MissingId, "Required project id and model id are not specified");
        const requestContext = await this.getRequestContext();
        if (shared)
            return IModelApp_1.IModelApp.settings.saveSharedSetting(requestContext, settings, this.namespace, existingId, this.appSpecific, projectId, modelId);
        return IModelApp_1.IModelApp.settings.saveUserSetting(requestContext, settings, this.namespace, existingId, this.appSpecific, projectId, modelId);
    }
    /** @internal */
    async deleteSetting(iModel, shared, existingId) {
        const projectId = this.getProjectId(iModel);
        const modelId = this.getiModelId(iModel);
        if (undefined === projectId || undefined === modelId)
            throw new imodeljs_common_1.IModelError(bentleyjs_core_1.IModelStatus.MissingId, "Required project id and model id are not specified");
        const requestContext = await this.getRequestContext();
        if (shared)
            return IModelApp_1.IModelApp.settings.deleteSharedSetting(requestContext, this.namespace, existingId, this.appSpecific, projectId, modelId);
        return IModelApp_1.IModelApp.settings.deleteUserSetting(requestContext, this.namespace, existingId, this.appSpecific, projectId, modelId);
    }
    /** @internal */
    async getCachedSetting(iModel, shared, existingId) {
        const existing = this._cachedClips.get(existingId);
        if (undefined !== existing && shared === existing.shared)
            return existing;
        const cacheEntry = (undefined === existing ? { shared, modified: false } : existing);
        this._cachedClips.set(existingId, cacheEntry); // Insert invalid entry to avoid repeated failures...
        try {
            const result = await this.getSetting(iModel, shared, existingId);
            if (imodeljs_clients_1.SettingsStatus.Success === result.status) {
                cacheEntry.clip = geometry_core_1.ClipVector.fromJSON(result.setting.clip);
                cacheEntry.name = result.setting.name;
                cacheEntry.shared = shared;
                return cacheEntry;
            }
            return cacheEntry;
        }
        catch (error) {
            return cacheEntry;
        }
    }
    /** @internal */
    async newCachedSetting(iModel, shared, newId, settings) {
        try {
            const result = await this.saveSetting(iModel, shared, newId, settings);
            if (imodeljs_clients_1.SettingsStatus.Success === result.status)
                this._cachedClips.set(newId, { clip: settings.clip, name: settings.name, shared, modified: false });
            return result.status;
        }
        catch (error) {
            return imodeljs_clients_1.SettingsStatus.AuthorizationError;
        }
    }
    /** @internal */
    async updateCachedSetting(iModel, shared, existingId, settings) {
        const existing = await this.getCachedSetting(iModel, shared, existingId);
        if (undefined === existing.clip)
            return imodeljs_clients_1.SettingsStatus.SettingNotFound;
        try {
            if (undefined === settings.name)
                settings.name = existing.name; // Preserve name when called to update clip...
            const result = await this.saveSetting(iModel, existing.shared, existingId, settings);
            if (imodeljs_clients_1.SettingsStatus.Success === result.status)
                this._cachedClips.set(existingId, { clip: settings.clip, name: settings.name, shared: existing.shared, modified: false });
            return result.status;
        }
        catch (error) {
            return imodeljs_clients_1.SettingsStatus.AuthorizationError;
        }
    }
    /** @internal */
    async deleteCachedSetting(iModel, shared, existingId) {
        try {
            const result = await this.deleteSetting(iModel, shared, existingId);
            if (imodeljs_clients_1.SettingsStatus.Success === result.status)
                this._cachedClips.delete(existingId);
            return result.status;
        }
        catch (error) {
            return imodeljs_clients_1.SettingsStatus.AuthorizationError;
        }
    }
    /** @internal */
    async renameCachedSetting(iModel, shared, existingId, name) {
        const existing = await this.getCachedSetting(iModel, shared, existingId);
        if (undefined === existing.clip)
            return imodeljs_clients_1.SettingsStatus.SettingNotFound;
        else if (name === existing.name)
            return imodeljs_clients_1.SettingsStatus.Success;
        try {
            const result = await this.saveSetting(iModel, existing.shared, existingId, { clip: existing.clip, name });
            if (imodeljs_clients_1.SettingsStatus.Success === result.status)
                this._cachedClips.set(existingId, { clip: existing.clip, name, shared: existing.shared, modified: false });
            return result.status;
        }
        catch (error) {
            return imodeljs_clients_1.SettingsStatus.AuthorizationError;
        }
    }
    /** @internal */
    async shareCachedSetting(iModel, existingId, newShared) {
        const existing = await this.getCachedSetting(iModel, !newShared, existingId);
        if (undefined === existing.clip)
            return imodeljs_clients_1.SettingsStatus.SettingNotFound;
        else if (existing.shared === newShared)
            return imodeljs_clients_1.SettingsStatus.Success;
        try {
            const status = await this.newCachedSetting(iModel, newShared, existingId, { clip: existing.clip, name: existing.name });
            if (imodeljs_clients_1.SettingsStatus.Success === status)
                await this.deleteSetting(iModel, !newShared, existingId);
            return status;
        }
        catch (error) {
            return imodeljs_clients_1.SettingsStatus.AuthorizationError;
        }
    }
    /** @internal */
    validateActiveClipId(viewport) {
        const activeId = this.getActiveClipId(viewport);
        if (undefined !== activeId) {
            const current = viewport.view.getViewClip();
            const active = this._cachedClips.get(activeId);
            if (undefined === current || undefined === active || undefined === active.clip || !ViewClipTool.areClipsEqual(current, active.clip))
                return this.clearActiveClipId(viewport);
        }
        this.purgeActiveClipIdCache();
    }
    /** @internal */
    purgeActiveClipIdCache() {
        if (this._cachedClips.size <= this._activeClips.size)
            return;
        const usedCache = new Map(); // Purge cache entries not currently being referenced by a view...
        this._activeClips.forEach((usedId) => { const usedEntry = this._cachedClips.get(usedId); if (undefined !== usedEntry)
            usedCache.set(usedId, usedEntry); });
        this._cachedClips = usedCache;
    }
    getActiveClipId(viewport) {
        return this._activeClips.get(viewport.viewportId);
    }
    /** @internal */
    setActiveClipId(viewport, existingId) {
        this._activeClips.set(viewport.viewportId, existingId);
        this.purgeActiveClipIdCache();
    }
    /** @internal */
    clearActiveClipId(viewport) {
        this._activeClips.delete(viewport.viewportId);
        this.purgeActiveClipIdCache();
    }
    /** @internal */
    clearActiveClipIdAllViews() {
        this._activeClips.clear();
        this._cachedClips.clear();
    }
    /** @internal */
    modifiedActiveClip(viewport) {
        const activeId = this.getActiveClipId(viewport);
        if (undefined === activeId)
            return false;
        const clip = viewport.view.getViewClip();
        if (undefined === clip)
            return false; // Expected onClearClip...
        const existing = this._cachedClips.get(activeId);
        if (undefined === existing)
            return false;
        existing.modified = true; // Mark cache as changed from saved state. User must choose to update, create new, or discard the changes...
        existing.clip = clip;
        return true;
    }
    async getSettings(settings, iModel, shared) {
        let userStatus = imodeljs_clients_1.SettingsStatus.Success;
        let sharedStatus = imodeljs_clients_1.SettingsStatus.Success;
        if (undefined === shared || !shared) {
            try {
                const userResult = await this.getAllSettings(iModel, false);
                if (imodeljs_clients_1.SettingsStatus.Success === userResult.status && undefined !== userResult.settingsMap) {
                    for (const [key, value] of userResult.settingsMap) {
                        settings.push({ id: key, name: value.name, shared: false });
                    }
                }
                userStatus = userResult.status;
            }
            catch (error) {
                userStatus = imodeljs_clients_1.SettingsStatus.AuthorizationError;
            }
        }
        if (undefined === shared || shared) {
            try {
                const sharedResult = await this.getAllSettings(iModel, true);
                if (imodeljs_clients_1.SettingsStatus.Success === sharedResult.status && undefined !== sharedResult.settingsMap) {
                    for (const [key, value] of sharedResult.settingsMap) {
                        settings.push({ id: key, name: value.name, shared: true });
                    }
                }
                sharedStatus = sharedResult.status;
            }
            catch (error) {
                sharedStatus = imodeljs_clients_1.SettingsStatus.AuthorizationError;
            }
        }
        if (userStatus === sharedStatus)
            return userStatus;
        else if (imodeljs_clients_1.SettingsStatus.SettingNotFound === userStatus)
            return sharedStatus;
        else if (imodeljs_clients_1.SettingsStatus.SettingNotFound === sharedStatus)
            return userStatus;
        else if (imodeljs_clients_1.SettingsStatus.Success === userStatus)
            return sharedStatus;
        else if (imodeljs_clients_1.SettingsStatus.Success === sharedStatus)
            return userStatus;
        return userStatus;
    }
    async getClip(iModel, shared, existingId) {
        const existing = await this.getCachedSetting(iModel, shared, existingId);
        if (undefined === existing.clip || !existing.clip.isValid)
            return undefined;
        return existing.clip;
    }
    async newClip(iModel, shared, clip, name) {
        const newId = bentleyjs_core_1.Guid.createValue();
        if (imodeljs_clients_1.SettingsStatus.Success === await this.newCachedSetting(iModel, shared, newId, { clip, name }))
            return newId;
        return undefined;
    }
    async copyClip(iModel, shared, existingId, copyShared, name) {
        const existingClip = await this.getClip(iModel, shared, existingId);
        if (undefined === existingClip)
            return undefined;
        return this.newClip(iModel, copyShared, existingClip, name);
    }
    async replaceClip(iModel, shared, existingId, clip) {
        return this.updateCachedSetting(iModel, shared, existingId, { clip }); // NOTE: Current name will be preserved when passing undefined...
    }
    async deleteClip(iModel, shared, existingId) {
        return this.deleteCachedSetting(iModel, shared, existingId);
    }
    async renameClip(iModel, shared, existingId, name) {
        return this.renameCachedSetting(iModel, shared, existingId, name);
    }
    async shareClip(iModel, existingId, newShare) {
        return this.shareCachedSetting(iModel, existingId, newShare);
    }
    async saveActiveClip(viewport, shared, name) {
        const clip = viewport.view.getViewClip();
        if (undefined === clip)
            return undefined;
        const activeId = this.getActiveClipId(viewport);
        if (undefined === activeId) {
            const newId = await this.newClip(viewport.iModel, shared, clip, name);
            if (undefined !== newId)
                this.setActiveClipId(viewport, newId);
            return newId;
        }
        else {
            const active = this._cachedClips.get(activeId);
            if (undefined === active || !active.modified)
                return activeId;
            if (active.shared !== shared)
                return undefined;
            const status = await this.replaceClip(viewport.iModel, active.shared, activeId, clip);
            return (imodeljs_clients_1.SettingsStatus.Success === status ? activeId : undefined);
        }
    }
    async activateSavedClip(viewport, id, shared, interactive = true) {
        const activeId = this.getActiveClipId(viewport);
        if (id === activeId)
            return imodeljs_clients_1.SettingsStatus.Success; // Already active...
        let existingClip = await this.getClip(viewport.iModel, shared, id);
        if (undefined === existingClip) {
            // NOTE: For non-interactive call to apply a saved view, shared flag should be based on saved view's setting...
            //       A shared saved view should never reference a user's saved clip.
            //       A user's saved view can reference a saved clip (or a user's saved clip that was later changed to shared).
            //       The saved view is not required to store the shared flag for the save clip.
            if (interactive || shared)
                return imodeljs_clients_1.SettingsStatus.SettingNotFound;
            existingClip = await this.getClip(viewport.iModel, true, id);
            if (undefined === existingClip)
                return imodeljs_clients_1.SettingsStatus.SettingNotFound;
        }
        if (!ViewClipTool.setViewClip(viewport, existingClip))
            return imodeljs_clients_1.SettingsStatus.UnknownError;
        this.setActiveClipId(viewport, id);
        if (undefined !== this._clipEventHandler)
            this._clipEventHandler.onActivateClip(viewport, interactive);
        return imodeljs_clients_1.SettingsStatus.Success;
    }
    async activateSavedClipPlanes(viewport, ids, shared) {
        if (ids.length < 2 || ids.length !== shared.length)
            return imodeljs_clients_1.SettingsStatus.UnknownError;
        const planeSet = geometry_core_1.ConvexClipPlaneSet.createEmpty();
        for (let iPlane = 0; iPlane < ids.length; iPlane++) {
            const existingClip = await this.getClip(viewport.iModel, shared[iPlane], ids[iPlane]);
            if (undefined === existingClip)
                return imodeljs_clients_1.SettingsStatus.SettingNotFound;
            const plane = ViewClipTool.isSingleClipPlane(existingClip);
            if (undefined === plane)
                return imodeljs_clients_1.SettingsStatus.UnknownError;
            planeSet.addPlaneToConvexSet(plane);
        }
        if (!ViewClipTool.doClipToConvexClipPlaneSet(viewport, planeSet))
            return imodeljs_clients_1.SettingsStatus.UnknownError;
        this.clearActiveClipId(viewport);
        if (undefined !== this._clipEventHandler)
            this._clipEventHandler.onActivateClip(viewport, true);
        return imodeljs_clients_1.SettingsStatus.Success;
    }
    async areSavedClipPlanes(iModel, ids, shared) {
        if (ids.length !== shared.length)
            return false;
        for (let iPlane = 0; iPlane < ids.length; iPlane++) {
            const existingClip = await this.getClip(iModel, shared[iPlane], ids[iPlane]);
            if (undefined === existingClip)
                return false;
            const plane = ViewClipTool.isSingleClipPlane(existingClip);
            if (undefined === plane)
                return false;
        }
        return true;
    }
    getActiveClipStatus(viewport) {
        this.validateActiveClipId(viewport);
        if (undefined === viewport.view.getViewClip())
            return ActiveClipStatus.None;
        const activeId = this.getActiveClipId(viewport);
        if (undefined === activeId)
            return ActiveClipStatus.Unsaved;
        const active = this._cachedClips.get(activeId);
        if (undefined === active)
            return ActiveClipStatus.Unsaved;
        return (active.modified ? ActiveClipStatus.Modified : ActiveClipStatus.Saved);
    }
}
exports.ViewClipSettingsProvider = ViewClipSettingsProvider;
/** @alpha Event types for ViewClipDecorationProvider.onActiveClipChanged */
var ClipEventType;
(function (ClipEventType) {
    ClipEventType[ClipEventType["New"] = 0] = "New";
    ClipEventType[ClipEventType["NewPlane"] = 1] = "NewPlane";
    ClipEventType[ClipEventType["Modify"] = 2] = "Modify";
    ClipEventType[ClipEventType["Clear"] = 3] = "Clear";
    ClipEventType[ClipEventType["Activate"] = 4] = "Activate";
})(ClipEventType = exports.ClipEventType || (exports.ClipEventType = {}));
/** @alpha An implementation of ViewClipEventHandler that responds to new clips by presenting clip modification handles */
class ViewClipDecorationProvider {
    constructor() {
        this.selectDecorationOnCreate = true;
        this.clearDecorationOnDeselect = true;
        /** Called when the active clip for a view is changed */
        this.onActiveClipChanged = new bentleyjs_core_1.BeEvent();
        /** Called on a right click over the clip geometry or clip modify handle. ViewClipDecoration provides methods for the following possible menu actions:
         * For ClipPlanes (undefined !== clipPlaneSet): Flip (doClipPlaneNegate), Clear (doClipPlaneClear), and Orient View (doClipPlaneOrientView)
         * For ClipShapes (undefined === clipPlaneSet): Orient View (doClipPlaneOrientView) and input fields to set world zLow/zHigh (doClipShapeSetZExtents provided isClipShapeAlignedWithWorldUp returns true)
         */
        this.onActiveClipRightClick = new bentleyjs_core_1.BeEvent();
    }
    /** Call to check if named clip settings have been enabled. Can use before calling settings.getActiveClipId to avoid creating settings */
    get hasSettings() { return (undefined !== this._settings); }
    /** Call to allow saving the active clip as a setting or to set the active clip from a previously saved setting */
    get settings() { if (undefined === this._settings)
        this._settings = new ViewClipSettingsProvider(this); return this._settings; }
    selectOnCreate() { return this.selectDecorationOnCreate; }
    clearOnDeselect() { return this.clearDecorationOnDeselect; }
    onNewClip(viewport) {
        ViewClipDecoration.create(viewport, this);
        if (undefined !== this._settings)
            this._settings.clearActiveClipId(viewport);
        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.New, this);
    }
    onNewClipPlane(viewport) {
        ViewClipDecoration.create(viewport, this);
        if (undefined !== this._settings)
            this._settings.clearActiveClipId(viewport);
        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.NewPlane, this);
    }
    onModifyClip(viewport) {
        if (undefined !== this._settings)
            this._settings.modifiedActiveClip(viewport);
        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.Modify, this);
    }
    onClearClip(viewport) {
        ViewClipDecoration.clear();
        if (undefined !== this._settings)
            this._settings.clearActiveClipId(viewport);
        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.Clear, this);
    }
    onActivateClip(viewport, interactive) {
        if (interactive)
            ViewClipDecoration.create(viewport, this);
        else
            ViewClipDecoration.clear();
        this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.Activate, this);
    }
    onRightClick(hit, ev) {
        const decoration = (undefined !== ev.viewport ? ViewClipDecoration.get(ev.viewport) : undefined);
        if (undefined === decoration)
            return false;
        if (0 === this.onActiveClipRightClick.numberOfListeners)
            return decoration.doClipPlaneNegate(decoration.getControlIndex(hit.sourceId));
        this.onActiveClipRightClick.raiseEvent(hit, ev, this);
        return true;
    }
    showDecoration(vp) { ViewClipDecoration.create(vp, this); }
    hideDecoration() { ViewClipDecoration.clear(); }
    toggleDecoration(vp) { ViewClipDecoration.toggle(vp, this); }
    static create() {
        if (undefined === ViewClipDecorationProvider._provider) {
            ViewClipDecoration.clear();
            ViewClipDecorationProvider._provider = new ViewClipDecorationProvider();
        }
        return ViewClipDecorationProvider._provider;
    }
    static clear() {
        if (undefined === ViewClipDecorationProvider._provider)
            return;
        ViewClipDecoration.clear();
        ViewClipDecorationProvider._provider = undefined;
    }
}
exports.ViewClipDecorationProvider = ViewClipDecorationProvider;


/***/ }),

/***/ "./lib/tools/EditManipulator.js":
/*!**************************************!*\
  !*** ./lib/tools/EditManipulator.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const ToolAdmin_1 = __webpack_require__(/*! ./ToolAdmin */ "./lib/tools/ToolAdmin.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
/** A manipulator maintains a set of controls used to modify element(s) or pickable decorations.
 * Interactive modification is handled by installing an InputCollector tool.
 * @alpha
 */
var EditManipulator;
(function (EditManipulator) {
    let EventType;
    (function (EventType) {
        EventType[EventType["Synch"] = 0] = "Synch";
        EventType[EventType["Cancel"] = 1] = "Cancel";
        EventType[EventType["Accept"] = 2] = "Accept";
    })(EventType = EditManipulator.EventType || (EditManipulator.EventType = {}));
    class HandleTool extends Tool_1.InputCollector {
        constructor(manipulator) {
            super();
            this.manipulator = manipulator;
        }
        /** Setup tool for press, hold, drag or click+click modification.
         * By default a geometry manipulator (ex. move linestring vertices) should honor all locks and support AccuSnap.
         * @note We set this.receivedDownEvent to get up events for this tool instance when it's installed from a down event like onModelStartDrag.
         */
        init() {
            this.receivedDownEvent = true;
            this.initLocateElements(false, true, undefined, Tool_1.CoordinateLockOverrides.None); // InputCollector inherits state of suspended primitive, set everything...
        }
        cancel(_ev) { return true; }
        onPostInstall() { super.onPostInstall(); this.init(); }
        async onDataButtonDown(ev) { if (!this.accept(ev))
            return Tool_1.EventHandled.No; this.exitTool(); this.manipulator.onManipulatorEvent(EventType.Accept); return Tool_1.EventHandled.Yes; }
        async onResetButtonUp(ev) { if (!this.cancel(ev))
            return Tool_1.EventHandled.No; this.exitTool(); this.manipulator.onManipulatorEvent(EventType.Cancel); return Tool_1.EventHandled.Yes; }
        async onTouchMove(ev) { return IModelApp_1.IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }
        async onTouchComplete(ev) { return IModelApp_1.IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }
        async onTouchCancel(ev) { return IModelApp_1.IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, Tool_1.BeButton.Reset); }
    }
    HandleTool.toolId = "Select.Manipulator";
    HandleTool.hidden = true;
    EditManipulator.HandleTool = HandleTool;
    class HandleProvider {
        constructor(iModel) {
            this.iModel = iModel;
            this._isActive = false;
            this._removeManipulatorToolListener = IModelApp_1.IModelApp.toolAdmin.manipulatorToolEvent.addListener(this.onManipulatorToolEvent, this);
        }
        stop() {
            if (this._removeSelectionListener) {
                this._removeSelectionListener();
                this._removeSelectionListener = undefined;
            }
            if (this._removeManipulatorToolListener) {
                this._removeManipulatorToolListener();
                this._removeManipulatorToolListener = undefined;
            }
            this.clearControls();
        }
        onManipulatorToolEvent(_tool, event) {
            switch (event) {
                case ToolAdmin_1.ManipulatorToolEvent.Start: {
                    if (this._removeSelectionListener)
                        break;
                    this._removeSelectionListener = this.iModel.selectionSet.onChanged.addListener(this.onSelectionChanged, this);
                    if (this.iModel.selectionSet.isActive)
                        this.onManipulatorEvent(EventType.Synch); // Give opportunity to add controls when tool is started with an existing selection...
                    break;
                }
                case ToolAdmin_1.ManipulatorToolEvent.Stop: {
                    if (!this._removeSelectionListener)
                        break;
                    this._removeSelectionListener();
                    this._removeSelectionListener = undefined;
                    this.clearControls();
                }
            }
        }
        onSelectionChanged(ev) {
            if (this.iModel === ev.set.iModel)
                this.onManipulatorEvent(EventType.Synch);
        }
        updateDecorationListener(add) {
            if (this._removeDecorationListener) {
                if (!add) {
                    this._removeDecorationListener();
                    this._removeDecorationListener = undefined;
                }
                IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            }
            else if (add) {
                if (!this._removeDecorationListener)
                    this._removeDecorationListener = IModelApp_1.IModelApp.viewManager.addDecorator(this);
                IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            }
        }
        decorate(_context) { }
        async updateControls() {
            const created = await this.createControls();
            if (this._isActive && !created)
                this.clearControls();
            else
                this.updateDecorationListener(this._isActive = created);
        }
        clearControls() {
            this.updateDecorationListener(this._isActive = false);
        }
        onManipulatorEvent(_eventType) { this.updateControls(); } // tslint:disable-line:no-floating-promises
        async onDoubleClick(_hit, _ev) { return Tool_1.EventHandled.No; }
        async onRightClick(_hit, _ev) { return Tool_1.EventHandled.No; }
        async onTouchTap(_hit, _ev) { return Tool_1.EventHandled.Yes; }
        async onDecorationButtonEvent(hit, ev) {
            if (!this._isActive)
                return Tool_1.EventHandled.No;
            if (ev.isDoubleClick)
                return this.onDoubleClick(hit, ev);
            if (Tool_1.BeButton.Reset === ev.button && !ev.isDown && !ev.isDragging)
                return this.onRightClick(hit, ev);
            if (Tool_1.BeButton.Data !== ev.button)
                return Tool_1.EventHandled.No;
            if (ev.isControlKey)
                return Tool_1.EventHandled.No; // Support ctrl+click to select multiple controls (ex. linestring vertices)...
            if (Tool_1.InputSource.Touch === ev.inputSource && !ev.isDragging)
                return this.onTouchTap(hit, ev); // Default is to select controls on touch drag only, ignore tap on control...
            if (ev.isDown && !ev.isDragging)
                return Tool_1.EventHandled.No; // Select controls on up event or down event only after drag started...
            if (!this.modifyControls(hit, ev))
                return Tool_1.EventHandled.No;
            // In case InputCollector was installed for handle modification, don't wait for motion to show dynamic frame adjusted for AccuDraw hints...
            IModelApp_1.IModelApp.accuDraw.refreshDecorationsAndDynamics();
            return Tool_1.EventHandled.Yes;
        }
    }
    EditManipulator.HandleProvider = HandleProvider;
    class HandleUtils {
        static getBoresite(origin, vp, checkAccuDraw = false, checkACS = false) {
            if (checkAccuDraw && IModelApp_1.IModelApp.accuDraw.isActive)
                return geometry_core_1.Ray3d.create(origin, IModelApp_1.IModelApp.accuDraw.getRotation().getRow(2).negate());
            if (checkACS && vp.isContextRotationRequired)
                return geometry_core_1.Ray3d.create(origin, vp.getAuxCoordRotation().getRow(2).negate());
            const eyePoint = vp.worldToViewMap.transform1.columnZ();
            const direction = geometry_core_1.Vector3d.createFrom(eyePoint);
            const aa = geometry_core_1.Geometry.conditionalDivideFraction(1, eyePoint.w);
            if (aa !== undefined) {
                const xyzEye = direction.scale(aa);
                direction.setFrom(origin.vectorTo(xyzEye));
            }
            direction.scaleToLength(-1.0, direction);
            return geometry_core_1.Ray3d.create(origin, direction);
        }
        static projectPointToPlaneInView(spacePt, planePt, planeNormal, vp, checkAccuDraw = false, checkACS = false) {
            const plane = geometry_core_1.Plane3dByOriginAndUnitNormal.create(planePt, planeNormal);
            if (undefined === plane)
                return undefined;
            const rayToEye = EditManipulator.HandleUtils.getBoresite(spacePt, vp, checkAccuDraw, checkACS);
            const projectedPt = geometry_core_1.Point3d.createZero();
            if (undefined === rayToEye.intersectionWithPlane(plane, projectedPt))
                return undefined;
            return projectedPt;
        }
        static projectPointToLineInView(spacePt, linePt, lineDirection, vp, checkAccuDraw = false, checkACS = false) {
            const lineRay = geometry_core_1.Ray3d.create(linePt, lineDirection);
            const rayToEye = EditManipulator.HandleUtils.getBoresite(spacePt, vp, checkAccuDraw, checkACS);
            if (rayToEye.direction.isParallelTo(lineRay.direction, true))
                return lineRay.projectPointToRay(spacePt);
            const matrix = geometry_core_1.Matrix3d.createRigidFromColumns(lineRay.direction, rayToEye.direction, geometry_core_1.AxisOrder.XZY);
            if (undefined === matrix)
                return undefined;
            const plane = geometry_core_1.Plane3dByOriginAndUnitNormal.create(linePt, matrix.columnZ());
            if (undefined === plane)
                return undefined;
            const projectedPt = geometry_core_1.Point3d.createZero();
            if (undefined === rayToEye.intersectionWithPlane(plane, projectedPt))
                return undefined;
            return lineRay.projectPointToRay(projectedPt);
        }
        /** Get a transform to orient arrow shape to view direction. If arrow direction is close to perpendicular to view direction will return undefined. */
        static getArrowTransform(vp, base, direction, sizeInches) {
            const boresite = EditManipulator.HandleUtils.getBoresite(base, vp);
            if (Math.abs(direction.dotProduct(boresite.direction)) >= 0.9)
                return undefined;
            const pixelSize = vp.pixelsFromInches(sizeInches);
            const scale = vp.viewFrustum.getPixelSizeAtPoint(base) * pixelSize;
            const matrix = geometry_core_1.Matrix3d.createRigidFromColumns(direction, boresite.direction, geometry_core_1.AxisOrder.XZY);
            if (undefined === matrix)
                return undefined;
            matrix.scaleColumnsInPlace(scale, scale, scale);
            return geometry_core_1.Transform.createRefs(base.clone(), matrix);
        }
        /** Return array of shape points representing a unit arrow in xy plane pointing in positive x direction. */
        static getArrowShape(baseStart = 0.0, baseWidth = 0.15, tipStart = 0.55, tipEnd = 1.0, tipWidth = 0.3, flangeStart = tipStart, flangeWidth = baseWidth) {
            const shapePts = [];
            shapePts[0] = geometry_core_1.Point3d.create(tipEnd, 0.0);
            shapePts[1] = geometry_core_1.Point3d.create(flangeStart, tipWidth);
            shapePts[2] = geometry_core_1.Point3d.create(tipStart, flangeWidth);
            shapePts[3] = geometry_core_1.Point3d.create(baseStart, baseWidth);
            shapePts[4] = geometry_core_1.Point3d.create(baseStart, -baseWidth);
            shapePts[5] = geometry_core_1.Point3d.create(tipStart, -flangeWidth);
            shapePts[6] = geometry_core_1.Point3d.create(flangeStart, -tipWidth);
            shapePts[7] = shapePts[0].clone();
            return shapePts;
        }
    }
    EditManipulator.HandleUtils = HandleUtils;
})(EditManipulator = exports.EditManipulator || (exports.EditManipulator = {}));


/***/ }),

/***/ "./lib/tools/ElementSetTool.js":
/*!*************************************!*\
  !*** ./lib/tools/ElementSetTool.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
/** The requested source for the elements to modify.
 * @internal Do we really want to propagate the *Elem* abbreviation?
 */
var ElemSource;
(function (ElemSource) {
    /** Populate ElementAgenda from a locate */
    ElemSource[ElemSource["Pick"] = 0] = "Pick";
    /**  Populate ElementAgenda from active fence */
    ElemSource[ElemSource["Fence"] = 1] = "Fence";
    /**  Populate ElementAgenda from active selection set */
    ElemSource[ElemSource["SelectionSet"] = 2] = "SelectionSet";
})(ElemSource = exports.ElemSource || (exports.ElemSource = {}));
/** The method that will be used to update the tool's ElementAgenda.
 * @internal Do we really want to propagate the *Elem* abbreviation?
 */
var ElemMethod;
(function (ElemMethod) {
    /** Entries will be added to ElementAgenda */
    ElemMethod[ElemMethod["Add"] = 0] = "Add";
    /** Entries currently in the ElementAgenda are removed, entries not currently in the ElementAgenda are added. */
    ElemMethod[ElemMethod["Invert"] = 1] = "Invert";
})(ElemMethod = exports.ElemMethod || (exports.ElemMethod = {}));
/** Should the active fence be used, required, or ignored as a possible ElemSource.
 * @internal
 */
var UsesFence;
(function (UsesFence) {
    /** Active Fence is allowed as ElemSource */
    UsesFence[UsesFence["Check"] = 0] = "Check";
    /** Active Fence is required as ElemSource */
    UsesFence[UsesFence["Required"] = 1] = "Required";
    /** Active Fence is not supported as ElemSource */
    UsesFence[UsesFence["None"] = 2] = "None";
})(UsesFence = exports.UsesFence || (exports.UsesFence = {}));
/** Should the active selection set be used, required, or ignored as a possible ElemSource.
 * @internal
 */
var UsesSelection;
(function (UsesSelection) {
    /** Active Selection Set is allowed as ElemSource */
    UsesSelection[UsesSelection["Check"] = 0] = "Check";
    /** Active Selection Set is required as ElemSource */
    UsesSelection[UsesSelection["Required"] = 1] = "Required";
    /** Active Selection Set is not supported as ElemSource */
    UsesSelection[UsesSelection["None"] = 2] = "None";
})(UsesSelection = exports.UsesSelection || (exports.UsesSelection = {}));
/** Should ElemSource::Pick allow a drag select to identify elements.
 * @internal
 */
var UsesDragSelect;
(function (UsesDragSelect) {
    /** Drag selection using shape inside/overlap */
    UsesDragSelect[UsesDragSelect["Box"] = 0] = "Box";
    /** Drag selection using crossing line */
    UsesDragSelect[UsesDragSelect["Line"] = 1] = "Line";
    /** Tool does not support drag selection for ElemSource.Pick */
    UsesDragSelect[UsesDragSelect["None"] = 2] = "None";
})(UsesDragSelect = exports.UsesDragSelect || (exports.UsesDragSelect = {}));
/** Helps determine the action ModifyAgenda will take on the agenda elements after calling doFenceClip.
 * @internal
 */
var ClipResult;
(function (ClipResult) {
    /** Tool does not support fence clip */
    ClipResult[ClipResult["NotSupported"] = 0] = "NotSupported";
    /** Valid entries in ElementAgenda are new elements, no elemRef but correct modelRef. */
    ClipResult[ClipResult["NewElements"] = 1] = "NewElements";
    /** Valid entries in ElementAgenda reference original elemRef and modelRef. */
    ClipResult[ClipResult["OriginalElements"] = 2] = "OriginalElements";
})(ClipResult = exports.ClipResult || (exports.ClipResult = {}));
/** ElemSource specific failures.
 * @internal
 */
var ErrorNums;
(function (ErrorNums) {
    /** No fence is currently active */
    ErrorNums[ErrorNums["NoFence"] = 0] = "NoFence";
    /** No acceptable element(s) inside fence */
    ErrorNums[ErrorNums["NoFenceElems"] = 1] = "NoFenceElems";
    /** No acceptable element(s) outside fence */
    ErrorNums[ErrorNums["NoFenceElemsOutside"] = 2] = "NoFenceElemsOutside";
    /** No acceptable element(s) in selection set */
    ErrorNums[ErrorNums["NoSSElems"] = 3] = "NoSSElems";
    /** Located element rejected by tool filters */
    ErrorNums[ErrorNums["NotSupportedElmType"] = 4] = "NotSupportedElmType";
})(ErrorNums = exports.ErrorNums || (exports.ErrorNums = {}));
/** @internal */
var HilitedState;
(function (HilitedState) {
    /**  this agenda is in an indeterminate state wrt hilite */
    HilitedState[HilitedState["Unknown"] = 0] = "Unknown";
    /**  all of the entries in this agenda were hilited by a call to ElementAgenda.hilite */
    HilitedState[HilitedState["Yes"] = 1] = "Yes";
    /**  all of the entries in this agenda were un-hilited by a call to ElementAgenda.clearHilite */
    HilitedState[HilitedState["No"] = 2] = "No";
})(HilitedState = exports.HilitedState || (exports.HilitedState = {}));
/** @internal */
var ModifyElementSource;
(function (ModifyElementSource) {
    /** The source for the element is unknown - not caused by a modification command. */
    ModifyElementSource[ModifyElementSource["Unknown"] = 0] = "Unknown";
    /** The element is selected by the user. */
    ModifyElementSource[ModifyElementSource["Selected"] = 1] = "Selected";
    /** The element is processed because it is in the selection set. */
    ModifyElementSource[ModifyElementSource["SelectionSet"] = 2] = "SelectionSet";
    /** The element is processed because it is passes the fence criteria. */
    ModifyElementSource[ModifyElementSource["Fence"] = 3] = "Fence";
    /** The element is processed because it belongs to the group of the selected element (for _FilterAgendaEntries only) */
    ModifyElementSource[ModifyElementSource["Group"] = 4] = "Group";
    /** The element is selected by the user by drag selection or multi-selection using ctrl. */
    ModifyElementSource[ModifyElementSource["DragSelect"] = 5] = "DragSelect";
})(ModifyElementSource = exports.ModifyElementSource || (exports.ModifyElementSource = {}));
/** @internal */
class ElementAgenda {
    constructor(iModel) {
        this.iModel = iModel;
        this.elements = [];
        this.groupMarks = [];
        /** Whether elements are flagged as hilited when added to the agenda. */
        this.hiliteOnAdd = true;
        this.hilitedState = HilitedState.Unknown;
    }
    /**
     * Get the source for this ElementAgenda, if applicable. The "source" is merely an indication of what the collection of elements
     * in this agenda means. When the source is ModifyElementSource.SelectionSet, the attempt will be made to keep the Selection
     * Set current with changes to the agenda.
     */
    getSource() { return this.groupMarks.length === 0 ? ModifyElementSource.Unknown : this.groupMarks[this.groupMarks.length - 1].source; }
    /** Set the source for this ElementAgenda. */
    setSource(val) { if (this.groupMarks.length > 0)
        this.groupMarks[this.groupMarks.length - 1].source = val; }
    get isEmpty() { return this.length === 0; }
    get count() { return this.length; }
    get length() { return this.elements.length; }
    /** Calls ClearHilite and empties this ElementAgenda. */
    clear() { this.clearHilite(); this.elements.length = 0; this.groupMarks.length = 0; }
    /** clear hilite on any currently hilited entries */
    clearHilite() {
        if (HilitedState.No === this.hilitedState)
            return;
        this.setEntriesHiliteState(false); // make sure all entries have their hilite flag off
        this.hilitedState = HilitedState.No;
    }
    setEntriesHiliteState(onOff, groupStart = 0, groupEnd = 0) {
        const group = (0 === groupEnd) ? this.elements : this.elements.filter((_id, index) => index >= groupStart && index < groupEnd);
        this.iModel.hilited.setHilite(group, onOff);
    }
    /** Calls ClearHilite and removes the last group of elements added to this ElementAgenda. */
    popGroup() {
        if (this.groupMarks.length <= 1) {
            this.clear();
            return;
        }
        const group = this.groupMarks.pop();
        if (HilitedState.No !== this.hilitedState)
            this.setEntriesHiliteState(false, group.start, this.length); // make sure removed entries aren't left hilited...
        this.elements.splice(group.start);
    }
    /** Mark all entries in this agenda as being hilited. */
    hilite() {
        if (HilitedState.Yes === this.hilitedState)
            return;
        this.setEntriesHiliteState(this.hiliteOnAdd); // make sure all entries have their hilite flag on.
        this.hilitedState = HilitedState.Yes;
    }
    has(id) { return this.elements.some((entry) => id === entry); }
    /** Return true if elementId is already in this ElementAgenda. */
    find(id) { return this.has(id); }
    /** Add elements to this ElementAgenda. */
    add(arg) {
        const groupStart = this.length;
        bentleyjs_core_1.Id64.forEach(arg, (id) => {
            if (!this.has(id))
                this.elements.push(id);
        });
        if (groupStart === this.length)
            return false;
        this.groupMarks.push({ start: groupStart, source: ModifyElementSource.Unknown });
        if (HilitedState.No !== this.hilitedState)
            this.setEntriesHiliteState(this.hiliteOnAdd, groupStart, this.length);
        return true;
    }
    removeOne(id) {
        let pos = -1;
        const elements = this.elements;
        const groupMarks = this.groupMarks;
        elements.some((entry, index) => { if (id !== entry)
            return false; pos = index; return true; });
        if (pos === -1)
            return false;
        if (1 === elements.length || (1 === groupMarks.length && ModifyElementSource.DragSelect !== groupMarks[groupMarks.length - 1].source)) {
            this.clear();
            return true;
        }
        const groupIndex = pos;
        let groupStart = 0, groupEnd = 0;
        let markToErase = 0;
        let removeSingleEntry = false;
        for (let iMark = 0; iMark < groupMarks.length; ++iMark) {
            if (0 === groupEnd) {
                if (iMark + 1 === groupMarks.length) {
                    markToErase = iMark;
                    removeSingleEntry = (ModifyElementSource.DragSelect === groupMarks[iMark].source);
                    groupStart = groupMarks[iMark].start;
                    groupEnd = elements.length;
                }
                else if (groupMarks[iMark].start <= groupIndex && groupMarks[iMark + 1].start > groupIndex) {
                    markToErase = iMark;
                    removeSingleEntry = (ModifyElementSource.DragSelect === groupMarks[iMark].source);
                    groupStart = groupMarks[iMark].start;
                    groupEnd = groupMarks[iMark + 1].start;
                }
                continue;
            }
            if (removeSingleEntry)
                groupMarks[iMark].start -= 1; // Only removing single entry, not entire group...
            else
                groupMarks[iMark].start -= (groupEnd - groupStart); // Adjust indices...
        }
        if (removeSingleEntry) { // Only remove single entry...
            if (HilitedState.No !== this.hilitedState)
                this.setEntriesHiliteState(false, groupIndex, groupIndex + 1); // make sure removed entry isn't left hilited...
            elements.splice(groupIndex, 1);
            if (groupEnd === groupStart + 1)
                groupMarks.splice(markToErase, 1);
            return true;
        }
        if (HilitedState.No !== this.hilitedState)
            this.setEntriesHiliteState(false, groupStart, groupEnd); // make sure removed entries aren't left hilited...
        elements.splice(groupStart, groupEnd - groupStart);
        groupMarks.splice(markToErase, 1);
        return true;
    }
    remove(arg) {
        if (0 === this.length)
            return false;
        if (0 === bentleyjs_core_1.Id64.sizeOf(arg))
            return false;
        const needClearHilite = (HilitedState.No !== this.hilitedState);
        if (needClearHilite)
            this.clearHilite(); // Avoid making multiple draws to unhilite entries as they are removed...
        bentleyjs_core_1.Id64.forEach(arg, (elId) => this.removeOne(elId)); // NOTE: Removes group associated with this element, not just a single entry...
        if (needClearHilite)
            this.hilite();
        return true;
    }
    /** Add elements not currently in the ElementAgenda and remove elements currently in the ElementAgenda. */
    invert(arg) {
        if (0 === this.length)
            return this.add(arg);
        if (0 === bentleyjs_core_1.Id64.sizeOf(arg))
            return false;
        const adds = [];
        const removes = [];
        bentleyjs_core_1.Id64.forEach(arg, (id) => { if (this.has(id))
            removes.push(id);
        else
            adds.push(id); });
        if (adds.length === 0 && removes.length === 0)
            return false;
        const needClearHilite = (HilitedState.No !== this.hilitedState);
        if (needClearHilite)
            this.clearHilite(); // Avoid making multiple draws to unhilite/hilite entries as they are removed/added...
        removes.forEach((id) => this.removeOne(id));
        if (adds.length > 0) {
            const groupStart = this.length;
            adds.forEach((id) => this.elements.push(id));
            this.groupMarks.push({ start: groupStart, source: ModifyElementSource.Unknown });
            if (HilitedState.No !== this.hilitedState)
                this.setEntriesHiliteState(this.hiliteOnAdd, groupStart, this.length); // make sure added entries are hilited (when not also removing)...
        }
        if (needClearHilite)
            this.hilite();
        return true;
    }
}
exports.ElementAgenda = ElementAgenda;


/***/ }),

/***/ "./lib/tools/EventController.js":
/*!**************************************!*\
  !*** ./lib/tools/EventController.js ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
/**
 * An EventController maps user input events from the canvas of a Viewport to the ToolAdmin so that tools can process them.
 * Viewports are assigned an EventController when they are registered with ViewManager.addViewport and they are destroyed with ViewManager.dropViewport.
 * @public
 */
class EventController {
    constructor(vp) {
        this.vp = vp;
        this._removals = [];
        const element = vp.parentDiv;
        if (element === undefined)
            return;
        this.addDomListeners(["mousedown", "mouseup", "mousemove", "mouseenter", "mouseleave", "wheel", "touchstart", "touchend", "touchcancel", "touchmove"], element);
        element.oncontextmenu = () => false;
        element.onselectstart = () => false; // TODO: onselectstart is experimental. This cast should be removed once it becomes official.
    }
    destroy() {
        this._removals.forEach((remove) => remove());
        this._removals.length = 0;
    }
    /**
     * Call element.addEventListener for each type of DOM event supplied. Creates a listener that will forward the HTML event to ToolAdmin.addEvent.
     * Records the listener in the [[removals]] member so they are removed when this EventController is destroyed.
     * @param domType An array of DOM event types to pass to element.addEventListener
     * @param element The HTML element to which the listeners are added
     */
    addDomListeners(domType, element) {
        const vp = this.vp;
        const { toolAdmin } = IModelApp_1.IModelApp;
        const listener = (ev) => { ev.preventDefault(); toolAdmin.addEvent(ev, vp); };
        domType.forEach((type) => {
            element.addEventListener(type, listener, false);
            this._removals.push(() => { element.removeEventListener(type, listener, false); });
        });
    }
}
exports.EventController = EventController;


/***/ }),

/***/ "./lib/tools/IdleTool.js":
/*!*******************************!*\
  !*** ./lib/tools/IdleTool.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const ViewTool_1 = __webpack_require__(/*! ./ViewTool */ "./lib/tools/ViewTool.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
/**
 * The default "idle" tool. If no tool is active, or the active tool does not respond to a given
 * event, input events are forwarded to the idle tool. The default idle tool converts middle mouse button events
 * and touch gestures into view navigation operations like pan, zoom, rotate, and fit.
 *
 * Controls are as follows:
 * - Mouse/keyboard:
 *   - mmb: pan
 *   - shift-mmb: rotate
 *   - wheel: zoom in/out
 *   - double-mmb: fit view
 * - Touch:
 *   - single-finger drag: rotate
 *   - two-finger drag: pan
 *   - pinch: zoom in/out
 *   - double-tap: fit view
 *
 * Touch inputs can be combined e.g. drag two fingers while moving them closer together => pan + zoom in
 * @public
 */
class IdleTool extends Tool_1.InteractiveTool {
    async onMouseStartDrag(ev) {
        if (!ev.viewport)
            return Tool_1.EventHandled.No;
        let toolId;
        let handleId;
        switch (ev.button) {
            case Tool_1.BeButton.Middle:
                if (ev.isControlKey) {
                    toolId = ev.viewport.view.allow3dManipulations() ? "View.Look" : "View.Scroll";
                    handleId = ev.viewport.view.allow3dManipulations() ? 128 /* Look */ : 8 /* Scroll */;
                }
                else if (ev.isShiftKey) {
                    toolId = "View.Rotate";
                    handleId = 1 /* Rotate */;
                }
                else {
                    toolId = "View.Pan";
                    handleId = 4 /* Pan */;
                }
                break;
            case Tool_1.BeButton.Data:
                // When no active tool is present install rotate view tool on drag of data button
                if (undefined !== IModelApp_1.IModelApp.toolAdmin.activeTool)
                    return Tool_1.EventHandled.No;
                toolId = "View.Rotate";
                handleId = 1 /* Rotate */;
                break;
            default:
                // When no active tool is present install pan view tool on drag of reset button
                if (undefined !== IModelApp_1.IModelApp.toolAdmin.activeTool)
                    return Tool_1.EventHandled.No;
                toolId = "View.Pan";
                handleId = 4 /* Pan */;
                break;
        }
        const currTool = IModelApp_1.IModelApp.toolAdmin.viewTool;
        if (currTool) {
            if (currTool instanceof ViewTool_1.ViewManip)
                return currTool.startHandleDrag(ev, handleId); // See if current view tool can drag using this handle, leave it active regardless...
            return Tool_1.EventHandled.No;
        }
        const viewTool = IModelApp_1.IModelApp.tools.create(toolId, ev.viewport, true, true);
        if (viewTool && viewTool.run())
            return viewTool.startHandleDrag(ev);
        return Tool_1.EventHandled.Yes;
    }
    async onMiddleButtonUp(ev) {
        if (!ev.viewport)
            return Tool_1.EventHandled.No;
        if (ev.isDoubleClick) {
            const viewTool = new ViewTool_1.FitViewTool(ev.viewport, true);
            return viewTool.run() ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
        }
        if (ev.isControlKey || ev.isShiftKey)
            return Tool_1.EventHandled.No;
        IModelApp_1.IModelApp.tentativePoint.process(ev);
        return Tool_1.EventHandled.Yes;
    }
    async onMouseWheel(ev) { return IModelApp_1.IModelApp.toolAdmin.processWheelEvent(ev, true); }
    async onTouchMoveStart(ev, startEv) {
        const tool = new ViewTool_1.DefaultViewTouchTool(startEv, ev);
        return tool.run() ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
    async onTouchTap(ev) {
        if (ev.isSingleTap) {
            // Send data down/up for single finger tap.
            IModelApp_1.IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev, Tool_1.BeButton.Data); // tslint:disable-line:no-floating-promises
            return Tool_1.EventHandled.Yes;
        }
        else if (ev.isTwoFingerTap) {
            // Send reset down/up for two finger tap.
            IModelApp_1.IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev, Tool_1.BeButton.Reset); // tslint:disable-line:no-floating-promises
            return Tool_1.EventHandled.Yes;
        }
        else if (ev.isDoubleTap) {
            // Fit view on single finger double tap.
            const tool = new ViewTool_1.FitViewTool(ev.viewport, true);
            return tool.run() ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
        }
        return Tool_1.EventHandled.No;
    }
    exitTool() { }
    run() { return true; }
}
IdleTool.toolId = "Idle";
IdleTool.hidden = true;
exports.IdleTool = IdleTool;


/***/ }),

/***/ "./lib/tools/MeasureTool.js":
/*!**********************************!*\
  !*** ./lib/tools/MeasureTool.js ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Measure */
Object.defineProperty(exports, "__esModule", { value: true });
const rendering_1 = __webpack_require__(/*! ../rendering */ "./lib/rendering.js");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const Marker_1 = __webpack_require__(/*! ../Marker */ "./lib/Marker.js");
const PrimitiveTool_1 = __webpack_require__(/*! ./PrimitiveTool */ "./lib/tools/PrimitiveTool.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const HitDetail_1 = __webpack_require__(/*! ../HitDetail */ "./lib/HitDetail.js");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const QuantityFormatter_1 = __webpack_require__(/*! ../QuantityFormatter */ "./lib/QuantityFormatter.js");
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const NotificationManager_1 = __webpack_require__(/*! ../NotificationManager */ "./lib/NotificationManager.js");
const AccuDrawTool_1 = __webpack_require__(/*! ./AccuDrawTool */ "./lib/tools/AccuDrawTool.js");
const AccuDraw_1 = __webpack_require__(/*! ../AccuDraw */ "./lib/AccuDraw.js");
/** @alpha */
class MeasureLabel {
    constructor(worldLocation, label) {
        this.worldLocation = new geometry_core_1.Point3d();
        this.position = new geometry_core_1.Point3d();
        this.worldLocation.setFrom(worldLocation);
        this.label = label;
    }
    drawDecoration(ctx) {
        ctx.font = "16px san-serif";
        const labelHeight = ctx.measureText("M").width; // Close enough for border padding...
        const labelWidth = ctx.measureText(this.label).width + labelHeight;
        ctx.lineWidth = 1;
        ctx.strokeStyle = "white";
        ctx.fillStyle = "rgba(0,0,0,.4)";
        ctx.shadowColor = "black";
        ctx.shadowBlur = 10;
        ctx.fillRect(-(labelWidth / 2), -labelHeight, labelWidth, labelHeight * 2);
        ctx.strokeRect(-(labelWidth / 2), -labelHeight, labelWidth, labelHeight * 2);
        ctx.fillStyle = "white";
        ctx.shadowBlur = 0;
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.label, 0, 0);
    }
    setPosition(vp) {
        vp.worldToView(this.worldLocation, this.position);
        this.position.y -= Math.floor(vp.pixelsFromInches(0.44)) + 0.5; // Offset from snap location...
        return vp.viewRect.containsPoint(this.position);
    }
    addDecoration(context) {
        if (this.setPosition(context.viewport))
            context.addCanvasDecoration(this);
    }
}
/** @alpha */
class MeasureMarker extends Marker_1.Marker {
    constructor(label, title, worldLocation, size) {
        super(worldLocation, size);
        this.isSelected = false;
        const markerDrawFunc = (ctx) => {
            ctx.beginPath();
            ctx.arc(0, 0, this.size.x * 0.5, 0, 2 * Math.PI);
            ctx.lineWidth = 2;
            ctx.strokeStyle = "black";
            const hilite = this.isSelected && this._hiliteColor ? this._hiliteColor.colors : undefined;
            ctx.fillStyle = undefined !== hilite ? "rgba(" + (hilite.r | 0) + "," + (hilite.g | 0) + "," + (hilite.b | 0) + ", 0.5)" : "rgba(255,255,255,.5)";
            ctx.fill();
            ctx.stroke();
        };
        this.drawFunc = markerDrawFunc;
        this.title = title;
        this.label = label;
        this.labelFont = "18px san-serif";
        this.labelColor = "black";
    }
}
/** @alpha */
class MeasureDistanceTool extends PrimitiveTool_1.PrimitiveTool {
    constructor() {
        super(...arguments);
        this._locationData = new Array();
        this._acceptedSegments = new Array();
        this._totalDistance = 0.0;
    }
    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.isSpatialView()); }
    requireWriteableTarget() { return false; }
    onPostInstall() { super.onPostInstall(); this.setupAndPromptForNextAction(); }
    onUnsuspend() { this.showPrompt(); }
    showPrompt() { IModelApp_1.IModelApp.notifications.outputPromptByKey(0 === this._locationData.length ? "CoreTools:tools.Measure.Distance.Prompts.FirstPoint" : "CoreTools:tools.Measure.Distance.Prompts.NextPoint"); }
    setupAndPromptForNextAction() {
        IModelApp_1.IModelApp.accuSnap.enableSnap(true);
        const hints = new AccuDraw_1.AccuDrawHintBuilder();
        hints.enableSmartRotation = true;
        hints.setModeRectangular();
        hints.sendHints(false);
        IModelApp_1.IModelApp.toolAdmin.setCursor(0 === this._locationData.length ? IModelApp_1.IModelApp.viewManager.crossHairCursor : IModelApp_1.IModelApp.viewManager.dynamicsCursor);
        this.showPrompt();
    }
    testDecorationHit(id) { return id === this._snapGeomId; }
    getSnapPoints() {
        if (this._acceptedSegments.length < 1 && this._locationData.length < 2)
            return undefined;
        const snapPoints = [];
        for (const seg of this._acceptedSegments) {
            if (0 === snapPoints.length || !seg.start.isAlmostEqual(snapPoints[snapPoints.length - 1]))
                snapPoints.push(seg.start);
            if (!seg.end.isAlmostEqual(snapPoints[0]))
                snapPoints.push(seg.end);
        }
        if (this._locationData.length > 1)
            for (const loc of this._locationData)
                snapPoints.push(loc.point);
        return snapPoints;
    }
    getDecorationGeometry(_hit) {
        const snapPoints = this.getSnapPoints();
        if (undefined === snapPoints)
            return undefined;
        const geomData = geometry_core_1.IModelJson.Writer.toIModelJson(geometry_core_1.PointString3d.create(snapPoints));
        return (undefined === geomData ? undefined : [geomData]);
    }
    displayDynamicDistance(context, points) {
        let totalDistance = 0.0;
        for (let i = 0; i < points.length - 1; i++)
            totalDistance += points[i].distance(points[i + 1]);
        if (0.0 === totalDistance)
            return;
        const formatterSpec = IModelApp_1.IModelApp.quantityFormatter.findFormatterSpecByQuantityType(QuantityFormatter_1.QuantityType.Length);
        if (undefined === formatterSpec)
            return;
        const formattedTotalDistance = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(totalDistance, formatterSpec);
        const distDyn = new MeasureLabel(points[points.length - 1], formattedTotalDistance);
        distDyn.addDecoration(context);
    }
    displayDelta(context, seg) {
        const xVec = new geometry_core_1.Vector3d(seg.delta.x, 0.0, 0.0);
        const yVec = new geometry_core_1.Vector3d(0.0, seg.delta.y, 0.0);
        const zVec = new geometry_core_1.Vector3d(0.0, 0.0, seg.delta.z);
        seg.refAxes.multiplyVectorInPlace(xVec);
        seg.refAxes.multiplyVectorInPlace(yVec);
        seg.refAxes.multiplyVectorInPlace(zVec);
        const builderAxes = context.createGraphicBuilder(rendering_1.GraphicType.WorldOverlay);
        let basePt = seg.start.clone();
        if (xVec.magnitude() > 1.0e-5) {
            const segPoints = [];
            segPoints.push(basePt);
            basePt = basePt.plus(xVec);
            segPoints.push(basePt);
            const colorX = imodeljs_common_1.ColorDef.red.adjustForContrast(context.viewport.view.backgroundColor);
            builderAxes.setSymbology(colorX, imodeljs_common_1.ColorDef.black, 5);
            builderAxes.addLineString(segPoints);
        }
        if (yVec.magnitude() > 1.0e-5) {
            const segPoints = [];
            segPoints.push(basePt);
            basePt = basePt.plus(yVec);
            segPoints.push(basePt);
            const colorY = imodeljs_common_1.ColorDef.green.adjustForContrast(context.viewport.view.backgroundColor);
            builderAxes.setSymbology(colorY, imodeljs_common_1.ColorDef.black, 5);
            builderAxes.addLineString(segPoints);
        }
        if (zVec.magnitude() > 1.0e-5) {
            const segPoints = [];
            segPoints.push(basePt);
            basePt = basePt.plus(zVec);
            segPoints.push(basePt);
            const colorZ = imodeljs_common_1.ColorDef.blue.adjustForContrast(context.viewport.view.backgroundColor);
            builderAxes.setSymbology(colorZ, imodeljs_common_1.ColorDef.black, 5);
            builderAxes.addLineString(segPoints);
        }
        const segGlow = context.viewport.hilite.color.clone();
        segGlow.setAlpha(50);
        builderAxes.setSymbology(segGlow, imodeljs_common_1.ColorDef.black, 8);
        builderAxes.addLineString([seg.start, seg.end]);
        context.addDecorationFromBuilder(builderAxes);
    }
    decorate(context) {
        if (!context.viewport.view.isSpatialView())
            return;
        if (this._locationData.length > 0) {
            const ev = new Tool_1.BeButtonEvent();
            IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
            const tmpPoints = [];
            for (const loc of this._locationData)
                tmpPoints.push(loc.point); // Deep copy not necessary...
            tmpPoints.push(ev.point);
            const builderDynVis = context.createGraphicBuilder(rendering_1.GraphicType.WorldDecoration);
            const colorDynVis = context.viewport.hilite.color;
            builderDynVis.setSymbology(colorDynVis, imodeljs_common_1.ColorDef.black, 3);
            builderDynVis.addLineString(tmpPoints);
            context.addDecorationFromBuilder(builderDynVis);
            const builderDynHid = context.createGraphicBuilder(rendering_1.GraphicType.WorldOverlay);
            const colorDynHid = colorDynVis.clone();
            colorDynHid.setAlpha(100);
            builderDynHid.setSymbology(colorDynHid, imodeljs_common_1.ColorDef.black, 1);
            builderDynHid.addLineString(tmpPoints);
            context.addDecorationFromBuilder(builderDynHid);
            this.displayDynamicDistance(context, tmpPoints);
        }
        if (this._acceptedSegments.length > 0) {
            const builderAccVis = context.createGraphicBuilder(rendering_1.GraphicType.WorldDecoration);
            const builderAccHid = context.createGraphicBuilder(rendering_1.GraphicType.WorldOverlay);
            const colorAccVis = imodeljs_common_1.ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);
            const colorAccHid = colorAccVis.clone();
            colorAccHid.setAlpha(100);
            builderAccVis.setSymbology(colorAccVis, imodeljs_common_1.ColorDef.black, 3);
            builderAccHid.setSymbology(colorAccHid, imodeljs_common_1.ColorDef.black, 1);
            for (const seg of this._acceptedSegments) {
                builderAccVis.addLineString([seg.start, seg.end]);
                builderAccHid.addLineString([seg.start, seg.end]);
                seg.marker.addDecoration(context);
                if (seg.marker.isSelected)
                    this.displayDelta(context, seg);
            }
            context.addDecorationFromBuilder(builderAccVis);
            context.addDecorationFromBuilder(builderAccHid);
        }
        if (undefined !== this._totalDistanceMarker)
            this._totalDistanceMarker.addDecoration(context);
        const snapPoints = this.getSnapPoints();
        if (undefined === snapPoints)
            return;
        if (undefined === this._snapGeomId)
            this._snapGeomId = this.iModel.transientIds.next;
        const builderSnapPts = context.createGraphicBuilder(rendering_1.GraphicType.WorldOverlay, undefined, this._snapGeomId);
        const colorAccPts = imodeljs_common_1.ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);
        builderSnapPts.setSymbology(colorAccPts, imodeljs_common_1.ColorDef.black, 7);
        builderSnapPts.addPointString(snapPoints);
        context.addDecorationFromBuilder(builderSnapPts);
    }
    decorateSuspended(context) { this.decorate(context); }
    async onMouseMotion(ev) { if (this._locationData.length > 0 && undefined !== ev.viewport)
        ev.viewport.invalidateDecorations(); }
    reportMeasurements() {
        if (undefined === this._totalDistanceMarker)
            return;
        const briefMsg = IModelApp_1.IModelApp.i18n.translateKeys(this._acceptedSegments.length > 1 ? "%{CoreTools:tools.Measure.Labels.CumulativeDistance}: " : "%{CoreTools:tools.Measure.Labels.Distance}: ") + this._totalDistanceMarker.label;
        const msgDetail = new NotificationManager_1.NotifyMessageDetails(NotificationManager_1.OutputMessagePriority.Info, briefMsg, undefined, NotificationManager_1.OutputMessageType.InputField);
        IModelApp_1.IModelApp.notifications.outputMessage(msgDetail);
    }
    async updateTotals() {
        this._totalDistance = 0.0;
        this._totalDistanceMarker = undefined;
        for (const seg of this._acceptedSegments)
            this._totalDistance += seg.distance;
        if (0.0 === this._totalDistance)
            return;
        const formatterSpec = await IModelApp_1.IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityFormatter_1.QuantityType.Length);
        if (undefined === formatterSpec)
            return;
        const formattedTotalDistance = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(this._totalDistance, formatterSpec);
        this._totalDistanceMarker = new MeasureLabel(this._acceptedSegments[this._acceptedSegments.length - 1].end, formattedTotalDistance);
        this.reportMeasurements();
    }
    async getMarkerToolTip(distance, slope, start, end, delta) {
        const toolTip = document.createElement("div");
        const distanceFormatterSpec = await IModelApp_1.IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityFormatter_1.QuantityType.Length);
        if (undefined === distanceFormatterSpec)
            return toolTip;
        let toolTipHtml = "";
        const formattedDistance = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(distance, distanceFormatterSpec);
        toolTipHtml += IModelApp_1.IModelApp.i18n.translateKeys("<b>%{CoreTools:tools.Measure.Labels.Distance}:</b> ") + formattedDistance + "<br>";
        const angleFormatterSpec = await IModelApp_1.IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityFormatter_1.QuantityType.Angle);
        if (undefined !== angleFormatterSpec) {
            const formattedSlope = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(slope, angleFormatterSpec);
            toolTipHtml += IModelApp_1.IModelApp.i18n.translateKeys("<b>%{CoreTools:tools.Measure.Labels.Slope}:</b> ") + formattedSlope + "<br>";
        }
        const coordFormatterSpec = await IModelApp_1.IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityFormatter_1.QuantityType.Coordinate);
        if (undefined !== coordFormatterSpec) {
            let startAdjusted = start;
            let endAdjusted = end;
            if (undefined !== this.targetView && this.targetView.view.isSpatialView()) {
                const globalOrigin = this.iModel.globalOrigin;
                startAdjusted = startAdjusted.minus(globalOrigin);
                endAdjusted = endAdjusted.minus(globalOrigin);
            }
            const formattedStartX = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(startAdjusted.x, coordFormatterSpec);
            const formattedStartY = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(startAdjusted.y, coordFormatterSpec);
            const formattedStartZ = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(startAdjusted.z, coordFormatterSpec);
            toolTipHtml += IModelApp_1.IModelApp.i18n.translateKeys("<b>%{CoreTools:tools.Measure.Labels.StartCoord}:</b> ") + formattedStartX + ", " + formattedStartY + ", " + formattedStartZ + "<br>";
            const formattedEndX = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(endAdjusted.x, coordFormatterSpec);
            const formattedEndY = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(endAdjusted.y, coordFormatterSpec);
            const formattedEndZ = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(endAdjusted.z, coordFormatterSpec);
            toolTipHtml += IModelApp_1.IModelApp.i18n.translateKeys("<b>%{CoreTools:tools.Measure.Labels.EndCoord}:</b> ") + formattedEndX + ", " + formattedEndY + ", " + formattedEndZ + "<br>";
        }
        if (undefined !== delta) {
            const formattedDeltaX = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.x), distanceFormatterSpec);
            const formattedDeltaY = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.y), distanceFormatterSpec);
            const formattedDeltaZ = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.z), distanceFormatterSpec);
            toolTipHtml += IModelApp_1.IModelApp.i18n.translateKeys("<b>%{CoreTools:tools.Measure.Labels.Delta}:</b> ") + formattedDeltaX + ", " + formattedDeltaY + ", " + formattedDeltaZ + "<br>";
        }
        toolTip.innerHTML = toolTipHtml;
        return toolTip;
    }
    async updateSelectedMarkerToolTip(seg, ev) {
        seg.marker.title = await this.getMarkerToolTip(seg.distance, seg.slope, seg.start, seg.end, seg.marker.isSelected ? seg.delta : undefined);
        if (undefined === ev.viewport || !IModelApp_1.IModelApp.notifications.isToolTipOpen)
            return;
        IModelApp_1.IModelApp.notifications.clearToolTip();
        ev.viewport.openToolTip(seg.marker.title, ev.viewPoint);
    }
    async acceptNewSegments() {
        if (this._locationData.length > 1) {
            for (let i = 0; i <= this._locationData.length - 2; i++) {
                const start = this._locationData[i].point;
                const end = this._locationData[i + 1].point;
                const distance = start.distance(end);
                const xyDist = start.distanceXY(end);
                const zDist = end.z - start.z;
                const slope = (0.0 === xyDist ? Math.PI : Math.atan(zDist / xyDist));
                const delta = geometry_core_1.Vector3d.createStartEnd(start, end);
                const refAxes = this._locationData[i].refAxes;
                refAxes.multiplyTransposeVectorInPlace(delta);
                const toolTip = await this.getMarkerToolTip(distance, slope, start, end);
                const marker = new MeasureMarker((this._acceptedSegments.length + 1).toString(), toolTip, start.interpolate(0.5, end), geometry_core_1.Point2d.create(25, 25));
                const segMarkerButtonFunc = (ev) => {
                    if (ev.isDown)
                        return true;
                    let selectedMarker;
                    for (const seg of this._acceptedSegments) {
                        if (!seg.marker.pick(ev.viewPoint))
                            continue;
                        selectedMarker = (seg.marker.isSelected ? undefined : seg.marker);
                        break;
                    }
                    for (const seg of this._acceptedSegments) {
                        const wasSelected = seg.marker.isSelected;
                        seg.marker.isSelected = (seg.marker === selectedMarker);
                        if (wasSelected !== seg.marker.isSelected)
                            this.updateSelectedMarkerToolTip(seg, ev); // tslint:disable-line:no-floating-promises
                    }
                    if (undefined !== ev.viewport)
                        ev.viewport.invalidateDecorations();
                    return true;
                };
                marker.onMouseButton = segMarkerButtonFunc;
                this._acceptedSegments.push({ distance, slope, start, end, delta, refAxes, marker });
            }
        }
        this._locationData.length = 0;
        await this.updateTotals();
    }
    getReferenceAxes(vp) {
        const refAxes = geometry_core_1.Matrix3d.createIdentity();
        if (undefined !== vp && vp.isContextRotationRequired)
            vp.getAuxCoordRotation(refAxes);
        return refAxes;
    }
    async onDataButtonDown(ev) {
        const point = ev.point.clone();
        const refAxes = this.getReferenceAxes(ev.viewport);
        const zDir = refAxes.columnZ();
        const normal = refAxes.columnZ();
        const tangent = refAxes.columnX();
        const snap = IModelApp_1.IModelApp.accuSnap.getCurrSnapDetail();
        // Report xyz delta relative to world up. The surface normal and edge tangent help determine the rotation about z...
        if (undefined !== snap) {
            if (undefined !== snap.primitive) {
                const locDetail = snap.primitive.closestPoint(point, false);
                if (undefined !== locDetail && (HitDetail_1.HitGeomType.Segment === snap.geomType || snap.primitive.isInPlane(geometry_core_1.Plane3dByOriginAndUnitNormal.create(point, undefined !== snap.normal ? snap.normal : normal)))) {
                    const locRay = snap.primitive.fractionToPointAndUnitTangent(locDetail.fraction);
                    tangent.setFrom(locRay.direction);
                    if (undefined !== snap.normal)
                        normal.setFrom(snap.normal);
                }
            }
            else if (undefined !== snap.normal) {
                normal.setFrom(snap.normal);
            }
        }
        if (!normal.isParallelTo(zDir, true)) {
            const yDir = zDir.unitCrossProduct(normal);
            if (undefined !== yDir) {
                yDir.unitCrossProduct(zDir, normal);
                geometry_core_1.Matrix3d.createColumnsInAxisOrder(geometry_core_1.AxisOrder.ZXY, normal, yDir, zDir, refAxes);
            }
        }
        else if (!tangent.isParallelTo(zDir, true)) {
            const yDir = zDir.unitCrossProduct(tangent);
            if (undefined !== yDir) {
                yDir.unitCrossProduct(zDir, tangent);
                geometry_core_1.Matrix3d.createColumnsInAxisOrder(geometry_core_1.AxisOrder.XYZ, tangent, yDir, zDir, refAxes);
            }
        }
        this._locationData.push({ point, refAxes });
        if (this._locationData.length > 1 && !ev.isControlKey)
            await this.acceptNewSegments();
        this.setupAndPromptForNextAction();
        if (undefined !== ev.viewport)
            ev.viewport.invalidateDecorations();
        return Tool_1.EventHandled.No;
    }
    async onResetButtonUp(ev) {
        if (0 === this._locationData.length) {
            this.onReinitialize();
            return Tool_1.EventHandled.No;
        }
        await this.acceptNewSegments();
        this.setupAndPromptForNextAction();
        if (undefined !== ev.viewport)
            ev.viewport.invalidateDecorations();
        return Tool_1.EventHandled.No;
    }
    async onUndoPreviousStep() {
        if (0 === this._locationData.length && 0 === this._acceptedSegments.length)
            return false;
        if (0 !== this._locationData.length) {
            this._locationData.pop();
        }
        else if (0 !== this._acceptedSegments.length) {
            this._acceptedSegments.pop();
        }
        if (0 === this._locationData.length && 0 === this._acceptedSegments.length) {
            this.onReinitialize();
        }
        else {
            await this.updateTotals();
            this.setupAndPromptForNextAction();
        }
        return true;
    }
    async onKeyTransition(wentDown, keyEvent) {
        if (Tool_1.EventHandled.Yes === await super.onKeyTransition(wentDown, keyEvent))
            return Tool_1.EventHandled.Yes;
        return (wentDown && AccuDrawTool_1.AccuDrawShortcuts.processShortcutKey(keyEvent)) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
    onRestartTool() {
        const tool = new MeasureDistanceTool();
        if (!tool.run())
            this.exitTool();
    }
}
MeasureDistanceTool.toolId = "Measure.Distance";
exports.MeasureDistanceTool = MeasureDistanceTool;
/** @alpha */
class MeasureLocationTool extends PrimitiveTool_1.PrimitiveTool {
    constructor() {
        super(...arguments);
        this._acceptedLocations = [];
    }
    isCompatibleViewport(vp, isSelectedViewChange) { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.isSpatialView()); }
    requireWriteableTarget() { return false; }
    onPostInstall() { super.onPostInstall(); this.setupAndPromptForNextAction(); }
    onUnsuspend() { this.showPrompt(); }
    showPrompt() { IModelApp_1.IModelApp.notifications.outputPromptByKey("CoreTools:tools.Measure.Location.Prompts.EnterPoint"); }
    setupAndPromptForNextAction() {
        IModelApp_1.IModelApp.accuSnap.enableSnap(true);
        this.showPrompt();
    }
    async getMarkerToolTip(point) {
        const toolTip = document.createElement("div");
        let toolTipHtml = "";
        const coordFormatterSpec = await IModelApp_1.IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityFormatter_1.QuantityType.Coordinate);
        if (undefined !== coordFormatterSpec) {
            let pointAdjusted = point;
            if (undefined !== this.targetView && this.targetView.view.isSpatialView()) {
                const globalOrigin = this.iModel.globalOrigin;
                pointAdjusted = pointAdjusted.minus(globalOrigin);
            }
            const formattedPointX = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(pointAdjusted.x, coordFormatterSpec);
            const formattedPointY = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(pointAdjusted.y, coordFormatterSpec);
            const formattedPointZ = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(pointAdjusted.z, coordFormatterSpec);
            if (undefined !== formattedPointX && undefined !== formattedPointY && undefined !== formattedPointZ)
                toolTipHtml += IModelApp_1.IModelApp.i18n.translateKeys("<b>%{CoreTools:tools.Measure.Labels.Coordinate}:</b> ") + formattedPointX + ", " + formattedPointY + ", " + formattedPointZ + "<br>";
        }
        if (undefined !== this.targetView && this.targetView.view.isSpatialView()) {
            const latLongFormatterSpec = await IModelApp_1.IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityFormatter_1.QuantityType.LatLong);
            if (undefined !== latLongFormatterSpec && undefined !== coordFormatterSpec) {
                try {
                    const cartographic = await this.iModel.spatialToCartographic(point);
                    const formattedLat = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(Math.abs(cartographic.latitude), latLongFormatterSpec);
                    const formattedLong = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(Math.abs(cartographic.longitude), latLongFormatterSpec);
                    const formattedHeight = IModelApp_1.IModelApp.quantityFormatter.formatQuantity(cartographic.height, coordFormatterSpec);
                    const latDir = IModelApp_1.IModelApp.i18n.translateKeys(cartographic.latitude < 0 ? "%{CoreTools:tools.Measure.Labels.S}" : "%{CoreTools:tools.Measure.Labels.N}");
                    const longDir = IModelApp_1.IModelApp.i18n.translateKeys(cartographic.longitude < 0 ? "%{CoreTools:tools.Measure.Labels.W}" : "%{CoreTools:tools.Measure.Labels.E}");
                    toolTipHtml += IModelApp_1.IModelApp.i18n.translateKeys("<b>%{CoreTools:tools.Measure.Labels.LatLong}:</b> ") + formattedLat + latDir + ", " + formattedLong + longDir + "<br>";
                    toolTipHtml += IModelApp_1.IModelApp.i18n.translateKeys("<b>%{CoreTools:tools.Measure.Labels.Altitude}:</b> ") + formattedHeight + "<br>";
                }
                catch (_a) { }
            }
        }
        toolTip.innerHTML = toolTipHtml;
        return toolTip;
    }
    decorate(context) { if (!context.viewport.view.isSpatialView())
        return; this._acceptedLocations.forEach((marker) => marker.addDecoration(context)); }
    decorateSuspended(context) { this.decorate(context); }
    reportMeasurements() { }
    async onDataButtonDown(ev) {
        const point = ev.point.clone();
        const toolTip = await this.getMarkerToolTip(point);
        const marker = new MeasureMarker((this._acceptedLocations.length + 1).toString(), toolTip, point, geometry_core_1.Point2d.create(25, 25));
        const noOpButtonFunc = (_ev) => true;
        marker.onMouseButton = noOpButtonFunc;
        this._acceptedLocations.push(marker);
        this.reportMeasurements();
        this.setupAndPromptForNextAction();
        if (undefined !== ev.viewport)
            ev.viewport.invalidateDecorations();
        return Tool_1.EventHandled.No;
    }
    async onResetButtonUp(_ev) {
        this.onReinitialize();
        return Tool_1.EventHandled.No;
    }
    async onUndoPreviousStep() {
        if (0 === this._acceptedLocations.length)
            return false;
        this._acceptedLocations.pop();
        if (0 === this._acceptedLocations.length) {
            this.onReinitialize();
        }
        else {
            this.reportMeasurements();
            this.setupAndPromptForNextAction();
        }
        return true;
    }
    onRestartTool() {
        const tool = new MeasureLocationTool();
        if (!tool.run())
            this.exitTool();
    }
}
MeasureLocationTool.toolId = "Measure.Location";
exports.MeasureLocationTool = MeasureLocationTool;


/***/ }),

/***/ "./lib/tools/PluginTool.js":
/*!*********************************!*\
  !*** ./lib/tools/PluginTool.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const Plugin_1 = __webpack_require__(/*! ../Plugin */ "./lib/Plugin.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
/** An Immediate Tool that starts the process of loading an iModelJs plugin. */
class PluginTool extends Tool_1.Tool {
    run(args) {
        if (args && args.length > 0 && args[0]) {
            Plugin_1.PluginAdmin.loadPlugin(args[0], args.slice(1))
                .then(() => { })
                .catch((_err) => { IModelApp_1.IModelApp.notifications.outputMessage(IModelApp_1.IModelApp.i18n.translate("PluginErrors.UnableToLoad", { pluginName: args[0] })); });
        }
        return true;
    }
}
PluginTool.toolId = "Plugin";
exports.PluginTool = PluginTool;


/***/ }),

/***/ "./lib/tools/PrimitiveTool.js":
/*!************************************!*\
  !*** ./lib/tools/PrimitiveTool.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const AccuDrawTool_1 = __webpack_require__(/*! ./AccuDrawTool */ "./lib/tools/AccuDrawTool.js");
const NotificationManager_1 = __webpack_require__(/*! ../NotificationManager */ "./lib/NotificationManager.js");
/** The PrimitiveTool class can be used to implement tools to create or modify geometric elements.
 * @see [Writing a PrimitiveTool]($docs/learning/frontend/primitivetools.md)
 * @public
 */
class PrimitiveTool extends Tool_1.InteractiveTool {
    constructor() {
        super(...arguments);
        this.targetIsLocked = false; // If target model is known, set this to true in constructor and override getTargetModel.
    }
    /** Get the iModel the tool is operating against. */
    get iModel() { return this.targetView.view.iModel; }
    /**
     * Establish this tool as the active PrimitiveTool.
     * @return true if this tool was installed (though it may have exited too)
     */
    run() {
        const { toolAdmin, viewManager } = IModelApp_1.IModelApp;
        if (!this.isCompatibleViewport(viewManager.selectedView, false) || !toolAdmin.onInstallTool(this))
            return false;
        toolAdmin.startPrimitiveTool(this);
        toolAdmin.onPostInstallTool(this);
        return true;
    }
    /**
     * Determine whether the supplied Viewport is compatible with this tool.
     * @param vp the Viewport to check
     */
    isCompatibleViewport(vp, isSelectedViewChange) {
        if (undefined === vp)
            return false; // No views are open...
        const view = vp.view;
        const iModel = view.iModel;
        if (this.requireWriteableTarget() && iModel.isReadonly)
            return false; // Tool can't be used when iModel is read only.
        if (undefined === this.targetView)
            this.targetView = vp; // Update target to newly selected view.
        if (!this.targetIsLocked) {
            if (isSelectedViewChange)
                this.targetView = vp; // Update target to newly selected view.
            return true; // Any type of model/view is still ok and target is still free to change.
        }
        if (iModel !== this.iModel)
            return false; // Once a ViewState has been established, only accept viewport showing the same iModel.
        if (this.targetModelId && !view.viewsModel(this.targetModelId))
            return false; // Only allow view where target is being viewed.
        return true;
    }
    /**
     * Checks that the adjusted point from the supplied button event is within the project extents for spatial views. The range of physical geometry
     * should always be fully inside the project extents. Only checking the adjusted point won't absolutely guarantee that a tool doesn't create/move geometry
     * outside the project extents, but it will be sufficient to handle most cases and provide good feedback to the user.
     * @return true if ev is acceptable.
     */
    isValidLocation(ev, isButtonEvent) {
        const vp = ev.viewport;
        if (undefined === vp)
            return false;
        if (isButtonEvent && Tool_1.BeButton.Data !== ev.button)
            return true;
        const view = vp.view;
        if (!view.isSpatialView())
            return true;
        // NOTE: If points aren't being adjusted then the tool shouldn't be creating geometry currently (ex. locating elements) and we shouldn't filter point...
        if (0 !== (IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr & Tool_1.CoordinateLockOverrides.ACS))
            return true;
        // We know the tool isn't doing a locate, we don't know what it will do with this point. Minimize erroneous filtering by restricting the check to when AccuSnap is tool enable (not user enabled)...
        if (!IModelApp_1.IModelApp.accuSnap.isSnapEnabled)
            return true;
        const extents = view.iModel.projectExtents;
        if (extents.containsPoint(ev.point))
            return true;
        if (isButtonEvent && ev.isDown)
            IModelApp_1.IModelApp.notifications.outputMessage(new NotificationManager_1.NotifyMessageDetails(NotificationManager_1.OutputMessagePriority.Error, IModelApp_1.IModelApp.i18n.translate("CoreTools:tools.ElementSet.Error.ProjectExtents")));
        return false;
    }
    /** Called on data button down event to lock the tool to its current target model. */
    autoLockTarget() { if (undefined === this.targetView)
        return; this.targetIsLocked = true; }
    /**  Returns the prompt based on the tool's current state. */
    getPrompt() { return ""; }
    /** Called from isCompatibleViewport to check for a read only iModel, which is not a valid target for tools that create or modify elements. */
    requireWriteableTarget() { return true; }
    /**
     * Called when active view changes. Tool may choose to restart or exit based on current view type.
     * @param _previous The previously active view.
     * @param current The new active view.
     */
    onSelectedViewportChanged(_previous, current) {
        if (this.isCompatibleViewport(current, true))
            return;
        this.onRestartTool();
    }
    /**
     * Called to reset tool to initial state. PrimitiveTool implements this method to call onRestartTool.
     */
    onReinitialize() { this.onRestartTool(); }
    exitTool() { IModelApp_1.IModelApp.toolAdmin.startDefaultTool(); }
    /**
     * Called to reverse to a previous tool state (ex. undo last data button).
     * @return false to instead reverse the most recent transaction.
     */
    async onUndoPreviousStep() { return false; }
    /** @internal */
    async undoPreviousStep() {
        if (!await this.onUndoPreviousStep())
            return false;
        AccuDrawTool_1.AccuDrawShortcuts.processPendingHints(); // Process any hints the active tool setup in _OnUndoPreviousStep now...
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        IModelApp_1.IModelApp.toolAdmin.updateDynamics();
        return true;
    }
    /**
     * Called to reinstate to a previous tool state (ex. redo last data button).
     * @return false to instead reinstate the most recent transaction.
     */
    async onRedoPreviousStep() { return false; }
    /** @internal */
    async redoPreviousStep() {
        if (!await this.onRedoPreviousStep())
            return false;
        AccuDrawTool_1.AccuDrawShortcuts.processPendingHints(); // Process any hints the active tool setup in _OnUndoPreviousStep now...
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        IModelApp_1.IModelApp.toolAdmin.updateDynamics();
        return true;
    }
    /**
     * Tools need to call SaveChanges to commit any elements they have added/changes they have made.
     * This helper method supplies the tool name for the undo string to iModel.saveChanges.
     */
    async saveChanges() { return this.iModel.saveChanges(this.toolId); }
}
exports.PrimitiveTool = PrimitiveTool;


/***/ }),

/***/ "./lib/tools/SelectTool.js":
/*!*********************************!*\
  !*** ./lib/tools/SelectTool.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module SelectionSet */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const ElementLocateManager_1 = __webpack_require__(/*! ../ElementLocateManager */ "./lib/ElementLocateManager.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const EditorParams_1 = __webpack_require__(/*! ../properties/EditorParams */ "./lib/properties/EditorParams.js");
const ToolSettingsValue_1 = __webpack_require__(/*! ../properties/ToolSettingsValue */ "./lib/properties/ToolSettingsValue.js");
const Viewport_1 = __webpack_require__(/*! ../Viewport */ "./lib/Viewport.js");
const PrimitiveTool_1 = __webpack_require__(/*! ./PrimitiveTool */ "./lib/tools/PrimitiveTool.js");
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const ToolAdmin_1 = __webpack_require__(/*! ./ToolAdmin */ "./lib/tools/ToolAdmin.js");
// cSpell:ignore buttongroup
/** The method for choosing elements with the [[SelectionTool]]
 * @public
 */
var SelectionMethod;
(function (SelectionMethod) {
    /** Identify element(s) by picking for drag selection (inside/overlap for drag box selection determined by point direction and shift key) */
    SelectionMethod[SelectionMethod["Pick"] = 0] = "Pick";
    /** Identify elements by overlap with crossing line */
    SelectionMethod[SelectionMethod["Line"] = 1] = "Line";
    /** Identify elements by box selection (inside/overlap for box selection determined by point direction and shift key) */
    SelectionMethod[SelectionMethod["Box"] = 2] = "Box";
})(SelectionMethod = exports.SelectionMethod || (exports.SelectionMethod = {}));
/** The mode for choosing elements with the [[SelectionTool]]
 * @public
 */
var SelectionMode;
(function (SelectionMode) {
    /** Identified elements replace the current selection set (use control key to add or remove) */
    SelectionMode[SelectionMode["Replace"] = 0] = "Replace";
    /** Identified elements are added to the current selection set */
    SelectionMode[SelectionMode["Add"] = 1] = "Add";
    /** Identified elements are removed from the current selection set */
    SelectionMode[SelectionMode["Remove"] = 2] = "Remove";
})(SelectionMode = exports.SelectionMode || (exports.SelectionMode = {}));
/** The processing method to use to update the current selection.
 * @public
 */
var SelectionProcessing;
(function (SelectionProcessing) {
    /** Add element to selection. */
    SelectionProcessing[SelectionProcessing["AddElementToSelection"] = 0] = "AddElementToSelection";
    /** Remove element from selection. */
    SelectionProcessing[SelectionProcessing["RemoveElementFromSelection"] = 1] = "RemoveElementFromSelection";
    /** If element is in selection remove it, else add it. */
    SelectionProcessing[SelectionProcessing["InvertElementInSelection"] = 2] = "InvertElementInSelection";
    /** Replace current selection with element. */
    SelectionProcessing[SelectionProcessing["ReplaceSelectionWithElement"] = 3] = "ReplaceSelectionWithElement";
})(SelectionProcessing = exports.SelectionProcessing || (exports.SelectionProcessing = {}));
/** Tool for picking a set of elements of interest, selected by the user.
 * @public
 */
class SelectionTool extends PrimitiveTool_1.PrimitiveTool {
    constructor() {
        super(...arguments);
        this._isSelectByPoints = false;
        this._isSuspended = false;
        this._points = [];
        this._selectionMethodValue = new ToolSettingsValue_1.ToolSettingsValue(SelectionMethod.Pick);
        this._selectionModeValue = new ToolSettingsValue_1.ToolSettingsValue(SelectionMode.Replace);
    }
    requireWriteableTarget() { return false; }
    autoLockTarget() { } // NOTE: For selecting elements we only care about iModel, so don't lock target model automatically.
    wantSelectionClearOnMiss(_ev) { return SelectionMode.Replace === this.selectionMode; }
    wantEditManipulators() { return SelectionMethod.Pick === this.selectionMethod; }
    wantPickableDecorations() { return this.wantEditManipulators(); } // Allow pickable decorations selection to be independent of manipulators...
    wantToolSettings() { return false; }
    get selectionMethod() { return this._selectionMethodValue.value; }
    set selectionMethod(method) { this._selectionMethodValue.value = method; }
    get selectionMode() { return this._selectionModeValue.value; }
    set selectionMode(mode) { this._selectionModeValue.value = mode; }
    static methodsMessage(str) { return IModelApp_1.IModelApp.i18n.translate("CoreTools:tools.ElementSet.SelectionMethods." + str); }
    /* The property descriptions used to generate ToolSettings UI. */
    static _getMethodsDescription() {
        return {
            name: SelectionTool._methodsName,
            displayLabel: IModelApp_1.IModelApp.i18n.translate("CoreTools:tools.ElementSet.Prompts.Mode"),
            typename: "enum",
            editor: {
                name: "enum-buttongroup",
                params: [
                    {
                        type: EditorParams_1.PropertyEditorParamTypes.ButtonGroupData,
                        buttons: [
                            { iconClass: "icon icon-select-single" },
                            { iconClass: "icon icon-select-line" },
                            { iconClass: "icon icon-select-box" },
                        ],
                    },
                ],
            },
            enum: {
                choices: [
                    { label: SelectionTool.methodsMessage("Pick"), value: SelectionMethod.Pick },
                    { label: SelectionTool.methodsMessage("Line"), value: SelectionMethod.Line },
                    { label: SelectionTool.methodsMessage("Box"), value: SelectionMethod.Box },
                ],
            },
        };
    }
    static modesMessage(str) { return IModelApp_1.IModelApp.i18n.translate("CoreTools:tools.ElementSet.SelectionModes." + str); }
    /* The property descriptions used to generate ToolSettings UI. */
    static _getModesDescription() {
        return {
            name: SelectionTool._modesName,
            displayLabel: "",
            typename: "enum",
            editor: {
                name: "enum-buttongroup",
                params: [
                    {
                        type: EditorParams_1.PropertyEditorParamTypes.ButtonGroupData,
                        buttons: [
                            { iconClass: "icon icon-replace" },
                            { iconClass: "icon icon-select-plus" },
                            {
                                iconClass: "icon icon-select-minus",
                                isEnabledFunction: () => { const tool = IModelApp_1.IModelApp.toolAdmin.activeTool; return tool instanceof PrimitiveTool_1.PrimitiveTool ? tool.iModel.selectionSet.isActive : false; },
                            },
                        ],
                    },
                    {
                        type: EditorParams_1.PropertyEditorParamTypes.SuppressEditorLabel,
                        suppressLabelPlaceholder: true,
                    },
                ],
            },
            enum: {
                choices: [
                    { label: SelectionTool.modesMessage("Replace"), value: SelectionMode.Replace },
                    { label: SelectionTool.modesMessage("Add"), value: SelectionMode.Add },
                    { label: SelectionTool.modesMessage("Remove"), value: SelectionMode.Remove },
                ],
            },
        };
    }
    showPrompt(mode, method) {
        let msg = "IdentifyElement";
        switch (mode) {
            case SelectionMode.Replace:
                switch (method) {
                    case SelectionMethod.Line:
                        msg = "IdentifyLine";
                        break;
                    case SelectionMethod.Box:
                        msg = "IdentifyBox";
                        break;
                }
                break;
            case SelectionMode.Add:
                switch (method) {
                    case SelectionMethod.Pick:
                        msg = "IdentifyElementAdd";
                        break;
                    case SelectionMethod.Line:
                        msg = "IdentifyLineAdd";
                        break;
                    case SelectionMethod.Box:
                        msg = "IdentifyBoxAdd";
                        break;
                }
                break;
            case SelectionMode.Remove:
                switch (method) {
                    case SelectionMethod.Pick:
                        msg = "IdentifyElementRemove";
                        break;
                    case SelectionMethod.Line:
                        msg = "IdentifyLineRemove";
                        break;
                    case SelectionMethod.Box:
                        msg = "IdentifyBoxRemove";
                        break;
                }
                break;
        }
        IModelApp_1.IModelApp.notifications.outputPromptByKey("CoreTools:tools.ElementSet.Prompts." + msg);
    }
    initSelectTool() {
        const method = this.selectionMethod;
        const mode = this.selectionMode;
        const enableLocate = SelectionMethod.Pick === method;
        this._isSelectByPoints = false;
        this._points.length = 0;
        this.initLocateElements(enableLocate, false, enableLocate ? "default" : IModelApp_1.IModelApp.viewManager.crossHairCursor, Tool_1.CoordinateLockOverrides.All);
        IModelApp_1.IModelApp.locateManager.options.allowDecorations = true; // Always locate to display tool tip even if we reject for adding to selection set...
        this.showPrompt(mode, method);
    }
    updateSelection(elementId, process) {
        let returnValue = false;
        switch (process) {
            case SelectionProcessing.AddElementToSelection:
                returnValue = this.iModel.selectionSet.add(elementId);
                break;
            case SelectionProcessing.RemoveElementFromSelection:
                returnValue = this.iModel.selectionSet.remove(elementId);
                break;
            case SelectionProcessing.InvertElementInSelection: // (if element is in selection remove it else add it.)
                returnValue = this.iModel.selectionSet.invert(elementId);
                break;
            case SelectionProcessing.ReplaceSelectionWithElement:
                this.iModel.selectionSet.replace(elementId);
                returnValue = true;
                break;
            default:
                return false;
        }
        // always force UI to sync display of options since the select option of Remove should only be enabled if the selection set has elements.
        if (returnValue)
            this.syncSelectionMode();
        return returnValue;
    }
    async processSelection(elementId, process) { return this.updateSelection(elementId, process); }
    useOverlapSelection(ev) {
        if (undefined === ev.viewport)
            return false;
        const pt1 = ev.viewport.worldToView(this._points[0]);
        const pt2 = ev.viewport.worldToView(ev.point);
        const overlapMode = (pt1.x > pt2.x);
        return (ev.isShiftKey ? !overlapMode : overlapMode); // Shift inverts inside/overlap selection...
    }
    selectByPointsDecorate(context) {
        if (!this._isSelectByPoints)
            return;
        const ev = new Tool_1.BeButtonEvent();
        IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev);
        if (undefined === ev.viewport)
            return;
        const vp = context.viewport;
        const bestContrastIsBlack = (imodeljs_common_1.ColorDef.black === vp.getContrastToBackgroundColor());
        const crossingLine = (SelectionMethod.Line === this.selectionMethod || (SelectionMethod.Pick === this.selectionMethod && Tool_1.BeButton.Reset === ev.button));
        const overlapSelection = (crossingLine || this.useOverlapSelection(ev));
        const position = vp.worldToView(this._points[0]);
        position.x = Math.floor(position.x) + 0.5;
        position.y = Math.floor(position.y) + 0.5;
        const position2 = vp.worldToView(ev.point);
        position2.x = Math.floor(position2.x) + 0.5;
        position2.y = Math.floor(position2.y) + 0.5;
        const offset = position2.minus(position);
        const drawDecoration = (ctx) => {
            ctx.strokeStyle = bestContrastIsBlack ? "black" : "white";
            ctx.lineWidth = 1;
            if (overlapSelection)
                ctx.setLineDash([5, 5]);
            if (crossingLine) {
                ctx.beginPath();
                ctx.moveTo(0, 0);
                ctx.lineTo(offset.x, offset.y);
                ctx.stroke();
            }
            else {
                ctx.strokeRect(0, 0, offset.x, offset.y);
                ctx.fillStyle = bestContrastIsBlack ? "rgba(0,0,0,.06)" : "rgba(255,255,255,.06)";
                ctx.fillRect(0, 0, offset.x, offset.y);
            }
        };
        context.addCanvasDecoration({ position, drawDecoration });
    }
    selectByPointsProcess(origin, corner, ev, method, overlap) {
        const vp = ev.viewport;
        if (!vp)
            return;
        const pts = [];
        pts[0] = new geometry_core_1.Point2d(Math.floor(origin.x + 0.5), Math.floor(origin.y + 0.5));
        pts[1] = new geometry_core_1.Point2d(Math.floor(corner.x + 0.5), Math.floor(corner.y + 0.5));
        const range = geometry_core_1.Range2d.createArray(pts);
        const rect = new Viewport_1.ViewRect();
        rect.initFromRange(range);
        vp.readPixels(rect, 1 /* Feature */, (pixels) => {
            if (undefined === pixels)
                return;
            let contents = new Set();
            const testPoint = geometry_core_1.Point2d.createZero();
            if (SelectionMethod.Box === method) {
                const outline = overlap ? undefined : new Set();
                const offset = range.clone();
                offset.expandInPlace(-2);
                for (testPoint.x = range.low.x; testPoint.x <= range.high.x; ++testPoint.x) {
                    for (testPoint.y = range.low.y; testPoint.y <= range.high.y; ++testPoint.y) {
                        const pixel = pixels.getPixel(testPoint.x, testPoint.y);
                        if (undefined === pixel || undefined === pixel.elementId || bentleyjs_core_1.Id64.isInvalid(pixel.elementId))
                            continue; // no geometry at this location...
                        if (undefined !== outline && !offset.containsPoint(testPoint))
                            outline.add(pixel.elementId.toString());
                        else
                            contents.add(pixel.elementId.toString());
                    }
                }
                if (undefined !== outline && 0 !== outline.size) {
                    const inside = new Set();
                    contents.forEach((id) => { if (!outline.has(id))
                        inside.add(id); });
                    contents = inside;
                }
            }
            else {
                const closePoint = geometry_core_1.Point2d.createZero();
                for (testPoint.x = range.low.x; testPoint.x <= range.high.x; ++testPoint.x) {
                    for (testPoint.y = range.low.y; testPoint.y <= range.high.y; ++testPoint.y) {
                        const pixel = pixels.getPixel(testPoint.x, testPoint.y);
                        if (undefined === pixel || undefined === pixel.elementId || bentleyjs_core_1.Id64.isInvalid(pixel.elementId))
                            continue; // no geometry at this location...
                        const fraction = testPoint.fractionOfProjectionToLine(pts[0], pts[1], 0.0);
                        pts[0].interpolate(fraction, pts[1], closePoint);
                        if (closePoint.distance(testPoint) < 1.5)
                            contents.add(pixel.elementId.toString());
                    }
                }
            }
            if (!this.wantPickableDecorations())
                contents.forEach((id) => { if (bentleyjs_core_1.Id64.isTransient(id))
                    contents.delete(id); });
            if (0 === contents.size) {
                if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev)) {
                    this.iModel.selectionSet.emptyAll();
                    this.syncSelectionMode();
                }
                return;
            }
            switch (this.selectionMode) {
                case SelectionMode.Replace:
                    if (!ev.isControlKey)
                        this.processSelection(contents, SelectionProcessing.ReplaceSelectionWithElement); // tslint:disable-line:no-floating-promises
                    else
                        this.processSelection(contents, SelectionProcessing.InvertElementInSelection); // tslint:disable-line:no-floating-promises
                    break;
                case SelectionMode.Add:
                    this.processSelection(contents, SelectionProcessing.AddElementToSelection); // tslint:disable-line:no-floating-promises
                    break;
                case SelectionMode.Remove:
                    this.processSelection(contents, SelectionProcessing.RemoveElementFromSelection); // tslint:disable-line:no-floating-promises
                    break;
            }
        }, true);
    }
    selectByPointsStart(ev) {
        if (Tool_1.BeButton.Data !== ev.button && Tool_1.BeButton.Reset !== ev.button)
            return false;
        this._points.length = 0;
        this._points.push(ev.point.clone());
        this._isSelectByPoints = true;
        IModelApp_1.IModelApp.accuSnap.enableLocate(false);
        IModelApp_1.IModelApp.toolAdmin.setLocateCircleOn(false);
        return true;
    }
    selectByPointsEnd(ev) {
        if (!this._isSelectByPoints)
            return false;
        const vp = ev.viewport;
        if (vp === undefined) {
            this.initSelectTool();
            return false;
        }
        const origin = vp.worldToView(this._points[0]);
        const corner = vp.worldToView(ev.point);
        if (SelectionMethod.Line === this.selectionMethod || (SelectionMethod.Pick === this.selectionMethod && Tool_1.BeButton.Reset === ev.button))
            this.selectByPointsProcess(origin, corner, ev, SelectionMethod.Line, true);
        else
            this.selectByPointsProcess(origin, corner, ev, SelectionMethod.Box, this.useOverlapSelection(ev));
        this.initSelectTool();
        vp.invalidateDecorations();
        return true;
    }
    async onMouseMotion(ev) {
        if (undefined !== ev.viewport && this._isSelectByPoints)
            ev.viewport.invalidateDecorations();
    }
    async selectDecoration(ev, currHit) {
        if (undefined === currHit)
            currHit = await IModelApp_1.IModelApp.locateManager.doLocate(new ElementLocateManager_1.LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);
        if (undefined !== currHit && !currHit.isElementHit)
            return IModelApp_1.IModelApp.viewManager.onDecorationButtonEvent(currHit, ev);
        return Tool_1.EventHandled.No;
    }
    async onMouseStartDrag(ev) {
        IModelApp_1.IModelApp.accuSnap.clear(); // Need to test hit at start drag location, not current AccuSnap...
        if (Tool_1.EventHandled.Yes === await this.selectDecoration(ev))
            return Tool_1.EventHandled.Yes;
        if (Tool_1.InputSource.Touch === ev.inputSource && SelectionMethod.Pick === this.selectionMethod)
            return Tool_1.EventHandled.No; // Require method change for line/box selection...allow IdleTool to handle touch move...
        return this.selectByPointsStart(ev) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
    async onMouseEndDrag(ev) {
        return this.selectByPointsEnd(ev) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
    async onDataButtonUp(ev) {
        if (undefined === ev.viewport)
            return Tool_1.EventHandled.No;
        if (this.selectByPointsEnd(ev))
            return Tool_1.EventHandled.Yes;
        if (SelectionMethod.Pick !== this.selectionMethod) {
            if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev)) {
                this.iModel.selectionSet.emptyAll();
                this.syncSelectionMode();
            }
            if (Tool_1.InputSource.Touch !== ev.inputSource)
                this.selectByPointsStart(ev); // Require touch move and not tap to start crossing line/box selection...
            return Tool_1.EventHandled.Yes;
        }
        const hit = await IModelApp_1.IModelApp.locateManager.doLocate(new ElementLocateManager_1.LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);
        if (hit !== undefined) {
            if (Tool_1.EventHandled.Yes === await this.selectDecoration(ev, hit))
                return Tool_1.EventHandled.Yes;
            switch (this.selectionMode) {
                case SelectionMode.Replace:
                    this.processSelection(hit.sourceId, ev.isControlKey ? SelectionProcessing.InvertElementInSelection : SelectionProcessing.ReplaceSelectionWithElement); // tslint:disable-line:no-floating-promises
                    break;
                case SelectionMode.Add:
                    this.processSelection(hit.sourceId, SelectionProcessing.AddElementToSelection); // tslint:disable-line:no-floating-promises
                    break;
                case SelectionMode.Remove:
                    this.processSelection(hit.sourceId, SelectionProcessing.RemoveElementFromSelection); // tslint:disable-line:no-floating-promises
                    break;
            }
            return Tool_1.EventHandled.Yes;
        }
        if (!ev.isControlKey && 0 !== this.iModel.selectionSet.size && this.wantSelectionClearOnMiss(ev)) {
            this.iModel.selectionSet.emptyAll();
            this.syncSelectionMode();
        }
        return Tool_1.EventHandled.Yes;
    }
    async onResetButtonUp(ev) {
        if (this._isSelectByPoints) {
            if (undefined !== ev.viewport)
                ev.viewport.invalidateDecorations();
            this.initSelectTool();
            return Tool_1.EventHandled.Yes;
        }
        // Check for overlapping hits...
        const lastHit = SelectionMode.Remove === this.selectionMode ? undefined : IModelApp_1.IModelApp.locateManager.currHit;
        if (lastHit && this.iModel.selectionSet.has(lastHit.sourceId)) {
            const autoHit = IModelApp_1.IModelApp.accuSnap.currHit;
            // Play nice w/auto-locate, only remove previous hit if not currently auto-locating or over previous hit
            if (undefined === autoHit || autoHit.isSameHit(lastHit)) {
                const response = new ElementLocateManager_1.LocateResponse();
                const nextHit = await IModelApp_1.IModelApp.locateManager.doLocate(response, false, ev.point, ev.viewport, ev.inputSource);
                // remove element(s) previously selected if in replace mode, or if we have a next element in add mode
                if (SelectionMode.Replace === this.selectionMode || undefined !== nextHit)
                    this.processSelection(lastHit.sourceId, SelectionProcessing.RemoveElementFromSelection); // tslint:disable-line:no-floating-promises
                // add element(s) located via reset button
                if (undefined !== nextHit)
                    this.processSelection(nextHit.sourceId, SelectionProcessing.AddElementToSelection); // tslint:disable-line:no-floating-promises
                return Tool_1.EventHandled.Yes;
            }
        }
        if (Tool_1.EventHandled.Yes === await this.selectDecoration(ev, IModelApp_1.IModelApp.accuSnap.currHit))
            return Tool_1.EventHandled.Yes;
        IModelApp_1.IModelApp.accuSnap.resetButton(); // tslint:disable-line:no-floating-promises
        return Tool_1.EventHandled.Yes;
    }
    onSuspend() { this._isSuspended = true; if (this.wantEditManipulators())
        IModelApp_1.IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ToolAdmin_1.ManipulatorToolEvent.Suspend); }
    onUnsuspend() { this._isSuspended = false; if (this.wantEditManipulators())
        IModelApp_1.IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ToolAdmin_1.ManipulatorToolEvent.Unsuspend); this.showPrompt(this.selectionMode, this.selectionMethod); } // TODO: Tool assistance...
    async onTouchMoveStart(ev, startEv) {
        if (startEv.isSingleTouch && !this._isSelectByPoints)
            await IModelApp_1.IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev);
        return (this._isSuspended || this._isSelectByPoints) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
    async onTouchMove(ev) { if (this._isSelectByPoints)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }
    async onTouchComplete(ev) { if (this._isSelectByPoints)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }
    async onTouchCancel(ev) { if (this._isSelectByPoints)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, Tool_1.BeButton.Reset); }
    decorate(context) { this.selectByPointsDecorate(context); }
    async onModifierKeyTransition(_wentDown, modifier, _event) {
        return (modifier === Tool_1.BeModifierKeys.Shift && this._isSelectByPoints) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
    }
    async filterHit(hit, _out) {
        if (!this.wantPickableDecorations() && !hit.isElementHit)
            return ElementLocateManager_1.LocateFilterStatus.Reject;
        const mode = this.selectionMode;
        if (SelectionMode.Replace === mode)
            return ElementLocateManager_1.LocateFilterStatus.Accept;
        const isSelected = this.iModel.selectionSet.has(hit.sourceId);
        return ((SelectionMode.Add === mode ? !isSelected : isSelected) ? ElementLocateManager_1.LocateFilterStatus.Accept : ElementLocateManager_1.LocateFilterStatus.Reject);
    }
    onRestartTool() { this.exitTool(); }
    onCleanup() {
        if (this.wantEditManipulators())
            IModelApp_1.IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ToolAdmin_1.ManipulatorToolEvent.Stop);
    }
    onPostInstall() {
        super.onPostInstall();
        if (!this.targetView)
            return;
        if (this.wantEditManipulators())
            IModelApp_1.IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ToolAdmin_1.ManipulatorToolEvent.Start);
        this.initSelectTool();
    }
    static startTool() { return new SelectionTool().run(); }
    syncSelectionMode() {
        if (SelectionMode.Remove === this.selectionMode && !this.iModel.selectionSet.isActive) {
            // No selection active resetting selection mode since there is nothing to Remove
            this.selectionMode = SelectionMode.Replace;
            this.initSelectTool();
        }
        if (this.wantToolSettings()) {
            const syncMode = { value: this._selectionModeValue.clone(), propertyName: SelectionTool._modesName };
            IModelApp_1.IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, syncMode);
            this.syncToolSettingsProperties([syncMode]);
        }
    }
    /** Used to supply DefaultToolSettingProvider with a list of properties to use to generate ToolSettings.  If undefined then no ToolSettings will be displayed
     * @beta
     */
    supplyToolSettingsProperties() {
        if (!this.wantToolSettings())
            return undefined;
        // load latest values from session
        IModelApp_1.IModelApp.toolAdmin.toolSettingsState.initializeToolSettingProperties(this.toolId, [
            { propertyName: SelectionTool._methodsName, value: this._selectionMethodValue },
            { propertyName: SelectionTool._modesName, value: this._selectionModeValue },
        ]);
        // Make sure a mode of SelectionMode.Remove is valid
        if (SelectionMode.Remove === this.selectionMode && !this.iModel.selectionSet.isActive) {
            this.selectionMode = SelectionMode.Replace;
        }
        const toolSettings = new Array();
        // generate 3 columns - label will be placed in column 0 and button group editors in columns 1 and 2.
        toolSettings.push(new ToolSettingsValue_1.ToolSettingsPropertyRecord(this._selectionMethodValue.clone(), SelectionTool._getMethodsDescription(), { rowPriority: 0, columnIndex: 1 }));
        toolSettings.push(new ToolSettingsValue_1.ToolSettingsPropertyRecord(this._selectionModeValue.clone(), SelectionTool._getModesDescription(), { rowPriority: 0, columnIndex: 2 }));
        return toolSettings;
    }
    /** Used to send changes from UI back to Tool
     * @beta
     */
    applyToolSettingPropertyChange(updatedValue) {
        let changed = false;
        if (updatedValue.propertyName === SelectionTool._methodsName) {
            const saveWantManipulators = this.wantEditManipulators();
            if (this._selectionMethodValue.update(updatedValue.value)) {
                const currWantManipulators = this.wantEditManipulators();
                if (this.wantToolSettings())
                    IModelApp_1.IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: SelectionTool._methodsName, value: this._selectionMethodValue });
                if (saveWantManipulators !== currWantManipulators)
                    IModelApp_1.IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, currWantManipulators ? ToolAdmin_1.ManipulatorToolEvent.Start : ToolAdmin_1.ManipulatorToolEvent.Stop);
                changed = true;
            }
        }
        if (updatedValue.propertyName === SelectionTool._modesName) {
            if (this._selectionModeValue.update(updatedValue.value)) {
                if (this.wantToolSettings())
                    IModelApp_1.IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: SelectionTool._modesName, value: this._selectionModeValue });
                changed = true;
            }
        }
        if (changed)
            this.initSelectTool();
        return true; // return true if change is valid
    }
}
SelectionTool.hidden = false;
SelectionTool.toolId = "Select";
SelectionTool._methodsName = "selectionMethods";
SelectionTool._modesName = "selectionModes";
exports.SelectionTool = SelectionTool;


/***/ }),

/***/ "./lib/tools/Tool.js":
/*!***************************!*\
  !*** ./lib/tools/Tool.js ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const ElementLocateManager_1 = __webpack_require__(/*! ../ElementLocateManager */ "./lib/ElementLocateManager.js");
const FuzzySearch_1 = __webpack_require__(/*! ../FuzzySearch */ "./lib/FuzzySearch.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
/** Settings that control the behavior of built-in tools. Applications may modify these values.
 * @public
 */
class ToolSettings {
}
/** Duration of animations of viewing operations. */
ToolSettings.animationTime = bentleyjs_core_1.BeDuration.fromMilliseconds(260);
/** Two tap must be within this period to be a double tap. */
ToolSettings.doubleTapTimeout = bentleyjs_core_1.BeDuration.fromMilliseconds(250);
/** Two clicks must be within this period to be a double click. */
ToolSettings.doubleClickTimeout = bentleyjs_core_1.BeDuration.fromMilliseconds(500);
/** Number of screen inches of movement allowed between clicks to still qualify as a double-click.  */
ToolSettings.doubleClickToleranceInches = 0.05;
/** Duration without movement before a no-motion event is generated. */
ToolSettings.noMotionTimeout = bentleyjs_core_1.BeDuration.fromMilliseconds(10);
/** If true, view rotation tool keeps the up vector (worldZ) aligned with screenY. */
ToolSettings.preserveWorldUp = true;
/** Delay with a touch on the surface before a move operation begins. */
ToolSettings.touchMoveDelay = bentleyjs_core_1.BeDuration.fromMilliseconds(50);
/** Delay with the mouse down before a drag operation begins. */
ToolSettings.startDragDelay = bentleyjs_core_1.BeDuration.fromMilliseconds(110);
/** Distance in screen inches a touch point must move before being considered motion. */
ToolSettings.touchMoveDistanceInches = 0.15;
/** Distance in screen inches the cursor must move before a drag operation begins. */
ToolSettings.startDragDistanceInches = 0.15;
/** Radius in screen inches to search for elements that anchor viewing operations. */
ToolSettings.viewToolPickRadiusInches = 0.20;
/** Camera angle enforced for walk tool. */
ToolSettings.walkCameraAngle = geometry_core_1.Angle.createDegrees(75.6);
/** Whether the walk tool enforces worldZ be aligned with screenY */
ToolSettings.walkEnforceZUp = false;
/** Speed, in meters per second, for the walk tool. */
ToolSettings.walkVelocity = 3.5;
/** Scale factor applied for wheel events with "per-line" modifier. */
ToolSettings.wheelLineFactor = 40;
/** Scale factor applied for wheel events with "per-page" modifier. */
ToolSettings.wheelPageFactor = 120;
/** When the zoom-with-wheel tool (with camera enabled) gets closer than this distance to an obstacle, it "bumps" through. */
ToolSettings.wheelZoomBumpDistance = geometry_core_1.Constant.oneCentimeter;
/** Scale factor for zooming with mouse wheel. */
ToolSettings.wheelZoomRatio = 1.75;
exports.ToolSettings = ToolSettings;
/** @public */
var BeButton;
(function (BeButton) {
    BeButton[BeButton["Data"] = 0] = "Data";
    BeButton[BeButton["Reset"] = 1] = "Reset";
    BeButton[BeButton["Middle"] = 2] = "Middle";
})(BeButton = exports.BeButton || (exports.BeButton = {}));
/** @public */
var CoordinateLockOverrides;
(function (CoordinateLockOverrides) {
    CoordinateLockOverrides[CoordinateLockOverrides["None"] = 0] = "None";
    CoordinateLockOverrides[CoordinateLockOverrides["ACS"] = 2] = "ACS";
    CoordinateLockOverrides[CoordinateLockOverrides["Grid"] = 4] = "Grid";
    CoordinateLockOverrides[CoordinateLockOverrides["All"] = 65535] = "All";
})(CoordinateLockOverrides = exports.CoordinateLockOverrides || (exports.CoordinateLockOverrides = {}));
/** The *source* that generated an event.
 * @public
 */
var InputSource;
(function (InputSource) {
    /** Source not defined */
    InputSource[InputSource["Unknown"] = 0] = "Unknown";
    /** From a mouse or other pointing device */
    InputSource[InputSource["Mouse"] = 1] = "Mouse";
    /** From a touch screen */
    InputSource[InputSource["Touch"] = 2] = "Touch";
})(InputSource = exports.InputSource || (exports.InputSource = {}));
/** The *source* that generated a coordinate.
 * @public
 */
var CoordSource;
(function (CoordSource) {
    /** Event was created by an action from the user */
    CoordSource[CoordSource["User"] = 0] = "User";
    /** Event was created by a program or by a precision keyin */
    CoordSource[CoordSource["Precision"] = 1] = "Precision";
    /** Event was created by a tentative point */
    CoordSource[CoordSource["TentativePoint"] = 2] = "TentativePoint";
    /** Event was created by snapping to an element */
    CoordSource[CoordSource["ElemSnap"] = 3] = "ElemSnap";
})(CoordSource = exports.CoordSource || (exports.CoordSource = {}));
/** Numeric mask for a set of modifier keys (control, shift, and alt).
 * @public
 */
var BeModifierKeys;
(function (BeModifierKeys) {
    BeModifierKeys[BeModifierKeys["None"] = 0] = "None";
    BeModifierKeys[BeModifierKeys["Control"] = 1] = "Control";
    BeModifierKeys[BeModifierKeys["Shift"] = 2] = "Shift";
    BeModifierKeys[BeModifierKeys["Alt"] = 4] = "Alt";
})(BeModifierKeys = exports.BeModifierKeys || (exports.BeModifierKeys = {}));
/** @public */
class BeButtonState {
    constructor() {
        this._downUorPt = new geometry_core_1.Point3d();
        this._downRawPt = new geometry_core_1.Point3d();
        this.downTime = 0;
        this.isDown = false;
        this.isDoubleClick = false;
        this.isDragging = false;
        this.inputSource = InputSource.Unknown;
    }
    get downRawPt() { return this._downRawPt; }
    set downRawPt(pt) { this._downRawPt.setFrom(pt); }
    get downUorPt() { return this._downUorPt; }
    set downUorPt(pt) { this._downUorPt.setFrom(pt); }
    init(downUorPt, downRawPt, downTime, isDown, isDoubleClick, isDragging, source) {
        this.downUorPt = downUorPt;
        this.downRawPt = downRawPt;
        this.downTime = downTime;
        this.isDown = isDown;
        this.isDoubleClick = isDoubleClick;
        this.isDragging = isDragging;
        this.inputSource = source;
    }
}
exports.BeButtonState = BeButtonState;
/** Object sent to Tools that holds information about button/touch/wheel events.
 * @public
 */
class BeButtonEvent {
    constructor(props) {
        this._point = new geometry_core_1.Point3d();
        this._rawPoint = new geometry_core_1.Point3d();
        this._viewPoint = new geometry_core_1.Point3d();
        /** How the coordinate values were generated (either from an action by the user or from a program.) */
        this.coordsFrom = CoordSource.User;
        /** The keyboard modifiers that were pressed when the event was generated. */
        this.keyModifiers = BeModifierKeys.None;
        /** If true, this event was generated from a mouse-down transition, false from a button-up transition. */
        this.isDown = false;
        /** If true, this is the second down in a rapid double-click of the same button. */
        this.isDoubleClick = false;
        /** If true, this event was created by pressing, holding, and then moving a mouse button. */
        this.isDragging = false;
        /** The mouse button that created this event. */
        this.button = BeButton.Data;
        /** Whether this event came from a pointing device (e.g. mouse) or a touch device. */
        this.inputSource = InputSource.Unknown;
        if (props)
            this.init(props);
    }
    /** Determine whether this BeButtonEvent has valid data.
     * @note BeButtonEvents may be constructed as "blank", and are not considered to hold valid data unless the [[viewport]] member is defined.
     */
    get isValid() { return this.viewport !== undefined; }
    /** The point for this event, in world coordinates.
     * @note these coordinates may have been *adjusted* for some reason (e.g. snapping, locks, etc.) from the [[rawPoint]].
     */
    get point() { return this._point; }
    set point(pt) { this._point.setFrom(pt); }
    /** The *raw* (unadjusted) point for this event, in world coordinates. */
    get rawPoint() { return this._rawPoint; }
    set rawPoint(pt) { this._rawPoint.setFrom(pt); }
    /** The point, in screen coordinates for this event.
     * @note generally the z value is not useful, but some 3d pointing devices do supply it.
     */
    get viewPoint() { return this._viewPoint; }
    set viewPoint(pt) { this._viewPoint.setFrom(pt); }
    /** Mark this BeButtonEvent as invalid. Can only become valid again by calling [[init]] */
    invalidate() { this.viewport = undefined; }
    /** Initialize the values of this BeButtonEvent. */
    init(props) {
        if (undefined !== props.point)
            this.point = props.point;
        if (undefined !== props.rawPoint)
            this.rawPoint = props.rawPoint;
        if (undefined !== props.viewPoint)
            this.viewPoint = props.viewPoint;
        if (undefined !== props.viewport)
            this.viewport = props.viewport;
        if (undefined !== props.coordsFrom)
            this.coordsFrom = props.coordsFrom;
        if (undefined !== props.keyModifiers)
            this.keyModifiers = props.keyModifiers;
        if (undefined !== props.isDown)
            this.isDown = props.isDown;
        if (undefined !== props.isDoubleClick)
            this.isDoubleClick = props.isDoubleClick;
        if (undefined !== props.isDragging)
            this.isDragging = props.isDragging;
        if (undefined !== props.button)
            this.button = props.button;
        if (undefined !== props.inputSource)
            this.inputSource = props.inputSource;
    }
    /** Determine whether the control key was pressed  */
    get isControlKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Control); }
    /** Determine whether the shift key was pressed  */
    get isShiftKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Shift); }
    /** Determine whether the alt key was pressed  */
    get isAltKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Alt); }
    /** Copy the values from another BeButtonEvent into this BeButtonEvent */
    setFrom(src) {
        this.point = src.point;
        this.rawPoint = src.rawPoint;
        this.viewPoint = src.viewPoint;
        this.viewport = src.viewport;
        this.coordsFrom = src.coordsFrom;
        this.keyModifiers = src.keyModifiers;
        this.isDown = src.isDown;
        this.isDoubleClick = src.isDoubleClick;
        this.isDragging = src.isDragging;
        this.button = src.button;
        this.inputSource = src.inputSource;
        return this;
    }
    /** Make a copy of this BeButtonEvent. */
    clone() { return new this.constructor(this); }
}
exports.BeButtonEvent = BeButtonEvent;
/** A ButtonEvent generated by touch input.
 * @public
 */
class BeTouchEvent extends BeButtonEvent {
    constructor(props) {
        super(props);
        this.tapCount = 0;
        this.touchEvent = props.touchEvent;
    }
    get touchCount() { return this.touchEvent.targetTouches.length; }
    get isSingleTouch() { return 1 === this.touchCount; }
    get isTwoFingerTouch() { return 2 === this.touchCount; }
    get isSingleTap() { return 1 === this.tapCount && 1 === this.touchCount; }
    get isDoubleTap() { return 2 === this.tapCount && 1 === this.touchCount; }
    get isTwoFingerTap() { return 1 === this.tapCount && 2 === this.touchCount; }
    setFrom(src) {
        super.setFrom(src);
        this.touchEvent = src.touchEvent;
        this.tapCount = src.tapCount;
        return this;
    }
    static getTouchPosition(touch, vp) {
        const rect = vp.getClientRect();
        return geometry_core_1.Point2d.createFrom({ x: touch.clientX - rect.left, y: touch.clientY - rect.top });
    }
    static getTouchListCentroid(list, vp) {
        switch (list.length) {
            case 0: {
                return undefined;
            }
            case 1: {
                return this.getTouchPosition(list[0], vp);
            }
            case 2: {
                return this.getTouchPosition(list[0], vp).interpolate(0.5, this.getTouchPosition(list[1], vp));
            }
            default: {
                const points = [];
                // tslint:disable-next-line:prefer-for-of
                for (let i = 0; i < list.length; i++) {
                    points.push(this.getTouchPosition(list[i], vp));
                }
                const centroid = geometry_core_1.Point2d.createZero();
                geometry_core_1.PolygonOps.centroidAndAreaXY(points, centroid);
                return centroid;
            }
        }
    }
    static findTouchById(list, id) {
        // tslint:disable-next-line:prefer-for-of
        for (let i = 0; i < list.length; i++) {
            if (id === list[i].identifier)
                return list[i];
        }
        return undefined;
    }
}
exports.BeTouchEvent = BeTouchEvent;
/** A BeButtonEvent generated by movement of a mouse wheel.
 * @note wheel events include mouse location.
 * @public
 */
class BeWheelEvent extends BeButtonEvent {
    constructor(props) {
        super(props);
        this.wheelDelta = 0;
        if (props && props.wheelDelta !== undefined)
            this.wheelDelta = props.wheelDelta;
    }
    setFrom(src) {
        super.setFrom(src);
        this.wheelDelta = src.wheelDelta;
        return this;
    }
}
exports.BeWheelEvent = BeWheelEvent;
/** Base Tool class for writing an immediate tool that executes it's assigned task immediately without further input.
 * @see [[InteractiveTool]] for a base Tool class to handle user input events from a Viewport.
 * @see [Tools]($docs/learning/frontend/tools.md)
 * @public
 */
class Tool {
    constructor(..._args) { }
    static get _localizeBase() { return this.namespace.name + ":tools." + this.toolId; }
    static get _keyinKey() { return this._localizeBase + ".keyin"; }
    static get _flyoverKey() { return this._localizeBase + ".flyover"; }
    static get _descriptionKey() { return this._localizeBase + ".description"; }
    /**
     * Register this Tool class with the ToolRegistry.
     * @param namespace optional namespace to supply to ToolRegistry.register. If undefined, use namespace from superclass.
     */
    static register(namespace) { IModelApp_1.IModelApp.tools.register(this, namespace); }
    /**
     * Get the localized keyin string for this Tool class. This returns the value of "tools." + this.toolId + ".keyin" from the
     * .json file for the current locale of its registered Namespace (e.g. "en/MyApp.json")
     */
    static get keyin() { return this._keyin ? this._keyin : (this._keyin = IModelApp_1.IModelApp.i18n && IModelApp_1.IModelApp.i18n.translate(this._keyinKey)); }
    /**
     * Get the localized flyover for this Tool class. This returns the value of "tools." + this.toolId + ".flyover" from the
     * .json file for the current locale of its registered Namespace (e.g. "en/MyApp.json"). If that key is not in the localization namespace,
     * the keyin property is returned.
     */
    static get flyover() { return this._flyover ? this._flyover : (this._flyover = IModelApp_1.IModelApp.i18n && IModelApp_1.IModelApp.i18n.translate([this._flyoverKey, this._keyinKey])); }
    /**
     * Get the localized description for this Tool class. This returns the value of "tools." + this.toolId + ".description" from the
     * .json file for the current locale of its registered Namespace (e.g. "en/MyApp.json"). If that key is not in the localization namespace,
     * the flyover property is returned.
     */
    static get description() { return this._description ? this._description : (this._description = IModelApp_1.IModelApp.i18n && IModelApp_1.IModelApp.i18n.translate([this._descriptionKey, this._flyoverKey, this._keyinKey])); }
    /**
     * Get the toolId string for this Tool class. This string is used to identify the Tool in the ToolRegistry and is used to localize
     * the keyin, description, etc. from the current locale.
     */
    get toolId() { return this.constructor.toolId; }
    /** Get the localized keyin string from this Tool's class */
    get keyin() { return this.constructor.keyin; }
    /** Get the localized flyover string from this Tool's class */
    get flyover() { return this.constructor.flyover; }
    /** Get the localized description string from this Tool's class */
    get description() { return this.constructor.description; }
    /**
     * Run this instance of a Tool. Subclasses should override to perform some action.
     * @returns `true` if the tool executed successfully.
     */
    run(..._arg) { return true; }
}
/** If true, this Tool will not appear in the list from [[ToolRegistry.getToolList]]. This should be overridden in subclasses to hide them. */
Tool.hidden = false;
/** The unique string that identifies this tool. This must be overridden in every subclass. */
Tool.toolId = "";
exports.Tool = Tool;
/** @public */
var EventHandled;
(function (EventHandled) {
    EventHandled[EventHandled["No"] = 0] = "No";
    EventHandled[EventHandled["Yes"] = 1] = "Yes";
})(EventHandled = exports.EventHandled || (exports.EventHandled = {}));
/** A Tool that may be installed, via [[ToolAdmin]], to handle user input. The ToolAdmin manages the currently installed ViewingTool, PrimitiveTool,
 * InputCollector, and IdleTool. Each must derive from this class and there may only be one of each type installed at a time.
 * @public
 */
class InteractiveTool extends Tool {
    constructor() {
        super(...arguments);
        /** Used to avoid sending tools up events for which they did not receive the down event. */
        this.receivedDownEvent = false;
    }
    /** Override to execute additional logic when tool is installed. Return false to prevent this tool from becoming active */
    onInstall() { return true; }
    /** Override to execute additional logic after tool becomes active */
    onPostInstall() { }
    /** Override Call to reset tool to initial state */
    onReinitialize() { }
    /** Invoked when the tool becomes no longer active, to perform additional cleanup logic */
    onCleanup() { }
    /** Notification of a ViewTool or InputCollector starting and this tool is being suspended.
     * @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.
     */
    onSuspend() { }
    /** Notification of a ViewTool or InputCollector exiting and this tool is being unsuspended.
     *  @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.
     */
    onUnsuspend() { }
    /** Called to support operations on pickable decorations, like snapping. */
    testDecorationHit(_id) { return false; }
    /** Called to allow snapping to pickable decoration geometry.
     * @note Snap geometry can be different from decoration geometry (ex. center point of a + symbol). Valid decoration geometry for snapping should be "stable" and not change based on the current cursor location.
     */
    getDecorationGeometry(_hit) { return undefined; }
    /**
     * Called to allow an active tool to display non-element decorations in overlay mode.
     * This method is NOT called while the tool is suspended by a viewing tool or input collector.
     */
    decorate(_context) { }
    /**
     * Called to allow a suspended tool to display non-element decorations in overlay mode.
     * This method is ONLY called when the tool is suspended by a viewing tool or input collector.
     * @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.
     */
    decorateSuspended(_context) { }
    /** Invoked when the reset button is pressed.
     * @return No by default. Sub-classes may ascribe special meaning to this status.
     * @note To support right-press menus, a tool should put its reset event processing in onResetButtonUp instead of onResetButtonDown.
     */
    async onResetButtonDown(_ev) { return EventHandled.No; }
    /** Invoked when the reset button is released.
     * @return No by default. Sub-classes may ascribe special meaning to this status.
     */
    async onResetButtonUp(_ev) { return EventHandled.No; }
    /** Invoked when the data button is pressed.
     * @return No by default. Sub-classes may ascribe special meaning to this status.
     */
    async onDataButtonDown(_ev) { return EventHandled.No; }
    /** Invoked when the data button is released.
     * @return No by default. Sub-classes may ascribe special meaning to this status.
     */
    async onDataButtonUp(_ev) { return EventHandled.No; }
    /** Invoked when the middle mouse button is pressed.
     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    async onMiddleButtonDown(_ev) { return EventHandled.No; }
    /** Invoked when the middle mouse button is released.
     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    async onMiddleButtonUp(_ev) { return EventHandled.No; }
    /** Invoked when the cursor is moving */
    async onMouseMotion(_ev) { }
    /** Invoked when the cursor is not moving */
    async onMouseNoMotion(_ev) { }
    /** Invoked when the cursor was previously moving, and has stopped moving. */
    async onMouseMotionStopped(_ev) { }
    /** Invoked when the cursor begins moving while a button is depressed.
     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    async onMouseStartDrag(_ev) { return EventHandled.No; }
    /** Invoked when the button is released after onMouseStartDrag.
     * @note default placement tool behavior is to treat press, drag, and release of data button the same as click, click by calling onDataButtonDown.
     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    async onMouseEndDrag(ev) { if (BeButton.Data !== ev.button)
        return EventHandled.No; if (ev.isDown)
        return this.onDataButtonDown(ev); const downEv = ev.clone(); downEv.isDown = true; return this.onDataButtonDown(downEv); }
    /** Invoked when the mouse wheel moves.
     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    async onMouseWheel(_ev) { return EventHandled.No; }
    /** Called when Control, Shift, or Alt modifier keys are pressed or released.
     * @param _wentDown up or down key event
     * @param _modifier The modifier key mask
     * @param _event The event that caused this call
     * @return Yes to refresh view decorations or update dynamics.
     */
    async onModifierKeyTransition(_wentDown, _modifier, _event) { return EventHandled.No; }
    /** Called when any key is pressed or released.
     * @param _wentDown up or down key event
     * @param _keyEvent The KeyboardEvent
     * @return Yes to prevent further processing of this event
     * @see [[onModifierKeyTransition]]
     */
    async onKeyTransition(_wentDown, _keyEvent) { return EventHandled.No; }
    /** Called when user adds a touch point by placing a finger or stylus on the surface. */
    async onTouchStart(_ev) { }
    /** Called when user removes a touch point by lifting a finger or stylus from the surface. */
    async onTouchEnd(_ev) { }
    /** Called when the last touch point is removed from the surface completing the current gesture. This is a convenience event sent following onTouchEnd when no target touch points remain on the surface. */
    async onTouchComplete(_ev) { }
    /** Called when a touch point is interrupted in some way and needs to be dropped from the list of target touches. */
    async onTouchCancel(_ev) { }
    /** Called when a touch point moves along the surface. */
    async onTouchMove(_ev) { }
    /** Called after at least one touch point has moved for an appreciable time and distance along the surface to not be considered a tap.
     * @param _ev The event that caused this call
     * @param _startEv The event from the last call to onTouchStart
     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.
     */
    async onTouchMoveStart(_ev, _startEv) { return EventHandled.No; }
    /** Called when touch point(s) are added and removed from a surface within a small time window without any touch point moving.
     * @param _ev The event that caused this call
     * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.
     * @note A double or triple tap event will not be preceded by a single tap event.
     */
    async onTouchTap(_ev) { return EventHandled.No; }
    isCompatibleViewport(_vp, _isSelectedViewChange) { return true; }
    isValidLocation(_ev, _isButtonEvent) { return true; }
    /**
     * Called when active view changes. Tool may choose to restart or exit based on current view type.
     * @param previous The previously active view.
     * @param current The new active view.
     */
    onSelectedViewportChanged(_previous, _current) { }
    /**
     * Invoked before the locate tooltip is displayed to retrieve the information about the located element. Allows the tool to override the toolTip.
     * @param hit The HitDetail whose info is needed.
     * @return A Promise for the HTMLElement or string to describe the hit.
     * @note If you override this method, you may decide whether to call your superclass' implementation or not (it is not required).
     */
    async getToolTip(_hit) { return _hit.getToolTip(); }
    /** Fill the supplied button event from the current cursor location.   */
    getCurrentButtonEvent(ev) { IModelApp_1.IModelApp.toolAdmin.fillEventFromCursorLocation(ev); }
    /** Call to find out if dynamics are currently active. */
    get isDynamicsStarted() { return IModelApp_1.IModelApp.viewManager.inDynamicsMode; }
    /** Call to initialize dynamics mode. While dynamics are active onDynamicFrame will be called. Dynamics are typically only used by a PrimitiveTool that creates or modifies geometric elements. */
    beginDynamics() { IModelApp_1.IModelApp.toolAdmin.beginDynamics(); }
    /** Call to terminate dynamics mode. */
    endDynamics() { IModelApp_1.IModelApp.toolAdmin.endDynamics(); }
    /** Called to allow Tool to display dynamic elements. */
    onDynamicFrame(_ev, _context) { }
    /** Invoked to allow tools to filter which elements can be located.
     * @return Reject if hit is unacceptable for this tool (fill out response with explanation, if it is defined)
     */
    async filterHit(_hit, _out) { return ElementLocateManager_1.LocateFilterStatus.Accept; }
    /** Helper method to keep the view cursor, display of locate circle, and coordinate lock overrides consistent with [[AccuSnap.isLocateEnabled]] and [[AccuSnap.isSnapEnabled]].
     * @param enableLocate Value to pass to [[AccuSnap.enableLocate]]. Tools that locate elements should always pass true to give the user feedback regarding the element at the current cursor location.
     * @param enableSnap Optional value to pass to [[AccuSnap.enableSnap]]. Tools that don't care about the element pick location should not pass true. Default is false.
     * @note User must also have snapping enabled [[AccuSnap.isSnapEnabledByUser]], otherwise [[TentativePoint]] is used to snap.
     * @param cursor Optional tool specific cursor override. Default is either cross or dynamics cursor depending on whether dynamics are currently active.
     * @param coordLockOvr Optional tool specific coordinate lock overrides. A tool that only identifies elements and does not use [[BeButtonEvent.point]] can set ToolState.coordLockOvr to CoordinateLockOverrides.ACS
     * or CoordinateLockOverrides.All, otherwise locate is affected by the input point being first projected to the ACS plane. A tool that will use [[BeButtonEvent.point]], especially those that call [[AccuSnap.enableSnap]]
     * should honor all locks and leave ToolState.coordLockOvr set to CoordinateLockOverrides.None, the default for ViewTool and PrimitiveTool.
     */
    changeLocateState(enableLocate, enableSnap, cursor, coordLockOvr) {
        if (undefined !== cursor) {
            IModelApp_1.IModelApp.toolAdmin.setCursor(cursor);
            IModelApp_1.IModelApp.toolAdmin.setLocateCircleOn(enableLocate);
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        }
        else {
            IModelApp_1.IModelApp.toolAdmin.setLocateCursor(enableLocate);
        }
        IModelApp_1.IModelApp.accuSnap.enableLocate(enableLocate);
        if (undefined !== enableSnap)
            IModelApp_1.IModelApp.accuSnap.enableSnap(enableSnap);
        else
            IModelApp_1.IModelApp.accuSnap.enableSnap(false);
        if (undefined !== coordLockOvr) {
            IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr = coordLockOvr;
        }
        else {
            if (enableLocate && !IModelApp_1.IModelApp.accuSnap.isSnapEnabled)
                IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr |= CoordinateLockOverrides.ACS;
            else
                IModelApp_1.IModelApp.toolAdmin.toolState.coordLockOvr &= ~CoordinateLockOverrides.ACS;
        }
    }
    /** Helper method for tools that need to locate existing elements.
     * Initializes [[ElementLocateManager]], changes the view cursor to locate, enables display of the locate circle, and sets the appropriate coordinate lock overrides.
     * @see [[changeLocateState]]
     */
    initLocateElements(enableLocate = true, enableSnap, cursor, coordLockOvr) {
        IModelApp_1.IModelApp.locateManager.initToolLocate();
        this.changeLocateState(enableLocate, enableSnap, cursor, coordLockOvr);
    }
    /** Used to supply list of properties that can be used to generate ToolSettings. If undefined is returned then no ToolSettings will be displayed
     * @beta
     */
    supplyToolSettingsProperties() { return undefined; }
    /** Used to receive property changes from UI. Return false if there was an error applying updatedValue.
     * @beta
     */
    applyToolSettingPropertyChange(_updatedValue) { return true; }
    /** Called by tool to synchronize the UI with property changes made by tool. This is typically used to provide user feedback during tool dynamics.
     * If the syncData contains a quantity value and if the displayValue is not defined, the displayValue will be generated in the UI layer before displaying the value.
     * @beta
     */
    syncToolSettingsProperties(syncData) {
        IModelApp_1.IModelApp.toolAdmin.syncToolSettingsProperties(this.toolId, syncData);
    }
}
exports.InteractiveTool = InteractiveTool;
/** The InputCollector class can be used to implement a command for gathering input (ex. get a distance by snapping to 2 points) without affecting the state of the active primitive tool.
 * @public
 */
class InputCollector extends InteractiveTool {
    run() {
        const toolAdmin = IModelApp_1.IModelApp.toolAdmin;
        // An input collector can only suspend a primitive tool, don't install if a viewing tool is active...
        if (undefined !== toolAdmin.viewTool || !toolAdmin.onInstallTool(this))
            return false;
        toolAdmin.startInputCollector(this);
        toolAdmin.onPostInstallTool(this);
        return true;
    }
    exitTool() { IModelApp_1.IModelApp.toolAdmin.exitInputCollector(); }
    async onResetButtonUp(_ev) { this.exitTool(); return EventHandled.Yes; }
}
exports.InputCollector = InputCollector;
/** The ToolRegistry holds a mapping between toolIds and their corresponding Tool class. This provides the mechanism to
 * find Tools by their toolId, and also a way to iterate over the set of Tools available.
 * @public
 */
class ToolRegistry {
    constructor() {
        this.tools = new Map();
    }
    /**
     * Un-register a previously registered Tool class.
     * @param toolId the toolId of a previously registered tool to unRegister.
     */
    unRegister(toolId) { this.tools.delete(toolId); this._keyinList = undefined; }
    /**
     * Register a Tool class. This establishes a connection between the toolId of the class and the class itself.
     * @param toolClass the subclass of Tool to register.
     * @param namespace the namespace for the localized strings for this tool. If undefined, use namespace from superclass.
     */
    register(toolClass, namespace) {
        if (namespace) // namespace is optional because it can come from superclass
            toolClass.namespace = namespace;
        if (toolClass.toolId.length === 0)
            return; // must be an abstract class, ignore it
        if (!toolClass.namespace)
            throw new imodeljs_common_1.IModelError(-1, "Tools must have a namespace");
        this.tools.set(toolClass.toolId, toolClass);
        this._keyinList = undefined; // throw away the current keyinList so we'll produce a new one next time we're asked.
    }
    /**
     * Register all the Tool classes found in a module.
     * @param modelObj the module to search for subclasses of Tool.
     */
    registerModule(moduleObj, namespace) {
        for (const thisMember in moduleObj) {
            if (!thisMember)
                continue;
            const thisTool = moduleObj[thisMember];
            if (thisTool.prototype instanceof Tool) {
                this.register(thisTool, namespace);
            }
        }
    }
    /** Look up a tool by toolId */
    find(toolId) { return this.tools.get(toolId); }
    /**
     * Look up a tool by toolId and, if found, create an instance with the supplied arguments.
     * @param toolId the toolId of the tool
     * @param args arguments to pass to the constructor.
     * @returns an instance of the registered Tool class, or undefined if toolId is not registered.
     */
    create(toolId, ...args) {
        const toolClass = this.find(toolId);
        return toolClass ? new toolClass(...args) : undefined;
    }
    /**
     * Look up a tool by toolId and, if found, create an instance with the supplied arguments and run it.
     * @param toolId toolId of the immediate tool
     * @param args arguments to pass to the constructor, and to run.
     * @return true if the tool was found and successfully run.
     */
    run(toolId, ...args) {
        const tool = this.create(toolId, ...args);
        return tool !== undefined && tool.run(...args);
    }
    /** Get a list of Tools currently registered, excluding hidden tools */
    getToolList() {
        if (this._keyinList === undefined) {
            this._keyinList = [];
            this.tools.forEach((thisTool) => { if (!thisTool.hidden)
                this._keyinList.push(thisTool); });
        }
        return this._keyinList;
    }
    /**
     * Find a tool by its localized keyin using a FuzzySearch
     * @param keyin the localized keyin string of the Tool.
     * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.
     * @internal
     */
    findPartialMatches(keyin) {
        return new FuzzySearch_1.FuzzySearch().search(this.getToolList(), ["keyin"], keyin);
    }
    /**
     * Find a tool by its localized keyin. If found (via exact match), execute the tool with the supplied arguments.
     * @param keyin the localized keyin string of the Tool to run.
     * @param args the arguments for the tool. Note: these argument are passed to both the constructor and the tools' run method.
     * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.
     * @internal
     */
    executeExactMatch(keyin, ...args) {
        const foundClass = this.findExactMatch(keyin);
        return foundClass ? new foundClass(...args).run(...args) : false;
    }
    /**
     * Find a tool by its localized keyin.
     * @param keyin the localized keyin string of the Tool.
     * @returns the Tool class, if an exact match is found, otherwise returns undefined.
     * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.
     * @internal
     */
    findExactMatch(keyin) { return this.getToolList().find((thisTool) => thisTool.keyin === keyin); }
}
exports.ToolRegistry = ToolRegistry;


/***/ }),

/***/ "./lib/tools/ToolAdmin.js":
/*!********************************!*\
  !*** ./lib/tools/ToolAdmin.js ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const bentleyjs_core_1 = __webpack_require__(/*! @bentley/bentleyjs-core */ "@bentley/bentleyjs-core");
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const AccuSnap_1 = __webpack_require__(/*! ../AccuSnap */ "./lib/AccuSnap.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const Sprites_1 = __webpack_require__(/*! ../Sprites */ "./lib/Sprites.js");
const ViewContext_1 = __webpack_require__(/*! ../ViewContext */ "./lib/ViewContext.js");
const Viewport_1 = __webpack_require__(/*! ../Viewport */ "./lib/Viewport.js");
const ViewState_1 = __webpack_require__(/*! ../ViewState */ "./lib/ViewState.js");
const PrimitiveTool_1 = __webpack_require__(/*! ./PrimitiveTool */ "./lib/tools/PrimitiveTool.js");
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
/** @public */
var StartOrResume;
(function (StartOrResume) {
    StartOrResume[StartOrResume["Start"] = 1] = "Start";
    StartOrResume[StartOrResume["Resume"] = 2] = "Resume";
})(StartOrResume = exports.StartOrResume || (exports.StartOrResume = {}));
/** @alpha */
var ManipulatorToolEvent;
(function (ManipulatorToolEvent) {
    ManipulatorToolEvent[ManipulatorToolEvent["Start"] = 1] = "Start";
    ManipulatorToolEvent[ManipulatorToolEvent["Stop"] = 2] = "Stop";
    ManipulatorToolEvent[ManipulatorToolEvent["Suspend"] = 3] = "Suspend";
    ManipulatorToolEvent[ManipulatorToolEvent["Unsuspend"] = 4] = "Unsuspend";
})(ManipulatorToolEvent = exports.ManipulatorToolEvent || (exports.ManipulatorToolEvent = {}));
/** Class that assists in maintaining the state of tool settings properties for the current session
 *  @internal
 */
class ToolSettingsState {
    /** Initialize single tool settings value
     * @internal
     */
    initializeToolSettingProperty(toolId, item) {
        if (item) {
            const key = `${toolId}:${item.propertyName}`;
            const savedValue = window.sessionStorage.getItem(key);
            if (savedValue) {
                const readValue = JSON.parse(savedValue);
                // set the primitive value to the saved value - note: tool settings only support primitive values.
                item.value.value = readValue.value;
                if (readValue.hasDisplayValue)
                    item.value.displayValue = readValue.displayValue;
            }
        }
    }
    /** Initialize an array of tool settings values
     *  @internal
     */
    initializeToolSettingProperties(toolId, tsProps) {
        if (tsProps && tsProps.length) {
            tsProps.forEach((item) => {
                this.initializeToolSettingProperty(toolId, item);
            });
        }
    }
    /** Save single tool settings value
     * @internal
     */
    saveToolSettingProperty(toolId, item) {
        if (item) {
            const key = `${toolId}:${item.propertyName}`;
            const objectAsString = JSON.stringify(item.value);
            window.sessionStorage.setItem(key, objectAsString);
        }
    }
    /** Save an array of tool settings values
     * @internal
     */
    saveToolSettingProperties(toolId, tsProps) {
        if (tsProps && tsProps.length) {
            tsProps.forEach((item) => {
                this.saveToolSettingProperty(toolId, item);
            });
        }
    }
}
exports.ToolSettingsState = ToolSettingsState;
/** @internal */
class ToolState {
    constructor() {
        this.coordLockOvr = Tool_1.CoordinateLockOverrides.None;
        this.locateCircleOn = false;
    }
    setFrom(other) { this.coordLockOvr = other.coordLockOvr; this.locateCircleOn = other.locateCircleOn; }
    clone() { const val = new ToolState(); val.setFrom(this); return val; }
}
exports.ToolState = ToolState;
/** @internal */
class SuspendedToolState {
    constructor() {
        this._shuttingDown = false;
        const { toolAdmin, viewManager, accuSnap, locateManager } = IModelApp_1.IModelApp;
        toolAdmin.setIncompatibleViewportCursor(true); // Don't save this
        this._toolState = toolAdmin.toolState.clone();
        this._accuSnapState = accuSnap.toolState.clone();
        this._locateOptions = locateManager.options.clone();
        this._viewCursor = viewManager.cursor;
        this._inDynamics = viewManager.inDynamicsMode;
        if (this._inDynamics)
            viewManager.endDynamicsMode();
    }
    stop() {
        if (this._shuttingDown)
            return;
        const { toolAdmin, viewManager, accuSnap, locateManager } = IModelApp_1.IModelApp;
        toolAdmin.setIncompatibleViewportCursor(true); // Don't restore this
        toolAdmin.toolState.setFrom(this._toolState);
        accuSnap.toolState.setFrom(this._accuSnapState);
        locateManager.options.setFrom(this._locateOptions);
        viewManager.setViewCursor(this._viewCursor);
        if (this._inDynamics)
            viewManager.beginDynamicsMode();
        else
            viewManager.endDynamicsMode();
    }
}
exports.SuspendedToolState = SuspendedToolState;
/** @internal */
class CurrentInputState {
    constructor() {
        this._rawPoint = new geometry_core_1.Point3d();
        this._uorPoint = new geometry_core_1.Point3d();
        this._viewPoint = new geometry_core_1.Point3d();
        this.qualifiers = Tool_1.BeModifierKeys.None;
        this.motionTime = 0;
        this.button = [new Tool_1.BeButtonState(), new Tool_1.BeButtonState(), new Tool_1.BeButtonState()];
        this.lastButton = Tool_1.BeButton.Data;
        this.inputSource = Tool_1.InputSource.Unknown;
        this.lastMotion = new geometry_core_1.Point2d();
    }
    get rawPoint() { return this._rawPoint; }
    set rawPoint(pt) { this._rawPoint.setFrom(pt); }
    get uorPoint() { return this._uorPoint; }
    set uorPoint(pt) { this._uorPoint.setFrom(pt); }
    get viewPoint() { return this._viewPoint; }
    set viewPoint(pt) { this._viewPoint.setFrom(pt); }
    get wasMotion() { return 0 !== this.motionTime; }
    get isShiftDown() { return 0 !== (this.qualifiers & Tool_1.BeModifierKeys.Shift); }
    get isControlDown() { return 0 !== (this.qualifiers & Tool_1.BeModifierKeys.Control); }
    get isAltDown() { return 0 !== (this.qualifiers & Tool_1.BeModifierKeys.Alt); }
    isDragging(button) { return this.button[button].isDragging; }
    onStartDrag(button) { this.button[button].isDragging = true; }
    onInstallTool() { this.clearKeyQualifiers(); if (undefined !== this.lastWheelEvent)
        this.lastWheelEvent.invalidate(); this.lastTouchStart = this.touchTapTimer = this.touchTapCount = undefined; }
    clearKeyQualifiers() { this.qualifiers = Tool_1.BeModifierKeys.None; }
    clearViewport(vp) { if (vp === this.viewport)
        this.viewport = undefined; }
    isAnyDragging() { return this.button.some((button) => button.isDragging); }
    setKeyQualifier(qual, down) { this.qualifiers = down ? (this.qualifiers | qual) : (this.qualifiers & (~qual)); }
    setKeyQualifiers(ev) {
        this.setKeyQualifier(Tool_1.BeModifierKeys.Shift, ev.shiftKey);
        this.setKeyQualifier(Tool_1.BeModifierKeys.Control, ev.ctrlKey);
        this.setKeyQualifier(Tool_1.BeModifierKeys.Alt, ev.altKey);
    }
    onMotion(pt2d) {
        this.motionTime = Date.now();
        this.lastMotion.x = pt2d.x;
        this.lastMotion.y = pt2d.y;
    }
    get hasMotionStopped() {
        const result = this.hasEventInputStopped(this.motionTime, Tool_1.ToolSettings.noMotionTimeout);
        if (result.stopped)
            this.motionTime = result.eventTimer;
        return result.stopped;
    }
    hasEventInputStopped(timer, eventTimeout) {
        let isStopped = false;
        if (0 !== timer && ((Date.now() - timer) >= eventTimeout.milliseconds)) {
            isStopped = true;
            timer = 0;
        }
        return { eventTimer: timer, stopped: isStopped };
    }
    changeButtonToDownPoint(ev) {
        ev.point = this.button[ev.button].downUorPt;
        ev.rawPoint = this.button[ev.button].downRawPt;
        if (ev.viewport)
            ev.viewPoint = ev.viewport.worldToView(ev.rawPoint);
    }
    updateDownPoint(ev) { this.button[ev.button].downUorPt = ev.point; }
    onButtonDown(button) {
        const viewPt = this.viewport.worldToView(this.button[button].downRawPt);
        const center = this.viewport.npcToView(imodeljs_common_1.NpcCenter);
        viewPt.z = center.z;
        const now = Date.now();
        const isDoubleClick = ((now - this.button[button].downTime) < Tool_1.ToolSettings.doubleClickTimeout.milliseconds) && (viewPt.distance(this.viewPoint) < this.viewport.pixelsFromInches(Tool_1.ToolSettings.doubleClickToleranceInches));
        this.button[button].init(this.uorPoint, this.rawPoint, now, true, isDoubleClick, false, this.inputSource);
        this.lastButton = button;
    }
    onButtonUp(button) {
        this.button[button].isDown = false;
        this.button[button].isDragging = false;
        this.lastButton = button;
    }
    toEvent(ev, useSnap) {
        let coordsFrom = Tool_1.CoordSource.User;
        const point = this.uorPoint.clone();
        let viewport = this.viewport;
        if (useSnap) {
            const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
            if (snap) {
                coordsFrom = snap.isHot ? Tool_1.CoordSource.ElemSnap : Tool_1.CoordSource.User;
                point.setFrom(snap.isPointAdjusted ? snap.adjustedPoint : snap.getPoint()); // NOTE: adjustedPoint can be set by adjustSnapPoint even when not hot...
                viewport = snap.viewport;
            }
            else if (IModelApp_1.IModelApp.tentativePoint.isActive) {
                coordsFrom = Tool_1.CoordSource.TentativePoint;
                point.setFrom(IModelApp_1.IModelApp.tentativePoint.getPoint());
                viewport = IModelApp_1.IModelApp.tentativePoint.viewport;
            }
        }
        const buttonState = this.button[this.lastButton];
        ev.init({
            point, rawPoint: this.rawPoint, viewPoint: this.viewPoint, viewport, coordsFrom,
            keyModifiers: this.qualifiers, button: this.lastButton, isDown: buttonState.isDown,
            isDoubleClick: buttonState.isDoubleClick, isDragging: buttonState.isDragging,
            inputSource: this.inputSource,
        });
    }
    adjustLastDataPoint(ev) {
        const state = this.button[Tool_1.BeButton.Data];
        state.downUorPt = ev.point;
        state.downRawPt = ev.point;
        this.viewport = ev.viewport;
    }
    toEventFromLastDataPoint(ev) {
        const state = this.button[Tool_1.BeButton.Data];
        const point = state.downUorPt;
        const rawPoint = state.downRawPt;
        const viewPoint = this.viewport.worldToView(rawPoint);
        ev.init({
            point, rawPoint, viewPoint, viewport: this.viewport, coordsFrom: Tool_1.CoordSource.User,
            keyModifiers: this.qualifiers, button: Tool_1.BeButton.Data, isDown: state.isDown,
            isDoubleClick: state.isDoubleClick, isDragging: state.isDragging, inputSource: state.inputSource,
        });
    }
    fromPoint(vp, pt, source) {
        this.viewport = vp;
        this._viewPoint.x = pt.x;
        this._viewPoint.y = pt.y;
        this._viewPoint.z = vp.npcToView(imodeljs_common_1.NpcCenter).z;
        vp.viewToWorld(this._viewPoint, this._rawPoint);
        this._uorPoint = this._rawPoint.clone();
        this.inputSource = source;
    }
    fromButton(vp, pt, source, applyLocks) {
        this.fromPoint(vp, pt, source);
        // NOTE: Using the hit point on the element is preferable to ignoring a snap that is not "hot" completely
        if (AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false)) {
            if (applyLocks)
                IModelApp_1.IModelApp.toolAdmin.adjustSnapPoint();
            return;
        }
        IModelApp_1.IModelApp.toolAdmin.adjustPoint(this._uorPoint, vp, true, applyLocks);
    }
    isStartDrag(button) {
        // First make sure we aren't already dragging any button
        if (this.isAnyDragging())
            return false;
        const state = this.button[button];
        if (!state.isDown)
            return false;
        if ((Date.now() - state.downTime) <= Tool_1.ToolSettings.startDragDelay.milliseconds)
            return false;
        const viewPt = this.viewport.worldToView(state.downRawPt);
        const deltaX = Math.abs(this._viewPoint.x - viewPt.x);
        const deltaY = Math.abs(this._viewPoint.y - viewPt.y);
        return ((deltaX + deltaY) > this.viewport.pixelsFromInches(Tool_1.ToolSettings.startDragDistanceInches));
    }
}
exports.CurrentInputState = CurrentInputState;
/** Controls operation of Tools. Administers the current view, primitive, and idle tools. Forwards events to the appropriate tool.
 * @public
 */
class ToolAdmin {
    constructor() {
        /** @internal */
        this.currentInputState = new CurrentInputState();
        /** @internal */
        this.toolState = new ToolState();
        /** @internal */
        this.toolSettingsState = new ToolSettingsState();
        this._saveLocateCircle = false;
        this._modifierKeyWentDown = false;
        this._defaultToolId = "Select";
        this._modifierKey = Tool_1.BeModifierKeys.None;
        /** Apply operations such as transform, copy or delete to all members of an assembly. */
        this.assemblyLock = false;
        /** If Grid Lock is on, project data points to grid. */
        this.gridLock = false;
        /** If ACS Snap Lock is on, project snap points to the ACS plane. */
        this.acsPlaneSnapLock = false;
        /** If ACS Plane Lock is on, standard view rotations are relative to the ACS instead of global. */
        this.acsContextLock = false;
        /** Handler that wants to process synching latest tool setting properties with UI.
         *  @internal
         */
        this._toolSettingsChangeHandler = undefined;
        /** A first-in-first-out queue of ToolEvents. */
        this._toolEvents = [];
        this._processingEvent = false;
        /**
         * Event raised whenever the active tool changes. This includes PrimitiveTool, ViewTool, and InputCollector.
         * @param newTool The newly activated tool
         */
        this.activeToolChanged = new bentleyjs_core_1.BeEvent();
        /**
         * Event raised by tools that support edit manipulators like the SelectTool.
         * @param tool The current tool
         * @alpha
         */
        this.manipulatorToolEvent = new bentleyjs_core_1.BeEvent();
    }
    /** Return the name of the [[PrimitiveTool]] to use as the default tool, if any.
     * @see [[startDefaultTool]]
     * @internal
     */
    get defaultToolId() { return this._defaultToolId; }
    /** Set the name of the [[PrimitiveTool]] to use as the default tool, if any.
     * @see [[startDefaultTool]]
     * @internal
     */
    set defaultToolId(toolId) { this._defaultToolId = toolId; }
    /** Return the default arguments to pass in when starting the default tool, if any.
     * @see [[startDefaultTool]]
     * @internal
     */
    get defaultToolArgs() { return this._defaultToolArgs; }
    /** Set the default arguments to pass in when starting the default tool, if any.
     * @see [[startDefaultTool]]
     * @internal
     */
    set defaultToolArgs(args) { this._defaultToolArgs = args; }
    /** @internal */
    /** Set by object that will be provide UI for tool settings properties. */
    set toolSettingsChangeHandler(handler) {
        this._toolSettingsChangeHandler = handler;
    }
    /** @internal */
    get toolSettingsChangeHandler() { return this._toolSettingsChangeHandler; }
    /** @internal */
    onInitialized() {
        if (typeof document === "undefined")
            return; // if document isn't defined, we're probably running in a test environment. At any rate, we can't have interactive tools.
        this._idleTool = IModelApp_1.IModelApp.tools.create("Idle");
        ["keydown", "keyup"].forEach((type) => {
            document.addEventListener(type, ToolAdmin._keyEventHandler, false);
            ToolAdmin._removals.push(() => { document.removeEventListener(type, ToolAdmin._keyEventHandler, false); });
        });
        // the list of currently down keys can get out of sync if a key goes down and then we lose focus. Clear the list every time we get focus.
        window.onfocus = () => { ToolAdmin._keysCurrentlyDown.clear(); };
        ToolAdmin._removals.push(() => { window.onfocus = null; });
    }
    /** @internal */
    startEventLoop() {
        if (!ToolAdmin._wantEventLoop) {
            ToolAdmin._wantEventLoop = true;
            requestAnimationFrame(ToolAdmin.eventLoop);
        }
    }
    /** @internal */
    onShutDown() {
        this._idleTool = undefined;
        Sprites_1.IconSprites.emptyAll(); // clear cache of icon sprites
        ToolAdmin._wantEventLoop = false;
        ToolAdmin._removals.forEach((remove) => remove());
        ToolAdmin._removals.length = 0;
    }
    /** Get the ScreenViewport where the cursor is currently, if any. */
    get cursorView() { return this.currentInputState.viewport; }
    tryReplace(event) {
        if (this._toolEvents.length < 1)
            return false;
        const last = this._toolEvents[this._toolEvents.length - 1];
        if ((last.ev.type !== "mousemove" && last.ev.type !== "touchmove") || last.ev.type !== event.ev.type)
            return false; // only mousemove and touchmove can replace previous
        last.ev = event.ev; // sequential moves are not important. Replace the previous one with this one.
        last.vp = event.vp;
        return true;
    }
    /** Called from HTML event listeners. Events are processed in the order they're received in ToolAdmin.eventLoop
     * @internal
     */
    addEvent(ev, vp) {
        const event = { ev, vp };
        if (!this.tryReplace(event)) // see if this event replaces the last event in the queue
            this._toolEvents.push(event); // otherwise put it at the end of the queue.
    }
    getMousePosition(event) {
        const ev = event.ev;
        const rect = event.vp.getClientRect();
        return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };
    }
    getMouseButton(button) {
        switch (button) {
            case 1 /* Middle */: return Tool_1.BeButton.Middle;
            case 2 /* Right */: return Tool_1.BeButton.Reset;
            default: return Tool_1.BeButton.Data;
        }
    }
    async onMouseButton(event, isDown) {
        const ev = event.ev;
        const vp = event.vp;
        const pos = this.getMousePosition(event);
        const button = this.getMouseButton(ev.button);
        this.currentInputState.setKeyQualifiers(ev);
        return isDown ? this.onButtonDown(vp, pos, button, Tool_1.InputSource.Mouse) : this.onButtonUp(vp, pos, button, Tool_1.InputSource.Mouse);
    }
    async onWheel(event) {
        const ev = event.ev;
        const vp = event.vp;
        if (this.filterViewport(vp))
            return Tool_1.EventHandled.Yes;
        const current = this.currentInputState;
        current.setKeyQualifiers(ev);
        if (ev.deltaY === 0)
            return Tool_1.EventHandled.No;
        let delta;
        switch (ev.deltaMode) {
            case ev.DOM_DELTA_LINE:
                delta = -ev.deltaY * Tool_1.ToolSettings.wheelLineFactor; // 40
                break;
            case ev.DOM_DELTA_PAGE:
                delta = -ev.deltaY * Tool_1.ToolSettings.wheelPageFactor; // 120;
                break;
            default: // DOM_DELTA_PIXEL:
                delta = -ev.deltaY;
                break;
        }
        const pt2d = this.getMousePosition(event);
        vp.removeAnimator();
        current.fromButton(vp, pt2d, Tool_1.InputSource.Mouse, true);
        const wheelEvent = new Tool_1.BeWheelEvent();
        wheelEvent.wheelDelta = delta;
        current.toEvent(wheelEvent, true);
        const overlayHit = this.pickCanvasDecoration(wheelEvent);
        if (undefined !== overlayHit && undefined !== overlayHit.onWheel && overlayHit.onWheel(wheelEvent))
            return Tool_1.EventHandled.Yes;
        const tool = this.activeTool;
        if (undefined === tool || Tool_1.EventHandled.Yes !== await tool.onMouseWheel(wheelEvent) && vp !== this.markupView)
            return this.idleTool.onMouseWheel(wheelEvent);
        return Tool_1.EventHandled.Yes;
    }
    async onTouch(event) {
        const touchEvent = event.ev;
        const vp = event.vp;
        if (this.filterViewport(vp))
            return;
        vp.removeAnimator();
        const ev = new Tool_1.BeTouchEvent({ touchEvent });
        const current = this.currentInputState;
        const pos = Tool_1.BeTouchEvent.getTouchListCentroid(0 !== touchEvent.targetTouches.length ? touchEvent.targetTouches : touchEvent.changedTouches, vp);
        switch (touchEvent.type) {
            case "touchstart":
            case "touchend":
                current.setKeyQualifiers(touchEvent);
                break;
        }
        current.fromButton(vp, undefined !== pos ? pos : geometry_core_1.Point2d.createZero(), Tool_1.InputSource.Touch, true);
        current.toEvent(ev, false);
        const tool = this.activeTool;
        switch (touchEvent.type) {
            case "touchstart": {
                current.lastTouchStart = ev;
                IModelApp_1.IModelApp.accuSnap.onTouchStart(ev);
                if (undefined !== tool)
                    tool.onTouchStart(ev); // tslint:disable-line:no-floating-promises
                return;
            }
            case "touchend": {
                IModelApp_1.IModelApp.accuSnap.onTouchEnd(ev);
                if (undefined !== tool) {
                    await tool.onTouchEnd(ev);
                    if (0 === ev.touchCount)
                        await tool.onTouchComplete(ev);
                }
                if (undefined === current.lastTouchStart)
                    return;
                // tslint:disable-next-line:prefer-for-of
                for (let i = 0; i < ev.touchEvent.changedTouches.length; i++) {
                    const currTouch = ev.touchEvent.changedTouches[i];
                    const startTouch = Tool_1.BeTouchEvent.findTouchById(current.lastTouchStart.touchEvent.targetTouches, currTouch.identifier);
                    if (undefined !== startTouch) {
                        const currPt = Tool_1.BeTouchEvent.getTouchPosition(currTouch, vp);
                        const startPt = Tool_1.BeTouchEvent.getTouchPosition(startTouch, vp);
                        if (currPt.distance(startPt) < vp.pixelsFromInches(Tool_1.ToolSettings.touchMoveDistanceInches))
                            continue; // Hasn't moved appreciably....
                    }
                    current.lastTouchStart = undefined; // Not a tap...
                    return;
                }
                if (0 !== ev.touchCount || undefined === current.lastTouchStart)
                    return;
                // All fingers off, defer processing tap until we've waited long enough to detect double tap...
                if (undefined === current.touchTapTimer) {
                    current.touchTapTimer = Date.now();
                    current.touchTapCount = 1;
                }
                else if (undefined !== current.touchTapCount) {
                    current.touchTapCount++;
                }
                return;
            }
            case "touchcancel": {
                current.lastTouchStart = undefined;
                IModelApp_1.IModelApp.accuSnap.onTouchCancel(ev);
                if (undefined !== tool)
                    tool.onTouchCancel(ev); // tslint:disable-line:no-floating-promises
                return;
            }
            case "touchmove": {
                if (!IModelApp_1.IModelApp.accuSnap.onTouchMove(ev) && undefined !== tool)
                    tool.onTouchMove(ev); // tslint:disable-line:no-floating-promises
                if (undefined === current.lastTouchStart)
                    return;
                if (ev.touchEvent.timeStamp - current.lastTouchStart.touchEvent.timeStamp < Tool_1.ToolSettings.touchMoveDelay.milliseconds)
                    return;
                // tslint:disable-next-line:prefer-for-of
                for (let i = 0; i < ev.touchEvent.changedTouches.length; i++) {
                    const currTouch = ev.touchEvent.changedTouches[i];
                    const startTouch = Tool_1.BeTouchEvent.findTouchById(current.lastTouchStart.touchEvent.targetTouches, currTouch.identifier);
                    if (undefined === startTouch)
                        continue;
                    const currPt = Tool_1.BeTouchEvent.getTouchPosition(currTouch, vp);
                    const startPt = Tool_1.BeTouchEvent.getTouchPosition(startTouch, vp);
                    if (currPt.distance(startPt) < vp.pixelsFromInches(Tool_1.ToolSettings.touchMoveDistanceInches))
                        continue; // Hasn't moved appreciably....
                    const touchStart = current.lastTouchStart;
                    current.lastTouchStart = undefined;
                    if (IModelApp_1.IModelApp.accuSnap.onTouchMoveStart(ev, touchStart))
                        return;
                    if (undefined === tool || Tool_1.EventHandled.Yes !== await tool.onTouchMoveStart(ev, touchStart))
                        this.idleTool.onTouchMoveStart(ev, touchStart); // tslint:disable-line:no-floating-promises
                    return;
                }
                return;
            }
        }
    }
    /** Process the next event in the event queue, if any. */
    async processNextEvent() {
        const event = this._toolEvents.shift(); // pull first event from the queue
        if (undefined === event)
            return; // nothing in queue
        switch (event.ev.type) {
            case "mousedown": return this.onMouseButton(event, true);
            case "mouseup": return this.onMouseButton(event, false);
            case "mousemove": return this.onMouseMove(event);
            case "mouseenter": return this.onMouseEnter(event.vp);
            case "mouseleave": return this.onMouseLeave(event.vp);
            case "wheel": return this.onWheel(event);
            case "keydown": return this.onKeyTransition(event, true);
            case "keyup": return this.onKeyTransition(event, false);
            case "touchstart": return this.onTouch(event);
            case "touchend": return this.onTouch(event);
            case "touchcancel": return this.onTouch(event);
            case "touchmove": return this.onTouch(event);
        }
    }
    /**
     * Process a single event, plus timer events. Don't start work on new events if the previous one has not finished.
     */
    async processEvent() {
        if (this._processingEvent)
            return; // we're still working on the previous event.
        try {
            this._processingEvent = true; // we can't allow any further event processing until the current event completes.
            await this.onTimerEvent(); // timer events are also suspended by asynchronous tool events. That's necessary since they can be asynchronous too.
            await this.processNextEvent();
        }
        catch (error) {
            throw error; // enable this in debug only.
        }
        finally {
            this._processingEvent = false; // this event is now finished. Allow processing next time through.
        }
    }
    /** The main event processing loop for Tools (and rendering). */
    static eventLoop() {
        if (!ToolAdmin._wantEventLoop) // flag turned on at startup
            return;
        IModelApp_1.IModelApp.toolAdmin.processEvent(); // tslint:disable-line:no-floating-promises
        IModelApp_1.IModelApp.viewManager.renderLoop();
        IModelApp_1.IModelApp.tileAdmin.process();
        requestAnimationFrame(ToolAdmin.eventLoop);
    }
    /** The idleTool handles events that are not otherwise processed. */
    get idleTool() { return this._idleTool; }
    /** Return true to filter (ignore) events to the given viewport */
    filterViewport(vp) {
        if (undefined === vp)
            return true;
        const tool = this.activeTool;
        return (undefined !== tool ? !tool.isCompatibleViewport(vp, false) : false);
    }
    /** @internal */
    onInstallTool(tool) { this.currentInputState.onInstallTool(); return tool.onInstall(); }
    /** @internal */
    onPostInstallTool(tool) { tool.onPostInstall(); }
    get viewTool() { return this._viewTool; }
    get primitiveTool() { return this._primitiveTool; }
    /** The currently active InteractiveTool. May be ViewTool, InputCollector, PrimitiveTool, undefined - in that priority order. */
    get activeTool() {
        return this._viewTool ? this._viewTool : (this._inputCollector ? this._inputCollector : this._primitiveTool); // NOTE: Viewing tools suspend input collectors as well as primitives
    }
    /** The current tool. May be ViewTool, InputCollector, PrimitiveTool, or IdleTool - in that priority order. */
    get currentTool() { return this.activeTool ? this.activeTool : this.idleTool; }
    /** Ask the current tool to provide tooltip contents for the supplied HitDetail. */
    async getToolTip(hit) { return this.currentTool.getToolTip(hit); }
    async onMouseEnter(vp) { this.currentInputState.viewport = vp; }
    /** @internal */
    async onMouseLeave(vp) {
        IModelApp_1.IModelApp.accuSnap.clear();
        this.currentInputState.clearViewport(vp);
        this.setCanvasDecoration(vp);
        vp.invalidateDecorations(); // stop drawing locate circle...
    }
    /** @internal */
    updateDynamics(ev, useLastData, adjustPoint) {
        if (!IModelApp_1.IModelApp.viewManager.inDynamicsMode || undefined === this.activeTool)
            return;
        if (undefined === ev) {
            ev = new Tool_1.BeButtonEvent();
            if (useLastData)
                this.fillEventFromLastDataButton(ev);
            else
                this.fillEventFromCursorLocation(ev);
            if (adjustPoint && undefined !== ev.viewport)
                this.adjustPoint(ev.point, ev.viewport);
        }
        if (undefined === ev.viewport)
            return;
        const context = new ViewContext_1.DynamicsContext(ev.viewport);
        this.activeTool.onDynamicFrame(ev, context);
        context.changeDynamics();
    }
    /** This is invoked on a timer to update  input state and forward events to tools.
     * @internal
     */
    async onTimerEvent() {
        const tool = this.activeTool;
        const current = this.currentInputState;
        if (undefined !== current.touchTapTimer) {
            const now = Date.now();
            if ((now - current.touchTapTimer) >= Tool_1.ToolSettings.doubleTapTimeout.milliseconds) {
                const touchEv = current.lastTouchStart;
                const numTouches = (undefined !== current.lastTouchStart ? current.lastTouchStart.touchCount : 0);
                const numTaps = (undefined !== current.touchTapCount ? current.touchTapCount : 0);
                current.touchTapTimer = current.touchTapCount = current.lastTouchStart = undefined;
                if (undefined !== touchEv && numTouches > 0 && numTaps > 0) {
                    touchEv.tapCount = numTaps;
                    const overlayHit = this.pickCanvasDecoration(touchEv);
                    if (undefined !== overlayHit && undefined !== overlayHit.onMouseButton && overlayHit.onMouseButton(touchEv))
                        return;
                    if (await IModelApp_1.IModelApp.accuSnap.onTouchTap(touchEv))
                        return;
                    if ((undefined !== tool && Tool_1.EventHandled.Yes === await tool.onTouchTap(touchEv)) || Tool_1.EventHandled.Yes === await this.idleTool.onTouchTap(touchEv))
                        return;
                }
            }
        }
        const ev = new Tool_1.BeButtonEvent();
        current.toEvent(ev, true);
        const wasMotion = current.wasMotion;
        if (!wasMotion) {
            if (tool)
                await tool.onMouseNoMotion(ev);
            if (Tool_1.InputSource.Mouse === current.inputSource && this.currentInputState.viewport) {
                await IModelApp_1.IModelApp.accuSnap.onNoMotion(ev);
            }
        }
        if (current.hasMotionStopped) {
            if (tool)
                await tool.onMouseMotionStopped(ev);
            if (Tool_1.InputSource.Mouse === current.inputSource) {
                IModelApp_1.IModelApp.accuSnap.onMotionStopped(ev);
            }
        }
    }
    async sendEndDragEvent(ev) {
        let tool = this.activeTool;
        if (undefined !== tool) {
            if (!tool.isValidLocation(ev, true))
                tool = undefined;
            else if (tool.receivedDownEvent)
                tool.receivedDownEvent = false;
            else
                tool = undefined;
        }
        // Don't send tool end drag event if it didn't get the start drag event
        if (undefined === tool || Tool_1.EventHandled.Yes !== await tool.onMouseEndDrag(ev))
            return this.idleTool.onMouseEndDrag(ev);
    }
    setCanvasDecoration(vp, dec, ev) {
        if (dec === this._canvasDecoration)
            return;
        if (this._canvasDecoration && this._canvasDecoration.onMouseLeave)
            this._canvasDecoration.onMouseLeave();
        this._canvasDecoration = dec;
        if (ev && dec && dec.onMouseEnter)
            dec.onMouseEnter(ev);
        vp.canvas.style.cursor = dec ? (dec.decorationCursor ? dec.decorationCursor : "pointer") : IModelApp_1.IModelApp.viewManager.cursor;
        vp.invalidateDecorations();
    }
    pickCanvasDecoration(ev) {
        const vp = ev.viewport;
        const decoration = (undefined === this.viewTool) ? vp.pickCanvasDecoration(ev.viewPoint) : undefined;
        this.setCanvasDecoration(vp, decoration, ev);
        return decoration;
    }
    async onMotion(vp, pt2d, inputSource, forceStartDrag = false) {
        const current = this.currentInputState;
        current.onMotion(pt2d);
        if (this.filterViewport(vp)) {
            this.setIncompatibleViewportCursor(false);
            return;
        }
        const ev = new Tool_1.BeButtonEvent();
        current.fromPoint(vp, pt2d, inputSource);
        current.toEvent(ev, false);
        const overlayHit = this.pickCanvasDecoration(ev);
        if (undefined !== overlayHit) {
            if (overlayHit.onMouseMove)
                overlayHit.onMouseMove(ev);
            return; // we're inside a pickable decoration, don't send event to tool
        }
        await IModelApp_1.IModelApp.accuSnap.onMotion(ev); // wait for AccuSnap before calling fromButton
        current.fromButton(vp, pt2d, inputSource, true);
        current.toEvent(ev, true);
        IModelApp_1.IModelApp.accuDraw.onMotion(ev);
        const tool = this.activeTool;
        const isValidLocation = (undefined !== tool ? tool.isValidLocation(ev, false) : true);
        this.setIncompatibleViewportCursor(isValidLocation);
        if (forceStartDrag || current.isStartDrag(ev.button)) {
            current.onStartDrag(ev.button);
            current.changeButtonToDownPoint(ev);
            ev.isDragging = true;
            if (undefined !== tool && isValidLocation)
                tool.receivedDownEvent = true;
            // Pass start drag event to idle tool if active tool doesn't explicitly handle it
            if (undefined === tool || !isValidLocation || Tool_1.EventHandled.Yes !== await tool.onMouseStartDrag(ev))
                return this.idleTool.onMouseStartDrag(ev);
            return;
        }
        if (tool) {
            tool.onMouseMotion(ev); // tslint:disable-line:no-floating-promises
            this.updateDynamics(ev);
        }
        if (this.isLocateCircleOn)
            vp.invalidateDecorations();
    }
    async onMouseMove(event) {
        const vp = event.vp;
        const pos = this.getMousePosition(event);
        // Sometimes the mouse goes down in a view, but we lose focus while its down so we never receive the up event.
        // That makes it look like the motion is a drag. Fix that by clearing the "isDown" based on the buttons member of the MouseEvent.
        const buttonMask = event.ev.buttons;
        if (!(buttonMask & 1))
            this.currentInputState.button[Tool_1.BeButton.Data].isDown = false;
        return this.onMotion(vp, pos, Tool_1.InputSource.Mouse);
    }
    adjustPointToACS(pointActive, vp, perpendicular) {
        // The "I don't want ACS lock" flag can be set by tools to override the default behavior
        if (0 !== (this.toolState.coordLockOvr & Tool_1.CoordinateLockOverrides.ACS))
            return;
        let viewZRoot;
        // Lock to the construction plane
        if (vp.view.is3d() && vp.view.isCameraOn)
            viewZRoot = vp.view.camera.eye.vectorTo(pointActive);
        else
            viewZRoot = vp.rotation.getRow(2);
        const auxOriginRoot = vp.getAuxCoordOrigin();
        const auxRMatrixRoot = vp.getAuxCoordRotation();
        let auxNormalRoot = auxRMatrixRoot.getRow(2);
        // If ACS xy plane is perpendicular to view and not snapping, project to closest xz or yz plane instead
        if (auxNormalRoot.isPerpendicularTo(viewZRoot) && !AccuSnap_1.TentativeOrAccuSnap.isHot) {
            const auxXRoot = auxRMatrixRoot.getRow(0);
            const auxYRoot = auxRMatrixRoot.getRow(1);
            auxNormalRoot = (Math.abs(auxXRoot.dotProduct(viewZRoot)) > Math.abs(auxYRoot.dotProduct(viewZRoot))) ? auxXRoot : auxYRoot;
        }
        Viewport_1.linePlaneIntersect(pointActive, pointActive, viewZRoot, auxOriginRoot, auxNormalRoot, perpendicular);
    }
    adjustPointToGrid(pointActive, vp) {
        // The "I don't want grid lock" flag can be set by tools to override the default behavior
        if (!this.gridLock || 0 !== (this.toolState.coordLockOvr & Tool_1.CoordinateLockOverrides.Grid))
            return;
        vp.pointToGrid(pointActive);
    }
    adjustPoint(pointActive, vp, projectToACS = true, applyLocks = true) {
        if (Math.abs(pointActive.z) < 1.0e-7)
            pointActive.z = 0.0; // remove Z fuzz introduced by active depth when near 0
        let handled = false;
        if (applyLocks && !(IModelApp_1.IModelApp.tentativePoint.isActive || IModelApp_1.IModelApp.accuSnap.isHot))
            handled = IModelApp_1.IModelApp.accuDraw.adjustPoint(pointActive, vp, false);
        // NOTE: We don't need to support axis lock, it is worthless if you have AccuDraw
        if (!handled && vp.isPointAdjustmentRequired) {
            if (applyLocks)
                this.adjustPointToGrid(pointActive, vp);
            if (projectToACS)
                this.adjustPointToACS(pointActive, vp, false);
        }
        else if (applyLocks) {
            const savePoint = pointActive.clone();
            this.adjustPointToGrid(pointActive, vp);
            // if grid lock changes point, resend point to accudraw
            if (handled && !pointActive.isExactEqual(savePoint))
                IModelApp_1.IModelApp.accuDraw.adjustPoint(pointActive, vp, false);
        }
        if (Math.abs(pointActive.z) < 1.0e-7)
            pointActive.z = 0.0;
    }
    adjustSnapPoint(perpendicular = true) {
        const snap = AccuSnap_1.TentativeOrAccuSnap.getCurrentSnap(false);
        if (!snap)
            return;
        const vp = snap.viewport;
        const isHot = snap.isHot;
        const point = snap.getPoint().clone();
        const savePt = point.clone();
        if (!isHot) // Want point adjusted to grid for a hit that isn't hot
            this.adjustPointToGrid(point, vp);
        if (!IModelApp_1.IModelApp.accuDraw.adjustPoint(point, vp, isHot)) {
            if (vp.isSnapAdjustmentRequired)
                this.adjustPointToACS(point, vp, perpendicular || IModelApp_1.IModelApp.accuDraw.isActive);
        }
        if (!point.isExactEqual(savePt))
            snap.adjustedPoint.setFrom(point);
    }
    /** @internal */
    async sendButtonEvent(ev) {
        const overlayHit = this.pickCanvasDecoration(ev);
        if (undefined !== overlayHit && undefined !== overlayHit.onMouseButton && overlayHit.onMouseButton(ev))
            return;
        if (IModelApp_1.IModelApp.accuSnap.onPreButtonEvent(ev))
            return;
        const activeTool = this.activeTool;
        let tool = activeTool;
        if (undefined !== tool) {
            if (!tool.isValidLocation(ev, true))
                tool = undefined;
            else if (ev.isDown)
                tool.receivedDownEvent = true;
            else if (tool.receivedDownEvent)
                tool.receivedDownEvent = false;
            else
                tool = undefined;
        }
        if (IModelApp_1.IModelApp.accuDraw.onPreButtonEvent(ev))
            return;
        switch (ev.button) {
            case Tool_1.BeButton.Data: {
                if (undefined === tool) {
                    if (undefined !== activeTool)
                        break;
                    tool = this.idleTool; // Pass data button event to idle tool when no active tool present
                }
                if (ev.isDown) {
                    await tool.onDataButtonDown(ev);
                }
                else {
                    await tool.onDataButtonUp(ev);
                    break;
                }
                // Lock tool to target model of this view on first data button
                if (tool instanceof PrimitiveTool_1.PrimitiveTool)
                    tool.autoLockTarget();
                // Update tool dynamics. Use last data button location which was potentially adjusted by onDataButtonDown and not current event
                this.updateDynamics(undefined, true);
                break;
            }
            case Tool_1.BeButton.Reset: {
                if (undefined === tool) {
                    if (undefined !== activeTool)
                        break;
                    tool = this.idleTool; // Pass reset button event to idle tool when no active tool present
                }
                if (ev.isDown)
                    await tool.onResetButtonDown(ev);
                else
                    await tool.onResetButtonUp(ev);
                break;
            }
            case Tool_1.BeButton.Middle: {
                // Pass middle button event to idle tool when active tool doesn't explicitly handle it
                if (ev.isDown) {
                    if (undefined === tool || Tool_1.EventHandled.Yes !== await tool.onMiddleButtonDown(ev))
                        await this.idleTool.onMiddleButtonDown(ev);
                }
                else {
                    if (undefined === tool || Tool_1.EventHandled.Yes !== await tool.onMiddleButtonUp(ev))
                        await this.idleTool.onMiddleButtonUp(ev);
                }
                break;
            }
        }
        IModelApp_1.IModelApp.tentativePoint.onButtonEvent(ev);
        IModelApp_1.IModelApp.accuDraw.onPostButtonEvent(ev);
    }
    async onButtonDown(vp, pt2d, button, inputSource) {
        const filtered = this.filterViewport(vp);
        if (undefined === this._viewTool && button === Tool_1.BeButton.Data)
            IModelApp_1.IModelApp.viewManager.setSelectedView(vp);
        if (filtered)
            return;
        vp.removeAnimator();
        const ev = new Tool_1.BeButtonEvent();
        const current = this.currentInputState;
        current.fromButton(vp, pt2d, inputSource, true);
        current.onButtonDown(button);
        current.toEvent(ev, true);
        current.updateDownPoint(ev);
        return this.sendButtonEvent(ev);
    }
    async onButtonUp(vp, pt2d, button, inputSource) {
        if (this.filterViewport(vp))
            return;
        const ev = new Tool_1.BeButtonEvent();
        const current = this.currentInputState;
        const wasDragging = current.isDragging(button);
        current.fromButton(vp, pt2d, inputSource, true);
        current.onButtonUp(button);
        current.toEvent(ev, true);
        if (wasDragging)
            return this.sendEndDragEvent(ev);
        current.changeButtonToDownPoint(ev);
        return this.sendButtonEvent(ev);
    }
    /** Called when any *modifier* (Shift, Alt, or Control) key is pressed or released. */
    async onModifierKeyTransition(wentDown, modifier, event) {
        if (wentDown === this._modifierKeyWentDown && modifier === this._modifierKey)
            return;
        const activeTool = this.activeTool;
        const changed = activeTool ? await activeTool.onModifierKeyTransition(wentDown, modifier, event) : Tool_1.EventHandled.No;
        this._modifierKey = modifier;
        this._modifierKeyWentDown = wentDown;
        if (changed === Tool_1.EventHandled.Yes) {
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            this.updateDynamics();
        }
    }
    static getModifierKey(event) {
        switch (event.key) {
            case "Alt": return Tool_1.BeModifierKeys.Alt;
            case "Shift": return Tool_1.BeModifierKeys.Shift;
            case "Control": return Tool_1.BeModifierKeys.Control;
        }
        return Tool_1.BeModifierKeys.None;
    }
    /** Event for every key down and up transition. */
    async onKeyTransition(event, wentDown) {
        const activeTool = this.activeTool;
        if (!activeTool)
            return;
        const keyEvent = event.ev;
        this.currentInputState.setKeyQualifiers(keyEvent);
        const modifierKey = ToolAdmin.getModifierKey(keyEvent);
        if (Tool_1.BeModifierKeys.None !== modifierKey)
            return this.onModifierKeyTransition(wentDown, modifierKey, keyEvent);
        if (wentDown && keyEvent.ctrlKey) {
            switch (keyEvent.key) {
                case "z":
                case "Z":
                    return this.doUndoOperation();
                case "y":
                case "Y":
                    return this.doRedoOperation();
            }
        }
        return activeTool.onKeyTransition(wentDown, keyEvent);
    }
    /** Called to undo previous data button for primitive tools or undo last write operation. */
    async doUndoOperation() {
        const activeTool = this.activeTool;
        if (activeTool instanceof PrimitiveTool_1.PrimitiveTool) {
            // ### TODO Add method so UI can be showing string to inform user that undo of last data point is available...
            if (await activeTool.undoPreviousStep())
                return true;
        }
        // ### TODO Request TxnManager undo and restart this.primitiveTool...
        return false;
    }
    /** Called to redo previous data button for primitive tools or undo last write operation. */
    async doRedoOperation() {
        const activeTool = this.activeTool;
        if (activeTool instanceof PrimitiveTool_1.PrimitiveTool) {
            // ### TODO Add method so UI can be showing string to inform user that undo of last data point is available...
            if (await activeTool.redoPreviousStep())
                return true;
        }
        // ### TODO Request TxnManager undo and restart this.primitiveTool...
        return false;
    }
    onUnsuspendTool() {
        const tool = this.activeTool;
        if (tool === undefined)
            return;
        tool.onUnsuspend();
        this.activeToolChanged.raiseEvent(tool, StartOrResume.Resume);
    }
    /** @internal */
    setInputCollector(newTool) {
        if (undefined !== this._inputCollector) {
            this._inputCollector.onCleanup();
            this._inputCollector = undefined;
        }
        this._inputCollector = newTool;
    }
    /** @internal */
    exitInputCollector() {
        if (undefined === this._inputCollector)
            return;
        let unsuspend = false;
        if (this._suspendedByInputCollector) {
            this._suspendedByInputCollector.stop();
            this._suspendedByInputCollector = undefined;
            unsuspend = true;
        }
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        this.setInputCollector(undefined);
        if (unsuspend)
            this.onUnsuspendTool();
        IModelApp_1.IModelApp.accuDraw.onInputCollectorExit();
        this.updateDynamics();
    }
    /** @internal */
    startInputCollector(newTool) {
        IModelApp_1.IModelApp.notifications.outputPrompt("");
        IModelApp_1.IModelApp.accuDraw.onInputCollectorInstall();
        if (undefined !== this._inputCollector) {
            this.setInputCollector(undefined);
        }
        else {
            const tool = this.activeTool;
            if (tool)
                tool.onSuspend();
            this._suspendedByInputCollector = new SuspendedToolState();
        }
        IModelApp_1.IModelApp.viewManager.endDynamicsMode();
        this.activeToolChanged.raiseEvent(newTool, StartOrResume.Start);
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        this.setInputCollector(newTool);
    }
    /** @internal */
    setViewTool(newTool) {
        if (undefined !== this._viewTool) {
            this._viewTool.onCleanup();
            this._viewTool = undefined;
        }
        this._viewTool = newTool;
    }
    /** @internal */
    exitViewTool() {
        if (undefined === this._viewTool)
            return;
        let unsuspend = false;
        if (undefined !== this._suspendedByViewTool) {
            this._suspendedByViewTool.stop(); // Restore state of suspended tool
            this._suspendedByViewTool = undefined;
            unsuspend = true;
        }
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        this.setViewTool(undefined);
        if (unsuspend)
            this.onUnsuspendTool();
        IModelApp_1.IModelApp.accuDraw.onViewToolExit();
        this.updateDynamics();
    }
    /** @internal */
    startViewTool(newTool) {
        IModelApp_1.IModelApp.notifications.outputPrompt("");
        IModelApp_1.IModelApp.accuDraw.onViewToolInstall();
        if (undefined !== this._viewTool) {
            this.setViewTool(undefined);
        }
        else {
            const tool = this.activeTool;
            if (tool)
                tool.onSuspend();
            this._suspendedByViewTool = new SuspendedToolState();
        }
        IModelApp_1.IModelApp.viewManager.endDynamicsMode();
        this.activeToolChanged.raiseEvent(newTool, StartOrResume.Start);
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        this.toolState.coordLockOvr = Tool_1.CoordinateLockOverrides.All;
        this.toolState.locateCircleOn = false;
        IModelApp_1.IModelApp.accuSnap.onStartTool();
        this.setCursor(IModelApp_1.IModelApp.viewManager.crossHairCursor);
        this.setViewTool(newTool);
    }
    /** @internal */
    setPrimitiveTool(newTool) {
        if (undefined !== this._primitiveTool) {
            this._primitiveTool.onCleanup();
            this._primitiveTool = undefined;
        }
        this._primitiveTool = newTool;
    }
    /** @internal */
    startPrimitiveTool(newTool) {
        IModelApp_1.IModelApp.notifications.outputPrompt("");
        this.exitViewTool();
        if (undefined !== this._primitiveTool)
            this.setPrimitiveTool(undefined);
        // clear the primitive tool first so following call does not trigger the refreshing of the ToolSetting for the previous primitive tool
        this.exitInputCollector();
        IModelApp_1.IModelApp.viewManager.endDynamicsMode();
        this.activeToolChanged.raiseEvent(undefined !== newTool ? newTool : this.idleTool, StartOrResume.Start);
        this.setIncompatibleViewportCursor(true); // Don't restore this
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        this.toolState.coordLockOvr = Tool_1.CoordinateLockOverrides.None;
        this.toolState.locateCircleOn = false;
        IModelApp_1.IModelApp.accuDraw.onPrimitiveToolInstall();
        IModelApp_1.IModelApp.accuSnap.onStartTool();
        if (undefined === newTool)
            return;
        this.setCursor(IModelApp_1.IModelApp.viewManager.crossHairCursor);
        this.setPrimitiveTool(newTool);
    }
    /** Method used by interactive tools to send updated values to UI components, typically showing tool settings.
     * @beta
     */
    syncToolSettingsProperties(toolId, syncProperties) {
        if (this.toolSettingsChangeHandler)
            this.toolSettingsChangeHandler(toolId, syncProperties);
    }
    /**
     * Starts the default tool, if any. Generally invoked automatically when other tools exit, so shouldn't be called directly.
     * @note The default tool is expected to be a subclass of [[PrimitiveTool]]. A call to startDefaultTool is required to terminate
     * an active [[ViewTool]] or [[InputCollector]] and replace or clear the current [[PrimitiveTool]].
     * @internal
     */
    startDefaultTool() {
        if (!IModelApp_1.IModelApp.tools.run(this.defaultToolId, this.defaultToolArgs))
            this.startPrimitiveTool(undefined);
    }
    setCursor(cursor) {
        if (undefined === this._saveCursor)
            IModelApp_1.IModelApp.viewManager.setViewCursor(cursor);
        else
            this._saveCursor = cursor;
    }
    /** @internal */
    testDecorationHit(id) { return this.currentTool.testDecorationHit(id); }
    /** @internal */
    getDecorationGeometry(hit) { return this.currentTool.getDecorationGeometry(hit); }
    /** @internal */
    decorate(context) {
        const tool = this.activeTool;
        if (undefined !== tool) {
            tool.decorate(context);
            if (undefined !== this._inputCollector && tool !== this._inputCollector)
                this._inputCollector.decorateSuspended(context);
            if (undefined !== this._primitiveTool && tool !== this._primitiveTool)
                this._primitiveTool.decorateSuspended(context);
        }
        const viewport = this.currentInputState.viewport;
        if (viewport !== context.viewport)
            return;
        const ev = new Tool_1.BeButtonEvent();
        this.fillEventFromCursorLocation(ev);
        const hit = IModelApp_1.IModelApp.accuDraw.isActive ? undefined : IModelApp_1.IModelApp.accuSnap.currHit; // NOTE: Show surface normal until AccuDraw becomes active
        viewport.drawLocateCursor(context, ev.point, viewport.pixelsFromInches(IModelApp_1.IModelApp.locateManager.apertureInches), this.isLocateCircleOn, hit);
    }
    get isLocateCircleOn() { return this.toolState.locateCircleOn && this.currentInputState.inputSource === Tool_1.InputSource.Mouse && this._canvasDecoration === undefined; }
    /** @internal */
    beginDynamics() {
        IModelApp_1.IModelApp.accuDraw.onBeginDynamics();
        IModelApp_1.IModelApp.viewManager.beginDynamicsMode();
        this.setCursor(IModelApp_1.IModelApp.viewManager.dynamicsCursor);
    }
    /** @internal */
    endDynamics() {
        IModelApp_1.IModelApp.accuDraw.onEndDynamics();
        IModelApp_1.IModelApp.viewManager.endDynamicsMode();
        this.setCursor(IModelApp_1.IModelApp.viewManager.crossHairCursor);
    }
    /** @internal */
    fillEventFromCursorLocation(ev) { this.currentInputState.toEvent(ev, true); }
    /** @internal */
    fillEventFromLastDataButton(ev) { this.currentInputState.toEventFromLastDataPoint(ev); }
    /** @internal */
    setAdjustedDataPoint(ev) { this.currentInputState.adjustLastDataPoint(ev); }
    /** Can be called by tools that wish to emulate mouse button down/up events for onTouchTap. */
    async convertTouchTapToButtonDownAndUp(ev, button = Tool_1.BeButton.Data) {
        const pt2d = ev.viewPoint;
        await this.onButtonDown(ev.viewport, pt2d, button, Tool_1.InputSource.Touch);
        return this.onButtonUp(ev.viewport, pt2d, button, Tool_1.InputSource.Touch);
    }
    /** Can be called by tools that wish to emulate moving the mouse with a button depressed for onTouchMoveStart.
     * @note Calls the tool's onMouseStartDrag method from onMotion.
     */
    async convertTouchMoveStartToButtonDownAndMotion(startEv, ev, button = Tool_1.BeButton.Data) {
        await this.onButtonDown(startEv.viewport, startEv.viewPoint, button, Tool_1.InputSource.Touch);
        return this.onMotion(ev.viewport, ev.viewPoint, Tool_1.InputSource.Touch, true);
    }
    /** Can be called by tools that wish to emulate pressing the mouse button for onTouchStart or onTouchMoveStart. */
    async convertTouchStartToButtonDown(ev, button = Tool_1.BeButton.Data) {
        return this.onButtonDown(ev.viewport, ev.viewPoint, button, Tool_1.InputSource.Touch);
    }
    /** Can be called by tools that wish to emulate releasing the mouse button for onTouchEnd or onTouchComplete.
     * @note Calls the tool's onMouseEndDrag method if convertTouchMoveStartToButtonDownAndMotion was called for onTouchMoveStart.
     */
    async convertTouchEndToButtonUp(ev, button = Tool_1.BeButton.Data) {
        return this.onButtonUp(ev.viewport, ev.viewPoint, button, Tool_1.InputSource.Touch);
    }
    /** Can be called by tools that wish to emulate a mouse motion event for onTouchMove. */
    async convertTouchMoveToMotion(ev) {
        return this.onMotion(ev.viewport, ev.viewPoint, Tool_1.InputSource.Touch);
    }
    /** @internal */
    setIncompatibleViewportCursor(restore) {
        if (restore) {
            if (undefined === this._saveCursor)
                return;
            this.toolState.locateCircleOn = this._saveLocateCircle;
            IModelApp_1.IModelApp.viewManager.setViewCursor(this._saveCursor);
            this._saveCursor = undefined;
            return;
        }
        if (undefined !== this._saveCursor)
            return;
        this._saveLocateCircle = this.toolState.locateCircleOn;
        this._saveCursor = IModelApp_1.IModelApp.viewManager.cursor;
        this.toolState.locateCircleOn = false;
        IModelApp_1.IModelApp.viewManager.setViewCursor("not-allowed");
    }
    /** Performs default handling of mouse wheel event (zoom in/out) */
    async processWheelEvent(ev, doUpdate) {
        await WheelEventProcessor.process(ev, doUpdate);
        this.updateDynamics(ev);
        IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
        return Tool_1.EventHandled.Yes;
    }
    /** @internal */
    onSelectedViewportChanged(previous, current) {
        IModelApp_1.IModelApp.accuDraw.onSelectedViewportChanged(previous, current);
        if (undefined === current) {
            this.callOnCleanup();
            return;
        }
        if (undefined !== this._viewTool)
            this._viewTool.onSelectedViewportChanged(previous, current);
        if (undefined !== this._inputCollector)
            this._inputCollector.onSelectedViewportChanged(previous, current);
        if (undefined !== this._primitiveTool)
            this._primitiveTool.onSelectedViewportChanged(previous, current);
    }
    setLocateCircleOn(locateOn) {
        if (undefined === this._saveCursor)
            this.toolState.locateCircleOn = locateOn;
        else
            this._saveLocateCircle = locateOn;
    }
    setLocateCursor(enableLocate) {
        const { viewManager } = IModelApp_1.IModelApp;
        this.setCursor(viewManager.inDynamicsMode ? IModelApp_1.IModelApp.viewManager.dynamicsCursor : IModelApp_1.IModelApp.viewManager.crossHairCursor);
        this.setLocateCircleOn(enableLocate);
        viewManager.invalidateDecorationsAllViews();
    }
    /** @internal */
    callOnCleanup() {
        this.exitViewTool();
        this.exitInputCollector();
        if (undefined !== this._primitiveTool)
            this._primitiveTool.onCleanup();
    }
}
ToolAdmin._wantEventLoop = false;
ToolAdmin._removals = [];
// Workaround for Edge Bug.
ToolAdmin._keysCurrentlyDown = new Set(); // The (small) set of keys that are currently pressed.
/** Handler for keyboard events. */
ToolAdmin._keyEventHandler = (ev) => {
    if (ev.repeat) // we don't want repeated keyboard events. If we keep them they interfere with replacing mouse motion events, since they come as a stream.
        return;
    // Workaround for Edge Bug. Edge doesn't correctly set the "repeat" flag for keyboard events. We therefore have to implement it
    // ourselves. Keep the test above since it will be faster for other browsers. We can delete this entire block of code when Edge works correctly.
    if (ev.type === "keydown") {
        if (ToolAdmin._keysCurrentlyDown.has(ev.code)) // if we've already received a keydown for this key, its a repeat. Skip it
            return;
        ToolAdmin._keysCurrentlyDown.add(ev.code);
    }
    else {
        ToolAdmin._keysCurrentlyDown.delete(ev.code);
    }
    IModelApp_1.IModelApp.toolAdmin.addEvent(ev);
};
exports.ToolAdmin = ToolAdmin;
/**
 * Default processor to handle wheel events.
 * @internal
 */
class WheelEventProcessor {
    static async process(ev, doUpdate) {
        const vp = ev.viewport;
        if (undefined === vp)
            return;
        await this.doZoom(ev);
        if (doUpdate) {
            vp.synchWithView(true);
            // AccuSnap hit won't be invalidated without cursor motion (closes info window, etc.).
            IModelApp_1.IModelApp.accuSnap.clear();
        }
    }
    static async doZoom(ev) {
        const vp = ev.viewport;
        if (undefined === vp)
            return ViewState_1.ViewStatus.InvalidViewport;
        let zoomRatio = Tool_1.ToolSettings.wheelZoomRatio;
        if (zoomRatio < 1)
            zoomRatio = 1;
        if (ev.wheelDelta > 0)
            zoomRatio = 1 / zoomRatio;
        let isSnapOrPrecision = false;
        const target = geometry_core_1.Point3d.create();
        if (IModelApp_1.IModelApp.tentativePoint.isActive) {
            // Always use Tentative location, adjusted point, not cross
            isSnapOrPrecision = true;
            target.setFrom(IModelApp_1.IModelApp.tentativePoint.getPoint());
        }
        else {
            // Never use AccuSnap location as initial zoom clears snap causing zoom center to "jump"
            isSnapOrPrecision = Tool_1.CoordSource.Precision === ev.coordsFrom;
            target.setFrom(isSnapOrPrecision ? ev.point : ev.rawPoint);
        }
        let status;
        if (vp.view.is3d() && vp.isCameraOn) {
            let lastEventWasValid = false;
            if (!isSnapOrPrecision) {
                const targetNpc = vp.worldToNpc(target);
                const newTarget = new geometry_core_1.Point3d();
                const lastEvent = IModelApp_1.IModelApp.toolAdmin.currentInputState.lastWheelEvent;
                if (lastEvent && lastEvent.viewport && lastEvent.viewport.view.equals(vp.view) && lastEvent.viewPoint.distanceSquaredXY(ev.viewPoint) < 10) {
                    vp.worldToNpc(lastEvent.point, newTarget);
                    targetNpc.z = newTarget.z;
                    lastEventWasValid = true;
                }
                else if (undefined !== vp.pickNearestVisibleGeometry(target, vp.pixelsFromInches(Tool_1.ToolSettings.viewToolPickRadiusInches), true, newTarget)) {
                    vp.worldToNpc(newTarget, newTarget);
                    targetNpc.z = newTarget.z;
                }
                else {
                    vp.view.getTargetPoint(newTarget);
                    vp.worldToNpc(newTarget, newTarget);
                    targetNpc.z = newTarget.z;
                }
                vp.npcToWorld(targetNpc, target);
            }
            const cameraView = vp.view;
            const transform = geometry_core_1.Transform.createFixedPointAndMatrix(target, geometry_core_1.Matrix3d.createScale(zoomRatio, zoomRatio, zoomRatio));
            const oldCameraPos = cameraView.getEyePoint();
            const newCameraPos = transform.multiplyPoint3d(oldCameraPos);
            const offset = geometry_core_1.Vector3d.createStartEnd(oldCameraPos, newCameraPos);
            // when you're too close to an object, the wheel zoom operation will stop. We set a "bump distance" so you can blast through obstacles.
            if (!isSnapOrPrecision && offset.magnitude() < Tool_1.ToolSettings.wheelZoomBumpDistance) {
                offset.scaleToLength(Tool_1.ToolSettings.wheelZoomBumpDistance / 3.0, offset); // move 1/3 of the bump distance, just to get to the other side.
                lastEventWasValid = false;
                target.addInPlace(offset);
            }
            const viewTarget = cameraView.getTargetPoint().clone();
            viewTarget.addInPlace(offset);
            newCameraPos.setFrom(oldCameraPos.plus(offset));
            if (!lastEventWasValid) {
                const thisEvent = ev.clone();
                thisEvent.point.setFrom(target);
                IModelApp_1.IModelApp.toolAdmin.currentInputState.lastWheelEvent = thisEvent;
            }
            status = cameraView.lookAt(newCameraPos, viewTarget, cameraView.getYVector());
            vp.synchWithView(false);
        }
        else {
            const targetNpc = vp.worldToNpc(target);
            const trans = geometry_core_1.Transform.createFixedPointAndMatrix(targetNpc, geometry_core_1.Matrix3d.createScale(zoomRatio, zoomRatio, 1));
            const viewCenter = geometry_core_1.Point3d.create(.5, .5, .5);
            trans.multiplyPoint3d(viewCenter, viewCenter);
            vp.npcToWorld(viewCenter, viewCenter);
            vp.zoom(viewCenter, zoomRatio, { saveInUndo: false, animateFrustumChange: false });
            status = ViewState_1.ViewStatus.Success;
        }
        // if we scrolled out, we may have invalidated the current AccuSnap path
        await IModelApp_1.IModelApp.accuSnap.reEvaluate();
        return status;
    }
}
exports.WheelEventProcessor = WheelEventProcessor;


/***/ }),

/***/ "./lib/tools/ViewTool.js":
/*!*******************************!*\
  !*** ./lib/tools/ViewTool.js ***!
  \*******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

/*---------------------------------------------------------------------------------------------
* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.
* Licensed under the MIT License. See LICENSE.md in the project root for license terms.
*--------------------------------------------------------------------------------------------*/
/** @module Tools */
Object.defineProperty(exports, "__esModule", { value: true });
const geometry_core_1 = __webpack_require__(/*! @bentley/geometry-core */ "@bentley/geometry-core");
const imodeljs_common_1 = __webpack_require__(/*! @bentley/imodeljs-common */ "@bentley/imodeljs-common");
const AccuSnap_1 = __webpack_require__(/*! ../AccuSnap */ "./lib/AccuSnap.js");
const IModelApp_1 = __webpack_require__(/*! ../IModelApp */ "./lib/IModelApp.js");
const rendering_1 = __webpack_require__(/*! ../rendering */ "./lib/rendering.js");
const Viewport_1 = __webpack_require__(/*! ../Viewport */ "./lib/Viewport.js");
const ViewState_1 = __webpack_require__(/*! ../ViewState */ "./lib/ViewState.js");
const Tool_1 = __webpack_require__(/*! ./Tool */ "./lib/tools/Tool.js");
const AccuDraw_1 = __webpack_require__(/*! ../AccuDraw */ "./lib/AccuDraw.js");
/** An InteractiveTool that manipulates a view.
 * @public
 */
class ViewTool extends Tool_1.InteractiveTool {
    constructor(viewport) {
        super();
        this.viewport = viewport;
        this.inDynamicUpdate = false;
    }
    beginDynamicUpdate() { this.inDynamicUpdate = true; }
    endDynamicUpdate() { this.inDynamicUpdate = false; }
    run() {
        const toolAdmin = IModelApp_1.IModelApp.toolAdmin;
        if (undefined !== this.viewport && this.viewport === toolAdmin.markupView) {
            IModelApp_1.IModelApp.notifications.outputPromptByKey("Viewing.NotDuringMarkup");
            return false;
        }
        if (!toolAdmin.onInstallTool(this))
            return false;
        toolAdmin.startViewTool(this);
        toolAdmin.onPostInstallTool(this);
        return true;
    }
    async onResetButtonUp(_ev) { this.exitTool(); return Tool_1.EventHandled.Yes; }
    /** Do not override. */
    exitTool() { IModelApp_1.IModelApp.toolAdmin.exitViewTool(); }
    static showPrompt(prompt) { IModelApp_1.IModelApp.notifications.outputPromptByKey("CoreTools:tools.View." + prompt); }
}
exports.ViewTool = ViewTool;
/** @internal */
class ViewingToolHandle {
    constructor(viewTool) {
        this.viewTool = viewTool;
    }
    onReinitialize() { }
    focusOut() { }
    noMotion(_ev) { return false; }
    motion(_ev) { return false; }
    checkOneShot() { return true; }
    getHandleCursor() { return "default"; }
    focusIn() { IModelApp_1.IModelApp.toolAdmin.setCursor(this.getHandleCursor()); }
    drawHandle(_context, _hasFocus) { }
}
exports.ViewingToolHandle = ViewingToolHandle;
/** @internal */
class ViewHandleArray {
    constructor(viewTool) {
        this.viewTool = viewTool;
        this.handles = [];
        this.focus = -1;
        this.focusDrag = false;
        this.hitHandleIndex = 0;
    }
    empty() {
        this.focus = -1;
        this.focusDrag = false;
        this.hitHandleIndex = -1; // setting to -1 will result in onReinitialize getting called before testHit which sets the hit index
        this.handles.length = 0;
    }
    get count() { return this.handles.length; }
    get hitHandle() { return this.getByIndex(this.hitHandleIndex); }
    get focusHandle() { return this.getByIndex(this.focus); }
    add(handle) { this.handles.push(handle); }
    getByIndex(index) { return (index >= 0 && index < this.count) ? this.handles[index] : undefined; }
    focusHitHandle() { this.setFocus(this.hitHandleIndex); }
    testHit(ptScreen, forced = 0 /* None */) {
        this.hitHandleIndex = -1;
        const data = { distance: 0.0, priority: 10 /* Normal */ };
        let minDistance = 0.0;
        let minDistValid = false;
        let highestPriority = 1 /* Low */;
        let nearestHitHandle;
        for (let i = 0; i < this.count; i++) {
            data.priority = 10 /* Normal */;
            const handle = this.handles[i];
            if (forced) {
                if (handle.handleType === forced) {
                    this.hitHandleIndex = i;
                    return true;
                }
            }
            else if (handle.testHandleForHit(ptScreen, data)) {
                if (data.priority >= highestPriority) {
                    if (data.priority > highestPriority)
                        minDistValid = false;
                    highestPriority = data.priority;
                    if (!minDistValid || (data.distance < minDistance)) {
                        minDistValid = true;
                        minDistance = data.distance;
                        nearestHitHandle = handle;
                        this.hitHandleIndex = i;
                    }
                }
            }
        }
        return undefined !== nearestHitHandle;
    }
    drawHandles(context) {
        if (0 === this.count)
            return;
        // all handle objects must draw themselves
        for (let i = 0; i < this.count; ++i) {
            if (i !== this.hitHandleIndex) {
                const handle = this.handles[i];
                handle.drawHandle(context, this.focus === i);
            }
        }
        // draw the hit handle last
        if (-1 !== this.hitHandleIndex) {
            const handle = this.handles[this.hitHandleIndex];
            handle.drawHandle(context, this.focus === this.hitHandleIndex);
        }
    }
    setFocus(index) {
        if (this.focus === index && (this.focusDrag === this.viewTool.inHandleModify))
            return;
        let focusHandle;
        if (this.focus >= 0) {
            focusHandle = this.getByIndex(this.focus);
            if (focusHandle)
                focusHandle.focusOut();
        }
        if (index >= 0) {
            focusHandle = this.getByIndex(index);
            if (focusHandle)
                focusHandle.focusIn();
        }
        this.focus = index;
        this.focusDrag = this.viewTool.inHandleModify;
        if (undefined !== this.viewport)
            this.viewport.invalidateDecorations();
    }
    onReinitialize() { this.handles.forEach((handle) => handle.onReinitialize()); }
    motion(ev) { this.handles.forEach((handle) => handle.motion(ev)); }
    /** determine whether a handle of a specific type exists */
    hasHandle(handleType) { return this.handles.some((handle) => handle.handleType === handleType); }
}
exports.ViewHandleArray = ViewHandleArray;
/** Base class for tools that manipulate the frustum of a Viewport.
 * @public
 */
class ViewManip extends ViewTool {
    constructor(viewport, handleMask, oneShot, isDraggingRequired = false) {
        super(viewport);
        this.handleMask = handleMask;
        this.oneShot = oneShot;
        this.isDraggingRequired = isDraggingRequired;
        this.frustumValid = false;
        this.targetCenterWorld = new geometry_core_1.Point3d();
        this.inHandleModify = false;
        this.isDragging = false;
        this.stoppedOverHandle = false;
        this.targetCenterValid = false;
        this.targetCenterLocked = false;
        this.nPts = 0;
        /** @internal */
        this._forcedHandle = 0 /* None */;
        this.viewHandles = new ViewHandleArray(this);
        this.changeViewport(viewport);
    }
    decorate(context) { this.viewHandles.drawHandles(context); }
    onReinitialize() {
        if (undefined !== this.viewport) {
            this.viewport.synchWithView(true); // make sure we store any changes in view undo buffer.
            this.viewHandles.setFocus(-1);
        }
        this.nPts = 0;
        this.inHandleModify = false;
        this.inDynamicUpdate = false;
        this.frustumValid = false;
        this.viewHandles.onReinitialize();
    }
    async onDataButtonDown(ev) {
        // Tool was started in "drag required" mode, don't advance tool state and wait to see if we get the start drag event.
        if (0 === this.nPts && this.isDraggingRequired && !this.isDragging || undefined === ev.viewport)
            return Tool_1.EventHandled.No;
        switch (this.nPts) {
            case 0:
                this.changeViewport(ev.viewport);
                if (this.processFirstPoint(ev))
                    this.nPts = 1;
                break;
            case 1:
                this.nPts = 2;
                break;
        }
        if (this.nPts > 1) {
            this.inDynamicUpdate = false;
            if (this.processPoint(ev, false) && this.oneShot)
                this.exitTool();
            else
                this.onReinitialize();
        }
        return Tool_1.EventHandled.Yes;
    }
    async onDataButtonUp(_ev) {
        if (this.nPts <= 1 && this.isDraggingRequired && !this.isDragging && this.oneShot)
            this.exitTool();
        return Tool_1.EventHandled.No;
    }
    async onMouseWheel(inputEv) {
        const ev = inputEv.clone();
        // If rotate is active, the mouse wheel should about the target center when it's displayed...
        if ((this.handleMask & 1 /* Rotate */) && (this.targetCenterLocked || this.inHandleModify)) {
            ev.point = this.targetCenterWorld;
            ev.coordsFrom = Tool_1.CoordSource.Precision; // don't want raw point used...
        }
        IModelApp_1.IModelApp.toolAdmin.processWheelEvent(ev, false); // tslint:disable-line:no-floating-promises
        return Tool_1.EventHandled.Yes;
    }
    /** @internal */
    async startHandleDrag(ev, forcedHandle) {
        if (this.inHandleModify)
            return Tool_1.EventHandled.No; // If already changing the view reject the request...
        if (undefined !== forcedHandle) {
            if (!this.viewHandles.hasHandle(forcedHandle))
                return Tool_1.EventHandled.No; // If requested handle isn't present reject the request...
            this._forcedHandle = forcedHandle;
        }
        this.receivedDownEvent = true; // Request up events even though we may not have gotten the down event...
        this.isDragging = true;
        if (0 === this.nPts)
            this.onDataButtonDown(ev); // tslint:disable-line:no-floating-promises
        return Tool_1.EventHandled.Yes;
    }
    async onMouseStartDrag(ev) {
        switch (ev.button) {
            case Tool_1.BeButton.Reset:
                return Tool_1.EventHandled.No;
            case Tool_1.BeButton.Middle:
                if (!this.viewHandles.hasHandle(32 /* Walk */) && !this.viewHandles.hasHandle(64 /* Fly */)) // Allow middle drag to override IdleTool for walk/fly...
                    return Tool_1.EventHandled.No;
        }
        return this.startHandleDrag(ev);
    }
    async onMouseEndDrag(ev) {
        // NOTE: To support startHandleDrag being called by IdleTool for middle button drag, check inHandleModify and not the button type...
        if (!this.inHandleModify)
            return Tool_1.EventHandled.No;
        this.isDragging = false;
        if (0 === this.nPts)
            return Tool_1.EventHandled.Yes;
        return this.onDataButtonDown(ev);
    }
    async onMouseMotion(ev) {
        this.stoppedOverHandle = false;
        if (0 === this.nPts && this.viewHandles.testHit(ev.viewPoint))
            this.viewHandles.focusHitHandle();
        if (0 !== this.nPts)
            this.processPoint(ev, true);
        this.viewHandles.motion(ev);
    }
    async onMouseMotionStopped(ev) {
        if (ev.viewport !== this.viewport)
            return;
        if (0 === this.nPts) {
            if (this.viewHandles.testHit(ev.viewPoint)) {
                this.stoppedOverHandle = true;
                this.viewHandles.focusHitHandle();
            }
            else if (this.stoppedOverHandle) {
                this.stoppedOverHandle = false;
                this.viewport.invalidateDecorations();
            }
        }
    }
    async onMouseNoMotion(ev) {
        if (0 === this.nPts || !ev.viewport)
            return;
        const hitHandle = this.viewHandles.hitHandle;
        if (hitHandle)
            hitHandle.noMotion(ev);
    }
    async onTouchTap(ev) { return ev.isSingleTap ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No; } // Prevent IdleTool from converting single tap into data button down/up...
    async onTouchMoveStart(ev, startEv) { if (!this.inHandleModify && startEv.isSingleTouch)
        await IModelApp_1.IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev); return this.inHandleModify ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No; }
    async onTouchMove(ev) { if (this.inHandleModify)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }
    async onTouchComplete(ev) { if (this.inHandleModify)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }
    async onTouchCancel(ev) { if (this.inHandleModify)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, Tool_1.BeButton.Reset); }
    onPostInstall() {
        super.onPostInstall();
        this.onReinitialize(); // Call onReinitialize now that tool is installed.
    }
    onCleanup() {
        let restorePrevious = false;
        if (this.inDynamicUpdate) {
            this.endDynamicUpdate();
            restorePrevious = true;
        }
        const vp = this.viewport;
        if (undefined !== vp) {
            vp.synchWithView(true);
            if (restorePrevious)
                vp.doUndo(Tool_1.ToolSettings.animationTime);
            vp.invalidateDecorations();
        }
        this.viewHandles.empty();
    }
    updateTargetCenter() {
        const vp = this.viewport;
        if (!vp)
            return;
        if (this.targetCenterValid) {
            if (this.inHandleModify)
                return;
            if (IModelApp_1.IModelApp.tentativePoint.isActive) {
                this.setTargetCenterWorld(IModelApp_1.IModelApp.tentativePoint.getPoint(), true, false);
                IModelApp_1.IModelApp.tentativePoint.clear(true); // Clear tentative, there won't be a datapoint to accept...
            }
            return;
        }
        if (IModelApp_1.IModelApp.tentativePoint.isActive)
            return this.setTargetCenterWorld(IModelApp_1.IModelApp.tentativePoint.getPoint(), true, false);
        if (AccuSnap_1.TentativeOrAccuSnap.isHot)
            return this.setTargetCenterWorld(AccuSnap_1.TentativeOrAccuSnap.getCurrentPoint(), true, false);
        if (vp.viewCmdTargetCenter && this.isPointVisible(vp.viewCmdTargetCenter))
            return this.setTargetCenterWorld(vp.viewCmdTargetCenter, true, true);
        if (!vp.view.allow3dManipulations()) {
            const defaultPoint = vp.npcToWorld(imodeljs_common_1.NpcCenter);
            defaultPoint.z = 0.0;
            return this.setTargetCenterWorld(defaultPoint, false, false);
        }
        const visiblePoint = vp.pickNearestVisibleGeometry(vp.npcToWorld(imodeljs_common_1.NpcCenter), vp.pixelsFromInches(Tool_1.ToolSettings.viewToolPickRadiusInches));
        this.setTargetCenterWorld(undefined !== visiblePoint ? visiblePoint : vp.view.getTargetPoint(), false, false);
    }
    processFirstPoint(ev) {
        const forcedHandle = this._forcedHandle;
        this._forcedHandle = 0 /* None */;
        this.frustumValid = false;
        if (this.viewHandles.testHit(ev.viewPoint, forcedHandle)) {
            this.inHandleModify = true;
            this.viewHandles.focusHitHandle();
            const handle = this.viewHandles.hitHandle;
            if (undefined !== handle && !handle.firstPoint(ev))
                return false;
        }
        return true;
    }
    processPoint(ev, inDynamics) {
        const hitHandle = this.viewHandles.hitHandle;
        if (undefined === hitHandle)
            return true;
        const doUpdate = hitHandle.doManipulation(ev, inDynamics);
        return inDynamics || (doUpdate && hitHandle.checkOneShot());
    }
    lensAngleMatches(angle, tolerance) {
        const cameraView = this.viewport.view;
        return !cameraView.is3d() ? false : Math.abs(cameraView.calcLensAngle().radians - angle.radians) < tolerance;
    }
    get isZUp() {
        const view = this.viewport.view;
        const viewX = view.getXVector();
        const viewY = view.getXVector();
        const zVec = geometry_core_1.Vector3d.unitZ();
        return (Math.abs(zVec.dotProduct(viewY)) > 0.99 && Math.abs(zVec.dotProduct(viewX)) < 0.01);
    }
    static getFocusPlaneNpc(vp) {
        const pt = vp.view.getTargetPoint();
        if (pt.z < 0.0 || pt.z > 1.0) {
            pt.set(0.5, 0.5, 0.0);
            const pt2 = new geometry_core_1.Point3d(0.5, 0.5, 1.0);
            vp.npcToWorld(pt, pt);
            vp.npcToWorld(pt2, pt2);
            pt.interpolate(0.5, pt2, pt);
            vp.worldToNpc(pt, pt);
        }
        return pt.z;
    }
    /**
     * Set the target point for viewing operations.
     * @param pt the new target point in world coordinates
     * @param lockTarget consider the target point locked for this tool instance
     * @param saveTarget save this target point for use between tool instances
     */
    setTargetCenterWorld(pt, lockTarget, saveTarget) {
        this.targetCenterWorld.setFrom(pt);
        this.targetCenterValid = true;
        this.targetCenterLocked = lockTarget;
        if (!this.viewport)
            return;
        if (!this.viewport.view.allow3dManipulations())
            this.targetCenterWorld.z = 0.0;
        this.viewport.viewCmdTargetCenter = (saveTarget ? pt : undefined);
    }
    /** Determine whether the supplied point is visible in this Viewport. */
    isPointVisible(testPt) {
        const vp = this.viewport;
        if (!vp)
            return false;
        const testPtView = vp.worldToView(testPt);
        const frustum = vp.getFrustum(Viewport_1.CoordSystem.View, false);
        const screenRange = geometry_core_1.Point3d.create(frustum.points[imodeljs_common_1.Npc._000].distance(frustum.points[imodeljs_common_1.Npc._100]), frustum.points[imodeljs_common_1.Npc._000].distance(frustum.points[imodeljs_common_1.Npc._010]), frustum.points[imodeljs_common_1.Npc._000].distance(frustum.points[imodeljs_common_1.Npc._001]));
        return (!((testPtView.x < 0 || testPtView.x > screenRange.x) || (testPtView.y < 0 || testPtView.y > screenRange.y)));
    }
    static fitView(viewport, doAnimate, marginPercent) {
        const range = viewport.computeViewRange();
        const aspect = viewport.viewRect.aspect;
        const before = viewport.getFrustum();
        const clip = (viewport.viewFlags.clipVolume ? viewport.view.getViewClip() : undefined);
        if (undefined !== clip) {
            const clipRange = geometry_core_1.ClipUtilities.rangeOfClipperIntersectionWithRange(clip, range);
            if (!clipRange.isNull)
                range.setFrom(clipRange);
        }
        if (this._useViewAlignedVolume)
            viewport.view.lookAtViewAlignedVolume(range, aspect, marginPercent);
        else
            viewport.view.lookAtVolume(range, aspect, marginPercent);
        viewport.synchWithView(false);
        const after = viewport.getFrustum();
        viewport.view.setupFromFrustum(after);
        viewport.synchWithView(true);
        viewport.viewCmdTargetCenter = undefined;
        if (doAnimate)
            viewport.animateFrustumChange(before, after);
    }
    static async zoomToAlwaysDrawnExclusive(viewport, doAnimate, marginPercent) {
        if (!viewport.isAlwaysDrawnExclusive || undefined === viewport.alwaysDrawn || 0 === viewport.alwaysDrawn.size)
            return false;
        await viewport.zoomToElements(viewport.alwaysDrawn, { animateFrustumChange: doAnimate, marginPercent });
        return true;
    }
    setCameraLensAngle(lensAngle, retainEyePoint) {
        const vp = this.viewport;
        if (!vp)
            return ViewState_1.ViewStatus.InvalidViewport;
        const view = vp.view;
        if (!view || !view.is3d() || !view.allow3dManipulations())
            return ViewState_1.ViewStatus.InvalidViewport;
        const result = (retainEyePoint && view.isCameraOn) ?
            view.lookAtUsingLensAngle(view.getEyePoint(), view.getTargetPoint(), view.getYVector(), lensAngle) :
            vp.turnCameraOn(lensAngle);
        if (result !== ViewState_1.ViewStatus.Success)
            return result;
        vp.synchWithView(false);
        if (!this.targetCenterLocked) {
            this.targetCenterValid = false;
            this.updateTargetCenter(); // Update default rotate point for when the camera needed to be turned on...
        }
        return ViewState_1.ViewStatus.Success;
    }
    enforceZUp(pivotPoint) {
        const vp = this.viewport;
        if (!vp || this.isZUp)
            return false;
        const view = vp.view;
        const viewY = view.getYVector();
        const rotMatrix = geometry_core_1.Matrix3d.createRotationVectorToVector(viewY, geometry_core_1.Vector3d.unitZ());
        if (!rotMatrix)
            return false;
        const transform = geometry_core_1.Transform.createFixedPointAndMatrix(pivotPoint, rotMatrix);
        const frust = vp.getWorldFrustum();
        frust.multiply(transform);
        vp.setupViewFromFrustum(frust);
        return true;
    }
    changeViewport(vp) {
        if (vp === this.viewport && 0 !== this.viewHandles.count) // If viewport isn't really changing do nothing...
            return;
        if (this.viewport) {
            this.viewport.invalidateDecorations(); // Remove decorations from current viewport...
            this.viewHandles.empty();
        }
        this.viewport = vp;
        if (this.viewport === undefined)
            return;
        this.viewHandles.viewport = vp;
        this.targetCenterValid = false;
        this.updateTargetCenter();
        if (this.handleMask & 1 /* Rotate */)
            this.viewHandles.add(new ViewRotate(this));
        if (this.handleMask & 2 /* TargetCenter */)
            this.viewHandles.add(new ViewTargetCenter(this));
        if (this.handleMask & 4 /* Pan */)
            this.viewHandles.add(new ViewPan(this));
        if (this.handleMask & 8 /* Scroll */)
            this.viewHandles.add(new ViewScroll(this));
        if (this.handleMask & 16 /* Zoom */)
            this.viewHandles.add(new ViewZoom(this));
        if (this.handleMask & 32 /* Walk */)
            this.viewHandles.add(new ViewWalk(this));
        if (this.handleMask & 64 /* Fly */)
            this.viewHandles.add(new ViewFly(this));
        if (this.handleMask & 128 /* Look */)
            this.viewHandles.add(new ViewLook(this));
    }
}
ViewManip._useViewAlignedVolume = false;
exports.ViewManip = ViewManip;
/** ViewingToolHandle for modifying the view's target point for operations like rotate */
class ViewTargetCenter extends ViewingToolHandle {
    get handleType() { return 2 /* TargetCenter */; }
    checkOneShot() { return false; } // Don't exit tool after moving target in single-shot mode...
    firstPoint(ev) {
        if (!ev.viewport)
            return false;
        IModelApp_1.IModelApp.accuSnap.enableSnap(true);
        return true;
    }
    testHandleForHit(ptScreen, out) {
        if (this.viewTool.isDraggingRequired)
            return false; // Target center handle is not movable in this mode, but it's still nice to display the point we're rotating about...
        const targetPt = this.viewTool.viewport.worldToView(this.viewTool.targetCenterWorld);
        const distance = targetPt.distanceXY(ptScreen);
        const locateThreshold = this.viewTool.viewport.pixelsFromInches(0.15);
        if (distance > locateThreshold)
            return false;
        out.distance = distance;
        out.priority = 1000 /* High */;
        return true;
    }
    drawHandle(context, hasFocus) {
        if (context.viewport !== this.viewTool.viewport)
            return;
        if (!this.viewTool.targetCenterLocked && !this.viewTool.inHandleModify)
            return; // Don't display default target center, will be updated to use pick point on element...
        let sizeInches = 0.2;
        if (!hasFocus && this.viewTool.inHandleModify) {
            const hitHandle = this.viewTool.viewHandles.hitHandle;
            if (undefined !== hitHandle && 1 /* Rotate */ !== hitHandle.handleType)
                return; // Only display when modifying another handle if that handle is rotate (not pan)...
            sizeInches = 0.1; // Display small target when dragging...
        }
        const crossSize = Math.floor(context.viewport.pixelsFromInches(sizeInches)) + 0.5;
        const outlineSize = crossSize + 1;
        const position = this.viewTool.viewport.worldToView(this.viewTool.targetCenterWorld);
        position.x = Math.floor(position.x) + 0.5;
        position.y = Math.floor(position.y) + 0.5;
        const drawDecoration = (ctx) => {
            ctx.beginPath();
            ctx.strokeStyle = "rgba(0,0,0,.5)";
            ctx.lineWidth = hasFocus ? 5 : 3;
            ctx.moveTo(-outlineSize, 0);
            ctx.lineTo(outlineSize, 0);
            ctx.moveTo(0, -outlineSize);
            ctx.lineTo(0, outlineSize);
            ctx.stroke();
            ctx.beginPath();
            ctx.strokeStyle = "white";
            ctx.lineWidth = hasFocus ? 3 : 1;
            ctx.shadowColor = "black";
            ctx.shadowBlur = hasFocus ? 7 : 5;
            ctx.moveTo(-crossSize, 0);
            ctx.lineTo(crossSize, 0);
            ctx.moveTo(0, -crossSize);
            ctx.lineTo(0, crossSize);
            ctx.stroke();
        };
        context.addCanvasDecoration({ position, drawDecoration });
    }
    doManipulation(ev, inDynamics) {
        if (ev.viewport !== this.viewTool.viewport)
            return false;
        this.viewTool.setTargetCenterWorld(ev.point, !inDynamics, Tool_1.InputSource.Touch === ev.inputSource ? false : !inDynamics);
        ev.viewport.invalidateDecorations();
        if (!inDynamics)
            IModelApp_1.IModelApp.accuSnap.enableSnap(false);
        return false; // false means don't do screen update
    }
}
/** ViewingToolHandle for performing the "pan view" operation */
class ViewPan extends ViewingToolHandle {
    constructor() {
        super(...arguments);
        this._anchorPt = new geometry_core_1.Point3d();
        this._lastPtNpc = new geometry_core_1.Point3d();
    }
    get handleType() { return 4 /* Pan */; }
    getHandleCursor() { return this.viewTool.inHandleModify ? IModelApp_1.IModelApp.viewManager.grabbingCursor : IModelApp_1.IModelApp.viewManager.grabCursor; }
    doManipulation(ev, _inDynamics) {
        const vp = ev.viewport;
        const newPtWorld = ev.point.clone();
        const thisPtNpc = vp.worldToNpc(newPtWorld);
        const firstPtNpc = vp.worldToNpc(this._anchorPt);
        thisPtNpc.z = firstPtNpc.z;
        if (this._lastPtNpc.isAlmostEqual(thisPtNpc, 1.0e-10))
            return true;
        vp.npcToWorld(thisPtNpc, newPtWorld);
        this._lastPtNpc.setFrom(thisPtNpc);
        return this.doPan(newPtWorld);
    }
    firstPoint(ev) {
        const vp = ev.viewport;
        this._anchorPt.setFrom(ev.rawPoint);
        // if the camera is on, we need to find the element under the starting point to get the z
        if (vp.isCameraOn) {
            const visiblePoint = vp.pickNearestVisibleGeometry(this._anchorPt, vp.pixelsFromInches(Tool_1.ToolSettings.viewToolPickRadiusInches));
            if (undefined !== visiblePoint) {
                this._anchorPt.setFrom(visiblePoint);
            }
            else {
                const firstPtNpc = vp.worldToNpc(this._anchorPt);
                firstPtNpc.z = ViewManip.getFocusPlaneNpc(vp);
                this._anchorPt = vp.npcToWorld(firstPtNpc, this._anchorPt);
            }
        }
        this.viewTool.beginDynamicUpdate();
        ViewTool.showPrompt("Pan.Prompts.NextPoint");
        return true;
    }
    onReinitialize() {
        const vha = this.viewTool.viewHandles.hitHandle;
        if (vha === this) {
            IModelApp_1.IModelApp.toolAdmin.setCursor(this.getHandleCursor());
        }
    }
    testHandleForHit(_ptScreen, out) {
        out.distance = 0.0;
        out.priority = 1 /* Low */;
        return true;
    }
    doPan(newPtWorld) {
        const vp = this.viewTool.viewport;
        const view = vp.view;
        const dist = newPtWorld.vectorTo(this._anchorPt);
        if (view.is3d()) {
            if (ViewState_1.ViewStatus.Success !== view.moveCameraWorld(dist))
                return false;
        }
        else {
            view.setOrigin(view.getOrigin().plus(dist));
        }
        vp.synchWithView(false);
        return true;
    }
}
/** ViewingToolHandle for performing the "rotate view" operation */
class ViewRotate extends ViewingToolHandle {
    constructor() {
        super(...arguments);
        this._lastPtNpc = new geometry_core_1.Point3d();
        this._firstPtNpc = new geometry_core_1.Point3d();
        this._frustum = new imodeljs_common_1.Frustum();
        this._activeFrustum = new imodeljs_common_1.Frustum();
    }
    get handleType() { return 1 /* Rotate */; }
    getHandleCursor() { return "move"; }
    testHandleForHit(ptScreen, out) {
        const targetPt = this.viewTool.viewport.worldToView(this.viewTool.targetCenterWorld);
        out.distance = targetPt.distanceXY(ptScreen);
        out.priority = 10 /* Normal */;
        return true;
    }
    firstPoint(ev) {
        const tool = this.viewTool;
        const vp = ev.viewport;
        if (!tool.targetCenterLocked && vp.view.allow3dManipulations()) {
            const visiblePoint = vp.pickNearestVisibleGeometry(ev.rawPoint, vp.pixelsFromInches(Tool_1.ToolSettings.viewToolPickRadiusInches));
            if (undefined !== visiblePoint)
                tool.setTargetCenterWorld(visiblePoint, false, false);
        }
        const pickPt = ev.rawPoint.clone();
        const pickPtOrig = pickPt.clone();
        vp.worldToNpc(pickPtOrig, this._firstPtNpc);
        this._lastPtNpc.setFrom(this._firstPtNpc);
        vp.getWorldFrustum(this._activeFrustum);
        this._frustum.setFrom(this._activeFrustum);
        tool.beginDynamicUpdate();
        ViewTool.showPrompt("Rotate.Prompts.NextPoint");
        return true;
    }
    doManipulation(ev, _inDynamics) {
        const tool = this.viewTool;
        const viewport = tool.viewport;
        const ptNpc = viewport.worldToNpc(ev.point);
        if (this._lastPtNpc.isAlmostEqual(ptNpc, 1.0e-10)) // no movement since last point
            return true;
        if (this._firstPtNpc.isAlmostEqual(ptNpc, 1.0e-2)) // too close to anchor pt
            ptNpc.setFrom(this._firstPtNpc);
        this._lastPtNpc.setFrom(ptNpc);
        const currentFrustum = viewport.getWorldFrustum();
        const frustumChange = !currentFrustum.equals(this._activeFrustum);
        if (frustumChange)
            this._frustum.setFrom(currentFrustum);
        else if (!viewport.setupViewFromFrustum(this._frustum))
            return false;
        const currPt = viewport.npcToView(ptNpc);
        if (frustumChange)
            this._firstPtNpc.setFrom(ptNpc);
        let radians;
        let worldAxis;
        const worldPt = tool.targetCenterWorld;
        if (!viewport.view.allow3dManipulations()) {
            const centerPt = viewport.worldToView(worldPt);
            const firstPt = viewport.npcToView(this._firstPtNpc);
            const vector0 = geometry_core_1.Vector2d.createStartEnd(centerPt, firstPt);
            const vector1 = geometry_core_1.Vector2d.createStartEnd(centerPt, currPt);
            radians = vector0.angleTo(vector1);
            worldAxis = geometry_core_1.Vector3d.unitZ();
        }
        else {
            const viewRect = viewport.viewRect;
            const xExtent = viewRect.width;
            const yExtent = viewRect.height;
            viewport.npcToView(ptNpc, currPt);
            const firstPt = viewport.npcToView(this._firstPtNpc);
            const xDelta = (currPt.x - firstPt.x);
            const yDelta = (currPt.y - firstPt.y);
            // Movement in screen x == rotation about drawing Z (preserve up) or rotation about screen  Y...
            const xAxis = Tool_1.ToolSettings.preserveWorldUp ? geometry_core_1.Vector3d.unitZ() : viewport.rotation.getRow(1);
            // Movement in screen y == rotation about screen X...
            const yAxis = viewport.rotation.getRow(0);
            const xRMatrix = xDelta ? geometry_core_1.Matrix3d.createRotationAroundVector(xAxis, geometry_core_1.Angle.createRadians(Math.PI / (xExtent / xDelta))) : geometry_core_1.Matrix3d.createIdentity();
            const yRMatrix = yDelta ? geometry_core_1.Matrix3d.createRotationAroundVector(yAxis, geometry_core_1.Angle.createRadians(Math.PI / (yExtent / yDelta))) : geometry_core_1.Matrix3d.createIdentity();
            const worldRMatrix = yRMatrix.multiplyMatrixMatrix(xRMatrix);
            const result = worldRMatrix.getAxisAndAngleOfRotation();
            radians = geometry_core_1.Angle.createRadians(-result.angle.radians);
            worldAxis = result.axis;
        }
        this.rotateViewWorld(worldPt, worldAxis, radians);
        viewport.getWorldFrustum(this._activeFrustum);
        return true;
    }
    rotateViewWorld(worldOrigin, worldAxisVector, primaryAngle) {
        const worldMatrix = geometry_core_1.Matrix3d.createRotationAroundVector(worldAxisVector, primaryAngle);
        if (!worldMatrix)
            return;
        const worldTransform = geometry_core_1.Transform.createFixedPointAndMatrix(worldOrigin, worldMatrix);
        const frustum = this._frustum.transformBy(worldTransform);
        this.viewTool.viewport.setupViewFromFrustum(frustum);
    }
}
/** ViewingToolHandle for performing the "look view" operation */
class ViewLook extends ViewingToolHandle {
    constructor() {
        super(...arguments);
        this._eyePoint = new geometry_core_1.Point3d();
        this._firstPtView = new geometry_core_1.Point3d();
        this._rotation = new geometry_core_1.Matrix3d();
        this._frustum = new imodeljs_common_1.Frustum();
    }
    get handleType() { return 128 /* Look */; }
    getHandleCursor() { return IModelApp_1.IModelApp.viewManager.crossHairCursor; }
    testHandleForHit(_ptScreen, out) {
        out.distance = 0.0;
        out.priority = 1 /* Low */;
        return true;
    }
    firstPoint(ev) {
        const tool = this.viewTool;
        const vp = ev.viewport;
        const view = vp.view;
        if (!view || !view.is3d() || !view.allow3dManipulations())
            return false;
        this._firstPtView.setFrom(ev.viewPoint);
        this._eyePoint.setFrom(view.getEyePoint());
        this._rotation.setFrom(vp.rotation);
        vp.getWorldFrustum(this._frustum);
        tool.beginDynamicUpdate();
        ViewTool.showPrompt("Look.Prompts.NextPoint");
        return true;
    }
    doManipulation(ev, _inDynamics) {
        const tool = this.viewTool;
        const viewport = tool.viewport;
        if (ev.viewport !== viewport)
            return false;
        const worldTransform = this.getLookTransform(viewport, this._firstPtView, ev.viewPoint);
        const frustum = this._frustum.transformBy(worldTransform);
        this.viewTool.viewport.setupViewFromFrustum(frustum);
        return true;
    }
    getLookTransform(vp, firstPt, currPt) {
        const viewRect = vp.viewRect;
        const xExtent = viewRect.width;
        const yExtent = viewRect.height;
        const xDelta = (currPt.x - firstPt.x);
        const yDelta = (currPt.y - firstPt.y);
        const xAngle = -(xDelta / xExtent) * Math.PI;
        const yAngle = -(yDelta / yExtent) * Math.PI;
        const inverseRotation = this._rotation.inverse();
        const horizontalRotation = geometry_core_1.Matrix3d.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), geometry_core_1.Angle.createRadians(xAngle));
        const verticalRotation = geometry_core_1.Matrix3d.createRotationAroundVector(geometry_core_1.Vector3d.unitX(), geometry_core_1.Angle.createRadians(yAngle));
        if (undefined === inverseRotation || undefined === horizontalRotation || undefined === verticalRotation)
            return geometry_core_1.Transform.createIdentity();
        verticalRotation.multiplyMatrixMatrix(this._rotation, verticalRotation);
        inverseRotation.multiplyMatrixMatrix(verticalRotation, verticalRotation);
        const newRotation = horizontalRotation.multiplyMatrixMatrix(verticalRotation);
        const transform = geometry_core_1.Transform.createFixedPointAndMatrix(this._eyePoint, newRotation);
        return transform;
    }
}
/** ViewingToolHandle for performing the "scroll view" operation */
class ViewScroll extends ViewingToolHandle {
    constructor() {
        super(...arguments);
        this._anchorPtView = new geometry_core_1.Point3d();
        this._lastPtView = new geometry_core_1.Point3d();
    }
    get handleType() { return 8 /* Scroll */; }
    getHandleCursor() { return IModelApp_1.IModelApp.viewManager.crossHairCursor; }
    testHandleForHit(_ptScreen, out) {
        out.distance = 0.0;
        out.priority = 1 /* Low */;
        return true;
    }
    drawHandle(context, _hasFocus) {
        if (context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)
            return;
        const radius = Math.floor(context.viewport.pixelsFromInches(0.15)) + 0.5;
        const position = this._anchorPtView.clone();
        position.x = Math.floor(position.x) + 0.5;
        position.y = Math.floor(position.y) + 0.5;
        const position2 = this._lastPtView.clone();
        position2.x = Math.floor(position2.x) + 0.5;
        position2.y = Math.floor(position2.y) + 0.5;
        const offset = position2.minus(position);
        const drawDecoration = (ctx) => {
            ctx.beginPath();
            ctx.strokeStyle = "green";
            ctx.lineWidth = 2;
            ctx.moveTo(0, 0);
            ctx.lineTo(offset.x, offset.y);
            ctx.stroke();
            ctx.beginPath();
            ctx.strokeStyle = "rgba(0,0,0,.5)";
            ctx.lineWidth = 1;
            ctx.fillStyle = "rgba(255,255,255,.5)";
            ctx.arc(0, 0, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            let vec = geometry_core_1.Vector2d.createStartEnd(position, position2);
            if (undefined === vec)
                vec = geometry_core_1.Vector2d.unitX();
            else
                vec.normalize(vec);
            const slashPts = [new geometry_core_1.Point2d(), new geometry_core_1.Point2d()];
            slashPts[0].plusScaled(vec, radius, slashPts[0]);
            slashPts[1].plusScaled(vec, -radius, slashPts[1]);
            ctx.beginPath();
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.moveTo(slashPts[0].x, slashPts[0].y);
            ctx.lineTo(slashPts[1].x, slashPts[1].y);
            ctx.stroke();
        };
        context.addCanvasDecoration({ position, drawDecoration }, true);
    }
    firstPoint(ev) {
        const tool = this.viewTool;
        this._anchorPtView.setFrom(ev.viewPoint);
        this._lastPtView.setFrom(ev.viewPoint);
        tool.beginDynamicUpdate();
        ViewTool.showPrompt("Scroll.Prompts.NextPoint");
        return true;
    }
    doManipulation(ev, _inDynamics) {
        const tool = this.viewTool;
        const viewport = tool.viewport;
        if (ev.viewport !== viewport)
            return false;
        return this.doScroll(ev);
    }
    noMotion(ev) {
        if (ev.viewport !== this.viewTool.viewport)
            return false;
        this.doScroll(ev);
        return false;
    }
    doScroll(ev) {
        this._lastPtView.setFrom(ev.viewPoint);
        // if we're resting near the anchor point, don't bother with this
        if ((Math.abs(this._anchorPtView.x - this._lastPtView.x) < 5.0) && Math.abs(this._anchorPtView.y - this._lastPtView.y) < 5.0)
            return false;
        const scrollFactor = (-1.0 / 8.5);
        const dist = this._anchorPtView.minus(this._lastPtView);
        dist.z = 0.0;
        const viewport = ev.viewport;
        const view = viewport.view;
        if (view.is3d() && view.isCameraOn) {
            const points = new Array(2);
            points[0] = this._anchorPtView.clone();
            points[1] = points[0].plusScaled(dist, scrollFactor);
            viewport.viewToNpcArray(points);
            points[0].z = points[1].z = ViewManip.getFocusPlaneNpc(viewport); // use the focal plane for z coordinates
            viewport.npcToWorldArray(points);
            const offset = points[1].minus(points[0]);
            const offsetTransform = geometry_core_1.Transform.createTranslation(offset);
            const frustum = viewport.getWorldFrustum();
            frustum.transformBy(offsetTransform, frustum);
            viewport.setupViewFromFrustum(frustum);
        }
        else {
            const iDist = geometry_core_1.Point2d.create(Math.floor(dist.x * scrollFactor), Math.floor(dist.y * scrollFactor));
            viewport.scroll(iDist, { saveInUndo: false, animateFrustumChange: false });
        }
        return true;
    }
}
/** ViewingToolHandle for performing the "zoom view" operation */
class ViewZoom extends ViewingToolHandle {
    constructor() {
        super(...arguments);
        this._anchorPtView = new geometry_core_1.Point3d();
        this._anchorPtNpc = new geometry_core_1.Point3d();
        this._lastPtView = new geometry_core_1.Point3d();
        this._lastZoomRatio = 1.0;
    }
    get handleType() { return 16 /* Zoom */; }
    getHandleCursor() { return IModelApp_1.IModelApp.viewManager.crossHairCursor; }
    testHandleForHit(_ptScreen, out) {
        out.distance = 0.0;
        out.priority = 1 /* Low */;
        return true;
    }
    drawHandle(context, _hasFocus) {
        if (context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)
            return;
        const radius = Math.floor(context.viewport.pixelsFromInches(0.15)) + 0.5;
        const crossRadius = radius * 0.6;
        const position = this._anchorPtView.clone();
        position.x = Math.floor(position.x) + 0.5;
        position.y = Math.floor(position.y) + 0.5;
        const drawDecoration = (ctx) => {
            ctx.beginPath();
            ctx.strokeStyle = "rgba(0,0,0,.5)";
            ctx.lineWidth = 1;
            ctx.fillStyle = "rgba(255,255,255,.5)";
            ctx.arc(0, 0, radius, 0, 2 * Math.PI);
            ctx.fill();
            ctx.stroke();
            ctx.beginPath();
            ctx.strokeStyle = "black";
            ctx.lineWidth = 2;
            ctx.moveTo(-crossRadius, 0);
            ctx.lineTo(crossRadius, 0);
            if (this._lastZoomRatio < 1.0) {
                ctx.moveTo(0, -crossRadius);
                ctx.lineTo(0, crossRadius);
            }
            ctx.stroke();
        };
        context.addCanvasDecoration({ position, drawDecoration }, true);
    }
    firstPoint(ev) {
        const tool = this.viewTool;
        const viewport = tool.viewport;
        const view = viewport.view;
        if (view.is3d() && view.isCameraOn) {
            const visiblePoint = viewport.pickNearestVisibleGeometry(Tool_1.CoordSource.User === ev.coordsFrom ? ev.rawPoint : ev.point, viewport.pixelsFromInches(Tool_1.ToolSettings.viewToolPickRadiusInches));
            if (undefined !== visiblePoint) {
                this._anchorPtView.setFrom(visiblePoint);
                viewport.worldToView(this._anchorPtView, this._anchorPtView);
                this._lastPtView.setFrom(this._anchorPtView);
                tool.viewport.viewToNpc(this._anchorPtView, this._anchorPtNpc);
                tool.beginDynamicUpdate();
                ViewTool.showPrompt("Zoom.Prompts.NextPoint");
                return true;
            }
        }
        if (Tool_1.CoordSource.User === ev.coordsFrom)
            this._anchorPtView.setFrom(ev.viewPoint);
        else
            viewport.worldToView(ev.point, this._anchorPtView);
        this._lastPtView.setFrom(this._anchorPtView);
        tool.viewport.viewToNpc(this._anchorPtView, this._anchorPtNpc);
        tool.beginDynamicUpdate();
        ViewTool.showPrompt("Zoom.Prompts.NextPoint");
        return true;
    }
    doManipulation(ev, _inDynamics) {
        if (ev.viewport !== this.viewTool.viewport)
            return false;
        return this.doZoom(ev);
    }
    noMotion(ev) {
        if (ev.viewport !== this.viewTool.viewport)
            return false;
        this.doZoom(ev);
        return false;
    }
    doZoom(ev) {
        this._lastPtView.setFrom(ev.viewPoint);
        // if we're resting near the anchor point, don't bother with this
        if ((Math.abs(this._anchorPtView.x - this._lastPtView.x) < 5.0) && Math.abs(this._anchorPtView.y - this._lastPtView.y) < 5.0)
            return false;
        const viewport = ev.viewport;
        const view = viewport.view;
        const thisPtNpc = viewport.viewToNpc(this._lastPtView);
        const dist = this._anchorPtNpc.minus(thisPtNpc);
        dist.z = 0.0;
        const zoomFactor = 0.35;
        let zoomRatio = 1.0 + (dist.magnitude() * zoomFactor);
        if (dist.y < 0)
            zoomRatio = 1.0 / zoomRatio;
        this._lastZoomRatio = zoomRatio;
        if (view.is3d() && view.isCameraOn) {
            const anchorPtWorld = viewport.npcToWorld(this._anchorPtNpc);
            const transform = geometry_core_1.Transform.createFixedPointAndMatrix(anchorPtWorld, geometry_core_1.Matrix3d.createScale(zoomRatio, zoomRatio, zoomRatio));
            const oldEyePoint = view.getEyePoint();
            const newEyePoint = transform.multiplyPoint3d(oldEyePoint);
            const cameraOffset = newEyePoint.minus(oldEyePoint);
            const cameraOffsetTransform = geometry_core_1.Transform.createTranslation(cameraOffset);
            const frustum = viewport.getWorldFrustum();
            frustum.transformBy(cameraOffsetTransform, frustum);
            viewport.setupViewFromFrustum(frustum);
        }
        else {
            const transform = geometry_core_1.Transform.createFixedPointAndMatrix(this._anchorPtNpc, geometry_core_1.Matrix3d.createScale(zoomRatio, zoomRatio, 1.0));
            const frustum = viewport.getFrustum(Viewport_1.CoordSystem.Npc, true);
            frustum.transformBy(transform, frustum);
            viewport.npcToWorldArray(frustum.points);
            viewport.setupViewFromFrustum(frustum);
        }
        return true;
    }
}
/** @internal */
class NavigateMotion {
    constructor(viewport) {
        this.viewport = viewport;
        this.deltaTime = 0;
        this.transform = geometry_core_1.Transform.createIdentity();
    }
    init(elapsedMilliseconds) {
        this.deltaTime = elapsedMilliseconds * 0.001;
        this.transform.setIdentity();
    }
    getViewUp(result) { return this.viewport.rotation.getRow(1, result); }
    getViewDirection(result) {
        const forward = this.viewport.rotation.getRow(2, result);
        forward.scale(-1, forward); // positive z is out of the screen, but we want direction into the screen
        return forward;
    }
    takeElevator(distance) {
        const trans = geometry_core_1.Point3d.create(0, 0, distance * this.deltaTime);
        geometry_core_1.Transform.createTranslation(trans, this.transform);
    }
    modifyPitchAngleToPreventInversion(pitchAngle) {
        const angleLimit = geometry_core_1.Angle.degreesToRadians(85);
        const angleTolerance = geometry_core_1.Angle.degreesToRadians(0.01);
        if (0.0 === pitchAngle)
            return 0.0;
        const viewUp = this.getViewUp();
        const viewDir = this.getViewDirection();
        const worldUp = geometry_core_1.Vector3d.unitZ();
        let viewAngle = worldUp.angleTo(viewUp).radians;
        if (viewDir.z < 0)
            viewAngle *= -1;
        let newAngle = pitchAngle + viewAngle;
        if (Math.abs(newAngle) < angleLimit)
            return pitchAngle; // not close to the limit
        if ((pitchAngle > 0) !== (viewAngle > 0) && (Math.abs(pitchAngle) < Math.PI / 2))
            return pitchAngle; // tilting away from the limit
        if (Math.abs(viewAngle) >= (angleLimit - angleTolerance))
            return 0.0; // at the limit already
        const difference = Math.abs(newAngle) - angleLimit;
        newAngle = (pitchAngle > 0) ? pitchAngle - difference : pitchAngle + difference;
        return newAngle; // almost at the limit, but still can go a little bit closer
    }
    generateRotationTransform(yawRate, pitchRate, result) {
        const vp = this.viewport;
        const view = vp.view;
        const viewRot = vp.rotation;
        const invViewRot = viewRot.inverse();
        const pitchAngle = geometry_core_1.Angle.createRadians(this.modifyPitchAngleToPreventInversion(pitchRate * this.deltaTime));
        const pitchMatrix = geometry_core_1.Matrix3d.createRotationAroundVector(geometry_core_1.Vector3d.unitX(), pitchAngle);
        const pitchTimesView = pitchMatrix.multiplyMatrixMatrix(viewRot);
        const inverseViewTimesPitchTimesView = invViewRot.multiplyMatrixMatrix(pitchTimesView);
        const yawMatrix = geometry_core_1.Matrix3d.createRotationAroundVector(geometry_core_1.Vector3d.unitZ(), geometry_core_1.Angle.createRadians(yawRate * this.deltaTime));
        const yawTimesInverseViewTimesPitchTimesView = yawMatrix.multiplyMatrixMatrix(inverseViewTimesPitchTimesView);
        return geometry_core_1.Transform.createFixedPointAndMatrix(view.getEyePoint(), yawTimesInverseViewTimesPitchTimesView, result);
    }
    generateTranslationTransform(velocity, isConstrainedToXY, result) {
        const points = new Array(3);
        points[0] = new geometry_core_1.Point3d(0, 0, 0);
        points[1] = new geometry_core_1.Point3d(1, 0, 0);
        points[2] = new geometry_core_1.Point3d(0, 1, 0);
        if (this.viewport.isCameraOn) {
            this.viewport.viewToNpcArray(points);
            points[0].z = points[1].z = points[2].z = ViewManip.getFocusPlaneNpc(this.viewport); // use the focal plane for z coordinates
            this.viewport.npcToViewArray(points);
        }
        this.viewport.viewToWorldArray(points);
        const xDir = geometry_core_1.Vector3d.createStartEnd(points[0], points[1]);
        xDir.normalizeInPlace();
        const yDir = geometry_core_1.Vector3d.createStartEnd(points[0], points[2]);
        yDir.normalizeInPlace();
        const zDir = this.getViewDirection();
        if (isConstrainedToXY) {
            const up = geometry_core_1.Vector3d.unitZ();
            const cross = up.crossProduct(zDir);
            cross.crossProduct(up, zDir);
            zDir.normalizeInPlace();
        }
        xDir.scale(velocity.x * this.deltaTime, xDir);
        yDir.scale(velocity.y * this.deltaTime, yDir);
        zDir.scale(velocity.z * this.deltaTime, zDir);
        xDir.plus(yDir, xDir).plus(zDir, xDir);
        return geometry_core_1.Transform.createTranslation(xDir, result);
    }
    moveAndLook(linearVelocity, angularVelocityX, angularVelocityY, isConstrainedToXY) {
        const rotateTrans = this.generateRotationTransform(angularVelocityX, angularVelocityY);
        const dollyTrans = this.generateTranslationTransform(linearVelocity, isConstrainedToXY);
        this.transform.setMultiplyTransformTransform(rotateTrans, dollyTrans);
    }
    pan(horizontalVelocity, verticalVelocity) {
        const travel = new geometry_core_1.Vector3d(horizontalVelocity, verticalVelocity, 0);
        this.moveAndLook(travel, 0, 0, false);
    }
    travel(yawRate, pitchRate, forwardVelocity, isConstrainedToXY) {
        const travel = new geometry_core_1.Vector3d(0, 0, forwardVelocity);
        this.moveAndLook(travel, yawRate, pitchRate, isConstrainedToXY);
    }
    look(yawRate, pitchRate) { this.generateRotationTransform(yawRate, pitchRate, this.transform); }
    /** reset pitch of view to zero */
    resetToLevel() {
        const view = this.viewport.view;
        if (!view.is3d() || !view.isCameraOn)
            return;
        const angles = geometry_core_1.YawPitchRollAngles.createFromMatrix3d(this.viewport.rotation);
        angles.pitch.setRadians(0); // reset pitch to zero
        geometry_core_1.Transform.createFixedPointAndMatrix(view.getEyePoint(), angles.toMatrix3d(), this.transform);
    }
}
/** ViewingToolHandle for performing the "walk and fly view" operations */
class ViewNavigate extends ViewingToolHandle {
    constructor(viewManip) {
        super(viewManip);
        this._anchorPtView = new geometry_core_1.Point3d();
        this._lastPtView = new geometry_core_1.Point3d();
        this._initialized = false;
        this._lastMotionTime = 0;
        this._orientationValid = false;
        this._orientationTime = 0;
        this._orientationZ = new geometry_core_1.Vector3d();
    }
    haveStaticOrientation(zVec, currentTime) {
        if (!this._orientationValid || zVec.angleTo(this._orientationZ).radians > ViewNavigate._angleLimit || this._orientationZ.isAlmostZero) {
            this._orientationValid = true;
            this._orientationTime = currentTime;
            this._orientationZ = zVec;
            return false;
        }
        return (currentTime - this._orientationTime) > ViewNavigate._timeLimit;
    }
    tryOrientationEvent(_forward, _ev) {
        return { eventsEnabled: false, result: 1 /* NoEvent */ };
    }
    getElapsedTime(currentTime) {
        let elapsedTime = currentTime - this._lastMotionTime;
        if (0 === this._lastMotionTime || elapsedTime < 0 || elapsedTime > 1000)
            elapsedTime = 100;
        return elapsedTime;
    }
    getMaxLinearVelocity() { return Tool_1.ToolSettings.walkVelocity; }
    getMaxAngularVelocity() { return Math.PI / 4; }
    testHandleForHit(_ptScreen, out) {
        out.distance = 0.0;
        out.priority = 1 /* Low */;
        return true;
    }
    getInputVector(result) {
        const inputDeadZone = 5.0;
        const input = this._anchorPtView.vectorTo(this._lastPtView, result);
        const viewRect = this.viewTool.viewport.viewRect;
        if (Math.abs(input.x) < inputDeadZone)
            input.x = 0;
        else
            input.x = 2 * input.x / viewRect.width;
        if (Math.abs(input.y) < inputDeadZone)
            input.y = 0;
        else
            input.y = 2 * input.y / viewRect.height;
        input.x = Math.min(input.x, 1);
        input.y = Math.min(input.y, 1);
        return input;
    }
    getCenterPoint(result) {
        const center = result ? result : new geometry_core_1.Point3d();
        center.setZero();
        const rect = this.viewTool.viewport.viewRect;
        const width = rect.width;
        const height = rect.height;
        if (width > 0)
            center.x = width / 2;
        if (height > 0)
            center.y = height / 2;
        return center;
    }
    getNavigateMode() {
        const state = IModelApp_1.IModelApp.toolAdmin.currentInputState;
        if (state.isShiftDown || !this.viewTool.viewport.isCameraOn)
            return 0 /* Pan */;
        return state.isControlDown ? 1 /* Look */ : 2 /* Travel */;
    }
    doNavigate(ev) {
        const currentTime = Date.now();
        const forward = new geometry_core_1.Vector3d();
        const orientationEvent = this.tryOrientationEvent(forward, ev);
        const orientationResult = orientationEvent.result;
        const elapsedTime = this.getElapsedTime(currentTime);
        this._lastMotionTime = currentTime;
        const vp = this.viewTool.viewport;
        const motion = this.getNavigateMotion(elapsedTime);
        let haveNavigateEvent = !!motion;
        if (haveNavigateEvent) {
            const frust = vp.getWorldFrustum();
            frust.multiply(motion.transform);
            if (!vp.setupViewFromFrustum(frust)) {
                haveNavigateEvent = false;
                if (1 /* NoEvent */ === orientationResult)
                    return false;
            }
            return true;
        }
        switch (orientationResult) {
            case 2 /* Disabled */:
            case 1 /* NoEvent */:
                return true;
            case 3 /* RejectedByController */:
            case 0 /* Success */:
                return this.haveStaticOrientation(forward, currentTime);
            default:
                return false;
        }
    }
    doManipulation(ev, inDynamics) {
        if (!inDynamics)
            return true;
        else if (ev.viewport !== this.viewTool.viewport)
            return false;
        this._lastPtView.setFrom(ev.viewPoint);
        return this.doNavigate(ev);
    }
    noMotion(ev) {
        if (ev.viewport !== this.viewTool.viewport)
            return false;
        this.doNavigate(ev);
        return false;
    }
    onReinitialize() {
        if (this._initialized)
            return;
        this._initialized = true;
        const tool = this.viewTool;
        const vp = tool.viewport;
        const view = vp.view;
        if (!view.allow3dManipulations())
            return;
        const startFrust = vp.getWorldFrustum();
        const walkAngle = Tool_1.ToolSettings.walkCameraAngle;
        if (!tool.lensAngleMatches(walkAngle, geometry_core_1.Angle.degreesToRadians(10)) || !tool.isZUp) {
            //  This turns on the camera if its not already on. It also assures the camera is centered. Obviously this is required if
            //  the camera is not on or the lens angle is not what we want. We also want to do it if Z will be
            //  adjusted because EnforceZUp swivels the camera around what GetTargetPoint returns. If the FocusDistance is not set to something
            //  reasonable the target point may be far beyond anything relevant.
            tool.setCameraLensAngle(walkAngle, tool.lensAngleMatches(walkAngle, geometry_core_1.Angle.degreesToRadians(45.)));
        }
        if (Tool_1.ToolSettings.walkEnforceZUp)
            this.viewTool.enforceZUp(view.getTargetPoint());
        const endFrust = vp.getWorldFrustum();
        if (!startFrust.equals(endFrust))
            vp.animateFrustumChange(startFrust, endFrust);
        this.getCenterPoint(this._anchorPtView);
    }
    onCleanup() {
    }
    firstPoint(ev) {
        // NB: In desktop apps we want to center the cursor in the view.
        // The browser doesn't support that, and it is more useful to be able to place the anchor point freely anyway.
        this.viewTool.beginDynamicUpdate();
        this._lastPtView.setFrom(ev.viewPoint);
        this._anchorPtView.setFrom(this._lastPtView);
        return true;
    }
    getHandleCursor() { return IModelApp_1.IModelApp.viewManager.crossHairCursor; }
    drawHandle(context, _hasFocus) {
        if (context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)
            return;
        const position = this._anchorPtView.clone();
        position.x = Math.floor(position.x) + 0.5;
        position.y = Math.floor(position.y) + 0.5;
        const drawDecoration = (ctx) => {
            ctx.strokeStyle = "black";
            ctx.lineWidth = 1;
            ctx.strokeRect(-2, -2, 5, 5);
            ctx.fillStyle = "white";
            ctx.fillRect(-1, -1, 3, 3);
        };
        context.addCanvasDecoration({ position, drawDecoration });
    }
}
ViewNavigate._angleLimit = 0.075;
ViewNavigate._timeLimit = 500;
/** ViewingToolHandle for performing the "walk view" operation */
class ViewWalk extends ViewNavigate {
    constructor(viewManip) {
        super(viewManip);
        this._navigateMotion = new NavigateMotion(this.viewTool.viewport);
    }
    get handleType() { return 32 /* Walk */; }
    firstPoint(ev) { ViewTool.showPrompt("Walk.Prompts.NextPoint"); return super.firstPoint(ev); }
    getNavigateMotion(elapsedTime) {
        const input = this.getInputVector();
        if (0 === input.x && 0 === input.y)
            return undefined;
        const motion = this._navigateMotion;
        motion.init(elapsedTime);
        switch (this.getNavigateMode()) {
            case 0 /* Pan */:
                input.scale(this.getMaxLinearVelocity(), input);
                motion.pan(input.x, input.y);
                break;
            case 1 /* Look */:
                input.scale(-this.getMaxAngularVelocity(), input);
                motion.look(input.x, input.y);
                break;
            case 2 /* Travel */:
                motion.travel(-input.x * this.getMaxAngularVelocity(), 0, -input.y * this.getMaxLinearVelocity(), true);
                break;
        }
        return motion;
    }
}
/** ViewingToolHandle for performing the "fly view" operation */
class ViewFly extends ViewNavigate {
    constructor(viewManip) {
        super(viewManip);
        this._navigateMotion = new NavigateMotion(this.viewTool.viewport);
    }
    get handleType() { return 64 /* Fly */; }
    firstPoint(ev) { ViewTool.showPrompt("Fly.Prompts.NextPoint"); return super.firstPoint(ev); }
    getNavigateMotion(elapsedTime) {
        const input = this.getInputVector();
        const motion = this._navigateMotion;
        motion.init(elapsedTime);
        switch (this.getNavigateMode()) {
            case 0 /* Pan */:
                if (0 === input.x && 0 === input.y)
                    return undefined;
                input.scale(this.getMaxLinearVelocity(), input);
                motion.pan(input.x, input.y);
                break;
            case 1 /* Look */:
                if (0 === input.x && 0 === input.y)
                    return undefined;
                input.scale(-this.getMaxAngularVelocity(), input);
                motion.look(input.x, input.y);
                break;
            case 2 /* Travel */:
                input.scale(-this.getMaxAngularVelocity() * 2.0, input);
                motion.travel(input.x, input.y, this.getMaxLinearVelocity(), false);
                break;
        }
        return motion;
    }
}
/** The tool that performs a Pan view operation
 * @public
 */
class PanViewTool extends ViewManip {
    constructor(vp, oneShot = false, isDraggingRequired = false) {
        super(vp, 4 /* Pan */, oneShot, isDraggingRequired);
    }
    onReinitialize() { super.onReinitialize(); ViewTool.showPrompt("Pan.Prompts.FirstPoint"); }
}
PanViewTool.toolId = "View.Pan";
exports.PanViewTool = PanViewTool;
/** A tool that performs a Rotate view operation
 * @public
 */
class RotateViewTool extends ViewManip {
    constructor(vp, oneShot = false, isDraggingRequired = false) {
        super(vp, 1 /* Rotate */ | 4 /* Pan */ | 2 /* TargetCenter */, oneShot, isDraggingRequired);
    }
    onReinitialize() { super.onReinitialize(); ViewTool.showPrompt("Rotate.Prompts.FirstPoint"); }
}
RotateViewTool.toolId = "View.Rotate";
exports.RotateViewTool = RotateViewTool;
/** A tool that performs the look operation
 * @public
 */
class LookViewTool extends ViewManip {
    constructor(vp, oneShot = false, isDraggingRequired = false) {
        super(vp, 128 /* Look */, oneShot, isDraggingRequired);
    }
    onReinitialize() { super.onReinitialize(); ViewTool.showPrompt("Look.Prompts.FirstPoint"); }
}
LookViewTool.toolId = "View.Look";
exports.LookViewTool = LookViewTool;
/** A tool that performs the scroll operation
 * @public
 */
class ScrollViewTool extends ViewManip {
    constructor(vp, oneShot = false, isDraggingRequired = false) {
        super(vp, 8 /* Scroll */, oneShot, isDraggingRequired);
    }
    onReinitialize() { super.onReinitialize(); ViewTool.showPrompt("Scroll.Prompts.FirstPoint"); }
}
ScrollViewTool.toolId = "View.Scroll";
exports.ScrollViewTool = ScrollViewTool;
/** A tool that performs the zoom operation
 * @public
 */
class ZoomViewTool extends ViewManip {
    constructor(vp, oneShot = false, isDraggingRequired = false) {
        super(vp, 16 /* Zoom */, oneShot, isDraggingRequired);
    }
    onReinitialize() { super.onReinitialize(); ViewTool.showPrompt("Zoom.Prompts.FirstPoint"); }
}
ZoomViewTool.toolId = "View.Zoom";
exports.ZoomViewTool = ZoomViewTool;
/** A tool that performs the walk operation
 * @public
 */
class WalkViewTool extends ViewManip {
    constructor(vp, oneShot = false, isDraggingRequired = false) {
        super(vp, 32 /* Walk */, oneShot, isDraggingRequired);
    }
    onReinitialize() { super.onReinitialize(); ViewTool.showPrompt("Walk.Prompts.FirstPoint"); }
}
WalkViewTool.toolId = "View.Walk";
exports.WalkViewTool = WalkViewTool;
/** A tool that performs the fly operation
 * @public
 */
class FlyViewTool extends ViewManip {
    constructor(vp, oneShot = false, isDraggingRequired = false) {
        super(vp, 64 /* Fly */, oneShot, isDraggingRequired);
    }
    onReinitialize() { super.onReinitialize(); ViewTool.showPrompt("Fly.Prompts.FirstPoint"); }
}
FlyViewTool.toolId = "View.Fly";
exports.FlyViewTool = FlyViewTool;
/** A tool that performs a fit view
 * @public
 */
class FitViewTool extends ViewTool {
    constructor(viewport, oneShot, doAnimate = true, isolatedOnly = true) {
        super(viewport);
        this.viewport = viewport;
        this.oneShot = oneShot;
        this.doAnimate = doAnimate;
        this.isolatedOnly = isolatedOnly;
    }
    async onDataButtonDown(ev) {
        if (ev.viewport)
            return await this.doFit(ev.viewport, this.oneShot, this.doAnimate, this.isolatedOnly) ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No;
        return Tool_1.EventHandled.No;
    }
    onPostInstall() {
        super.onPostInstall();
        if (undefined === this.viewport || !this.oneShot)
            ViewTool.showPrompt("Fit.Prompts.FirstPoint");
        if (this.viewport)
            this.doFit(this.viewport, this.oneShot, this.doAnimate, this.isolatedOnly); // tslint:disable-line:no-floating-promises
    }
    async doFit(viewport, oneShot, doAnimate = true, isolatedOnly = true) {
        if (!isolatedOnly || !await ViewManip.zoomToAlwaysDrawnExclusive(viewport, doAnimate))
            ViewManip.fitView(viewport, doAnimate);
        if (oneShot)
            this.exitTool();
        return oneShot;
    }
}
FitViewTool.toolId = "View.Fit";
exports.FitViewTool = FitViewTool;
/** A tool that rotates the view to one of the standard views.
 * @public
 */
class StandardViewTool extends ViewTool {
    constructor(viewport, _standardViewId) {
        super(viewport);
        this._standardViewId = _standardViewId;
    }
    onPostInstall() {
        super.onPostInstall();
        if (this.viewport) {
            const id = this._standardViewId;
            const vp = this.viewport;
            const rMatrix = AccuDraw_1.AccuDraw.getStandardRotation(id, vp, vp.isContextRotationRequired);
            const inverse = rMatrix.inverse();
            if (undefined !== inverse) {
                const targetMatrix = inverse.multiplyMatrixMatrix(vp.rotation);
                const rotateTransform = geometry_core_1.Transform.createFixedPointAndMatrix(vp.view.getTargetPoint(), targetMatrix);
                const startFrustum = vp.getFrustum();
                const newFrustum = startFrustum.clone();
                newFrustum.multiply(rotateTransform);
                vp.animateFrustumChange(startFrustum, newFrustum);
                vp.view.setupFromFrustum(newFrustum);
                vp.synchWithView(true);
            }
        }
        this.exitTool();
    }
}
StandardViewTool.toolId = "View.Standard";
exports.StandardViewTool = StandardViewTool;
/** A tool that performs a Window-area view operation
 * @public
 */
class WindowAreaTool extends ViewTool {
    constructor() {
        super(...arguments);
        this._haveFirstPoint = false;
        this._firstPtWorld = geometry_core_1.Point3d.create();
        this._secondPtWorld = geometry_core_1.Point3d.create();
        this._corners = [new geometry_core_1.Point3d(), new geometry_core_1.Point3d()];
        this._shapePts = [new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d(), new geometry_core_1.Point3d()];
        this._fillColor = imodeljs_common_1.ColorDef.from(0, 0, 255, 200);
    }
    onPostInstall() { super.onPostInstall(); ViewTool.showPrompt("WindowArea.Prompts.FirstPoint"); }
    onReinitialize() { this._haveFirstPoint = false; this._firstPtWorld.setZero(); this._secondPtWorld.setZero(); ViewTool.showPrompt("WindowArea.Prompts.FirstPoint"); }
    async onResetButtonUp(ev) { if (this._haveFirstPoint) {
        this.onReinitialize();
        return Tool_1.EventHandled.Yes;
    } return super.onResetButtonUp(ev); }
    async onDataButtonDown(ev) {
        if (undefined === ev.viewport) {
            return Tool_1.EventHandled.Yes;
        }
        else if (undefined === this.viewport) {
            this.viewport = ev.viewport;
        }
        else if (this.viewport.view.iModel !== ev.viewport.view.iModel) {
            if (this._haveFirstPoint)
                return Tool_1.EventHandled.Yes;
            this.viewport = ev.viewport;
            this._lastPtView = ev.viewPoint;
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            return Tool_1.EventHandled.Yes;
        }
        if (this._haveFirstPoint) {
            this._secondPtWorld.setFrom(ev.point);
            this.doManipulation(ev, false);
            this.onReinitialize();
            this.viewport.invalidateDecorations();
        }
        else {
            this._firstPtWorld.setFrom(ev.point);
            this._secondPtWorld.setFrom(this._firstPtWorld);
            this._haveFirstPoint = true;
            this._lastPtView = ev.viewPoint;
            ViewTool.showPrompt("WindowArea.Prompts.NextPoint");
        }
        return Tool_1.EventHandled.Yes;
    }
    async onMouseMotion(ev) { this.doManipulation(ev, true); }
    async onTouchTap(ev) { return ev.isSingleTap ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No; } // Prevent IdleTool from converting single tap into data button down/up...
    async onTouchMoveStart(ev, startEv) { if (!this._haveFirstPoint && startEv.isSingleTouch)
        await IModelApp_1.IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev); return this._haveFirstPoint ? Tool_1.EventHandled.Yes : Tool_1.EventHandled.No; }
    async onTouchMove(ev) { if (this._haveFirstPoint)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }
    async onTouchComplete(ev) { if (this._haveFirstPoint)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }
    async onTouchCancel(ev) { if (this._haveFirstPoint)
        return IModelApp_1.IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, Tool_1.BeButton.Reset); }
    computeWindowCorners() {
        const vp = this.viewport;
        const corners = this._corners;
        corners[0].setFrom(this._firstPtWorld);
        corners[1].setFrom(this._secondPtWorld);
        vp.worldToViewArray(corners);
        const delta = corners[1].minus(corners[0]);
        if (delta.magnitudeXY() < vp.pixelsFromInches(Tool_1.ToolSettings.startDragDistanceInches))
            return undefined;
        const currentDelta = vp.viewDelta;
        if (currentDelta.x === 0 || delta.x === 0)
            return undefined;
        const viewAspect = currentDelta.y / currentDelta.x;
        const aspectRatio = Math.abs(delta.y / delta.x);
        let halfDeltaX;
        let halfDeltaY;
        if (aspectRatio < viewAspect) {
            halfDeltaX = Math.abs(delta.x) / 2.0;
            halfDeltaY = halfDeltaX * viewAspect;
        }
        else {
            halfDeltaY = Math.abs(delta.y) / 2.0;
            halfDeltaX = halfDeltaY / viewAspect;
        }
        const center = corners[0].plusScaled(delta, 0.5);
        corners[0].x = center.x - halfDeltaX;
        corners[0].y = center.y - halfDeltaY;
        corners[1].x = center.x + halfDeltaX;
        corners[1].y = center.y + halfDeltaY;
        return corners;
    }
    decorate(context) {
        if (undefined === this.viewport || this.viewport.view.iModel !== context.viewport.view.iModel)
            return;
        const vp = this.viewport;
        const color = vp.getContrastToBackgroundColor();
        if (this._haveFirstPoint) {
            const corners = this.computeWindowCorners();
            if (undefined === corners)
                return;
            this._shapePts[0].x = this._shapePts[3].x = corners[0].x;
            this._shapePts[1].x = this._shapePts[2].x = corners[1].x;
            this._shapePts[0].y = this._shapePts[1].y = corners[0].y;
            this._shapePts[2].y = this._shapePts[3].y = corners[1].y;
            this._shapePts[0].z = this._shapePts[1].z = this._shapePts[2].z = this._shapePts[3].z = corners[0].z;
            this._shapePts[4].setFrom(this._shapePts[0]);
            vp.viewToWorldArray(this._shapePts);
            const builder = context.createGraphicBuilder(rendering_1.GraphicType.WorldOverlay);
            builder.setBlankingFill(this._fillColor);
            builder.addShape(this._shapePts);
            builder.setSymbology(color, color, 1 /* Thin */);
            builder.addLineString(this._shapePts);
            builder.setSymbology(color, color, 8 /* FatDot */);
            builder.addPointString([this._firstPtWorld]);
            context.addDecorationFromBuilder(builder);
            return;
        }
        if (undefined === this._lastPtView)
            return;
        const cursorPt = this._lastPtView.clone();
        cursorPt.x = Math.floor(cursorPt.x) + 0.5;
        cursorPt.y = Math.floor(cursorPt.y) + 0.5;
        const viewRect = vp.viewRect;
        const drawDecoration = (ctx) => {
            ctx.beginPath();
            ctx.strokeStyle = (imodeljs_common_1.ColorDef.black === color ? "black" : "white");
            ctx.lineWidth = 1;
            ctx.moveTo(viewRect.left, cursorPt.y);
            ctx.lineTo(viewRect.right, cursorPt.y);
            ctx.moveTo(cursorPt.x, viewRect.top);
            ctx.lineTo(cursorPt.x, viewRect.bottom);
            ctx.stroke();
        };
        context.addCanvasDecoration({ drawDecoration });
    }
    doManipulation(ev, inDynamics) {
        this._secondPtWorld.setFrom(ev.point);
        if (inDynamics) {
            if (undefined !== this.viewport && undefined !== ev.viewport && this.viewport.view.iModel !== ev.viewport.view.iModel) {
                this._lastPtView = undefined;
                return;
            }
            this._lastPtView = ev.viewPoint;
            IModelApp_1.IModelApp.viewManager.invalidateDecorationsAllViews();
            return;
        }
        const corners = this.computeWindowCorners();
        if (!corners)
            return;
        let delta;
        const vp = this.viewport;
        const startFrust = vp.getWorldFrustum();
        vp.viewToWorldArray(corners);
        if (vp.view.is3d() && vp.view.isCameraOn) {
            const cameraView = vp.view;
            const windowArray = [corners[0].clone(), corners[1].clone()];
            vp.worldToViewArray(windowArray);
            const windowRange = new Viewport_1.ViewRect(windowArray[0].x, windowArray[0].y, windowArray[1].x, windowArray[1].y);
            let npcZValues = vp.determineVisibleDepthRange(windowRange);
            if (!npcZValues)
                npcZValues = { minimum: 0, maximum: ViewManip.getFocusPlaneNpc(vp) };
            const lensAngle = cameraView.getLensAngle();
            vp.worldToNpcArray(corners);
            corners[0].z = corners[1].z = npcZValues.maximum;
            vp.npcToWorldArray(corners); // Put corners back in world at correct depth
            const viewPts = [corners[0].clone(), corners[1].clone()];
            vp.rotation.multiplyVectorArrayInPlace(viewPts); // rotate to view orientation to get extents
            const range = geometry_core_1.Range3d.createArray(viewPts);
            delta = geometry_core_1.Vector3d.createStartEnd(range.low, range.high);
            const focusDist = Math.max(delta.x, delta.y) / (2.0 * Math.tan(lensAngle.radians / 2));
            const newTarget = corners[0].interpolate(.5, corners[1]);
            const newEye = newTarget.plusScaled(cameraView.getZVector(), focusDist);
            if (cameraView.lookAtUsingLensAngle(newEye, newTarget, cameraView.getYVector(), lensAngle, focusDist) !== ViewState_1.ViewStatus.Success)
                return;
        }
        else {
            vp.rotation.multiplyVectorArrayInPlace(corners);
            const range = geometry_core_1.Range3d.createArray(corners);
            delta = geometry_core_1.Vector3d.createStartEnd(range.low, range.high);
            // get the view extents
            delta.z = vp.view.getExtents().z;
            // make sure its not too big or too small
            vp.view.validateViewDelta(delta, true);
            vp.view.setExtents(delta);
            const originVec = vp.rotation.multiplyTransposeXYZ(range.low.x, range.low.y, range.low.z);
            vp.view.setOrigin(geometry_core_1.Point3d.createFrom(originVec));
        }
        vp.synchWithView(true);
        vp.animateFrustumChange(startFrust, vp.getFrustum());
    }
}
WindowAreaTool.toolId = "View.WindowArea";
exports.WindowAreaTool = WindowAreaTool;
/** @internal */
class DefaultViewTouchTool extends ViewManip {
    constructor(startEv, _ev) {
        super(startEv.viewport, 0, true, false);
        this._lastPtView = new geometry_core_1.Point3d();
        this._startPtWorld = new geometry_core_1.Point3d();
        this._startPtView = new geometry_core_1.Point3d();
        this._startDirection = new geometry_core_1.Vector2d();
        this._startDistance = 0.0;
        this._startTouchCount = 0;
        this._frustum = new imodeljs_common_1.Frustum();
        this.onStart(startEv);
    }
    onStart(ev) {
        const vp = this.viewport;
        vp.getWorldFrustum(this._frustum);
        const visiblePoint = vp.pickNearestVisibleGeometry(ev.rawPoint, vp.pixelsFromInches(Tool_1.ToolSettings.viewToolPickRadiusInches));
        if (undefined !== visiblePoint) {
            this._startPtWorld.setFrom(visiblePoint);
            vp.worldToView(this._startPtWorld, this._startPtView);
        }
        else {
            this._startPtView.setFrom(ev.viewPoint);
            this._startPtView.z = vp.worldToView(vp.view.getTargetPoint()).z;
            vp.viewToWorld(this._startPtView, this._startPtWorld);
        }
        this._lastPtView.setFrom(this._startPtView);
        this._startTouchCount = ev.touchCount;
        this._startDirection = (2 <= ev.touchCount ? geometry_core_1.Vector2d.createStartEnd(Tool_1.BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp), Tool_1.BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp)) : geometry_core_1.Vector2d.createZero());
        this._startDistance = (2 === ev.touchCount ? this._startDirection.magnitude() : 0.0);
    }
    computeZoomRatio(ev) {
        if (0.0 === this._startDistance)
            return 1.0;
        const vp = this.viewport;
        const distance = (2 === ev.touchCount ? Tool_1.BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp).distance(Tool_1.BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp)) : 0.0);
        if (0.0 === distance)
            return 1.0;
        if (Math.abs(this._startDistance - distance) < this.viewport.pixelsFromInches(0.2))
            return 1.0;
        let zoomRatio = this._startDistance / distance;
        if (zoomRatio < 0.1)
            zoomRatio = 0.1;
        else if (zoomRatio > 10.0)
            zoomRatio = 10.0;
        return zoomRatio;
    }
    computeRotation(ev) {
        if (ev.touchCount < 2)
            return geometry_core_1.Angle.createDegrees(0.0);
        const vp = this.viewport;
        const direction = geometry_core_1.Vector2d.createStartEnd(Tool_1.BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp), Tool_1.BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp));
        const rotation = this._startDirection.angleTo(direction);
        if (Math.abs(rotation.radians) < geometry_core_1.Angle.createDegrees(5.0).radians)
            return geometry_core_1.Angle.createDegrees(0.0);
        const angularDistance = Math.abs(direction.magnitude() / 2.0 * Math.sin(Math.abs(rotation.radians)));
        const zoomDistance = Math.abs(direction.magnitude() - this._startDirection.magnitude());
        const panDistance = this._startPtView.distanceXY(this._lastPtView);
        // NOTE: The * 0.75 below is because it's easy to confuse an attempted rotate for an attempted pan, and this tries to balance that without having a false positive in the opposite direction.
        if (Math.abs(rotation.radians) > geometry_core_1.Angle.createDegrees(18.0).radians || (angularDistance > zoomDistance && angularDistance > panDistance * 0.75))
            return rotation;
        return geometry_core_1.Angle.createDegrees(0.0);
    }
    handle2dPan(_ev) {
        const vp = this.viewport;
        const screenDist = geometry_core_1.Point2d.create(this._startPtView.x - this._lastPtView.x, this._startPtView.y - this._lastPtView.y);
        vp.scroll(screenDist, { saveInUndo: false, animateFrustumChange: false });
    }
    handle2dRotateZoom(ev) {
        const vp = this.viewport;
        const rotation = this.computeRotation(ev);
        const zoomRatio = this.computeZoomRatio(ev);
        const targetWorld = vp.viewToWorld(this._lastPtView);
        const translateTransform = geometry_core_1.Transform.createTranslation(this._startPtWorld.minus(targetWorld));
        const rotationTransform = geometry_core_1.Transform.createFixedPointAndMatrix(targetWorld, geometry_core_1.Matrix3d.createRotationAroundVector(vp.view.getZVector(), rotation));
        const scaleTransform = geometry_core_1.Transform.createScaleAboutPoint(this._startPtWorld, zoomRatio);
        const transform = translateTransform.multiplyTransformTransform(rotationTransform);
        scaleTransform.multiplyTransformTransform(transform, transform);
        const frustum = this._frustum.transformBy(transform);
        vp.setupViewFromFrustum(frustum);
    }
    handle3dRotate(_ev) {
        const vp = this.viewport;
        const viewRect = vp.viewRect;
        const xExtent = viewRect.width;
        const yExtent = viewRect.height;
        const xDelta = this._lastPtView.x - this._startPtView.x;
        const yDelta = this._lastPtView.y - this._startPtView.y;
        const xAxis = Tool_1.ToolSettings.preserveWorldUp ? geometry_core_1.Vector3d.unitZ() : vp.rotation.getRow(1);
        const yAxis = vp.rotation.getRow(0);
        const xRMatrix = (0.0 !== xDelta) ? geometry_core_1.Matrix3d.createRotationAroundVector(xAxis, geometry_core_1.Angle.createRadians(Math.PI / (xExtent / xDelta))) : geometry_core_1.Matrix3d.identity;
        const yRMatrix = (0.0 !== yDelta) ? geometry_core_1.Matrix3d.createRotationAroundVector(yAxis, geometry_core_1.Angle.createRadians(Math.PI / (yExtent / yDelta))) : geometry_core_1.Matrix3d.identity;
        const worldRMatrix = yRMatrix.multiplyMatrixMatrix(xRMatrix);
        const result = worldRMatrix.getAxisAndAngleOfRotation();
        const radians = geometry_core_1.Angle.createRadians(-result.angle.radians);
        const worldAxis = result.axis;
        const rotationMatrix = geometry_core_1.Matrix3d.createRotationAroundVector(worldAxis, radians);
        if (!rotationMatrix)
            return;
        const worldTransform = geometry_core_1.Transform.createFixedPointAndMatrix(this._startPtWorld, rotationMatrix);
        const frustum = this._frustum.transformBy(worldTransform);
        vp.setupViewFromFrustum(frustum);
    }
    handle3dPanZoom(ev) {
        const vp = this.viewport;
        const zoomRatio = this.computeZoomRatio(ev);
        if (vp.isCameraOn) {
            const targetWorld = vp.viewToWorld(this._lastPtView);
            const preTrans = geometry_core_1.Transform.createTranslationXYZ(-targetWorld.x, -targetWorld.y, -targetWorld.z);
            const postTrans = geometry_core_1.Transform.createTranslation(this._startPtWorld);
            preTrans.origin.scaleInPlace(zoomRatio);
            preTrans.matrix.scale(zoomRatio, preTrans.matrix);
            const cameraTransform = postTrans.multiplyTransformTransform(preTrans);
            const view = vp.view;
            const oldEyePoint = view.getEyePoint();
            const newEyePoint = cameraTransform.multiplyPoint3d(oldEyePoint);
            const cameraOffset = newEyePoint.minus(oldEyePoint);
            const cameraOffsetTransform = geometry_core_1.Transform.createTranslation(cameraOffset);
            const frustum = this._frustum.transformBy(cameraOffsetTransform);
            vp.setupViewFromFrustum(frustum);
            return;
        }
        const targetNpc = vp.viewToNpc(this._lastPtView);
        const transform = geometry_core_1.Transform.createFixedPointAndMatrix(targetNpc, geometry_core_1.Matrix3d.createScale(zoomRatio, zoomRatio, 1.0));
        const viewCenter = geometry_core_1.Point3d.create(.5, .5, .5);
        const startPtNpc = vp.viewToNpc(this._startPtView);
        const shift = startPtNpc.minus(targetNpc);
        shift.z = 0.0;
        const offset = geometry_core_1.Transform.createTranslation(shift);
        offset.multiplyTransformTransform(transform, transform);
        transform.multiplyPoint3d(viewCenter, viewCenter);
        vp.npcToWorld(viewCenter, viewCenter);
        vp.zoom(viewCenter, zoomRatio, { saveInUndo: false, animateFrustumChange: false });
    }
    handleEvent(ev) {
        if (undefined === this.viewport)
            return;
        if (this._startTouchCount !== ev.touchCount) {
            this.onStart(ev);
            return;
        }
        const smallDistance = this.viewport.pixelsFromInches(0.05);
        if (this._lastPtView.isAlmostEqualXY(ev.viewPoint, smallDistance))
            return;
        if (this._startPtView.isAlmostEqualXY(ev.viewPoint, smallDistance)) {
            this._lastPtView.setFrom(this._startPtView);
        }
        else {
            this._lastPtView.setFrom(ev.viewPoint);
            this._lastPtView.z = this._startPtView.z;
        }
        if (!this.viewport.setupViewFromFrustum(this._frustum))
            return;
        if (this.viewport.view.allow3dManipulations()) {
            if (ev.isSingleTouch)
                return this.handle3dRotate(ev);
            return this.handle3dPanZoom(ev);
        }
        if (ev.isSingleTouch)
            return this.handle2dPan(ev);
        return this.handle2dRotateZoom(ev);
    }
    async onTouchMove(ev) { this.handleEvent(ev); }
    async onTouchComplete(_ev) { this.exitTool(); }
    async onTouchCancel(_ev) { this.exitTool(); }
    async onDataButtonDown(_ev) { return Tool_1.EventHandled.Yes; }
    async onDataButtonUp(_ev) { return Tool_1.EventHandled.Yes; }
}
DefaultViewTouchTool.toolId = ""; // touch tools installed by IdleTool are never registered
exports.DefaultViewTouchTool = DefaultViewTouchTool;
/** A tool that performs view undo operation. An application could also just call Viewport.doUndo directly, creating a ViewTool isn't required.
 * @public
 */
class ViewUndoTool extends ViewTool {
    onPostInstall() {
        if (this.viewport)
            this.viewport.doUndo(Tool_1.ToolSettings.animationTime);
        this.exitTool();
    }
}
ViewUndoTool.toolId = "View.Undo";
exports.ViewUndoTool = ViewUndoTool;
/** A tool that performs view redo operation. An application could also just call Viewport.doRedo directly, creating a ViewTool isn't required.
 * @public
 */
class ViewRedoTool extends ViewTool {
    onPostInstall() {
        if (this.viewport)
            this.viewport.doRedo(Tool_1.ToolSettings.animationTime);
        this.exitTool();
    }
}
ViewRedoTool.toolId = "View.Redo";
exports.ViewRedoTool = ViewRedoTool;
/** A tool that toggles the camera on/off in a spatial view
 * @public
 */
class ViewToggleCameraTool extends ViewTool {
    onInstall() { return (undefined !== this.viewport && this.viewport.view.allow3dManipulations()); }
    onPostInstall() {
        if (this.viewport) {
            const vp = this.viewport;
            if (vp.isCameraOn)
                vp.view.turnCameraOff();
            else
                vp.turnCameraOn();
            const startFrustum = vp.getFrustum();
            vp.synchWithView(true);
            vp.animateFrustumChange(startFrustum, vp.getFrustum());
        }
        this.exitTool();
    }
}
ViewToggleCameraTool.toolId = "View.ToggleCamera";
exports.ViewToggleCameraTool = ViewToggleCameraTool;


/***/ }),

/***/ "@bentley/bentleyjs-core":
/*!*********************************!*\
  !*** external "bentleyjs_core" ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;

/***/ }),

/***/ "@bentley/geometry-core":
/*!********************************!*\
  !*** external "geometry_core" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_geometry_core__;

/***/ }),

/***/ "@bentley/imodeljs-clients":
/*!***********************************!*\
  !*** external "imodeljs_clients" ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_clients__;

/***/ }),

/***/ "@bentley/imodeljs-common":
/*!**********************************!*\
  !*** external "imodeljs_common" ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_common__;

/***/ }),

/***/ "@bentley/imodeljs-i18n":
/*!********************************!*\
  !*** external "imodeljs_i18n" ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_i18n__;

/***/ }),

/***/ "@bentley/imodeljs-quantity":
/*!************************************!*\
  !*** external "imodeljs_quantity" ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_quantity__;

/***/ })

},[["./lib/imodeljs-frontend.js","runtime"]]]);
});
//# sourceMappingURL=imodeljs-frontend.js.map