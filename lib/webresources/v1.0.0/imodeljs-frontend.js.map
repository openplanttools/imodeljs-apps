{"version":3,"file":"imodeljs-frontend.js","sources":["file:///webpack/universalModuleDefinition","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\fuse.js\\3.4.5\\node_modules\\fuse.js\\dist\\fuse.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\oidc-client\\1.7.1\\node_modules\\oidc-client\\lib\\oidc-client.min.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\process\\0.11.10\\node_modules\\process\\browser.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\semver\\5.7.0\\node_modules\\semver\\semver.js","file:///D:\\vsts_b\\5\\s\\common\\temp\\node_modules\\.registry.npmjs.org\\webpack\\4.32.2\\node_modules\\webpack\\buildin\\global.js","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\AccuDraw.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\AccuSnap.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\AuxCoordSys.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\CategorySelectorState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\ContextRealityModelState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\DevTools.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\DisplayStyleState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\ElementLocateManager.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\EmphasizeElements.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\EntityState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\FrontendLoggerCategory.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\FrontendRequestContext.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\FuzzySearch.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\GeoServices.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\HitDetail.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\IModelApp.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\IModelConnection.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\ImageUtil.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\Marker.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\ModelSelectorState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\ModelState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\NoRenderApp.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\NotificationManager.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\Plugin.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\QuantityFormatter.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\RenderCompatibility.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\RenderScheduleState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\SelectionSet.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\Sheet.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\SolarCalculate.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\SpatialClassification.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\Sprites.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\StandardView.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\SubCategoriesCache.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\TentativePoint.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\TerrainProvider.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\TiledGraphicsProvider.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\ViewContext.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\ViewManager.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\ViewState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\Viewport.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\imodeljs-frontend.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\oidc\\OidcBrowserClient.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\properties\\EditorParams.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\properties\\Record.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\properties\\ToolSettingsValue.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\properties\\Value.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\FeatureSymbology.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\GraphicBuilder.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\MockRender.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\System.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\AuxChannelTable.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\ColorMap.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\DisplayParams.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\PointCloudPrimitive.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\Polyface.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\Primitives.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\Strokes.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\VertexKey.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\VertexTable.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\geometry\\GeometryAccumulator.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\geometry\\GeometryList.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\geometry\\GeometryListBuilder.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\geometry\\GeometryPrimitives.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\mesh\\MeshBuilder.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\mesh\\MeshBuilderMap.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\primitives\\mesh\\MeshPrimitives.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\BranchState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\CachedGeometry.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\ClipVolume.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\ColorInfo.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Diagnostics.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\DrawCommand.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\EdgeOverrides.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\FeatureDimensions.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\FeaturesInfo.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\FloatRGBA.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\FrameBuffer.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\GL.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Graphic.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Handle.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\InstancedGeometry.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Material.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Matrix.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Mesh.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\PlanarClassifier.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\PointCloud.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\PointString.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Polyline.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Primitive.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\RenderBuffer.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\RenderFlags.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\RenderState.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\SceneCompositor.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\ShaderBuilder.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\ShaderProgram.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\SolarShadowMap.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\System.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Target.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Technique.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\TechniqueFlags.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\TechniqueId.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\Texture.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\VertexLUT.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\AmbientOcclusion.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Animation.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Blur.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\ClearPickAndColor.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\ClearTranslucent.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\ClipMask.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Clipping.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Color.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\CombineTextures.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Common.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Composite.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\CopyColor.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\CopyPickBuffers.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\CopyStencil.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Decode.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Edge.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\FeatureSymbology.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Fragment.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Instancing.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Lighting.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\LookupTable.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Monochrome.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\PlanarClassification.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\PointCloud.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\PointString.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Polyline.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\RenderPass.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\SkyBox.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\SkySphere.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\SolarShadowMapping.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Surface.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Translucency.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Vertex.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\Viewport.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\render\\webgl\\glsl\\ViewportQuad.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\rendering.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\B3dmTileIO.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\CompositeTileIO.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\GltfTileIO.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\I3dmTileIO.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\IModelTile.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\IModelTileIO.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\PntsTileIO.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\RealityModelTileTree.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\TileAdmin.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\TileIO.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\TileRequest.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\TileTree.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tile\\WebMapTileTree.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\AccuDrawTool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\ClipViewTool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\EditManipulator.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\ElementSetTool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\EventController.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\IdleTool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\MeasureTool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\PluginTool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\PrimitiveTool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\SelectTool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\Tool.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\ToolAdmin.ts","file:///D:\\vsts_b\\5\\s\\core\\frontend\\src\\tools\\ViewTool.ts","file:///external \"bentleyjs_core\"","file:///external \"geometry_core\"","file:///external \"imodeljs_clients\"","file:///external \"imodeljs_common\"","file:///external \"imodeljs_i18n\"","file:///external \"imodeljs_quantity\""],"sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory(require(\"bentleyjs_core\"), require(\"geometry_core\"), require(\"imodeljs_clients\"), require(\"imodeljs_common\"), require(\"imodeljs_i18n\"), require(\"imodeljs_quantity\"));\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"imodeljs_frontend\", [\"bentleyjs_core\", \"geometry_core\", \"imodeljs_clients\", \"imodeljs_common\", \"imodeljs_i18n\", \"imodeljs_quantity\"], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"imodeljs_frontend\"] = factory(require(\"bentleyjs_core\"), require(\"geometry_core\"), require(\"imodeljs_clients\"), require(\"imodeljs_common\"), require(\"imodeljs_i18n\"), require(\"imodeljs_quantity\"));\n\telse\n\t\troot[\"imodeljs_frontend\"] = factory(root[\"bentleyjs_core\"], root[\"geometry_core\"], root[\"imodeljs_clients\"], root[\"imodeljs_common\"], root[\"imodeljs_i18n\"], root[\"imodeljs_quantity\"]);\n})(this, function(__WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__, __WEBPACK_EXTERNAL_MODULE__bentley_geometry_core__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_clients__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_common__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_i18n__, __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_quantity__) {\nreturn ","/*!\n * Fuse.js v3.4.5 - Lightweight fuzzy-search (http://fusejs.io)\n * \n * Copyright (c) 2012-2017 Kirollos Risk (http://kiro.me)\n * All Rights Reserved. Apache Software License 2.0\n * \n * http://www.apache.org/licenses/LICENSE-2.0\n */\n!function(e,t){\"object\"==typeof exports&&\"object\"==typeof module?module.exports=t():\"function\"==typeof define&&define.amd?define(\"Fuse\",[],t):\"object\"==typeof exports?exports.Fuse=t():e.Fuse=t()}(this,function(){return function(e){var t={};function n(r){if(t[r])return t[r].exports;var o=t[r]={i:r,l:!1,exports:{}};return e[r].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,r){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},n.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(n.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var o in e)n.d(r,o,function(t){return e[t]}.bind(null,o));return r},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,\"a\",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p=\"\",n(n.s=1)}([function(e,t){e.exports=function(e){return Array.isArray?Array.isArray(e):\"[object Array]\"===Object.prototype.toString.call(e)}},function(e,t,n){function r(e){return(r=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e})(e)}function o(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var i=n(2),a=n(8),s=n(0),c=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.caseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m,S=n.id,x=void 0===S?null:S,b=n.keys,M=void 0===b?[]:b,_=n.shouldSort,L=void 0===_||_,w=n.getFn,A=void 0===w?a:w,C=n.sortFn,I=void 0===C?function(e,t){return e.score-t.score}:C,O=n.tokenize,j=void 0!==O&&O,P=n.matchAllTokens,F=void 0!==P&&P,T=n.includeMatches,z=void 0!==T&&T,E=n.includeScore,K=void 0!==E&&E,$=n.verbose,J=void 0!==$&&$;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k,id:x,keys:M,includeMatches:z,includeScore:K,shouldSort:L,getFn:A,sortFn:I,verbose:J,tokenize:j,matchAllTokens:F},this.setCollection(t)}var t,n,c;return t=e,(n=[{key:\"setCollection\",value:function(e){return this.list=e,e}},{key:\"search\",value:function(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{limit:!1};this._log('---------\\nSearch pattern: \"'.concat(e,'\"'));var n=this._prepareSearchers(e),r=n.tokenSearchers,o=n.fullSearcher,i=this._search(r,o),a=i.weights,s=i.results;return this._computeScore(a,s),this.options.shouldSort&&this._sort(s),t.limit&&\"number\"==typeof t.limit&&(s=s.slice(0,t.limit)),this._format(s)}},{key:\"_prepareSearchers\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:\"\",t=[];if(this.options.tokenize)for(var n=e.split(this.options.tokenSeparator),r=0,o=n.length;r<o;r+=1)t.push(new i(n[r],this.options));return{tokenSearchers:t,fullSearcher:new i(e,this.options)}}},{key:\"_search\",value:function(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1?arguments[1]:void 0,n=this.list,r={},o=[];if(\"string\"==typeof n[0]){for(var i=0,a=n.length;i<a;i+=1)this._analyze({key:\"\",value:n[i],record:i,index:i},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t});return{weights:null,results:o}}for(var s={},c=0,h=n.length;c<h;c+=1)for(var l=n[c],u=0,f=this.options.keys.length;u<f;u+=1){var d=this.options.keys[u];if(\"string\"!=typeof d){if(s[d.name]={weight:1-d.weight||1},d.weight<=0||d.weight>1)throw new Error(\"Key weight has to be > 0 and <= 1\");d=d.name}else s[d]={weight:1};this._analyze({key:d,value:this.options.getFn(l,d),record:l,index:c},{resultMap:r,results:o,tokenSearchers:e,fullSearcher:t})}return{weights:s,results:o}}},{key:\"_analyze\",value:function(e,t){var n=e.key,r=e.arrayIndex,o=void 0===r?-1:r,i=e.value,a=e.record,c=e.index,h=t.tokenSearchers,l=void 0===h?[]:h,u=t.fullSearcher,f=void 0===u?[]:u,d=t.resultMap,v=void 0===d?{}:d,p=t.results,g=void 0===p?[]:p;if(null!=i){var y=!1,m=-1,k=0;if(\"string\"==typeof i){this._log(\"\\nKey: \".concat(\"\"===n?\"-\":n));var S=f.search(i);if(this._log('Full text: \"'.concat(i,'\", score: ').concat(S.score)),this.options.tokenize){for(var x=i.split(this.options.tokenSeparator),b=[],M=0;M<l.length;M+=1){var _=l[M];this._log('\\nPattern: \"'.concat(_.pattern,'\"'));for(var L=!1,w=0;w<x.length;w+=1){var A=x[w],C=_.search(A),I={};C.isMatch?(I[A]=C.score,y=!0,L=!0,b.push(C.score)):(I[A]=1,this.options.matchAllTokens||b.push(1)),this._log('Token: \"'.concat(A,'\", score: ').concat(I[A]))}L&&(k+=1)}m=b[0];for(var O=b.length,j=1;j<O;j+=1)m+=b[j];m/=O,this._log(\"Token score average:\",m)}var P=S.score;m>-1&&(P=(P+m)/2),this._log(\"Score average:\",P);var F=!this.options.tokenize||!this.options.matchAllTokens||k>=l.length;if(this._log(\"\\nCheck Matches: \".concat(F)),(y||S.isMatch)&&F){var T=v[c];T?T.output.push({key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}):(v[c]={item:a,output:[{key:n,arrayIndex:o,value:i,score:P,matchedIndices:S.matchedIndices}]},g.push(v[c]))}}else if(s(i))for(var z=0,E=i.length;z<E;z+=1)this._analyze({key:n,arrayIndex:z,value:i[z],record:a,index:c},{resultMap:v,results:g,tokenSearchers:l,fullSearcher:f})}}},{key:\"_computeScore\",value:function(e,t){this._log(\"\\n\\nComputing score:\\n\");for(var n=0,r=t.length;n<r;n+=1){for(var o=t[n].output,i=o.length,a=1,s=1,c=0;c<i;c+=1){var h=e?e[o[c].key].weight:1,l=(1===h?o[c].score:o[c].score||.001)*h;1!==h?s=Math.min(s,l):(o[c].nScore=l,a*=l)}t[n].score=1===s?a:s,this._log(t[n])}}},{key:\"_sort\",value:function(e){this._log(\"\\n\\nSorting....\"),e.sort(this.options.sortFn)}},{key:\"_format\",value:function(e){var t=[];if(this.options.verbose){var n=[];this._log(\"\\n\\nOutput:\\n\\n\",JSON.stringify(e,function(e,t){if(\"object\"===r(t)&&null!==t){if(-1!==n.indexOf(t))return;n.push(t)}return t})),n=null}var o=[];this.options.includeMatches&&o.push(function(e,t){var n=e.output;t.matches=[];for(var r=0,o=n.length;r<o;r+=1){var i=n[r];if(0!==i.matchedIndices.length){var a={indices:i.matchedIndices,value:i.value};i.key&&(a.key=i.key),i.hasOwnProperty(\"arrayIndex\")&&i.arrayIndex>-1&&(a.arrayIndex=i.arrayIndex),t.matches.push(a)}}}),this.options.includeScore&&o.push(function(e,t){t.score=e.score});for(var i=0,a=e.length;i<a;i+=1){var s=e[i];if(this.options.id&&(s.item=this.options.getFn(s.item,this.options.id)[0]),o.length){for(var c={item:s.item},h=0,l=o.length;h<l;h+=1)o[h](s,c);t.push(c)}else t.push(s.item)}return t}},{key:\"_log\",value:function(){var e;this.options.verbose&&(e=console).log.apply(e,arguments)}}])&&o(t.prototype,n),c&&o(t,c),e}();e.exports=c},function(e,t,n){function r(e,t){for(var n=0;n<t.length;n++){var r=t[n];r.enumerable=r.enumerable||!1,r.configurable=!0,\"value\"in r&&(r.writable=!0),Object.defineProperty(e,r.key,r)}}var o=n(3),i=n(4),a=n(7),s=function(){function e(t,n){var r=n.location,o=void 0===r?0:r,i=n.distance,s=void 0===i?100:i,c=n.threshold,h=void 0===c?.6:c,l=n.maxPatternLength,u=void 0===l?32:l,f=n.isCaseSensitive,d=void 0!==f&&f,v=n.tokenSeparator,p=void 0===v?/ +/g:v,g=n.findAllMatches,y=void 0!==g&&g,m=n.minMatchCharLength,k=void 0===m?1:m;!function(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,e),this.options={location:o,distance:s,threshold:h,maxPatternLength:u,isCaseSensitive:d,tokenSeparator:p,findAllMatches:y,minMatchCharLength:k},this.pattern=this.options.isCaseSensitive?t:t.toLowerCase(),this.pattern.length<=u&&(this.patternAlphabet=a(this.pattern))}var t,n,s;return t=e,(n=[{key:\"search\",value:function(e){if(this.options.isCaseSensitive||(e=e.toLowerCase()),this.pattern===e)return{isMatch:!0,score:0,matchedIndices:[[0,e.length-1]]};var t=this.options,n=t.maxPatternLength,r=t.tokenSeparator;if(this.pattern.length>n)return o(e,this.pattern,r);var a=this.options,s=a.location,c=a.distance,h=a.threshold,l=a.findAllMatches,u=a.minMatchCharLength;return i(e,this.pattern,this.patternAlphabet,{location:s,distance:c,threshold:h,findAllMatches:l,minMatchCharLength:u})}}])&&r(t.prototype,n),s&&r(t,s),e}();e.exports=s},function(e,t){var n=/[\\-\\[\\]\\/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g;e.exports=function(e,t){var r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:/ +/g,o=new RegExp(t.replace(n,\"\\\\$&\").replace(r,\"|\")),i=e.match(o),a=!!i,s=[];if(a)for(var c=0,h=i.length;c<h;c+=1){var l=i[c];s.push([e.indexOf(l),l.length-1])}return{score:a?.5:1,isMatch:a,matchedIndices:s}}},function(e,t,n){var r=n(5),o=n(6);e.exports=function(e,t,n,i){for(var a=i.location,s=void 0===a?0:a,c=i.distance,h=void 0===c?100:c,l=i.threshold,u=void 0===l?.6:l,f=i.findAllMatches,d=void 0!==f&&f,v=i.minMatchCharLength,p=void 0===v?1:v,g=s,y=e.length,m=u,k=e.indexOf(t,g),S=t.length,x=[],b=0;b<y;b+=1)x[b]=0;if(-1!==k){var M=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});if(m=Math.min(M,m),-1!==(k=e.lastIndexOf(t,g+S))){var _=r(t,{errors:0,currentLocation:k,expectedLocation:g,distance:h});m=Math.min(_,m)}}k=-1;for(var L=[],w=1,A=S+y,C=1<<S-1,I=0;I<S;I+=1){for(var O=0,j=A;O<j;){r(t,{errors:I,currentLocation:g+j,expectedLocation:g,distance:h})<=m?O=j:A=j,j=Math.floor((A-O)/2+O)}A=j;var P=Math.max(1,g-j+1),F=d?y:Math.min(g+j,y)+S,T=Array(F+2);T[F+1]=(1<<I)-1;for(var z=F;z>=P;z-=1){var E=z-1,K=n[e.charAt(E)];if(K&&(x[E]=1),T[z]=(T[z+1]<<1|1)&K,0!==I&&(T[z]|=(L[z+1]|L[z])<<1|1|L[z+1]),T[z]&C&&(w=r(t,{errors:I,currentLocation:E,expectedLocation:g,distance:h}))<=m){if(m=w,(k=E)<=g)break;P=Math.max(1,2*g-k)}}if(r(t,{errors:I+1,currentLocation:g,expectedLocation:g,distance:h})>m)break;L=T}return{isMatch:k>=0,score:0===w?.001:w,matchedIndices:o(x,p)}}},function(e,t){e.exports=function(e,t){var n=t.errors,r=void 0===n?0:n,o=t.currentLocation,i=void 0===o?0:o,a=t.expectedLocation,s=void 0===a?0:a,c=t.distance,h=void 0===c?100:c,l=r/e.length,u=Math.abs(s-i);return h?l+u/h:u?1:l}},function(e,t){e.exports=function(){for(var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:[],t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=[],r=-1,o=-1,i=0,a=e.length;i<a;i+=1){var s=e[i];s&&-1===r?r=i:s||-1===r||((o=i-1)-r+1>=t&&n.push([r,o]),r=-1)}return e[i-1]&&i-r>=t&&n.push([r,i-1]),n}},function(e,t){e.exports=function(e){for(var t={},n=e.length,r=0;r<n;r+=1)t[e.charAt(r)]=0;for(var o=0;o<n;o+=1)t[e.charAt(o)]|=1<<n-o-1;return t}},function(e,t,n){var r=n(0);e.exports=function(e,t){return function e(t,n,o){if(n){var i=n.indexOf(\".\"),a=n,s=null;-1!==i&&(a=n.slice(0,i),s=n.slice(i+1));var c=t[a];if(null!=c)if(s||\"string\"!=typeof c&&\"number\"!=typeof c)if(r(c))for(var h=0,l=c.length;h<l;h+=1)e(c[h],s,o);else s&&e(c,s,o);else o.push(c.toString())}else o.push(t);return o}(e,t,[])}}])});","!function webpackUniversalModuleDefinition(e,t){if(\"object\"==typeof exports&&\"object\"==typeof module)module.exports=t();else if(\"function\"==typeof define&&define.amd)define([],t);else{var r=t();for(var n in r)(\"object\"==typeof exports?exports:e)[n]=r[n]}}(this,function(){return function(e){var t={};function __webpack_require__(r){if(t[r])return t[r].exports;var n=t[r]={i:r,l:!1,exports:{}};return e[r].call(n.exports,n,n.exports,__webpack_require__),n.l=!0,n.exports}return __webpack_require__.m=e,__webpack_require__.c=t,__webpack_require__.d=function(e,t,r){__webpack_require__.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:r})},__webpack_require__.r=function(e){\"undefined\"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:\"Module\"}),Object.defineProperty(e,\"__esModule\",{value:!0})},__webpack_require__.t=function(e,t){if(1&t&&(e=__webpack_require__(e)),8&t)return e;if(4&t&&\"object\"==typeof e&&e&&e.__esModule)return e;var r=Object.create(null);if(__webpack_require__.r(r),Object.defineProperty(r,\"default\",{enumerable:!0,value:e}),2&t&&\"string\"!=typeof e)for(var n in e)__webpack_require__.d(r,n,function(t){return e[t]}.bind(null,n));return r},__webpack_require__.n=function(e){var t=e&&e.__esModule?function getDefault(){return e.default}:function getModuleExports(){return e};return __webpack_require__.d(t,\"a\",t),t},__webpack_require__.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},__webpack_require__.p=\"\",__webpack_require__(__webpack_require__.s=22)}([function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}();var i={debug:function debug(){},info:function info(){},warn:function warn(){},error:function error(){}},o=void 0,s=void 0;(t.Log=function(){function Log(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,Log)}return Log.reset=function reset(){s=3,o=i},Log.debug=function debug(){if(s>=4){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];o.debug.apply(o,Array.from(t))}},Log.info=function info(){if(s>=3){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];o.info.apply(o,Array.from(t))}},Log.warn=function warn(){if(s>=2){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];o.warn.apply(o,Array.from(t))}},Log.error=function error(){if(s>=1){for(var e=arguments.length,t=Array(e),r=0;r<e;r++)t[r]=arguments[r];o.error.apply(o,Array.from(t))}},n(Log,null,[{key:\"NONE\",get:function get(){return 0}},{key:\"ERROR\",get:function get(){return 1}},{key:\"WARN\",get:function get(){return 2}},{key:\"INFO\",get:function get(){return 3}},{key:\"DEBUG\",get:function get(){return 4}},{key:\"level\",get:function get(){return s},set:function set(e){if(!(0<=e&&e<=4))throw new Error(\"Invalid log level\");s=e}},{key:\"logger\",get:function get(){return o},set:function set(e){if(!e.debug&&e.info&&(e.debug=e.info),!(e.debug&&e.info&&e.warn&&e.error))throw new Error(\"Invalid logger\");o=e}}]),Log}()).reset()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}();var i={setInterval:function(e){function setInterval(t,r){return e.apply(this,arguments)}return setInterval.toString=function(){return e.toString()},setInterval}(function(e,t){return setInterval(e,t)}),clearInterval:function(e){function clearInterval(t){return e.apply(this,arguments)}return clearInterval.toString=function(){return e.toString()},clearInterval}(function(e){return clearInterval(e)})},o=!1,s=null;t.Global=function(){function Global(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,Global)}return Global._testing=function _testing(){o=!0},Global.setXMLHttpRequest=function setXMLHttpRequest(e){s=e},n(Global,null,[{key:\"location\",get:function get(){if(!o)return location}},{key:\"localStorage\",get:function get(){if(!o&&\"undefined\"!=typeof window)return localStorage}},{key:\"sessionStorage\",get:function get(){if(!o&&\"undefined\"!=typeof window)return sessionStorage}},{key:\"XMLHttpRequest\",get:function get(){if(!o&&\"undefined\"!=typeof window)return s||XMLHttpRequest}},{key:\"timer\",get:function get(){if(!o)return i}}]),Global}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.MetadataService=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(7);t.MetadataService=function(){function MetadataService(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.JsonService;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,MetadataService),!e)throw i.Log.error(\"MetadataService: No settings passed to MetadataService\"),new Error(\"settings\");this._settings=e,this._jsonService=new t([\"application/jwk-set+json\"])}return MetadataService.prototype.getMetadata=function getMetadata(){var e=this;return this._settings.metadata?(i.Log.debug(\"MetadataService.getMetadata: Returning metadata from settings\"),Promise.resolve(this._settings.metadata)):this.metadataUrl?(i.Log.debug(\"MetadataService.getMetadata: getting metadata from\",this.metadataUrl),this._jsonService.getJson(this.metadataUrl).then(function(t){return i.Log.debug(\"MetadataService.getMetadata: json received\"),e._settings.metadata=t,t})):(i.Log.error(\"MetadataService.getMetadata: No authority or metadataUrl configured on settings\"),Promise.reject(new Error(\"No authority or metadataUrl configured on settings\")))},MetadataService.prototype.getIssuer=function getIssuer(){return this._getMetadataProperty(\"issuer\")},MetadataService.prototype.getAuthorizationEndpoint=function getAuthorizationEndpoint(){return this._getMetadataProperty(\"authorization_endpoint\")},MetadataService.prototype.getUserInfoEndpoint=function getUserInfoEndpoint(){return this._getMetadataProperty(\"userinfo_endpoint\")},MetadataService.prototype.getTokenEndpoint=function getTokenEndpoint(){var e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0];return this._getMetadataProperty(\"token_endpoint\",e)},MetadataService.prototype.getCheckSessionIframe=function getCheckSessionIframe(){return this._getMetadataProperty(\"check_session_iframe\",!0)},MetadataService.prototype.getEndSessionEndpoint=function getEndSessionEndpoint(){return this._getMetadataProperty(\"end_session_endpoint\",!0)},MetadataService.prototype.getRevocationEndpoint=function getRevocationEndpoint(){return this._getMetadataProperty(\"revocation_endpoint\",!0)},MetadataService.prototype.getKeysEndpoint=function getKeysEndpoint(){return this._getMetadataProperty(\"jwks_uri\",!0)},MetadataService.prototype._getMetadataProperty=function _getMetadataProperty(e){var t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return i.Log.debug(\"MetadataService.getMetadataProperty for: \"+e),this.getMetadata().then(function(r){if(i.Log.debug(\"MetadataService.getMetadataProperty: metadata recieved\"),void 0===r[e]){if(!0===t)return void i.Log.warn(\"MetadataService.getMetadataProperty: Metadata does not contain optional property \"+e);throw i.Log.error(\"MetadataService.getMetadataProperty: Metadata does not contain property \"+e),new Error(\"Metadata does not contain property \"+e)}return r[e]})},MetadataService.prototype.getSigningKeys=function getSigningKeys(){var e=this;return this._settings.signingKeys?(i.Log.debug(\"MetadataService.getSigningKeys: Returning signingKeys from settings\"),Promise.resolve(this._settings.signingKeys)):this._getMetadataProperty(\"jwks_uri\").then(function(t){return i.Log.debug(\"MetadataService.getSigningKeys: jwks_uri received\",t),e._jsonService.getJson(t).then(function(t){if(i.Log.debug(\"MetadataService.getSigningKeys: key set received\",t),!t.keys)throw i.Log.error(\"MetadataService.getSigningKeys: Missing keys on keyset\"),new Error(\"Missing keys on keyset\");return e._settings.signingKeys=t.keys,e._settings.signingKeys})})},n(MetadataService,[{key:\"metadataUrl\",get:function get(){return this._metadataUrl||(this._settings.metadataUrl?this._metadataUrl=this._settings.metadataUrl:(this._metadataUrl=this._settings.authority,this._metadataUrl&&this._metadataUrl.indexOf(\".well-known/openid-configuration\")<0&&(\"/\"!==this._metadataUrl[this._metadataUrl.length-1]&&(this._metadataUrl+=\"/\"),this._metadataUrl+=\".well-known/openid-configuration\"))),this._metadataUrl}}]),MetadataService}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.UrlUtility=void 0;var n=r(0),i=r(1);t.UrlUtility=function(){function UrlUtility(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,UrlUtility)}return UrlUtility.addQueryParam=function addQueryParam(e,t,r){return e.indexOf(\"?\")<0&&(e+=\"?\"),\"?\"!==e[e.length-1]&&(e+=\"&\"),e+=encodeURIComponent(t),e+=\"=\",e+=encodeURIComponent(r)},UrlUtility.parseUrlFragment=function parseUrlFragment(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"#\",r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.Global;\"string\"!=typeof e&&(e=r.location.href);var o=e.lastIndexOf(t);o>=0&&(e=e.substr(o+1)),\"?\"===t&&(o=e.indexOf(\"#\"))>=0&&(e=e.substr(0,o));for(var s,a={},u=/([^&=]+)=([^&]*)/g,c=0;s=u.exec(e);)if(a[decodeURIComponent(s[1])]=decodeURIComponent(s[2]),c++>50)return n.Log.error(\"UrlUtility.parseUrlFragment: response exceeded expected number of parameters\",e),{error:\"Response exceeded expected number of parameters\"};for(var h in a)return a;return{}},UrlUtility}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.JoseUtil=void 0;var n=r(25),i=r(0);var o=[\"RS256\",\"RS384\",\"RS512\",\"PS256\",\"PS384\",\"PS512\",\"ES256\",\"ES384\",\"ES512\"];t.JoseUtil=function(){function JoseUtil(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,JoseUtil)}return JoseUtil.parseJwt=function parseJwt(e){i.Log.debug(\"JoseUtil.parseJwt\");try{var t=n.jws.JWS.parse(e);return{header:t.headerObj,payload:t.payloadObj}}catch(e){i.Log.error(e)}},JoseUtil.validateJwt=function validateJwt(e,t,r,o,s,a,u){i.Log.debug(\"JoseUtil.validateJwt\");try{if(\"RSA\"===t.kty)if(t.e&&t.n)t=n.KEYUTIL.getKey(t);else{if(!t.x5c||!t.x5c.length)return i.Log.error(\"JoseUtil.validateJwt: RSA key missing key material\",t),Promise.reject(new Error(\"RSA key missing key material\"));var c=(0,n.b64tohex)(t.x5c[0]);t=n.X509.getPublicKeyFromCertHex(c)}else{if(\"EC\"!==t.kty)return i.Log.error(\"JoseUtil.validateJwt: Unsupported key type\",t&&t.kty),Promise.reject(new Error(t.kty));if(!(t.crv&&t.x&&t.y))return i.Log.error(\"JoseUtil.validateJwt: EC key missing key material\",t),Promise.reject(new Error(\"EC key missing key material\"));t=n.KEYUTIL.getKey(t)}return JoseUtil._validateJwt(e,t,r,o,s,a,u)}catch(e){return i.Log.error(e&&e.message||e),Promise.reject(\"JWT validation failed\")}},JoseUtil.validateJwtAttributes=function validateJwtAttributes(e,t,r,n,o,s){n||(n=0),o||(o=parseInt(Date.now()/1e3));var a=JoseUtil.parseJwt(e).payload;if(!a.iss)return i.Log.error(\"JoseUtil._validateJwt: issuer was not provided\"),Promise.reject(new Error(\"issuer was not provided\"));if(a.iss!==t)return i.Log.error(\"JoseUtil._validateJwt: Invalid issuer in token\",a.iss),Promise.reject(new Error(\"Invalid issuer in token: \"+a.iss));if(!a.aud)return i.Log.error(\"JoseUtil._validateJwt: aud was not provided\"),Promise.reject(new Error(\"aud was not provided\"));if(!(a.aud===r||Array.isArray(a.aud)&&a.aud.indexOf(r)>=0))return i.Log.error(\"JoseUtil._validateJwt: Invalid audience in token\",a.aud),Promise.reject(new Error(\"Invalid audience in token: \"+a.aud));if(a.azp&&a.azp!==r)return i.Log.error(\"JoseUtil._validateJwt: Invalid azp in token\",a.azp),Promise.reject(new Error(\"Invalid azp in token: \"+a.azp));if(!s){var u=o+n,c=o-n;if(!a.iat)return i.Log.error(\"JoseUtil._validateJwt: iat was not provided\"),Promise.reject(new Error(\"iat was not provided\"));if(u<a.iat)return i.Log.error(\"JoseUtil._validateJwt: iat is in the future\",a.iat),Promise.reject(new Error(\"iat is in the future: \"+a.iat));if(a.nbf&&u<a.nbf)return i.Log.error(\"JoseUtil._validateJwt: nbf is in the future\",a.nbf),Promise.reject(new Error(\"nbf is in the future: \"+a.nbf));if(!a.exp)return i.Log.error(\"JoseUtil._validateJwt: exp was not provided\"),Promise.reject(new Error(\"exp was not provided\"));if(a.exp<c)return i.Log.error(\"JoseUtil._validateJwt: exp is in the past\",a.exp),Promise.reject(new Error(\"exp is in the past:\"+a.exp))}return Promise.resolve(a)},JoseUtil._validateJwt=function _validateJwt(e,t,r,s,a,u,c){return JoseUtil.validateJwtAttributes(e,r,s,a,u,c).then(function(r){try{return n.jws.JWS.verify(e,t,o)?r:(i.Log.error(\"JoseUtil._validateJwt: signature validation failed\"),Promise.reject(new Error(\"signature validation failed\")))}catch(e){return i.Log.error(e&&e.message||e),Promise.reject(new Error(\"signature validation failed\"))}})},JoseUtil.hashString=function hashString(e,t){try{return n.crypto.Util.hashString(e,t)}catch(e){i.Log.error(e)}},JoseUtil.hexToBase64Url=function hexToBase64Url(e){try{return(0,n.hextob64u)(e)}catch(e){i.Log.error(e)}},JoseUtil}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.OidcClientSettings=void 0;var n=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},i=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),o=r(0),s=r(6),a=r(23),u=r(2);var c=\"id_token\",h=\"openid\",l=900,f=300;t.OidcClientSettings=function(){function OidcClientSettings(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.authority,r=e.metadataUrl,i=e.metadata,o=e.signingKeys,g=e.client_id,p=e.client_secret,d=e.response_type,v=void 0===d?c:d,y=e.scope,m=void 0===y?h:y,_=e.redirect_uri,S=e.post_logout_redirect_uri,b=e.prompt,F=e.display,w=e.max_age,E=e.ui_locales,x=e.acr_values,C=e.resource,k=e.response_mode,A=e.filterProtocolClaims,P=void 0===A||A,I=e.loadUserInfo,B=void 0===I||I,R=e.staleStateAge,T=void 0===R?l:R,U=e.clockSkew,D=void 0===U?f:U,L=e.userInfoJwtIssuer,M=void 0===L?\"OP\":L,N=e.stateStore,O=void 0===N?new s.WebStorageStateStore:N,H=e.ResponseValidatorCtor,j=void 0===H?a.ResponseValidator:H,K=e.MetadataServiceCtor,V=void 0===K?u.MetadataService:K,q=e.extraQueryParams,W=void 0===q?{}:q;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,OidcClientSettings),this._authority=t,this._metadataUrl=r,this._metadata=i,this._signingKeys=o,this._client_id=g,this._client_secret=p,this._response_type=v,this._scope=m,this._redirect_uri=_,this._post_logout_redirect_uri=S,this._prompt=b,this._display=F,this._max_age=w,this._ui_locales=E,this._acr_values=x,this._resource=C,this._response_mode=k,this._filterProtocolClaims=!!P,this._loadUserInfo=!!B,this._staleStateAge=T,this._clockSkew=D,this._userInfoJwtIssuer=M,this._stateStore=O,this._validator=new j(this),this._metadataService=new V(this),this._extraQueryParams=\"object\"===(void 0===W?\"undefined\":n(W))?W:{}}return i(OidcClientSettings,[{key:\"client_id\",get:function get(){return this._client_id},set:function set(e){if(this._client_id)throw o.Log.error(\"OidcClientSettings.set_client_id: client_id has already been assigned.\"),new Error(\"client_id has already been assigned.\");this._client_id=e}},{key:\"client_secret\",get:function get(){return this._client_secret}},{key:\"response_type\",get:function get(){return this._response_type}},{key:\"scope\",get:function get(){return this._scope}},{key:\"redirect_uri\",get:function get(){return this._redirect_uri}},{key:\"post_logout_redirect_uri\",get:function get(){return this._post_logout_redirect_uri}},{key:\"prompt\",get:function get(){return this._prompt}},{key:\"display\",get:function get(){return this._display}},{key:\"max_age\",get:function get(){return this._max_age}},{key:\"ui_locales\",get:function get(){return this._ui_locales}},{key:\"acr_values\",get:function get(){return this._acr_values}},{key:\"resource\",get:function get(){return this._resource}},{key:\"response_mode\",get:function get(){return this._response_mode}},{key:\"authority\",get:function get(){return this._authority},set:function set(e){if(this._authority)throw o.Log.error(\"OidcClientSettings.set_authority: authority has already been assigned.\"),new Error(\"authority has already been assigned.\");this._authority=e}},{key:\"metadataUrl\",get:function get(){return this._metadataUrl||(this._metadataUrl=this.authority,this._metadataUrl&&this._metadataUrl.indexOf(\".well-known/openid-configuration\")<0&&(\"/\"!==this._metadataUrl[this._metadataUrl.length-1]&&(this._metadataUrl+=\"/\"),this._metadataUrl+=\".well-known/openid-configuration\")),this._metadataUrl}},{key:\"metadata\",get:function get(){return this._metadata},set:function set(e){this._metadata=e}},{key:\"signingKeys\",get:function get(){return this._signingKeys},set:function set(e){this._signingKeys=e}},{key:\"filterProtocolClaims\",get:function get(){return this._filterProtocolClaims}},{key:\"loadUserInfo\",get:function get(){return this._loadUserInfo}},{key:\"staleStateAge\",get:function get(){return this._staleStateAge}},{key:\"clockSkew\",get:function get(){return this._clockSkew}},{key:\"userInfoJwtIssuer\",get:function get(){return this._userInfoJwtIssuer}},{key:\"stateStore\",get:function get(){return this._stateStore}},{key:\"validator\",get:function get(){return this._validator}},{key:\"metadataService\",get:function get(){return this._metadataService}},{key:\"extraQueryParams\",get:function get(){return this._extraQueryParams},set:function set(e){\"object\"===(void 0===e?\"undefined\":n(e))?this._extraQueryParams=e:this._extraQueryParams={}}}]),OidcClientSettings}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.WebStorageStateStore=void 0;var n=r(0),i=r(1);t.WebStorageStateStore=function(){function WebStorageStateStore(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.prefix,r=void 0===t?\"oidc.\":t,n=e.store,o=void 0===n?i.Global.localStorage:n;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,WebStorageStateStore),this._store=o,this._prefix=r}return WebStorageStateStore.prototype.set=function set(e,t){return n.Log.debug(\"WebStorageStateStore.set\",e),e=this._prefix+e,this._store.setItem(e,t),Promise.resolve()},WebStorageStateStore.prototype.get=function get(e){n.Log.debug(\"WebStorageStateStore.get\",e),e=this._prefix+e;var t=this._store.getItem(e);return Promise.resolve(t)},WebStorageStateStore.prototype.remove=function remove(e){n.Log.debug(\"WebStorageStateStore.remove\",e),e=this._prefix+e;var t=this._store.getItem(e);return this._store.removeItem(e),Promise.resolve(t)},WebStorageStateStore.prototype.getAllKeys=function getAllKeys(){n.Log.debug(\"WebStorageStateStore.getAllKeys\");for(var e=[],t=0;t<this._store.length;t++){var r=this._store.key(t);0===r.indexOf(this._prefix)&&e.push(r.substr(this._prefix.length))}return Promise.resolve(e)},WebStorageStateStore}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.JsonService=void 0;var n=r(0),i=r(1);t.JsonService=function(){function JsonService(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:i.Global.XMLHttpRequest,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,JsonService),e&&Array.isArray(e)?this._contentTypes=e.slice():this._contentTypes=[],this._contentTypes.push(\"application/json\"),r&&this._contentTypes.push(\"application/jwt\"),this._XMLHttpRequest=t,this._jwtHandler=r}return JsonService.prototype.getJson=function getJson(e,t){var r=this;if(!e)throw n.Log.error(\"JsonService.getJson: No url passed\"),new Error(\"url\");return n.Log.debug(\"JsonService.getJson, url: \",e),new Promise(function(i,o){var s=new r._XMLHttpRequest;s.open(\"GET\",e);var a=r._contentTypes,u=r._jwtHandler;s.onload=function(){if(n.Log.debug(\"JsonService.getJson: HTTP response received, status\",s.status),200===s.status){var t=s.getResponseHeader(\"Content-Type\");if(t){var r=a.find(function(e){if(t.startsWith(e))return!0});if(\"application/jwt\"==r)return void u(s).then(i,o);if(r)try{return void i(JSON.parse(s.responseText))}catch(e){return n.Log.error(\"JsonService.getJson: Error parsing JSON response\",e.message),void o(e)}}o(Error(\"Invalid response Content-Type: \"+t+\", from URL: \"+e))}else o(Error(s.statusText+\" (\"+s.status+\")\"))},s.onerror=function(){n.Log.error(\"JsonService.getJson: network error\"),o(Error(\"Network Error\"))},t&&(n.Log.debug(\"JsonService.getJson: token passed, setting Authorization header\"),s.setRequestHeader(\"Authorization\",\"Bearer \"+t)),s.send()})},JsonService.prototype.postForm=function postForm(e,t){var r=this;if(!e)throw n.Log.error(\"JsonService.postForm: No url passed\"),new Error(\"url\");return n.Log.debug(\"JsonService.postForm, url: \",e),new Promise(function(i,o){var s=new r._XMLHttpRequest;s.open(\"POST\",e);var a=r._contentTypes;s.onload=function(){if(n.Log.debug(\"JsonService.postForm: HTTP response received, status\",s.status),200!==s.status){if(400===s.status)if(r=s.getResponseHeader(\"Content-Type\"))if(a.find(function(e){if(r.startsWith(e))return!0}))try{var t=JSON.parse(s.responseText);if(t&&t.error)return n.Log.error(\"JsonService.postForm: Error from server: \",t.error),void o(new Error(t.error))}catch(e){return n.Log.error(\"JsonService.postForm: Error parsing JSON response\",e.message),void o(e)}o(Error(s.statusText+\" (\"+s.status+\")\"))}else{var r;if((r=s.getResponseHeader(\"Content-Type\"))&&a.find(function(e){if(r.startsWith(e))return!0}))try{return void i(JSON.parse(s.responseText))}catch(e){return n.Log.error(\"JsonService.postForm: Error parsing JSON response\",e.message),void o(e)}o(Error(\"Invalid response Content-Type: \"+r+\", from URL: \"+e))}},s.onerror=function(){n.Log.error(\"JsonService.postForm: network error\"),o(Error(\"Network Error\"))};var u=\"\";for(var c in t){var h=t[c];h&&(u.length>0&&(u+=\"&\"),u+=encodeURIComponent(c),u+=\"=\",u+=encodeURIComponent(h))}s.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"),s.send(u)})},JsonService}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.State=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}(r(14));t.State=function(){function State(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.id,r=e.data,n=e.created;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,State),this._id=t||(0,o.default)(),this._data=r,this._created=\"number\"==typeof n&&n>0?n:parseInt(Date.now()/1e3)}return State.prototype.toStorageString=function toStorageString(){return i.Log.debug(\"State.toStorageString\"),JSON.stringify({id:this.id,data:this.data,created:this.created})},State.fromStorageString=function fromStorageString(e){return i.Log.debug(\"State.fromStorageString\"),new State(JSON.parse(e))},State.clearStaleState=function clearStaleState(e,t){var r=Date.now()/1e3-t;return e.getAllKeys().then(function(t){i.Log.debug(\"State.clearStaleState: got keys\",t);for(var n=[],o=function _loop(o){var s=t[o];a=e.get(s).then(function(t){var n=!1;if(t)try{var o=State.fromStorageString(t);i.Log.debug(\"State.clearStaleState: got item from key: \",s,o.created),o.created<=r&&(n=!0)}catch(e){i.Log.error(\"State.clearStaleState: Error parsing state for key\",s,e.message),n=!0}else i.Log.debug(\"State.clearStaleState: no item in storage for key: \",s),n=!0;if(n)return i.Log.debug(\"State.clearStaleState: removed item for key: \",s),e.remove(s)}),n.push(a)},s=0;s<t.length;s++){var a;o(s)}return i.Log.debug(\"State.clearStaleState: waiting on promise count:\",n.length),Promise.all(n)})},n(State,[{key:\"id\",get:function get(){return this._id}},{key:\"data\",get:function get(){return this._data}},{key:\"created\",get:function get(){return this._created}}]),State}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.OidcClient=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(5),s=r(11),a=r(12),u=r(34),c=r(35),h=r(36),l=r(13),f=r(8);t.OidcClient=function(){function OidcClient(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,OidcClient),e instanceof o.OidcClientSettings?this._settings=e:this._settings=new o.OidcClientSettings(e)}return OidcClient.prototype.createSigninRequest=function createSigninRequest(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.response_type,n=t.scope,o=t.redirect_uri,s=t.data,u=t.state,c=t.prompt,h=t.display,l=t.max_age,f=t.ui_locales,g=t.id_token_hint,p=t.login_hint,d=t.acr_values,v=t.resource,y=t.request,m=t.request_uri,_=t.response_mode,S=t.extraQueryParams,b=arguments[1];i.Log.debug(\"OidcClient.createSigninRequest\");var F=this._settings.client_id;r=r||this._settings.response_type,n=n||this._settings.scope,o=o||this._settings.redirect_uri,c=c||this._settings.prompt,h=h||this._settings.display,l=l||this._settings.max_age,f=f||this._settings.ui_locales,d=d||this._settings.acr_values,v=v||this._settings.resource,_=_||this._settings.response_mode,S=S||this._settings.extraQueryParams;var w=this._settings.authority;return a.SigninRequest.isCode(r)&&\"code\"!==r?Promise.reject(new Error(\"OpenID Connect hybrid flow is not supported\")):this._metadataService.getAuthorizationEndpoint().then(function(t){i.Log.debug(\"OidcClient.createSigninRequest: Received authorization endpoint\",t);var E=new a.SigninRequest({url:t,client_id:F,redirect_uri:o,response_type:r,scope:n,data:s||u,authority:w,prompt:c,display:h,max_age:l,ui_locales:f,id_token_hint:g,login_hint:p,acr_values:d,resource:v,request:y,request_uri:m,extraQueryParams:S,response_mode:_}),x=E.state;return(b=b||e._stateStore).set(x.id,x.toStorageString()).then(function(){return E})})},OidcClient.prototype.processSigninResponse=function processSigninResponse(e,t){var r=this;i.Log.debug(\"OidcClient.processSigninResponse\");var n=\"query\"===this._settings.response_mode||!this._settings.response_mode&&a.SigninRequest.isCode(this._settings.response_type)?\"?\":\"#\",o=new u.SigninResponse(e,n);return o.state?(t=t||this._stateStore).remove(o.state).then(function(e){if(!e)throw i.Log.error(\"OidcClient.processSigninResponse: No matching state found in storage\"),new Error(\"No matching state found in storage\");var t=l.SigninState.fromStorageString(e);return i.Log.debug(\"OidcClient.processSigninResponse: Received state from storage; validating response\"),r._validator.validateSigninResponse(t,o)}):(i.Log.error(\"OidcClient.processSigninResponse: No state in response\"),Promise.reject(new Error(\"No state in response\")))},OidcClient.prototype.createSignoutRequest=function createSignoutRequest(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.id_token_hint,n=t.data,o=t.state,s=t.post_logout_redirect_uri,a=t.extraQueryParams,u=arguments[1];return i.Log.debug(\"OidcClient.createSignoutRequest\"),s=s||this._settings.post_logout_redirect_uri,a=a||this._settings.extraQueryParams,this._metadataService.getEndSessionEndpoint().then(function(t){if(!t)throw i.Log.error(\"OidcClient.createSignoutRequest: No end session endpoint url returned\"),new Error(\"no end session endpoint\");i.Log.debug(\"OidcClient.createSignoutRequest: Received end session endpoint\",t);var h=new c.SignoutRequest({url:t,id_token_hint:r,post_logout_redirect_uri:s,data:n||o,extraQueryParams:a}),l=h.state;return l&&(i.Log.debug(\"OidcClient.createSignoutRequest: Signout request has state to persist\"),(u=u||e._stateStore).set(l.id,l.toStorageString())),h})},OidcClient.prototype.processSignoutResponse=function processSignoutResponse(e,t){var r=this;i.Log.debug(\"OidcClient.processSignoutResponse\");var n=new h.SignoutResponse(e);if(!n.state)return i.Log.debug(\"OidcClient.processSignoutResponse: No state in response\"),n.error?(i.Log.warn(\"OidcClient.processSignoutResponse: Response was error: \",n.error),Promise.reject(new s.ErrorResponse(n))):Promise.resolve(n);var o=n.state;return(t=t||this._stateStore).remove(o).then(function(e){if(!e)throw i.Log.error(\"OidcClient.processSignoutResponse: No matching state found in storage\"),new Error(\"No matching state found in storage\");var t=f.State.fromStorageString(e);return i.Log.debug(\"OidcClient.processSignoutResponse: Received state from storage; validating response\"),r._validator.validateSignoutResponse(t,n)})},OidcClient.prototype.clearStaleState=function clearStaleState(e){return i.Log.debug(\"OidcClient.clearStaleState\"),e=e||this._stateStore,f.State.clearStaleState(e,this.settings.staleStateAge)},n(OidcClient,[{key:\"_stateStore\",get:function get(){return this.settings.stateStore}},{key:\"_validator\",get:function get(){return this.settings.validator}},{key:\"_metadataService\",get:function get(){return this.settings.metadataService}},{key:\"settings\",get:function get(){return this._settings}},{key:\"metadataService\",get:function get(){return this._metadataService}}]),OidcClient}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.TokenClient=void 0;var n=r(7),i=r(2),o=r(0);t.TokenClient=function(){function TokenClient(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.JsonService,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,TokenClient),!e)throw o.Log.error(\"TokenClient.ctor: No settings passed\"),new Error(\"settings\");this._settings=e,this._jsonService=new t,this._metadataService=new r(this._settings)}return TokenClient.prototype.exchangeCode=function exchangeCode(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.grant_type=t.grant_type||\"authorization_code\",t.client_id=t.client_id||this._settings.client_id,t.redirect_uri=t.redirect_uri||this._settings.redirect_uri,t.code?t.redirect_uri?t.code_verifier?t.client_id?this._metadataService.getTokenEndpoint(!1).then(function(r){return o.Log.debug(\"TokenClient.exchangeCode: Received token endpoint\"),e._jsonService.postForm(r,t).then(function(e){return o.Log.debug(\"TokenClient.exchangeCode: response received\"),e})}):(o.Log.error(\"TokenClient.exchangeCode: No client_id passed\"),Promise.reject(new Error(\"A client_id is required\"))):(o.Log.error(\"TokenClient.exchangeCode: No code_verifier passed\"),Promise.reject(new Error(\"A code_verifier is required\"))):(o.Log.error(\"TokenClient.exchangeCode: No redirect_uri passed\"),Promise.reject(new Error(\"A redirect_uri is required\"))):(o.Log.error(\"TokenClient.exchangeCode: No code passed\"),Promise.reject(new Error(\"A code is required\")))},TokenClient.prototype.exchangeRefreshToken=function exchangeRefreshToken(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return t.grant_type=t.grant_type||\"refresh_token\",t.client_id=t.client_id||this._settings.client_id,t.refresh_token?t.client_id?this._metadataService.getTokenEndpoint(!1).then(function(r){return o.Log.debug(\"TokenClient.exchangeRefreshToken: Received token endpoint\"),e._jsonService.postForm(r,t).then(function(e){return o.Log.debug(\"TokenClient.exchangeRefreshToken: response received\"),e})}):(o.Log.error(\"TokenClient.exchangeRefreshToken: No client_id passed\"),Promise.reject(new Error(\"A client_id is required\"))):(o.Log.error(\"TokenClient.exchangeRefreshToken: No refresh_token passed\"),Promise.reject(new Error(\"A refresh_token is required\")))},TokenClient}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.ErrorResponse=void 0;var n=r(0);t.ErrorResponse=function(e){function ErrorResponse(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.error,i=t.error_description,o=t.error_uri,s=t.state;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,ErrorResponse),!r)throw n.Log.error(\"No error passed to ErrorResponse\"),new Error(\"error\");var a=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!=typeof t&&\"function\"!=typeof t?e:t}(this,e.call(this,i||r));return a.name=\"ErrorResponse\",a.error=r,a.error_description=i,a.error_uri=o,a.state=s,a}return function _inherits(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(ErrorResponse,e),ErrorResponse}(Error)},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.SigninRequest=void 0;var n=r(0),i=r(3),o=r(13);t.SigninRequest=function(){function SigninRequest(e){var t=e.url,r=e.client_id,s=e.redirect_uri,a=e.response_type,u=e.scope,c=e.authority,h=e.data,l=e.prompt,f=e.display,g=e.max_age,p=e.ui_locales,d=e.id_token_hint,v=e.login_hint,y=e.acr_values,m=e.resource,_=e.response_mode,S=e.request,b=e.request_uri,F=e.extraQueryParams;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,SigninRequest),!t)throw n.Log.error(\"SigninRequest.ctor: No url passed\"),new Error(\"url\");if(!r)throw n.Log.error(\"SigninRequest.ctor: No client_id passed\"),new Error(\"client_id\");if(!s)throw n.Log.error(\"SigninRequest.ctor: No redirect_uri passed\"),new Error(\"redirect_uri\");if(!a)throw n.Log.error(\"SigninRequest.ctor: No response_type passed\"),new Error(\"response_type\");if(!u)throw n.Log.error(\"SigninRequest.ctor: No scope passed\"),new Error(\"scope\");if(!c)throw n.Log.error(\"SigninRequest.ctor: No authority passed\"),new Error(\"authority\");var w=SigninRequest.isOidc(a),E=SigninRequest.isCode(a);this.state=new o.SigninState({nonce:w,data:h,client_id:r,authority:c,redirect_uri:s,code_verifier:E}),t=i.UrlUtility.addQueryParam(t,\"client_id\",r),t=i.UrlUtility.addQueryParam(t,\"redirect_uri\",s),t=i.UrlUtility.addQueryParam(t,\"response_type\",a),t=i.UrlUtility.addQueryParam(t,\"scope\",u),t=i.UrlUtility.addQueryParam(t,\"state\",this.state.id),w&&(t=i.UrlUtility.addQueryParam(t,\"nonce\",this.state.nonce)),E&&(t=i.UrlUtility.addQueryParam(t,\"code_challenge\",this.state.code_challenge),t=i.UrlUtility.addQueryParam(t,\"code_challenge_method\",\"S256\"));var x={prompt:l,display:f,max_age:g,ui_locales:p,id_token_hint:d,login_hint:v,acr_values:y,resource:m,request:S,request_uri:b,response_mode:_};for(var C in x)x[C]&&(t=i.UrlUtility.addQueryParam(t,C,x[C]));for(var k in F)t=i.UrlUtility.addQueryParam(t,k,F[k]);this.url=t}return SigninRequest.isOidc=function isOidc(e){return!!e.split(/\\s+/g).filter(function(e){return\"id_token\"===e})[0]},SigninRequest.isOAuth=function isOAuth(e){return!!e.split(/\\s+/g).filter(function(e){return\"token\"===e})[0]},SigninRequest.isCode=function isCode(e){return!!e.split(/\\s+/g).filter(function(e){return\"code\"===e})[0]},SigninRequest}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.SigninState=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(8),s=r(4),a=function _interopRequireDefault(e){return e&&e.__esModule?e:{default:e}}(r(14));t.SigninState=function(e){function SigninState(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.nonce,n=t.authority,i=t.client_id,o=t.redirect_uri,u=t.code_verifier;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,SigninState);var c=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!=typeof t&&\"function\"!=typeof t?e:t}(this,e.call(this,arguments[0]));if(!0===r?c._nonce=(0,a.default)():r&&(c._nonce=r),!0===u?c._code_verifier=(0,a.default)()+(0,a.default)()+(0,a.default)():u&&(c._code_verifier=u),c.code_verifier){var h=s.JoseUtil.hashString(c.code_verifier,\"SHA256\");c._code_challenge=s.JoseUtil.hexToBase64Url(h)}return c._redirect_uri=o,c._authority=n,c._client_id=i,c}return function _inherits(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(SigninState,e),SigninState.prototype.toStorageString=function toStorageString(){return i.Log.debug(\"SigninState.toStorageString\"),JSON.stringify({id:this.id,data:this.data,created:this.created,nonce:this.nonce,code_verifier:this.code_verifier,redirect_uri:this.redirect_uri,authority:this.authority,client_id:this.client_id})},SigninState.fromStorageString=function fromStorageString(e){return i.Log.debug(\"SigninState.fromStorageString\"),new SigninState(JSON.parse(e))},n(SigninState,[{key:\"nonce\",get:function get(){return this._nonce}},{key:\"authority\",get:function get(){return this._authority}},{key:\"client_id\",get:function get(){return this._client_id}},{key:\"redirect_uri\",get:function get(){return this._redirect_uri}},{key:\"code_verifier\",get:function get(){return this._code_verifier}},{key:\"code_challenge\",get:function get(){return this._code_challenge}}]),SigninState}(o.State)},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.default=function random(){return n().replace(/-/g,\"\")};var n=r(31);e.exports=t.default},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.User=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);t.User=function(){function User(e){var t=e.id_token,r=e.session_state,n=e.access_token,i=e.refresh_token,o=e.token_type,s=e.scope,a=e.profile,u=e.expires_at,c=e.state;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,User),this.id_token=t,this.session_state=r,this.access_token=n,this.refresh_token=i,this.token_type=o,this.scope=s,this.profile=a,this.expires_at=u,this.state=c}return User.prototype.toStorageString=function toStorageString(){return i.Log.debug(\"User.toStorageString\"),JSON.stringify({id_token:this.id_token,session_state:this.session_state,access_token:this.access_token,refresh_token:this.refresh_token,token_type:this.token_type,scope:this.scope,profile:this.profile,expires_at:this.expires_at})},User.fromStorageString=function fromStorageString(e){return i.Log.debug(\"User.fromStorageString\"),new User(JSON.parse(e))},n(User,[{key:\"expires_in\",get:function get(){if(this.expires_at){var e=parseInt(Date.now()/1e3);return this.expires_at-e}},set:function set(e){var t=parseInt(e);if(\"number\"==typeof t&&t>0){var r=parseInt(Date.now()/1e3);this.expires_at=r+t}}},{key:\"expired\",get:function get(){var e=this.expires_in;if(void 0!==e)return e<=0}},{key:\"scopes\",get:function get(){return(this.scope||\"\").split(\" \")}}]),User}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.AccessTokenEvents=void 0;var n=r(0),i=r(46);var o=60;t.AccessTokenEvents=function(){function AccessTokenEvents(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.accessTokenExpiringNotificationTime,r=void 0===t?o:t,n=e.accessTokenExpiringTimer,s=void 0===n?new i.Timer(\"Access token expiring\"):n,a=e.accessTokenExpiredTimer,u=void 0===a?new i.Timer(\"Access token expired\"):a;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,AccessTokenEvents),this._accessTokenExpiringNotificationTime=r,this._accessTokenExpiring=s,this._accessTokenExpired=u}return AccessTokenEvents.prototype.load=function load(e){if(e.access_token&&void 0!==e.expires_in){var t=e.expires_in;if(n.Log.debug(\"AccessTokenEvents.load: access token present, remaining duration:\",t),t>0){var r=t-this._accessTokenExpiringNotificationTime;r<=0&&(r=1),n.Log.debug(\"AccessTokenEvents.load: registering expiring timer in:\",r),this._accessTokenExpiring.init(r)}else n.Log.debug(\"AccessTokenEvents.load: canceling existing expiring timer becase we're past expiration.\"),this._accessTokenExpiring.cancel();var i=t+1;n.Log.debug(\"AccessTokenEvents.load: registering expired timer in:\",i),this._accessTokenExpired.init(i)}else this._accessTokenExpiring.cancel(),this._accessTokenExpired.cancel()},AccessTokenEvents.prototype.unload=function unload(){n.Log.debug(\"AccessTokenEvents.unload: canceling existing access token timers\"),this._accessTokenExpiring.cancel(),this._accessTokenExpired.cancel()},AccessTokenEvents.prototype.addAccessTokenExpiring=function addAccessTokenExpiring(e){this._accessTokenExpiring.addHandler(e)},AccessTokenEvents.prototype.removeAccessTokenExpiring=function removeAccessTokenExpiring(e){this._accessTokenExpiring.removeHandler(e)},AccessTokenEvents.prototype.addAccessTokenExpired=function addAccessTokenExpired(e){this._accessTokenExpired.addHandler(e)},AccessTokenEvents.prototype.removeAccessTokenExpired=function removeAccessTokenExpired(e){this._accessTokenExpired.removeHandler(e)},AccessTokenEvents}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.Event=void 0;var n=r(0);t.Event=function(){function Event(e){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,Event),this._name=e,this._callbacks=[]}return Event.prototype.addHandler=function addHandler(e){this._callbacks.push(e)},Event.prototype.removeHandler=function removeHandler(e){var t=this._callbacks.findIndex(function(t){return t===e});t>=0&&this._callbacks.splice(t,1)},Event.prototype.raise=function raise(){n.Log.debug(\"Event: Raising event: \"+this._name);for(var e=0;e<this._callbacks.length;e++){var t;(t=this._callbacks)[e].apply(t,arguments)}},Event}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.SessionMonitor=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(19);t.SessionMonitor=function(){function SessionMonitor(e){var t=this,r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.CheckSessionIFrame;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,SessionMonitor),!e)throw i.Log.error(\"SessionMonitor.ctor: No user manager passed to SessionMonitor\"),new Error(\"userManager\");this._userManager=e,this._CheckSessionIFrameCtor=r,this._userManager.events.addUserLoaded(this._start.bind(this)),this._userManager.events.addUserUnloaded(this._stop.bind(this)),this._userManager.getUser().then(function(e){e&&t._start(e)}).catch(function(e){i.Log.error(\"SessionMonitor ctor: error from getUser:\",e.message)})}return SessionMonitor.prototype._start=function _start(e){var t=this,r=e.session_state;r&&(this._sub=e.profile.sub,this._sid=e.profile.sid,i.Log.debug(\"SessionMonitor._start: session_state:\",r,\", sub:\",this._sub),this._checkSessionIFrame?this._checkSessionIFrame.start(r):this._metadataService.getCheckSessionIframe().then(function(e){if(e){i.Log.debug(\"SessionMonitor._start: Initializing check session iframe\");var n=t._client_id,o=t._checkSessionInterval,s=t._stopCheckSessionOnError;t._checkSessionIFrame=new t._CheckSessionIFrameCtor(t._callback.bind(t),n,e,o,s),t._checkSessionIFrame.load().then(function(){t._checkSessionIFrame.start(r)})}else i.Log.warn(\"SessionMonitor._start: No check session iframe found in the metadata\")}).catch(function(e){i.Log.error(\"SessionMonitor._start: Error from getCheckSessionIframe:\",e.message)}))},SessionMonitor.prototype._stop=function _stop(){this._sub=null,this._sid=null,this._checkSessionIFrame&&(i.Log.debug(\"SessionMonitor._stop\"),this._checkSessionIFrame.stop())},SessionMonitor.prototype._callback=function _callback(){var e=this;this._userManager.querySessionStatus().then(function(t){var r=!0;t?t.sub===e._sub?(r=!1,e._checkSessionIFrame.start(t.session_state),t.sid===e._sid?i.Log.debug(\"SessionMonitor._callback: Same sub still logged in at OP, restarting check session iframe; session_state:\",t.session_state):(i.Log.debug(\"SessionMonitor._callback: Same sub still logged in at OP, session state has changed, restarting check session iframe; session_state:\",t.session_state),e._userManager.events._raiseUserSessionChanged())):i.Log.debug(\"SessionMonitor._callback: Different subject signed into OP:\",t.sub):i.Log.debug(\"SessionMonitor._callback: Subject no longer signed into OP\"),r&&(i.Log.debug(\"SessionMonitor._callback: SessionMonitor._callback; raising signed out event\"),e._userManager.events._raiseUserSignedOut())}).catch(function(t){i.Log.debug(\"SessionMonitor._callback: Error calling queryCurrentSigninSession; raising signed out event\",t.message),e._userManager.events._raiseUserSignedOut()})},n(SessionMonitor,[{key:\"_settings\",get:function get(){return this._userManager.settings}},{key:\"_metadataService\",get:function get(){return this._userManager.metadataService}},{key:\"_client_id\",get:function get(){return this._settings.client_id}},{key:\"_checkSessionInterval\",get:function get(){return this._settings.checkSessionInterval}},{key:\"_stopCheckSessionOnError\",get:function get(){return this._settings.stopCheckSessionOnError}}]),SessionMonitor}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.CheckSessionIFrame=void 0;var n=r(0);var i=2e3;t.CheckSessionIFrame=function(){function CheckSessionIFrame(e,t,r,n){var o=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,CheckSessionIFrame),this._callback=e,this._client_id=t,this._url=r,this._interval=n||i,this._stopOnError=o;var s=r.indexOf(\"/\",r.indexOf(\"//\")+2);this._frame_origin=r.substr(0,s),this._frame=window.document.createElement(\"iframe\"),this._frame.style.visibility=\"hidden\",this._frame.style.position=\"absolute\",this._frame.style.display=\"none\",this._frame.style.width=0,this._frame.style.height=0,this._frame.src=r}return CheckSessionIFrame.prototype.load=function load(){var e=this;return new Promise(function(t){e._frame.onload=function(){t()},window.document.body.appendChild(e._frame),e._boundMessageEvent=e._message.bind(e),window.addEventListener(\"message\",e._boundMessageEvent,!1)})},CheckSessionIFrame.prototype._message=function _message(e){e.origin===this._frame_origin&&e.source===this._frame.contentWindow&&(\"error\"===e.data?(n.Log.error(\"CheckSessionIFrame: error message from check session op iframe\"),this._stopOnError&&this.stop()):\"changed\"===e.data?(n.Log.debug(\"CheckSessionIFrame: changed message from check session op iframe\"),this.stop(),this._callback()):n.Log.debug(\"CheckSessionIFrame: \"+e.data+\" message from check session op iframe\"))},CheckSessionIFrame.prototype.start=function start(e){var t=this;if(this._session_state!==e){n.Log.debug(\"CheckSessionIFrame.start\"),this.stop(),this._session_state=e;var r=function send(){t._frame.contentWindow.postMessage(t._client_id+\" \"+t._session_state,t._frame_origin)};r(),this._timer=window.setInterval(r,this._interval)}},CheckSessionIFrame.prototype.stop=function stop(){this._session_state=null,this._timer&&(n.Log.debug(\"CheckSessionIFrame.stop\"),window.clearInterval(this._timer),this._timer=null)},CheckSessionIFrame}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.TokenRevocationClient=void 0;var n=r(0),i=r(2),o=r(1);t.TokenRevocationClient=function(){function TokenRevocationClient(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.Global.XMLHttpRequest,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,TokenRevocationClient),!e)throw n.Log.error(\"TokenRevocationClient.ctor: No settings provided\"),new Error(\"No settings provided.\");this._settings=e,this._XMLHttpRequestCtor=t,this._metadataService=new r(this._settings)}return TokenRevocationClient.prototype.revoke=function revoke(e,t){var r=this,i=arguments.length>2&&void 0!==arguments[2]?arguments[2]:\"access_token\";if(!e)throw n.Log.error(\"TokenRevocationClient.revoke: No token provided\"),new Error(\"No token provided.\");if(\"access_token\"!==i&&\"refresh_token\"!=i)throw n.Log.error(\"TokenRevocationClient.revoke: Invalid token type\"),new Error(\"Invalid token type.\");return this._metadataService.getRevocationEndpoint().then(function(o){if(o){n.Log.debug(\"TokenRevocationClient.revoke: Revoking \"+i);var s=r._settings.client_id,a=r._settings.client_secret;return r._revoke(o,s,a,e,i)}if(t)throw n.Log.error(\"TokenRevocationClient.revoke: Revocation not supported\"),new Error(\"Revocation not supported\")})},TokenRevocationClient.prototype._revoke=function _revoke(e,t,r,i,o){var s=this;return new Promise(function(a,u){var c=new s._XMLHttpRequestCtor;c.open(\"POST\",e),c.onload=function(){n.Log.debug(\"TokenRevocationClient.revoke: HTTP response received, status\",c.status),200===c.status?a():u(Error(c.statusText+\" (\"+c.status+\")\"))},c.onerror=function(){n.Log.debug(\"TokenRevocationClient.revoke: Network Error.\"),u(\"Network Error\")};var h=\"client_id=\"+encodeURIComponent(t);r&&(h+=\"&client_secret=\"+encodeURIComponent(r)),h+=\"&token_type_hint=\"+encodeURIComponent(o),h+=\"&token=\"+encodeURIComponent(i),c.setRequestHeader(\"Content-Type\",\"application/x-www-form-urlencoded\"),c.send(h)})},TokenRevocationClient}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.CordovaPopupWindow=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);var o=\"location=no,toolbar=no,zoom=no\",s=\"_blank\";t.CordovaPopupWindow=function(){function CordovaPopupWindow(e){var t=this;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,CordovaPopupWindow),this._promise=new Promise(function(e,r){t._resolve=e,t._reject=r}),this.features=e.popupWindowFeatures||o,this.target=e.popupWindowTarget||s,this.redirect_uri=e.startUrl,i.Log.debug(\"CordovaPopupWindow.ctor: redirect_uri: \"+this.redirect_uri)}return CordovaPopupWindow.prototype._isInAppBrowserInstalled=function _isInAppBrowserInstalled(e){return[\"cordova-plugin-inappbrowser\",\"cordova-plugin-inappbrowser.inappbrowser\",\"org.apache.cordova.inappbrowser\"].some(function(t){return e.hasOwnProperty(t)})},CordovaPopupWindow.prototype.navigate=function navigate(e){if(e&&e.url){if(!window.cordova)return this._error(\"cordova is undefined\");var t=window.cordova.require(\"cordova/plugin_list\").metadata;if(!1===this._isInAppBrowserInstalled(t))return this._error(\"InAppBrowser plugin not found\");this._popup=cordova.InAppBrowser.open(e.url,this.target,this.features),this._popup?(i.Log.debug(\"CordovaPopupWindow.navigate: popup successfully created\"),this._exitCallbackEvent=this._exitCallback.bind(this),this._loadStartCallbackEvent=this._loadStartCallback.bind(this),this._popup.addEventListener(\"exit\",this._exitCallbackEvent,!1),this._popup.addEventListener(\"loadstart\",this._loadStartCallbackEvent,!1)):this._error(\"Error opening popup window\")}else this._error(\"No url provided\");return this.promise},CordovaPopupWindow.prototype._loadStartCallback=function _loadStartCallback(e){0===e.url.indexOf(this.redirect_uri)&&this._success({url:e.url})},CordovaPopupWindow.prototype._exitCallback=function _exitCallback(e){this._error(e)},CordovaPopupWindow.prototype._success=function _success(e){this._cleanup(),i.Log.debug(\"CordovaPopupWindow: Successful response from cordova popup window\"),this._resolve(e)},CordovaPopupWindow.prototype._error=function _error(e){this._cleanup(),i.Log.error(e),this._reject(new Error(e))},CordovaPopupWindow.prototype.close=function close(){this._cleanup()},CordovaPopupWindow.prototype._cleanup=function _cleanup(){this._popup&&(i.Log.debug(\"CordovaPopupWindow: cleaning up popup\"),this._popup.removeEventListener(\"exit\",this._exitCallbackEvent,!1),this._popup.removeEventListener(\"loadstart\",this._loadStartCallbackEvent,!1),this._popup.close()),this._popup=null},n(CordovaPopupWindow,[{key:\"promise\",get:function get(){return this._promise}}]),CordovaPopupWindow}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0});var n=r(0),i=r(9),o=r(5),s=r(6),a=r(37),u=r(38),c=r(16),h=r(2),l=r(48),f=r(49),g=r(19),p=r(20),d=r(18),v=r(1),y=r(15);t.default={Log:n.Log,OidcClient:i.OidcClient,OidcClientSettings:o.OidcClientSettings,WebStorageStateStore:s.WebStorageStateStore,InMemoryWebStorage:a.InMemoryWebStorage,UserManager:u.UserManager,AccessTokenEvents:c.AccessTokenEvents,MetadataService:h.MetadataService,CordovaPopupNavigator:l.CordovaPopupNavigator,CordovaIFrameNavigator:f.CordovaIFrameNavigator,CheckSessionIFrame:g.CheckSessionIFrame,TokenRevocationClient:p.TokenRevocationClient,SessionMonitor:d.SessionMonitor,Global:v.Global,User:y.User},e.exports=t.default},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.ResponseValidator=void 0;var n=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},i=r(0),o=r(2),s=r(24),a=r(10),u=r(11),c=r(4);var h=[\"nonce\",\"at_hash\",\"iat\",\"nbf\",\"exp\",\"aud\",\"iss\",\"c_hash\"];t.ResponseValidator=function(){function ResponseValidator(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.MetadataService,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:s.UserInfoService,n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:c.JoseUtil,u=arguments.length>4&&void 0!==arguments[4]?arguments[4]:a.TokenClient;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,ResponseValidator),!e)throw i.Log.error(\"ResponseValidator.ctor: No settings passed to ResponseValidator\"),new Error(\"settings\");this._settings=e,this._metadataService=new t(this._settings),this._userInfoService=new r(this._settings),this._joseUtil=n,this._tokenClient=new u(this._settings)}return ResponseValidator.prototype.validateSigninResponse=function validateSigninResponse(e,t){var r=this;return i.Log.debug(\"ResponseValidator.validateSigninResponse\"),this._processSigninParams(e,t).then(function(t){return i.Log.debug(\"ResponseValidator.validateSigninResponse: state processed\"),r._validateTokens(e,t).then(function(e){return i.Log.debug(\"ResponseValidator.validateSigninResponse: tokens validated\"),r._processClaims(e).then(function(e){return i.Log.debug(\"ResponseValidator.validateSigninResponse: claims processed\"),e})})})},ResponseValidator.prototype.validateSignoutResponse=function validateSignoutResponse(e,t){return e.id!==t.state?(i.Log.error(\"ResponseValidator.validateSignoutResponse: State does not match\"),Promise.reject(new Error(\"State does not match\"))):(i.Log.debug(\"ResponseValidator.validateSignoutResponse: state validated\"),t.state=e.data,t.error?(i.Log.warn(\"ResponseValidator.validateSignoutResponse: Response was error\",t.error),Promise.reject(new u.ErrorResponse(t))):Promise.resolve(t))},ResponseValidator.prototype._processSigninParams=function _processSigninParams(e,t){if(e.id!==t.state)return i.Log.error(\"ResponseValidator._processSigninParams: State does not match\"),Promise.reject(new Error(\"State does not match\"));if(!e.client_id)return i.Log.error(\"ResponseValidator._processSigninParams: No client_id on state\"),Promise.reject(new Error(\"No client_id on state\"));if(!e.authority)return i.Log.error(\"ResponseValidator._processSigninParams: No authority on state\"),Promise.reject(new Error(\"No authority on state\"));if(this._settings.authority){if(this._settings.authority&&this._settings.authority!==e.authority)return i.Log.error(\"ResponseValidator._processSigninParams: authority mismatch on settings vs. signin state\"),Promise.reject(new Error(\"authority mismatch on settings vs. signin state\"))}else this._settings.authority=e.authority;if(this._settings.client_id){if(this._settings.client_id&&this._settings.client_id!==e.client_id)return i.Log.error(\"ResponseValidator._processSigninParams: client_id mismatch on settings vs. signin state\"),Promise.reject(new Error(\"client_id mismatch on settings vs. signin state\"))}else this._settings.client_id=e.client_id;return i.Log.debug(\"ResponseValidator._processSigninParams: state validated\"),t.state=e.data,t.error?(i.Log.warn(\"ResponseValidator._processSigninParams: Response was error\",t.error),Promise.reject(new u.ErrorResponse(t))):e.nonce&&!t.id_token?(i.Log.error(\"ResponseValidator._processSigninParams: Expecting id_token in response\"),Promise.reject(new Error(\"No id_token in response\"))):!e.nonce&&t.id_token?(i.Log.error(\"ResponseValidator._processSigninParams: Not expecting id_token in response\"),Promise.reject(new Error(\"Unexpected id_token in response\"))):e.code_verifier&&!t.code?(i.Log.error(\"ResponseValidator._processSigninParams: Expecting code in response\"),Promise.reject(new Error(\"No code in response\"))):!e.code_verifier&&t.code?(i.Log.error(\"ResponseValidator._processSigninParams: Not expecting code in response\"),Promise.reject(new Error(\"Unexpected code in response\"))):Promise.resolve(t)},ResponseValidator.prototype._processClaims=function _processClaims(e){var t=this;if(e.isOpenIdConnect){if(i.Log.debug(\"ResponseValidator._processClaims: response is OIDC, processing claims\"),e.profile=this._filterProtocolClaims(e.profile),this._settings.loadUserInfo&&e.access_token)return i.Log.debug(\"ResponseValidator._processClaims: loading user info\"),this._userInfoService.getClaims(e.access_token).then(function(r){return i.Log.debug(\"ResponseValidator._processClaims: user info claims received from user info endpoint\"),r.sub!==e.profile.sub?(i.Log.error(\"ResponseValidator._processClaims: sub from user info endpoint does not match sub in access_token\"),Promise.reject(new Error(\"sub from user info endpoint does not match sub in access_token\"))):(e.profile=t._mergeClaims(e.profile,r),i.Log.debug(\"ResponseValidator._processClaims: user info claims received, updated profile:\",e.profile),e)});i.Log.debug(\"ResponseValidator._processClaims: not loading user info\")}else i.Log.debug(\"ResponseValidator._processClaims: response is not OIDC, not processing claims\");return Promise.resolve(e)},ResponseValidator.prototype._mergeClaims=function _mergeClaims(e,t){var r=Object.assign({},e);for(var i in t){var o=t[i];Array.isArray(o)||(o=[o]);for(var s=0;s<o.length;s++){var a=o[s];r[i]?Array.isArray(r[i])?r[i].indexOf(a)<0&&r[i].push(a):r[i]!==a&&(\"object\"===(void 0===a?\"undefined\":n(a))?r[i]=this._mergeClaims(r[i],a):r[i]=[r[i],a]):r[i]=a}}return r},ResponseValidator.prototype._filterProtocolClaims=function _filterProtocolClaims(e){i.Log.debug(\"ResponseValidator._filterProtocolClaims, incoming claims:\",e);var t=Object.assign({},e);return this._settings._filterProtocolClaims?(h.forEach(function(e){delete t[e]}),i.Log.debug(\"ResponseValidator._filterProtocolClaims: protocol claims filtered\",t)):i.Log.debug(\"ResponseValidator._filterProtocolClaims: protocol claims not filtered\"),t},ResponseValidator.prototype._validateTokens=function _validateTokens(e,t){return t.code?(i.Log.debug(\"ResponseValidator._validateTokens: Validating code\"),this._processCode(e,t)):t.id_token?t.access_token?(i.Log.debug(\"ResponseValidator._validateTokens: Validating id_token and access_token\"),this._validateIdTokenAndAccessToken(e,t)):(i.Log.debug(\"ResponseValidator._validateTokens: Validating id_token\"),this._validateIdToken(e,t)):(i.Log.debug(\"ResponseValidator._validateTokens: No code to process or id_token to validate\"),Promise.resolve(t))},ResponseValidator.prototype._processCode=function _processCode(e,t){var r=this,n={client_id:e.client_id,client_secret:this._settings.client_secret,code:t.code,redirect_uri:e.redirect_uri,code_verifier:e.code_verifier};return this._tokenClient.exchangeCode(n).then(function(n){for(var o in n)t[o]=n[o];return t.id_token?(i.Log.debug(\"ResponseValidator._processCode: token response successful, processing id_token\"),r._validateIdTokenAttributes(e,t)):(i.Log.debug(\"ResponseValidator._processCode: token response successful, returning response\"),t)})},ResponseValidator.prototype._validateIdTokenAttributes=function _validateIdTokenAttributes(e,t){var r=this;return this._metadataService.getIssuer().then(function(n){var o=e.client_id,s=r._settings.clockSkew;return i.Log.debug(\"ResponseValidator._validateIdTokenAttributes: Validaing JWT attributes; using clock skew (in seconds) of: \",s),r._joseUtil.validateJwtAttributes(t.id_token,n,o,s).then(function(r){return e.nonce&&e.nonce!==r.nonce?(i.Log.error(\"ResponseValidator._validateIdTokenAttributes: Invalid nonce in id_token\"),Promise.reject(new Error(\"Invalid nonce in id_token\"))):r.sub?(t.profile=r,t):(i.Log.error(\"ResponseValidator._validateIdTokenAttributes: No sub present in id_token\"),Promise.reject(new Error(\"No sub present in id_token\")))})})},ResponseValidator.prototype._validateIdTokenAndAccessToken=function _validateIdTokenAndAccessToken(e,t){var r=this;return this._validateIdToken(e,t).then(function(e){return r._validateAccessToken(e)})},ResponseValidator.prototype._validateIdToken=function _validateIdToken(e,t){var r=this;if(!e.nonce)return i.Log.error(\"ResponseValidator._validateIdToken: No nonce on state\"),Promise.reject(new Error(\"No nonce on state\"));var n=this._joseUtil.parseJwt(t.id_token);if(!n||!n.header||!n.payload)return i.Log.error(\"ResponseValidator._validateIdToken: Failed to parse id_token\",n),Promise.reject(new Error(\"Failed to parse id_token\"));if(e.nonce!==n.payload.nonce)return i.Log.error(\"ResponseValidator._validateIdToken: Invalid nonce in id_token\"),Promise.reject(new Error(\"Invalid nonce in id_token\"));var o=n.header.kid;return this._metadataService.getIssuer().then(function(s){return i.Log.debug(\"ResponseValidator._validateIdToken: Received issuer\"),r._metadataService.getSigningKeys().then(function(a){if(!a)return i.Log.error(\"ResponseValidator._validateIdToken: No signing keys from metadata\"),Promise.reject(new Error(\"No signing keys from metadata\"));i.Log.debug(\"ResponseValidator._validateIdToken: Received signing keys\");var u=void 0;if(o)u=a.filter(function(e){return e.kid===o})[0];else{if((a=r._filterByAlg(a,n.header.alg)).length>1)return i.Log.error(\"ResponseValidator._validateIdToken: No kid found in id_token and more than one key found in metadata\"),Promise.reject(new Error(\"No kid found in id_token and more than one key found in metadata\"));u=a[0]}if(!u)return i.Log.error(\"ResponseValidator._validateIdToken: No key matching kid or alg found in signing keys\"),Promise.reject(new Error(\"No key matching kid or alg found in signing keys\"));var c=e.client_id,h=r._settings.clockSkew;return i.Log.debug(\"ResponseValidator._validateIdToken: Validaing JWT; using clock skew (in seconds) of: \",h),r._joseUtil.validateJwt(t.id_token,u,s,c,h).then(function(){return i.Log.debug(\"ResponseValidator._validateIdToken: JWT validation successful\"),n.payload.sub?(t.profile=n.payload,t):(i.Log.error(\"ResponseValidator._validateIdToken: No sub present in id_token\"),Promise.reject(new Error(\"No sub present in id_token\")))})})})},ResponseValidator.prototype._filterByAlg=function _filterByAlg(e,t){var r=null;if(t.startsWith(\"RS\"))r=\"RSA\";else if(t.startsWith(\"PS\"))r=\"PS\";else{if(!t.startsWith(\"ES\"))return i.Log.debug(\"ResponseValidator._filterByAlg: alg not supported: \",t),[];r=\"EC\"}return i.Log.debug(\"ResponseValidator._filterByAlg: Looking for keys that match kty: \",r),e=e.filter(function(e){return e.kty===r}),i.Log.debug(\"ResponseValidator._filterByAlg: Number of keys that match kty: \",r,e.length),e},ResponseValidator.prototype._validateAccessToken=function _validateAccessToken(e){if(!e.profile)return i.Log.error(\"ResponseValidator._validateAccessToken: No profile loaded from id_token\"),Promise.reject(new Error(\"No profile loaded from id_token\"));if(!e.profile.at_hash)return i.Log.error(\"ResponseValidator._validateAccessToken: No at_hash in id_token\"),Promise.reject(new Error(\"No at_hash in id_token\"));if(!e.id_token)return i.Log.error(\"ResponseValidator._validateAccessToken: No id_token\"),Promise.reject(new Error(\"No id_token\"));var t=this._joseUtil.parseJwt(e.id_token);if(!t||!t.header)return i.Log.error(\"ResponseValidator._validateAccessToken: Failed to parse id_token\",t),Promise.reject(new Error(\"Failed to parse id_token\"));var r=t.header.alg;if(!r||5!==r.length)return i.Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\",r),Promise.reject(new Error(\"Unsupported alg: \"+r));var n=r.substr(2,3);if(!n)return i.Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\",r,n),Promise.reject(new Error(\"Unsupported alg: \"+r));if(256!==(n=parseInt(n))&&384!==n&&512!==n)return i.Log.error(\"ResponseValidator._validateAccessToken: Unsupported alg:\",r,n),Promise.reject(new Error(\"Unsupported alg: \"+r));var o=\"sha\"+n,s=this._joseUtil.hashString(e.access_token,o);if(!s)return i.Log.error(\"ResponseValidator._validateAccessToken: access_token hash failed:\",o),Promise.reject(new Error(\"Failed to validate at_hash\"));var a=s.substr(0,s.length/2),u=this._joseUtil.hexToBase64Url(a);return u!==e.profile.at_hash?(i.Log.error(\"ResponseValidator._validateAccessToken: Failed to validate at_hash\",u,e.profile.at_hash),Promise.reject(new Error(\"Failed to validate at_hash\"))):(i.Log.debug(\"ResponseValidator._validateAccessToken: success\"),Promise.resolve(e))},ResponseValidator}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.UserInfoService=void 0;var n=r(7),i=r(2),o=r(0),s=r(4);t.UserInfoService=function(){function UserInfoService(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:n.JsonService,r=arguments.length>2&&void 0!==arguments[2]?arguments[2]:i.MetadataService,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:s.JoseUtil;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,UserInfoService),!e)throw o.Log.error(\"UserInfoService.ctor: No settings passed\"),new Error(\"settings\");this._settings=e,this._jsonService=new t(void 0,void 0,this._getClaimsFromJwt.bind(this)),this._metadataService=new r(this._settings),this._joseUtil=a}return UserInfoService.prototype.getClaims=function getClaims(e){var t=this;return e?this._metadataService.getUserInfoEndpoint().then(function(r){return o.Log.debug(\"UserInfoService.getClaims: received userinfo url\",r),t._jsonService.getJson(r,e).then(function(e){return o.Log.debug(\"UserInfoService.getClaims: claims received\",e),e})}):(o.Log.error(\"UserInfoService.getClaims: No token passed\"),Promise.reject(new Error(\"A token is required\")))},UserInfoService.prototype._getClaimsFromJwt=function _getClaimsFromJwt(e){var t=this;try{var r=this._joseUtil.parseJwt(e.responseText);if(!r||!r.header||!r.payload)return o.Log.error(\"UserInfoService._getClaimsFromJwt: Failed to parse JWT\",r),Promise.reject(new Error(\"Failed to parse id_token\"));var n=r.header.kid,i=void 0;switch(this._settings.userInfoJwtIssuer){case\"OP\":i=this._metadataService.getIssuer();break;case\"ANY\":i=Promise.resolve(r.payload.iss);break;default:i=Promise.resolve(this._settings.userInfoJwtIssuer)}return i.then(function(i){return o.Log.debug(\"UserInfoService._getClaimsFromJwt: Received issuer:\"+i),t._metadataService.getSigningKeys().then(function(s){if(!s)return o.Log.error(\"UserInfoService._getClaimsFromJwt: No signing keys from metadata\"),Promise.reject(new Error(\"No signing keys from metadata\"));o.Log.debug(\"UserInfoService._getClaimsFromJwt: Received signing keys\");var a=void 0;if(n)a=s.filter(function(e){return e.kid===n})[0];else{if((s=t._filterByAlg(s,r.header.alg)).length>1)return o.Log.error(\"UserInfoService._getClaimsFromJwt: No kid found in id_token and more than one key found in metadata\"),Promise.reject(new Error(\"No kid found in id_token and more than one key found in metadata\"));a=s[0]}if(!a)return o.Log.error(\"UserInfoService._getClaimsFromJwt: No key matching kid or alg found in signing keys\"),Promise.reject(new Error(\"No key matching kid or alg found in signing keys\"));var u=t._settings.client_id,c=t._settings.clockSkew;return o.Log.debug(\"UserInfoService._getClaimsFromJwt: Validaing JWT; using clock skew (in seconds) of: \",c),t._joseUtil.validateJwt(e.responseText,a,i,u,c,void 0,!0).then(function(){return o.Log.debug(\"UserInfoService._getClaimsFromJwt: JWT validation successful\"),r.payload})})})}catch(e){return o.Log.error(\"UserInfoService._getClaimsFromJwt: Error parsing JWT response\",e.message),void reject(e)}},UserInfoService.prototype._filterByAlg=function _filterByAlg(e,t){var r=null;if(t.startsWith(\"RS\"))r=\"RSA\";else if(t.startsWith(\"PS\"))r=\"PS\";else{if(!t.startsWith(\"ES\"))return o.Log.debug(\"UserInfoService._filterByAlg: alg not supported: \",t),[];r=\"EC\"}return o.Log.debug(\"UserInfoService._filterByAlg: Looking for keys that match kty: \",r),e=e.filter(function(e){return e.kty===r}),o.Log.debug(\"UserInfoService._filterByAlg: Number of keys that match kty: \",r,e.length),e},UserInfoService}()},function(e,t,r){\"use strict\";(function(n){Object.defineProperty(t,\"__esModule\",{value:!0});var i=\"function\"==typeof Symbol&&\"symbol\"==typeof Symbol.iterator?function(e){return typeof e}:function(e){return e&&\"function\"==typeof Symbol&&e.constructor===Symbol&&e!==Symbol.prototype?\"symbol\":typeof e},u={userAgent:!1},p={};\n/*!\nCopyright (c) 2011, Yahoo! Inc. All rights reserved.\nCode licensed under the BSD License:\nhttp://developer.yahoo.com/yui/license.html\nversion: 2.9.0\n*/\nif(void 0===v)var v={};v.lang={extend:function extend(t,r,n){if(!r||!t)throw new Error(\"YAHOO.lang.extend failed, please check that all dependencies are included.\");var i=function d(){};if(i.prototype=r.prototype,t.prototype=new i,t.prototype.constructor=t,t.superclass=r.prototype,r.prototype.constructor==Object.prototype.constructor&&(r.prototype.constructor=r),n){var o;for(o in n)t.prototype[o]=n[o];var s=function e(){},a=[\"toString\",\"valueOf\"];try{/MSIE/.test(u.userAgent)&&(s=function e(t,r){for(o=0;o<a.length;o+=1){var n=a[o],i=r[n];\"function\"==typeof i&&i!=Object.prototype[n]&&(t[n]=i)}})}catch(e){}s(t.prototype,n)}}};\n/*! CryptoJS v3.1.2 core-fix.js\n * code.google.com/p/crypto-js\n * (c) 2009-2013 by Jeff Mott. All rights reserved.\n * code.google.com/p/crypto-js/wiki/License\n * THIS IS FIX of 'core.js' to fix Hmac issue.\n * https://code.google.com/p/crypto-js/issues/detail?id=84\n * https://crypto-js.googlecode.com/svn-history/r667/branches/3.x/src/core.js\n */\nvar y=y||function(e,t){var r={},n=r.lib={},i=n.Base=function(){function n(){}return{extend:function extend(e){n.prototype=this;var t=new n;return e&&t.mixIn(e),t.hasOwnProperty(\"init\")||(t.init=function(){t.$super.init.apply(this,arguments)}),t.init.prototype=t,t.$super=this,t},create:function create(){var e=this.extend();return e.init.apply(e,arguments),e},init:function init(){},mixIn:function mixIn(e){for(var t in e)e.hasOwnProperty(t)&&(this[t]=e[t]);e.hasOwnProperty(\"toString\")&&(this.toString=e.toString)},clone:function clone(){return this.init.prototype.extend(this)}}}(),o=n.WordArray=i.extend({init:function init(e,t){e=this.words=e||[],this.sigBytes=void 0!=t?t:4*e.length},toString:function toString(e){return(e||a).stringify(this)},concat:function concat(e){var t=this.words,r=e.words,n=this.sigBytes,i=e.sigBytes;if(this.clamp(),n%4)for(var o=0;o<i;o++){var s=r[o>>>2]>>>24-o%4*8&255;t[n+o>>>2]|=s<<24-(n+o)%4*8}else for(o=0;o<i;o+=4)t[n+o>>>2]=r[o>>>2];return this.sigBytes+=i,this},clamp:function clamp(){var t=this.words,r=this.sigBytes;t[r>>>2]&=4294967295<<32-r%4*8,t.length=e.ceil(r/4)},clone:function clone(){var e=i.clone.call(this);return e.words=this.words.slice(0),e},random:function random(t){for(var r=[],n=0;n<t;n+=4)r.push(4294967296*e.random()|0);return new o.init(r,t)}}),s=r.enc={},a=s.Hex={stringify:function stringify(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i++){var o=t[i>>>2]>>>24-i%4*8&255;n.push((o>>>4).toString(16)),n.push((15&o).toString(16))}return n.join(\"\")},parse:function parse(e){for(var t=e.length,r=[],n=0;n<t;n+=2)r[n>>>3]|=parseInt(e.substr(n,2),16)<<24-n%8*4;return new o.init(r,t/2)}},u=s.Latin1={stringify:function stringify(e){for(var t=e.words,r=e.sigBytes,n=[],i=0;i<r;i++){var o=t[i>>>2]>>>24-i%4*8&255;n.push(String.fromCharCode(o))}return n.join(\"\")},parse:function parse(e){for(var t=e.length,r=[],n=0;n<t;n++)r[n>>>2]|=(255&e.charCodeAt(n))<<24-n%4*8;return new o.init(r,t)}},c=s.Utf8={stringify:function stringify(e){try{return decodeURIComponent(escape(u.stringify(e)))}catch(e){throw new Error(\"Malformed UTF-8 data\")}},parse:function parse(e){return u.parse(unescape(encodeURIComponent(e)))}},h=n.BufferedBlockAlgorithm=i.extend({reset:function reset(){this._data=new o.init,this._nDataBytes=0},_append:function _append(e){\"string\"==typeof e&&(e=c.parse(e)),this._data.concat(e),this._nDataBytes+=e.sigBytes},_process:function _process(t){var r=this._data,n=r.words,i=r.sigBytes,s=this.blockSize,a=i/(4*s),u=(a=t?e.ceil(a):e.max((0|a)-this._minBufferSize,0))*s,c=e.min(4*u,i);if(u){for(var h=0;h<u;h+=s)this._doProcessBlock(n,h);var l=n.splice(0,u);r.sigBytes-=c}return new o.init(l,c)},clone:function clone(){var e=i.clone.call(this);return e._data=this._data.clone(),e},_minBufferSize:0}),l=(n.Hasher=h.extend({cfg:i.extend(),init:function init(e){this.cfg=this.cfg.extend(e),this.reset()},reset:function reset(){h.reset.call(this),this._doReset()},update:function update(e){return this._append(e),this._process(),this},finalize:function finalize(e){return e&&this._append(e),this._doFinalize()},blockSize:16,_createHelper:function _createHelper(e){return function(t,r){return new e.init(r).finalize(t)}},_createHmacHelper:function _createHmacHelper(e){return function(t,r){return new l.HMAC.init(e,r).finalize(t)}}}),r.algo={});return r}(Math);!function(e){var t,r=(t=y).lib,n=r.Base,i=r.WordArray;(t=t.x64={}).Word=n.extend({init:function init(e,t){this.high=e,this.low=t}}),t.WordArray=n.extend({init:function init(e,t){e=this.words=e||[],this.sigBytes=void 0!=t?t:8*e.length},toX32:function toX32(){for(var e=this.words,t=e.length,r=[],n=0;n<t;n++){var o=e[n];r.push(o.high),r.push(o.low)}return i.create(r,this.sigBytes)},clone:function clone(){for(var e=n.clone.call(this),t=e.words=this.words.slice(0),r=t.length,i=0;i<r;i++)t[i]=t[i].clone();return e}})}(),function(){var e=y,t=e.lib.WordArray;e.enc.Base64={stringify:function stringify(e){var t=e.words,r=e.sigBytes,n=this._map;e.clamp(),e=[];for(var i=0;i<r;i+=3)for(var o=(t[i>>>2]>>>24-i%4*8&255)<<16|(t[i+1>>>2]>>>24-(i+1)%4*8&255)<<8|t[i+2>>>2]>>>24-(i+2)%4*8&255,s=0;4>s&&i+.75*s<r;s++)e.push(n.charAt(o>>>6*(3-s)&63));if(t=n.charAt(64))for(;e.length%4;)e.push(t);return e.join(\"\")},parse:function parse(e){var r=e.length,n=this._map;(i=n.charAt(64))&&(-1!=(i=e.indexOf(i))&&(r=i));for(var i=[],o=0,s=0;s<r;s++)if(s%4){var a=n.indexOf(e.charAt(s-1))<<s%4*2,u=n.indexOf(e.charAt(s))>>>6-s%4*2;i[o>>>2]|=(a|u)<<24-o%4*8,o++}return t.create(i,o)},_map:\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\"}}(),function(e){for(var t=y,r=(i=t.lib).WordArray,n=i.Hasher,i=t.algo,o=[],s=[],a=function u(e){return 4294967296*(e-(0|e))|0},u=2,c=0;64>c;){var h;e:{h=u;for(var l=e.sqrt(h),f=2;f<=l;f++)if(!(h%f)){h=!1;break e}h=!0}h&&(8>c&&(o[c]=a(e.pow(u,.5))),s[c]=a(e.pow(u,1/3)),c++),u++}var g=[];i=i.SHA256=n.extend({_doReset:function _doReset(){this._hash=new r.init(o.slice(0))},_doProcessBlock:function _doProcessBlock(e,t){for(var r=this._hash.words,n=r[0],i=r[1],o=r[2],a=r[3],u=r[4],c=r[5],h=r[6],l=r[7],f=0;64>f;f++){if(16>f)g[f]=0|e[t+f];else{var p=g[f-15],d=g[f-2];g[f]=((p<<25|p>>>7)^(p<<14|p>>>18)^p>>>3)+g[f-7]+((d<<15|d>>>17)^(d<<13|d>>>19)^d>>>10)+g[f-16]}p=l+((u<<26|u>>>6)^(u<<21|u>>>11)^(u<<7|u>>>25))+(u&c^~u&h)+s[f]+g[f],d=((n<<30|n>>>2)^(n<<19|n>>>13)^(n<<10|n>>>22))+(n&i^n&o^i&o),l=h,h=c,c=u,u=a+p|0,a=o,o=i,i=n,n=p+d|0}r[0]=r[0]+n|0,r[1]=r[1]+i|0,r[2]=r[2]+o|0,r[3]=r[3]+a|0,r[4]=r[4]+u|0,r[5]=r[5]+c|0,r[6]=r[6]+h|0,r[7]=r[7]+l|0},_doFinalize:function _doFinalize(){var t=this._data,r=t.words,n=8*this._nDataBytes,i=8*t.sigBytes;return r[i>>>5]|=128<<24-i%32,r[14+(i+64>>>9<<4)]=e.floor(n/4294967296),r[15+(i+64>>>9<<4)]=n,t.sigBytes=4*r.length,this._process(),this._hash},clone:function clone(){var e=n.clone.call(this);return e._hash=this._hash.clone(),e}});t.SHA256=n._createHelper(i),t.HmacSHA256=n._createHmacHelper(i)}(Math),function(){function a(){return r.create.apply(r,arguments)}for(var e=y,t=e.lib.Hasher,r=(i=e.x64).Word,n=i.WordArray,i=e.algo,o=[a(1116352408,3609767458),a(1899447441,602891725),a(3049323471,3964484399),a(3921009573,2173295548),a(961987163,4081628472),a(1508970993,3053834265),a(2453635748,2937671579),a(2870763221,3664609560),a(3624381080,2734883394),a(310598401,1164996542),a(607225278,1323610764),a(1426881987,3590304994),a(1925078388,4068182383),a(2162078206,991336113),a(2614888103,633803317),a(3248222580,3479774868),a(3835390401,2666613458),a(4022224774,944711139),a(264347078,2341262773),a(604807628,2007800933),a(770255983,1495990901),a(1249150122,1856431235),a(1555081692,3175218132),a(1996064986,2198950837),a(2554220882,3999719339),a(2821834349,766784016),a(2952996808,2566594879),a(3210313671,3203337956),a(3336571891,1034457026),a(3584528711,2466948901),a(113926993,3758326383),a(338241895,168717936),a(666307205,1188179964),a(773529912,1546045734),a(1294757372,1522805485),a(1396182291,2643833823),a(1695183700,2343527390),a(1986661051,1014477480),a(2177026350,1206759142),a(2456956037,344077627),a(2730485921,1290863460),a(2820302411,3158454273),a(3259730800,3505952657),a(3345764771,106217008),a(3516065817,3606008344),a(3600352804,1432725776),a(4094571909,1467031594),a(275423344,851169720),a(430227734,3100823752),a(506948616,1363258195),a(659060556,3750685593),a(883997877,3785050280),a(958139571,3318307427),a(1322822218,3812723403),a(1537002063,2003034995),a(1747873779,3602036899),a(1955562222,1575990012),a(2024104815,1125592928),a(2227730452,2716904306),a(2361852424,442776044),a(2428436474,593698344),a(2756734187,3733110249),a(3204031479,2999351573),a(3329325298,3815920427),a(3391569614,3928383900),a(3515267271,566280711),a(3940187606,3454069534),a(4118630271,4000239992),a(116418474,1914138554),a(174292421,2731055270),a(289380356,3203993006),a(460393269,320620315),a(685471733,587496836),a(852142971,1086792851),a(1017036298,365543100),a(1126000580,2618297676),a(1288033470,3409855158),a(1501505948,4234509866),a(1607167915,987167468),a(1816402316,1246189591)],s=[],u=0;80>u;u++)s[u]=a();i=i.SHA512=t.extend({_doReset:function _doReset(){this._hash=new n.init([new r.init(1779033703,4089235720),new r.init(3144134277,2227873595),new r.init(1013904242,4271175723),new r.init(2773480762,1595750129),new r.init(1359893119,2917565137),new r.init(2600822924,725511199),new r.init(528734635,4215389547),new r.init(1541459225,327033209)])},_doProcessBlock:function _doProcessBlock(e,t){for(var r=(l=this._hash.words)[0],n=l[1],i=l[2],a=l[3],u=l[4],c=l[5],h=l[6],l=l[7],f=r.high,g=r.low,p=n.high,d=n.low,v=i.high,y=i.low,m=a.high,_=a.low,S=u.high,b=u.low,F=c.high,w=c.low,E=h.high,x=h.low,C=l.high,k=l.low,A=f,P=g,I=p,B=d,R=v,T=y,U=m,D=_,L=S,M=b,N=F,O=w,H=E,j=x,K=C,V=k,q=0;80>q;q++){var W=s[q];if(16>q)var J=W.high=0|e[t+2*q],z=W.low=0|e[t+2*q+1];else{J=((z=(J=s[q-15]).high)>>>1|(Y=J.low)<<31)^(z>>>8|Y<<24)^z>>>7;var Y=(Y>>>1|z<<31)^(Y>>>8|z<<24)^(Y>>>7|z<<25),G=((z=(G=s[q-2]).high)>>>19|(X=G.low)<<13)^(z<<3|X>>>29)^z>>>6,X=(X>>>19|z<<13)^(X<<3|z>>>29)^(X>>>6|z<<26),Q=(z=s[q-7]).high,$=(Z=s[q-16]).high,Z=Z.low;J=(J=(J=J+Q+((z=Y+z.low)>>>0<Y>>>0?1:0))+G+((z=z+X)>>>0<X>>>0?1:0))+$+((z=z+Z)>>>0<Z>>>0?1:0);W.high=J,W.low=z}Q=L&N^~L&H,Z=M&O^~M&j,W=A&I^A&R^I&R;var ee=P&B^P&T^B&T,te=(Y=(A>>>28|P<<4)^(A<<30|P>>>2)^(A<<25|P>>>7),G=(P>>>28|A<<4)^(P<<30|A>>>2)^(P<<25|A>>>7),(X=o[q]).high),re=X.low;$=($=($=($=K+((L>>>14|M<<18)^(L>>>18|M<<14)^(L<<23|M>>>9))+((X=V+((M>>>14|L<<18)^(M>>>18|L<<14)^(M<<23|L>>>9)))>>>0<V>>>0?1:0))+Q+((X=X+Z)>>>0<Z>>>0?1:0))+te+((X=X+re)>>>0<re>>>0?1:0))+J+((X=X+z)>>>0<z>>>0?1:0),W=Y+W+((z=G+ee)>>>0<G>>>0?1:0),K=H,V=j,H=N,j=O,N=L,O=M,L=U+$+((M=D+X|0)>>>0<D>>>0?1:0)|0,U=R,D=T,R=I,T=B,I=A,B=P,A=$+W+((P=X+z|0)>>>0<X>>>0?1:0)|0}g=r.low=g+P,r.high=f+A+(g>>>0<P>>>0?1:0),d=n.low=d+B,n.high=p+I+(d>>>0<B>>>0?1:0),y=i.low=y+T,i.high=v+R+(y>>>0<T>>>0?1:0),_=a.low=_+D,a.high=m+U+(_>>>0<D>>>0?1:0),b=u.low=b+M,u.high=S+L+(b>>>0<M>>>0?1:0),w=c.low=w+O,c.high=F+N+(w>>>0<O>>>0?1:0),x=h.low=x+j,h.high=E+H+(x>>>0<j>>>0?1:0),k=l.low=k+V,l.high=C+K+(k>>>0<V>>>0?1:0)},_doFinalize:function _doFinalize(){var e=this._data,t=e.words,r=8*this._nDataBytes,n=8*e.sigBytes;return t[n>>>5]|=128<<24-n%32,t[30+(n+128>>>10<<5)]=Math.floor(r/4294967296),t[31+(n+128>>>10<<5)]=r,e.sigBytes=4*t.length,this._process(),this._hash.toX32()},clone:function clone(){var e=t.clone.call(this);return e._hash=this._hash.clone(),e},blockSize:32}),e.SHA512=t._createHelper(i),e.HmacSHA512=t._createHmacHelper(i)}(),function(){var e=y,t=(i=e.x64).Word,r=i.WordArray,n=(i=e.algo).SHA512,i=i.SHA384=n.extend({_doReset:function _doReset(){this._hash=new r.init([new t.init(3418070365,3238371032),new t.init(1654270250,914150663),new t.init(2438529370,812702999),new t.init(355462360,4144912697),new t.init(1731405415,4290775857),new t.init(2394180231,1750603025),new t.init(3675008525,1694076839),new t.init(1203062813,3204075428)])},_doFinalize:function _doFinalize(){var e=n._doFinalize.call(this);return e.sigBytes-=16,e}});e.SHA384=n._createHelper(i),e.HmacSHA384=n._createHmacHelper(i)}();\n/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */\nvar _,S=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",F=\"=\";function hex2b64(e){var t,r,n=\"\";for(t=0;t+3<=e.length;t+=3)r=parseInt(e.substring(t,t+3),16),n+=S.charAt(r>>6)+S.charAt(63&r);if(t+1==e.length?(r=parseInt(e.substring(t,t+1),16),n+=S.charAt(r<<2)):t+2==e.length&&(r=parseInt(e.substring(t,t+2),16),n+=S.charAt(r>>2)+S.charAt((3&r)<<4)),F)for(;(3&n.length)>0;)n+=F;return n}function b64tohex(e){var t,r,n,i=\"\",o=0;for(t=0;t<e.length&&e.charAt(t)!=F;++t)(n=S.indexOf(e.charAt(t)))<0||(0==o?(i+=int2char(n>>2),r=3&n,o=1):1==o?(i+=int2char(r<<2|n>>4),r=15&n,o=2):2==o?(i+=int2char(r),i+=int2char(n>>2),r=3&n,o=3):(i+=int2char(r<<2|n>>4),i+=int2char(15&n),o=0));return 1==o&&(i+=int2char(r<<2)),i}function b64toBA(e){var t,r=b64tohex(e),n=new Array;for(t=0;2*t<r.length;++t)n[t]=parseInt(r.substring(2*t,2*t+2),16);return n}function BigInteger(e,t,r){null!=e&&(\"number\"==typeof e?this.fromNumber(e,t,r):null==t&&\"string\"!=typeof e?this.fromString(e,256):this.fromString(e,t))}function nbi(){return new BigInteger(null)}\"Microsoft Internet Explorer\"==u.appName?(BigInteger.prototype.am=function am2(e,t,r,n,i,o){for(var s=32767&t,a=t>>15;--o>=0;){var u=32767&this[e],c=this[e++]>>15,h=a*u+c*s;i=((u=s*u+((32767&h)<<15)+r[n]+(1073741823&i))>>>30)+(h>>>15)+a*c+(i>>>30),r[n++]=1073741823&u}return i},_=30):\"Netscape\"!=u.appName?(BigInteger.prototype.am=function am1(e,t,r,n,i,o){for(;--o>=0;){var s=t*this[e++]+r[n]+i;i=Math.floor(s/67108864),r[n++]=67108863&s}return i},_=26):(BigInteger.prototype.am=function am3(e,t,r,n,i,o){for(var s=16383&t,a=t>>14;--o>=0;){var u=16383&this[e],c=this[e++]>>14,h=a*u+c*s;i=((u=s*u+((16383&h)<<14)+r[n]+i)>>28)+(h>>14)+a*c,r[n++]=268435455&u}return i},_=28),BigInteger.prototype.DB=_,BigInteger.prototype.DM=(1<<_)-1,BigInteger.prototype.DV=1<<_;BigInteger.prototype.FV=Math.pow(2,52),BigInteger.prototype.F1=52-_,BigInteger.prototype.F2=2*_-52;var w,E,C=\"0123456789abcdefghijklmnopqrstuvwxyz\",P=new Array;for(w=\"0\".charCodeAt(0),E=0;E<=9;++E)P[w++]=E;for(w=\"a\".charCodeAt(0),E=10;E<36;++E)P[w++]=E;for(w=\"A\".charCodeAt(0),E=10;E<36;++E)P[w++]=E;function int2char(e){return C.charAt(e)}function intAt(e,t){var r=P[e.charCodeAt(t)];return null==r?-1:r}function nbv(e){var t=nbi();return t.fromInt(e),t}function nbits(e){var t,r=1;return 0!=(t=e>>>16)&&(e=t,r+=16),0!=(t=e>>8)&&(e=t,r+=8),0!=(t=e>>4)&&(e=t,r+=4),0!=(t=e>>2)&&(e=t,r+=2),0!=(t=e>>1)&&(e=t,r+=1),r}function Classic(e){this.m=e}function Montgomery(e){this.m=e,this.mp=e.invDigit(),this.mpl=32767&this.mp,this.mph=this.mp>>15,this.um=(1<<e.DB-15)-1,this.mt2=2*e.t}function op_and(e,t){return e&t}function op_or(e,t){return e|t}function op_xor(e,t){return e^t}function op_andnot(e,t){return e&~t}function lbit(e){if(0==e)return-1;var t=0;return 0==(65535&e)&&(e>>=16,t+=16),0==(255&e)&&(e>>=8,t+=8),0==(15&e)&&(e>>=4,t+=4),0==(3&e)&&(e>>=2,t+=2),0==(1&e)&&++t,t}function cbit(e){for(var t=0;0!=e;)e&=e-1,++t;return t}function NullExp(){}function nNop(e){return e}function Barrett(e){this.r2=nbi(),this.q3=nbi(),BigInteger.ONE.dlShiftTo(2*e.t,this.r2),this.mu=this.r2.divide(e),this.m=e}Classic.prototype.convert=function cConvert(e){return e.s<0||e.compareTo(this.m)>=0?e.mod(this.m):e},Classic.prototype.revert=function cRevert(e){return e},Classic.prototype.reduce=function cReduce(e){e.divRemTo(this.m,null,e)},Classic.prototype.mulTo=function cMulTo(e,t,r){e.multiplyTo(t,r),this.reduce(r)},Classic.prototype.sqrTo=function cSqrTo(e,t){e.squareTo(t),this.reduce(t)},Montgomery.prototype.convert=function montConvert(e){var t=nbi();return e.abs().dlShiftTo(this.m.t,t),t.divRemTo(this.m,null,t),e.s<0&&t.compareTo(BigInteger.ZERO)>0&&this.m.subTo(t,t),t},Montgomery.prototype.revert=function montRevert(e){var t=nbi();return e.copyTo(t),this.reduce(t),t},Montgomery.prototype.reduce=function montReduce(e){for(;e.t<=this.mt2;)e[e.t++]=0;for(var t=0;t<this.m.t;++t){var r=32767&e[t],n=r*this.mpl+((r*this.mph+(e[t]>>15)*this.mpl&this.um)<<15)&e.DM;for(e[r=t+this.m.t]+=this.m.am(0,n,e,t,0,this.m.t);e[r]>=e.DV;)e[r]-=e.DV,e[++r]++}e.clamp(),e.drShiftTo(this.m.t,e),e.compareTo(this.m)>=0&&e.subTo(this.m,e)},Montgomery.prototype.mulTo=function montMulTo(e,t,r){e.multiplyTo(t,r),this.reduce(r)},Montgomery.prototype.sqrTo=function montSqrTo(e,t){e.squareTo(t),this.reduce(t)},BigInteger.prototype.copyTo=function bnpCopyTo(e){for(var t=this.t-1;t>=0;--t)e[t]=this[t];e.t=this.t,e.s=this.s},BigInteger.prototype.fromInt=function bnpFromInt(e){this.t=1,this.s=e<0?-1:0,e>0?this[0]=e:e<-1?this[0]=e+this.DV:this.t=0},BigInteger.prototype.fromString=function bnpFromString(e,t){var r;if(16==t)r=4;else if(8==t)r=3;else if(256==t)r=8;else if(2==t)r=1;else if(32==t)r=5;else{if(4!=t)return void this.fromRadix(e,t);r=2}this.t=0,this.s=0;for(var n=e.length,i=!1,o=0;--n>=0;){var s=8==r?255&e[n]:intAt(e,n);s<0?\"-\"==e.charAt(n)&&(i=!0):(i=!1,0==o?this[this.t++]=s:o+r>this.DB?(this[this.t-1]|=(s&(1<<this.DB-o)-1)<<o,this[this.t++]=s>>this.DB-o):this[this.t-1]|=s<<o,(o+=r)>=this.DB&&(o-=this.DB))}8==r&&0!=(128&e[0])&&(this.s=-1,o>0&&(this[this.t-1]|=(1<<this.DB-o)-1<<o)),this.clamp(),i&&BigInteger.ZERO.subTo(this,this)},BigInteger.prototype.clamp=function bnpClamp(){for(var e=this.s&this.DM;this.t>0&&this[this.t-1]==e;)--this.t},BigInteger.prototype.dlShiftTo=function bnpDLShiftTo(e,t){var r;for(r=this.t-1;r>=0;--r)t[r+e]=this[r];for(r=e-1;r>=0;--r)t[r]=0;t.t=this.t+e,t.s=this.s},BigInteger.prototype.drShiftTo=function bnpDRShiftTo(e,t){for(var r=e;r<this.t;++r)t[r-e]=this[r];t.t=Math.max(this.t-e,0),t.s=this.s},BigInteger.prototype.lShiftTo=function bnpLShiftTo(e,t){var r,n=e%this.DB,i=this.DB-n,o=(1<<i)-1,s=Math.floor(e/this.DB),a=this.s<<n&this.DM;for(r=this.t-1;r>=0;--r)t[r+s+1]=this[r]>>i|a,a=(this[r]&o)<<n;for(r=s-1;r>=0;--r)t[r]=0;t[s]=a,t.t=this.t+s+1,t.s=this.s,t.clamp()},BigInteger.prototype.rShiftTo=function bnpRShiftTo(e,t){t.s=this.s;var r=Math.floor(e/this.DB);if(r>=this.t)t.t=0;else{var n=e%this.DB,i=this.DB-n,o=(1<<n)-1;t[0]=this[r]>>n;for(var s=r+1;s<this.t;++s)t[s-r-1]|=(this[s]&o)<<i,t[s-r]=this[s]>>n;n>0&&(t[this.t-r-1]|=(this.s&o)<<i),t.t=this.t-r,t.clamp()}},BigInteger.prototype.subTo=function bnpSubTo(e,t){for(var r=0,n=0,i=Math.min(e.t,this.t);r<i;)n+=this[r]-e[r],t[r++]=n&this.DM,n>>=this.DB;if(e.t<this.t){for(n-=e.s;r<this.t;)n+=this[r],t[r++]=n&this.DM,n>>=this.DB;n+=this.s}else{for(n+=this.s;r<e.t;)n-=e[r],t[r++]=n&this.DM,n>>=this.DB;n-=e.s}t.s=n<0?-1:0,n<-1?t[r++]=this.DV+n:n>0&&(t[r++]=n),t.t=r,t.clamp()},BigInteger.prototype.multiplyTo=function bnpMultiplyTo(e,t){var r=this.abs(),n=e.abs(),i=r.t;for(t.t=i+n.t;--i>=0;)t[i]=0;for(i=0;i<n.t;++i)t[i+r.t]=r.am(0,n[i],t,i,0,r.t);t.s=0,t.clamp(),this.s!=e.s&&BigInteger.ZERO.subTo(t,t)},BigInteger.prototype.squareTo=function bnpSquareTo(e){for(var t=this.abs(),r=e.t=2*t.t;--r>=0;)e[r]=0;for(r=0;r<t.t-1;++r){var n=t.am(r,t[r],e,2*r,0,1);(e[r+t.t]+=t.am(r+1,2*t[r],e,2*r+1,n,t.t-r-1))>=t.DV&&(e[r+t.t]-=t.DV,e[r+t.t+1]=1)}e.t>0&&(e[e.t-1]+=t.am(r,t[r],e,2*r,0,1)),e.s=0,e.clamp()},BigInteger.prototype.divRemTo=function bnpDivRemTo(e,t,r){var n=e.abs();if(!(n.t<=0)){var i=this.abs();if(i.t<n.t)return null!=t&&t.fromInt(0),void(null!=r&&this.copyTo(r));null==r&&(r=nbi());var o=nbi(),s=this.s,a=e.s,u=this.DB-nbits(n[n.t-1]);u>0?(n.lShiftTo(u,o),i.lShiftTo(u,r)):(n.copyTo(o),i.copyTo(r));var c=o.t,h=o[c-1];if(0!=h){var l=h*(1<<this.F1)+(c>1?o[c-2]>>this.F2:0),f=this.FV/l,g=(1<<this.F1)/l,p=1<<this.F2,d=r.t,v=d-c,y=null==t?nbi():t;for(o.dlShiftTo(v,y),r.compareTo(y)>=0&&(r[r.t++]=1,r.subTo(y,r)),BigInteger.ONE.dlShiftTo(c,y),y.subTo(o,o);o.t<c;)o[o.t++]=0;for(;--v>=0;){var m=r[--d]==h?this.DM:Math.floor(r[d]*f+(r[d-1]+p)*g);if((r[d]+=o.am(0,m,r,v,0,c))<m)for(o.dlShiftTo(v,y),r.subTo(y,r);r[d]<--m;)r.subTo(y,r)}null!=t&&(r.drShiftTo(c,t),s!=a&&BigInteger.ZERO.subTo(t,t)),r.t=c,r.clamp(),u>0&&r.rShiftTo(u,r),s<0&&BigInteger.ZERO.subTo(r,r)}}},BigInteger.prototype.invDigit=function bnpInvDigit(){if(this.t<1)return 0;var e=this[0];if(0==(1&e))return 0;var t=3&e;return(t=(t=(t=(t=t*(2-(15&e)*t)&15)*(2-(255&e)*t)&255)*(2-((65535&e)*t&65535))&65535)*(2-e*t%this.DV)%this.DV)>0?this.DV-t:-t},BigInteger.prototype.isEven=function bnpIsEven(){return 0==(this.t>0?1&this[0]:this.s)},BigInteger.prototype.exp=function bnpExp(e,t){if(e>4294967295||e<1)return BigInteger.ONE;var r=nbi(),n=nbi(),i=t.convert(this),o=nbits(e)-1;for(i.copyTo(r);--o>=0;)if(t.sqrTo(r,n),(e&1<<o)>0)t.mulTo(n,i,r);else{var s=r;r=n,n=s}return t.revert(r)},BigInteger.prototype.toString=function bnToString(e){if(this.s<0)return\"-\"+this.negate().toString(e);var t;if(16==e)t=4;else if(8==e)t=3;else if(2==e)t=1;else if(32==e)t=5;else{if(4!=e)return this.toRadix(e);t=2}var r,n=(1<<t)-1,i=!1,o=\"\",s=this.t,a=this.DB-s*this.DB%t;if(s-- >0)for(a<this.DB&&(r=this[s]>>a)>0&&(i=!0,o=int2char(r));s>=0;)a<t?(r=(this[s]&(1<<a)-1)<<t-a,r|=this[--s]>>(a+=this.DB-t)):(r=this[s]>>(a-=t)&n,a<=0&&(a+=this.DB,--s)),r>0&&(i=!0),i&&(o+=int2char(r));return i?o:\"0\"},BigInteger.prototype.negate=function bnNegate(){var e=nbi();return BigInteger.ZERO.subTo(this,e),e},BigInteger.prototype.abs=function bnAbs(){return this.s<0?this.negate():this},BigInteger.prototype.compareTo=function bnCompareTo(e){var t=this.s-e.s;if(0!=t)return t;var r=this.t;if(0!=(t=r-e.t))return this.s<0?-t:t;for(;--r>=0;)if(0!=(t=this[r]-e[r]))return t;return 0},BigInteger.prototype.bitLength=function bnBitLength(){return this.t<=0?0:this.DB*(this.t-1)+nbits(this[this.t-1]^this.s&this.DM)},BigInteger.prototype.mod=function bnMod(e){var t=nbi();return this.abs().divRemTo(e,null,t),this.s<0&&t.compareTo(BigInteger.ZERO)>0&&e.subTo(t,t),t},BigInteger.prototype.modPowInt=function bnModPowInt(e,t){var r;return r=e<256||t.isEven()?new Classic(t):new Montgomery(t),this.exp(e,r)},BigInteger.ZERO=nbv(0),BigInteger.ONE=nbv(1),NullExp.prototype.convert=nNop,NullExp.prototype.revert=nNop,NullExp.prototype.mulTo=function nMulTo(e,t,r){e.multiplyTo(t,r)},NullExp.prototype.sqrTo=function nSqrTo(e,t){e.squareTo(t)},Barrett.prototype.convert=function barrettConvert(e){if(e.s<0||e.t>2*this.m.t)return e.mod(this.m);if(e.compareTo(this.m)<0)return e;var t=nbi();return e.copyTo(t),this.reduce(t),t},Barrett.prototype.revert=function barrettRevert(e){return e},Barrett.prototype.reduce=function barrettReduce(e){for(e.drShiftTo(this.m.t-1,this.r2),e.t>this.m.t+1&&(e.t=this.m.t+1,e.clamp()),this.mu.multiplyUpperTo(this.r2,this.m.t+1,this.q3),this.m.multiplyLowerTo(this.q3,this.m.t+1,this.r2);e.compareTo(this.r2)<0;)e.dAddOffset(1,this.m.t+1);for(e.subTo(this.r2,e);e.compareTo(this.m)>=0;)e.subTo(this.m,e)},Barrett.prototype.mulTo=function barrettMulTo(e,t,r){e.multiplyTo(t,r),this.reduce(r)},Barrett.prototype.sqrTo=function barrettSqrTo(e,t){e.squareTo(t),this.reduce(t)};var I=[2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997],R=(1<<26)/I[I.length-1];\n/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */\nfunction Arcfour(){this.i=0,this.j=0,this.S=new Array}BigInteger.prototype.chunkSize=function bnpChunkSize(e){return Math.floor(Math.LN2*this.DB/Math.log(e))},BigInteger.prototype.toRadix=function bnpToRadix(e){if(null==e&&(e=10),0==this.signum()||e<2||e>36)return\"0\";var t=this.chunkSize(e),r=Math.pow(e,t),n=nbv(r),i=nbi(),o=nbi(),s=\"\";for(this.divRemTo(n,i,o);i.signum()>0;)s=(r+o.intValue()).toString(e).substr(1)+s,i.divRemTo(n,i,o);return o.intValue().toString(e)+s},BigInteger.prototype.fromRadix=function bnpFromRadix(e,t){this.fromInt(0),null==t&&(t=10);for(var r=this.chunkSize(t),n=Math.pow(t,r),i=!1,o=0,s=0,a=0;a<e.length;++a){var u=intAt(e,a);u<0?\"-\"==e.charAt(a)&&0==this.signum()&&(i=!0):(s=t*s+u,++o>=r&&(this.dMultiply(n),this.dAddOffset(s,0),o=0,s=0))}o>0&&(this.dMultiply(Math.pow(t,o)),this.dAddOffset(s,0)),i&&BigInteger.ZERO.subTo(this,this)},BigInteger.prototype.fromNumber=function bnpFromNumber(e,t,r){if(\"number\"==typeof t)if(e<2)this.fromInt(1);else for(this.fromNumber(e,r),this.testBit(e-1)||this.bitwiseTo(BigInteger.ONE.shiftLeft(e-1),op_or,this),this.isEven()&&this.dAddOffset(1,0);!this.isProbablePrime(t);)this.dAddOffset(2,0),this.bitLength()>e&&this.subTo(BigInteger.ONE.shiftLeft(e-1),this);else{var n=new Array,i=7&e;n.length=1+(e>>3),t.nextBytes(n),i>0?n[0]&=(1<<i)-1:n[0]=0,this.fromString(n,256)}},BigInteger.prototype.bitwiseTo=function bnpBitwiseTo(e,t,r){var n,i,o=Math.min(e.t,this.t);for(n=0;n<o;++n)r[n]=t(this[n],e[n]);if(e.t<this.t){for(i=e.s&this.DM,n=o;n<this.t;++n)r[n]=t(this[n],i);r.t=this.t}else{for(i=this.s&this.DM,n=o;n<e.t;++n)r[n]=t(i,e[n]);r.t=e.t}r.s=t(this.s,e.s),r.clamp()},BigInteger.prototype.changeBit=function bnpChangeBit(e,t){var r=BigInteger.ONE.shiftLeft(e);return this.bitwiseTo(r,t,r),r},BigInteger.prototype.addTo=function bnpAddTo(e,t){for(var r=0,n=0,i=Math.min(e.t,this.t);r<i;)n+=this[r]+e[r],t[r++]=n&this.DM,n>>=this.DB;if(e.t<this.t){for(n+=e.s;r<this.t;)n+=this[r],t[r++]=n&this.DM,n>>=this.DB;n+=this.s}else{for(n+=this.s;r<e.t;)n+=e[r],t[r++]=n&this.DM,n>>=this.DB;n+=e.s}t.s=n<0?-1:0,n>0?t[r++]=n:n<-1&&(t[r++]=this.DV+n),t.t=r,t.clamp()},BigInteger.prototype.dMultiply=function bnpDMultiply(e){this[this.t]=this.am(0,e-1,this,0,0,this.t),++this.t,this.clamp()},BigInteger.prototype.dAddOffset=function bnpDAddOffset(e,t){if(0!=e){for(;this.t<=t;)this[this.t++]=0;for(this[t]+=e;this[t]>=this.DV;)this[t]-=this.DV,++t>=this.t&&(this[this.t++]=0),++this[t]}},BigInteger.prototype.multiplyLowerTo=function bnpMultiplyLowerTo(e,t,r){var n,i=Math.min(this.t+e.t,t);for(r.s=0,r.t=i;i>0;)r[--i]=0;for(n=r.t-this.t;i<n;++i)r[i+this.t]=this.am(0,e[i],r,i,0,this.t);for(n=Math.min(e.t,t);i<n;++i)this.am(0,e[i],r,i,0,t-i);r.clamp()},BigInteger.prototype.multiplyUpperTo=function bnpMultiplyUpperTo(e,t,r){--t;var n=r.t=this.t+e.t-t;for(r.s=0;--n>=0;)r[n]=0;for(n=Math.max(t-this.t,0);n<e.t;++n)r[this.t+n-t]=this.am(t-n,e[n],r,0,0,this.t+n-t);r.clamp(),r.drShiftTo(1,r)},BigInteger.prototype.modInt=function bnpModInt(e){if(e<=0)return 0;var t=this.DV%e,r=this.s<0?e-1:0;if(this.t>0)if(0==t)r=this[0]%e;else for(var n=this.t-1;n>=0;--n)r=(t*r+this[n])%e;return r},BigInteger.prototype.millerRabin=function bnpMillerRabin(e){var t=this.subtract(BigInteger.ONE),r=t.getLowestSetBit();if(r<=0)return!1;var n=t.shiftRight(r);(e=e+1>>1)>I.length&&(e=I.length);for(var i=nbi(),o=0;o<e;++o){i.fromInt(I[Math.floor(Math.random()*I.length)]);var s=i.modPow(n,this);if(0!=s.compareTo(BigInteger.ONE)&&0!=s.compareTo(t)){for(var a=1;a++<r&&0!=s.compareTo(t);)if(0==(s=s.modPowInt(2,this)).compareTo(BigInteger.ONE))return!1;if(0!=s.compareTo(t))return!1}}return!0},BigInteger.prototype.clone=\n/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */\nfunction bnClone(){var e=nbi();return this.copyTo(e),e},BigInteger.prototype.intValue=function bnIntValue(){if(this.s<0){if(1==this.t)return this[0]-this.DV;if(0==this.t)return-1}else{if(1==this.t)return this[0];if(0==this.t)return 0}return(this[1]&(1<<32-this.DB)-1)<<this.DB|this[0]},BigInteger.prototype.byteValue=function bnByteValue(){return 0==this.t?this.s:this[0]<<24>>24},BigInteger.prototype.shortValue=function bnShortValue(){return 0==this.t?this.s:this[0]<<16>>16},BigInteger.prototype.signum=function bnSigNum(){return this.s<0?-1:this.t<=0||1==this.t&&this[0]<=0?0:1},BigInteger.prototype.toByteArray=function bnToByteArray(){var e=this.t,t=new Array;t[0]=this.s;var r,n=this.DB-e*this.DB%8,i=0;if(e-- >0)for(n<this.DB&&(r=this[e]>>n)!=(this.s&this.DM)>>n&&(t[i++]=r|this.s<<this.DB-n);e>=0;)n<8?(r=(this[e]&(1<<n)-1)<<8-n,r|=this[--e]>>(n+=this.DB-8)):(r=this[e]>>(n-=8)&255,n<=0&&(n+=this.DB,--e)),0!=(128&r)&&(r|=-256),0==i&&(128&this.s)!=(128&r)&&++i,(i>0||r!=this.s)&&(t[i++]=r);return t},BigInteger.prototype.equals=function bnEquals(e){return 0==this.compareTo(e)},BigInteger.prototype.min=function bnMin(e){return this.compareTo(e)<0?this:e},BigInteger.prototype.max=function bnMax(e){return this.compareTo(e)>0?this:e},BigInteger.prototype.and=function bnAnd(e){var t=nbi();return this.bitwiseTo(e,op_and,t),t},BigInteger.prototype.or=function bnOr(e){var t=nbi();return this.bitwiseTo(e,op_or,t),t},BigInteger.prototype.xor=function bnXor(e){var t=nbi();return this.bitwiseTo(e,op_xor,t),t},BigInteger.prototype.andNot=function bnAndNot(e){var t=nbi();return this.bitwiseTo(e,op_andnot,t),t},BigInteger.prototype.not=function bnNot(){for(var e=nbi(),t=0;t<this.t;++t)e[t]=this.DM&~this[t];return e.t=this.t,e.s=~this.s,e},BigInteger.prototype.shiftLeft=function bnShiftLeft(e){var t=nbi();return e<0?this.rShiftTo(-e,t):this.lShiftTo(e,t),t},BigInteger.prototype.shiftRight=function bnShiftRight(e){var t=nbi();return e<0?this.lShiftTo(-e,t):this.rShiftTo(e,t),t},BigInteger.prototype.getLowestSetBit=function bnGetLowestSetBit(){for(var e=0;e<this.t;++e)if(0!=this[e])return e*this.DB+lbit(this[e]);return this.s<0?this.t*this.DB:-1},BigInteger.prototype.bitCount=function bnBitCount(){for(var e=0,t=this.s&this.DM,r=0;r<this.t;++r)e+=cbit(this[r]^t);return e},BigInteger.prototype.testBit=function bnTestBit(e){var t=Math.floor(e/this.DB);return t>=this.t?0!=this.s:0!=(this[t]&1<<e%this.DB)},BigInteger.prototype.setBit=function bnSetBit(e){return this.changeBit(e,op_or)},BigInteger.prototype.clearBit=function bnClearBit(e){return this.changeBit(e,op_andnot)},BigInteger.prototype.flipBit=function bnFlipBit(e){return this.changeBit(e,op_xor)},BigInteger.prototype.add=function bnAdd(e){var t=nbi();return this.addTo(e,t),t},BigInteger.prototype.subtract=function bnSubtract(e){var t=nbi();return this.subTo(e,t),t},BigInteger.prototype.multiply=function bnMultiply(e){var t=nbi();return this.multiplyTo(e,t),t},BigInteger.prototype.divide=function bnDivide(e){var t=nbi();return this.divRemTo(e,t,null),t},BigInteger.prototype.remainder=function bnRemainder(e){var t=nbi();return this.divRemTo(e,null,t),t},BigInteger.prototype.divideAndRemainder=function bnDivideAndRemainder(e){var t=nbi(),r=nbi();return this.divRemTo(e,t,r),new Array(t,r)},BigInteger.prototype.modPow=function bnModPow(e,t){var r,n,i=e.bitLength(),o=nbv(1);if(i<=0)return o;r=i<18?1:i<48?3:i<144?4:i<768?5:6,n=i<8?new Classic(t):t.isEven()?new Barrett(t):new Montgomery(t);var s=new Array,a=3,u=r-1,c=(1<<r)-1;if(s[1]=n.convert(this),r>1){var h=nbi();for(n.sqrTo(s[1],h);a<=c;)s[a]=nbi(),n.mulTo(h,s[a-2],s[a]),a+=2}var l,f,g=e.t-1,p=!0,d=nbi();for(i=nbits(e[g])-1;g>=0;){for(i>=u?l=e[g]>>i-u&c:(l=(e[g]&(1<<i+1)-1)<<u-i,g>0&&(l|=e[g-1]>>this.DB+i-u)),a=r;0==(1&l);)l>>=1,--a;if((i-=a)<0&&(i+=this.DB,--g),p)s[l].copyTo(o),p=!1;else{for(;a>1;)n.sqrTo(o,d),n.sqrTo(d,o),a-=2;a>0?n.sqrTo(o,d):(f=o,o=d,d=f),n.mulTo(d,s[l],o)}for(;g>=0&&0==(e[g]&1<<i);)n.sqrTo(o,d),f=o,o=d,d=f,--i<0&&(i=this.DB-1,--g)}return n.revert(o)},BigInteger.prototype.modInverse=function bnModInverse(e){var t=e.isEven();if(this.isEven()&&t||0==e.signum())return BigInteger.ZERO;for(var r=e.clone(),n=this.clone(),i=nbv(1),o=nbv(0),s=nbv(0),a=nbv(1);0!=r.signum();){for(;r.isEven();)r.rShiftTo(1,r),t?(i.isEven()&&o.isEven()||(i.addTo(this,i),o.subTo(e,o)),i.rShiftTo(1,i)):o.isEven()||o.subTo(e,o),o.rShiftTo(1,o);for(;n.isEven();)n.rShiftTo(1,n),t?(s.isEven()&&a.isEven()||(s.addTo(this,s),a.subTo(e,a)),s.rShiftTo(1,s)):a.isEven()||a.subTo(e,a),a.rShiftTo(1,a);r.compareTo(n)>=0?(r.subTo(n,r),t&&i.subTo(s,i),o.subTo(a,o)):(n.subTo(r,n),t&&s.subTo(i,s),a.subTo(o,a))}return 0!=n.compareTo(BigInteger.ONE)?BigInteger.ZERO:a.compareTo(e)>=0?a.subtract(e):a.signum()<0?(a.addTo(e,a),a.signum()<0?a.add(e):a):a},BigInteger.prototype.pow=function bnPow(e){return this.exp(e,new NullExp)},BigInteger.prototype.gcd=function bnGCD(e){var t=this.s<0?this.negate():this.clone(),r=e.s<0?e.negate():e.clone();if(t.compareTo(r)<0){var n=t;t=r,r=n}var i=t.getLowestSetBit(),o=r.getLowestSetBit();if(o<0)return t;for(i<o&&(o=i),o>0&&(t.rShiftTo(o,t),r.rShiftTo(o,r));t.signum()>0;)(i=t.getLowestSetBit())>0&&t.rShiftTo(i,t),(i=r.getLowestSetBit())>0&&r.rShiftTo(i,r),t.compareTo(r)>=0?(t.subTo(r,t),t.rShiftTo(1,t)):(r.subTo(t,r),r.rShiftTo(1,r));return o>0&&r.lShiftTo(o,r),r},BigInteger.prototype.isProbablePrime=function bnIsProbablePrime(e){var t,r=this.abs();if(1==r.t&&r[0]<=I[I.length-1]){for(t=0;t<I.length;++t)if(r[0]==I[t])return!0;return!1}if(r.isEven())return!1;for(t=1;t<I.length;){for(var n=I[t],i=t+1;i<I.length&&n<R;)n*=I[i++];for(n=r.modInt(n);t<i;)if(n%I[t++]==0)return!1}return r.millerRabin(e)},BigInteger.prototype.square=function bnSquare(){var e=nbi();return this.squareTo(e),e},Arcfour.prototype.init=function ARC4init(e){var t,r,n;for(t=0;t<256;++t)this.S[t]=t;for(r=0,t=0;t<256;++t)r=r+this.S[t]+e[t%e.length]&255,n=this.S[t],this.S[t]=this.S[r],this.S[r]=n;this.i=0,this.j=0},Arcfour.prototype.next=function ARC4next(){var e;return this.i=this.i+1&255,this.j=this.j+this.S[this.i]&255,e=this.S[this.i],this.S[this.i]=this.S[this.j],this.S[this.j]=e,this.S[e+this.S[this.i]&255]};var T,U,D,L=256;\n/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */function rng_seed_time(){!function rng_seed_int(e){U[D++]^=255&e,U[D++]^=e>>8&255,U[D++]^=e>>16&255,U[D++]^=e>>24&255,D>=L&&(D-=L)}((new Date).getTime())}if(null==U){var M;if(U=new Array,D=0,void 0!==p&&(void 0!==p.crypto||void 0!==p.msCrypto)){var N=p.crypto||p.msCrypto;if(N.getRandomValues){var O=new Uint8Array(32);for(N.getRandomValues(O),M=0;M<32;++M)U[D++]=O[M]}else if(\"Netscape\"==u.appName&&u.appVersion<\"5\"){var H=p.crypto.random(32);for(M=0;M<H.length;++M)U[D++]=255&H.charCodeAt(M)}}for(;D<L;)M=Math.floor(65536*Math.random()),U[D++]=M>>>8,U[D++]=255&M;D=0,rng_seed_time()}function rng_get_byte(){if(null==T){for(rng_seed_time(),(T=function prng_newstate(){return new Arcfour}()).init(U),D=0;D<U.length;++D)U[D]=0;D=0}return T.next()}function SecureRandom(){}\n/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */\nfunction parseBigInt(e,t){return new BigInteger(e,t)}function oaep_mgf1_arr(e,t,r){for(var n=\"\",i=0;n.length<t;)n+=r(String.fromCharCode.apply(String,e.concat([(4278190080&i)>>24,(16711680&i)>>16,(65280&i)>>8,255&i]))),i+=1;return n}function RSAKey(){this.n=null,this.e=0,this.d=null,this.p=null,this.q=null,this.dmp1=null,this.dmq1=null,this.coeff=null}\n/*! (c) Tom Wu | http://www-cs-students.stanford.edu/~tjw/jsbn/\n */\nfunction ECFieldElementFp(e,t){this.x=t,this.q=e}function ECPointFp(e,t,r,n){this.curve=e,this.x=t,this.y=r,this.z=null==n?BigInteger.ONE:n,this.zinv=null}function ECCurveFp(e,t,r){this.q=e,this.a=this.fromBigInteger(t),this.b=this.fromBigInteger(r),this.infinity=new ECPointFp(this,null,null)}SecureRandom.prototype.nextBytes=function rng_get_bytes(e){var t;for(t=0;t<e.length;++t)e[t]=rng_get_byte()},RSAKey.prototype.doPublic=function RSADoPublic(e){return e.modPowInt(this.e,this.n)},RSAKey.prototype.setPublic=function RSASetPublic(e,t){if(this.isPublic=!0,this.isPrivate=!1,\"string\"!=typeof e)this.n=e,this.e=t;else{if(!(null!=e&&null!=t&&e.length>0&&t.length>0))throw\"Invalid RSA public key\";this.n=parseBigInt(e,16),this.e=parseInt(t,16)}},RSAKey.prototype.encrypt=function RSAEncrypt(e){var t=function pkcs1pad2(e,t){if(t<e.length+11)throw\"Message too long for RSA\";for(var r=new Array,n=e.length-1;n>=0&&t>0;){var i=e.charCodeAt(n--);i<128?r[--t]=i:i>127&&i<2048?(r[--t]=63&i|128,r[--t]=i>>6|192):(r[--t]=63&i|128,r[--t]=i>>6&63|128,r[--t]=i>>12|224)}r[--t]=0;for(var o=new SecureRandom,s=new Array;t>2;){for(s[0]=0;0==s[0];)o.nextBytes(s);r[--t]=s[0]}return r[--t]=2,r[--t]=0,new BigInteger(r)}(e,this.n.bitLength()+7>>3);if(null==t)return null;var r=this.doPublic(t);if(null==r)return null;var n=r.toString(16);return 0==(1&n.length)?n:\"0\"+n},RSAKey.prototype.encryptOAEP=function RSAEncryptOAEP(e,t,r){var n=function oaep_pad(e,t,r,n){var i=V.crypto.MessageDigest,o=V.crypto.Util,s=null;if(r||(r=\"sha1\"),\"string\"==typeof r&&(s=i.getCanonicalAlgName(r),n=i.getHashLength(s),r=function f(e){return hextorstr(o.hashHex(rstrtohex(e),s))}),e.length+2*n+2>t)throw\"Message too long for RSA\";var a,u=\"\";for(a=0;a<t-e.length-2*n-2;a+=1)u+=\"\\0\";var c=r(\"\")+u+\"\u0001\"+e,h=new Array(n);(new SecureRandom).nextBytes(h);var l=oaep_mgf1_arr(h,c.length,r),g=[];for(a=0;a<c.length;a+=1)g[a]=c.charCodeAt(a)^l.charCodeAt(a);var p=oaep_mgf1_arr(g,h.length,r),d=[0];for(a=0;a<h.length;a+=1)d[a+1]=h[a]^p.charCodeAt(a);return new BigInteger(d.concat(g))}(e,this.n.bitLength()+7>>3,t,r);if(null==n)return null;var i=this.doPublic(n);if(null==i)return null;var o=i.toString(16);return 0==(1&o.length)?o:\"0\"+o},RSAKey.prototype.type=\"RSA\",ECFieldElementFp.prototype.equals=function feFpEquals(e){return e==this||this.q.equals(e.q)&&this.x.equals(e.x)},ECFieldElementFp.prototype.toBigInteger=function feFpToBigInteger(){return this.x},ECFieldElementFp.prototype.negate=function feFpNegate(){return new ECFieldElementFp(this.q,this.x.negate().mod(this.q))},ECFieldElementFp.prototype.add=function feFpAdd(e){return new ECFieldElementFp(this.q,this.x.add(e.toBigInteger()).mod(this.q))},ECFieldElementFp.prototype.subtract=function feFpSubtract(e){return new ECFieldElementFp(this.q,this.x.subtract(e.toBigInteger()).mod(this.q))},ECFieldElementFp.prototype.multiply=function feFpMultiply(e){return new ECFieldElementFp(this.q,this.x.multiply(e.toBigInteger()).mod(this.q))},ECFieldElementFp.prototype.square=function feFpSquare(){return new ECFieldElementFp(this.q,this.x.square().mod(this.q))},ECFieldElementFp.prototype.divide=function feFpDivide(e){return new ECFieldElementFp(this.q,this.x.multiply(e.toBigInteger().modInverse(this.q)).mod(this.q))},ECPointFp.prototype.getX=function pointFpGetX(){return null==this.zinv&&(this.zinv=this.z.modInverse(this.curve.q)),this.curve.fromBigInteger(this.x.toBigInteger().multiply(this.zinv).mod(this.curve.q))},ECPointFp.prototype.getY=function pointFpGetY(){return null==this.zinv&&(this.zinv=this.z.modInverse(this.curve.q)),this.curve.fromBigInteger(this.y.toBigInteger().multiply(this.zinv).mod(this.curve.q))},ECPointFp.prototype.equals=function pointFpEquals(e){return e==this||(this.isInfinity()?e.isInfinity():e.isInfinity()?this.isInfinity():!!e.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(e.z)).mod(this.curve.q).equals(BigInteger.ZERO)&&e.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(e.z)).mod(this.curve.q).equals(BigInteger.ZERO))},ECPointFp.prototype.isInfinity=function pointFpIsInfinity(){return null==this.x&&null==this.y||this.z.equals(BigInteger.ZERO)&&!this.y.toBigInteger().equals(BigInteger.ZERO)},ECPointFp.prototype.negate=function pointFpNegate(){return new ECPointFp(this.curve,this.x,this.y.negate(),this.z)},ECPointFp.prototype.add=function pointFpAdd(e){if(this.isInfinity())return e;if(e.isInfinity())return this;var t=e.y.toBigInteger().multiply(this.z).subtract(this.y.toBigInteger().multiply(e.z)).mod(this.curve.q),r=e.x.toBigInteger().multiply(this.z).subtract(this.x.toBigInteger().multiply(e.z)).mod(this.curve.q);if(BigInteger.ZERO.equals(r))return BigInteger.ZERO.equals(t)?this.twice():this.curve.getInfinity();var n=new BigInteger(\"3\"),i=this.x.toBigInteger(),o=this.y.toBigInteger(),s=(e.x.toBigInteger(),e.y.toBigInteger(),r.square()),a=s.multiply(r),u=i.multiply(s),c=t.square().multiply(this.z),h=c.subtract(u.shiftLeft(1)).multiply(e.z).subtract(a).multiply(r).mod(this.curve.q),l=u.multiply(n).multiply(t).subtract(o.multiply(a)).subtract(c.multiply(t)).multiply(e.z).add(t.multiply(a)).mod(this.curve.q),f=a.multiply(this.z).multiply(e.z).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(h),this.curve.fromBigInteger(l),f)},ECPointFp.prototype.twice=function pointFpTwice(){if(this.isInfinity())return this;if(0==this.y.toBigInteger().signum())return this.curve.getInfinity();var e=new BigInteger(\"3\"),t=this.x.toBigInteger(),r=this.y.toBigInteger(),n=r.multiply(this.z),i=n.multiply(r).mod(this.curve.q),o=this.curve.a.toBigInteger(),s=t.square().multiply(e);BigInteger.ZERO.equals(o)||(s=s.add(this.z.square().multiply(o)));var a=(s=s.mod(this.curve.q)).square().subtract(t.shiftLeft(3).multiply(i)).shiftLeft(1).multiply(n).mod(this.curve.q),u=s.multiply(e).multiply(t).subtract(i.shiftLeft(1)).shiftLeft(2).multiply(i).subtract(s.square().multiply(s)).mod(this.curve.q),c=n.square().multiply(n).shiftLeft(3).mod(this.curve.q);return new ECPointFp(this.curve,this.curve.fromBigInteger(a),this.curve.fromBigInteger(u),c)},ECPointFp.prototype.multiply=function pointFpMultiply(e){if(this.isInfinity())return this;if(0==e.signum())return this.curve.getInfinity();var t,r=e,n=r.multiply(new BigInteger(\"3\")),i=this.negate(),o=this;for(t=n.bitLength()-2;t>0;--t){o=o.twice();var s=n.testBit(t);s!=r.testBit(t)&&(o=o.add(s?this:i))}return o},ECPointFp.prototype.multiplyTwo=function pointFpMultiplyTwo(e,t,r){var n;n=e.bitLength()>r.bitLength()?e.bitLength()-1:r.bitLength()-1;for(var i=this.curve.getInfinity(),o=this.add(t);n>=0;)i=i.twice(),e.testBit(n)?i=r.testBit(n)?i.add(o):i.add(this):r.testBit(n)&&(i=i.add(t)),--n;return i},ECCurveFp.prototype.getQ=function curveFpGetQ(){return this.q},ECCurveFp.prototype.getA=function curveFpGetA(){return this.a},ECCurveFp.prototype.getB=function curveFpGetB(){return this.b},ECCurveFp.prototype.equals=function curveFpEquals(e){return e==this||this.q.equals(e.q)&&this.a.equals(e.a)&&this.b.equals(e.b)},ECCurveFp.prototype.getInfinity=function curveFpGetInfinity(){return this.infinity},ECCurveFp.prototype.fromBigInteger=function curveFpFromBigInteger(e){return new ECFieldElementFp(this.q,e)},ECCurveFp.prototype.decodePointHex=function curveFpDecodePointHex(e){switch(parseInt(e.substr(0,2),16)){case 0:return this.infinity;case 2:case 3:return null;case 4:case 6:case 7:var t=(e.length-2)/2,r=e.substr(2,t),n=e.substr(t+2,t);return new ECPointFp(this,this.fromBigInteger(new BigInteger(r,16)),this.fromBigInteger(new BigInteger(n,16)));default:return null}},\n/*! (c) Stefan Thomas | https://github.com/bitcoinjs/bitcoinjs-lib\n */\nECFieldElementFp.prototype.getByteLength=function(){return Math.floor((this.toBigInteger().bitLength()+7)/8)},ECPointFp.prototype.getEncoded=function(e){var t=function d(e,t){var r=e.toByteArrayUnsigned();if(t<r.length)r=r.slice(r.length-t);else for(;t>r.length;)r.unshift(0);return r},r=this.getX().toBigInteger(),n=this.getY().toBigInteger(),i=t(r,32);return e?n.isEven()?i.unshift(2):i.unshift(3):(i.unshift(4),i=i.concat(t(n,32))),i},ECPointFp.decodeFrom=function(e,t){t[0];var r=t.length-1,n=t.slice(1,1+r/2),i=t.slice(1+r/2,1+r);n.unshift(0),i.unshift(0);var o=new BigInteger(n),s=new BigInteger(i);return new ECPointFp(e,e.fromBigInteger(o),e.fromBigInteger(s))},ECPointFp.decodeFromHex=function(e,t){t.substr(0,2);var r=t.length-2,n=t.substr(2,r/2),i=t.substr(2+r/2,r/2),o=new BigInteger(n,16),s=new BigInteger(i,16);return new ECPointFp(e,e.fromBigInteger(o),e.fromBigInteger(s))},ECPointFp.prototype.add2D=function(e){if(this.isInfinity())return e;if(e.isInfinity())return this;if(this.x.equals(e.x))return this.y.equals(e.y)?this.twice():this.curve.getInfinity();var t=e.x.subtract(this.x),r=e.y.subtract(this.y).divide(t),n=r.square().subtract(this.x).subtract(e.x),i=r.multiply(this.x.subtract(n)).subtract(this.y);return new ECPointFp(this.curve,n,i)},ECPointFp.prototype.twice2D=function(){if(this.isInfinity())return this;if(0==this.y.toBigInteger().signum())return this.curve.getInfinity();var e=this.curve.fromBigInteger(BigInteger.valueOf(2)),t=this.curve.fromBigInteger(BigInteger.valueOf(3)),r=this.x.square().multiply(t).add(this.curve.a).divide(this.y.multiply(e)),n=r.square().subtract(this.x.multiply(e)),i=r.multiply(this.x.subtract(n)).subtract(this.y);return new ECPointFp(this.curve,n,i)},ECPointFp.prototype.multiply2D=function(e){if(this.isInfinity())return this;if(0==e.signum())return this.curve.getInfinity();var t,r=e,n=r.multiply(new BigInteger(\"3\")),i=this.negate(),o=this;for(t=n.bitLength()-2;t>0;--t){o=o.twice();var s=n.testBit(t);s!=r.testBit(t)&&(o=o.add2D(s?this:i))}return o},ECPointFp.prototype.isOnCurve=function(){var e=this.getX().toBigInteger(),t=this.getY().toBigInteger(),r=this.curve.getA().toBigInteger(),n=this.curve.getB().toBigInteger(),i=this.curve.getQ(),o=t.multiply(t).mod(i),s=e.multiply(e).multiply(e).add(r.multiply(e)).add(n).mod(i);return o.equals(s)},ECPointFp.prototype.toString=function(){return\"(\"+this.getX().toBigInteger().toString()+\",\"+this.getY().toBigInteger().toString()+\")\"},ECPointFp.prototype.validate=function(){var e=this.curve.getQ();if(this.isInfinity())throw new Error(\"Point is at infinity.\");var t=this.getX().toBigInteger(),r=this.getY().toBigInteger();if(t.compareTo(BigInteger.ONE)<0||t.compareTo(e.subtract(BigInteger.ONE))>0)throw new Error(\"x coordinate out of bounds\");if(r.compareTo(BigInteger.ONE)<0||r.compareTo(e.subtract(BigInteger.ONE))>0)throw new Error(\"y coordinate out of bounds\");if(!this.isOnCurve())throw new Error(\"Point is not on the curve.\");if(this.multiply(e).isInfinity())throw new Error(\"Point is not a scalar multiple of G.\");return!0};\n/*! Mike Samuel (c) 2009 | code.google.com/p/json-sans-eval\n */\nvar K=function(){var e=new RegExp('(?:false|true|null|[\\\\{\\\\}\\\\[\\\\]]|(?:-?\\\\b(?:0|[1-9][0-9]*)(?:\\\\.[0-9]+)?(?:[eE][+-]?[0-9]+)?\\\\b)|(?:\"(?:[^\\\\0-\\\\x08\\\\x0a-\\\\x1f\"\\\\\\\\]|\\\\\\\\(?:[\"/\\\\\\\\bfnrt]|u[0-9A-Fa-f]{4}))*\"))',\"g\"),t=new RegExp(\"\\\\\\\\(?:([^u])|u(.{4}))\",\"g\"),r={'\"':'\"',\"/\":\"/\",\"\\\\\":\"\\\\\",b:\"\\b\",f:\"\\f\",n:\"\\n\",r:\"\\r\",t:\"\\t\"};function h(e,t,n){return t?r[t]:String.fromCharCode(parseInt(n,16))}var n=new String(\"\"),o=(Object,Array,Object.hasOwnProperty);return function(r,a){var u,c,l=r.match(e),f=l[0],g=!1;\"{\"===f?u={}:\"[\"===f?u=[]:(u=[],g=!0);for(var p=[u],d=1-g,v=l.length;d<v;++d){var y;switch((f=l[d]).charCodeAt(0)){default:(y=p[0])[c||y.length]=+f,c=void 0;break;case 34:if(-1!==(f=f.substring(1,f.length-1)).indexOf(\"\\\\\")&&(f=f.replace(t,h)),y=p[0],!c){if(!(y instanceof Array)){c=f||n;break}c=y.length}y[c]=f,c=void 0;break;case 91:y=p[0],p.unshift(y[c||y.length]=[]),c=void 0;break;case 93:p.shift();break;case 102:(y=p[0])[c||y.length]=!1,c=void 0;break;case 110:(y=p[0])[c||y.length]=null,c=void 0;break;case 116:(y=p[0])[c||y.length]=!0,c=void 0;break;case 123:y=p[0],p.unshift(y[c||y.length]={}),c=void 0;break;case 125:p.shift()}}if(g){if(1!==p.length)throw new Error;u=u[0]}else if(p.length)throw new Error;if(a){u=function s(e,t){var r=e[t];if(r&&\"object\"===(void 0===r?\"undefined\":i(r))){var n=null;for(var u in r)if(o.call(r,u)&&r!==e){var c=s(r,u);void 0!==c?r[u]=c:(n||(n=[]),n.push(u))}if(n)for(var h=n.length;--h>=0;)delete r[n[h]]}return a.call(e,t,r)}({\"\":u},\"\")}return u}}();void 0!==V&&V||(t.KJUR=V={}),void 0!==V.asn1&&V.asn1||(V.asn1={}),V.asn1.ASN1Util=new function(){this.integerToByteHex=function(e){var t=e.toString(16);return t.length%2==1&&(t=\"0\"+t),t},this.bigIntToMinTwosComplementsHex=function(e){var t=e.toString(16);if(\"-\"!=t.substr(0,1))t.length%2==1?t=\"0\"+t:t.match(/^[0-7]/)||(t=\"00\"+t);else{var r=t.substr(1).length;r%2==1?r+=1:t.match(/^[0-7]/)||(r+=2);for(var n=\"\",i=0;i<r;i++)n+=\"f\";t=new BigInteger(n,16).xor(e).add(BigInteger.ONE).toString(16).replace(/^-/,\"\")}return t},this.getPEMStringFromHex=function(e,t){return hextopem(e,t)},this.newObject=function(e){var t=V.asn1,r=t.DERBoolean,n=t.DERInteger,i=t.DERBitString,o=t.DEROctetString,s=t.DERNull,a=t.DERObjectIdentifier,u=t.DEREnumerated,c=t.DERUTF8String,h=t.DERNumericString,l=t.DERPrintableString,f=t.DERTeletexString,g=t.DERIA5String,p=t.DERUTCTime,d=t.DERGeneralizedTime,v=t.DERSequence,y=t.DERSet,m=t.DERTaggedObject,_=t.ASN1Util.newObject,S=Object.keys(e);if(1!=S.length)throw\"key of param shall be only one.\";var b=S[0];if(-1==\":bool:int:bitstr:octstr:null:oid:enum:utf8str:numstr:prnstr:telstr:ia5str:utctime:gentime:seq:set:tag:\".indexOf(\":\"+b+\":\"))throw\"undefined key: \"+b;if(\"bool\"==b)return new r(e[b]);if(\"int\"==b)return new n(e[b]);if(\"bitstr\"==b)return new i(e[b]);if(\"octstr\"==b)return new o(e[b]);if(\"null\"==b)return new s(e[b]);if(\"oid\"==b)return new a(e[b]);if(\"enum\"==b)return new u(e[b]);if(\"utf8str\"==b)return new c(e[b]);if(\"numstr\"==b)return new h(e[b]);if(\"prnstr\"==b)return new l(e[b]);if(\"telstr\"==b)return new f(e[b]);if(\"ia5str\"==b)return new g(e[b]);if(\"utctime\"==b)return new p(e[b]);if(\"gentime\"==b)return new d(e[b]);if(\"seq\"==b){for(var F=e[b],w=[],E=0;E<F.length;E++){var x=_(F[E]);w.push(x)}return new v({array:w})}if(\"set\"==b){for(F=e[b],w=[],E=0;E<F.length;E++){x=_(F[E]);w.push(x)}return new y({array:w})}if(\"tag\"==b){var C=e[b];if(\"[object Array]\"===Object.prototype.toString.call(C)&&3==C.length){var k=_(C[2]);return new m({tag:C[0],explicit:C[1],obj:k})}var A={};if(void 0!==C.explicit&&(A.explicit=C.explicit),void 0!==C.tag&&(A.tag=C.tag),void 0===C.obj)throw\"obj shall be specified for 'tag'.\";return A.obj=_(C.obj),new m(A)}},this.jsonToASN1HEX=function(e){return this.newObject(e).getEncodedHex()}},V.asn1.ASN1Util.oidHexToInt=function(e){for(var t=\"\",r=parseInt(e.substr(0,2),16),n=(t=Math.floor(r/40)+\".\"+r%40,\"\"),i=2;i<e.length;i+=2){var o=(\"00000000\"+parseInt(e.substr(i,2),16).toString(2)).slice(-8);if(n+=o.substr(1,7),\"0\"==o.substr(0,1))t=t+\".\"+new BigInteger(n,2).toString(10),n=\"\"}return t},V.asn1.ASN1Util.oidIntToHex=function(e){var t=function e(t){var r=t.toString(16);return 1==r.length&&(r=\"0\"+r),r},r=function d(e){var r=\"\",n=new BigInteger(e,10).toString(2),i=7-n.length%7;7==i&&(i=0);for(var o=\"\",s=0;s<i;s++)o+=\"0\";n=o+n;for(s=0;s<n.length-1;s+=7){var a=n.substr(s,7);s!=n.length-7&&(a=\"1\"+a),r+=t(parseInt(a,2))}return r};if(!e.match(/^[0-9.]+$/))throw\"malformed oid string: \"+e;var n=\"\",i=e.split(\".\"),o=40*parseInt(i[0])+parseInt(i[1]);n+=t(o),i.splice(0,2);for(var s=0;s<i.length;s++)n+=r(i[s]);return n},V.asn1.ASN1Object=function(){this.getLengthHexFromValue=function(){if(void 0===this.hV||null==this.hV)throw\"this.hV is null or undefined.\";if(this.hV.length%2==1)throw\"value hex must be even length: n=\"+\"\".length+\",v=\"+this.hV;var e=this.hV.length/2,t=e.toString(16);if(t.length%2==1&&(t=\"0\"+t),e<128)return t;var r=t.length/2;if(r>15)throw\"ASN.1 length too long to represent by 8x: n = \"+e.toString(16);return(128+r).toString(16)+t},this.getEncodedHex=function(){return(null==this.hTLV||this.isModified)&&(this.hV=this.getFreshValueHex(),this.hL=this.getLengthHexFromValue(),this.hTLV=this.hT+this.hL+this.hV,this.isModified=!1),this.hTLV},this.getValueHex=function(){return this.getEncodedHex(),this.hV},this.getFreshValueHex=function(){return\"\"}},V.asn1.DERAbstractString=function(e){V.asn1.DERAbstractString.superclass.constructor.call(this);this.getString=function(){return this.s},this.setString=function(e){this.hTLV=null,this.isModified=!0,this.s=e,this.hV=utf8tohex(this.s).toLowerCase()},this.setStringHex=function(e){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(\"string\"==typeof e?this.setString(e):void 0!==e.str?this.setString(e.str):void 0!==e.hex&&this.setStringHex(e.hex))},v.lang.extend(V.asn1.DERAbstractString,V.asn1.ASN1Object),V.asn1.DERAbstractTime=function(e){V.asn1.DERAbstractTime.superclass.constructor.call(this);this.localDateToUTC=function(e){return utc=e.getTime()+6e4*e.getTimezoneOffset(),new Date(utc)},this.formatDate=function(e,t,r){var n=this.zeroPadding,i=this.localDateToUTC(e),o=String(i.getFullYear());\"utc\"==t&&(o=o.substr(2,2));var s=o+n(String(i.getMonth()+1),2)+n(String(i.getDate()),2)+n(String(i.getHours()),2)+n(String(i.getMinutes()),2)+n(String(i.getSeconds()),2);if(!0===r){var a=i.getMilliseconds();if(0!=a){var u=n(String(a),3);s=s+\".\"+(u=u.replace(/[0]+$/,\"\"))}}return s+\"Z\"},this.zeroPadding=function(e,t){return e.length>=t?e:new Array(t-e.length+1).join(\"0\")+e},this.getString=function(){return this.s},this.setString=function(e){this.hTLV=null,this.isModified=!0,this.s=e,this.hV=stohex(e)},this.setByDateValue=function(e,t,r,n,i,o){var s=new Date(Date.UTC(e,t-1,r,n,i,o,0));this.setByDate(s)},this.getFreshValueHex=function(){return this.hV}},v.lang.extend(V.asn1.DERAbstractTime,V.asn1.ASN1Object),V.asn1.DERAbstractStructured=function(e){V.asn1.DERAbstractString.superclass.constructor.call(this);this.setByASN1ObjectArray=function(e){this.hTLV=null,this.isModified=!0,this.asn1Array=e},this.appendASN1Object=function(e){this.hTLV=null,this.isModified=!0,this.asn1Array.push(e)},this.asn1Array=new Array,void 0!==e&&void 0!==e.array&&(this.asn1Array=e.array)},v.lang.extend(V.asn1.DERAbstractStructured,V.asn1.ASN1Object),V.asn1.DERBoolean=function(){V.asn1.DERBoolean.superclass.constructor.call(this),this.hT=\"01\",this.hTLV=\"0101ff\"},v.lang.extend(V.asn1.DERBoolean,V.asn1.ASN1Object),V.asn1.DERInteger=function(e){V.asn1.DERInteger.superclass.constructor.call(this),this.hT=\"02\",this.setByBigInteger=function(e){this.hTLV=null,this.isModified=!0,this.hV=V.asn1.ASN1Util.bigIntToMinTwosComplementsHex(e)},this.setByInteger=function(e){var t=new BigInteger(String(e),10);this.setByBigInteger(t)},this.setValueHex=function(e){this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.bigint?this.setByBigInteger(e.bigint):void 0!==e.int?this.setByInteger(e.int):\"number\"==typeof e?this.setByInteger(e):void 0!==e.hex&&this.setValueHex(e.hex))},v.lang.extend(V.asn1.DERInteger,V.asn1.ASN1Object),V.asn1.DERBitString=function(e){if(void 0!==e&&void 0!==e.obj){var t=V.asn1.ASN1Util.newObject(e.obj);e.hex=\"00\"+t.getEncodedHex()}V.asn1.DERBitString.superclass.constructor.call(this),this.hT=\"03\",this.setHexValueIncludingUnusedBits=function(e){this.hTLV=null,this.isModified=!0,this.hV=e},this.setUnusedBitsAndHexValue=function(e,t){if(e<0||7<e)throw\"unused bits shall be from 0 to 7: u = \"+e;var r=\"0\"+e;this.hTLV=null,this.isModified=!0,this.hV=r+t},this.setByBinaryString=function(e){var t=8-(e=e.replace(/0+$/,\"\")).length%8;8==t&&(t=0);for(var r=0;r<=t;r++)e+=\"0\";var n=\"\";for(r=0;r<e.length-1;r+=8){var i=e.substr(r,8),o=parseInt(i,2).toString(16);1==o.length&&(o=\"0\"+o),n+=o}this.hTLV=null,this.isModified=!0,this.hV=\"0\"+t+n},this.setByBooleanArray=function(e){for(var t=\"\",r=0;r<e.length;r++)1==e[r]?t+=\"1\":t+=\"0\";this.setByBinaryString(t)},this.newFalseArray=function(e){for(var t=new Array(e),r=0;r<e;r++)t[r]=!1;return t},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(\"string\"==typeof e&&e.toLowerCase().match(/^[0-9a-f]+$/)?this.setHexValueIncludingUnusedBits(e):void 0!==e.hex?this.setHexValueIncludingUnusedBits(e.hex):void 0!==e.bin?this.setByBinaryString(e.bin):void 0!==e.array&&this.setByBooleanArray(e.array))},v.lang.extend(V.asn1.DERBitString,V.asn1.ASN1Object),V.asn1.DEROctetString=function(e){if(void 0!==e&&void 0!==e.obj){var t=V.asn1.ASN1Util.newObject(e.obj);e.hex=t.getEncodedHex()}V.asn1.DEROctetString.superclass.constructor.call(this,e),this.hT=\"04\"},v.lang.extend(V.asn1.DEROctetString,V.asn1.DERAbstractString),V.asn1.DERNull=function(){V.asn1.DERNull.superclass.constructor.call(this),this.hT=\"05\",this.hTLV=\"0500\"},v.lang.extend(V.asn1.DERNull,V.asn1.ASN1Object),V.asn1.DERObjectIdentifier=function(e){var t=function b(e){var t=e.toString(16);return 1==t.length&&(t=\"0\"+t),t},r=function a(e){var r=\"\",n=new BigInteger(e,10).toString(2),i=7-n.length%7;7==i&&(i=0);for(var o=\"\",s=0;s<i;s++)o+=\"0\";n=o+n;for(s=0;s<n.length-1;s+=7){var u=n.substr(s,7);s!=n.length-7&&(u=\"1\"+u),r+=t(parseInt(u,2))}return r};V.asn1.DERObjectIdentifier.superclass.constructor.call(this),this.hT=\"06\",this.setValueHex=function(e){this.hTLV=null,this.isModified=!0,this.s=null,this.hV=e},this.setValueOidString=function(e){if(!e.match(/^[0-9.]+$/))throw\"malformed oid string: \"+e;var n=\"\",i=e.split(\".\"),o=40*parseInt(i[0])+parseInt(i[1]);n+=t(o),i.splice(0,2);for(var s=0;s<i.length;s++)n+=r(i[s]);this.hTLV=null,this.isModified=!0,this.s=null,this.hV=n},this.setValueName=function(e){var t=V.asn1.x509.OID.name2oid(e);if(\"\"===t)throw\"DERObjectIdentifier oidName undefined: \"+e;this.setValueOidString(t)},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(\"string\"==typeof e?e.match(/^[0-2].[0-9.]+$/)?this.setValueOidString(e):this.setValueName(e):void 0!==e.oid?this.setValueOidString(e.oid):void 0!==e.hex?this.setValueHex(e.hex):void 0!==e.name&&this.setValueName(e.name))},v.lang.extend(V.asn1.DERObjectIdentifier,V.asn1.ASN1Object),V.asn1.DEREnumerated=function(e){V.asn1.DEREnumerated.superclass.constructor.call(this),this.hT=\"0a\",this.setByBigInteger=function(e){this.hTLV=null,this.isModified=!0,this.hV=V.asn1.ASN1Util.bigIntToMinTwosComplementsHex(e)},this.setByInteger=function(e){var t=new BigInteger(String(e),10);this.setByBigInteger(t)},this.setValueHex=function(e){this.hV=e},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.int?this.setByInteger(e.int):\"number\"==typeof e?this.setByInteger(e):void 0!==e.hex&&this.setValueHex(e.hex))},v.lang.extend(V.asn1.DEREnumerated,V.asn1.ASN1Object),V.asn1.DERUTF8String=function(e){V.asn1.DERUTF8String.superclass.constructor.call(this,e),this.hT=\"0c\"},v.lang.extend(V.asn1.DERUTF8String,V.asn1.DERAbstractString),V.asn1.DERNumericString=function(e){V.asn1.DERNumericString.superclass.constructor.call(this,e),this.hT=\"12\"},v.lang.extend(V.asn1.DERNumericString,V.asn1.DERAbstractString),V.asn1.DERPrintableString=function(e){V.asn1.DERPrintableString.superclass.constructor.call(this,e),this.hT=\"13\"},v.lang.extend(V.asn1.DERPrintableString,V.asn1.DERAbstractString),V.asn1.DERTeletexString=function(e){V.asn1.DERTeletexString.superclass.constructor.call(this,e),this.hT=\"14\"},v.lang.extend(V.asn1.DERTeletexString,V.asn1.DERAbstractString),V.asn1.DERIA5String=function(e){V.asn1.DERIA5String.superclass.constructor.call(this,e),this.hT=\"16\"},v.lang.extend(V.asn1.DERIA5String,V.asn1.DERAbstractString),V.asn1.DERUTCTime=function(e){V.asn1.DERUTCTime.superclass.constructor.call(this,e),this.hT=\"17\",this.setByDate=function(e){this.hTLV=null,this.isModified=!0,this.date=e,this.s=this.formatDate(this.date,\"utc\"),this.hV=stohex(this.s)},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,\"utc\"),this.hV=stohex(this.s)),this.hV},void 0!==e&&(void 0!==e.str?this.setString(e.str):\"string\"==typeof e&&e.match(/^[0-9]{12}Z$/)?this.setString(e):void 0!==e.hex?this.setStringHex(e.hex):void 0!==e.date&&this.setByDate(e.date))},v.lang.extend(V.asn1.DERUTCTime,V.asn1.DERAbstractTime),V.asn1.DERGeneralizedTime=function(e){V.asn1.DERGeneralizedTime.superclass.constructor.call(this,e),this.hT=\"18\",this.withMillis=!1,this.setByDate=function(e){this.hTLV=null,this.isModified=!0,this.date=e,this.s=this.formatDate(this.date,\"gen\",this.withMillis),this.hV=stohex(this.s)},this.getFreshValueHex=function(){return void 0===this.date&&void 0===this.s&&(this.date=new Date,this.s=this.formatDate(this.date,\"gen\",this.withMillis),this.hV=stohex(this.s)),this.hV},void 0!==e&&(void 0!==e.str?this.setString(e.str):\"string\"==typeof e&&e.match(/^[0-9]{14}Z$/)?this.setString(e):void 0!==e.hex?this.setStringHex(e.hex):void 0!==e.date&&this.setByDate(e.date),!0===e.millis&&(this.withMillis=!0))},v.lang.extend(V.asn1.DERGeneralizedTime,V.asn1.DERAbstractTime),V.asn1.DERSequence=function(e){V.asn1.DERSequence.superclass.constructor.call(this,e),this.hT=\"30\",this.getFreshValueHex=function(){for(var e=\"\",t=0;t<this.asn1Array.length;t++){e+=this.asn1Array[t].getEncodedHex()}return this.hV=e,this.hV}},v.lang.extend(V.asn1.DERSequence,V.asn1.DERAbstractStructured),V.asn1.DERSet=function(e){V.asn1.DERSet.superclass.constructor.call(this,e),this.hT=\"31\",this.sortFlag=!0,this.getFreshValueHex=function(){for(var e=new Array,t=0;t<this.asn1Array.length;t++){var r=this.asn1Array[t];e.push(r.getEncodedHex())}return 1==this.sortFlag&&e.sort(),this.hV=e.join(\"\"),this.hV},void 0!==e&&void 0!==e.sortflag&&0==e.sortflag&&(this.sortFlag=!1)},v.lang.extend(V.asn1.DERSet,V.asn1.DERAbstractStructured),V.asn1.DERTaggedObject=function(e){V.asn1.DERTaggedObject.superclass.constructor.call(this),this.hT=\"a0\",this.hV=\"\",this.isExplicit=!0,this.asn1Object=null,this.setASN1Object=function(e,t,r){this.hT=t,this.isExplicit=e,this.asn1Object=r,this.isExplicit?(this.hV=this.asn1Object.getEncodedHex(),this.hTLV=null,this.isModified=!0):(this.hV=null,this.hTLV=r.getEncodedHex(),this.hTLV=this.hTLV.replace(/^../,t),this.isModified=!1)},this.getFreshValueHex=function(){return this.hV},void 0!==e&&(void 0!==e.tag&&(this.hT=e.tag),void 0!==e.explicit&&(this.isExplicit=e.explicit),void 0!==e.obj&&(this.asn1Object=e.obj,this.setASN1Object(this.isExplicit,this.hT,this.asn1Object)))},v.lang.extend(V.asn1.DERTaggedObject,V.asn1.ASN1Object);var V,q,W,J=new function(){};function stoBA(e){for(var t=new Array,r=0;r<e.length;r++)t[r]=e.charCodeAt(r);return t}function BAtos(e){for(var t=\"\",r=0;r<e.length;r++)t+=String.fromCharCode(e[r]);return t}function BAtohex(e){for(var t=\"\",r=0;r<e.length;r++){var n=e[r].toString(16);1==n.length&&(n=\"0\"+n),t+=n}return t}function stohex(e){return BAtohex(stoBA(e))}function b64tob64u(e){return e=(e=(e=e.replace(/\\=/g,\"\")).replace(/\\+/g,\"-\")).replace(/\\//g,\"_\")}function b64utob64(e){return e.length%4==2?e+=\"==\":e.length%4==3&&(e+=\"=\"),e=(e=e.replace(/-/g,\"+\")).replace(/_/g,\"/\")}function hextob64u(e){return e.length%2==1&&(e=\"0\"+e),b64tob64u(hex2b64(e))}function b64utohex(e){return b64tohex(b64utob64(e))}function utf8tohex(e){return uricmptohex(encodeURIComponentAll(e))}function hextoutf8(e){return decodeURIComponent(hextouricmp(e))}function hextorstr(e){for(var t=\"\",r=0;r<e.length-1;r+=2)t+=String.fromCharCode(parseInt(e.substr(r,2),16));return t}function rstrtohex(e){for(var t=\"\",r=0;r<e.length;r++)t+=(\"0\"+e.charCodeAt(r).toString(16)).slice(-2);return t}function hextob64(e){return hex2b64(e)}function hextob64nl(e){var t=hextob64(e).replace(/(.{64})/g,\"$1\\r\\n\");return t=t.replace(/\\r\\n$/,\"\")}function b64nltohex(e){return b64tohex(e.replace(/[^0-9A-Za-z\\/+=]*/g,\"\"))}function hextopem(e,t){return\"-----BEGIN \"+t+\"-----\\r\\n\"+hextob64nl(e)+\"\\r\\n-----END \"+t+\"-----\\r\\n\"}function pemtohex(e,t){if(-1==e.indexOf(\"-----BEGIN \"))throw\"can't find PEM header: \"+t;return b64nltohex(e=void 0!==t?(e=e.replace(\"-----BEGIN \"+t+\"-----\",\"\")).replace(\"-----END \"+t+\"-----\",\"\"):(e=e.replace(/-----BEGIN [^-]+-----/,\"\")).replace(/-----END [^-]+-----/,\"\"))}function zulutomsec(e){var t,r,n,i,o,s,a,u,c,h,l;if(l=e.match(/^(\\d{2}|\\d{4})(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)(\\d\\d)(|\\.\\d+)Z$/))return u=l[1],t=parseInt(u),2===u.length&&(50<=t&&t<100?t=1900+t:0<=t&&t<50&&(t=2e3+t)),r=parseInt(l[2])-1,n=parseInt(l[3]),i=parseInt(l[4]),o=parseInt(l[5]),s=parseInt(l[6]),a=0,\"\"!==(c=l[7])&&(h=(c.substr(1)+\"00\").substr(0,3),a=parseInt(h)),Date.UTC(t,r,n,i,o,s,a);throw\"unsupported zulu format: \"+e}function zulutosec(e){return~~(zulutomsec(e)/1e3)}function uricmptohex(e){return e.replace(/%/g,\"\")}function hextouricmp(e){return e.replace(/(..)/g,\"%$1\")}function ipv6tohex(e){var t=\"malformed IPv6 address\";if(!e.match(/^[0-9A-Fa-f:]+$/))throw t;var r=(e=e.toLowerCase()).split(\":\").length-1;if(r<2)throw t;var n=\":\".repeat(7-r+2),i=(e=e.replace(\"::\",n)).split(\":\");if(8!=i.length)throw t;for(var o=0;o<8;o++)i[o]=(\"0000\"+i[o]).slice(-4);return i.join(\"\")}function hextoipv6(e){if(!e.match(/^[0-9A-Fa-f]{32}$/))throw\"malformed IPv6 address octet\";for(var t=(e=e.toLowerCase()).match(/.{1,4}/g),r=0;r<8;r++)t[r]=t[r].replace(/^0+/,\"\"),\"\"==t[r]&&(t[r]=\"0\");var n=(e=\":\"+t.join(\":\")+\":\").match(/:(0:){2,}/g);if(null===n)return e.slice(1,-1);var i=\"\";for(r=0;r<n.length;r++)n[r].length>i.length&&(i=n[r]);return(e=e.replace(i,\"::\")).slice(1,-1)}function hextoip(e){var t=\"malformed hex value\";if(!e.match(/^([0-9A-Fa-f][0-9A-Fa-f]){1,}$/))throw t;if(8!=e.length)return 32==e.length?hextoipv6(e):e;try{return parseInt(e.substr(0,2),16)+\".\"+parseInt(e.substr(2,2),16)+\".\"+parseInt(e.substr(4,2),16)+\".\"+parseInt(e.substr(6,2),16)}catch(e){throw t}}function encodeURIComponentAll(e){for(var t=encodeURIComponent(e),r=\"\",n=0;n<t.length;n++)\"%\"==t[n]?(r+=t.substr(n,3),n+=2):r=r+\"%\"+stohex(t[n]);return r}function hextoposhex(e){return e.length%2==1?\"0\"+e:e.substr(0,1)>\"7\"?\"00\"+e:e}J.getLblen=function(e,t){if(\"8\"!=e.substr(t+2,1))return 1;var r=parseInt(e.substr(t+3,1));return 0==r?-1:0<r&&r<10?r+1:-2},J.getL=function(e,t){var r=J.getLblen(e,t);return r<1?\"\":e.substr(t+2,2*r)},J.getVblen=function(e,t){var r;return\"\"==(r=J.getL(e,t))?-1:(\"8\"===r.substr(0,1)?new BigInteger(r.substr(2),16):new BigInteger(r,16)).intValue()},J.getVidx=function(e,t){var r=J.getLblen(e,t);return r<0?r:t+2*(r+1)},J.getV=function(e,t){var r=J.getVidx(e,t),n=J.getVblen(e,t);return e.substr(r,2*n)},J.getTLV=function(e,t){return e.substr(t,2)+J.getL(e,t)+J.getV(e,t)},J.getNextSiblingIdx=function(e,t){return J.getVidx(e,t)+2*J.getVblen(e,t)},J.getChildIdx=function(e,t){var r=J,n=new Array,i=r.getVidx(e,t);\"03\"==e.substr(t,2)?n.push(i+2):n.push(i);for(var o=r.getVblen(e,t),s=i,a=0;;){var u=r.getNextSiblingIdx(e,s);if(null==u||u-i>=2*o)break;if(a>=200)break;n.push(u),s=u,a++}return n},J.getNthChildIdx=function(e,t,r){return J.getChildIdx(e,t)[r]},J.getIdxbyList=function(e,t,r,n){var i,o,s=J;if(0==r.length){if(void 0!==n&&e.substr(t,2)!==n)throw\"checking tag doesn't match: \"+e.substr(t,2)+\"!=\"+n;return t}return i=r.shift(),o=s.getChildIdx(e,t),s.getIdxbyList(e,o[i],r,n)},J.getTLVbyList=function(e,t,r,n){var i=J,o=i.getIdxbyList(e,t,r);if(void 0===o)throw\"can't find nthList object\";if(void 0!==n&&e.substr(o,2)!=n)throw\"checking tag doesn't match: \"+e.substr(o,2)+\"!=\"+n;return i.getTLV(e,o)},J.getVbyList=function(e,t,r,n,i){var o,s,a=J;if(void 0===(o=a.getIdxbyList(e,t,r,n)))throw\"can't find nthList object\";return s=a.getV(e,o),!0===i&&(s=s.substr(2)),s},J.hextooidstr=function(e){var t=function h(e,t){return e.length>=t?e:new Array(t-e.length+1).join(\"0\")+e},r=[],n=e.substr(0,2),i=parseInt(n,16);r[0]=new String(Math.floor(i/40)),r[1]=new String(i%40);for(var o=e.substr(2),s=[],a=0;a<o.length/2;a++)s.push(parseInt(o.substr(2*a,2),16));var u=[],c=\"\";for(a=0;a<s.length;a++)128&s[a]?c+=t((127&s[a]).toString(2),7):(c+=t((127&s[a]).toString(2),7),u.push(new String(parseInt(c,2))),c=\"\");var h=r.join(\".\");return u.length>0&&(h=h+\".\"+u.join(\".\")),h},J.dump=function(e,t,r,n){var i=J,o=i.getV,s=i.dump,a=i.getChildIdx,u=e;e instanceof V.asn1.ASN1Object&&(u=e.getEncodedHex());var c=function q(e,t){return e.length<=2*t?e:e.substr(0,t)+\"..(total \"+e.length/2+\"bytes)..\"+e.substr(e.length-t,t)};void 0===t&&(t={ommit_long_octet:32}),void 0===r&&(r=0),void 0===n&&(n=\"\");var h=t.ommit_long_octet;if(\"01\"==u.substr(r,2))return\"00\"==(l=o(u,r))?n+\"BOOLEAN FALSE\\n\":n+\"BOOLEAN TRUE\\n\";if(\"02\"==u.substr(r,2))return n+\"INTEGER \"+c(l=o(u,r),h)+\"\\n\";if(\"03\"==u.substr(r,2))return n+\"BITSTRING \"+c(l=o(u,r),h)+\"\\n\";if(\"04\"==u.substr(r,2)){var l=o(u,r);if(i.isASN1HEX(l)){var f=n+\"OCTETSTRING, encapsulates\\n\";return f+=s(l,t,0,n+\"  \")}return n+\"OCTETSTRING \"+c(l,h)+\"\\n\"}if(\"05\"==u.substr(r,2))return n+\"NULL\\n\";if(\"06\"==u.substr(r,2)){var g=o(u,r),p=V.asn1.ASN1Util.oidHexToInt(g),d=V.asn1.x509.OID.oid2name(p),v=p.replace(/\\./g,\" \");return\"\"!=d?n+\"ObjectIdentifier \"+d+\" (\"+v+\")\\n\":n+\"ObjectIdentifier (\"+v+\")\\n\"}if(\"0c\"==u.substr(r,2))return n+\"UTF8String '\"+hextoutf8(o(u,r))+\"'\\n\";if(\"13\"==u.substr(r,2))return n+\"PrintableString '\"+hextoutf8(o(u,r))+\"'\\n\";if(\"14\"==u.substr(r,2))return n+\"TeletexString '\"+hextoutf8(o(u,r))+\"'\\n\";if(\"16\"==u.substr(r,2))return n+\"IA5String '\"+hextoutf8(o(u,r))+\"'\\n\";if(\"17\"==u.substr(r,2))return n+\"UTCTime \"+hextoutf8(o(u,r))+\"\\n\";if(\"18\"==u.substr(r,2))return n+\"GeneralizedTime \"+hextoutf8(o(u,r))+\"\\n\";if(\"30\"==u.substr(r,2)){if(\"3000\"==u.substr(r,4))return n+\"SEQUENCE {}\\n\";f=n+\"SEQUENCE\\n\";var y=t;if((2==(S=a(u,r)).length||3==S.length)&&\"06\"==u.substr(S[0],2)&&\"04\"==u.substr(S[S.length-1],2)){d=i.oidname(o(u,S[0]));var m=JSON.parse(JSON.stringify(t));m.x509ExtName=d,y=m}for(var _=0;_<S.length;_++)f+=s(u,y,S[_],n+\"  \");return f}if(\"31\"==u.substr(r,2)){f=n+\"SET\\n\";var S=a(u,r);for(_=0;_<S.length;_++)f+=s(u,t,S[_],n+\"  \");return f}var b=parseInt(u.substr(r,2),16);if(0!=(128&b)){var F=31&b;if(0!=(32&b)){var f=n+\"[\"+F+\"]\\n\";for(S=a(u,r),_=0;_<S.length;_++)f+=s(u,t,S[_],n+\"  \");return f}return\"68747470\"==(l=o(u,r)).substr(0,8)&&(l=hextoutf8(l)),\"subjectAltName\"===t.x509ExtName&&2==F&&(l=hextoutf8(l)),f=n+\"[\"+F+\"] \"+l+\"\\n\"}return n+\"UNKNOWN(\"+u.substr(r,2)+\") \"+o(u,r)+\"\\n\"},J.isASN1HEX=function(e){var t=J;if(e.length%2==1)return!1;var r=t.getVblen(e,0),n=e.substr(0,2),i=t.getL(e,0);return e.length-n.length-i.length==2*r},J.oidname=function(e){var t=V.asn1;V.lang.String.isHex(e)&&(e=t.ASN1Util.oidHexToInt(e));var r=t.x509.OID.oid2name(e);return\"\"===r&&(r=e),r},void 0!==V&&V||(t.KJUR=V={}),void 0!==V.lang&&V.lang||(V.lang={}),V.lang.String=function(){},\"function\"==typeof n?(t.utf8tob64u=q=function utf8tob64u(e){return b64tob64u(new n(e,\"utf8\").toString(\"base64\"))},t.b64utoutf8=W=function b64utoutf8(e){return new n(b64utob64(e),\"base64\").toString(\"utf8\")}):(t.utf8tob64u=q=function utf8tob64u(e){return hextob64u(uricmptohex(encodeURIComponentAll(e)))},t.b64utoutf8=W=function b64utoutf8(e){return decodeURIComponent(hextouricmp(b64utohex(e)))}),V.lang.String.isInteger=function(e){return!!e.match(/^[0-9]+$/)||!!e.match(/^-[0-9]+$/)},V.lang.String.isHex=function(e){return!(e.length%2!=0||!e.match(/^[0-9a-f]+$/)&&!e.match(/^[0-9A-F]+$/))},V.lang.String.isBase64=function(e){return!(!(e=e.replace(/\\s+/g,\"\")).match(/^[0-9A-Za-z+\\/]+={0,3}$/)||e.length%4!=0)},V.lang.String.isBase64URL=function(e){return!e.match(/[+/=]/)&&(e=b64utob64(e),V.lang.String.isBase64(e))},V.lang.String.isIntegerArray=function(e){return!!(e=e.replace(/\\s+/g,\"\")).match(/^\\[[0-9,]+\\]$/)};void 0!==V&&V||(t.KJUR=V={}),void 0!==V.crypto&&V.crypto||(V.crypto={}),V.crypto.Util=new function(){this.DIGESTINFOHEAD={sha1:\"3021300906052b0e03021a05000414\",sha224:\"302d300d06096086480165030402040500041c\",sha256:\"3031300d060960864801650304020105000420\",sha384:\"3041300d060960864801650304020205000430\",sha512:\"3051300d060960864801650304020305000440\",md2:\"3020300c06082a864886f70d020205000410\",md5:\"3020300c06082a864886f70d020505000410\",ripemd160:\"3021300906052b2403020105000414\"},this.DEFAULTPROVIDER={md5:\"cryptojs\",sha1:\"cryptojs\",sha224:\"cryptojs\",sha256:\"cryptojs\",sha384:\"cryptojs\",sha512:\"cryptojs\",ripemd160:\"cryptojs\",hmacmd5:\"cryptojs\",hmacsha1:\"cryptojs\",hmacsha224:\"cryptojs\",hmacsha256:\"cryptojs\",hmacsha384:\"cryptojs\",hmacsha512:\"cryptojs\",hmacripemd160:\"cryptojs\",MD5withRSA:\"cryptojs/jsrsa\",SHA1withRSA:\"cryptojs/jsrsa\",SHA224withRSA:\"cryptojs/jsrsa\",SHA256withRSA:\"cryptojs/jsrsa\",SHA384withRSA:\"cryptojs/jsrsa\",SHA512withRSA:\"cryptojs/jsrsa\",RIPEMD160withRSA:\"cryptojs/jsrsa\",MD5withECDSA:\"cryptojs/jsrsa\",SHA1withECDSA:\"cryptojs/jsrsa\",SHA224withECDSA:\"cryptojs/jsrsa\",SHA256withECDSA:\"cryptojs/jsrsa\",SHA384withECDSA:\"cryptojs/jsrsa\",SHA512withECDSA:\"cryptojs/jsrsa\",RIPEMD160withECDSA:\"cryptojs/jsrsa\",SHA1withDSA:\"cryptojs/jsrsa\",SHA224withDSA:\"cryptojs/jsrsa\",SHA256withDSA:\"cryptojs/jsrsa\",MD5withRSAandMGF1:\"cryptojs/jsrsa\",SHA1withRSAandMGF1:\"cryptojs/jsrsa\",SHA224withRSAandMGF1:\"cryptojs/jsrsa\",SHA256withRSAandMGF1:\"cryptojs/jsrsa\",SHA384withRSAandMGF1:\"cryptojs/jsrsa\",SHA512withRSAandMGF1:\"cryptojs/jsrsa\",RIPEMD160withRSAandMGF1:\"cryptojs/jsrsa\"},this.CRYPTOJSMESSAGEDIGESTNAME={md5:y.algo.MD5,sha1:y.algo.SHA1,sha224:y.algo.SHA224,sha256:y.algo.SHA256,sha384:y.algo.SHA384,sha512:y.algo.SHA512,ripemd160:y.algo.RIPEMD160},this.getDigestInfoHex=function(e,t){if(void 0===this.DIGESTINFOHEAD[t])throw\"alg not supported in Util.DIGESTINFOHEAD: \"+t;return this.DIGESTINFOHEAD[t]+e},this.getPaddedDigestInfoHex=function(e,t,r){var n=this.getDigestInfoHex(e,t),i=r/4;if(n.length+22>i)throw\"key is too short for SigAlg: keylen=\"+r+\",\"+t;for(var o=\"0001\",s=\"00\"+n,a=\"\",u=i-o.length-s.length,c=0;c<u;c+=2)a+=\"ff\";return o+a+s},this.hashString=function(e,t){return new V.crypto.MessageDigest({alg:t}).digestString(e)},this.hashHex=function(e,t){return new V.crypto.MessageDigest({alg:t}).digestHex(e)},this.sha1=function(e){return new V.crypto.MessageDigest({alg:\"sha1\",prov:\"cryptojs\"}).digestString(e)},this.sha256=function(e){return new V.crypto.MessageDigest({alg:\"sha256\",prov:\"cryptojs\"}).digestString(e)},this.sha256Hex=function(e){return new V.crypto.MessageDigest({alg:\"sha256\",prov:\"cryptojs\"}).digestHex(e)},this.sha512=function(e){return new V.crypto.MessageDigest({alg:\"sha512\",prov:\"cryptojs\"}).digestString(e)},this.sha512Hex=function(e){return new V.crypto.MessageDigest({alg:\"sha512\",prov:\"cryptojs\"}).digestHex(e)}},V.crypto.Util.md5=function(e){return new V.crypto.MessageDigest({alg:\"md5\",prov:\"cryptojs\"}).digestString(e)},V.crypto.Util.ripemd160=function(e){return new V.crypto.MessageDigest({alg:\"ripemd160\",prov:\"cryptojs\"}).digestString(e)},V.crypto.Util.SECURERANDOMGEN=new SecureRandom,V.crypto.Util.getRandomHexOfNbytes=function(e){var t=new Array(e);return V.crypto.Util.SECURERANDOMGEN.nextBytes(t),BAtohex(t)},V.crypto.Util.getRandomBigIntegerOfNbytes=function(e){return new BigInteger(V.crypto.Util.getRandomHexOfNbytes(e),16)},V.crypto.Util.getRandomHexOfNbits=function(e){var t=e%8,r=new Array((e-t)/8+1);return V.crypto.Util.SECURERANDOMGEN.nextBytes(r),r[0]=(255<<t&255^255)&r[0],BAtohex(r)},V.crypto.Util.getRandomBigIntegerOfNbits=function(e){return new BigInteger(V.crypto.Util.getRandomHexOfNbits(e),16)},V.crypto.Util.getRandomBigIntegerZeroToMax=function(e){for(var t=e.bitLength();;){var r=V.crypto.Util.getRandomBigIntegerOfNbits(t);if(-1!=e.compareTo(r))return r}},V.crypto.Util.getRandomBigIntegerMinToMax=function(e,t){var r=e.compareTo(t);if(1==r)throw\"biMin is greater than biMax\";if(0==r)return e;var n=t.subtract(e);return V.crypto.Util.getRandomBigIntegerZeroToMax(n).add(e)},V.crypto.MessageDigest=function(e){this.setAlgAndProvider=function(e,t){if(null!==(e=V.crypto.MessageDigest.getCanonicalAlgName(e))&&void 0===t&&(t=V.crypto.Util.DEFAULTPROVIDER[e]),-1!=\":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\".indexOf(e)&&\"cryptojs\"==t){try{this.md=V.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[e].create()}catch(t){throw\"setAlgAndProvider hash alg set fail alg=\"+e+\"/\"+t}this.updateString=function(e){this.md.update(e)},this.updateHex=function(e){var t=y.enc.Hex.parse(e);this.md.update(t)},this.digest=function(){return this.md.finalize().toString(y.enc.Hex)},this.digestString=function(e){return this.updateString(e),this.digest()},this.digestHex=function(e){return this.updateHex(e),this.digest()}}if(-1!=\":sha256:\".indexOf(e)&&\"sjcl\"==t){try{this.md=new sjcl.hash.sha256}catch(t){throw\"setAlgAndProvider hash alg set fail alg=\"+e+\"/\"+t}this.updateString=function(e){this.md.update(e)},this.updateHex=function(e){var t=sjcl.codec.hex.toBits(e);this.md.update(t)},this.digest=function(){var e=this.md.finalize();return sjcl.codec.hex.fromBits(e)},this.digestString=function(e){return this.updateString(e),this.digest()},this.digestHex=function(e){return this.updateHex(e),this.digest()}}},this.updateString=function(e){throw\"updateString(str) not supported for this alg/prov: \"+this.algName+\"/\"+this.provName},this.updateHex=function(e){throw\"updateHex(hex) not supported for this alg/prov: \"+this.algName+\"/\"+this.provName},this.digest=function(){throw\"digest() not supported for this alg/prov: \"+this.algName+\"/\"+this.provName},this.digestString=function(e){throw\"digestString(str) not supported for this alg/prov: \"+this.algName+\"/\"+this.provName},this.digestHex=function(e){throw\"digestHex(hex) not supported for this alg/prov: \"+this.algName+\"/\"+this.provName},void 0!==e&&void 0!==e.alg&&(this.algName=e.alg,void 0===e.prov&&(this.provName=V.crypto.Util.DEFAULTPROVIDER[this.algName]),this.setAlgAndProvider(this.algName,this.provName))},V.crypto.MessageDigest.getCanonicalAlgName=function(e){return\"string\"==typeof e&&(e=(e=e.toLowerCase()).replace(/-/,\"\")),e},V.crypto.MessageDigest.getHashLength=function(e){var t=V.crypto.MessageDigest,r=t.getCanonicalAlgName(e);if(void 0===t.HASHLENGTH[r])throw\"not supported algorithm: \"+e;return t.HASHLENGTH[r]},V.crypto.MessageDigest.HASHLENGTH={md5:16,sha1:20,sha224:28,sha256:32,sha384:48,sha512:64,ripemd160:20},V.crypto.Mac=function(e){this.setAlgAndProvider=function(e,t){if(null==(e=e.toLowerCase())&&(e=\"hmacsha1\"),\"hmac\"!=(e=e.toLowerCase()).substr(0,4))throw\"setAlgAndProvider unsupported HMAC alg: \"+e;void 0===t&&(t=V.crypto.Util.DEFAULTPROVIDER[e]),this.algProv=e+\"/\"+t;var r=e.substr(4);if(-1!=\":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\".indexOf(r)&&\"cryptojs\"==t){try{var n=V.crypto.Util.CRYPTOJSMESSAGEDIGESTNAME[r];this.mac=y.algo.HMAC.create(n,this.pass)}catch(e){throw\"setAlgAndProvider hash alg set fail hashAlg=\"+r+\"/\"+e}this.updateString=function(e){this.mac.update(e)},this.updateHex=function(e){var t=y.enc.Hex.parse(e);this.mac.update(t)},this.doFinal=function(){return this.mac.finalize().toString(y.enc.Hex)},this.doFinalString=function(e){return this.updateString(e),this.doFinal()},this.doFinalHex=function(e){return this.updateHex(e),this.doFinal()}}},this.updateString=function(e){throw\"updateString(str) not supported for this alg/prov: \"+this.algProv},this.updateHex=function(e){throw\"updateHex(hex) not supported for this alg/prov: \"+this.algProv},this.doFinal=function(){throw\"digest() not supported for this alg/prov: \"+this.algProv},this.doFinalString=function(e){throw\"digestString(str) not supported for this alg/prov: \"+this.algProv},this.doFinalHex=function(e){throw\"digestHex(hex) not supported for this alg/prov: \"+this.algProv},this.setPassword=function(e){if(\"string\"==typeof e){var t=e;return e.length%2!=1&&e.match(/^[0-9A-Fa-f]+$/)||(t=rstrtohex(e)),void(this.pass=y.enc.Hex.parse(t))}if(\"object\"!=(void 0===e?\"undefined\":i(e)))throw\"KJUR.crypto.Mac unsupported password type: \"+e;t=null;if(void 0!==e.hex){if(e.hex.length%2!=0||!e.hex.match(/^[0-9A-Fa-f]+$/))throw\"Mac: wrong hex password: \"+e.hex;t=e.hex}if(void 0!==e.utf8&&(t=utf8tohex(e.utf8)),void 0!==e.rstr&&(t=rstrtohex(e.rstr)),void 0!==e.b64&&(t=b64tohex(e.b64)),void 0!==e.b64u&&(t=b64utohex(e.b64u)),null==t)throw\"KJUR.crypto.Mac unsupported password type: \"+e;this.pass=y.enc.Hex.parse(t)},void 0!==e&&(void 0!==e.pass&&this.setPassword(e.pass),void 0!==e.alg&&(this.algName=e.alg,void 0===e.prov&&(this.provName=V.crypto.Util.DEFAULTPROVIDER[this.algName]),this.setAlgAndProvider(this.algName,this.provName)))},V.crypto.Signature=function(e){var t=null;if(this._setAlgNames=function(){var e=this.algName.match(/^(.+)with(.+)$/);e&&(this.mdAlgName=e[1].toLowerCase(),this.pubkeyAlgName=e[2].toLowerCase())},this._zeroPaddingOfSignature=function(e,t){for(var r=\"\",n=t/4-e.length,i=0;i<n;i++)r+=\"0\";return r+e},this.setAlgAndProvider=function(e,t){if(this._setAlgNames(),\"cryptojs/jsrsa\"!=t)throw\"provider not supported: \"+t;if(-1!=\":md5:sha1:sha224:sha256:sha384:sha512:ripemd160:\".indexOf(this.mdAlgName)){try{this.md=new V.crypto.MessageDigest({alg:this.mdAlgName})}catch(e){throw\"setAlgAndProvider hash alg set fail alg=\"+this.mdAlgName+\"/\"+e}this.init=function(e,t){var r=null;try{r=void 0===t?z.getKey(e):z.getKey(e,t)}catch(e){throw\"init failed:\"+e}if(!0===r.isPrivate)this.prvKey=r,this.state=\"SIGN\";else{if(!0!==r.isPublic)throw\"init failed.:\"+r;this.pubKey=r,this.state=\"VERIFY\"}},this.updateString=function(e){this.md.updateString(e)},this.updateHex=function(e){this.md.updateHex(e)},this.sign=function(){if(this.sHashHex=this.md.digest(),void 0!==this.ecprvhex&&void 0!==this.eccurvename){var e=new V.crypto.ECDSA({curve:this.eccurvename});this.hSign=e.signHex(this.sHashHex,this.ecprvhex)}else if(this.prvKey instanceof RSAKey&&\"rsaandmgf1\"===this.pubkeyAlgName)this.hSign=this.prvKey.signWithMessageHashPSS(this.sHashHex,this.mdAlgName,this.pssSaltLen);else if(this.prvKey instanceof RSAKey&&\"rsa\"===this.pubkeyAlgName)this.hSign=this.prvKey.signWithMessageHash(this.sHashHex,this.mdAlgName);else if(this.prvKey instanceof V.crypto.ECDSA)this.hSign=this.prvKey.signWithMessageHash(this.sHashHex);else{if(!(this.prvKey instanceof V.crypto.DSA))throw\"Signature: unsupported private key alg: \"+this.pubkeyAlgName;this.hSign=this.prvKey.signWithMessageHash(this.sHashHex)}return this.hSign},this.signString=function(e){return this.updateString(e),this.sign()},this.signHex=function(e){return this.updateHex(e),this.sign()},this.verify=function(e){if(this.sHashHex=this.md.digest(),void 0!==this.ecpubhex&&void 0!==this.eccurvename)return new V.crypto.ECDSA({curve:this.eccurvename}).verifyHex(this.sHashHex,e,this.ecpubhex);if(this.pubKey instanceof RSAKey&&\"rsaandmgf1\"===this.pubkeyAlgName)return this.pubKey.verifyWithMessageHashPSS(this.sHashHex,e,this.mdAlgName,this.pssSaltLen);if(this.pubKey instanceof RSAKey&&\"rsa\"===this.pubkeyAlgName)return this.pubKey.verifyWithMessageHash(this.sHashHex,e);if(void 0!==V.crypto.ECDSA&&this.pubKey instanceof V.crypto.ECDSA)return this.pubKey.verifyWithMessageHash(this.sHashHex,e);if(void 0!==V.crypto.DSA&&this.pubKey instanceof V.crypto.DSA)return this.pubKey.verifyWithMessageHash(this.sHashHex,e);throw\"Signature: unsupported public key alg: \"+this.pubkeyAlgName}}},this.init=function(e,t){throw\"init(key, pass) not supported for this alg:prov=\"+this.algProvName},this.updateString=function(e){throw\"updateString(str) not supported for this alg:prov=\"+this.algProvName},this.updateHex=function(e){throw\"updateHex(hex) not supported for this alg:prov=\"+this.algProvName},this.sign=function(){throw\"sign() not supported for this alg:prov=\"+this.algProvName},this.signString=function(e){throw\"digestString(str) not supported for this alg:prov=\"+this.algProvName},this.signHex=function(e){throw\"digestHex(hex) not supported for this alg:prov=\"+this.algProvName},this.verify=function(e){throw\"verify(hSigVal) not supported for this alg:prov=\"+this.algProvName},this.initParams=e,void 0!==e&&(void 0!==e.alg&&(this.algName=e.alg,void 0===e.prov?this.provName=V.crypto.Util.DEFAULTPROVIDER[this.algName]:this.provName=e.prov,this.algProvName=this.algName+\":\"+this.provName,this.setAlgAndProvider(this.algName,this.provName),this._setAlgNames()),void 0!==e.psssaltlen&&(this.pssSaltLen=e.psssaltlen),void 0!==e.prvkeypem)){if(void 0!==e.prvkeypas)throw\"both prvkeypem and prvkeypas parameters not supported\";try{t=z.getKey(e.prvkeypem);this.init(t)}catch(e){throw\"fatal error to load pem private key: \"+e}}},V.crypto.Cipher=function(e){},V.crypto.Cipher.encrypt=function(e,t,r){if(t instanceof RSAKey&&t.isPublic){var n=V.crypto.Cipher.getAlgByKeyAndName(t,r);if(\"RSA\"===n)return t.encrypt(e);if(\"RSAOAEP\"===n)return t.encryptOAEP(e,\"sha1\");var i=n.match(/^RSAOAEP(\\d+)$/);if(null!==i)return t.encryptOAEP(e,\"sha\"+i[1]);throw\"Cipher.encrypt: unsupported algorithm for RSAKey: \"+r}throw\"Cipher.encrypt: unsupported key or algorithm\"},V.crypto.Cipher.decrypt=function(e,t,r){if(t instanceof RSAKey&&t.isPrivate){var n=V.crypto.Cipher.getAlgByKeyAndName(t,r);if(\"RSA\"===n)return t.decrypt(e);if(\"RSAOAEP\"===n)return t.decryptOAEP(e,\"sha1\");var i=n.match(/^RSAOAEP(\\d+)$/);if(null!==i)return t.decryptOAEP(e,\"sha\"+i[1]);throw\"Cipher.decrypt: unsupported algorithm for RSAKey: \"+r}throw\"Cipher.decrypt: unsupported key or algorithm\"},V.crypto.Cipher.getAlgByKeyAndName=function(e,t){if(e instanceof RSAKey){if(-1!=\":RSA:RSAOAEP:RSAOAEP224:RSAOAEP256:RSAOAEP384:RSAOAEP512:\".indexOf(t))return t;if(null===t||void 0===t)return\"RSA\";throw\"getAlgByKeyAndName: not supported algorithm name for RSAKey: \"+t}throw\"getAlgByKeyAndName: not supported algorithm name: \"+t},V.crypto.OID=new function(){this.oidhex2name={\"2a864886f70d010101\":\"rsaEncryption\",\"2a8648ce3d0201\":\"ecPublicKey\",\"2a8648ce380401\":\"dsa\",\"2a8648ce3d030107\":\"secp256r1\",\"2b8104001f\":\"secp192k1\",\"2b81040021\":\"secp224r1\",\"2b8104000a\":\"secp256k1\",\"2b81040023\":\"secp521r1\",\"2b81040022\":\"secp384r1\",\"2a8648ce380403\":\"SHA1withDSA\",\"608648016503040301\":\"SHA224withDSA\",\"608648016503040302\":\"SHA256withDSA\"}},void 0!==V&&V||(t.KJUR=V={}),void 0!==V.crypto&&V.crypto||(V.crypto={}),V.crypto.ECDSA=function(e){var t=new SecureRandom;this.type=\"EC\",this.isPrivate=!1,this.isPublic=!1,this.getBigRandom=function(e){return new BigInteger(e.bitLength(),t).mod(e.subtract(BigInteger.ONE)).add(BigInteger.ONE)},this.setNamedCurve=function(e){this.ecparams=V.crypto.ECParameterDB.getByName(e),this.prvKeyHex=null,this.pubKeyHex=null,this.curveName=e},this.setPrivateKeyHex=function(e){this.isPrivate=!0,this.prvKeyHex=e},this.setPublicKeyHex=function(e){this.isPublic=!0,this.pubKeyHex=e},this.getPublicKeyXYHex=function(){var e=this.pubKeyHex;if(\"04\"!==e.substr(0,2))throw\"this method supports uncompressed format(04) only\";var t=this.ecparams.keylen/4;if(e.length!==2+2*t)throw\"malformed public key hex length\";var r={};return r.x=e.substr(2,t),r.y=e.substr(2+t),r},this.getShortNISTPCurveName=function(){var e=this.curveName;return\"secp256r1\"===e||\"NIST P-256\"===e||\"P-256\"===e||\"prime256v1\"===e?\"P-256\":\"secp384r1\"===e||\"NIST P-384\"===e||\"P-384\"===e?\"P-384\":null},this.generateKeyPairHex=function(){var e=this.ecparams.n,t=this.getBigRandom(e),r=this.ecparams.G.multiply(t),n=r.getX().toBigInteger(),i=r.getY().toBigInteger(),o=this.ecparams.keylen/4,s=(\"0000000000\"+t.toString(16)).slice(-o),a=\"04\"+(\"0000000000\"+n.toString(16)).slice(-o)+(\"0000000000\"+i.toString(16)).slice(-o);return this.setPrivateKeyHex(s),this.setPublicKeyHex(a),{ecprvhex:s,ecpubhex:a}},this.signWithMessageHash=function(e){return this.signHex(e,this.prvKeyHex)},this.signHex=function(e,t){var r=new BigInteger(t,16),n=this.ecparams.n,i=new BigInteger(e,16);do{var o=this.getBigRandom(n),s=this.ecparams.G.multiply(o).getX().toBigInteger().mod(n)}while(s.compareTo(BigInteger.ZERO)<=0);var a=o.modInverse(n).multiply(i.add(r.multiply(s))).mod(n);return V.crypto.ECDSA.biRSSigToASN1Sig(s,a)},this.sign=function(e,t){var r=t,n=this.ecparams.n,i=BigInteger.fromByteArrayUnsigned(e);do{var o=this.getBigRandom(n),s=this.ecparams.G.multiply(o).getX().toBigInteger().mod(n)}while(s.compareTo(BigInteger.ZERO)<=0);var a=o.modInverse(n).multiply(i.add(r.multiply(s))).mod(n);return this.serializeSig(s,a)},this.verifyWithMessageHash=function(e,t){return this.verifyHex(e,t,this.pubKeyHex)},this.verifyHex=function(e,t,r){var n,i,o,s=V.crypto.ECDSA.parseSigHex(t);n=s.r,i=s.s,o=ECPointFp.decodeFromHex(this.ecparams.curve,r);var a=new BigInteger(e,16);return this.verifyRaw(a,n,i,o)},this.verify=function(e,t,r){var n,o,s;if(Bitcoin.Util.isArray(t)){var a=this.parseSig(t);n=a.r,o=a.s}else{if(\"object\"!==(void 0===t?\"undefined\":i(t))||!t.r||!t.s)throw\"Invalid value for signature\";n=t.r,o=t.s}if(r instanceof ECPointFp)s=r;else{if(!Bitcoin.Util.isArray(r))throw\"Invalid format for pubkey value, must be byte array or ECPointFp\";s=ECPointFp.decodeFrom(this.ecparams.curve,r)}var u=BigInteger.fromByteArrayUnsigned(e);return this.verifyRaw(u,n,o,s)},this.verifyRaw=function(e,t,r,n){var i=this.ecparams.n,o=this.ecparams.G;if(t.compareTo(BigInteger.ONE)<0||t.compareTo(i)>=0)return!1;if(r.compareTo(BigInteger.ONE)<0||r.compareTo(i)>=0)return!1;var s=r.modInverse(i),a=e.multiply(s).mod(i),u=t.multiply(s).mod(i);return o.multiply(a).add(n.multiply(u)).getX().toBigInteger().mod(i).equals(t)},this.serializeSig=function(e,t){var r=e.toByteArraySigned(),n=t.toByteArraySigned(),i=[];return i.push(2),i.push(r.length),(i=i.concat(r)).push(2),i.push(n.length),(i=i.concat(n)).unshift(i.length),i.unshift(48),i},this.parseSig=function(e){var t;if(48!=e[0])throw new Error(\"Signature not a valid DERSequence\");if(2!=e[t=2])throw new Error(\"First element in signature must be a DERInteger\");var r=e.slice(t+2,t+2+e[t+1]);if(2!=e[t+=2+e[t+1]])throw new Error(\"Second element in signature must be a DERInteger\");var n=e.slice(t+2,t+2+e[t+1]);return t+=2+e[t+1],{r:BigInteger.fromByteArrayUnsigned(r),s:BigInteger.fromByteArrayUnsigned(n)}},this.parseSigCompact=function(e){if(65!==e.length)throw\"Signature has the wrong length\";var t=e[0]-27;if(t<0||t>7)throw\"Invalid signature type\";var r=this.ecparams.n;return{r:BigInteger.fromByteArrayUnsigned(e.slice(1,33)).mod(r),s:BigInteger.fromByteArrayUnsigned(e.slice(33,65)).mod(r),i:t}},this.readPKCS5PrvKeyHex=function(e){var t,r,n,i=J,o=V.crypto.ECDSA.getName,s=i.getVbyList;if(!1===i.isASN1HEX(e))throw\"not ASN.1 hex string\";try{t=s(e,0,[2,0],\"06\"),r=s(e,0,[1],\"04\");try{n=s(e,0,[3,0],\"03\").substr(2)}catch(e){}}catch(e){throw\"malformed PKCS#1/5 plain ECC private key\"}if(this.curveName=o(t),void 0===this.curveName)throw\"unsupported curve name\";this.setNamedCurve(this.curveName),this.setPublicKeyHex(n),this.setPrivateKeyHex(r),this.isPublic=!1},this.readPKCS8PrvKeyHex=function(e){var t,r,n,i=J,o=V.crypto.ECDSA.getName,s=i.getVbyList;if(!1===i.isASN1HEX(e))throw\"not ASN.1 hex string\";try{s(e,0,[1,0],\"06\"),t=s(e,0,[1,1],\"06\"),r=s(e,0,[2,0,1],\"04\");try{n=s(e,0,[2,0,2,0],\"03\").substr(2)}catch(e){}}catch(e){throw\"malformed PKCS#8 plain ECC private key\"}if(this.curveName=o(t),void 0===this.curveName)throw\"unsupported curve name\";this.setNamedCurve(this.curveName),this.setPublicKeyHex(n),this.setPrivateKeyHex(r),this.isPublic=!1},this.readPKCS8PubKeyHex=function(e){var t,r,n=J,i=V.crypto.ECDSA.getName,o=n.getVbyList;if(!1===n.isASN1HEX(e))throw\"not ASN.1 hex string\";try{o(e,0,[0,0],\"06\"),t=o(e,0,[0,1],\"06\"),r=o(e,0,[1],\"03\").substr(2)}catch(e){throw\"malformed PKCS#8 ECC public key\"}if(this.curveName=i(t),null===this.curveName)throw\"unsupported curve name\";this.setNamedCurve(this.curveName),this.setPublicKeyHex(r)},this.readCertPubKeyHex=function(e,t){5!==t&&(t=6);var r,n,i=J,o=V.crypto.ECDSA.getName,s=i.getVbyList;if(!1===i.isASN1HEX(e))throw\"not ASN.1 hex string\";try{r=s(e,0,[0,t,0,1],\"06\"),n=s(e,0,[0,t,1],\"03\").substr(2)}catch(e){throw\"malformed X.509 certificate ECC public key\"}if(this.curveName=o(r),null===this.curveName)throw\"unsupported curve name\";this.setNamedCurve(this.curveName),this.setPublicKeyHex(n)},void 0!==e&&void 0!==e.curve&&(this.curveName=e.curve),void 0===this.curveName&&(this.curveName=\"secp256r1\"),this.setNamedCurve(this.curveName),void 0!==e&&(void 0!==e.prv&&this.setPrivateKeyHex(e.prv),void 0!==e.pub&&this.setPublicKeyHex(e.pub))},V.crypto.ECDSA.parseSigHex=function(e){var t=V.crypto.ECDSA.parseSigHexInHexRS(e);return{r:new BigInteger(t.r,16),s:new BigInteger(t.s,16)}},V.crypto.ECDSA.parseSigHexInHexRS=function(e){var t=J,r=t.getChildIdx,n=t.getV;if(\"30\"!=e.substr(0,2))throw\"signature is not a ASN.1 sequence\";var i=r(e,0);if(2!=i.length)throw\"number of signature ASN.1 sequence elements seem wrong\";var o=i[0],s=i[1];if(\"02\"!=e.substr(o,2))throw\"1st item of sequene of signature is not ASN.1 integer\";if(\"02\"!=e.substr(s,2))throw\"2nd item of sequene of signature is not ASN.1 integer\";return{r:n(e,o),s:n(e,s)}},V.crypto.ECDSA.asn1SigToConcatSig=function(e){var t=V.crypto.ECDSA.parseSigHexInHexRS(e),r=t.r,n=t.s;if(\"00\"==r.substr(0,2)&&r.length%32==2&&(r=r.substr(2)),\"00\"==n.substr(0,2)&&n.length%32==2&&(n=n.substr(2)),r.length%32==30&&(r=\"00\"+r),n.length%32==30&&(n=\"00\"+n),r.length%32!=0)throw\"unknown ECDSA sig r length error\";if(n.length%32!=0)throw\"unknown ECDSA sig s length error\";return r+n},V.crypto.ECDSA.concatSigToASN1Sig=function(e){if(e.length/2*8%128!=0)throw\"unknown ECDSA concatinated r-s sig  length error\";var t=e.substr(0,e.length/2),r=e.substr(e.length/2);return V.crypto.ECDSA.hexRSSigToASN1Sig(t,r)},V.crypto.ECDSA.hexRSSigToASN1Sig=function(e,t){var r=new BigInteger(e,16),n=new BigInteger(t,16);return V.crypto.ECDSA.biRSSigToASN1Sig(r,n)},V.crypto.ECDSA.biRSSigToASN1Sig=function(e,t){var r=V.asn1,n=new r.DERInteger({bigint:e}),i=new r.DERInteger({bigint:t});return new r.DERSequence({array:[n,i]}).getEncodedHex()},V.crypto.ECDSA.getName=function(e){return\"2a8648ce3d030107\"===e?\"secp256r1\":\"2b8104000a\"===e?\"secp256k1\":\"2b81040022\"===e?\"secp384r1\":-1!==\"|secp256r1|NIST P-256|P-256|prime256v1|\".indexOf(e)?\"secp256r1\":-1!==\"|secp256k1|\".indexOf(e)?\"secp256k1\":-1!==\"|secp384r1|NIST P-384|P-384|\".indexOf(e)?\"secp384r1\":null},void 0!==V&&V||(t.KJUR=V={}),void 0!==V.crypto&&V.crypto||(V.crypto={}),V.crypto.ECParameterDB=new function(){var e={},t={};function a(e){return new BigInteger(e,16)}this.getByName=function(r){var n=r;if(void 0!==t[n]&&(n=t[r]),void 0!==e[n])return e[n];throw\"unregistered EC curve name: \"+n},this.regist=function(r,n,i,o,s,u,c,h,l,f,g,p){e[r]={};var d=a(i),v=a(o),y=a(s),m=a(u),_=a(c),S=new ECCurveFp(d,v,y),b=S.decodePointHex(\"04\"+h+l);e[r].name=r,e[r].keylen=n,e[r].curve=S,e[r].G=b,e[r].n=m,e[r].h=_,e[r].oid=g,e[r].info=p;for(var F=0;F<f.length;F++)t[f[F]]=r}},V.crypto.ECParameterDB.regist(\"secp128r1\",128,\"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFF\",\"FFFFFFFDFFFFFFFFFFFFFFFFFFFFFFFC\",\"E87579C11079F43DD824993C2CEE5ED3\",\"FFFFFFFE0000000075A30D1B9038A115\",\"1\",\"161FF7528B899B2D0C28607CA52C5B86\",\"CF5AC8395BAFEB13C02DA292DDED7A83\",[],\"\",\"secp128r1 : SECG curve over a 128 bit prime field\"),V.crypto.ECParameterDB.regist(\"secp160k1\",160,\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFAC73\",\"0\",\"7\",\"0100000000000000000001B8FA16DFAB9ACA16B6B3\",\"1\",\"3B4C382CE37AA192A4019E763036F4F5DD4D7EBB\",\"938CF935318FDCED6BC28286531733C3F03C4FEE\",[],\"\",\"secp160k1 : SECG curve over a 160 bit prime field\"),V.crypto.ECParameterDB.regist(\"secp160r1\",160,\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFF\",\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF7FFFFFFC\",\"1C97BEFC54BD7A8B65ACF89F81D4D4ADC565FA45\",\"0100000000000000000001F4C8F927AED3CA752257\",\"1\",\"4A96B5688EF573284664698968C38BB913CBFC82\",\"23A628553168947D59DCC912042351377AC5FB32\",[],\"\",\"secp160r1 : SECG curve over a 160 bit prime field\"),V.crypto.ECParameterDB.regist(\"secp192k1\",192,\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFEE37\",\"0\",\"3\",\"FFFFFFFFFFFFFFFFFFFFFFFE26F2FC170F69466A74DEFD8D\",\"1\",\"DB4FF10EC057E9AE26B07D0280B7F4341DA5D1B1EAE06C7D\",\"9B2F2F6D9C5628A7844163D015BE86344082AA88D95E2F9D\",[]),V.crypto.ECParameterDB.regist(\"secp192r1\",192,\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFF\",\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFC\",\"64210519E59C80E70FA7E9AB72243049FEB8DEECC146B9B1\",\"FFFFFFFFFFFFFFFFFFFFFFFF99DEF836146BC9B1B4D22831\",\"1\",\"188DA80EB03090F67CBF20EB43A18800F4FF0AFD82FF1012\",\"07192B95FFC8DA78631011ED6B24CDD573F977A11E794811\",[]),V.crypto.ECParameterDB.regist(\"secp224r1\",224,\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF000000000000000000000001\",\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFFFFFFFFFFFFFFFFFE\",\"B4050A850C04B3ABF54132565044B0B7D7BFD8BA270B39432355FFB4\",\"FFFFFFFFFFFFFFFFFFFFFFFFFFFF16A2E0B8F03E13DD29455C5C2A3D\",\"1\",\"B70E0CBD6BB4BF7F321390B94A03C1D356C21122343280D6115C1D21\",\"BD376388B5F723FB4C22DFE6CD4375A05A07476444D5819985007E34\",[]),V.crypto.ECParameterDB.regist(\"secp256k1\",256,\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F\",\"0\",\"7\",\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141\",\"1\",\"79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798\",\"483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8\",[]),V.crypto.ECParameterDB.regist(\"secp256r1\",256,\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF\",\"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC\",\"5AC635D8AA3A93E7B3EBBD55769886BC651D06B0CC53B0F63BCE3C3E27D2604B\",\"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551\",\"1\",\"6B17D1F2E12C4247F8BCE6E563A440F277037D812DEB33A0F4A13945D898C296\",\"4FE342E2FE1A7F9B8EE7EB4A7C0F9E162BCE33576B315ECECBB6406837BF51F5\",[\"NIST P-256\",\"P-256\",\"prime256v1\"]),V.crypto.ECParameterDB.regist(\"secp384r1\",384,\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFF\",\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFFFF0000000000000000FFFFFFFC\",\"B3312FA7E23EE7E4988E056BE3F82D19181D9C6EFE8141120314088F5013875AC656398D8A2ED19D2A85C8EDD3EC2AEF\",\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC7634D81F4372DDF581A0DB248B0A77AECEC196ACCC52973\",\"1\",\"AA87CA22BE8B05378EB1C71EF320AD746E1D3B628BA79B9859F741E082542A385502F25DBF55296C3A545E3872760AB7\",\"3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f\",[\"NIST P-384\",\"P-384\"]),V.crypto.ECParameterDB.regist(\"secp521r1\",521,\"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\",\"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFC\",\"051953EB9618E1C9A1F929A21A0B68540EEA2DA725B99B315F3B8B489918EF109E156193951EC7E937B1652C0BD3BB1BF073573DF883D2C34F1EF451FD46B503F00\",\"1FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFA51868783BF2F966B7FCC0148F709A5D03BB5C9B8899C47AEBB6FB71E91386409\",\"1\",\"C6858E06B70404E9CD9E3ECB662395B4429C648139053FB521F828AF606B4D3DBAA14B5E77EFE75928FE1DC127A2FFA8DE3348B3C1856A429BF97E7E31C2E5BD66\",\"011839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650\",[\"NIST P-521\",\"P-521\"]);var z=function(){var t=function d(e,t,n){return r(y.AES,e,t,n)},r=function k(e,t,r,n){var i=y.enc.Hex.parse(t),o=y.enc.Hex.parse(r),s=y.enc.Hex.parse(n),a={};a.key=o,a.iv=s,a.ciphertext=i;var u=e.decrypt(a,o,{iv:s});return y.enc.Hex.stringify(u)},n=function l(e,t,r){return i(y.AES,e,t,r)},i=function g(e,t,r,n){var i=y.enc.Hex.parse(t),o=y.enc.Hex.parse(r),s=y.enc.Hex.parse(n),a=e.encrypt(i,o,{iv:s}),u=y.enc.Hex.parse(a.toString());return y.enc.Base64.stringify(u)},s={\"AES-256-CBC\":{proc:t,eproc:n,keylen:32,ivlen:16},\"AES-192-CBC\":{proc:t,eproc:n,keylen:24,ivlen:16},\"AES-128-CBC\":{proc:t,eproc:n,keylen:16,ivlen:16},\"DES-EDE3-CBC\":{proc:function e(t,n,i){return r(y.TripleDES,t,n,i)},eproc:function o(e,t,r){return i(y.TripleDES,e,t,r)},keylen:24,ivlen:8},\"DES-CBC\":{proc:function a(e,t,n){return r(y.DES,e,t,n)},eproc:function f(e,t,r){return i(y.DES,e,t,r)},keylen:8,ivlen:8}},u=function n(e){var t={},r=e.match(new RegExp(\"DEK-Info: ([^,]+),([0-9A-Fa-f]+)\",\"m\"));r&&(t.cipher=r[1],t.ivsalt=r[2]);var i=e.match(new RegExp(\"-----BEGIN ([A-Z]+) PRIVATE KEY-----\"));i&&(t.type=i[1]);var o=-1,s=0;-1!=e.indexOf(\"\\r\\n\\r\\n\")&&(o=e.indexOf(\"\\r\\n\\r\\n\"),s=2),-1!=e.indexOf(\"\\n\\n\")&&(o=e.indexOf(\"\\n\\n\"),s=1);var a=e.indexOf(\"-----END\");if(-1!=o&&-1!=a){var u=e.substring(o+2*s,a-s);u=u.replace(/\\s+/g,\"\"),t.data=u}return t},c=function j(e,t,r){for(var n=r.substring(0,16),i=y.enc.Hex.parse(n),o=y.enc.Utf8.parse(t),a=s[e].keylen+s[e].ivlen,u=\"\",c=null;;){var h=y.algo.MD5.create();if(null!=c&&h.update(c),h.update(o),h.update(i),c=h.finalize(),(u+=y.enc.Hex.stringify(c)).length>=2*a)break}var l={};return l.keyhex=u.substr(0,2*s[e].keylen),l.ivhex=u.substr(2*s[e].keylen,2*s[e].ivlen),l},g=function b(e,t,r,n){var i=y.enc.Base64.parse(e),o=y.enc.Hex.stringify(i);return(0,s[t].proc)(o,r,n)};return{version:\"1.0.0\",parsePKCS5PEM:function parsePKCS5PEM(e){return u(e)},getKeyAndUnusedIvByPasscodeAndIvsalt:function getKeyAndUnusedIvByPasscodeAndIvsalt(e,t,r){return c(e,t,r)},decryptKeyB64:function decryptKeyB64(e,t,r,n){return g(e,t,r,n)},getDecryptedKeyHex:function getDecryptedKeyHex(e,t){var r=u(e),n=(r.type,r.cipher),i=r.ivsalt,o=r.data,s=c(n,t,i).keyhex;return g(o,n,s,i)},getEncryptedPKCS5PEMFromPrvKeyHex:function getEncryptedPKCS5PEMFromPrvKeyHex(e,t,r,n,i){var o=\"\";if(void 0!==n&&null!=n||(n=\"AES-256-CBC\"),void 0===s[n])throw\"KEYUTIL unsupported algorithm: \"+n;void 0!==i&&null!=i||(i=function m(e){var t=y.lib.WordArray.random(e);return y.enc.Hex.stringify(t)}(s[n].ivlen).toUpperCase());var a=function h(e,t,r,n){return(0,s[t].eproc)(e,r,n)}(t,n,c(n,r,i).keyhex,i);o=\"-----BEGIN \"+e+\" PRIVATE KEY-----\\r\\n\";return o+=\"Proc-Type: 4,ENCRYPTED\\r\\n\",o+=\"DEK-Info: \"+n+\",\"+i+\"\\r\\n\",o+=\"\\r\\n\",o+=a.replace(/(.{64})/g,\"$1\\r\\n\"),o+=\"\\r\\n-----END \"+e+\" PRIVATE KEY-----\\r\\n\"},parseHexOfEncryptedPKCS8:function parseHexOfEncryptedPKCS8(e){var t=J,r=t.getChildIdx,n=t.getV,i={},o=r(e,0);if(2!=o.length)throw\"malformed format: SEQUENCE(0).items != 2: \"+o.length;i.ciphertext=n(e,o[1]);var s=r(e,o[0]);if(2!=s.length)throw\"malformed format: SEQUENCE(0.0).items != 2: \"+s.length;if(\"2a864886f70d01050d\"!=n(e,s[0]))throw\"this only supports pkcs5PBES2\";var a=r(e,s[1]);if(2!=s.length)throw\"malformed format: SEQUENCE(0.0.1).items != 2: \"+a.length;var u=r(e,a[1]);if(2!=u.length)throw\"malformed format: SEQUENCE(0.0.1.1).items != 2: \"+u.length;if(\"2a864886f70d0307\"!=n(e,u[0]))throw\"this only supports TripleDES\";i.encryptionSchemeAlg=\"TripleDES\",i.encryptionSchemeIV=n(e,u[1]);var c=r(e,a[0]);if(2!=c.length)throw\"malformed format: SEQUENCE(0.0.1.0).items != 2: \"+c.length;if(\"2a864886f70d01050c\"!=n(e,c[0]))throw\"this only supports pkcs5PBKDF2\";var h=r(e,c[1]);if(h.length<2)throw\"malformed format: SEQUENCE(0.0.1.0.1).items < 2: \"+h.length;i.pbkdf2Salt=n(e,h[0]);var l=n(e,h[1]);try{i.pbkdf2Iter=parseInt(l,16)}catch(e){throw\"malformed format pbkdf2Iter: \"+l}return i},getPBKDF2KeyHexFromParam:function getPBKDF2KeyHexFromParam(e,t){var r=y.enc.Hex.parse(e.pbkdf2Salt),n=e.pbkdf2Iter,i=y.PBKDF2(t,r,{keySize:6,iterations:n});return y.enc.Hex.stringify(i)},_getPlainPKCS8HexFromEncryptedPKCS8PEM:function _getPlainPKCS8HexFromEncryptedPKCS8PEM(e,t){var r=pemtohex(e,\"ENCRYPTED PRIVATE KEY\"),n=this.parseHexOfEncryptedPKCS8(r),i=z.getPBKDF2KeyHexFromParam(n,t),o={};o.ciphertext=y.enc.Hex.parse(n.ciphertext);var s=y.enc.Hex.parse(i),a=y.enc.Hex.parse(n.encryptionSchemeIV),u=y.TripleDES.decrypt(o,s,{iv:a});return y.enc.Hex.stringify(u)},getKeyFromEncryptedPKCS8PEM:function getKeyFromEncryptedPKCS8PEM(e,t){var r=this._getPlainPKCS8HexFromEncryptedPKCS8PEM(e,t);return this.getKeyFromPlainPrivatePKCS8Hex(r)},parsePlainPrivatePKCS8Hex:function parsePlainPrivatePKCS8Hex(e){var t=J,r=t.getChildIdx,n=t.getV,i={algparam:null};if(\"30\"!=e.substr(0,2))throw\"malformed plain PKCS8 private key(code:001)\";var o=r(e,0);if(3!=o.length)throw\"malformed plain PKCS8 private key(code:002)\";if(\"30\"!=e.substr(o[1],2))throw\"malformed PKCS8 private key(code:003)\";var s=r(e,o[1]);if(2!=s.length)throw\"malformed PKCS8 private key(code:004)\";if(\"06\"!=e.substr(s[0],2))throw\"malformed PKCS8 private key(code:005)\";if(i.algoid=n(e,s[0]),\"06\"==e.substr(s[1],2)&&(i.algparam=n(e,s[1])),\"04\"!=e.substr(o[2],2))throw\"malformed PKCS8 private key(code:006)\";return i.keyidx=t.getVidx(e,o[2]),i},getKeyFromPlainPrivatePKCS8PEM:function getKeyFromPlainPrivatePKCS8PEM(e){var t=pemtohex(e,\"PRIVATE KEY\");return this.getKeyFromPlainPrivatePKCS8Hex(t)},getKeyFromPlainPrivatePKCS8Hex:function getKeyFromPlainPrivatePKCS8Hex(e){var t,r=this.parsePlainPrivatePKCS8Hex(e);if(\"2a864886f70d010101\"==r.algoid)t=new RSAKey;else if(\"2a8648ce380401\"==r.algoid)t=new V.crypto.DSA;else{if(\"2a8648ce3d0201\"!=r.algoid)throw\"unsupported private key algorithm\";t=new V.crypto.ECDSA}return t.readPKCS8PrvKeyHex(e),t},_getKeyFromPublicPKCS8Hex:function _getKeyFromPublicPKCS8Hex(e){var t,r=J.getVbyList(e,0,[0,0],\"06\");if(\"2a864886f70d010101\"===r)t=new RSAKey;else if(\"2a8648ce380401\"===r)t=new V.crypto.DSA;else{if(\"2a8648ce3d0201\"!==r)throw\"unsupported PKCS#8 public key hex\";t=new V.crypto.ECDSA}return t.readPKCS8PubKeyHex(e),t},parsePublicRawRSAKeyHex:function parsePublicRawRSAKeyHex(e){var t=J,r=t.getChildIdx,n=t.getV,i={};if(\"30\"!=e.substr(0,2))throw\"malformed RSA key(code:001)\";var o=r(e,0);if(2!=o.length)throw\"malformed RSA key(code:002)\";if(\"02\"!=e.substr(o[0],2))throw\"malformed RSA key(code:003)\";if(i.n=n(e,o[0]),\"02\"!=e.substr(o[1],2))throw\"malformed RSA key(code:004)\";return i.e=n(e,o[1]),i},parsePublicPKCS8Hex:function parsePublicPKCS8Hex(e){var t=J,r=t.getChildIdx,n=t.getV,i={algparam:null},o=r(e,0);if(2!=o.length)throw\"outer DERSequence shall have 2 elements: \"+o.length;var s=o[0];if(\"30\"!=e.substr(s,2))throw\"malformed PKCS8 public key(code:001)\";var a=r(e,s);if(2!=a.length)throw\"malformed PKCS8 public key(code:002)\";if(\"06\"!=e.substr(a[0],2))throw\"malformed PKCS8 public key(code:003)\";if(i.algoid=n(e,a[0]),\"06\"==e.substr(a[1],2)?i.algparam=n(e,a[1]):\"30\"==e.substr(a[1],2)&&(i.algparam={},i.algparam.p=t.getVbyList(e,a[1],[0],\"02\"),i.algparam.q=t.getVbyList(e,a[1],[1],\"02\"),i.algparam.g=t.getVbyList(e,a[1],[2],\"02\")),\"03\"!=e.substr(o[1],2))throw\"malformed PKCS8 public key(code:004)\";return i.key=n(e,o[1]).substr(2),i}}}();z.getKey=function(e,t,r){var n=(v=J).getChildIdx,i=(v.getV,v.getVbyList),o=V.crypto,s=o.ECDSA,a=o.DSA,u=RSAKey,c=pemtohex,h=z;if(void 0!==u&&e instanceof u)return e;if(void 0!==s&&e instanceof s)return e;if(void 0!==a&&e instanceof a)return e;if(void 0!==e.curve&&void 0!==e.xy&&void 0===e.d)return new s({pub:e.xy,curve:e.curve});if(void 0!==e.curve&&void 0!==e.d)return new s({prv:e.d,curve:e.curve});if(void 0===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0===e.d)return(k=new u).setPublic(e.n,e.e),k;if(void 0===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0!==e.d&&void 0!==e.p&&void 0!==e.q&&void 0!==e.dp&&void 0!==e.dq&&void 0!==e.co&&void 0===e.qi)return(k=new u).setPrivateEx(e.n,e.e,e.d,e.p,e.q,e.dp,e.dq,e.co),k;if(void 0===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0!==e.d&&void 0===e.p)return(k=new u).setPrivate(e.n,e.e,e.d),k;if(void 0!==e.p&&void 0!==e.q&&void 0!==e.g&&void 0!==e.y&&void 0===e.x)return(k=new a).setPublic(e.p,e.q,e.g,e.y),k;if(void 0!==e.p&&void 0!==e.q&&void 0!==e.g&&void 0!==e.y&&void 0!==e.x)return(k=new a).setPrivate(e.p,e.q,e.g,e.y,e.x),k;if(\"RSA\"===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0===e.d)return(k=new u).setPublic(b64utohex(e.n),b64utohex(e.e)),k;if(\"RSA\"===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0!==e.d&&void 0!==e.p&&void 0!==e.q&&void 0!==e.dp&&void 0!==e.dq&&void 0!==e.qi)return(k=new u).setPrivateEx(b64utohex(e.n),b64utohex(e.e),b64utohex(e.d),b64utohex(e.p),b64utohex(e.q),b64utohex(e.dp),b64utohex(e.dq),b64utohex(e.qi)),k;if(\"RSA\"===e.kty&&void 0!==e.n&&void 0!==e.e&&void 0!==e.d)return(k=new u).setPrivate(b64utohex(e.n),b64utohex(e.e),b64utohex(e.d)),k;if(\"EC\"===e.kty&&void 0!==e.crv&&void 0!==e.x&&void 0!==e.y&&void 0===e.d){var l=(C=new s({curve:e.crv})).ecparams.keylen/4,f=\"04\"+(\"0000000000\"+b64utohex(e.x)).slice(-l)+(\"0000000000\"+b64utohex(e.y)).slice(-l);return C.setPublicKeyHex(f),C}if(\"EC\"===e.kty&&void 0!==e.crv&&void 0!==e.x&&void 0!==e.y&&void 0!==e.d){l=(C=new s({curve:e.crv})).ecparams.keylen/4,f=\"04\"+(\"0000000000\"+b64utohex(e.x)).slice(-l)+(\"0000000000\"+b64utohex(e.y)).slice(-l);var g=(\"0000000000\"+b64utohex(e.d)).slice(-l);return C.setPublicKeyHex(f),C.setPrivateKeyHex(g),C}if(\"pkcs5prv\"===r){var p,d=e,v=J;if(9===(p=n(d,0)).length)(k=new u).readPKCS5PrvKeyHex(d);else if(6===p.length)(k=new a).readPKCS5PrvKeyHex(d);else{if(!(p.length>2&&\"04\"===d.substr(p[1],2)))throw\"unsupported PKCS#1/5 hexadecimal key\";(k=new s).readPKCS5PrvKeyHex(d)}return k}if(\"pkcs8prv\"===r)return k=h.getKeyFromPlainPrivatePKCS8Hex(e);if(\"pkcs8pub\"===r)return h._getKeyFromPublicPKCS8Hex(e);if(\"x509pub\"===r)return X509.getPublicKeyFromCertHex(e);if(-1!=e.indexOf(\"-END CERTIFICATE-\",0)||-1!=e.indexOf(\"-END X509 CERTIFICATE-\",0)||-1!=e.indexOf(\"-END TRUSTED CERTIFICATE-\",0))return X509.getPublicKeyFromCertPEM(e);if(-1!=e.indexOf(\"-END PUBLIC KEY-\")){var y=pemtohex(e,\"PUBLIC KEY\");return h._getKeyFromPublicPKCS8Hex(y)}if(-1!=e.indexOf(\"-END RSA PRIVATE KEY-\")&&-1==e.indexOf(\"4,ENCRYPTED\")){var m=c(e,\"RSA PRIVATE KEY\");return h.getKey(m,null,\"pkcs5prv\")}if(-1!=e.indexOf(\"-END DSA PRIVATE KEY-\")&&-1==e.indexOf(\"4,ENCRYPTED\")){var _=i(I=c(e,\"DSA PRIVATE KEY\"),0,[1],\"02\"),S=i(I,0,[2],\"02\"),b=i(I,0,[3],\"02\"),F=i(I,0,[4],\"02\"),w=i(I,0,[5],\"02\");return(k=new a).setPrivate(new BigInteger(_,16),new BigInteger(S,16),new BigInteger(b,16),new BigInteger(F,16),new BigInteger(w,16)),k}if(-1!=e.indexOf(\"-END PRIVATE KEY-\"))return h.getKeyFromPlainPrivatePKCS8PEM(e);if(-1!=e.indexOf(\"-END RSA PRIVATE KEY-\")&&-1!=e.indexOf(\"4,ENCRYPTED\")){var E=h.getDecryptedKeyHex(e,t),x=new RSAKey;return x.readPKCS5PrvKeyHex(E),x}if(-1!=e.indexOf(\"-END EC PRIVATE KEY-\")&&-1!=e.indexOf(\"4,ENCRYPTED\")){var C,k=i(I=h.getDecryptedKeyHex(e,t),0,[1],\"04\"),A=i(I,0,[2,0],\"06\"),P=i(I,0,[3,0],\"03\").substr(2);if(void 0===V.crypto.OID.oidhex2name[A])throw\"undefined OID(hex) in KJUR.crypto.OID: \"+A;return(C=new s({curve:V.crypto.OID.oidhex2name[A]})).setPublicKeyHex(P),C.setPrivateKeyHex(k),C.isPublic=!1,C}if(-1!=e.indexOf(\"-END DSA PRIVATE KEY-\")&&-1!=e.indexOf(\"4,ENCRYPTED\")){var I;_=i(I=h.getDecryptedKeyHex(e,t),0,[1],\"02\"),S=i(I,0,[2],\"02\"),b=i(I,0,[3],\"02\"),F=i(I,0,[4],\"02\"),w=i(I,0,[5],\"02\");return(k=new a).setPrivate(new BigInteger(_,16),new BigInteger(S,16),new BigInteger(b,16),new BigInteger(F,16),new BigInteger(w,16)),k}if(-1!=e.indexOf(\"-END ENCRYPTED PRIVATE KEY-\"))return h.getKeyFromEncryptedPKCS8PEM(e,t);throw\"not supported argument\"},z.generateKeypair=function(e,t){if(\"RSA\"==e){var r=t;(s=new RSAKey).generate(r,\"10001\"),s.isPrivate=!0,s.isPublic=!0;var n=new RSAKey,i=s.n.toString(16),o=s.e.toString(16);return n.setPublic(i,o),n.isPrivate=!1,n.isPublic=!0,(a={}).prvKeyObj=s,a.pubKeyObj=n,a}if(\"EC\"==e){var s,a,u=t,c=new V.crypto.ECDSA({curve:u}).generateKeyPairHex();return(s=new V.crypto.ECDSA({curve:u})).setPublicKeyHex(c.ecpubhex),s.setPrivateKeyHex(c.ecprvhex),s.isPrivate=!0,s.isPublic=!1,(n=new V.crypto.ECDSA({curve:u})).setPublicKeyHex(c.ecpubhex),n.isPrivate=!1,n.isPublic=!0,(a={}).prvKeyObj=s,a.pubKeyObj=n,a}throw\"unknown algorithm: \"+e},z.getPEM=function(e,t,r,n,i,s){var a=V,u=a.asn1,c=u.DERObjectIdentifier,h=u.DERInteger,l=u.ASN1Util.newObject,f=u.x509.SubjectPublicKeyInfo,g=a.crypto,p=g.DSA,d=g.ECDSA,v=RSAKey;function A(e){return l({seq:[{int:0},{int:{bigint:e.n}},{int:e.e},{int:{bigint:e.d}},{int:{bigint:e.p}},{int:{bigint:e.q}},{int:{bigint:e.dmp1}},{int:{bigint:e.dmq1}},{int:{bigint:e.coeff}}]})}function B(e){return l({seq:[{int:1},{octstr:{hex:e.prvKeyHex}},{tag:[\"a0\",!0,{oid:{name:e.curveName}}]},{tag:[\"a1\",!0,{bitstr:{hex:\"00\"+e.pubKeyHex}}]}]})}function x(e){return l({seq:[{int:0},{int:{bigint:e.p}},{int:{bigint:e.q}},{int:{bigint:e.g}},{int:{bigint:e.y}},{int:{bigint:e.x}}]})}if((void 0!==v&&e instanceof v||void 0!==p&&e instanceof p||void 0!==d&&e instanceof d)&&1==e.isPublic&&(void 0===t||\"PKCS8PUB\"==t))return hextopem(b=new f(e).getEncodedHex(),\"PUBLIC KEY\");if(\"PKCS1PRV\"==t&&void 0!==v&&e instanceof v&&(void 0===r||null==r)&&1==e.isPrivate)return hextopem(b=A(e).getEncodedHex(),\"RSA PRIVATE KEY\");if(\"PKCS1PRV\"==t&&void 0!==d&&e instanceof d&&(void 0===r||null==r)&&1==e.isPrivate){var m=new c({name:e.curveName}).getEncodedHex(),_=B(e).getEncodedHex(),S=\"\";return S+=hextopem(m,\"EC PARAMETERS\"),S+=hextopem(_,\"EC PRIVATE KEY\")}if(\"PKCS1PRV\"==t&&void 0!==p&&e instanceof p&&(void 0===r||null==r)&&1==e.isPrivate)return hextopem(b=x(e).getEncodedHex(),\"DSA PRIVATE KEY\");if(\"PKCS5PRV\"==t&&void 0!==v&&e instanceof v&&void 0!==r&&null!=r&&1==e.isPrivate){var b=A(e).getEncodedHex();return void 0===n&&(n=\"DES-EDE3-CBC\"),this.getEncryptedPKCS5PEMFromPrvKeyHex(\"RSA\",b,r,n,s)}if(\"PKCS5PRV\"==t&&void 0!==d&&e instanceof d&&void 0!==r&&null!=r&&1==e.isPrivate){b=B(e).getEncodedHex();return void 0===n&&(n=\"DES-EDE3-CBC\"),this.getEncryptedPKCS5PEMFromPrvKeyHex(\"EC\",b,r,n,s)}if(\"PKCS5PRV\"==t&&void 0!==p&&e instanceof p&&void 0!==r&&null!=r&&1==e.isPrivate){b=x(e).getEncodedHex();return void 0===n&&(n=\"DES-EDE3-CBC\"),this.getEncryptedPKCS5PEMFromPrvKeyHex(\"DSA\",b,r,n,s)}var F=function o(e,t){var r=w(e,t);return new l({seq:[{seq:[{oid:{name:\"pkcs5PBES2\"}},{seq:[{seq:[{oid:{name:\"pkcs5PBKDF2\"}},{seq:[{octstr:{hex:r.pbkdf2Salt}},{int:r.pbkdf2Iter}]}]},{seq:[{oid:{name:\"des-EDE3-CBC\"}},{octstr:{hex:r.encryptionSchemeIV}}]}]}]},{octstr:{hex:r.ciphertext}}]}).getEncodedHex()},w=function c(e,t){var r=y.lib.WordArray.random(8),n=y.lib.WordArray.random(8),i=y.PBKDF2(t,r,{keySize:6,iterations:100}),o=y.enc.Hex.parse(e),s=y.TripleDES.encrypt(o,i,{iv:n})+\"\",a={};return a.ciphertext=s,a.pbkdf2Salt=y.enc.Hex.stringify(r),a.pbkdf2Iter=100,a.encryptionSchemeAlg=\"DES-EDE3-CBC\",a.encryptionSchemeIV=y.enc.Hex.stringify(n),a};if(\"PKCS8PRV\"==t&&void 0!=v&&e instanceof v&&1==e.isPrivate){var E=A(e).getEncodedHex();b=l({seq:[{int:0},{seq:[{oid:{name:\"rsaEncryption\"}},{null:!0}]},{octstr:{hex:E}}]}).getEncodedHex();return void 0===r||null==r?hextopem(b,\"PRIVATE KEY\"):hextopem(_=F(b,r),\"ENCRYPTED PRIVATE KEY\")}if(\"PKCS8PRV\"==t&&void 0!==d&&e instanceof d&&1==e.isPrivate){E=new l({seq:[{int:1},{octstr:{hex:e.prvKeyHex}},{tag:[\"a1\",!0,{bitstr:{hex:\"00\"+e.pubKeyHex}}]}]}).getEncodedHex(),b=l({seq:[{int:0},{seq:[{oid:{name:\"ecPublicKey\"}},{oid:{name:e.curveName}}]},{octstr:{hex:E}}]}).getEncodedHex();return void 0===r||null==r?hextopem(b,\"PRIVATE KEY\"):hextopem(_=F(b,r),\"ENCRYPTED PRIVATE KEY\")}if(\"PKCS8PRV\"==t&&void 0!==p&&e instanceof p&&1==e.isPrivate){E=new h({bigint:e.x}).getEncodedHex(),b=l({seq:[{int:0},{seq:[{oid:{name:\"dsa\"}},{seq:[{int:{bigint:e.p}},{int:{bigint:e.q}},{int:{bigint:e.g}}]}]},{octstr:{hex:E}}]}).getEncodedHex();return void 0===r||null==r?hextopem(b,\"PRIVATE KEY\"):hextopem(_=F(b,r),\"ENCRYPTED PRIVATE KEY\")}throw\"unsupported object nor format\"},z.getKeyFromCSRPEM=function(e){var t=pemtohex(e,\"CERTIFICATE REQUEST\");return z.getKeyFromCSRHex(t)},z.getKeyFromCSRHex=function(e){var t=z.parseCSRHex(e);return z.getKey(t.p8pubkeyhex,null,\"pkcs8pub\")},z.parseCSRHex=function(e){var t=J,r=t.getChildIdx,n=t.getTLV,i={},o=e;if(\"30\"!=o.substr(0,2))throw\"malformed CSR(code:001)\";var s=r(o,0);if(s.length<1)throw\"malformed CSR(code:002)\";if(\"30\"!=o.substr(s[0],2))throw\"malformed CSR(code:003)\";var a=r(o,s[0]);if(a.length<3)throw\"malformed CSR(code:004)\";return i.p8pubkeyhex=n(o,a[2]),i},z.getJWKFromKey=function(e){var t={};if(e instanceof RSAKey&&e.isPrivate)return t.kty=\"RSA\",t.n=hextob64u(e.n.toString(16)),t.e=hextob64u(e.e.toString(16)),t.d=hextob64u(e.d.toString(16)),t.p=hextob64u(e.p.toString(16)),t.q=hextob64u(e.q.toString(16)),t.dp=hextob64u(e.dmp1.toString(16)),t.dq=hextob64u(e.dmq1.toString(16)),t.qi=hextob64u(e.coeff.toString(16)),t;if(e instanceof RSAKey&&e.isPublic)return t.kty=\"RSA\",t.n=hextob64u(e.n.toString(16)),t.e=hextob64u(e.e.toString(16)),t;if(e instanceof V.crypto.ECDSA&&e.isPrivate){if(\"P-256\"!==(n=e.getShortNISTPCurveName())&&\"P-384\"!==n)throw\"unsupported curve name for JWT: \"+n;var r=e.getPublicKeyXYHex();return t.kty=\"EC\",t.crv=n,t.x=hextob64u(r.x),t.y=hextob64u(r.y),t.d=hextob64u(e.prvKeyHex),t}if(e instanceof V.crypto.ECDSA&&e.isPublic){var n;if(\"P-256\"!==(n=e.getShortNISTPCurveName())&&\"P-384\"!==n)throw\"unsupported curve name for JWT: \"+n;r=e.getPublicKeyXYHex();return t.kty=\"EC\",t.crv=n,t.x=hextob64u(r.x),t.y=hextob64u(r.y),t}throw\"not supported key object\"},RSAKey.getPosArrayOfChildrenFromHex=function(e){return J.getChildIdx(e,0)},RSAKey.getHexValueArrayOfChildrenFromHex=function(e){var t,r=J.getV,n=r(e,(t=RSAKey.getPosArrayOfChildrenFromHex(e))[0]),i=r(e,t[1]),o=r(e,t[2]),s=r(e,t[3]),a=r(e,t[4]),u=r(e,t[5]),c=r(e,t[6]),h=r(e,t[7]),l=r(e,t[8]);return(t=new Array).push(n,i,o,s,a,u,c,h,l),t},RSAKey.prototype.readPrivateKeyFromPEMString=function(e){var t=pemtohex(e),r=RSAKey.getHexValueArrayOfChildrenFromHex(t);this.setPrivateEx(r[1],r[2],r[3],r[4],r[5],r[6],r[7],r[8])},RSAKey.prototype.readPKCS5PrvKeyHex=function(e){var t=RSAKey.getHexValueArrayOfChildrenFromHex(e);this.setPrivateEx(t[1],t[2],t[3],t[4],t[5],t[6],t[7],t[8])},RSAKey.prototype.readPKCS8PrvKeyHex=function(e){var t,r,n,i,o,s,a,u,c=J,h=c.getVbyList;if(!1===c.isASN1HEX(e))throw\"not ASN.1 hex string\";try{t=h(e,0,[2,0,1],\"02\"),r=h(e,0,[2,0,2],\"02\"),n=h(e,0,[2,0,3],\"02\"),i=h(e,0,[2,0,4],\"02\"),o=h(e,0,[2,0,5],\"02\"),s=h(e,0,[2,0,6],\"02\"),a=h(e,0,[2,0,7],\"02\"),u=h(e,0,[2,0,8],\"02\")}catch(e){throw\"malformed PKCS#8 plain RSA private key\"}this.setPrivateEx(t,r,n,i,o,s,a,u)},RSAKey.prototype.readPKCS5PubKeyHex=function(e){var t=J,r=t.getV;if(!1===t.isASN1HEX(e))throw\"keyHex is not ASN.1 hex string\";var n=t.getChildIdx(e,0);if(2!==n.length||\"02\"!==e.substr(n[0],2)||\"02\"!==e.substr(n[1],2))throw\"wrong hex for PKCS#5 public key\";var i=r(e,n[0]),o=r(e,n[1]);this.setPublic(i,o)},RSAKey.prototype.readPKCS8PubKeyHex=function(e){var t=J;if(!1===t.isASN1HEX(e))throw\"not ASN.1 hex string\";if(\"06092a864886f70d010101\"!==t.getTLVbyList(e,0,[0,0]))throw\"not PKCS8 RSA public key\";var r=t.getTLVbyList(e,0,[1,0]);this.readPKCS5PubKeyHex(r)},RSAKey.prototype.readCertPubKeyHex=function(e,t){var r,n;(r=new X509).readCertHex(e),n=r.getPublicKeyHex(),this.readPKCS8PubKeyHex(n)};var Y=new RegExp(\"\");function _zeroPaddingOfSignature(e,t){for(var r=\"\",n=t/4-e.length,i=0;i<n;i++)r+=\"0\";return r+e}function pss_mgf1_str(e,t,r){for(var n=\"\",i=0;n.length<t;)n+=hextorstr(r(rstrtohex(e+String.fromCharCode.apply(String,[(4278190080&i)>>24,(16711680&i)>>16,(65280&i)>>8,255&i])))),i+=1;return n}function _rsasign_getAlgNameAndHashFromHexDisgestInfo(e){for(var t in V.crypto.Util.DIGESTINFOHEAD){var r=V.crypto.Util.DIGESTINFOHEAD[t],n=r.length;if(e.substring(0,n)==r)return[t,e.substring(n)]}return[]}function X509(){var e=J,t=e.getChildIdx,r=e.getV,n=e.getTLV,i=e.getVbyList,o=e.getTLVbyList,s=e.getIdxbyList,a=e.getVidx,u=e.oidname,c=X509,h=pemtohex;this.hex=null,this.version=0,this.foffset=0,this.aExtInfo=null,this.getVersion=function(){return null===this.hex||0!==this.version?this.version:\"a003020102\"!==o(this.hex,0,[0,0])?(this.version=1,this.foffset=-1,1):(this.version=3,3)},this.getSerialNumberHex=function(){return i(this.hex,0,[0,1+this.foffset],\"02\")},this.getSignatureAlgorithmField=function(){return u(i(this.hex,0,[0,2+this.foffset,0],\"06\"))},this.getIssuerHex=function(){return o(this.hex,0,[0,3+this.foffset],\"30\")},this.getIssuerString=function(){return c.hex2dn(this.getIssuerHex())},this.getSubjectHex=function(){return o(this.hex,0,[0,5+this.foffset],\"30\")},this.getSubjectString=function(){return c.hex2dn(this.getSubjectHex())},this.getNotBefore=function(){var e=i(this.hex,0,[0,4+this.foffset,0]);return e=e.replace(/(..)/g,\"%$1\"),e=decodeURIComponent(e)},this.getNotAfter=function(){var e=i(this.hex,0,[0,4+this.foffset,1]);return e=e.replace(/(..)/g,\"%$1\"),e=decodeURIComponent(e)},this.getPublicKeyHex=function(){return e.getTLVbyList(this.hex,0,[0,6+this.foffset],\"30\")},this.getPublicKeyIdx=function(){return s(this.hex,0,[0,6+this.foffset],\"30\")},this.getPublicKeyContentIdx=function(){var e=this.getPublicKeyIdx();return s(this.hex,e,[1,0],\"30\")},this.getPublicKey=function(){return z.getKey(this.getPublicKeyHex(),null,\"pkcs8pub\")},this.getSignatureAlgorithmName=function(){return u(i(this.hex,0,[1,0],\"06\"))},this.getSignatureValueHex=function(){return i(this.hex,0,[2],\"03\",!0)},this.verifySignature=function(e){var t=this.getSignatureAlgorithmName(),r=this.getSignatureValueHex(),n=o(this.hex,0,[0],\"30\"),i=new V.crypto.Signature({alg:t});return i.init(e),i.updateHex(n),i.verify(r)},this.parseExt=function(){if(3!==this.version)return-1;var r=s(this.hex,0,[0,7,0],\"30\"),n=t(this.hex,r);this.aExtInfo=new Array;for(var o=0;o<n.length;o++){var u={critical:!1},c=0;3===t(this.hex,n[o]).length&&(u.critical=!0,c=1),u.oid=e.hextooidstr(i(this.hex,n[o],[0],\"06\"));var h=s(this.hex,n[o],[1+c]);u.vidx=a(this.hex,h),this.aExtInfo.push(u)}},this.getExtInfo=function(e){var t=this.aExtInfo,r=e;if(e.match(/^[0-9.]+$/)||(r=V.asn1.x509.OID.name2oid(e)),\"\"!==r)for(var n=0;n<t.length;n++)if(t[n].oid===r)return t[n]},this.getExtBasicConstraints=function(){var e=this.getExtInfo(\"basicConstraints\");if(void 0===e)return e;var t=r(this.hex,e.vidx);if(\"\"===t)return{};if(\"0101ff\"===t)return{cA:!0};if(\"0101ff02\"===t.substr(0,8)){var n=r(t,6);return{cA:!0,pathLen:parseInt(n,16)}}throw\"basicConstraints parse error\"},this.getExtKeyUsageBin=function(){var e=this.getExtInfo(\"keyUsage\");if(void 0===e)return\"\";var t=r(this.hex,e.vidx);if(t.length%2!=0||t.length<=2)throw\"malformed key usage value\";var n=parseInt(t.substr(0,2)),i=parseInt(t.substr(2),16).toString(2);return i.substr(0,i.length-n)},this.getExtKeyUsageString=function(){for(var e=this.getExtKeyUsageBin(),t=new Array,r=0;r<e.length;r++)\"1\"==e.substr(r,1)&&t.push(X509.KEYUSAGE_NAME[r]);return t.join(\",\")},this.getExtSubjectKeyIdentifier=function(){var e=this.getExtInfo(\"subjectKeyIdentifier\");return void 0===e?e:r(this.hex,e.vidx)},this.getExtAuthorityKeyIdentifier=function(){var e=this.getExtInfo(\"authorityKeyIdentifier\");if(void 0===e)return e;for(var i={},o=n(this.hex,e.vidx),s=t(o,0),a=0;a<s.length;a++)\"80\"===o.substr(s[a],2)&&(i.kid=r(o,s[a]));return i},this.getExtExtKeyUsageName=function(){var e=this.getExtInfo(\"extKeyUsage\");if(void 0===e)return e;var i=new Array,o=n(this.hex,e.vidx);if(\"\"===o)return i;for(var s=t(o,0),a=0;a<s.length;a++)i.push(u(r(o,s[a])));return i},this.getExtSubjectAltName=function(){for(var e=this.getExtSubjectAltName2(),t=new Array,r=0;r<e.length;r++)\"DNS\"===e[r][0]&&t.push(e[r][1]);return t},this.getExtSubjectAltName2=function(){var e,i,o,s=this.getExtInfo(\"subjectAltName\");if(void 0===s)return s;for(var a=new Array,u=n(this.hex,s.vidx),c=t(u,0),h=0;h<c.length;h++)o=u.substr(c[h],2),e=r(u,c[h]),\"81\"===o&&(i=hextoutf8(e),a.push([\"MAIL\",i])),\"82\"===o&&(i=hextoutf8(e),a.push([\"DNS\",i])),\"84\"===o&&(i=X509.hex2dn(e,0),a.push([\"DN\",i])),\"86\"===o&&(i=hextoutf8(e),a.push([\"URI\",i])),\"87\"===o&&(i=hextoip(e),a.push([\"IP\",i]));return a},this.getExtCRLDistributionPointsURI=function(){var e=this.getExtInfo(\"cRLDistributionPoints\");if(void 0===e)return e;for(var r=new Array,n=t(this.hex,e.vidx),o=0;o<n.length;o++)try{var s=hextoutf8(i(this.hex,n[o],[0,0,0],\"86\"));r.push(s)}catch(e){}return r},this.getExtAIAInfo=function(){var e=this.getExtInfo(\"authorityInfoAccess\");if(void 0===e)return e;for(var r={ocsp:[],caissuer:[]},n=t(this.hex,e.vidx),o=0;o<n.length;o++){var s=i(this.hex,n[o],[0],\"06\"),a=i(this.hex,n[o],[1],\"86\");\"2b06010505073001\"===s&&r.ocsp.push(hextoutf8(a)),\"2b06010505073002\"===s&&r.caissuer.push(hextoutf8(a))}return r},this.getExtCertificatePolicies=function(){var e=this.getExtInfo(\"certificatePolicies\");if(void 0===e)return e;for(var o=n(this.hex,e.vidx),s=[],a=t(o,0),c=0;c<a.length;c++){var h={},l=t(o,a[c]);if(h.id=u(r(o,l[0])),2===l.length)for(var f=t(o,l[1]),g=0;g<f.length;g++){var p=i(o,f[g],[0],\"06\");\"2b06010505070201\"===p?h.cps=hextoutf8(i(o,f[g],[1])):\"2b06010505070202\"===p&&(h.unotice=hextoutf8(i(o,f[g],[1,0])))}s.push(h)}return s},this.readCertPEM=function(e){this.readCertHex(h(e))},this.readCertHex=function(e){this.hex=e,this.getVersion();try{s(this.hex,0,[0,7],\"a3\"),this.parseExt()}catch(e){}},this.getInfo=function(){var e,t,r;if(e=\"Basic Fields\\n\",e+=\"  serial number: \"+this.getSerialNumberHex()+\"\\n\",e+=\"  signature algorithm: \"+this.getSignatureAlgorithmField()+\"\\n\",e+=\"  issuer: \"+this.getIssuerString()+\"\\n\",e+=\"  notBefore: \"+this.getNotBefore()+\"\\n\",e+=\"  notAfter: \"+this.getNotAfter()+\"\\n\",e+=\"  subject: \"+this.getSubjectString()+\"\\n\",e+=\"  subject public key info: \\n\",e+=\"    key algorithm: \"+(t=this.getPublicKey()).type+\"\\n\",\"RSA\"===t.type&&(e+=\"    n=\"+hextoposhex(t.n.toString(16)).substr(0,16)+\"...\\n\",e+=\"    e=\"+hextoposhex(t.e.toString(16))+\"\\n\"),void 0!==(r=this.aExtInfo)&&null!==r){e+=\"X509v3 Extensions:\\n\";for(var n=0;n<r.length;n++){var i=r[n],o=V.asn1.x509.OID.oid2name(i.oid);\"\"===o&&(o=i.oid);var s=\"\";if(!0===i.critical&&(s=\"CRITICAL\"),e+=\"  \"+o+\" \"+s+\":\\n\",\"basicConstraints\"===o){var a=this.getExtBasicConstraints();void 0===a.cA?e+=\"    {}\\n\":(e+=\"    cA=true\",void 0!==a.pathLen&&(e+=\", pathLen=\"+a.pathLen),e+=\"\\n\")}else if(\"keyUsage\"===o)e+=\"    \"+this.getExtKeyUsageString()+\"\\n\";else if(\"subjectKeyIdentifier\"===o)e+=\"    \"+this.getExtSubjectKeyIdentifier()+\"\\n\";else if(\"authorityKeyIdentifier\"===o){var u=this.getExtAuthorityKeyIdentifier();void 0!==u.kid&&(e+=\"    kid=\"+u.kid+\"\\n\")}else{if(\"extKeyUsage\"===o)e+=\"    \"+this.getExtExtKeyUsageName().join(\", \")+\"\\n\";else if(\"subjectAltName\"===o)e+=\"    \"+this.getExtSubjectAltName2()+\"\\n\";else if(\"cRLDistributionPoints\"===o)e+=\"    \"+this.getExtCRLDistributionPointsURI()+\"\\n\";else if(\"authorityInfoAccess\"===o){var c=this.getExtAIAInfo();void 0!==c.ocsp&&(e+=\"    ocsp: \"+c.ocsp.join(\",\")+\"\\n\"),void 0!==c.caissuer&&(e+=\"    caissuer: \"+c.caissuer.join(\",\")+\"\\n\")}else if(\"certificatePolicies\"===o)for(var h=this.getExtCertificatePolicies(),l=0;l<h.length;l++)void 0!==h[l].id&&(e+=\"    policy oid: \"+h[l].id+\"\\n\"),void 0!==h[l].cps&&(e+=\"    cps: \"+h[l].cps+\"\\n\")}}}return e+=\"signature algorithm: \"+this.getSignatureAlgorithmName()+\"\\n\",e+=\"signature: \"+this.getSignatureValueHex().substr(0,16)+\"...\\n\"}}Y.compile(\"[^0-9a-f]\",\"gi\"),RSAKey.prototype.sign=function(e,t){var r=function b(e){return V.crypto.Util.hashString(e,t)}(e);return this.signWithMessageHash(r,t)},RSAKey.prototype.signWithMessageHash=function(e,t){var r=parseBigInt(V.crypto.Util.getPaddedDigestInfoHex(e,t,this.n.bitLength()),16);return _zeroPaddingOfSignature(this.doPrivate(r).toString(16),this.n.bitLength())},RSAKey.prototype.signPSS=function(e,t,r){var n=function c(e){return V.crypto.Util.hashHex(e,t)}(rstrtohex(e));return void 0===r&&(r=-1),this.signWithMessageHashPSS(n,t,r)},RSAKey.prototype.signWithMessageHashPSS=function(e,t,r){var n,i=hextorstr(e),s=i.length,a=this.n.bitLength()-1,u=Math.ceil(a/8),c=function o(e){return V.crypto.Util.hashHex(e,t)};if(-1===r||void 0===r)r=s;else if(-2===r)r=u-s-2;else if(r<-2)throw\"invalid salt length\";if(u<s+r+2)throw\"data too long\";var h=\"\";r>0&&(h=new Array(r),(new SecureRandom).nextBytes(h),h=String.fromCharCode.apply(String,h));var l=hextorstr(c(rstrtohex(\"\\0\\0\\0\\0\\0\\0\\0\\0\"+i+h))),f=[];for(n=0;n<u-r-s-2;n+=1)f[n]=0;var g=String.fromCharCode.apply(String,f)+\"\u0001\"+h,p=pss_mgf1_str(l,g.length,c),d=[];for(n=0;n<g.length;n+=1)d[n]=g.charCodeAt(n)^p.charCodeAt(n);var v=65280>>8*u-a&255;for(d[0]&=~v,n=0;n<s;n++)d.push(l.charCodeAt(n));return d.push(188),_zeroPaddingOfSignature(this.doPrivate(new BigInteger(d)).toString(16),this.n.bitLength())},RSAKey.prototype.verify=function(e,t){var r=parseBigInt(t=(t=t.replace(Y,\"\")).replace(/[ \\n]+/g,\"\"),16);if(r.bitLength()>this.n.bitLength())return 0;var n=_rsasign_getAlgNameAndHashFromHexDisgestInfo(this.doPublic(r).toString(16).replace(/^1f+00/,\"\"));if(0==n.length)return!1;var i=n[0];return n[1]==function a(e){return V.crypto.Util.hashString(e,i)}(e)},RSAKey.prototype.verifyWithMessageHash=function(e,t){var r=parseBigInt(t=(t=t.replace(Y,\"\")).replace(/[ \\n]+/g,\"\"),16);if(r.bitLength()>this.n.bitLength())return 0;var n=_rsasign_getAlgNameAndHashFromHexDisgestInfo(this.doPublic(r).toString(16).replace(/^1f+00/,\"\"));if(0==n.length)return!1;n[0];return n[1]==e},RSAKey.prototype.verifyPSS=function(t,r,n,i){var o=function e(t){return V.crypto.Util.hashHex(t,n)}(rstrtohex(t));return void 0===i&&(i=-1),this.verifyWithMessageHashPSS(o,r,n,i)},RSAKey.prototype.verifyWithMessageHashPSS=function(e,t,n,i){var o=new BigInteger(t,16);if(o.bitLength()>this.n.bitLength())return!1;var s,a=function r(e){return V.crypto.Util.hashHex(e,n)},u=hextorstr(e),c=u.length,h=this.n.bitLength()-1,l=Math.ceil(h/8);if(-1===i||void 0===i)i=c;else if(-2===i)i=l-c-2;else if(i<-2)throw\"invalid salt length\";if(l<c+i+2)throw\"data too long\";var f=this.doPublic(o).toByteArray();for(s=0;s<f.length;s+=1)f[s]&=255;for(;f.length<l;)f.unshift(0);if(188!==f[l-1])throw\"encoded message does not end in 0xbc\";var g=(f=String.fromCharCode.apply(String,f)).substr(0,l-c-1),p=f.substr(g.length,c),d=65280>>8*l-h&255;if(0!=(g.charCodeAt(0)&d))throw\"bits beyond keysize not zero\";var v=pss_mgf1_str(p,g.length,a),y=[];for(s=0;s<g.length;s+=1)y[s]=g.charCodeAt(s)^v.charCodeAt(s);y[0]&=~d;var m=l-c-i-2;for(s=0;s<m;s+=1)if(0!==y[s])throw\"leftmost octets not zero\";if(1!==y[m])throw\"0x01 marker not found\";return p===hextorstr(a(rstrtohex(\"\\0\\0\\0\\0\\0\\0\\0\\0\"+u+String.fromCharCode.apply(String,y.slice(-i)))))},RSAKey.SALT_LEN_HLEN=-1,RSAKey.SALT_LEN_MAX=-2,RSAKey.SALT_LEN_RECOVER=-2,X509.hex2dn=function(e,t){if(void 0===t&&(t=0),\"30\"!==e.substr(t,2))throw\"malformed DN\";for(var r=new Array,n=J.getChildIdx(e,t),i=0;i<n.length;i++)r.push(X509.hex2rdn(e,n[i]));return\"/\"+(r=r.map(function(e){return e.replace(\"/\",\"\\\\/\")})).join(\"/\")},X509.hex2rdn=function(e,t){if(void 0===t&&(t=0),\"31\"!==e.substr(t,2))throw\"malformed RDN\";for(var r=new Array,n=J.getChildIdx(e,t),i=0;i<n.length;i++)r.push(X509.hex2attrTypeValue(e,n[i]));return(r=r.map(function(e){return e.replace(\"+\",\"\\\\+\")})).join(\"+\")},X509.hex2attrTypeValue=function(e,t){var r=J,n=r.getV;if(void 0===t&&(t=0),\"30\"!==e.substr(t,2))throw\"malformed attribute type and value\";var i=r.getChildIdx(e,t);2!==i.length||e.substr(i[0],2);var o=n(e,i[0]),s=V.asn1.ASN1Util.oidHexToInt(o);return V.asn1.x509.OID.oid2atype(s)+\"=\"+hextorstr(n(e,i[1]))},X509.getPublicKeyFromCertHex=function(e){var t=new X509;return t.readCertHex(e),t.getPublicKey()},X509.getPublicKeyFromCertPEM=function(e){var t=new X509;return t.readCertPEM(e),t.getPublicKey()},X509.getPublicKeyInfoPropOfCertPEM=function(e){var t,r,n=J.getVbyList,i={};return i.algparam=null,(t=new X509).readCertPEM(e),r=t.getPublicKeyHex(),i.keyhex=n(r,0,[1],\"03\").substr(2),i.algoid=n(r,0,[0,0],\"06\"),\"2a8648ce3d0201\"===i.algoid&&(i.algparam=n(r,0,[0,1],\"06\")),i},X509.KEYUSAGE_NAME=[\"digitalSignature\",\"nonRepudiation\",\"keyEncipherment\",\"dataEncipherment\",\"keyAgreement\",\"keyCertSign\",\"cRLSign\",\"encipherOnly\",\"decipherOnly\"],void 0!==V&&V||(t.KJUR=V={}),void 0!==V.jws&&V.jws||(V.jws={}),V.jws.JWS=function(){var e=V.jws.JWS.isSafeJSONString;this.parseJWS=function(t,r){if(void 0===this.parsedJWS||!r&&void 0===this.parsedJWS.sigvalH){var n=t.match(/^([^.]+)\\.([^.]+)\\.([^.]+)$/);if(null==n)throw\"JWS signature is not a form of 'Head.Payload.SigValue'.\";var i=n[1],o=n[2],s=n[3],a=i+\".\"+o;if(this.parsedJWS={},this.parsedJWS.headB64U=i,this.parsedJWS.payloadB64U=o,this.parsedJWS.sigvalB64U=s,this.parsedJWS.si=a,!r){var u=b64utohex(s),c=parseBigInt(u,16);this.parsedJWS.sigvalH=u,this.parsedJWS.sigvalBI=c}var h=W(i),l=W(o);if(this.parsedJWS.headS=h,this.parsedJWS.payloadS=l,!e(h,this.parsedJWS,\"headP\"))throw\"malformed JSON string for JWS Head: \"+h}}},V.jws.JWS.sign=function(e,t,r,n,o){var s,a,u,c=V,h=c.jws.JWS,l=h.readSafeJSONString,f=h.isSafeJSONString,g=c.crypto,p=(g.ECDSA,g.Mac),d=g.Signature,v=JSON;if(\"string\"!=typeof t&&\"object\"!=(void 0===t?\"undefined\":i(t)))throw\"spHeader must be JSON string or object: \"+t;if(\"object\"==(void 0===t?\"undefined\":i(t))&&(a=t,s=v.stringify(a)),\"string\"==typeof t){if(!f(s=t))throw\"JWS Head is not safe JSON string: \"+s;a=l(s)}if(u=r,\"object\"==(void 0===r?\"undefined\":i(r))&&(u=v.stringify(r)),\"\"!=e&&null!=e||void 0===a.alg||(e=a.alg),\"\"!=e&&null!=e&&void 0===a.alg&&(a.alg=e,s=v.stringify(a)),e!==a.alg)throw\"alg and sHeader.alg doesn't match: \"+e+\"!=\"+a.alg;var y=null;if(void 0===h.jwsalg2sigalg[e])throw\"unsupported alg name: \"+e;y=h.jwsalg2sigalg[e];var m=q(s)+\".\"+q(u),_=\"\";if(\"Hmac\"==y.substr(0,4)){if(void 0===n)throw\"mac key shall be specified for HS* alg\";var S=new p({alg:y,prov:\"cryptojs\",pass:n});S.updateString(m),_=S.doFinal()}else{var b;if(-1!=y.indexOf(\"withECDSA\"))(b=new d({alg:y})).init(n,o),b.updateString(m),hASN1Sig=b.sign(),_=V.crypto.ECDSA.asn1SigToConcatSig(hASN1Sig);else if(\"none\"!=y)(b=new d({alg:y})).init(n,o),b.updateString(m),_=b.sign()}return m+\".\"+hextob64u(_)},V.jws.JWS.verify=function(e,t,r){var n,o=V,s=o.jws.JWS,a=s.readSafeJSONString,u=o.crypto,c=u.ECDSA,h=u.Mac,l=u.Signature;void 0!==i(RSAKey)&&(n=RSAKey);var f=e.split(\".\");if(3!==f.length)return!1;var g=f[0]+\".\"+f[1],p=b64utohex(f[2]),d=a(W(f[0])),v=null,y=null;if(void 0===d.alg)throw\"algorithm not specified in header\";if((y=(v=d.alg).substr(0,2),null!=r&&\"[object Array]\"===Object.prototype.toString.call(r)&&r.length>0)&&-1==(\":\"+r.join(\":\")+\":\").indexOf(\":\"+v+\":\"))throw\"algorithm '\"+v+\"' not accepted in the list\";if(\"none\"!=v&&null===t)throw\"key shall be specified to verify.\";if(\"string\"==typeof t&&-1!=t.indexOf(\"-----BEGIN \")&&(t=z.getKey(t)),!(\"RS\"!=y&&\"PS\"!=y||t instanceof n))throw\"key shall be a RSAKey obj for RS* and PS* algs\";if(\"ES\"==y&&!(t instanceof c))throw\"key shall be a ECDSA obj for ES* algs\";var m=null;if(void 0===s.jwsalg2sigalg[d.alg])throw\"unsupported alg name: \"+v;if(\"none\"==(m=s.jwsalg2sigalg[v]))throw\"not supported\";if(\"Hmac\"==m.substr(0,4)){if(void 0===t)throw\"hexadecimal key shall be specified for HMAC\";var _=new h({alg:m,pass:t});return _.updateString(g),p==_.doFinal()}if(-1!=m.indexOf(\"withECDSA\")){var S,b=null;try{b=c.concatSigToASN1Sig(p)}catch(e){return!1}return(S=new l({alg:m})).init(t),S.updateString(g),S.verify(b)}return(S=new l({alg:m})).init(t),S.updateString(g),S.verify(p)},V.jws.JWS.parse=function(e){var t,r,n,i=e.split(\".\"),o={};if(2!=i.length&&3!=i.length)throw\"malformed sJWS: wrong number of '.' splitted elements\";return t=i[0],r=i[1],3==i.length&&(n=i[2]),o.headerObj=V.jws.JWS.readSafeJSONString(W(t)),o.payloadObj=V.jws.JWS.readSafeJSONString(W(r)),o.headerPP=JSON.stringify(o.headerObj,null,\"  \"),null==o.payloadObj?o.payloadPP=W(r):o.payloadPP=JSON.stringify(o.payloadObj,null,\"  \"),void 0!==n&&(o.sigHex=b64utohex(n)),o},V.jws.JWS.verifyJWT=function(e,t,r){var n=V.jws,o=n.JWS,s=o.readSafeJSONString,a=o.inArray,u=o.includedArray,c=e.split(\".\"),h=c[0],l=c[1],f=(b64utohex(c[2]),s(W(h))),g=s(W(l));if(void 0===f.alg)return!1;if(void 0===r.alg)throw\"acceptField.alg shall be specified\";if(!a(f.alg,r.alg))return!1;if(void 0!==g.iss&&\"object\"===i(r.iss)&&!a(g.iss,r.iss))return!1;if(void 0!==g.sub&&\"object\"===i(r.sub)&&!a(g.sub,r.sub))return!1;if(void 0!==g.aud&&\"object\"===i(r.aud))if(\"string\"==typeof g.aud){if(!a(g.aud,r.aud))return!1}else if(\"object\"==i(g.aud)&&!u(g.aud,r.aud))return!1;var p=n.IntDate.getNow();return void 0!==r.verifyAt&&\"number\"==typeof r.verifyAt&&(p=r.verifyAt),void 0!==r.gracePeriod&&\"number\"==typeof r.gracePeriod||(r.gracePeriod=0),!(void 0!==g.exp&&\"number\"==typeof g.exp&&g.exp+r.gracePeriod<p)&&(!(void 0!==g.nbf&&\"number\"==typeof g.nbf&&p<g.nbf-r.gracePeriod)&&(!(void 0!==g.iat&&\"number\"==typeof g.iat&&p<g.iat-r.gracePeriod)&&((void 0===g.jti||void 0===r.jti||g.jti===r.jti)&&!!o.verify(e,t,r.alg))))},V.jws.JWS.includedArray=function(e,t){var r=V.jws.JWS.inArray;if(null===e)return!1;if(\"object\"!==(void 0===e?\"undefined\":i(e)))return!1;if(\"number\"!=typeof e.length)return!1;for(var n=0;n<e.length;n++)if(!r(e[n],t))return!1;return!0},V.jws.JWS.inArray=function(e,t){if(null===t)return!1;if(\"object\"!==(void 0===t?\"undefined\":i(t)))return!1;if(\"number\"!=typeof t.length)return!1;for(var r=0;r<t.length;r++)if(t[r]==e)return!0;return!1},V.jws.JWS.jwsalg2sigalg={HS256:\"HmacSHA256\",HS384:\"HmacSHA384\",HS512:\"HmacSHA512\",RS256:\"SHA256withRSA\",RS384:\"SHA384withRSA\",RS512:\"SHA512withRSA\",ES256:\"SHA256withECDSA\",ES384:\"SHA384withECDSA\",PS256:\"SHA256withRSAandMGF1\",PS384:\"SHA384withRSAandMGF1\",PS512:\"SHA512withRSAandMGF1\",none:\"none\"},V.jws.JWS.isSafeJSONString=function(e,t,r){var n=null;try{return\"object\"!=(void 0===(n=K(e))?\"undefined\":i(n))?0:n.constructor===Array?0:(t&&(t[r]=n),1)}catch(e){return 0}},V.jws.JWS.readSafeJSONString=function(e){var t=null;try{return\"object\"!=(void 0===(t=K(e))?\"undefined\":i(t))?null:t.constructor===Array?null:t}catch(e){return null}},V.jws.JWS.getEncodedSignatureValueFromJWS=function(e){var t=e.match(/^[^.]+\\.[^.]+\\.([^.]+)$/);if(null==t)throw\"JWS signature is not a form of 'Head.Payload.SigValue'.\";return t[1]},V.jws.JWS.getJWKthumbprint=function(e){if(\"RSA\"!==e.kty&&\"EC\"!==e.kty&&\"oct\"!==e.kty)throw\"unsupported algorithm for JWK Thumprint\";var t=\"{\";if(\"RSA\"===e.kty){if(\"string\"!=typeof e.n||\"string\"!=typeof e.e)throw\"wrong n and e value for RSA key\";t+='\"e\":\"'+e.e+'\",',t+='\"kty\":\"'+e.kty+'\",',t+='\"n\":\"'+e.n+'\"}'}else if(\"EC\"===e.kty){if(\"string\"!=typeof e.crv||\"string\"!=typeof e.x||\"string\"!=typeof e.y)throw\"wrong crv, x and y value for EC key\";t+='\"crv\":\"'+e.crv+'\",',t+='\"kty\":\"'+e.kty+'\",',t+='\"x\":\"'+e.x+'\",',t+='\"y\":\"'+e.y+'\"}'}else if(\"oct\"===e.kty){if(\"string\"!=typeof e.k)throw\"wrong k value for oct(symmetric) key\";t+='\"kty\":\"'+e.kty+'\",',t+='\"k\":\"'+e.k+'\"}'}var r=rstrtohex(t);return hextob64u(V.crypto.Util.hashHex(r,\"sha256\"))},V.jws.IntDate={},V.jws.IntDate.get=function(e){var t=V.jws.IntDate,r=t.getNow,n=t.getZulu;if(\"now\"==e)return r();if(\"now + 1hour\"==e)return r()+3600;if(\"now + 1day\"==e)return r()+86400;if(\"now + 1month\"==e)return r()+2592e3;if(\"now + 1year\"==e)return r()+31536e3;if(e.match(/Z$/))return n(e);if(e.match(/^[0-9]+$/))return parseInt(e);throw\"unsupported format: \"+e},V.jws.IntDate.getZulu=function(e){return zulutosec(e)},V.jws.IntDate.getNow=function(){return~~(new Date/1e3)},V.jws.IntDate.intDate2UTCString=function(e){return new Date(1e3*e).toUTCString()},V.jws.IntDate.intDate2Zulu=function(e){var t=new Date(1e3*e);return(\"0000\"+t.getUTCFullYear()).slice(-4)+(\"00\"+(t.getUTCMonth()+1)).slice(-2)+(\"00\"+t.getUTCDate()).slice(-2)+(\"00\"+t.getUTCHours()).slice(-2)+(\"00\"+t.getUTCMinutes()).slice(-2)+(\"00\"+t.getUTCSeconds()).slice(-2)+\"Z\"},t.SecureRandom=SecureRandom,t.rng_seed_time=rng_seed_time,t.BigInteger=BigInteger,t.RSAKey=RSAKey;var G=V.crypto.EDSA;t.EDSA=G;var X=V.crypto.DSA;t.DSA=X;var Q=V.crypto.Signature;t.Signature=Q;var $=V.crypto.MessageDigest;t.MessageDigest=$;var Z=V.crypto.Mac;t.Mac=Z;var ee=V.crypto.Cipher;t.Cipher=ee,t.KEYUTIL=z,t.ASN1HEX=J,t.X509=X509,t.CryptoJS=y,t.b64tohex=b64tohex,t.b64toBA=b64toBA,t.stoBA=stoBA,t.BAtos=BAtos,t.BAtohex=BAtohex,t.stohex=stohex,t.stob64=function stob64(e){return hex2b64(stohex(e))},t.stob64u=function stob64u(e){return b64tob64u(hex2b64(stohex(e)))},t.b64utos=function b64utos(e){return BAtos(b64toBA(b64utob64(e)))},t.b64tob64u=b64tob64u,t.b64utob64=b64utob64,t.hex2b64=hex2b64,t.hextob64u=hextob64u,t.b64utohex=b64utohex,t.utf8tob64u=q,t.b64utoutf8=W,t.utf8tob64=function utf8tob64(e){return hex2b64(uricmptohex(encodeURIComponentAll(e)))},t.b64toutf8=function b64toutf8(e){return decodeURIComponent(hextouricmp(b64tohex(e)))},t.utf8tohex=utf8tohex,t.hextoutf8=hextoutf8,t.hextorstr=hextorstr,t.rstrtohex=rstrtohex,t.hextob64=hextob64,t.hextob64nl=hextob64nl,t.b64nltohex=b64nltohex,t.hextopem=hextopem,t.pemtohex=pemtohex,t.hextoArrayBuffer=function hextoArrayBuffer(e){if(e.length%2!=0)throw\"input is not even length\";if(null==e.match(/^[0-9A-Fa-f]+$/))throw\"input is not hexadecimal\";for(var t=new ArrayBuffer(e.length/2),r=new DataView(t),n=0;n<e.length/2;n++)r.setUint8(n,parseInt(e.substr(2*n,2),16));return t},t.ArrayBuffertohex=function ArrayBuffertohex(e){for(var t=\"\",r=new DataView(e),n=0;n<e.byteLength;n++)t+=(\"00\"+r.getUint8(n).toString(16)).slice(-2);return t},t.zulutomsec=zulutomsec,t.zulutosec=zulutosec,t.zulutodate=function zulutodate(e){return new Date(zulutomsec(e))},t.datetozulu=function datetozulu(e,t,r){var n,i=e.getUTCFullYear();if(t){if(i<1950||2049<i)throw\"not proper year for UTCTime: \"+i;n=(\"\"+i).slice(-2)}else n=(\"000\"+i).slice(-4);if(n+=(\"0\"+(e.getUTCMonth()+1)).slice(-2),n+=(\"0\"+e.getUTCDate()).slice(-2),n+=(\"0\"+e.getUTCHours()).slice(-2),n+=(\"0\"+e.getUTCMinutes()).slice(-2),n+=(\"0\"+e.getUTCSeconds()).slice(-2),r){var o=e.getUTCMilliseconds();0!==o&&(n+=\".\"+(o=(o=(\"00\"+o).slice(-3)).replace(/0+$/g,\"\")))}return n+=\"Z\"},t.uricmptohex=uricmptohex,t.hextouricmp=hextouricmp,t.ipv6tohex=ipv6tohex,t.hextoipv6=hextoipv6,t.hextoip=hextoip,t.iptohex=function iptohex(e){var t=\"malformed IP address\";if(!(e=e.toLowerCase(e)).match(/^[0-9.]+$/)){if(e.match(/^[0-9a-f:]+$/)&&-1!==e.indexOf(\":\"))return ipv6tohex(e);throw t}var r=e.split(\".\");if(4!==r.length)throw t;var n=\"\";try{for(var i=0;i<4;i++)n+=(\"0\"+parseInt(r[i]).toString(16)).slice(-2);return n}catch(e){throw t}},t.encodeURIComponentAll=encodeURIComponentAll,t.newline_toUnix=function newline_toUnix(e){return e=e.replace(/\\r\\n/gm,\"\\n\")},t.newline_toDos=function newline_toDos(e){return e=(e=e.replace(/\\r\\n/gm,\"\\n\")).replace(/\\n/gm,\"\\r\\n\")},t.hextoposhex=hextoposhex,t.intarystrtohex=function intarystrtohex(e){e=(e=(e=e.replace(/^\\s*\\[\\s*/,\"\")).replace(/\\s*\\]\\s*$/,\"\")).replace(/\\s*/g,\"\");try{return e.split(/,/).map(function(e,t,r){var n=parseInt(e);if(n<0||255<n)throw\"integer not in range 0-255\";return(\"00\"+n.toString(16)).slice(-2)}).join(\"\")}catch(e){throw\"malformed integer array string: \"+e}},t.strdiffidx=function strdiffidx(e,t){var r=e.length;e.length>t.length&&(r=t.length);for(var n=0;n<r;n++)if(e.charCodeAt(n)!=t.charCodeAt(n))return n;return e.length!=t.length?r:-1},t.KJUR=V;var te=V.crypto;t.crypto=te;var re=V.asn1;t.asn1=re;var ne=V.jws;t.jws=ne;var ie=V.lang;t.lang=ie}).call(this,r(26).Buffer)},function(e,t,r){\"use strict\";(function(e){\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <feross@feross.org> <http://feross.org>\n * @license  MIT\n */\nvar n=r(28),i=r(29),o=r(30);function kMaxLength(){return Buffer.TYPED_ARRAY_SUPPORT?2147483647:1073741823}function createBuffer(e,t){if(kMaxLength()<t)throw new RangeError(\"Invalid typed array length\");return Buffer.TYPED_ARRAY_SUPPORT?(e=new Uint8Array(t)).__proto__=Buffer.prototype:(null===e&&(e=new Buffer(t)),e.length=t),e}function Buffer(e,t,r){if(!(Buffer.TYPED_ARRAY_SUPPORT||this instanceof Buffer))return new Buffer(e,t,r);if(\"number\"==typeof e){if(\"string\"==typeof t)throw new Error(\"If encoding is specified then the first argument must be a string\");return allocUnsafe(this,e)}return from(this,e,t,r)}function from(e,t,r,n){if(\"number\"==typeof t)throw new TypeError('\"value\" argument must not be a number');return\"undefined\"!=typeof ArrayBuffer&&t instanceof ArrayBuffer?function fromArrayBuffer(e,t,r,n){if(t.byteLength,r<0||t.byteLength<r)throw new RangeError(\"'offset' is out of bounds\");if(t.byteLength<r+(n||0))throw new RangeError(\"'length' is out of bounds\");t=void 0===r&&void 0===n?new Uint8Array(t):void 0===n?new Uint8Array(t,r):new Uint8Array(t,r,n);Buffer.TYPED_ARRAY_SUPPORT?(e=t).__proto__=Buffer.prototype:e=fromArrayLike(e,t);return e}(e,t,r,n):\"string\"==typeof t?function fromString(e,t,r){\"string\"==typeof r&&\"\"!==r||(r=\"utf8\");if(!Buffer.isEncoding(r))throw new TypeError('\"encoding\" must be a valid string encoding');var n=0|byteLength(t,r),i=(e=createBuffer(e,n)).write(t,r);i!==n&&(e=e.slice(0,i));return e}(e,t,r):function fromObject(e,t){if(Buffer.isBuffer(t)){var r=0|checked(t.length);return 0===(e=createBuffer(e,r)).length?e:(t.copy(e,0,0,r),e)}if(t){if(\"undefined\"!=typeof ArrayBuffer&&t.buffer instanceof ArrayBuffer||\"length\"in t)return\"number\"!=typeof t.length||function isnan(e){return e!=e}(t.length)?createBuffer(e,0):fromArrayLike(e,t);if(\"Buffer\"===t.type&&o(t.data))return fromArrayLike(e,t.data)}throw new TypeError(\"First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.\")}(e,t)}function assertSize(e){if(\"number\"!=typeof e)throw new TypeError('\"size\" argument must be a number');if(e<0)throw new RangeError('\"size\" argument must not be negative')}function allocUnsafe(e,t){if(assertSize(t),e=createBuffer(e,t<0?0:0|checked(t)),!Buffer.TYPED_ARRAY_SUPPORT)for(var r=0;r<t;++r)e[r]=0;return e}function fromArrayLike(e,t){var r=t.length<0?0:0|checked(t.length);e=createBuffer(e,r);for(var n=0;n<r;n+=1)e[n]=255&t[n];return e}function checked(e){if(e>=kMaxLength())throw new RangeError(\"Attempt to allocate Buffer larger than maximum size: 0x\"+kMaxLength().toString(16)+\" bytes\");return 0|e}function byteLength(e,t){if(Buffer.isBuffer(e))return e.length;if(\"undefined\"!=typeof ArrayBuffer&&\"function\"==typeof ArrayBuffer.isView&&(ArrayBuffer.isView(e)||e instanceof ArrayBuffer))return e.byteLength;\"string\"!=typeof e&&(e=\"\"+e);var r=e.length;if(0===r)return 0;for(var n=!1;;)switch(t){case\"ascii\":case\"latin1\":case\"binary\":return r;case\"utf8\":case\"utf-8\":case void 0:return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return 2*r;case\"hex\":return r>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n)return utf8ToBytes(e).length;t=(\"\"+t).toLowerCase(),n=!0}}function swap(e,t,r){var n=e[t];e[t]=e[r],e[r]=n}function bidirectionalIndexOf(e,t,r,n,i){if(0===e.length)return-1;if(\"string\"==typeof r?(n=r,r=0):r>2147483647?r=2147483647:r<-2147483648&&(r=-2147483648),r=+r,isNaN(r)&&(r=i?0:e.length-1),r<0&&(r=e.length+r),r>=e.length){if(i)return-1;r=e.length-1}else if(r<0){if(!i)return-1;r=0}if(\"string\"==typeof t&&(t=Buffer.from(t,n)),Buffer.isBuffer(t))return 0===t.length?-1:arrayIndexOf(e,t,r,n,i);if(\"number\"==typeof t)return t&=255,Buffer.TYPED_ARRAY_SUPPORT&&\"function\"==typeof Uint8Array.prototype.indexOf?i?Uint8Array.prototype.indexOf.call(e,t,r):Uint8Array.prototype.lastIndexOf.call(e,t,r):arrayIndexOf(e,[t],r,n,i);throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,t,r,n,i){var o,s=1,a=e.length,u=t.length;if(void 0!==n&&(\"ucs2\"===(n=String(n).toLowerCase())||\"ucs-2\"===n||\"utf16le\"===n||\"utf-16le\"===n)){if(e.length<2||t.length<2)return-1;s=2,a/=2,u/=2,r/=2}function read(e,t){return 1===s?e[t]:e.readUInt16BE(t*s)}if(i){var c=-1;for(o=r;o<a;o++)if(read(e,o)===read(t,-1===c?0:o-c)){if(-1===c&&(c=o),o-c+1===u)return c*s}else-1!==c&&(o-=o-c),c=-1}else for(r+u>a&&(r=a-u),o=r;o>=0;o--){for(var h=!0,l=0;l<u;l++)if(read(e,o+l)!==read(t,l)){h=!1;break}if(h)return o}return-1}function hexWrite(e,t,r,n){r=Number(r)||0;var i=e.length-r;n?(n=Number(n))>i&&(n=i):n=i;var o=t.length;if(o%2!=0)throw new TypeError(\"Invalid hex string\");n>o/2&&(n=o/2);for(var s=0;s<n;++s){var a=parseInt(t.substr(2*s,2),16);if(isNaN(a))return s;e[r+s]=a}return s}function utf8Write(e,t,r,n){return blitBuffer(utf8ToBytes(t,e.length-r),e,r,n)}function asciiWrite(e,t,r,n){return blitBuffer(function asciiToBytes(e){for(var t=[],r=0;r<e.length;++r)t.push(255&e.charCodeAt(r));return t}(t),e,r,n)}function latin1Write(e,t,r,n){return asciiWrite(e,t,r,n)}function base64Write(e,t,r,n){return blitBuffer(base64ToBytes(t),e,r,n)}function ucs2Write(e,t,r,n){return blitBuffer(function utf16leToBytes(e,t){for(var r,n,i,o=[],s=0;s<e.length&&!((t-=2)<0);++s)r=e.charCodeAt(s),n=r>>8,i=r%256,o.push(i),o.push(n);return o}(t,e.length-r),e,r,n)}function base64Slice(e,t,r){return 0===t&&r===e.length?n.fromByteArray(e):n.fromByteArray(e.slice(t,r))}function utf8Slice(e,t,r){r=Math.min(e.length,r);for(var n=[],i=t;i<r;){var o,a,u,c,h=e[i],l=null,f=h>239?4:h>223?3:h>191?2:1;if(i+f<=r)switch(f){case 1:h<128&&(l=h);break;case 2:128==(192&(o=e[i+1]))&&(c=(31&h)<<6|63&o)>127&&(l=c);break;case 3:o=e[i+1],a=e[i+2],128==(192&o)&&128==(192&a)&&(c=(15&h)<<12|(63&o)<<6|63&a)>2047&&(c<55296||c>57343)&&(l=c);break;case 4:o=e[i+1],a=e[i+2],u=e[i+3],128==(192&o)&&128==(192&a)&&128==(192&u)&&(c=(15&h)<<18|(63&o)<<12|(63&a)<<6|63&u)>65535&&c<1114112&&(l=c)}null===l?(l=65533,f=1):l>65535&&(l-=65536,n.push(l>>>10&1023|55296),l=56320|1023&l),n.push(l),i+=f}return function decodeCodePointsArray(e){var t=e.length;if(t<=s)return String.fromCharCode.apply(String,e);var r=\"\",n=0;for(;n<t;)r+=String.fromCharCode.apply(String,e.slice(n,n+=s));return r}(n)}t.Buffer=Buffer,t.SlowBuffer=function SlowBuffer(e){+e!=e&&(e=0);return Buffer.alloc(+e)},t.INSPECT_MAX_BYTES=50,Buffer.TYPED_ARRAY_SUPPORT=void 0!==e.TYPED_ARRAY_SUPPORT?e.TYPED_ARRAY_SUPPORT:function typedArraySupport(){try{var e=new Uint8Array(1);return e.__proto__={__proto__:Uint8Array.prototype,foo:function(){return 42}},42===e.foo()&&\"function\"==typeof e.subarray&&0===e.subarray(1,1).byteLength}catch(e){return!1}}(),t.kMaxLength=kMaxLength(),Buffer.poolSize=8192,Buffer._augment=function(e){return e.__proto__=Buffer.prototype,e},Buffer.from=function(e,t,r){return from(null,e,t,r)},Buffer.TYPED_ARRAY_SUPPORT&&(Buffer.prototype.__proto__=Uint8Array.prototype,Buffer.__proto__=Uint8Array,\"undefined\"!=typeof Symbol&&Symbol.species&&Buffer[Symbol.species]===Buffer&&Object.defineProperty(Buffer,Symbol.species,{value:null,configurable:!0})),Buffer.alloc=function(e,t,r){return function alloc(e,t,r,n){return assertSize(t),t<=0?createBuffer(e,t):void 0!==r?\"string\"==typeof n?createBuffer(e,t).fill(r,n):createBuffer(e,t).fill(r):createBuffer(e,t)}(null,e,t,r)},Buffer.allocUnsafe=function(e){return allocUnsafe(null,e)},Buffer.allocUnsafeSlow=function(e){return allocUnsafe(null,e)},Buffer.isBuffer=function isBuffer(e){return!(null==e||!e._isBuffer)},Buffer.compare=function compare(e,t){if(!Buffer.isBuffer(e)||!Buffer.isBuffer(t))throw new TypeError(\"Arguments must be Buffers\");if(e===t)return 0;for(var r=e.length,n=t.length,i=0,o=Math.min(r,n);i<o;++i)if(e[i]!==t[i]){r=e[i],n=t[i];break}return r<n?-1:n<r?1:0},Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return!0;default:return!1}},Buffer.concat=function concat(e,t){if(!o(e))throw new TypeError('\"list\" argument must be an Array of Buffers');if(0===e.length)return Buffer.alloc(0);var r;if(void 0===t)for(t=0,r=0;r<e.length;++r)t+=e[r].length;var n=Buffer.allocUnsafe(t),i=0;for(r=0;r<e.length;++r){var s=e[r];if(!Buffer.isBuffer(s))throw new TypeError('\"list\" argument must be an Array of Buffers');s.copy(n,i),i+=s.length}return n},Buffer.byteLength=byteLength,Buffer.prototype._isBuffer=!0,Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!=0)throw new RangeError(\"Buffer size must be a multiple of 16-bits\");for(var t=0;t<e;t+=2)swap(this,t,t+1);return this},Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!=0)throw new RangeError(\"Buffer size must be a multiple of 32-bits\");for(var t=0;t<e;t+=4)swap(this,t,t+3),swap(this,t+1,t+2);return this},Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!=0)throw new RangeError(\"Buffer size must be a multiple of 64-bits\");for(var t=0;t<e;t+=8)swap(this,t,t+7),swap(this,t+1,t+6),swap(this,t+2,t+5),swap(this,t+3,t+4);return this},Buffer.prototype.toString=function toString(){var e=0|this.length;return 0===e?\"\":0===arguments.length?utf8Slice(this,0,e):function slowToString(e,t,r){var n=!1;if((void 0===t||t<0)&&(t=0),t>this.length)return\"\";if((void 0===r||r>this.length)&&(r=this.length),r<=0)return\"\";if((r>>>=0)<=(t>>>=0))return\"\";for(e||(e=\"utf8\");;)switch(e){case\"hex\":return hexSlice(this,t,r);case\"utf8\":case\"utf-8\":return utf8Slice(this,t,r);case\"ascii\":return asciiSlice(this,t,r);case\"latin1\":case\"binary\":return latin1Slice(this,t,r);case\"base64\":return base64Slice(this,t,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,t,r);default:if(n)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase(),n=!0}}.apply(this,arguments)},Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");return this===e||0===Buffer.compare(this,e)},Buffer.prototype.inspect=function inspect(){var e=\"\",r=t.INSPECT_MAX_BYTES;return this.length>0&&(e=this.toString(\"hex\",0,r).match(/.{2}/g).join(\" \"),this.length>r&&(e+=\" ... \")),\"<Buffer \"+e+\">\"},Buffer.prototype.compare=function compare(e,t,r,n,i){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(void 0===t&&(t=0),void 0===r&&(r=e?e.length:0),void 0===n&&(n=0),void 0===i&&(i=this.length),t<0||r>e.length||n<0||i>this.length)throw new RangeError(\"out of range index\");if(n>=i&&t>=r)return 0;if(n>=i)return-1;if(t>=r)return 1;if(t>>>=0,r>>>=0,n>>>=0,i>>>=0,this===e)return 0;for(var o=i-n,s=r-t,a=Math.min(o,s),u=this.slice(n,i),c=e.slice(t,r),h=0;h<a;++h)if(u[h]!==c[h]){o=u[h],s=c[h];break}return o<s?-1:s<o?1:0},Buffer.prototype.includes=function includes(e,t,r){return-1!==this.indexOf(e,t,r)},Buffer.prototype.indexOf=function indexOf(e,t,r){return bidirectionalIndexOf(this,e,t,r,!0)},Buffer.prototype.lastIndexOf=function lastIndexOf(e,t,r){return bidirectionalIndexOf(this,e,t,r,!1)},Buffer.prototype.write=function write(e,t,r,n){if(void 0===t)n=\"utf8\",r=this.length,t=0;else if(void 0===r&&\"string\"==typeof t)n=t,r=this.length,t=0;else{if(!isFinite(t))throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\");t|=0,isFinite(r)?(r|=0,void 0===n&&(n=\"utf8\")):(n=r,r=void 0)}var i=this.length-t;if((void 0===r||r>i)&&(r=i),e.length>0&&(r<0||t<0)||t>this.length)throw new RangeError(\"Attempt to write outside buffer bounds\");n||(n=\"utf8\");for(var o=!1;;)switch(n){case\"hex\":return hexWrite(this,e,t,r);case\"utf8\":case\"utf-8\":return utf8Write(this,e,t,r);case\"ascii\":return asciiWrite(this,e,t,r);case\"latin1\":case\"binary\":return latin1Write(this,e,t,r);case\"base64\":return base64Write(this,e,t,r);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,t,r);default:if(o)throw new TypeError(\"Unknown encoding: \"+n);n=(\"\"+n).toLowerCase(),o=!0}},Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};var s=4096;function asciiSlice(e,t,r){var n=\"\";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(127&e[i]);return n}function latin1Slice(e,t,r){var n=\"\";r=Math.min(e.length,r);for(var i=t;i<r;++i)n+=String.fromCharCode(e[i]);return n}function hexSlice(e,t,r){var n=e.length;(!t||t<0)&&(t=0),(!r||r<0||r>n)&&(r=n);for(var i=\"\",o=t;o<r;++o)i+=toHex(e[o]);return i}function utf16leSlice(e,t,r){for(var n=e.slice(t,r),i=\"\",o=0;o<n.length;o+=2)i+=String.fromCharCode(n[o]+256*n[o+1]);return i}function checkOffset(e,t,r){if(e%1!=0||e<0)throw new RangeError(\"offset is not uint\");if(e+t>r)throw new RangeError(\"Trying to access beyond buffer length\")}function checkInt(e,t,r,n,i,o){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(t>i||t<o)throw new RangeError('\"value\" argument is out of bounds');if(r+n>e.length)throw new RangeError(\"Index out of range\")}function objectWriteUInt16(e,t,r,n){t<0&&(t=65535+t+1);for(var i=0,o=Math.min(e.length-r,2);i<o;++i)e[r+i]=(t&255<<8*(n?i:1-i))>>>8*(n?i:1-i)}function objectWriteUInt32(e,t,r,n){t<0&&(t=4294967295+t+1);for(var i=0,o=Math.min(e.length-r,4);i<o;++i)e[r+i]=t>>>8*(n?i:3-i)&255}function checkIEEE754(e,t,r,n,i,o){if(r+n>e.length)throw new RangeError(\"Index out of range\");if(r<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,t,r,n,o){return o||checkIEEE754(e,0,r,4),i.write(e,t,r,n,23,4),r+4}function writeDouble(e,t,r,n,o){return o||checkIEEE754(e,0,r,8),i.write(e,t,r,n,52,8),r+8}Buffer.prototype.slice=function slice(e,t){var r,n=this.length;if(e=~~e,t=void 0===t?n:~~t,e<0?(e+=n)<0&&(e=0):e>n&&(e=n),t<0?(t+=n)<0&&(t=0):t>n&&(t=n),t<e&&(t=e),Buffer.TYPED_ARRAY_SUPPORT)(r=this.subarray(e,t)).__proto__=Buffer.prototype;else{var i=t-e;r=new Buffer(i,void 0);for(var o=0;o<i;++o)r[o]=this[o+e]}return r},Buffer.prototype.readUIntLE=function readUIntLE(e,t,r){e|=0,t|=0,r||checkOffset(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n},Buffer.prototype.readUIntBE=function readUIntBE(e,t,r){e|=0,t|=0,r||checkOffset(e,t,this.length);for(var n=this[e+--t],i=1;t>0&&(i*=256);)n+=this[e+--t]*i;return n},Buffer.prototype.readUInt8=function readUInt8(e,t){return t||checkOffset(e,1,this.length),this[e]},Buffer.prototype.readUInt16LE=function readUInt16LE(e,t){return t||checkOffset(e,2,this.length),this[e]|this[e+1]<<8},Buffer.prototype.readUInt16BE=function readUInt16BE(e,t){return t||checkOffset(e,2,this.length),this[e]<<8|this[e+1]},Buffer.prototype.readUInt32LE=function readUInt32LE(e,t){return t||checkOffset(e,4,this.length),(this[e]|this[e+1]<<8|this[e+2]<<16)+16777216*this[e+3]},Buffer.prototype.readUInt32BE=function readUInt32BE(e,t){return t||checkOffset(e,4,this.length),16777216*this[e]+(this[e+1]<<16|this[e+2]<<8|this[e+3])},Buffer.prototype.readIntLE=function readIntLE(e,t,r){e|=0,t|=0,r||checkOffset(e,t,this.length);for(var n=this[e],i=1,o=0;++o<t&&(i*=256);)n+=this[e+o]*i;return n>=(i*=128)&&(n-=Math.pow(2,8*t)),n},Buffer.prototype.readIntBE=function readIntBE(e,t,r){e|=0,t|=0,r||checkOffset(e,t,this.length);for(var n=t,i=1,o=this[e+--n];n>0&&(i*=256);)o+=this[e+--n]*i;return o>=(i*=128)&&(o-=Math.pow(2,8*t)),o},Buffer.prototype.readInt8=function readInt8(e,t){return t||checkOffset(e,1,this.length),128&this[e]?-1*(255-this[e]+1):this[e]},Buffer.prototype.readInt16LE=function readInt16LE(e,t){t||checkOffset(e,2,this.length);var r=this[e]|this[e+1]<<8;return 32768&r?4294901760|r:r},Buffer.prototype.readInt16BE=function readInt16BE(e,t){t||checkOffset(e,2,this.length);var r=this[e+1]|this[e]<<8;return 32768&r?4294901760|r:r},Buffer.prototype.readInt32LE=function readInt32LE(e,t){return t||checkOffset(e,4,this.length),this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24},Buffer.prototype.readInt32BE=function readInt32BE(e,t){return t||checkOffset(e,4,this.length),this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]},Buffer.prototype.readFloatLE=function readFloatLE(e,t){return t||checkOffset(e,4,this.length),i.read(this,e,!0,23,4)},Buffer.prototype.readFloatBE=function readFloatBE(e,t){return t||checkOffset(e,4,this.length),i.read(this,e,!1,23,4)},Buffer.prototype.readDoubleLE=function readDoubleLE(e,t){return t||checkOffset(e,8,this.length),i.read(this,e,!0,52,8)},Buffer.prototype.readDoubleBE=function readDoubleBE(e,t){return t||checkOffset(e,8,this.length),i.read(this,e,!1,52,8)},Buffer.prototype.writeUIntLE=function writeUIntLE(e,t,r,n){(e=+e,t|=0,r|=0,n)||checkInt(this,e,t,r,Math.pow(2,8*r)-1,0);var i=1,o=0;for(this[t]=255&e;++o<r&&(i*=256);)this[t+o]=e/i&255;return t+r},Buffer.prototype.writeUIntBE=function writeUIntBE(e,t,r,n){(e=+e,t|=0,r|=0,n)||checkInt(this,e,t,r,Math.pow(2,8*r)-1,0);var i=r-1,o=1;for(this[t+i]=255&e;--i>=0&&(o*=256);)this[t+i]=e/o&255;return t+r},Buffer.prototype.writeUInt8=function writeUInt8(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,1,255,0),Buffer.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),this[t]=255&e,t+1},Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,2,65535,0),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):objectWriteUInt16(this,e,t,!0),t+2},Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,2,65535,0),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):objectWriteUInt16(this,e,t,!1),t+2},Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,4,4294967295,0),Buffer.TYPED_ARRAY_SUPPORT?(this[t+3]=e>>>24,this[t+2]=e>>>16,this[t+1]=e>>>8,this[t]=255&e):objectWriteUInt32(this,e,t,!0),t+4},Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,4,4294967295,0),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):objectWriteUInt32(this,e,t,!1),t+4},Buffer.prototype.writeIntLE=function writeIntLE(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);checkInt(this,e,t,r,i-1,-i)}var o=0,s=1,a=0;for(this[t]=255&e;++o<r&&(s*=256);)e<0&&0===a&&0!==this[t+o-1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+r},Buffer.prototype.writeIntBE=function writeIntBE(e,t,r,n){if(e=+e,t|=0,!n){var i=Math.pow(2,8*r-1);checkInt(this,e,t,r,i-1,-i)}var o=r-1,s=1,a=0;for(this[t+o]=255&e;--o>=0&&(s*=256);)e<0&&0===a&&0!==this[t+o+1]&&(a=1),this[t+o]=(e/s>>0)-a&255;return t+r},Buffer.prototype.writeInt8=function writeInt8(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,1,127,-128),Buffer.TYPED_ARRAY_SUPPORT||(e=Math.floor(e)),e<0&&(e=255+e+1),this[t]=255&e,t+1},Buffer.prototype.writeInt16LE=function writeInt16LE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,2,32767,-32768),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8):objectWriteUInt16(this,e,t,!0),t+2},Buffer.prototype.writeInt16BE=function writeInt16BE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,2,32767,-32768),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=e>>>8,this[t+1]=255&e):objectWriteUInt16(this,e,t,!1),t+2},Buffer.prototype.writeInt32LE=function writeInt32LE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,4,2147483647,-2147483648),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=255&e,this[t+1]=e>>>8,this[t+2]=e>>>16,this[t+3]=e>>>24):objectWriteUInt32(this,e,t,!0),t+4},Buffer.prototype.writeInt32BE=function writeInt32BE(e,t,r){return e=+e,t|=0,r||checkInt(this,e,t,4,2147483647,-2147483648),e<0&&(e=4294967295+e+1),Buffer.TYPED_ARRAY_SUPPORT?(this[t]=e>>>24,this[t+1]=e>>>16,this[t+2]=e>>>8,this[t+3]=255&e):objectWriteUInt32(this,e,t,!1),t+4},Buffer.prototype.writeFloatLE=function writeFloatLE(e,t,r){return writeFloat(this,e,t,!0,r)},Buffer.prototype.writeFloatBE=function writeFloatBE(e,t,r){return writeFloat(this,e,t,!1,r)},Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,t,r){return writeDouble(this,e,t,!0,r)},Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,t,r){return writeDouble(this,e,t,!1,r)},Buffer.prototype.copy=function copy(e,t,r,n){if(r||(r=0),n||0===n||(n=this.length),t>=e.length&&(t=e.length),t||(t=0),n>0&&n<r&&(n=r),n===r)return 0;if(0===e.length||0===this.length)return 0;if(t<0)throw new RangeError(\"targetStart out of bounds\");if(r<0||r>=this.length)throw new RangeError(\"sourceStart out of bounds\");if(n<0)throw new RangeError(\"sourceEnd out of bounds\");n>this.length&&(n=this.length),e.length-t<n-r&&(n=e.length-t+r);var i,o=n-r;if(this===e&&r<t&&t<n)for(i=o-1;i>=0;--i)e[i+t]=this[i+r];else if(o<1e3||!Buffer.TYPED_ARRAY_SUPPORT)for(i=0;i<o;++i)e[i+t]=this[i+r];else Uint8Array.prototype.set.call(e,this.subarray(r,r+o),t);return o},Buffer.prototype.fill=function fill(e,t,r,n){if(\"string\"==typeof e){if(\"string\"==typeof t?(n=t,t=0,r=this.length):\"string\"==typeof r&&(n=r,r=this.length),1===e.length){var i=e.charCodeAt(0);i<256&&(e=i)}if(void 0!==n&&\"string\"!=typeof n)throw new TypeError(\"encoding must be a string\");if(\"string\"==typeof n&&!Buffer.isEncoding(n))throw new TypeError(\"Unknown encoding: \"+n)}else\"number\"==typeof e&&(e&=255);if(t<0||this.length<t||this.length<r)throw new RangeError(\"Out of range index\");if(r<=t)return this;var o;if(t>>>=0,r=void 0===r?this.length:r>>>0,e||(e=0),\"number\"==typeof e)for(o=t;o<r;++o)this[o]=e;else{var s=Buffer.isBuffer(e)?e:utf8ToBytes(new Buffer(e,n).toString()),a=s.length;for(o=0;o<r-t;++o)this[o+t]=s[o%a]}return this};var a=/[^+\\/0-9A-Za-z-_]/g;function toHex(e){return e<16?\"0\"+e.toString(16):e.toString(16)}function utf8ToBytes(e,t){var r;t=t||1/0;for(var n=e.length,i=null,o=[],s=0;s<n;++s){if((r=e.charCodeAt(s))>55295&&r<57344){if(!i){if(r>56319){(t-=3)>-1&&o.push(239,191,189);continue}if(s+1===n){(t-=3)>-1&&o.push(239,191,189);continue}i=r;continue}if(r<56320){(t-=3)>-1&&o.push(239,191,189),i=r;continue}r=65536+(i-55296<<10|r-56320)}else i&&(t-=3)>-1&&o.push(239,191,189);if(i=null,r<128){if((t-=1)<0)break;o.push(r)}else if(r<2048){if((t-=2)<0)break;o.push(r>>6|192,63&r|128)}else if(r<65536){if((t-=3)<0)break;o.push(r>>12|224,r>>6&63|128,63&r|128)}else{if(!(r<1114112))throw new Error(\"Invalid code point\");if((t-=4)<0)break;o.push(r>>18|240,r>>12&63|128,r>>6&63|128,63&r|128)}}return o}function base64ToBytes(e){return n.toByteArray(function base64clean(e){if((e=function stringtrim(e){return e.trim?e.trim():e.replace(/^\\s+|\\s+$/g,\"\")}(e).replace(a,\"\")).length<2)return\"\";for(;e.length%4!=0;)e+=\"=\";return e}(e))}function blitBuffer(e,t,r,n){for(var i=0;i<n&&!(i+r>=t.length||i>=e.length);++i)t[i+r]=e[i];return i}}).call(this,r(27))},function(e,t){var r;r=function(){return this}();try{r=r||new Function(\"return this\")()}catch(e){\"object\"==typeof window&&(r=window)}e.exports=r},function(e,t,r){\"use strict\";t.byteLength=function byteLength(e){var t=getLens(e),r=t[0],n=t[1];return 3*(r+n)/4-n},t.toByteArray=function toByteArray(e){for(var t,r=getLens(e),n=r[0],s=r[1],a=new o(function _byteLength(e,t,r){return 3*(t+r)/4-r}(0,n,s)),u=0,c=s>0?n-4:n,h=0;h<c;h+=4)t=i[e.charCodeAt(h)]<<18|i[e.charCodeAt(h+1)]<<12|i[e.charCodeAt(h+2)]<<6|i[e.charCodeAt(h+3)],a[u++]=t>>16&255,a[u++]=t>>8&255,a[u++]=255&t;2===s&&(t=i[e.charCodeAt(h)]<<2|i[e.charCodeAt(h+1)]>>4,a[u++]=255&t);1===s&&(t=i[e.charCodeAt(h)]<<10|i[e.charCodeAt(h+1)]<<4|i[e.charCodeAt(h+2)]>>2,a[u++]=t>>8&255,a[u++]=255&t);return a},t.fromByteArray=function fromByteArray(e){for(var t,r=e.length,i=r%3,o=[],s=0,a=r-i;s<a;s+=16383)o.push(encodeChunk(e,s,s+16383>a?a:s+16383));1===i?(t=e[r-1],o.push(n[t>>2]+n[t<<4&63]+\"==\")):2===i&&(t=(e[r-2]<<8)+e[r-1],o.push(n[t>>10]+n[t>>4&63]+n[t<<2&63]+\"=\"));return o.join(\"\")};for(var n=[],i=[],o=\"undefined\"!=typeof Uint8Array?Uint8Array:Array,s=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\",a=0,u=s.length;a<u;++a)n[a]=s[a],i[s.charCodeAt(a)]=a;function getLens(e){var t=e.length;if(t%4>0)throw new Error(\"Invalid string. Length must be a multiple of 4\");var r=e.indexOf(\"=\");return-1===r&&(r=t),[r,r===t?0:4-r%4]}function tripletToBase64(e){return n[e>>18&63]+n[e>>12&63]+n[e>>6&63]+n[63&e]}function encodeChunk(e,t,r){for(var n,i=[],o=t;o<r;o+=3)n=(e[o]<<16&16711680)+(e[o+1]<<8&65280)+(255&e[o+2]),i.push(tripletToBase64(n));return i.join(\"\")}i[\"-\".charCodeAt(0)]=62,i[\"_\".charCodeAt(0)]=63},function(e,t){t.read=function(e,t,r,n,i){var o,s,a=8*i-n-1,u=(1<<a)-1,c=u>>1,h=-7,l=r?i-1:0,f=r?-1:1,g=e[t+l];for(l+=f,o=g&(1<<-h)-1,g>>=-h,h+=a;h>0;o=256*o+e[t+l],l+=f,h-=8);for(s=o&(1<<-h)-1,o>>=-h,h+=n;h>0;s=256*s+e[t+l],l+=f,h-=8);if(0===o)o=1-c;else{if(o===u)return s?NaN:1/0*(g?-1:1);s+=Math.pow(2,n),o-=c}return(g?-1:1)*s*Math.pow(2,o-n)},t.write=function(e,t,r,n,i,o){var s,a,u,c=8*o-i-1,h=(1<<c)-1,l=h>>1,f=23===i?Math.pow(2,-24)-Math.pow(2,-77):0,g=n?0:o-1,p=n?1:-1,d=t<0||0===t&&1/t<0?1:0;for(t=Math.abs(t),isNaN(t)||t===1/0?(a=isNaN(t)?1:0,s=h):(s=Math.floor(Math.log(t)/Math.LN2),t*(u=Math.pow(2,-s))<1&&(s--,u*=2),(t+=s+l>=1?f/u:f*Math.pow(2,1-l))*u>=2&&(s++,u/=2),s+l>=h?(a=0,s=h):s+l>=1?(a=(t*u-1)*Math.pow(2,i),s+=l):(a=t*Math.pow(2,l-1)*Math.pow(2,i),s=0));i>=8;e[r+g]=255&a,g+=p,a/=256,i-=8);for(s=s<<i|a,c+=i;c>0;e[r+g]=255&s,g+=p,s/=256,c-=8);e[r+g-p]|=128*d}},function(e,t){var r={}.toString;e.exports=Array.isArray||function(e){return\"[object Array]\"==r.call(e)}},function(e,t,r){var n=r(32),i=r(33);e.exports=function v4(e,t,r){var o=t&&r||0;\"string\"==typeof e&&(t=\"binary\"===e?new Array(16):null,e=null);var s=(e=e||{}).random||(e.rng||n)();if(s[6]=15&s[6]|64,s[8]=63&s[8]|128,t)for(var a=0;a<16;++a)t[o+a]=s[a];return t||i(s)}},function(e,t){var r=\"undefined\"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||\"undefined\"!=typeof msCrypto&&\"function\"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(r){var n=new Uint8Array(16);e.exports=function whatwgRNG(){return r(n),n}}else{var i=new Array(16);e.exports=function mathRNG(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),i[t]=e>>>((3&t)<<3)&255;return i}}},function(e,t){for(var r=[],n=0;n<256;++n)r[n]=(n+256).toString(16).substr(1);e.exports=function bytesToUuid(e,t){var n=t||0,i=r;return[i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],\"-\",i[e[n++]],i[e[n++]],\"-\",i[e[n++]],i[e[n++]],\"-\",i[e[n++]],i[e[n++]],\"-\",i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]],i[e[n++]]].join(\"\")}},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.SigninResponse=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(3);t.SigninResponse=function(){function SigninResponse(e){var t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:\"#\";!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,SigninResponse);var r=i.UrlUtility.parseUrlFragment(e,t);this.error=r.error,this.error_description=r.error_description,this.error_uri=r.error_uri,this.code=r.code,this.state=r.state,this.id_token=r.id_token,this.session_state=r.session_state,this.access_token=r.access_token,this.token_type=r.token_type,this.scope=r.scope,this.profile=void 0,this.expires_in=r.expires_in}return n(SigninResponse,[{key:\"expires_in\",get:function get(){if(this.expires_at){var e=parseInt(Date.now()/1e3);return this.expires_at-e}},set:function set(e){var t=parseInt(e);if(\"number\"==typeof t&&t>0){var r=parseInt(Date.now()/1e3);this.expires_at=r+t}}},{key:\"expired\",get:function get(){var e=this.expires_in;if(void 0!==e)return e<=0}},{key:\"scopes\",get:function get(){return(this.scope||\"\").split(\" \")}},{key:\"isOpenIdConnect\",get:function get(){return this.scopes.indexOf(\"openid\")>=0||!!this.id_token}}]),SigninResponse}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.SignoutRequest=void 0;var n=r(0),i=r(3),o=r(8);t.SignoutRequest=function SignoutRequest(e){var t=e.url,r=e.id_token_hint,s=e.post_logout_redirect_uri,a=e.data,u=e.extraQueryParams;if(function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,SignoutRequest),!t)throw n.Log.error(\"SignoutRequest.ctor: No url passed\"),new Error(\"url\");for(var c in r&&(t=i.UrlUtility.addQueryParam(t,\"id_token_hint\",r)),s&&(t=i.UrlUtility.addQueryParam(t,\"post_logout_redirect_uri\",s),a&&(this.state=new o.State({data:a}),t=i.UrlUtility.addQueryParam(t,\"state\",this.state.id))),u)t=i.UrlUtility.addQueryParam(t,c,u[c]);this.url=t}},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.SignoutResponse=void 0;var n=r(3);t.SignoutResponse=function SignoutResponse(e){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,SignoutResponse);var t=n.UrlUtility.parseUrlFragment(e,\"?\");this.error=t.error,this.error_description=t.error_description,this.error_uri=t.error_uri,this.state=t.state}},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.InMemoryWebStorage=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);t.InMemoryWebStorage=function(){function InMemoryWebStorage(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,InMemoryWebStorage),this._data={}}return InMemoryWebStorage.prototype.getItem=function getItem(e){return i.Log.debug(\"InMemoryWebStorage.getItem\",e),this._data[e]},InMemoryWebStorage.prototype.setItem=function setItem(e,t){i.Log.debug(\"InMemoryWebStorage.setItem\",e),this._data[e]=t},InMemoryWebStorage.prototype.removeItem=function removeItem(e){i.Log.debug(\"InMemoryWebStorage.removeItem\",e),delete this._data[e]},InMemoryWebStorage.prototype.key=function key(e){return Object.getOwnPropertyNames(this._data)[e]},n(InMemoryWebStorage,[{key:\"length\",get:function get(){return Object.getOwnPropertyNames(this._data).length}}]),InMemoryWebStorage}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.UserManager=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(9),s=r(39),a=r(15),u=r(45),c=r(47),h=r(18),l=r(20),f=r(10),g=r(4);t.UserManager=function(e){function UserManager(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:c.SilentRenewService,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:h.SessionMonitor,o=arguments.length>3&&void 0!==arguments[3]?arguments[3]:l.TokenRevocationClient,a=arguments.length>4&&void 0!==arguments[4]?arguments[4]:f.TokenClient,p=arguments.length>5&&void 0!==arguments[5]?arguments[5]:g.JoseUtil;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,UserManager),t instanceof s.UserManagerSettings||(t=new s.UserManagerSettings(t));var d=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!=typeof t&&\"function\"!=typeof t?e:t}(this,e.call(this,t));return d._events=new u.UserManagerEvents(t),d._silentRenewService=new r(d),d.settings.automaticSilentRenew&&(i.Log.debug(\"UserManager.ctor: automaticSilentRenew is configured, setting up silent renew\"),d.startSilentRenew()),d.settings.monitorSession&&(i.Log.debug(\"UserManager.ctor: monitorSession is configured, setting up session monitor\"),d._sessionMonitor=new n(d)),d._tokenRevocationClient=new o(d._settings),d._tokenClient=new a(d._settings),d._joseUtil=p,d}return function _inherits(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(UserManager,e),UserManager.prototype.getUser=function getUser(){var e=this;return this._loadUser().then(function(t){return t?(i.Log.info(\"UserManager.getUser: user loaded\"),e._events.load(t,!1),t):(i.Log.info(\"UserManager.getUser: user not found in storage\"),null)})},UserManager.prototype.removeUser=function removeUser(){var e=this;return this.storeUser(null).then(function(){i.Log.info(\"UserManager.removeUser: user removed from storage\"),e._events.unload()})},UserManager.prototype.signinRedirect=function signinRedirect(e){return this._signinStart(e,this._redirectNavigator).then(function(){i.Log.info(\"UserManager.signinRedirect: successful\")})},UserManager.prototype.signinRedirectCallback=function signinRedirectCallback(e){return this._signinEnd(e||this._redirectNavigator.url).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info(\"UserManager.signinRedirectCallback: successful, signed in sub: \",e.profile.sub):i.Log.info(\"UserManager.signinRedirectCallback: no sub\")),e})},UserManager.prototype.signinPopup=function signinPopup(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.redirect_uri||this.settings.popup_redirect_uri||this.settings.redirect_uri;return t?(e.redirect_uri=t,e.display=\"popup\",this._signin(e,this._popupNavigator,{startUrl:t,popupWindowFeatures:e.popupWindowFeatures||this.settings.popupWindowFeatures,popupWindowTarget:e.popupWindowTarget||this.settings.popupWindowTarget}).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info(\"UserManager.signinPopup: signinPopup successful, signed in sub: \",e.profile.sub):i.Log.info(\"UserManager.signinPopup: no sub\")),e})):(i.Log.error(\"UserManager.signinPopup: No popup_redirect_uri or redirect_uri configured\"),Promise.reject(new Error(\"No popup_redirect_uri or redirect_uri configured\")))},UserManager.prototype.signinPopupCallback=function signinPopupCallback(e){return this._signinCallback(e,this._popupNavigator).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info(\"UserManager.signinPopupCallback: successful, signed in sub: \",e.profile.sub):i.Log.info(\"UserManager.signinPopupCallback: no sub\")),e}).catch(function(e){i.Log.error(e.message)})},UserManager.prototype.signinSilent=function signinSilent(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this._loadUser().then(function(r){return r&&r.refresh_token?(t.refresh_token=r.refresh_token,e._useRefreshToken(t)):(t.id_token_hint=t.id_token_hint||e.settings.includeIdTokenInSilentRenew&&r&&r.id_token,e._signinSilentIframe(t))})},UserManager.prototype._useRefreshToken=function _useRefreshToken(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};return this._tokenClient.exchangeRefreshToken(t).then(function(t){return t?t.access_token?e._loadUser().then(function(r){if(r){var n=Promise.resolve();return t.id_token&&(n=e._validateIdTokenFromTokenRefreshToken(r.profile,t.id_token)),n.then(function(){return i.Log.debug(\"UserManager._useRefreshToken: refresh token response success\"),r.access_token=t.access_token,r.refresh_token=t.refresh_token||r.refresh_token,r.expires_in=t.expires_in,e.storeUser(r).then(function(){return e._events.load(r),r})})}return null}):(i.Log.error(\"UserManager._useRefreshToken: No access token returned from token endpoint\"),Promise.reject(\"No access token returned from token endpoint\")):(i.Log.error(\"UserManager._useRefreshToken: No response returned from token endpoint\"),Promise.reject(\"No response returned from token endpoint\"))})},UserManager.prototype._validateIdTokenFromTokenRefreshToken=function _validateIdTokenFromTokenRefreshToken(e,t){var r=this;return this._metadataService.getIssuer().then(function(n){return r._joseUtil.validateJwtAttributes(t,n,r._settings.client_id,r._settings.clockSkew).then(function(t){return t?t.sub!==e.sub?(i.Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: sub in id_token does not match current sub\"),Promise.reject(new Error(\"sub in id_token does not match current sub\"))):t.auth_time&&t.auth_time!==e.auth_time?(i.Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: auth_time in id_token does not match original auth_time\"),Promise.reject(new Error(\"auth_time in id_token does not match original auth_time\"))):t.azp&&t.azp!==e.azp?(i.Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: azp in id_token does not match original azp\"),Promise.reject(new Error(\"azp in id_token does not match original azp\"))):!t.azp&&e.azp?(i.Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: azp not in id_token, but present in original id_token\"),Promise.reject(new Error(\"azp not in id_token, but present in original id_token\"))):void 0:(i.Log.error(\"UserManager._validateIdTokenFromTokenRefreshToken: Failed to validate id_token\"),Promise.reject(new Error(\"Failed to validate id_token\")))})})},UserManager.prototype._signinSilentIframe=function _signinSilentIframe(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.redirect_uri||this.settings.silent_redirect_uri;return t?(e.redirect_uri=t,e.prompt=e.prompt||\"none\",this._signin(e,this._iframeNavigator,{startUrl:t,silentRequestTimeout:e.silentRequestTimeout||this.settings.silentRequestTimeout}).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info(\"UserManager.signinSilent: successful, signed in sub: \",e.profile.sub):i.Log.info(\"UserManager.signinSilent: no sub\")),e})):(i.Log.error(\"UserManager.signinSilent: No silent_redirect_uri configured\"),Promise.reject(new Error(\"No silent_redirect_uri configured\")))},UserManager.prototype.signinSilentCallback=function signinSilentCallback(e){return this._signinCallback(e,this._iframeNavigator).then(function(e){return e&&(e.profile&&e.profile.sub?i.Log.info(\"UserManager.signinSilentCallback: successful, signed in sub: \",e.profile.sub):i.Log.info(\"UserManager.signinSilentCallback: no sub\")),e})},UserManager.prototype.querySessionStatus=function querySessionStatus(){var e=this,t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.redirect_uri||this.settings.silent_redirect_uri;return r?(t.redirect_uri=r,t.prompt=\"none\",t.response_type=t.response_type||this.settings.query_status_response_type,t.scope=\"openid\",this._signinStart(t,this._iframeNavigator,{startUrl:r,silentRequestTimeout:t.silentRequestTimeout||this.settings.silentRequestTimeout}).then(function(t){return e.processSigninResponse(t.url).then(function(e){if(i.Log.debug(\"UserManager.querySessionStatus: got signin response\"),e.session_state&&e.profile.sub)return i.Log.info(\"UserManager.querySessionStatus: querySessionStatus success for sub: \",e.profile.sub),{session_state:e.session_state,sub:e.profile.sub,sid:e.profile.sid};i.Log.info(\"querySessionStatus successful, user not authenticated\")})})):(i.Log.error(\"UserManager.querySessionStatus: No silent_redirect_uri configured\"),Promise.reject(new Error(\"No silent_redirect_uri configured\")))},UserManager.prototype._signin=function _signin(e,t){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._signinStart(e,t,n).then(function(e){return r._signinEnd(e.url)})},UserManager.prototype._signinStart=function _signinStart(e,t){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return t.prepare(n).then(function(t){return i.Log.debug(\"UserManager._signinStart: got navigator window handle\"),r.createSigninRequest(e).then(function(e){return i.Log.debug(\"UserManager._signinStart: got signin request\"),n.url=e.url,n.id=e.state.id,t.navigate(n)}).catch(function(e){throw t.close&&(i.Log.debug(\"UserManager._signinStart: Error after preparing navigator, closing navigator window\"),t.close()),e})})},UserManager.prototype._signinEnd=function _signinEnd(e){var t=this;return this.processSigninResponse(e).then(function(e){i.Log.debug(\"UserManager._signinEnd: got signin response\");var r=new a.User(e);return t.storeUser(r).then(function(){return i.Log.debug(\"UserManager._signinEnd: user stored\"),t._events.load(r),r})})},UserManager.prototype._signinCallback=function _signinCallback(e,t){return i.Log.debug(\"UserManager._signinCallback\"),t.callback(e)},UserManager.prototype.signoutRedirect=function signoutRedirect(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.post_logout_redirect_uri||this.settings.post_logout_redirect_uri;return t&&(e.post_logout_redirect_uri=t),this._signoutStart(e,this._redirectNavigator).then(function(){i.Log.info(\"UserManager.signoutRedirect: successful\")})},UserManager.prototype.signoutRedirectCallback=function signoutRedirectCallback(e){return this._signoutEnd(e||this._redirectNavigator.url).then(function(e){return i.Log.info(\"UserManager.signoutRedirectCallback: successful\"),e})},UserManager.prototype.signoutPopup=function signoutPopup(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=e.post_logout_redirect_uri||this.settings.popup_post_logout_redirect_uri||this.settings.post_logout_redirect_uri;return e.post_logout_redirect_uri=t,e.display=\"popup\",e.post_logout_redirect_uri&&(e.state=e.state||{}),this._signout(e,this._popupNavigator,{startUrl:t,popupWindowFeatures:e.popupWindowFeatures||this.settings.popupWindowFeatures,popupWindowTarget:e.popupWindowTarget||this.settings.popupWindowTarget}).then(function(){i.Log.info(\"UserManager.signoutPopup: successful\")})},UserManager.prototype.signoutPopupCallback=function signoutPopupCallback(e,t){void 0===t&&\"boolean\"==typeof e&&(t=e,e=null);return this._popupNavigator.callback(e,t,\"?\").then(function(){i.Log.info(\"UserManager.signoutPopupCallback: successful\")})},UserManager.prototype._signout=function _signout(e,t){var r=this,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return this._signoutStart(e,t,n).then(function(e){return r._signoutEnd(e.url)})},UserManager.prototype._signoutStart=function _signoutStart(){var e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=this,r=arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};return r.prepare(n).then(function(r){return i.Log.debug(\"UserManager._signoutStart: got navigator window handle\"),t._loadUser().then(function(o){return i.Log.debug(\"UserManager._signoutStart: loaded current user from storage\"),(t._settings.revokeAccessTokenOnSignout?t._revokeInternal(o):Promise.resolve()).then(function(){var s=e.id_token_hint||o&&o.id_token;return s&&(i.Log.debug(\"UserManager._signoutStart: Setting id_token into signout request\"),e.id_token_hint=s),t.removeUser().then(function(){return i.Log.debug(\"UserManager._signoutStart: user removed, creating signout request\"),t.createSignoutRequest(e).then(function(e){return i.Log.debug(\"UserManager._signoutStart: got signout request\"),n.url=e.url,e.state&&(n.id=e.state.id),r.navigate(n)})})})}).catch(function(e){throw r.close&&(i.Log.debug(\"UserManager._signoutStart: Error after preparing navigator, closing navigator window\"),r.close()),e})})},UserManager.prototype._signoutEnd=function _signoutEnd(e){return this.processSignoutResponse(e).then(function(e){return i.Log.debug(\"UserManager._signoutEnd: got signout response\"),e})},UserManager.prototype.revokeAccessToken=function revokeAccessToken(){var e=this;return this._loadUser().then(function(t){return e._revokeInternal(t,!0).then(function(r){if(r)return i.Log.debug(\"UserManager.revokeAccessToken: removing token properties from user and re-storing\"),t.access_token=null,t.refresh_token=null,t.expires_at=null,t.token_type=null,e.storeUser(t).then(function(){i.Log.debug(\"UserManager.revokeAccessToken: user stored\"),e._events.load(t)})})}).then(function(){i.Log.info(\"UserManager.revokeAccessToken: access token revoked successfully\")})},UserManager.prototype._revokeInternal=function _revokeInternal(e,t){var r=this;if(e){var n=e.access_token,o=e.refresh_token;return this._revokeAccessTokenInternal(n,t).then(function(e){return r._revokeRefreshTokenInternal(o,t).then(function(t){return e||t||i.Log.debug(\"UserManager.revokeAccessToken: no need to revoke due to no token(s), or JWT format\"),e||t})})}return Promise.resolve(!1)},UserManager.prototype._revokeAccessTokenInternal=function _revokeAccessTokenInternal(e,t){return!e||e.indexOf(\".\")>=0?Promise.resolve(!1):this._tokenRevocationClient.revoke(e,t).then(function(){return!0})},UserManager.prototype._revokeRefreshTokenInternal=function _revokeRefreshTokenInternal(e,t){return e?this._tokenRevocationClient.revoke(e,t,\"refresh_token\").then(function(){return!0}):Promise.resolve(!1)},UserManager.prototype.startSilentRenew=function startSilentRenew(){this._silentRenewService.start()},UserManager.prototype.stopSilentRenew=function stopSilentRenew(){this._silentRenewService.stop()},UserManager.prototype._loadUser=function _loadUser(){return this._userStore.get(this._userStoreKey).then(function(e){return e?(i.Log.debug(\"UserManager._loadUser: user storageString loaded\"),a.User.fromStorageString(e)):(i.Log.debug(\"UserManager._loadUser: no user storageString\"),null)})},UserManager.prototype.storeUser=function storeUser(e){if(e){i.Log.debug(\"UserManager.storeUser: storing user\");var t=e.toStorageString();return this._userStore.set(this._userStoreKey,t)}return i.Log.debug(\"storeUser.storeUser: removing user\"),this._userStore.remove(this._userStoreKey)},n(UserManager,[{key:\"_redirectNavigator\",get:function get(){return this.settings.redirectNavigator}},{key:\"_popupNavigator\",get:function get(){return this.settings.popupNavigator}},{key:\"_iframeNavigator\",get:function get(){return this.settings.iframeNavigator}},{key:\"_userStore\",get:function get(){return this.settings.userStore}},{key:\"events\",get:function get(){return this._events}},{key:\"_userStoreKey\",get:function get(){return\"user:\"+this.settings.authority+\":\"+this.settings.client_id}}]),UserManager}(o.OidcClient)},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.UserManagerSettings=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=(r(0),r(5)),o=r(40),s=r(41),a=r(43),u=r(6),c=r(1),h=r(12);var l=60,f=2e3;t.UserManagerSettings=function(e){function UserManagerSettings(){var t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},r=t.popup_redirect_uri,n=t.popup_post_logout_redirect_uri,i=t.popupWindowFeatures,g=t.popupWindowTarget,p=t.silent_redirect_uri,d=t.silentRequestTimeout,v=t.automaticSilentRenew,y=void 0!==v&&v,m=t.includeIdTokenInSilentRenew,_=void 0===m||m,S=t.monitorSession,b=void 0===S||S,F=t.checkSessionInterval,w=void 0===F?f:F,E=t.stopCheckSessionOnError,x=void 0===E||E,C=t.query_status_response_type,k=t.revokeAccessTokenOnSignout,A=void 0!==k&&k,P=t.accessTokenExpiringNotificationTime,I=void 0===P?l:P,B=t.redirectNavigator,R=void 0===B?new o.RedirectNavigator:B,T=t.popupNavigator,U=void 0===T?new s.PopupNavigator:T,D=t.iframeNavigator,L=void 0===D?new a.IFrameNavigator:D,M=t.userStore,N=void 0===M?new u.WebStorageStateStore({store:c.Global.sessionStorage}):M;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,UserManagerSettings);var O=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!=typeof t&&\"function\"!=typeof t?e:t}(this,e.call(this,arguments[0]));return O._popup_redirect_uri=r,O._popup_post_logout_redirect_uri=n,O._popupWindowFeatures=i,O._popupWindowTarget=g,O._silent_redirect_uri=p,O._silentRequestTimeout=d,O._automaticSilentRenew=y,O._includeIdTokenInSilentRenew=_,O._accessTokenExpiringNotificationTime=I,O._monitorSession=b,O._checkSessionInterval=w,O._stopCheckSessionOnError=x,C?O._query_status_response_type=C:arguments[0]&&arguments[0].response_type?O._query_status_response_type=h.SigninRequest.isOidc(arguments[0].response_type)?\"id_token\":\"code\":O._query_status_response_type=\"id_token\",O._revokeAccessTokenOnSignout=A,O._redirectNavigator=R,O._popupNavigator=U,O._iframeNavigator=L,O._userStore=N,O}return function _inherits(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(UserManagerSettings,e),n(UserManagerSettings,[{key:\"popup_redirect_uri\",get:function get(){return this._popup_redirect_uri}},{key:\"popup_post_logout_redirect_uri\",get:function get(){return this._popup_post_logout_redirect_uri}},{key:\"popupWindowFeatures\",get:function get(){return this._popupWindowFeatures}},{key:\"popupWindowTarget\",get:function get(){return this._popupWindowTarget}},{key:\"silent_redirect_uri\",get:function get(){return this._silent_redirect_uri}},{key:\"silentRequestTimeout\",get:function get(){return this._silentRequestTimeout}},{key:\"automaticSilentRenew\",get:function get(){return this._automaticSilentRenew}},{key:\"includeIdTokenInSilentRenew\",get:function get(){return this._includeIdTokenInSilentRenew}},{key:\"accessTokenExpiringNotificationTime\",get:function get(){return this._accessTokenExpiringNotificationTime}},{key:\"monitorSession\",get:function get(){return this._monitorSession}},{key:\"checkSessionInterval\",get:function get(){return this._checkSessionInterval}},{key:\"stopCheckSessionOnError\",get:function get(){return this._stopCheckSessionOnError}},{key:\"query_status_response_type\",get:function get(){return this._query_status_response_type}},{key:\"revokeAccessTokenOnSignout\",get:function get(){return this._revokeAccessTokenOnSignout}},{key:\"redirectNavigator\",get:function get(){return this._redirectNavigator}},{key:\"popupNavigator\",get:function get(){return this._popupNavigator}},{key:\"iframeNavigator\",get:function get(){return this._iframeNavigator}},{key:\"userStore\",get:function get(){return this._userStore}}]),UserManagerSettings}(i.OidcClientSettings)},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.RedirectNavigator=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);t.RedirectNavigator=function(){function RedirectNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,RedirectNavigator)}return RedirectNavigator.prototype.prepare=function prepare(){return Promise.resolve(this)},RedirectNavigator.prototype.navigate=function navigate(e){return e&&e.url?(window.location=e.url,Promise.resolve()):(i.Log.error(\"RedirectNavigator.navigate: No url provided\"),Promise.reject(new Error(\"No url provided\")))},n(RedirectNavigator,[{key:\"url\",get:function get(){return window.location.href}}]),RedirectNavigator}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.PopupNavigator=void 0;var n=r(0),i=r(42);t.PopupNavigator=function(){function PopupNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,PopupNavigator)}return PopupNavigator.prototype.prepare=function prepare(e){var t=new i.PopupWindow(e);return Promise.resolve(t)},PopupNavigator.prototype.callback=function callback(e,t,r){n.Log.debug(\"PopupNavigator.callback\");try{return i.PopupWindow.notifyOpener(e,t,r),Promise.resolve()}catch(e){return Promise.reject(e)}},PopupNavigator}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.PopupWindow=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(3);var s=500,a=\"location=no,toolbar=no,width=500,height=500,left=100,top=100;\",u=\"_blank\";t.PopupWindow=function(){function PopupWindow(e){var t=this;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,PopupWindow),this._promise=new Promise(function(e,r){t._resolve=e,t._reject=r});var r=e.popupWindowTarget||u,n=e.popupWindowFeatures||a;this._popup=window.open(\"\",r,n),this._popup&&(i.Log.debug(\"PopupWindow.ctor: popup successfully created\"),this._checkForPopupClosedTimer=window.setInterval(this._checkForPopupClosed.bind(this),s))}return PopupWindow.prototype.navigate=function navigate(e){return this._popup?e&&e.url?(i.Log.debug(\"PopupWindow.navigate: Setting URL in popup\"),this._id=e.id,this._id&&(window[\"popupCallback_\"+e.id]=this._callback.bind(this)),this._popup.focus(),this._popup.window.location=e.url):(this._error(\"PopupWindow.navigate: no url provided\"),this._error(\"No url provided\")):this._error(\"PopupWindow.navigate: Error opening popup window\"),this.promise},PopupWindow.prototype._success=function _success(e){i.Log.debug(\"PopupWindow.callback: Successful response from popup window\"),this._cleanup(),this._resolve(e)},PopupWindow.prototype._error=function _error(e){i.Log.error(\"PopupWindow.error: \",e),this._cleanup(),this._reject(new Error(e))},PopupWindow.prototype.close=function close(){this._cleanup(!1)},PopupWindow.prototype._cleanup=function _cleanup(e){i.Log.debug(\"PopupWindow.cleanup\"),window.clearInterval(this._checkForPopupClosedTimer),this._checkForPopupClosedTimer=null,delete window[\"popupCallback_\"+this._id],this._popup&&!e&&this._popup.close(),this._popup=null},PopupWindow.prototype._checkForPopupClosed=function _checkForPopupClosed(){this._popup&&!this._popup.closed||this._error(\"Popup window closed\")},PopupWindow.prototype._callback=function _callback(e,t){this._cleanup(t),e?(i.Log.debug(\"PopupWindow.callback success\"),this._success({url:e})):(i.Log.debug(\"PopupWindow.callback: Invalid response from popup\"),this._error(\"Invalid response from popup\"))},PopupWindow.notifyOpener=function notifyOpener(e,t,r){if(window.opener){if(e=e||window.location.href){var n=o.UrlUtility.parseUrlFragment(e,r);if(n.state){var s=\"popupCallback_\"+n.state,a=window.opener[s];a?(i.Log.debug(\"PopupWindow.notifyOpener: passing url message to opener\"),a(e,t)):i.Log.warn(\"PopupWindow.notifyOpener: no matching callback found on opener\")}else i.Log.warn(\"PopupWindow.notifyOpener: no state found in response url\")}}else i.Log.warn(\"PopupWindow.notifyOpener: no window.opener. Can't complete notification.\")},n(PopupWindow,[{key:\"promise\",get:function get(){return this._promise}}]),PopupWindow}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.IFrameNavigator=void 0;var n=r(0),i=r(44);t.IFrameNavigator=function(){function IFrameNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,IFrameNavigator)}return IFrameNavigator.prototype.prepare=function prepare(e){var t=new i.IFrameWindow(e);return Promise.resolve(t)},IFrameNavigator.prototype.callback=function callback(e){n.Log.debug(\"IFrameNavigator.callback\");try{return i.IFrameWindow.notifyParent(e),Promise.resolve()}catch(e){return Promise.reject(e)}},IFrameNavigator}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.IFrameWindow=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0);t.IFrameWindow=function(){function IFrameWindow(e){var t=this;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,IFrameWindow),this._promise=new Promise(function(e,r){t._resolve=e,t._reject=r}),this._boundMessageEvent=this._message.bind(this),window.addEventListener(\"message\",this._boundMessageEvent,!1),this._frame=window.document.createElement(\"iframe\"),this._frame.style.visibility=\"hidden\",this._frame.style.position=\"absolute\",this._frame.style.display=\"none\",this._frame.style.width=0,this._frame.style.height=0,window.document.body.appendChild(this._frame)}return IFrameWindow.prototype.navigate=function navigate(e){if(e&&e.url){var t=e.silentRequestTimeout||1e4;i.Log.debug(\"IFrameWindow.navigate: Using timeout of:\",t),this._timer=window.setTimeout(this._timeout.bind(this),t),this._frame.src=e.url}else this._error(\"No url provided\");return this.promise},IFrameWindow.prototype._success=function _success(e){this._cleanup(),i.Log.debug(\"IFrameWindow: Successful response from frame window\"),this._resolve(e)},IFrameWindow.prototype._error=function _error(e){this._cleanup(),i.Log.error(e),this._reject(new Error(e))},IFrameWindow.prototype.close=function close(){this._cleanup()},IFrameWindow.prototype._cleanup=function _cleanup(){this._frame&&(i.Log.debug(\"IFrameWindow: cleanup\"),window.removeEventListener(\"message\",this._boundMessageEvent,!1),window.clearTimeout(this._timer),window.document.body.removeChild(this._frame),this._timer=null,this._frame=null,this._boundMessageEvent=null)},IFrameWindow.prototype._timeout=function _timeout(){i.Log.debug(\"IFrameWindow.timeout\"),this._error(\"Frame window timed out\")},IFrameWindow.prototype._message=function _message(e){if(i.Log.debug(\"IFrameWindow.message\"),this._timer&&e.origin===this._origin&&e.source===this._frame.contentWindow){var t=e.data;t?this._success({url:t}):this._error(\"Invalid response from frame\")}},IFrameWindow.notifyParent=function notifyParent(e){i.Log.debug(\"IFrameWindow.notifyParent\"),window.frameElement&&(e=e||window.location.href)&&(i.Log.debug(\"IFrameWindow.notifyParent: posting url message to parent\"),window.parent.postMessage(e,location.protocol+\"//\"+location.host))},n(IFrameWindow,[{key:\"promise\",get:function get(){return this._promise}},{key:\"_origin\",get:function get(){return location.protocol+\"//\"+location.host}}]),IFrameWindow}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.UserManagerEvents=void 0;var n=r(0),i=r(16),o=r(17);t.UserManagerEvents=function(e){function UserManagerEvents(t){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,UserManagerEvents);var r=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!=typeof t&&\"function\"!=typeof t?e:t}(this,e.call(this,t));return r._userLoaded=new o.Event(\"User loaded\"),r._userUnloaded=new o.Event(\"User unloaded\"),r._silentRenewError=new o.Event(\"Silent renew error\"),r._userSignedOut=new o.Event(\"User signed out\"),r._userSessionChanged=new o.Event(\"User session changed\"),r}return function _inherits(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(UserManagerEvents,e),UserManagerEvents.prototype.load=function load(t){var r=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];n.Log.debug(\"UserManagerEvents.load\"),e.prototype.load.call(this,t),r&&this._userLoaded.raise(t)},UserManagerEvents.prototype.unload=function unload(){n.Log.debug(\"UserManagerEvents.unload\"),e.prototype.unload.call(this),this._userUnloaded.raise()},UserManagerEvents.prototype.addUserLoaded=function addUserLoaded(e){this._userLoaded.addHandler(e)},UserManagerEvents.prototype.removeUserLoaded=function removeUserLoaded(e){this._userLoaded.removeHandler(e)},UserManagerEvents.prototype.addUserUnloaded=function addUserUnloaded(e){this._userUnloaded.addHandler(e)},UserManagerEvents.prototype.removeUserUnloaded=function removeUserUnloaded(e){this._userUnloaded.removeHandler(e)},UserManagerEvents.prototype.addSilentRenewError=function addSilentRenewError(e){this._silentRenewError.addHandler(e)},UserManagerEvents.prototype.removeSilentRenewError=function removeSilentRenewError(e){this._silentRenewError.removeHandler(e)},UserManagerEvents.prototype._raiseSilentRenewError=function _raiseSilentRenewError(e){n.Log.debug(\"UserManagerEvents._raiseSilentRenewError\",e.message),this._silentRenewError.raise(e)},UserManagerEvents.prototype.addUserSignedOut=function addUserSignedOut(e){this._userSignedOut.addHandler(e)},UserManagerEvents.prototype.removeUserSignedOut=function removeUserSignedOut(e){this._userSignedOut.removeHandler(e)},UserManagerEvents.prototype._raiseUserSignedOut=function _raiseUserSignedOut(e){n.Log.debug(\"UserManagerEvents._raiseUserSignedOut\"),this._userSignedOut.raise(e)},UserManagerEvents.prototype.addUserSessionChanged=function addUserSessionChanged(e){this._userSessionChanged.addHandler(e)},UserManagerEvents.prototype.removeUserSessionChanged=function removeUserSessionChanged(e){this._userSessionChanged.removeHandler(e)},UserManagerEvents.prototype._raiseUserSessionChanged=function _raiseUserSessionChanged(e){n.Log.debug(\"UserManagerEvents._raiseUserSessionChanged\"),this._userSessionChanged.raise(e)},UserManagerEvents}(i.AccessTokenEvents)},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.Timer=void 0;var n=function(){function defineProperties(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,\"value\"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}return function(e,t,r){return t&&defineProperties(e.prototype,t),r&&defineProperties(e,r),e}}(),i=r(0),o=r(1),s=r(17);t.Timer=function(e){function Timer(t){var r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:o.Global.timer,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,Timer);var i=function _possibleConstructorReturn(e,t){if(!e)throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");return!t||\"object\"!=typeof t&&\"function\"!=typeof t?e:t}(this,e.call(this,t));return i._timer=r,i._nowFunc=n||function(){return Date.now()/1e3},i}return function _inherits(e,t){if(\"function\"!=typeof t&&null!==t)throw new TypeError(\"Super expression must either be null or a function, not \"+typeof t);e.prototype=Object.create(t&&t.prototype,{constructor:{value:e,enumerable:!1,writable:!0,configurable:!0}}),t&&(Object.setPrototypeOf?Object.setPrototypeOf(e,t):e.__proto__=t)}(Timer,e),Timer.prototype.init=function init(e){e<=0&&(e=1),e=parseInt(e);var t=this.now+e;if(this.expiration===t&&this._timerHandle)i.Log.debug(\"Timer.init timer \"+this._name+\" skipping initialization since already initialized for expiration:\",this.expiration);else{this.cancel(),i.Log.debug(\"Timer.init timer \"+this._name+\" for duration:\",e),this._expiration=t;var r=5;e<r&&(r=e),this._timerHandle=this._timer.setInterval(this._callback.bind(this),1e3*r)}},Timer.prototype.cancel=function cancel(){this._timerHandle&&(i.Log.debug(\"Timer.cancel: \",this._name),this._timer.clearInterval(this._timerHandle),this._timerHandle=null)},Timer.prototype._callback=function _callback(){var t=this._expiration-this.now;i.Log.debug(\"Timer.callback; \"+this._name+\" timer expires in:\",t),this._expiration<=this.now&&(this.cancel(),e.prototype.raise.call(this))},n(Timer,[{key:\"now\",get:function get(){return parseInt(this._nowFunc())}},{key:\"expiration\",get:function get(){return this._expiration}}]),Timer}(s.Event)},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.SilentRenewService=void 0;var n=r(0);t.SilentRenewService=function(){function SilentRenewService(e){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,SilentRenewService),this._userManager=e}return SilentRenewService.prototype.start=function start(){this._callback||(this._callback=this._tokenExpiring.bind(this),this._userManager.events.addAccessTokenExpiring(this._callback),this._userManager.getUser().then(function(e){}).catch(function(e){n.Log.error(\"SilentRenewService.start: Error from getUser:\",e.message)}))},SilentRenewService.prototype.stop=function stop(){this._callback&&(this._userManager.events.removeAccessTokenExpiring(this._callback),delete this._callback)},SilentRenewService.prototype._tokenExpiring=function _tokenExpiring(){var e=this;this._userManager.signinSilent().then(function(e){n.Log.debug(\"SilentRenewService._tokenExpiring: Silent token renewal successful\")},function(t){n.Log.error(\"SilentRenewService._tokenExpiring: Error from signinSilent:\",t.message),e._userManager.events._raiseSilentRenewError(t)})},SilentRenewService}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.CordovaPopupNavigator=void 0;var n=r(21);t.CordovaPopupNavigator=function(){function CordovaPopupNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,CordovaPopupNavigator)}return CordovaPopupNavigator.prototype.prepare=function prepare(e){var t=new n.CordovaPopupWindow(e);return Promise.resolve(t)},CordovaPopupNavigator}()},function(e,t,r){\"use strict\";Object.defineProperty(t,\"__esModule\",{value:!0}),t.CordovaIFrameNavigator=void 0;var n=r(21);t.CordovaIFrameNavigator=function(){function CordovaIFrameNavigator(){!function _classCallCheck(e,t){if(!(e instanceof t))throw new TypeError(\"Cannot call a class as a function\")}(this,CordovaIFrameNavigator)}return CordovaIFrameNavigator.prototype.prepare=function prepare(e){e.popupWindowFeatures=\"hidden=yes\";var t=new n.CordovaPopupWindow(e);return Promise.resolve(t)},CordovaIFrameNavigator}()}])});","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","exports = module.exports = SemVer\n\nvar debug\n/* istanbul ignore next */\nif (typeof process === 'object' &&\n    process.env &&\n    process.env.NODE_DEBUG &&\n    /\\bsemver\\b/i.test(process.env.NODE_DEBUG)) {\n  debug = function () {\n    var args = Array.prototype.slice.call(arguments, 0)\n    args.unshift('SEMVER')\n    console.log.apply(console, args)\n  }\n} else {\n  debug = function () {}\n}\n\n// Note: this is the semver.org version of the spec that it implements\n// Not necessarily the package version of this code.\nexports.SEMVER_SPEC_VERSION = '2.0.0'\n\nvar MAX_LENGTH = 256\nvar MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER ||\n  /* istanbul ignore next */ 9007199254740991\n\n// Max safe segment length for coercion.\nvar MAX_SAFE_COMPONENT_LENGTH = 16\n\n// The actual regexps go on exports.re\nvar re = exports.re = []\nvar src = exports.src = []\nvar R = 0\n\n// The following Regular Expressions can be used for tokenizing,\n// validating, and parsing SemVer version strings.\n\n// ## Numeric Identifier\n// A single `0`, or a non-zero digit followed by zero or more digits.\n\nvar NUMERICIDENTIFIER = R++\nsrc[NUMERICIDENTIFIER] = '0|[1-9]\\\\d*'\nvar NUMERICIDENTIFIERLOOSE = R++\nsrc[NUMERICIDENTIFIERLOOSE] = '[0-9]+'\n\n// ## Non-numeric Identifier\n// Zero or more digits, followed by a letter or hyphen, and then zero or\n// more letters, digits, or hyphens.\n\nvar NONNUMERICIDENTIFIER = R++\nsrc[NONNUMERICIDENTIFIER] = '\\\\d*[a-zA-Z-][a-zA-Z0-9-]*'\n\n// ## Main Version\n// Three dot-separated numeric identifiers.\n\nvar MAINVERSION = R++\nsrc[MAINVERSION] = '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')\\\\.' +\n                   '(' + src[NUMERICIDENTIFIER] + ')'\n\nvar MAINVERSIONLOOSE = R++\nsrc[MAINVERSIONLOOSE] = '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')\\\\.' +\n                        '(' + src[NUMERICIDENTIFIERLOOSE] + ')'\n\n// ## Pre-release Version Identifier\n// A numeric identifier, or a non-numeric identifier.\n\nvar PRERELEASEIDENTIFIER = R++\nsrc[PRERELEASEIDENTIFIER] = '(?:' + src[NUMERICIDENTIFIER] +\n                            '|' + src[NONNUMERICIDENTIFIER] + ')'\n\nvar PRERELEASEIDENTIFIERLOOSE = R++\nsrc[PRERELEASEIDENTIFIERLOOSE] = '(?:' + src[NUMERICIDENTIFIERLOOSE] +\n                                 '|' + src[NONNUMERICIDENTIFIER] + ')'\n\n// ## Pre-release Version\n// Hyphen, followed by one or more dot-separated pre-release version\n// identifiers.\n\nvar PRERELEASE = R++\nsrc[PRERELEASE] = '(?:-(' + src[PRERELEASEIDENTIFIER] +\n                  '(?:\\\\.' + src[PRERELEASEIDENTIFIER] + ')*))'\n\nvar PRERELEASELOOSE = R++\nsrc[PRERELEASELOOSE] = '(?:-?(' + src[PRERELEASEIDENTIFIERLOOSE] +\n                       '(?:\\\\.' + src[PRERELEASEIDENTIFIERLOOSE] + ')*))'\n\n// ## Build Metadata Identifier\n// Any combination of digits, letters, or hyphens.\n\nvar BUILDIDENTIFIER = R++\nsrc[BUILDIDENTIFIER] = '[0-9A-Za-z-]+'\n\n// ## Build Metadata\n// Plus sign, followed by one or more period-separated build metadata\n// identifiers.\n\nvar BUILD = R++\nsrc[BUILD] = '(?:\\\\+(' + src[BUILDIDENTIFIER] +\n             '(?:\\\\.' + src[BUILDIDENTIFIER] + ')*))'\n\n// ## Full Version String\n// A main version, followed optionally by a pre-release version and\n// build metadata.\n\n// Note that the only major, minor, patch, and pre-release sections of\n// the version string are capturing groups.  The build metadata is not a\n// capturing group, because it should not ever be used in version\n// comparison.\n\nvar FULL = R++\nvar FULLPLAIN = 'v?' + src[MAINVERSION] +\n                src[PRERELEASE] + '?' +\n                src[BUILD] + '?'\n\nsrc[FULL] = '^' + FULLPLAIN + '$'\n\n// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.\n// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty\n// common in the npm registry.\nvar LOOSEPLAIN = '[v=\\\\s]*' + src[MAINVERSIONLOOSE] +\n                 src[PRERELEASELOOSE] + '?' +\n                 src[BUILD] + '?'\n\nvar LOOSE = R++\nsrc[LOOSE] = '^' + LOOSEPLAIN + '$'\n\nvar GTLT = R++\nsrc[GTLT] = '((?:<|>)?=?)'\n\n// Something like \"2.*\" or \"1.2.x\".\n// Note that \"x.x\" is a valid xRange identifer, meaning \"any version\"\n// Only the first item is strictly required.\nvar XRANGEIDENTIFIERLOOSE = R++\nsrc[XRANGEIDENTIFIERLOOSE] = src[NUMERICIDENTIFIERLOOSE] + '|x|X|\\\\*'\nvar XRANGEIDENTIFIER = R++\nsrc[XRANGEIDENTIFIER] = src[NUMERICIDENTIFIER] + '|x|X|\\\\*'\n\nvar XRANGEPLAIN = R++\nsrc[XRANGEPLAIN] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:\\\\.(' + src[XRANGEIDENTIFIER] + ')' +\n                   '(?:' + src[PRERELEASE] + ')?' +\n                   src[BUILD] + '?' +\n                   ')?)?'\n\nvar XRANGEPLAINLOOSE = R++\nsrc[XRANGEPLAINLOOSE] = '[v=\\\\s]*(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:\\\\.(' + src[XRANGEIDENTIFIERLOOSE] + ')' +\n                        '(?:' + src[PRERELEASELOOSE] + ')?' +\n                        src[BUILD] + '?' +\n                        ')?)?'\n\nvar XRANGE = R++\nsrc[XRANGE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAIN] + '$'\nvar XRANGELOOSE = R++\nsrc[XRANGELOOSE] = '^' + src[GTLT] + '\\\\s*' + src[XRANGEPLAINLOOSE] + '$'\n\n// Coercion.\n// Extract anything that could conceivably be a part of a valid semver\nvar COERCE = R++\nsrc[COERCE] = '(?:^|[^\\\\d])' +\n              '(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '})' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:\\\\.(\\\\d{1,' + MAX_SAFE_COMPONENT_LENGTH + '}))?' +\n              '(?:$|[^\\\\d])'\n\n// Tilde ranges.\n// Meaning is \"reasonably at or greater than\"\nvar LONETILDE = R++\nsrc[LONETILDE] = '(?:~>?)'\n\nvar TILDETRIM = R++\nsrc[TILDETRIM] = '(\\\\s*)' + src[LONETILDE] + '\\\\s+'\nre[TILDETRIM] = new RegExp(src[TILDETRIM], 'g')\nvar tildeTrimReplace = '$1~'\n\nvar TILDE = R++\nsrc[TILDE] = '^' + src[LONETILDE] + src[XRANGEPLAIN] + '$'\nvar TILDELOOSE = R++\nsrc[TILDELOOSE] = '^' + src[LONETILDE] + src[XRANGEPLAINLOOSE] + '$'\n\n// Caret ranges.\n// Meaning is \"at least and backwards compatible with\"\nvar LONECARET = R++\nsrc[LONECARET] = '(?:\\\\^)'\n\nvar CARETTRIM = R++\nsrc[CARETTRIM] = '(\\\\s*)' + src[LONECARET] + '\\\\s+'\nre[CARETTRIM] = new RegExp(src[CARETTRIM], 'g')\nvar caretTrimReplace = '$1^'\n\nvar CARET = R++\nsrc[CARET] = '^' + src[LONECARET] + src[XRANGEPLAIN] + '$'\nvar CARETLOOSE = R++\nsrc[CARETLOOSE] = '^' + src[LONECARET] + src[XRANGEPLAINLOOSE] + '$'\n\n// A simple gt/lt/eq thing, or just \"\" to indicate \"any version\"\nvar COMPARATORLOOSE = R++\nsrc[COMPARATORLOOSE] = '^' + src[GTLT] + '\\\\s*(' + LOOSEPLAIN + ')$|^$'\nvar COMPARATOR = R++\nsrc[COMPARATOR] = '^' + src[GTLT] + '\\\\s*(' + FULLPLAIN + ')$|^$'\n\n// An expression to strip any whitespace between the gtlt and the thing\n// it modifies, so that `> 1.2.3` ==> `>1.2.3`\nvar COMPARATORTRIM = R++\nsrc[COMPARATORTRIM] = '(\\\\s*)' + src[GTLT] +\n                      '\\\\s*(' + LOOSEPLAIN + '|' + src[XRANGEPLAIN] + ')'\n\n// this one has to use the /g flag\nre[COMPARATORTRIM] = new RegExp(src[COMPARATORTRIM], 'g')\nvar comparatorTrimReplace = '$1$2$3'\n\n// Something like `1.2.3 - 1.2.4`\n// Note that these all use the loose form, because they'll be\n// checked against either the strict or loose comparator form\n// later.\nvar HYPHENRANGE = R++\nsrc[HYPHENRANGE] = '^\\\\s*(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s+-\\\\s+' +\n                   '(' + src[XRANGEPLAIN] + ')' +\n                   '\\\\s*$'\n\nvar HYPHENRANGELOOSE = R++\nsrc[HYPHENRANGELOOSE] = '^\\\\s*(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s+-\\\\s+' +\n                        '(' + src[XRANGEPLAINLOOSE] + ')' +\n                        '\\\\s*$'\n\n// Star ranges basically just allow anything at all.\nvar STAR = R++\nsrc[STAR] = '(<|>)?=?\\\\s*\\\\*'\n\n// Compile to actual regexp objects.\n// All are flag-free, unless they were created above with a flag.\nfor (var i = 0; i < R; i++) {\n  debug(i, src[i])\n  if (!re[i]) {\n    re[i] = new RegExp(src[i])\n  }\n}\n\nexports.parse = parse\nfunction parse (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  if (version.length > MAX_LENGTH) {\n    return null\n  }\n\n  var r = options.loose ? re[LOOSE] : re[FULL]\n  if (!r.test(version)) {\n    return null\n  }\n\n  try {\n    return new SemVer(version, options)\n  } catch (er) {\n    return null\n  }\n}\n\nexports.valid = valid\nfunction valid (version, options) {\n  var v = parse(version, options)\n  return v ? v.version : null\n}\n\nexports.clean = clean\nfunction clean (version, options) {\n  var s = parse(version.trim().replace(/^[=v]+/, ''), options)\n  return s ? s.version : null\n}\n\nexports.SemVer = SemVer\n\nfunction SemVer (version, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n  if (version instanceof SemVer) {\n    if (version.loose === options.loose) {\n      return version\n    } else {\n      version = version.version\n    }\n  } else if (typeof version !== 'string') {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  if (version.length > MAX_LENGTH) {\n    throw new TypeError('version is longer than ' + MAX_LENGTH + ' characters')\n  }\n\n  if (!(this instanceof SemVer)) {\n    return new SemVer(version, options)\n  }\n\n  debug('SemVer', version, options)\n  this.options = options\n  this.loose = !!options.loose\n\n  var m = version.trim().match(options.loose ? re[LOOSE] : re[FULL])\n\n  if (!m) {\n    throw new TypeError('Invalid Version: ' + version)\n  }\n\n  this.raw = version\n\n  // these are actually numbers\n  this.major = +m[1]\n  this.minor = +m[2]\n  this.patch = +m[3]\n\n  if (this.major > MAX_SAFE_INTEGER || this.major < 0) {\n    throw new TypeError('Invalid major version')\n  }\n\n  if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {\n    throw new TypeError('Invalid minor version')\n  }\n\n  if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {\n    throw new TypeError('Invalid patch version')\n  }\n\n  // numberify any prerelease numeric ids\n  if (!m[4]) {\n    this.prerelease = []\n  } else {\n    this.prerelease = m[4].split('.').map(function (id) {\n      if (/^[0-9]+$/.test(id)) {\n        var num = +id\n        if (num >= 0 && num < MAX_SAFE_INTEGER) {\n          return num\n        }\n      }\n      return id\n    })\n  }\n\n  this.build = m[5] ? m[5].split('.') : []\n  this.format()\n}\n\nSemVer.prototype.format = function () {\n  this.version = this.major + '.' + this.minor + '.' + this.patch\n  if (this.prerelease.length) {\n    this.version += '-' + this.prerelease.join('.')\n  }\n  return this.version\n}\n\nSemVer.prototype.toString = function () {\n  return this.version\n}\n\nSemVer.prototype.compare = function (other) {\n  debug('SemVer.compare', this.version, this.options, other)\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return this.compareMain(other) || this.comparePre(other)\n}\n\nSemVer.prototype.compareMain = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  return compareIdentifiers(this.major, other.major) ||\n         compareIdentifiers(this.minor, other.minor) ||\n         compareIdentifiers(this.patch, other.patch)\n}\n\nSemVer.prototype.comparePre = function (other) {\n  if (!(other instanceof SemVer)) {\n    other = new SemVer(other, this.options)\n  }\n\n  // NOT having a prerelease is > having one\n  if (this.prerelease.length && !other.prerelease.length) {\n    return -1\n  } else if (!this.prerelease.length && other.prerelease.length) {\n    return 1\n  } else if (!this.prerelease.length && !other.prerelease.length) {\n    return 0\n  }\n\n  var i = 0\n  do {\n    var a = this.prerelease[i]\n    var b = other.prerelease[i]\n    debug('prerelease compare', i, a, b)\n    if (a === undefined && b === undefined) {\n      return 0\n    } else if (b === undefined) {\n      return 1\n    } else if (a === undefined) {\n      return -1\n    } else if (a === b) {\n      continue\n    } else {\n      return compareIdentifiers(a, b)\n    }\n  } while (++i)\n}\n\n// preminor will bump the version up to the next minor release, and immediately\n// down to pre-release. premajor and prepatch work the same way.\nSemVer.prototype.inc = function (release, identifier) {\n  switch (release) {\n    case 'premajor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor = 0\n      this.major++\n      this.inc('pre', identifier)\n      break\n    case 'preminor':\n      this.prerelease.length = 0\n      this.patch = 0\n      this.minor++\n      this.inc('pre', identifier)\n      break\n    case 'prepatch':\n      // If this is already a prerelease, it will bump to the next version\n      // drop any prereleases that might already exist, since they are not\n      // relevant at this point.\n      this.prerelease.length = 0\n      this.inc('patch', identifier)\n      this.inc('pre', identifier)\n      break\n    // If the input is a non-prerelease version, this acts the same as\n    // prepatch.\n    case 'prerelease':\n      if (this.prerelease.length === 0) {\n        this.inc('patch', identifier)\n      }\n      this.inc('pre', identifier)\n      break\n\n    case 'major':\n      // If this is a pre-major version, bump up to the same major version.\n      // Otherwise increment major.\n      // 1.0.0-5 bumps to 1.0.0\n      // 1.1.0 bumps to 2.0.0\n      if (this.minor !== 0 ||\n          this.patch !== 0 ||\n          this.prerelease.length === 0) {\n        this.major++\n      }\n      this.minor = 0\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'minor':\n      // If this is a pre-minor version, bump up to the same minor version.\n      // Otherwise increment minor.\n      // 1.2.0-5 bumps to 1.2.0\n      // 1.2.1 bumps to 1.3.0\n      if (this.patch !== 0 || this.prerelease.length === 0) {\n        this.minor++\n      }\n      this.patch = 0\n      this.prerelease = []\n      break\n    case 'patch':\n      // If this is not a pre-release version, it will increment the patch.\n      // If it is a pre-release it will bump up to the same patch version.\n      // 1.2.0-5 patches to 1.2.0\n      // 1.2.0 patches to 1.2.1\n      if (this.prerelease.length === 0) {\n        this.patch++\n      }\n      this.prerelease = []\n      break\n    // This probably shouldn't be used publicly.\n    // 1.0.0 \"pre\" would become 1.0.0-0 which is the wrong direction.\n    case 'pre':\n      if (this.prerelease.length === 0) {\n        this.prerelease = [0]\n      } else {\n        var i = this.prerelease.length\n        while (--i >= 0) {\n          if (typeof this.prerelease[i] === 'number') {\n            this.prerelease[i]++\n            i = -2\n          }\n        }\n        if (i === -1) {\n          // didn't increment anything\n          this.prerelease.push(0)\n        }\n      }\n      if (identifier) {\n        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,\n        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0\n        if (this.prerelease[0] === identifier) {\n          if (isNaN(this.prerelease[1])) {\n            this.prerelease = [identifier, 0]\n          }\n        } else {\n          this.prerelease = [identifier, 0]\n        }\n      }\n      break\n\n    default:\n      throw new Error('invalid increment argument: ' + release)\n  }\n  this.format()\n  this.raw = this.version\n  return this\n}\n\nexports.inc = inc\nfunction inc (version, release, loose, identifier) {\n  if (typeof (loose) === 'string') {\n    identifier = loose\n    loose = undefined\n  }\n\n  try {\n    return new SemVer(version, loose).inc(release, identifier).version\n  } catch (er) {\n    return null\n  }\n}\n\nexports.diff = diff\nfunction diff (version1, version2) {\n  if (eq(version1, version2)) {\n    return null\n  } else {\n    var v1 = parse(version1)\n    var v2 = parse(version2)\n    var prefix = ''\n    if (v1.prerelease.length || v2.prerelease.length) {\n      prefix = 'pre'\n      var defaultResult = 'prerelease'\n    }\n    for (var key in v1) {\n      if (key === 'major' || key === 'minor' || key === 'patch') {\n        if (v1[key] !== v2[key]) {\n          return prefix + key\n        }\n      }\n    }\n    return defaultResult // may be undefined\n  }\n}\n\nexports.compareIdentifiers = compareIdentifiers\n\nvar numeric = /^[0-9]+$/\nfunction compareIdentifiers (a, b) {\n  var anum = numeric.test(a)\n  var bnum = numeric.test(b)\n\n  if (anum && bnum) {\n    a = +a\n    b = +b\n  }\n\n  return a === b ? 0\n    : (anum && !bnum) ? -1\n    : (bnum && !anum) ? 1\n    : a < b ? -1\n    : 1\n}\n\nexports.rcompareIdentifiers = rcompareIdentifiers\nfunction rcompareIdentifiers (a, b) {\n  return compareIdentifiers(b, a)\n}\n\nexports.major = major\nfunction major (a, loose) {\n  return new SemVer(a, loose).major\n}\n\nexports.minor = minor\nfunction minor (a, loose) {\n  return new SemVer(a, loose).minor\n}\n\nexports.patch = patch\nfunction patch (a, loose) {\n  return new SemVer(a, loose).patch\n}\n\nexports.compare = compare\nfunction compare (a, b, loose) {\n  return new SemVer(a, loose).compare(new SemVer(b, loose))\n}\n\nexports.compareLoose = compareLoose\nfunction compareLoose (a, b) {\n  return compare(a, b, true)\n}\n\nexports.rcompare = rcompare\nfunction rcompare (a, b, loose) {\n  return compare(b, a, loose)\n}\n\nexports.sort = sort\nfunction sort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.compare(a, b, loose)\n  })\n}\n\nexports.rsort = rsort\nfunction rsort (list, loose) {\n  return list.sort(function (a, b) {\n    return exports.rcompare(a, b, loose)\n  })\n}\n\nexports.gt = gt\nfunction gt (a, b, loose) {\n  return compare(a, b, loose) > 0\n}\n\nexports.lt = lt\nfunction lt (a, b, loose) {\n  return compare(a, b, loose) < 0\n}\n\nexports.eq = eq\nfunction eq (a, b, loose) {\n  return compare(a, b, loose) === 0\n}\n\nexports.neq = neq\nfunction neq (a, b, loose) {\n  return compare(a, b, loose) !== 0\n}\n\nexports.gte = gte\nfunction gte (a, b, loose) {\n  return compare(a, b, loose) >= 0\n}\n\nexports.lte = lte\nfunction lte (a, b, loose) {\n  return compare(a, b, loose) <= 0\n}\n\nexports.cmp = cmp\nfunction cmp (a, op, b, loose) {\n  switch (op) {\n    case '===':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a === b\n\n    case '!==':\n      if (typeof a === 'object')\n        a = a.version\n      if (typeof b === 'object')\n        b = b.version\n      return a !== b\n\n    case '':\n    case '=':\n    case '==':\n      return eq(a, b, loose)\n\n    case '!=':\n      return neq(a, b, loose)\n\n    case '>':\n      return gt(a, b, loose)\n\n    case '>=':\n      return gte(a, b, loose)\n\n    case '<':\n      return lt(a, b, loose)\n\n    case '<=':\n      return lte(a, b, loose)\n\n    default:\n      throw new TypeError('Invalid operator: ' + op)\n  }\n}\n\nexports.Comparator = Comparator\nfunction Comparator (comp, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (comp instanceof Comparator) {\n    if (comp.loose === !!options.loose) {\n      return comp\n    } else {\n      comp = comp.value\n    }\n  }\n\n  if (!(this instanceof Comparator)) {\n    return new Comparator(comp, options)\n  }\n\n  debug('comparator', comp, options)\n  this.options = options\n  this.loose = !!options.loose\n  this.parse(comp)\n\n  if (this.semver === ANY) {\n    this.value = ''\n  } else {\n    this.value = this.operator + this.semver.version\n  }\n\n  debug('comp', this)\n}\n\nvar ANY = {}\nComparator.prototype.parse = function (comp) {\n  var r = this.options.loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var m = comp.match(r)\n\n  if (!m) {\n    throw new TypeError('Invalid comparator: ' + comp)\n  }\n\n  this.operator = m[1]\n  if (this.operator === '=') {\n    this.operator = ''\n  }\n\n  // if it literally is just '>' or '' then allow anything.\n  if (!m[2]) {\n    this.semver = ANY\n  } else {\n    this.semver = new SemVer(m[2], this.options.loose)\n  }\n}\n\nComparator.prototype.toString = function () {\n  return this.value\n}\n\nComparator.prototype.test = function (version) {\n  debug('Comparator.test', version, this.options.loose)\n\n  if (this.semver === ANY) {\n    return true\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  return cmp(version, this.operator, this.semver, this.options)\n}\n\nComparator.prototype.intersects = function (comp, options) {\n  if (!(comp instanceof Comparator)) {\n    throw new TypeError('a Comparator is required')\n  }\n\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  var rangeTmp\n\n  if (this.operator === '') {\n    rangeTmp = new Range(comp.value, options)\n    return satisfies(this.value, rangeTmp, options)\n  } else if (comp.operator === '') {\n    rangeTmp = new Range(this.value, options)\n    return satisfies(comp.semver, rangeTmp, options)\n  }\n\n  var sameDirectionIncreasing =\n    (this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '>=' || comp.operator === '>')\n  var sameDirectionDecreasing =\n    (this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '<=' || comp.operator === '<')\n  var sameSemVer = this.semver.version === comp.semver.version\n  var differentDirectionsInclusive =\n    (this.operator === '>=' || this.operator === '<=') &&\n    (comp.operator === '>=' || comp.operator === '<=')\n  var oppositeDirectionsLessThan =\n    cmp(this.semver, '<', comp.semver, options) &&\n    ((this.operator === '>=' || this.operator === '>') &&\n    (comp.operator === '<=' || comp.operator === '<'))\n  var oppositeDirectionsGreaterThan =\n    cmp(this.semver, '>', comp.semver, options) &&\n    ((this.operator === '<=' || this.operator === '<') &&\n    (comp.operator === '>=' || comp.operator === '>'))\n\n  return sameDirectionIncreasing || sameDirectionDecreasing ||\n    (sameSemVer && differentDirectionsInclusive) ||\n    oppositeDirectionsLessThan || oppositeDirectionsGreaterThan\n}\n\nexports.Range = Range\nfunction Range (range, options) {\n  if (!options || typeof options !== 'object') {\n    options = {\n      loose: !!options,\n      includePrerelease: false\n    }\n  }\n\n  if (range instanceof Range) {\n    if (range.loose === !!options.loose &&\n        range.includePrerelease === !!options.includePrerelease) {\n      return range\n    } else {\n      return new Range(range.raw, options)\n    }\n  }\n\n  if (range instanceof Comparator) {\n    return new Range(range.value, options)\n  }\n\n  if (!(this instanceof Range)) {\n    return new Range(range, options)\n  }\n\n  this.options = options\n  this.loose = !!options.loose\n  this.includePrerelease = !!options.includePrerelease\n\n  // First, split based on boolean or ||\n  this.raw = range\n  this.set = range.split(/\\s*\\|\\|\\s*/).map(function (range) {\n    return this.parseRange(range.trim())\n  }, this).filter(function (c) {\n    // throw out any that are not relevant for whatever reason\n    return c.length\n  })\n\n  if (!this.set.length) {\n    throw new TypeError('Invalid SemVer Range: ' + range)\n  }\n\n  this.format()\n}\n\nRange.prototype.format = function () {\n  this.range = this.set.map(function (comps) {\n    return comps.join(' ').trim()\n  }).join('||').trim()\n  return this.range\n}\n\nRange.prototype.toString = function () {\n  return this.range\n}\n\nRange.prototype.parseRange = function (range) {\n  var loose = this.options.loose\n  range = range.trim()\n  // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`\n  var hr = loose ? re[HYPHENRANGELOOSE] : re[HYPHENRANGE]\n  range = range.replace(hr, hyphenReplace)\n  debug('hyphen replace', range)\n  // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`\n  range = range.replace(re[COMPARATORTRIM], comparatorTrimReplace)\n  debug('comparator trim', range, re[COMPARATORTRIM])\n\n  // `~ 1.2.3` => `~1.2.3`\n  range = range.replace(re[TILDETRIM], tildeTrimReplace)\n\n  // `^ 1.2.3` => `^1.2.3`\n  range = range.replace(re[CARETTRIM], caretTrimReplace)\n\n  // normalize spaces\n  range = range.split(/\\s+/).join(' ')\n\n  // At this point, the range is completely trimmed and\n  // ready to be split into comparators.\n\n  var compRe = loose ? re[COMPARATORLOOSE] : re[COMPARATOR]\n  var set = range.split(' ').map(function (comp) {\n    return parseComparator(comp, this.options)\n  }, this).join(' ').split(/\\s+/)\n  if (this.options.loose) {\n    // in loose mode, throw out any that are not valid comparators\n    set = set.filter(function (comp) {\n      return !!comp.match(compRe)\n    })\n  }\n  set = set.map(function (comp) {\n    return new Comparator(comp, this.options)\n  }, this)\n\n  return set\n}\n\nRange.prototype.intersects = function (range, options) {\n  if (!(range instanceof Range)) {\n    throw new TypeError('a Range is required')\n  }\n\n  return this.set.some(function (thisComparators) {\n    return thisComparators.every(function (thisComparator) {\n      return range.set.some(function (rangeComparators) {\n        return rangeComparators.every(function (rangeComparator) {\n          return thisComparator.intersects(rangeComparator, options)\n        })\n      })\n    })\n  })\n}\n\n// Mostly just for testing and legacy API reasons\nexports.toComparators = toComparators\nfunction toComparators (range, options) {\n  return new Range(range, options).set.map(function (comp) {\n    return comp.map(function (c) {\n      return c.value\n    }).join(' ').trim().split(' ')\n  })\n}\n\n// comprised of xranges, tildes, stars, and gtlt's at this point.\n// already replaced the hyphen ranges\n// turn into a set of JUST comparators.\nfunction parseComparator (comp, options) {\n  debug('comp', comp, options)\n  comp = replaceCarets(comp, options)\n  debug('caret', comp)\n  comp = replaceTildes(comp, options)\n  debug('tildes', comp)\n  comp = replaceXRanges(comp, options)\n  debug('xrange', comp)\n  comp = replaceStars(comp, options)\n  debug('stars', comp)\n  return comp\n}\n\nfunction isX (id) {\n  return !id || id.toLowerCase() === 'x' || id === '*'\n}\n\n// ~, ~> --> * (any, kinda silly)\n// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0\n// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0\n// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0\n// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0\n// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0\nfunction replaceTildes (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceTilde(comp, options)\n  }).join(' ')\n}\n\nfunction replaceTilde (comp, options) {\n  var r = options.loose ? re[TILDELOOSE] : re[TILDE]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('tilde', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      // ~1.2 == >=1.2.0 <1.3.0\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    } else if (pr) {\n      debug('replaceTilde pr', pr)\n      ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    } else {\n      // ~1.2.3 == >=1.2.3 <1.3.0\n      ret = '>=' + M + '.' + m + '.' + p +\n            ' <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('tilde return', ret)\n    return ret\n  })\n}\n\n// ^ --> * (any, kinda silly)\n// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0\n// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0\n// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0\n// ^1.2.3 --> >=1.2.3 <2.0.0\n// ^1.2.0 --> >=1.2.0 <2.0.0\nfunction replaceCarets (comp, options) {\n  return comp.trim().split(/\\s+/).map(function (comp) {\n    return replaceCaret(comp, options)\n  }).join(' ')\n}\n\nfunction replaceCaret (comp, options) {\n  debug('caret', comp, options)\n  var r = options.loose ? re[CARETLOOSE] : re[CARET]\n  return comp.replace(r, function (_, M, m, p, pr) {\n    debug('caret', comp, _, M, m, p, pr)\n    var ret\n\n    if (isX(M)) {\n      ret = ''\n    } else if (isX(m)) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (isX(p)) {\n      if (M === '0') {\n        ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n      } else {\n        ret = '>=' + M + '.' + m + '.0 <' + (+M + 1) + '.0.0'\n      }\n    } else if (pr) {\n      debug('replaceCaret pr', pr)\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p + '-' + pr +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    } else {\n      debug('no pr')\n      if (M === '0') {\n        if (m === '0') {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + m + '.' + (+p + 1)\n        } else {\n          ret = '>=' + M + '.' + m + '.' + p +\n                ' <' + M + '.' + (+m + 1) + '.0'\n        }\n      } else {\n        ret = '>=' + M + '.' + m + '.' + p +\n              ' <' + (+M + 1) + '.0.0'\n      }\n    }\n\n    debug('caret return', ret)\n    return ret\n  })\n}\n\nfunction replaceXRanges (comp, options) {\n  debug('replaceXRanges', comp, options)\n  return comp.split(/\\s+/).map(function (comp) {\n    return replaceXRange(comp, options)\n  }).join(' ')\n}\n\nfunction replaceXRange (comp, options) {\n  comp = comp.trim()\n  var r = options.loose ? re[XRANGELOOSE] : re[XRANGE]\n  return comp.replace(r, function (ret, gtlt, M, m, p, pr) {\n    debug('xRange', comp, ret, gtlt, M, m, p, pr)\n    var xM = isX(M)\n    var xm = xM || isX(m)\n    var xp = xm || isX(p)\n    var anyX = xp\n\n    if (gtlt === '=' && anyX) {\n      gtlt = ''\n    }\n\n    if (xM) {\n      if (gtlt === '>' || gtlt === '<') {\n        // nothing is allowed\n        ret = '<0.0.0'\n      } else {\n        // nothing is forbidden\n        ret = '*'\n      }\n    } else if (gtlt && anyX) {\n      // we know patch is an x, because we have any x at all.\n      // replace X with 0\n      if (xm) {\n        m = 0\n      }\n      p = 0\n\n      if (gtlt === '>') {\n        // >1 => >=2.0.0\n        // >1.2 => >=1.3.0\n        // >1.2.3 => >= 1.2.4\n        gtlt = '>='\n        if (xm) {\n          M = +M + 1\n          m = 0\n          p = 0\n        } else {\n          m = +m + 1\n          p = 0\n        }\n      } else if (gtlt === '<=') {\n        // <=0.7.x is actually <0.8.0, since any 0.7.x should\n        // pass.  Similarly, <=7.x is actually <8.0.0, etc.\n        gtlt = '<'\n        if (xm) {\n          M = +M + 1\n        } else {\n          m = +m + 1\n        }\n      }\n\n      ret = gtlt + M + '.' + m + '.' + p\n    } else if (xm) {\n      ret = '>=' + M + '.0.0 <' + (+M + 1) + '.0.0'\n    } else if (xp) {\n      ret = '>=' + M + '.' + m + '.0 <' + M + '.' + (+m + 1) + '.0'\n    }\n\n    debug('xRange return', ret)\n\n    return ret\n  })\n}\n\n// Because * is AND-ed with everything else in the comparator,\n// and '' means \"any version\", just remove the *s entirely.\nfunction replaceStars (comp, options) {\n  debug('replaceStars', comp, options)\n  // Looseness is ignored here.  star is always as loose as it gets!\n  return comp.trim().replace(re[STAR], '')\n}\n\n// This function is passed to string.replace(re[HYPHENRANGE])\n// M, m, patch, prerelease, build\n// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5\n// 1.2.3 - 3.4 => >=1.2.0 <3.5.0 Any 3.4.x will do\n// 1.2 - 3.4 => >=1.2.0 <3.5.0\nfunction hyphenReplace ($0,\n  from, fM, fm, fp, fpr, fb,\n  to, tM, tm, tp, tpr, tb) {\n  if (isX(fM)) {\n    from = ''\n  } else if (isX(fm)) {\n    from = '>=' + fM + '.0.0'\n  } else if (isX(fp)) {\n    from = '>=' + fM + '.' + fm + '.0'\n  } else {\n    from = '>=' + from\n  }\n\n  if (isX(tM)) {\n    to = ''\n  } else if (isX(tm)) {\n    to = '<' + (+tM + 1) + '.0.0'\n  } else if (isX(tp)) {\n    to = '<' + tM + '.' + (+tm + 1) + '.0'\n  } else if (tpr) {\n    to = '<=' + tM + '.' + tm + '.' + tp + '-' + tpr\n  } else {\n    to = '<=' + to\n  }\n\n  return (from + ' ' + to).trim()\n}\n\n// if ANY of the sets match ALL of its comparators, then pass\nRange.prototype.test = function (version) {\n  if (!version) {\n    return false\n  }\n\n  if (typeof version === 'string') {\n    version = new SemVer(version, this.options)\n  }\n\n  for (var i = 0; i < this.set.length; i++) {\n    if (testSet(this.set[i], version, this.options)) {\n      return true\n    }\n  }\n  return false\n}\n\nfunction testSet (set, version, options) {\n  for (var i = 0; i < set.length; i++) {\n    if (!set[i].test(version)) {\n      return false\n    }\n  }\n\n  if (version.prerelease.length && !options.includePrerelease) {\n    // Find the set of versions that are allowed to have prereleases\n    // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0\n    // That should allow `1.2.3-pr.2` to pass.\n    // However, `1.2.4-alpha.notready` should NOT be allowed,\n    // even though it's within the range set by the comparators.\n    for (i = 0; i < set.length; i++) {\n      debug(set[i].semver)\n      if (set[i].semver === ANY) {\n        continue\n      }\n\n      if (set[i].semver.prerelease.length > 0) {\n        var allowed = set[i].semver\n        if (allowed.major === version.major &&\n            allowed.minor === version.minor &&\n            allowed.patch === version.patch) {\n          return true\n        }\n      }\n    }\n\n    // Version has a -pre, but it's not one of the ones we like.\n    return false\n  }\n\n  return true\n}\n\nexports.satisfies = satisfies\nfunction satisfies (version, range, options) {\n  try {\n    range = new Range(range, options)\n  } catch (er) {\n    return false\n  }\n  return range.test(version)\n}\n\nexports.maxSatisfying = maxSatisfying\nfunction maxSatisfying (versions, range, options) {\n  var max = null\n  var maxSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!max || maxSV.compare(v) === -1) {\n        // compare(max, v, true)\n        max = v\n        maxSV = new SemVer(max, options)\n      }\n    }\n  })\n  return max\n}\n\nexports.minSatisfying = minSatisfying\nfunction minSatisfying (versions, range, options) {\n  var min = null\n  var minSV = null\n  try {\n    var rangeObj = new Range(range, options)\n  } catch (er) {\n    return null\n  }\n  versions.forEach(function (v) {\n    if (rangeObj.test(v)) {\n      // satisfies(v, range, options)\n      if (!min || minSV.compare(v) === 1) {\n        // compare(min, v, true)\n        min = v\n        minSV = new SemVer(min, options)\n      }\n    }\n  })\n  return min\n}\n\nexports.minVersion = minVersion\nfunction minVersion (range, loose) {\n  range = new Range(range, loose)\n\n  var minver = new SemVer('0.0.0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = new SemVer('0.0.0-0')\n  if (range.test(minver)) {\n    return minver\n  }\n\n  minver = null\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    comparators.forEach(function (comparator) {\n      // Clone to avoid manipulating the comparator's semver object.\n      var compver = new SemVer(comparator.semver.version)\n      switch (comparator.operator) {\n        case '>':\n          if (compver.prerelease.length === 0) {\n            compver.patch++\n          } else {\n            compver.prerelease.push(0)\n          }\n          compver.raw = compver.format()\n          /* fallthrough */\n        case '':\n        case '>=':\n          if (!minver || gt(minver, compver)) {\n            minver = compver\n          }\n          break\n        case '<':\n        case '<=':\n          /* Ignore maximum versions */\n          break\n        /* istanbul ignore next */\n        default:\n          throw new Error('Unexpected operation: ' + comparator.operator)\n      }\n    })\n  }\n\n  if (minver && range.test(minver)) {\n    return minver\n  }\n\n  return null\n}\n\nexports.validRange = validRange\nfunction validRange (range, options) {\n  try {\n    // Return '*' instead of '' so that truthiness works.\n    // This will throw if it's invalid anyway\n    return new Range(range, options).range || '*'\n  } catch (er) {\n    return null\n  }\n}\n\n// Determine if version is less than all the versions possible in the range\nexports.ltr = ltr\nfunction ltr (version, range, options) {\n  return outside(version, range, '<', options)\n}\n\n// Determine if version is greater than all the versions possible in the range.\nexports.gtr = gtr\nfunction gtr (version, range, options) {\n  return outside(version, range, '>', options)\n}\n\nexports.outside = outside\nfunction outside (version, range, hilo, options) {\n  version = new SemVer(version, options)\n  range = new Range(range, options)\n\n  var gtfn, ltefn, ltfn, comp, ecomp\n  switch (hilo) {\n    case '>':\n      gtfn = gt\n      ltefn = lte\n      ltfn = lt\n      comp = '>'\n      ecomp = '>='\n      break\n    case '<':\n      gtfn = lt\n      ltefn = gte\n      ltfn = gt\n      comp = '<'\n      ecomp = '<='\n      break\n    default:\n      throw new TypeError('Must provide a hilo val of \"<\" or \">\"')\n  }\n\n  // If it satisifes the range it is not outside\n  if (satisfies(version, range, options)) {\n    return false\n  }\n\n  // From now on, variable terms are as if we're in \"gtr\" mode.\n  // but note that everything is flipped for the \"ltr\" function.\n\n  for (var i = 0; i < range.set.length; ++i) {\n    var comparators = range.set[i]\n\n    var high = null\n    var low = null\n\n    comparators.forEach(function (comparator) {\n      if (comparator.semver === ANY) {\n        comparator = new Comparator('>=0.0.0')\n      }\n      high = high || comparator\n      low = low || comparator\n      if (gtfn(comparator.semver, high.semver, options)) {\n        high = comparator\n      } else if (ltfn(comparator.semver, low.semver, options)) {\n        low = comparator\n      }\n    })\n\n    // If the edge version comparator has a operator then our version\n    // isn't outside it\n    if (high.operator === comp || high.operator === ecomp) {\n      return false\n    }\n\n    // If the lowest version comparator has an operator and our version\n    // is less than it then it isn't higher than the range\n    if ((!low.operator || low.operator === comp) &&\n        ltefn(version, low.semver)) {\n      return false\n    } else if (low.operator === ecomp && ltfn(version, low.semver)) {\n      return false\n    }\n  }\n  return true\n}\n\nexports.prerelease = prerelease\nfunction prerelease (version, options) {\n  var parsed = parse(version, options)\n  return (parsed && parsed.prerelease.length) ? parsed.prerelease : null\n}\n\nexports.intersects = intersects\nfunction intersects (r1, r2, options) {\n  r1 = new Range(r1, options)\n  r2 = new Range(r2, options)\n  return r1.intersects(r2)\n}\n\nexports.coerce = coerce\nfunction coerce (version) {\n  if (version instanceof SemVer) {\n    return version\n  }\n\n  if (typeof version !== 'string') {\n    return null\n  }\n\n  var match = version.match(re[COERCE])\n\n  if (match == null) {\n    return null\n  }\n\n  return parse(match[1] +\n    '.' + (match[2] || '0') +\n    '.' + (match[3] || '0'))\n}\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module AccuDraw */\r\nimport { IModelApp } from \"./IModelApp\";\r\nimport {\r\n  Point3d, Vector3d, Point2d, Matrix3d, Transform, Geometry, Arc3d, LineSegment3d, CurvePrimitive,\r\n  LineString3d, AxisOrder, CurveCurve, PointString3d, IModelJson as GeomJson,\r\n} from \"@bentley/geometry-core\";\r\nimport { Viewport, ScreenViewport, linePlaneIntersect } from \"./Viewport\";\r\nimport { BentleyStatus } from \"@bentley/bentleyjs-core\";\r\nimport { StandardViewId } from \"./StandardView\";\r\nimport { ViewState } from \"./ViewState\";\r\nimport { ColorDef, ColorByName, LinePixels, GeometryStreamProps } from \"@bentley/imodeljs-common\";\r\nimport { BeButtonEvent, CoordSource, BeButton, InputCollector, CoordinateLockOverrides } from \"./tools/Tool\";\r\nimport { SnapMode, SnapDetail, SnapHeat, HitDetail } from \"./HitDetail\";\r\nimport { TentativeOrAccuSnap } from \"./AccuSnap\";\r\nimport { AuxCoordSystemState, ACSDisplayOptions } from \"./AuxCoordSys\";\r\nimport { GraphicBuilder, GraphicType } from \"./render/GraphicBuilder\";\r\nimport { DecorateContext } from \"./ViewContext\";\r\nimport { ViewTool } from \"./tools/ViewTool\";\r\n\r\n/** @internal */\r\nexport enum AccuDrawFlags {\r\n  SetModePolar = 1,\r\n  SetModeRect = 1 << 1,\r\n  SetOrigin = (1 << 2),\r\n  FixedOrigin = (1 << 3),\r\n  SetRMatrix = (1 << 4),\r\n  SetXAxis = (1 << 5),\r\n  SetNormal = (1 << 6),\r\n  SetDistance = (1 << 7),\r\n  LockDistance = (1 << 8),\r\n  Lock_X = (1 << 9),\r\n  Lock_Y = (1 << 10),\r\n  Lock_Z = (1 << 11),\r\n  Disable = (1 << 12),\r\n  OrientDefault = (1 << 14),\r\n  SetFocus = (1 << 15),\r\n  OrientACS = (1 << 17),\r\n  SetXAxis2 = (1 << 18),\r\n  LockAngle = (1 << 19),\r\n  AlwaysSetOrigin = SetOrigin | (1 << 21),\r\n  RedrawCompass = (1 << 22),\r\n  UpdateRotation = (1 << 23),\r\n  SmartRotation = (1 << 24),\r\n}\r\n\r\n/** @internal */\r\nexport enum CompassMode {\r\n  Polar = 0,\r\n  Rectangular = 1,\r\n}\r\n\r\n/** @alpha */\r\nexport enum RotationMode {\r\n  Top = 1,\r\n  Front = 2,\r\n  Side = 3,\r\n  View = 4,\r\n  ACS = 5,\r\n  Context = 6,\r\n}\r\n\r\n/** @internal */\r\nexport enum LockedStates {\r\n  NONE_LOCKED = 0,\r\n  X_BM = (1),\r\n  Y_BM = (1 << 1),\r\n  VEC_BM = (1 << 2),\r\n  DIST_BM = (1 << 3),\r\n  XY_BM = (X_BM | Y_BM),\r\n  ANGLE_BM = (XY_BM | VEC_BM),\r\n}\r\n\r\n/** @internal */\r\nexport enum CurrentState {\r\n  NotEnabled = 0, // Compass disabled/unwanted for this session.\r\n  Deactivated = 1, // Compass deactivated but CAN be activated by user.\r\n  Inactive = 2, // Compass not displayed awaiting automatic activation (default tool state).\r\n  Active = 3, // Compass displayed and adjusting points.\r\n}\r\n\r\n/** @internal */\r\nexport enum ContextMode {\r\n  Locked = 0,\r\n  XAxis = 1,\r\n  YAxis = 2,\r\n  ZAxis = 3,\r\n  XAxis2 = 4,\r\n  None = 15,\r\n}\r\n\r\n/** @internal */\r\nexport enum ItemField {\r\n  DIST_Item = 0,\r\n  ANGLE_Item = 1,\r\n  X_Item = 2,\r\n  Y_Item = 3,\r\n  Z_Item = 4,\r\n}\r\n\r\n/** @internal */\r\nexport enum KeyinStatus {\r\n  Dynamic = 0,\r\n  Partial = 1,\r\n  DontUpdate = 2,\r\n}\r\n\r\nconst enum Constants {\r\n  MAX_SAVED_VALUES = 20,\r\n  SMALL_ANGLE = 1.0e-12,\r\n  SMALL_DELTA = 0.00001,\r\n}\r\n\r\n/** @internal */\r\nexport class AccudrawData {\r\n  public flags = 0; // AccuDrawFlags\r\n  public readonly origin = new Point3d(); // used if ACCUDRAW_SetOrigin\r\n  public readonly delta = new Point3d(); // if ACCUDRAW_Lock_X, etc.\r\n  public readonly rMatrix = new Matrix3d(); // if ACCUDRAW_SetRMatrix/ACCUDRAW_Set3dMatrix\r\n  public readonly vector = new Vector3d(); // if ACCUDRAW_SetXAxis, etc.\r\n  public distance = 0; // if ACCUDRAW_SetDistance\r\n  public angle = 0; // if ACCUDRAW_SetAngle\r\n  public zero() { this.flags = this.distance = this.angle = 0; this.origin.setZero(); this.delta.setZero(); this.vector.setZero(); this.rMatrix.setIdentity(); }\r\n}\r\n\r\n/** @internal */\r\nexport class Flags {\r\n  public redrawCompass = false;\r\n  public dialogNeedsUpdate = false;\r\n  public rotationNeedsUpdate = true;\r\n  public lockedRotation = false;\r\n  public indexLocked = false;\r\n  public haveValidOrigin = false;\r\n  public fixedOrg = false;\r\n  public auxRotationPlane = RotationMode.Top;\r\n  public contextRotMode = 0;\r\n  public baseRotation = RotationMode.View;\r\n  public baseMode = 0;\r\n  public pointIsOnPlane = false; // whether rawPointOnPlane is on compass plane\r\n  public softAngleLock = false;\r\n  public bearingFixToPlane2D = false;\r\n  public inDataPoint = false;\r\n  public ignoreDataButton = false;\r\n  public animateRotation = false;\r\n}\r\n\r\n/** @internal */\r\nexport class RoundOff {\r\n  public active = false;\r\n  public units = new Set<number>();\r\n}\r\n\r\n/** @internal */\r\nexport class SavedState {\r\n  public state = CurrentState.NotEnabled;\r\n  public mode = CompassMode.Polar;\r\n  public rotationMode = RotationMode.View;\r\n  public readonly axes = new ThreeAxes();\r\n  public readonly origin = new Point3d();\r\n  public auxRotationPlane = 0;\r\n  public contextRotMode = 0;\r\n  public fixedOrg = false;\r\n  public ignoreDataButton = true; // By default the data point that terminates a view tool or input collector should be ignored...\r\n  public ignoreFlags: AccuDrawFlags = 0;\r\n}\r\n\r\n/** @internal */\r\nclass SavedCoords {\r\n  public nSaveValues = 0;\r\n  public readonly savedValues: number[] = [];\r\n  public readonly savedValIsAngle: boolean[] = [];\r\n}\r\n\r\n/** @internal */\r\nexport class ThreeAxes {\r\n  public readonly x = Vector3d.unitX();\r\n  public readonly y = Vector3d.unitY();\r\n  public readonly z = Vector3d.unitZ();\r\n  public setFrom(other: ThreeAxes) {\r\n    this.x.setFrom(other.x);\r\n    this.y.setFrom(other.y);\r\n    this.z.setFrom(other.z);\r\n  }\r\n  public fromMatrix3d(rMatrix: Matrix3d): void {\r\n    rMatrix.getRow(0, this.x);\r\n    rMatrix.getRow(1, this.y);\r\n    rMatrix.getRow(2, this.z);\r\n  }\r\n  public static createFromMatrix3d(rMatrix: Matrix3d, result?: ThreeAxes): ThreeAxes {\r\n    result = result ? result : new ThreeAxes();\r\n    result.fromMatrix3d(rMatrix);\r\n    return result;\r\n  }\r\n  public toMatrix3d(out?: Matrix3d) { return Matrix3d.createRows(this.x, this.y, this.z, out); }\r\n  public clone(): ThreeAxes { const out = new ThreeAxes(); out.setFrom(this); return out; }\r\n  public equals(other: ThreeAxes): boolean { return this.x.isExactEqual(other.x) && this.y.isExactEqual(other.y) && this.z.isExactEqual(other.z); }\r\n}\r\n\r\n/** Accudraw is an aide for entering coordinate data.\r\n * @internal\r\n */\r\nexport class AccuDraw {\r\n  /** @internal */\r\n  public currentState = CurrentState.NotEnabled; // Compass state\r\n  /** @internal */\r\n  public compassMode = CompassMode.Rectangular; // Compass mode\r\n  /** @internal */\r\n  public rotationMode = RotationMode.View; // Compass rotation\r\n  /** @internal */\r\n  public currentView?: ScreenViewport; // will be nullptr if view not yet defined\r\n  /** @internal */\r\n  public readonly published = new AccudrawData(); // Staging area for hints\r\n  /** @internal */\r\n  public readonly origin = new Point3d(); // origin point...not on compass plane when z != 0.0\r\n  /** @internal */\r\n  public readonly axes = new ThreeAxes(); // X, Y and Z vectors (3d rotation matrix)\r\n  /** @internal */\r\n  public readonly delta = Vector3d.unitZ(); // dialog items (x, y & z)\r\n  private _distance = 0; // current distance\r\n  private _angle = 0; // current angle\r\n  /** @internal */\r\n  public locked = LockedStates.NONE_LOCKED; // axis/distance locked bit mask\r\n  /** @internal */\r\n  public indexed = LockedStates.NONE_LOCKED; // axis/distance indexed bit mask\r\n  private readonly _distanceRoundOff = new RoundOff(); // distance round off enabled and unit\r\n  private readonly _angleRoundOff = new RoundOff(); // angle round off enabled and unit\r\n  /** @internal */\r\n  public readonly flags = new Flags(); // current state flags\r\n  private readonly _fieldLocked: boolean[] = []; // locked state of fields\r\n  private readonly _keyinStatus: KeyinStatus[] = []; // state of input field\r\n  /** @internal */\r\n  public readonly savedStateViewTool = new SavedState(); // Restore point for shortcuts/tools...\r\n  /** @internal */\r\n  public readonly savedStateInputCollector = new SavedState(); // Restore point for shortcuts/tools...\r\n  private readonly _savedCoords = new SavedCoords(); // History of previous angles/distances...\r\n  /** @internal */\r\n  public readonly baseAxes = new ThreeAxes(); // Used for \"context\" base rotation to hold arbitrary rotation w/o needing to change ACS...\r\n  /** @internal */\r\n  public readonly lastAxes = new ThreeAxes(); // Last result from UpdateRotation, replaces cM.rMatrix...\r\n  private _lastDistance = 0; // previous saved distance or distance indexing tick\r\n  private _tolerance = 0; // computed view based indexing tolerance\r\n  private _percentChanged = 0; // Compass animation state\r\n  private _threshold = 0; // Threshold for automatic x/y field focus change.\r\n  /** @internal */\r\n  public readonly planePt = new Point3d(); // same as origin unless non-zero locked z value\r\n  private readonly _rawDelta = new Point2d(); // used by rect fix point\r\n  private readonly _rawPoint = new Point3d(); // raw uor point passed to fix point\r\n  private readonly _rawPointOnPlane = new Point3d(); // adjusted rawPoint by applying hard/soft construction plane\r\n  /** @internal */\r\n  public readonly point = new Point3d(); // current cursor point\r\n  /** @internal */\r\n  public readonly vector = Vector3d.unitZ(); // current/last good locked direction\r\n  private _xIsNegative = false; // Last delta.x was negative\r\n  private _yIsNegative = false; // Last delta.y was negative\r\n  private _xIsExplicit = false; // Sign of delta.x established from user input input, don't allow +/- side flip.\r\n  private _yIsExplicit = false; // Sign of delta.y established from user input input, don't allow +/- side flip.\r\n  public dontMoveFocus = false; // Disable automatic focus change when user is entering input.\r\n  /** @internal */\r\n  public newFocus = ItemField.X_Item; // Item to move focus to (X_Item or Y_Item) for automatic focus change.\r\n  private readonly _rMatrix = new Matrix3d();\r\n  /** @internal */\r\n  protected _acsPickId?: string;\r\n\r\n  // Compass Display Preferences...\r\n  /** @internal */\r\n  protected _compassSizeInches = 0.44;\r\n  /** @internal */\r\n  protected _animationFrames = 12;\r\n  /** @internal */\r\n  protected _indexToleranceInches = 0.11;\r\n  /** @internal */\r\n  protected readonly _frameColor = new ColorDef(ColorByName.lightGrey);\r\n  /** @internal */\r\n  protected readonly _fillColor = new ColorDef(ColorByName.blue);\r\n  /** @internal */\r\n  protected readonly _xColor = new ColorDef(ColorByName.red);\r\n  /** @internal */\r\n  protected readonly _yColor = new ColorDef(ColorByName.green);\r\n  /** @internal */\r\n  protected readonly _indexColor = new ColorDef(ColorByName.white);\r\n  /** @internal */\r\n  protected readonly _frameColorNoFocus = new ColorDef(ColorByName.darkGrey);\r\n  /** @internal */\r\n  protected readonly _fillColorNoFocus = new ColorDef(ColorByName.lightGrey);\r\n\r\n  // User Preference Settings...\r\n  public smartKeyin = true;\r\n  public floatingOrigin = true;\r\n  public stickyZLock = false;\r\n  public alwaysShowCompass = false;\r\n  public contextSensitive = true;\r\n  public axisIndexing = true;\r\n  public distanceIndexing = true;\r\n  public autoFocusFields = true;\r\n  public autoPointPlacement = false;\r\n  private static _tempRot = new Matrix3d();\r\n\r\n  /** @internal */\r\n  public onInitialized() { this.enableForSession(); }\r\n  /** @internal */\r\n  public getRotation(rMatrix?: Matrix3d): Matrix3d { if (!rMatrix) rMatrix = this._rMatrix; Matrix3d.createRows(this.axes.x, this.axes.y, this.axes.z, rMatrix); return rMatrix; }\r\n\r\n  public get isActive(): boolean { return CurrentState.Active === this.currentState; }\r\n  public get isEnabled(): boolean { return (this.currentState > CurrentState.NotEnabled); }\r\n  public get isInactive(): boolean { return (CurrentState.Inactive === this.currentState); }\r\n  public get isDeactivated(): boolean { return (CurrentState.Deactivated === this.currentState); }\r\n  /** @internal */\r\n  protected setNewFocus(index: ItemField) { this.newFocus = index; }\r\n  /** @internal */\r\n  public getFieldLock(index: ItemField): boolean { return this._fieldLocked[index]; }\r\n  /** @internal */\r\n  public getKeyinStatus(index: ItemField): KeyinStatus { return this._keyinStatus[index]; }\r\n\r\n  /** Implement this method to set focus to the AccuDraw UI.\r\n   * @internal\r\n   */\r\n  public grabInputFocus() { }\r\n\r\n  /** @internal */\r\n  public activate(): void {\r\n    // Upgrade state to inactive so upgradeToActiveState knows it is ok to move to active...\r\n    if (CurrentState.Deactivated === this.currentState)\r\n      this.currentState = CurrentState.Inactive;\r\n    this.upgradeToActiveState();\r\n  }\r\n\r\n  /** @internal */\r\n  public deactivate() {\r\n    this.downgradeInactiveState();\r\n    // Don't allow compass to come back until user re-enables it...\r\n    if (CurrentState.Inactive === this.currentState)\r\n      this.currentState = CurrentState.Deactivated;\r\n  }\r\n\r\n  /** @internal */\r\n  public setCompassMode(mode: CompassMode): void {\r\n    if (mode === this.compassMode) return;\r\n    this.compassMode = mode;\r\n    this.onCompassModeChange();\r\n  }\r\n\r\n  /** @internal */\r\n  public setRotationMode(mode: RotationMode): void {\r\n    if (mode === this.rotationMode) return;\r\n    this.rotationMode = mode;\r\n    this.onRotationModeChange();\r\n  }\r\n\r\n  /** @internal */\r\n  public setFieldLock(index: ItemField, locked: boolean): void {\r\n    if (locked === this._fieldLocked[index]) return;\r\n    this._fieldLocked[index] = locked;\r\n    this.onFieldLockChange(index);\r\n  }\r\n\r\n  /** @internal */\r\n  public setKeyinStatus(index: ItemField, status: KeyinStatus): void {\r\n    this._keyinStatus[index] = status;\r\n    if (KeyinStatus.Dynamic !== status)\r\n      this.dontMoveFocus = true;\r\n    if (KeyinStatus.Partial === status)\r\n      this._threshold = Math.abs(ItemField.X_Item === index ? this._rawDelta.y : this._rawDelta.x) + this._tolerance;\r\n  }\r\n\r\n  private needsRefresh(vp: Viewport): boolean {\r\n    if (!this.isEnabled || this.isDeactivated)\r\n      return false;\r\n\r\n    // Get snap point from AccuSnap/Tentative or use raw point...\r\n    let distance = 0.0;\r\n    let snapPt = this._rawPoint;\r\n    const ptP = this.point;\r\n    const snap = TentativeOrAccuSnap.getCurrentSnap();\r\n\r\n    if (snap) {\r\n      snapPt = snap.snapPoint;\r\n      distance = ptP.distance(snapPt);\r\n    }\r\n\r\n    const isRectMode = (CompassMode.Rectangular === this.compassMode);\r\n    const offsetSnap = ((TentativeOrAccuSnap.isHot || IModelApp.tentativePoint.isActive) && ((this.locked) || (distance > 0.0)));\r\n\r\n    // XY Offset:\r\n    if (offsetSnap) {\r\n      if (isRectMode) {\r\n        let xIsOffset = false, yIsOffset = false;\r\n\r\n        const vec = ptP.vectorTo(this._rawPointOnPlane);\r\n        const xOffset = vec.dotProduct(this.axes.x);\r\n        const yOffset = vec.dotProduct(this.axes.y);\r\n\r\n        xIsOffset = (Math.abs(xOffset) > 1.0);\r\n        yIsOffset = (Math.abs(yOffset) > 1.0);\r\n\r\n        if (xIsOffset || yIsOffset)\r\n          return true;\r\n      }\r\n    }\r\n\r\n    const isOnCompassPlane = (!vp.view.is3d() || this.flags.pointIsOnPlane || this.isZLocked(vp));\r\n\r\n    // Z Offset:\r\n    if (offsetSnap) {\r\n      if (isOnCompassPlane) {\r\n        const zOffset = snapPt.distance(this._rawPointOnPlane);\r\n        if (zOffset > Constants.SMALL_ANGLE || zOffset < -Constants.SMALL_ANGLE)\r\n          return true;\r\n      }\r\n    }\r\n\r\n    // Fat Point:\r\n    if (offsetSnap)\r\n      return true;\r\n\r\n    let axisIsIndexed = false;\r\n\r\n    // Axis Indexing:\r\n    if (isRectMode) {\r\n      if ((this.indexed & LockedStates.XY_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))\r\n        axisIsIndexed = true;\r\n    } else {\r\n      if ((this.indexed & LockedStates.ANGLE_BM || this.locked & LockedStates.ANGLE_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))\r\n        axisIsIndexed = true;\r\n    }\r\n\r\n    if (axisIsIndexed)\r\n      return true;\r\n\r\n    // Distance Indexing:\r\n    if (this.indexed & LockedStates.DIST_BM)\r\n      return true;\r\n\r\n    // XY Lock:\r\n    if (isRectMode && !axisIsIndexed) {\r\n      const locked = this.locked & LockedStates.XY_BM;\r\n\r\n      if ((0 !== locked) && isOnCompassPlane) {\r\n        switch (locked) {\r\n          case LockedStates.X_BM:\r\n          case LockedStates.Y_BM:\r\n          case LockedStates.XY_BM:\r\n            return true;\r\n        }\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public adjustPoint(pointActive: Point3d, vp: ScreenViewport, fromSnap: boolean): boolean {\r\n    if (!this.isEnabled)\r\n      return false;\r\n\r\n    const lastWasIndexed = (0 !== this.indexed);\r\n    let pointChanged = false, handled = false;\r\n\r\n    if (0.0 !== pointActive.z && !vp.isPointAdjustmentRequired)\r\n      pointActive.z = 0.0;\r\n\r\n    if (this.isInactive) {\r\n      this.point.setFrom(pointActive);\r\n      this.currentView = vp;\r\n\r\n      this.fixPoint(pointActive, vp);\r\n\r\n      if (!fromSnap && IModelApp.accuSnap.currHit)\r\n        this.flags.redrawCompass = true;\r\n    } else if (this.isActive) {\r\n      const lastPt = this.point.clone();\r\n      this.fixPoint(pointActive, vp);\r\n      pointChanged = !lastPt.isExactEqual(this.point);\r\n      this.processHints();\r\n      handled = true;\r\n    } else {\r\n      this.currentView = vp; // Keep view up to date...\r\n    }\r\n\r\n    // If redraw of compass isn't required (yet!) check if needed...\r\n    if (!this.flags.redrawCompass && this.isActive) {\r\n      // Redraw required to erase/draw old/new indexing geometry...\r\n      if (pointChanged && (lastWasIndexed || this.needsRefresh(vp)))\r\n        this.flags.redrawCompass = true;\r\n    }\r\n    // Redraw is necessary, force decorators to be called...\r\n    if (this.flags.redrawCompass)\r\n      vp.invalidateDecorations();\r\n\r\n    return handled;\r\n  }\r\n\r\n  private setDefaultOrigin(vp?: Viewport): void {\r\n    if (!vp || this.locked || this._fieldLocked[ItemField.Z_Item])\r\n      return;\r\n\r\n    const view = vp.view;\r\n    const rMatrix = view.getRotation();\r\n    const acsOrigin = vp.getAuxCoordOrigin();\r\n    rMatrix.multiplyVectorInPlace(acsOrigin);\r\n\r\n    const origin = view.getCenter();\r\n    view.getRotation().multiplyVectorInPlace(origin);\r\n    origin.z = acsOrigin.z;\r\n    view.getRotation().multiplyTransposeVectorInPlace(origin);\r\n\r\n    this.origin.setFrom(origin); // View center at acs z...\r\n    this.planePt.setFrom(origin);\r\n  }\r\n\r\n  /** @internal */\r\n  public isZLocked(vp: Viewport): boolean {\r\n    if (this._fieldLocked[ItemField.Z_Item])\r\n      return true;\r\n    if (vp.isSnapAdjustmentRequired) //  && TentativeOrAccuSnap.isHot())\r\n      return true;\r\n\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public accountForAuxRotationPlane(rot: ThreeAxes, plane: RotationMode): void {\r\n    // ACS mode now can have \"front\" and \"side\" variations...\r\n    switch (plane) {\r\n      case RotationMode.Top:\r\n        return;\r\n\r\n      case RotationMode.Front:\r\n        const temp = rot.y.clone();\r\n        rot.y.setFrom(rot.z);\r\n        temp.scale(-1.0, rot.z);\r\n        return;\r\n\r\n      case RotationMode.Side:\r\n        const temp0 = rot.x.clone();\r\n        rot.x.setFrom(rot.y);\r\n        rot.y.setFrom(rot.z);\r\n        rot.z.setFrom(temp0);\r\n    }\r\n  }\r\n\r\n  private accountForACSContextLock(vec: Vector3d): void {\r\n    // Base rotation is relative to ACS when ACS context lock is enabled...\r\n    if (!this.currentView || !this.currentView.isContextRotationRequired)\r\n      return;\r\n\r\n    const rMatrix = AccuDraw.getStandardRotation(StandardViewId.Top, this.currentView, true);\r\n    rMatrix!.multiplyTransposeVectorInPlace(vec);\r\n  }\r\n\r\n  private static useACSContextRotation(vp: Viewport, isSnap: boolean): boolean {\r\n    if (isSnap) {\r\n      if (!vp.isSnapAdjustmentRequired)\r\n        return false;\r\n    } else {\r\n      if (!vp.isContextRotationRequired)\r\n        return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** Gets X, Y or Z vector from top, front, (right) side, ACS, or View. */\r\n  private getStandardVector(whichVec: number): Vector3d {\r\n    const vp = this.currentView;\r\n    let rMatrix: Matrix3d;\r\n    let myAxes: ThreeAxes;\r\n    const vecP = Vector3d.createZero();\r\n    switch (this.flags.baseRotation) {\r\n      case RotationMode.Top:\r\n        switch (whichVec) {\r\n          case 0: vecP.x = 1.0; break;\r\n          case 1: vecP.y = 1.0; break;\r\n          case 2: vecP.z = 1.0; break;\r\n        }\r\n        this.accountForACSContextLock(vecP);\r\n        break;\r\n\r\n      case RotationMode.Front:\r\n        switch (whichVec) {\r\n          case 0: vecP.x = 1.0; break;\r\n          case 1: vecP.z = 1.0; break;\r\n          case 2: vecP.y = -1.0; break;\r\n        }\r\n        this.accountForACSContextLock(vecP);\r\n        break;\r\n\r\n      case RotationMode.Side:\r\n        switch (whichVec) {\r\n          case 0: vecP.y = 1.0; break;\r\n          case 1: vecP.z = 1.0; break;\r\n          case 2: vecP.x = 1.0; break;\r\n        }\r\n        this.accountForACSContextLock(vecP);\r\n        break;\r\n\r\n      case RotationMode.ACS:\r\n        rMatrix = vp ? vp.getAuxCoordRotation() : Matrix3d.createIdentity();\r\n        myAxes = ThreeAxes.createFromMatrix3d(rMatrix);\r\n        this.accountForAuxRotationPlane(myAxes, this.flags.auxRotationPlane);\r\n        switch (whichVec) {\r\n          case 0: vecP.setFrom(myAxes.x); break;\r\n          case 1: vecP.setFrom(myAxes.y); break;\r\n          case 2: vecP.setFrom(myAxes.z); break;\r\n        }\r\n        break;\r\n\r\n      case RotationMode.View:\r\n        rMatrix = vp ? vp.rotation : Matrix3d.createIdentity();\r\n        rMatrix.getRow(whichVec, vecP);\r\n        break;\r\n\r\n      case RotationMode.Context:\r\n        myAxes = this.baseAxes.clone();\r\n        this.accountForAuxRotationPlane(myAxes, this.flags.auxRotationPlane);\r\n        switch (whichVec) {\r\n          case 0: vecP.setFrom(myAxes.x); break;\r\n          case 1: vecP.setFrom(myAxes.y); break;\r\n          case 2: vecP.setFrom(myAxes.z); break;\r\n        }\r\n        break;\r\n    }\r\n    return vecP;\r\n  }\r\n\r\n  private getBestViewedRotationFromXVector(rotation: ThreeAxes, vp: Viewport): void {\r\n    const viewZ = vp.rotation.getRow(2);\r\n    const vec1 = this.getStandardVector(2);\r\n    const vec2 = this.getStandardVector(1);\r\n    const vec3 = this.getStandardVector(0);\r\n    const rot1 = vec1.crossProduct(rotation.x);\r\n    const rot2 = vec2.crossProduct(rotation.x);\r\n    const rot3 = vec3.crossProduct(rotation.x);\r\n    const useRot1 = (rot1.normalizeWithLength(rot1).mag > 0.00001);\r\n    const useRot2 = (rot2.normalizeWithLength(rot2).mag > 0.00001);\r\n    const useRot3 = (rot3.normalizeWithLength(rot3).mag > 0.00001);\r\n    const dot1 = (useRot1 ? Math.abs(rotation.x.crossProduct(rot1).dotProduct(viewZ)) : -1.0);\r\n    const dot2 = (useRot2 ? Math.abs(rotation.x.crossProduct(rot2).dotProduct(viewZ)) : -1.0);\r\n    const dot3 = (useRot3 ? Math.abs(rotation.x.crossProduct(rot3).dotProduct(viewZ)) : -1.0);\r\n    const max = Math.max(dot1, dot2, dot3);\r\n\r\n    if (Geometry.isDistanceWithinTol(dot1 - dot2, 0.1) && (max !== dot3))\r\n      rotation.y.setFrom(rot1);\r\n    else if (max === dot1)\r\n      rotation.y.setFrom(rot1);\r\n    else if (max === dot2)\r\n      rotation.y.setFrom(rot2);\r\n    else\r\n      rotation.y.setFrom(rot3);\r\n\r\n    rotation.z.setFrom(rotation.x.crossProduct(rotation.y));\r\n  }\r\n\r\n  private getRotationFromVector(rotation: ThreeAxes, whichVec: number): void {\r\n    let vec: Vector3d;\r\n    switch (whichVec) {\r\n      case 0:\r\n        vec = this.getStandardVector(2);\r\n        vec.crossProduct(rotation.x, rotation.y);\r\n\r\n        if (rotation.y.normalizeWithLength(rotation.y).mag < .00001) {\r\n          vec = this.getStandardVector(1);\r\n          vec.crossProduct(rotation.x, rotation.y);\r\n          rotation.y.normalizeInPlace();\r\n        }\r\n\r\n        rotation.x.crossProduct(rotation.y, rotation.z);\r\n        break;\r\n\r\n      case 1:\r\n        vec = this.getStandardVector(2);\r\n        vec.crossProduct(rotation.y, rotation.x);\r\n\r\n        if (rotation.x.normalizeWithLength(rotation.x).mag < .00001) {\r\n          vec = this.getStandardVector(0);\r\n          vec.crossProduct(rotation.y, rotation.x);\r\n          rotation.x.normalizeInPlace();\r\n        }\r\n\r\n        rotation.x.crossProduct(rotation.y, rotation.z);\r\n        break;\r\n\r\n      case 2:\r\n        vec = this.getStandardVector(0);\r\n        rotation.z.crossProduct(vec, rotation.y);\r\n\r\n        if (rotation.y.normalizeWithLength(rotation.y).mag < .00001) {\r\n          vec = this.getStandardVector(1);\r\n          vec.crossProduct(rotation.z, rotation.x);\r\n          rotation.x.normalizeInPlace();\r\n          rotation.z.crossProduct(rotation.x, rotation.y);\r\n        } else {\r\n          rotation.y.crossProduct(rotation.z, rotation.x);\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public updateRotation(animate: boolean = false, newRotationIn?: Matrix3d): void {\r\n    let clearLocks = true;\r\n    const oldRotation = this.axes.clone();\r\n    let rMatrix: Matrix3d;\r\n    let newRotation: ThreeAxes;\r\n\r\n    if (!newRotationIn)\r\n      newRotation = this.axes.clone(); // for axis based\r\n    else\r\n      newRotation = ThreeAxes.createFromMatrix3d(newRotationIn); // for animating context rotation change...\r\n\r\n    const vp = this.currentView;\r\n    const useACS = vp ? vp.isContextRotationRequired : false;\r\n\r\n    switch (this.rotationMode) {\r\n      case RotationMode.Top:\r\n        // Get standard rotation relative to ACS when ACS context lock is enabled...\r\n        newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardViewId.Top, vp, useACS));\r\n        this.flags.lockedRotation = true;\r\n        break;\r\n\r\n      case RotationMode.Front:\r\n        // Get standard rotation relative to ACS when ACS context lock is enabled...\r\n        newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardViewId.Front, vp, useACS));\r\n        this.flags.lockedRotation = true;\r\n        break;\r\n\r\n      case RotationMode.Side:\r\n        // Get standard rotation relative to ACS when ACS context lock is enabled...\r\n        newRotation.fromMatrix3d(AccuDraw.getStandardRotation(StandardViewId.Right, vp, useACS));\r\n        this.flags.lockedRotation = true;\r\n        break;\r\n\r\n      case RotationMode.ACS:\r\n        rMatrix = vp ? vp.getAuxCoordRotation() : Matrix3d.createIdentity();\r\n        newRotation.fromMatrix3d(rMatrix);\r\n        this.accountForAuxRotationPlane(newRotation, this.flags.auxRotationPlane);\r\n        this.flags.lockedRotation = true;\r\n        break;\r\n\r\n      case RotationMode.View:\r\n        rMatrix = vp ? vp.rotation : Matrix3d.createIdentity();\r\n        newRotation.fromMatrix3d(rMatrix);\r\n        this.flags.lockedRotation = false;\r\n        break;\r\n\r\n      case RotationMode.Context:\r\n        switch (this.flags.contextRotMode) {\r\n          case ContextMode.XAxis:\r\n            this.getRotationFromVector(newRotation, 0);\r\n            clearLocks = (LockedStates.Y_BM !== this.locked || !oldRotation.x.isExactEqual(newRotation.x)); // Try to keep locked axis when tool being unsuspended...\r\n            break;\r\n\r\n          case ContextMode.XAxis2:\r\n            if (vp)\r\n              this.getBestViewedRotationFromXVector(newRotation, vp); // Use base rotation axis that results in compass being most closely aligned to view direction....\r\n            else\r\n              this.getRotationFromVector(newRotation, 0);\r\n            clearLocks = (LockedStates.Y_BM !== this.locked || !oldRotation.x.isExactEqual(newRotation.x)); // Try to keep locked axis when tool being unsuspended...\r\n            break;\r\n\r\n          case ContextMode.YAxis:\r\n            this.getRotationFromVector(newRotation, 1);\r\n            clearLocks = (LockedStates.X_BM !== this.locked || !oldRotation.y.isExactEqual(newRotation.y)); // Try to keep locked axis when tool being unsuspended...\r\n            break;\r\n\r\n          case ContextMode.ZAxis:\r\n            this.getRotationFromVector(newRotation, 2);\r\n            break;\r\n\r\n          case ContextMode.Locked:\r\n            break;\r\n        }\r\n        break;\r\n    }\r\n\r\n    const isChanged = !oldRotation.equals(newRotation);\r\n\r\n    // unlock stuff if rotation has changed\r\n    if (isChanged && clearLocks && (CompassMode.Rectangular === this.compassMode || !this._fieldLocked[ItemField.DIST_Item] || animate)) {\r\n      this.locked = this.indexed = LockedStates.NONE_LOCKED;\r\n      this.unlockAllFields();\r\n    }\r\n\r\n    this.axes.setFrom(newRotation);\r\n    this.lastAxes.setFrom(newRotation);\r\n    this.flags.redrawCompass = true;\r\n\r\n    // If animate frame preference is set...\r\n    if (!animate || !vp)\r\n      return;\r\n\r\n    // AccuDrawAnimatorPtr animator = AccuDrawAnimator:: Create();\r\n    // viewport -> SetAnimator(* animator);\r\n    // animator -> ChangeOfRotation(Matrix3d:: FromColumnVectors(oldRotation[0], oldRotation[1], oldRotation[2]));\r\n  }\r\n\r\n  /** @internal */\r\n  public enableForSession(): void { if (CurrentState.NotEnabled === this.currentState) this.currentState = CurrentState.Inactive; }\r\n  /** @internal */\r\n  public disableForSession(): void {\r\n    this.currentState = CurrentState.NotEnabled;\r\n    this.flags.redrawCompass = true; // Make sure decorators are called so we don't draw (i.e. erase AccuDraw compass)\r\n  }\r\n\r\n  /** @internal */\r\n  public setLastPoint(pt: Point3d): void {\r\n    const viewport = this.currentView;\r\n    if (!viewport)\r\n      return;\r\n\r\n    const ev = new BeButtonEvent({ point: pt, rawPoint: pt, viewPoint: viewport.worldToView(pt), viewport, coordsFrom: CoordSource.User });\r\n    IModelApp.toolAdmin.setAdjustedDataPoint(ev);\r\n  }\r\n\r\n  /** @internal */\r\n  public async sendDataPoint(pt: Point3d, viewport: ScreenViewport): Promise<void> {\r\n    const ev = new BeButtonEvent({ point: pt, rawPoint: pt, viewPoint: viewport.worldToView(pt), viewport, coordsFrom: CoordSource.User });\r\n\r\n    // Send both down and up events...\r\n    await IModelApp.toolAdmin.sendButtonEvent(ev);\r\n    ev.isDown = false;\r\n    return IModelApp.toolAdmin.sendButtonEvent(ev);\r\n  }\r\n\r\n  /** @internal */\r\n  public clearTentative(): boolean {\r\n    if (!IModelApp.tentativePoint.isActive)\r\n      return false;\r\n\r\n    const wasSnapped = IModelApp.tentativePoint.isSnapped;\r\n    IModelApp.tentativePoint.clear(true);\r\n    return wasSnapped;\r\n  }\r\n\r\n  /** @internal */\r\n  public async doAutoPoint(index: ItemField, mode: CompassMode): Promise<void> {\r\n    const vp = this.currentView;\r\n    if (!vp)\r\n      return;\r\n\r\n    if (CompassMode.Polar === mode) {\r\n      if (!this.autoPointPlacement)\r\n        return;\r\n\r\n      if (this._fieldLocked[ItemField.DIST_Item] && (this._fieldLocked[ItemField.ANGLE_Item] || this.indexed & LockedStates.ANGLE_BM) && KeyinStatus.Dynamic === this._keyinStatus[index]) {\r\n        this.fixPointPolar(vp);\r\n        return this.sendDataPoint(this.point, vp);\r\n      }\r\n\r\n      return;\r\n    }\r\n\r\n    if (this._fieldLocked[ItemField.X_Item] && this._fieldLocked[ItemField.Y_Item]) {\r\n      if (!this.isActive) {\r\n        if (!vp.view.is3d() || this._fieldLocked[ItemField.Z_Item]) {\r\n          const globalOrigin = new Point3d();\r\n\r\n          if (vp.view.isSpatialView())\r\n            globalOrigin.setFrom(vp.view.iModel.globalOrigin);\r\n\r\n          return this.sendDataPoint(globalOrigin.plus(this.delta), vp);\r\n        }\r\n\r\n        return;\r\n      }\r\n\r\n      if (!this.autoPointPlacement || KeyinStatus.Dynamic !== this._keyinStatus[index])\r\n        return;\r\n\r\n      this.origin.plus3Scaled(this.axes.x, this.delta.x, this.axes.y, this.delta.y, this.axes.z, this.delta.z, this.point);\r\n      return this.sendDataPoint(this.point, vp);\r\n    }\r\n\r\n    if (!this.autoPointPlacement || KeyinStatus.Dynamic !== this._keyinStatus[index])\r\n      return;\r\n\r\n    if ((ItemField.X_Item === index && this._fieldLocked[ItemField.X_Item] && (this.indexed & LockedStates.Y_BM)) || (ItemField.Y_Item === index && this._fieldLocked[ItemField.Y_Item] && (this.indexed & LockedStates.X_BM))) {\r\n      this.origin.plus3Scaled(this.axes.x, this.delta.x, this.axes.y, this.delta.y, this.axes.z, this.delta.z, this.point);\r\n      return this.sendDataPoint(this.point, vp);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public getValueByIndex(index: ItemField): number {\r\n    switch (index) {\r\n      case ItemField.X_Item: return this.delta.x;\r\n      case ItemField.Y_Item: return this.delta.y;\r\n      case ItemField.Z_Item: return this.delta.z;\r\n      case ItemField.DIST_Item: return this._distance;\r\n      case ItemField.ANGLE_Item: return this._angle;\r\n      default:\r\n        return 0.0;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public setValueByIndex(index: ItemField, value: number): void {\r\n    switch (index) {\r\n      case ItemField.X_Item:\r\n        this.delta.x = value;\r\n        break;\r\n      case ItemField.Y_Item:\r\n        this.delta.y = value;\r\n        break;\r\n      case ItemField.Z_Item:\r\n        this.delta.z = value;\r\n        break;\r\n      case ItemField.DIST_Item:\r\n        this._distance = value;\r\n        break;\r\n      case ItemField.ANGLE_Item:\r\n        this._angle = value;\r\n        break;\r\n    }\r\n  }\r\n\r\n  private updateVector(angle: number): void {\r\n    this.vector.set(Math.cos(angle), Math.sin(angle), 0.0);\r\n    const rMatrix = this.getRotation();\r\n    rMatrix.multiplyTransposeVector(this.vector);\r\n  }\r\n\r\n  private stringToUORs(_uors: number[], _str: string): BentleyStatus {\r\n    // DistanceParserPtr parser = DistanceParser:: Create();\r\n    // DgnViewportP   vp = GetCompassViewport();\r\n\r\n    // if (NULL == vp)\r\n    //   parser = DistanceParser:: Create();\r\n    //   else\r\n    // parser = DistanceParser:: Create(* vp);\r\n\r\n    // if (SUCCESS != parser.ToValue(uors, str))\r\n    //   return ERROR;\r\n\r\n    return BentleyStatus.SUCCESS;\r\n  }\r\n\r\n  private stringToAngle(_angle: number[], _out: { isBearing: boolean }, _inString: string, _restrict: boolean): BentleyStatus {\r\n    // WString     buffer(inString, BentleyCharEncoding:: Utf8);\r\n    // WChar * p1, * p2, * string;\r\n    // int         north = 0, east = 0;\r\n    // bool        bearing = false;\r\n\r\n    // if (isBearing)\r\n    //       * isBearing = false;\r\n\r\n    // string = buffer.begin();\r\n\r\n    // if ((p1 = wcspbrk(string, L\"NnSs\")) != NULL) {\r\n    //   string = p1 + 1;\r\n\r\n    //   if ((p2 = wcspbrk(string, L\"EeWw\")) == NULL)\r\n    //     return ERROR;\r\n\r\n    //   north = (towupper(* p1) == L'N');\r\n    //   east = (towupper(* p2) == L'E');\r\n    //       * p2 = 0; // terminate string\r\n    //   bearing = true;\r\n    // }\r\n    // else if (string[1] == L' ')\r\n    // {\r\n    //   bearing = true;\r\n\r\n    //   switch (string[0]) {\r\n    //     case L'1':\r\n    //       north = true;\r\n    //       east = true;\r\n    //       break;\r\n    //     case L'2':\r\n    //       north = false;\r\n    //       east = true;\r\n    //       break;\r\n    //     case L'3':\r\n    //       north = false;\r\n    //       east = false;\r\n    //       break;\r\n    //     case L'4':\r\n    //       north = true;\r\n    //       east = false;\r\n    //       break;\r\n    //     default:\r\n    //       bearing = false;\r\n    //       break;\r\n    //   }\r\n\r\n    //   if (bearing)\r\n    //     string += 2;\r\n    // }\r\n    //   else\r\n    // {\r\n    //   bearing = false;\r\n    // }\r\n\r\n    // while (* string == L' ')\r\n    // string++;\r\n\r\n    // AngleParserPtr parser = AngleParser:: Create();\r\n\r\n    // _SetupAngleParser(* parser);\r\n\r\n    // if (SUCCESS != parser -> ToValue(angle, Utf8String(string).c_str()))\r\n    //   return ERROR;\r\n\r\n    // if (bearing) {\r\n    //   if (north) {\r\n    //     if (east)\r\n    //       angle = 90.0 - angle;\r\n    //     else\r\n    //       angle = 90.0 + angle;\r\n    //   }\r\n    //   else {\r\n    //     if (east)\r\n    //       angle = 270.0 + angle;\r\n    //     else\r\n    //       angle = 270.0 - angle;\r\n    //   }\r\n    // }\r\n    // else {\r\n    //   DirectionFormatterPtr  formatter;\r\n\r\n    //   DgnViewportP vp = GetCompassViewport();\r\n    //   if (vp)\r\n    //     formatter = DirectionFormatter:: Create(* vp -> GetViewController().GetTargetModel());\r\n    //       else\r\n    //   formatter = DirectionFormatter:: Create();\r\n\r\n    //   if (DirectionMode:: Azimuth == formatter -> GetDirectionMode())\r\n    //   {\r\n    //     if (formatter -> GetClockwise())\r\n    //       angle = formatter -> GetBaseDirection() - angle;\r\n    //     else\r\n    //       angle = angle - formatter -> GetBaseDirection();\r\n    //   }\r\n    // }\r\n\r\n    // if (restrict == true) {\r\n    //   while (angle >= 360.0)\r\n    //     angle -= 360.0;\r\n\r\n    //   while (angle < 0.0)\r\n    //     angle += 360.0;\r\n    // }\r\n\r\n    // angle *= (msGeomConst_pi / 180.0);\r\n\r\n    // if (isBearing)\r\n    //       * isBearing = bearing;\r\n\r\n    return BentleyStatus.SUCCESS;\r\n  }\r\n\r\n  private updateFieldValue(index: ItemField, input: string, out: { isBearing: boolean }): BentleyStatus {\r\n    if (input.length === 0)\r\n      return BentleyStatus.ERROR;\r\n\r\n    if (input.length === 1)\r\n      switch (input) {\r\n        case \":\":\r\n        case \"-\":\r\n        case \"+\":\r\n        case \".\":\r\n          return BentleyStatus.ERROR;\r\n      }\r\n\r\n    switch (index) {\r\n      case ItemField.DIST_Item:\r\n        if (BentleyStatus.SUCCESS !== this.stringToUORs([this._distance], input))\r\n          return BentleyStatus.ERROR;\r\n        break;\r\n\r\n      case ItemField.ANGLE_Item:\r\n        if (BentleyStatus.SUCCESS !== this.stringToAngle([this._angle], out, input, true))\r\n          return BentleyStatus.ERROR;\r\n        break;\r\n\r\n      case ItemField.X_Item:\r\n        if (BentleyStatus.SUCCESS !== this.stringToUORs([this.delta.x], input))\r\n          return BentleyStatus.ERROR;\r\n\r\n        this._xIsExplicit = (input[0] === \"+\" || input[0] === \"-\");\r\n        if (!this._xIsExplicit) {\r\n          if (this.smartKeyin && this.isActive && this._xIsNegative === (this.delta.x >= 0.0))\r\n            this.delta.x = -this.delta.x;\r\n        }\r\n        break;\r\n\r\n      case ItemField.Y_Item:\r\n        if (BentleyStatus.SUCCESS !== this.stringToUORs([this.delta.y], input))\r\n          return BentleyStatus.ERROR;\r\n\r\n        this._yIsExplicit = (input[0] === \"+\" || input[0] === \"-\");\r\n        if (!this._yIsExplicit) {\r\n          if (this.smartKeyin && this.isActive && this._yIsNegative === (this.delta.y >= 0.0))\r\n            this.delta.y = -this.delta.y;\r\n        }\r\n        break;\r\n\r\n      case ItemField.Z_Item:\r\n        if (BentleyStatus.SUCCESS !== this.stringToUORs([this.delta.z], input))\r\n          return BentleyStatus.ERROR;\r\n        break;\r\n    }\r\n\r\n    return BentleyStatus.SUCCESS;\r\n  }\r\n\r\n  /** @internal */\r\n  public unlockAllFields(): void {\r\n    this.locked = 0;\r\n\r\n    if (CompassMode.Polar === this.compassMode) {\r\n      if (this._fieldLocked[ItemField.DIST_Item])\r\n        this.setFieldLock(ItemField.DIST_Item, false);\r\n\r\n      if (this._fieldLocked[ItemField.ANGLE_Item])\r\n        this.setFieldLock(ItemField.ANGLE_Item, false);\r\n    } else {\r\n      if (this._fieldLocked[ItemField.X_Item])\r\n        this.setFieldLock(ItemField.X_Item, false);\r\n\r\n      if (this._fieldLocked[ItemField.Y_Item])\r\n        this.setFieldLock(ItemField.Y_Item, false);\r\n    }\r\n\r\n    if (this._fieldLocked[ItemField.Z_Item]) {\r\n      if (this.stickyZLock)\r\n        this.delta.z = 0.0;\r\n      else\r\n        this.setFieldLock(ItemField.Z_Item, false);\r\n    }\r\n\r\n    this.setKeyinStatus(ItemField.DIST_Item, KeyinStatus.Dynamic);\r\n    this.setKeyinStatus(ItemField.ANGLE_Item, KeyinStatus.Dynamic);\r\n    this.setKeyinStatus(ItemField.X_Item, KeyinStatus.Dynamic);\r\n    this.setKeyinStatus(ItemField.Y_Item, KeyinStatus.Dynamic);\r\n    this.setKeyinStatus(ItemField.Z_Item, KeyinStatus.Dynamic);\r\n\r\n    if (!this.smartKeyin)\r\n      this.setFocusItem(CompassMode.Polar === this.compassMode ? ItemField.DIST_Item : ItemField.X_Item);\r\n\r\n    this.dontMoveFocus = false;\r\n  }\r\n\r\n  /** produces the normal vector of the closest plane to the view which\r\n   * contains inVec (uses true view rotation, never auxiliary)\r\n   */\r\n  private planeByVectorAndView(normalVec: Vector3d, inVec: Vector3d, vp: Viewport): boolean {\r\n    if (!vp.view.is3d()) {\r\n      normalVec.setFrom(Vector3d.unitZ());\r\n      return true;\r\n    }\r\n\r\n    const viewNormal = vp.rotation.getRow(2);\r\n    const yVec = viewNormal.crossProduct(inVec);\r\n\r\n    if (!yVec.normalizeInPlace()) {\r\n      normalVec = viewNormal;\r\n      return false;\r\n    }\r\n\r\n    inVec.crossProduct(yVec, normalVec);\r\n    return true;\r\n  }\r\n\r\n  private handleDegeneratePolarCase(): void {\r\n    if (!(this.locked & LockedStates.DIST_BM))\r\n      this._distance = 0.0;\r\n\r\n    if (this.locked & LockedStates.VEC_BM) {\r\n      this._angle = Math.acos(this.vector.dotProduct(this.axes.x));\r\n    } else if (this.locked & LockedStates.Y_BM) {\r\n      this.vector.setFrom(this.axes.y);\r\n      this._angle = Math.PI / 2.0;\r\n      this.indexed = this.locked;\r\n    } else if (this.locked & LockedStates.X_BM) {\r\n      this.vector.setFrom(this.axes.x);\r\n      this._angle = 0.0;\r\n      this.indexed = this.locked;\r\n    } else {\r\n      // use last good vector\r\n      this._angle = Math.acos(this.vector.dotProduct(this.axes.x));\r\n    }\r\n    this.origin.plusScaled(this.vector, this._distance, this.point);\r\n  }\r\n\r\n  private rawDeltaIsValid(rawDelta: number): boolean {\r\n    /* Cursor Distance (*(+/-)) sense testing is not valid when raw delta is\r\n       meaningless (0.0)...to make this change safer only reject the\r\n       raw delta if unit or grid lock is also on. */\r\n    if (0.0 !== rawDelta)\r\n      return true;\r\n\r\n    // The \"I don't want grid lock\" flag can be set by tools to override the default behavior...\r\n    if (0 === (IModelApp.toolAdmin.toolState.coordLockOvr & CoordinateLockOverrides.Grid))\r\n      return true;\r\n\r\n    return (!IModelApp.toolAdmin.gridLock);\r\n  }\r\n\r\n  /** @internal */\r\n  public async processFieldInput(index: ItemField, input: string, synchText: boolean): Promise<void> {\r\n    const isBearing = false;\r\n\r\n    if (BentleyStatus.SUCCESS !== this.updateFieldValue(index, input, { isBearing })) {\r\n      const saveKeyinStatus = this._keyinStatus[index]; // Don't want this to change when entering '.', etc.\r\n      this.updateFieldLock(index, false);\r\n      this._keyinStatus[index] = saveKeyinStatus;\r\n      return;\r\n    }\r\n\r\n    switch (index) {\r\n      case ItemField.DIST_Item:\r\n        this.distanceLock(synchText, true);\r\n        await this.doAutoPoint(index, CompassMode.Polar);\r\n        break;\r\n\r\n      case ItemField.ANGLE_Item:\r\n        this.setFieldLock(index, true);\r\n\r\n        if (synchText) {\r\n          this.onFieldValueChange(index);\r\n          this.setKeyinStatus(index, KeyinStatus.Dynamic);\r\n        }\r\n\r\n        if (!isBearing || !this.flags.bearingFixToPlane2D)\r\n          this.updateVector(this._angle);\r\n        else\r\n          this.vector.set(Math.cos(this._angle), Math.sin(this._angle), 0.0);\r\n\r\n        this.locked |= LockedStates.VEC_BM;\r\n        await this.doAutoPoint(index, CompassMode.Polar);\r\n        break;\r\n\r\n      case ItemField.X_Item:\r\n      case ItemField.Y_Item:\r\n        this.locked |= (ItemField.X_Item === index) ? LockedStates.X_BM : LockedStates.Y_BM;\r\n      /* falls through */\r\n\r\n      case ItemField.Z_Item:\r\n        this.setFieldLock(index, true);\r\n        if (synchText) {\r\n          this.onFieldValueChange(index);\r\n          this.setKeyinStatus(index, KeyinStatus.Dynamic);\r\n        }\r\n\r\n        await this.doAutoPoint(index, this.compassMode);\r\n        break;\r\n    }\r\n\r\n    this.refreshDecorationsAndDynamics();\r\n  }\r\n\r\n  /** @internal */\r\n  public updateFieldLock(index: ItemField, locked: boolean): void {\r\n    if (locked) {\r\n      if (!this._fieldLocked[index]) {\r\n        this.setFieldLock(index, true);\r\n\r\n        switch (index) {\r\n          case ItemField.DIST_Item:\r\n            this.distanceLock(true, false);\r\n            break;\r\n\r\n          case ItemField.ANGLE_Item:\r\n            this.angleLock();\r\n            break;\r\n\r\n          case ItemField.X_Item:\r\n            this.locked |= LockedStates.X_BM;\r\n            break;\r\n\r\n          case ItemField.Y_Item:\r\n            this.locked |= LockedStates.Y_BM;\r\n            break;\r\n\r\n          case ItemField.Z_Item:\r\n            break;\r\n        }\r\n      }\r\n      return;\r\n    }\r\n\r\n    switch (index) {\r\n      case ItemField.DIST_Item:\r\n        this.locked &= ~LockedStates.DIST_BM;\r\n        break;\r\n\r\n      case ItemField.ANGLE_Item:\r\n        this.locked &= ~LockedStates.VEC_BM;\r\n        break;\r\n\r\n      case ItemField.X_Item:\r\n        this.locked &= ~LockedStates.X_BM;\r\n        break;\r\n\r\n      case ItemField.Y_Item:\r\n        this.locked &= ~LockedStates.Y_BM;\r\n        break;\r\n    }\r\n\r\n    if (index !== ItemField.Z_Item || !this.stickyZLock)\r\n      this.setFieldLock(index, false);\r\n\r\n    this.setKeyinStatus(index, KeyinStatus.Dynamic);\r\n  }\r\n\r\n  /** @internal */\r\n  public static getSnapRotation(snap: SnapDetail, currentVp: Viewport | undefined, out?: Matrix3d): Matrix3d | undefined {\r\n    const vp = (undefined !== currentVp) ? currentVp : snap.viewport;\r\n    const rotation = out ? out : new Matrix3d();\r\n    const viewZ = vp.rotation.rowZ();\r\n    const snapLoc = (undefined !== snap.primitive ? snap.primitive.closestPoint(snap.snapPoint, false) : undefined);\r\n\r\n    if (undefined !== snapLoc) {\r\n      const frame = snap.primitive!.fractionToFrenetFrame(snapLoc.fraction);\r\n      const frameZ = (undefined !== frame ? frame.matrix.columnZ() : Vector3d.unitZ());\r\n      let xVec = (undefined !== frame ? frame.matrix.columnX() : Vector3d.unitX());\r\n      const zVec = (vp.view.allow3dManipulations() ? (undefined !== snap.normal ? snap.normal.clone() : frameZ.clone()) : Vector3d.unitZ());\r\n\r\n      if (!vp.isCameraOn && viewZ.isPerpendicularTo(zVec))\r\n        zVec.setFrom(viewZ);\r\n\r\n      xVec.normalizeInPlace();\r\n      zVec.normalizeInPlace();\r\n\r\n      let yVec = xVec.unitCrossProduct(zVec);\r\n\r\n      if (undefined !== yVec) {\r\n        const viewX = vp.rotation.rowX();\r\n        if (snap.primitive instanceof LineString3d) {\r\n          if (Math.abs(xVec.dotProduct(viewX)) < Math.abs(yVec.dotProduct(viewX))) {\r\n            const tVec = xVec;\r\n            xVec = yVec;\r\n            yVec = tVec;\r\n          }\r\n          if (xVec.dotProduct(viewX) < 0.0)\r\n            xVec.negate(xVec);\r\n        } else {\r\n          const ray = snap.primitive!.fractionToPointAndUnitTangent(0.0);\r\n          if (ray.direction.dotProduct(viewX) < 0.0 && ray.direction.dotProduct(xVec) > 0.0)\r\n            xVec.negate(xVec);\r\n        }\r\n\r\n        if (zVec.dotProduct(viewZ) < 0.0)\r\n          zVec.negate(zVec);\r\n\r\n        yVec = xVec.unitCrossProduct(zVec);\r\n\r\n        if (undefined !== yVec) {\r\n          rotation.setColumns(xVec, yVec, zVec);\r\n          Matrix3d.createRigidFromMatrix3d(rotation, AxisOrder.XZY, rotation);\r\n          rotation.transposeInPlace();\r\n\r\n          return rotation;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (undefined !== snap.normal) {\r\n      const zVec = (vp.view.allow3dManipulations() ? snap.normal.clone() : Vector3d.unitZ());\r\n\r\n      if (!vp.isCameraOn && viewZ.isPerpendicularTo(zVec))\r\n        zVec.setFrom(viewZ);\r\n\r\n      zVec.normalizeInPlace();\r\n      Matrix3d.createRigidHeadsUp(zVec, undefined, rotation);\r\n      rotation.transposeInPlace();\r\n\r\n      return rotation;\r\n    }\r\n\r\n    return undefined;\r\n  }\r\n\r\n  /** @internal */\r\n  public static getStandardRotation(nStandard: StandardViewId, vp: Viewport | undefined, useACS: boolean, out?: Matrix3d): Matrix3d {\r\n    const rMatrix = out ? out : new Matrix3d();\r\n    rMatrix.setFrom(ViewState.getStandardViewMatrix(nStandard));\r\n    const useVp = vp ? vp : IModelApp.viewManager.selectedView;\r\n    if (!useACS || !useVp)\r\n      return rMatrix;\r\n\r\n    rMatrix.multiplyMatrixMatrix(useVp.getAuxCoordRotation(AccuDraw._tempRot), rMatrix);\r\n    return rMatrix;\r\n  }\r\n\r\n  /** @internal */\r\n  public static getCurrentOrientation(vp: Viewport, checkAccuDraw: boolean, checkACS: boolean, rMatrix?: Matrix3d): Matrix3d | undefined {\r\n    if (checkAccuDraw && IModelApp.accuDraw.isActive)\r\n      return IModelApp.accuDraw.getRotation(rMatrix);\r\n\r\n    const useVp = vp ? vp : IModelApp.viewManager.selectedView;\r\n    if (!useVp)\r\n      return Matrix3d.createIdentity(rMatrix);\r\n\r\n    if (checkACS && useVp.isContextRotationRequired)\r\n      return useVp.getAuxCoordRotation(rMatrix);\r\n\r\n    return useVp.rotation;\r\n  }\r\n\r\n  /** @internal */\r\n  public static updateAuxCoordinateSystem(acs: AuxCoordSystemState, vp: Viewport, allViews: boolean = true): void {\r\n    // When modeling with multiple spatial views open, you'd typically want the same ACS in all views...\r\n    if (allViews && vp.view.isSpatialView()) {\r\n      IModelApp.viewManager.forEachViewport((otherVp) => {\r\n        if (otherVp !== vp && otherVp.view.isSpatialView())\r\n          otherVp.view.setAuxiliaryCoordinateSystem(acs);\r\n      });\r\n    }\r\n\r\n    vp.view.setAuxiliaryCoordinateSystem(acs);\r\n\r\n    // NOTE: Change AccuDraw's base rotation to ACS.\r\n    IModelApp.accuDraw.setContext(AccuDrawFlags.OrientACS);\r\n  }\r\n\r\n  /** @internal */\r\n  public distanceLock(synchText: boolean, saveInHistory: boolean): void {\r\n    this.locked |= LockedStates.DIST_BM;\r\n\r\n    if (!this._fieldLocked[ItemField.DIST_Item])\r\n      this.setFieldLock(ItemField.DIST_Item, true);\r\n\r\n    if (saveInHistory)\r\n      this.saveCoordinate(ItemField.DIST_Item, this._distance);\r\n\r\n    if (synchText) {\r\n      this.onFieldValueChange(ItemField.DIST_Item);\r\n      this.setKeyinStatus(ItemField.DIST_Item, KeyinStatus.Dynamic);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public angleLock(): void {\r\n    if (this.indexed & LockedStates.Y_BM)\r\n      this.locked |= LockedStates.Y_BM;\r\n    else if (this.indexed & LockedStates.X_BM)\r\n      this.locked |= LockedStates.X_BM;\r\n    else\r\n      this.locked |= LockedStates.VEC_BM;\r\n\r\n    this.clearTentative();\r\n\r\n    if (!this._fieldLocked[ItemField.ANGLE_Item]) {\r\n      this.setFieldLock(ItemField.ANGLE_Item, true);\r\n      this.setKeyinStatus(ItemField.ANGLE_Item, KeyinStatus.Dynamic);\r\n    }\r\n\r\n    this.flags.lockedRotation = true;\r\n    this.flags.softAngleLock = false;\r\n  }\r\n\r\n  /** @internal */\r\n  public doLockAngle(isSnapped: boolean): void {\r\n    if (CompassMode.Polar !== this.compassMode) {\r\n      this.locked = LockedStates.NONE_LOCKED;\r\n      this._rawPoint.setFrom(this.point);\r\n\r\n      const vp = this.currentView;\r\n      if (vp)\r\n        this.fixPointPolar(vp);\r\n\r\n      this.changeCompassMode(true);\r\n    }\r\n\r\n    this.setFieldLock(ItemField.ANGLE_Item, !this._fieldLocked[ItemField.ANGLE_Item]);\r\n\r\n    if (this._fieldLocked[ItemField.ANGLE_Item]) {\r\n      // Move focus to angle field...\r\n      if (!isSnapped && this.autoFocusFields)\r\n        this.setFocusItem(ItemField.ANGLE_Item);\r\n\r\n      this.angleLock();\r\n\r\n      if (!isSnapped)\r\n        this.flags.softAngleLock = true;\r\n    } else {\r\n      this.locked &= ~LockedStates.ANGLE_BM;\r\n      this.saveCoordinate(ItemField.ANGLE_Item, this._angle);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public saveCoordinate(index: ItemField, value: number): void {\r\n    const isAngle = (ItemField.ANGLE_Item === index);\r\n    let currIndex = this._savedCoords.nSaveValues + 1;\r\n\r\n    if (currIndex >= Constants.MAX_SAVED_VALUES)\r\n      currIndex = 0;\r\n\r\n    if (this._savedCoords.savedValues[this._savedCoords.nSaveValues] === value && this._savedCoords.savedValIsAngle[this._savedCoords.nSaveValues] === isAngle)\r\n      return;\r\n\r\n    if (isAngle) {\r\n      // don't accept 0, 90, -90, and 180 degrees\r\n      if (value === 0.0 || value === Math.PI || value === (Math.PI / 2.0) || value === -Math.PI)\r\n        return;\r\n    } else {\r\n      // don't accept zero\r\n      value = Math.abs(value);\r\n      if (value < Constants.SMALL_ANGLE)\r\n        return;\r\n    }\r\n\r\n    this._savedCoords.savedValues[currIndex] = value;\r\n    this._savedCoords.savedValIsAngle[currIndex] = isAngle;\r\n    this._savedCoords.nSaveValues = currIndex;\r\n\r\n    if (!isAngle)\r\n      this._lastDistance = value;\r\n  }\r\n\r\n  /** @internal */\r\n  public changeCompassMode(animate: boolean = false): void {\r\n    this.setCompassMode(CompassMode.Polar === this.compassMode ? CompassMode.Rectangular : CompassMode.Polar);\r\n\r\n    const viewport = this.currentView;\r\n    if (!animate || !viewport)\r\n      return;\r\n\r\n    // AccuDrawAnimatorPtr animator = AccuDrawAnimator:: Create();\r\n    // viewport.setAnimator(* animator);\r\n    // animator -> ChangeOfMode();\r\n  }\r\n\r\n  /** @internal */\r\n  public changeBaseRotationMode(mode: RotationMode): void {\r\n    if (mode > RotationMode.Context)\r\n      return;\r\n\r\n    if (RotationMode.Context === mode) {\r\n      // See if it is better to stay with the current base rotation (only care about z)...\r\n      if (RotationMode.Context !== this.flags.baseRotation) {\r\n        const baseRMatrix = this.getBaseRotation();\r\n        const baseZ = baseRMatrix.getRow(2);\r\n\r\n        if (baseZ.isParallelTo(this.axes.z, true))\r\n          return;\r\n      }\r\n\r\n      this.baseAxes.setFrom(this.axes);\r\n      this.flags.auxRotationPlane = RotationMode.Top;\r\n    }\r\n\r\n    this.flags.baseRotation = mode;\r\n  }\r\n\r\n  private getBaseRotation(): Matrix3d {\r\n    const vp = this.currentView;\r\n    let baseRMatrix: Matrix3d;\r\n    const useAcs = vp ? vp.isContextRotationRequired : false;\r\n    switch (this.flags.baseRotation) {\r\n      case RotationMode.Top: {\r\n        baseRMatrix = AccuDraw.getStandardRotation(StandardViewId.Top, vp, useAcs)!;\r\n        break;\r\n      }\r\n\r\n      case RotationMode.Front: {\r\n        baseRMatrix = AccuDraw.getStandardRotation(StandardViewId.Front, vp, useAcs)!;\r\n        break;\r\n      }\r\n\r\n      case RotationMode.Side: {\r\n        baseRMatrix = AccuDraw.getStandardRotation(StandardViewId.Right, vp, useAcs)!;\r\n        break;\r\n      }\r\n\r\n      case RotationMode.ACS: {\r\n        baseRMatrix = vp ? vp.getAuxCoordRotation() : Matrix3d.createIdentity();\r\n        const axes = ThreeAxes.createFromMatrix3d(baseRMatrix);\r\n        this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);\r\n        axes.toMatrix3d(baseRMatrix);\r\n        break;\r\n      }\r\n\r\n      case RotationMode.View: {\r\n        baseRMatrix = vp ? vp.rotation : Matrix3d.createIdentity();\r\n        break;\r\n      }\r\n\r\n      case RotationMode.Context: {\r\n        const axes = new ThreeAxes();\r\n        axes.setFrom(this.baseAxes);\r\n        this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);\r\n        baseRMatrix = axes.toMatrix3d();\r\n        break;\r\n      }\r\n\r\n      default: {\r\n        baseRMatrix = Matrix3d.createIdentity();\r\n        break;\r\n      }\r\n    }\r\n    return baseRMatrix;\r\n  }\r\n\r\n  /** @internal */\r\n  public setContextRotation(rMatrix: Matrix3d, locked: boolean, animate: boolean): void {\r\n    this.flags.lockedRotation = locked;\r\n    this.flags.contextRotMode = locked ? ContextMode.Locked : ContextMode.None;\r\n    this.setRotationMode(RotationMode.Context);\r\n    this.updateRotation(animate, rMatrix);\r\n  }\r\n\r\n  private clearContext(): void {\r\n    this.published.flags = 0;\r\n    this.flags.rotationNeedsUpdate = true;\r\n    this.flags.fixedOrg = false;\r\n\r\n    this.setNewFocus(ItemField.X_Item);\r\n    this.unlockAllFields();\r\n\r\n    if (this.rotationMode !== this.flags.baseRotation)\r\n      this.setRotationMode(this.flags.baseRotation);\r\n\r\n    if (this.compassMode !== this.flags.baseMode)\r\n      this.setCompassMode(this.flags.baseMode);\r\n  }\r\n\r\n  /** @internal */\r\n  public setContext(flags: AccuDrawFlags, originP?: Point3d, orientationP?: Matrix3d | Vector3d, deltaP?: Vector3d, distanceP?: number, angleP?: number, transP?: Transform): BentleyStatus {\r\n    this.published.flags |= flags;\r\n\r\n    if (flags & AccuDrawFlags.SetOrigin && originP) {\r\n      this.published.origin.setFrom(originP);\r\n\r\n      if (transP)\r\n        transP.multiplyPoint3d(this.published.origin, this.published.origin);\r\n    }\r\n\r\n    if (deltaP) {\r\n      this.published.delta.setFrom(deltaP);\r\n\r\n      if (transP)\r\n        this.published.delta.scaleInPlace(transP.matrix.columnX().magnitude());\r\n    }\r\n\r\n    if (typeof distanceP === \"number\") {\r\n      this.published.distance = distanceP;\r\n\r\n      if (transP)\r\n        this.published.distance *= transP.matrix.columnX().magnitude();\r\n    }\r\n\r\n    if (typeof angleP === \"number\")\r\n      this.published.angle = angleP;\r\n\r\n    if (orientationP) {\r\n      if (flags & AccuDrawFlags.SetXAxis || flags & AccuDrawFlags.SetNormal || flags & AccuDrawFlags.SetXAxis2) {\r\n        this.published.vector.setFrom(orientationP as Vector3d);\r\n\r\n        if (transP)\r\n          transP.matrix.multiplyVectorInPlace(this.published.vector);\r\n\r\n        this.published.vector.normalizeInPlace();\r\n      } else if (flags & AccuDrawFlags.SetRMatrix) {\r\n        this.published.rMatrix.setFrom(orientationP as Matrix3d);\r\n\r\n        if (transP) {\r\n          this.published.rMatrix.multiplyMatrixMatrix(transP.matrix, this.published.rMatrix);\r\n          this.published.rMatrix.normalizeColumnsInPlace();\r\n        }\r\n      }\r\n    }\r\n\r\n    if (flags) {\r\n      this.onEventCommon();\r\n      if (!this.flags.haveValidOrigin)\r\n        this.setDefaultOrigin(this.currentView);\r\n    }\r\n\r\n    return this.isEnabled ? BentleyStatus.SUCCESS : BentleyStatus.ERROR;\r\n  }\r\n\r\n  private onEventCommon(): void {\r\n    if (this.published.flags & AccuDrawFlags.RedrawCompass) {\r\n      this.flags.indexLocked = true;\r\n      this.flags.redrawCompass = true;\r\n    }\r\n\r\n    if (this.published.flags & AccuDrawFlags.UpdateRotation) {\r\n      this.flags.indexLocked = true;\r\n      this.flags.contextRotMode = ContextMode.XAxis;\r\n      this.setRotationMode(RotationMode.Context);\r\n      this.updateRotation();\r\n      this.flags.indexLocked = true;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public onPrimitiveToolInstall(): boolean {\r\n    if (!this.isEnabled)\r\n      return false;\r\n\r\n    this.onEventCommon();\r\n    this.saveLockedCoords();\r\n    // Setup default starting tool state...\r\n    this.currentState = CurrentState.Inactive;\r\n    this.clearContext();\r\n    if (this.alwaysShowCompass)\r\n      this.activate();\r\n\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public onViewToolInstall(): boolean {\r\n    if (!this.isEnabled)\r\n      return false;\r\n\r\n    this.onEventCommon();\r\n\r\n    const tool = IModelApp.toolAdmin.activeTool;\r\n    if (tool && !(tool instanceof ViewTool))\r\n      this.saveState(this.savedStateViewTool); // Save AccuDraw state of tool being suspended...\r\n\r\n    this.currentState = CurrentState.Deactivated; // Default to disabled for view tools.\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public onViewToolExit(): boolean {\r\n    if (!this.isEnabled)\r\n      return false;\r\n\r\n    this.onEventCommon();\r\n    this.restoreState(this.savedStateViewTool); // Restore AccuDraw state of suspended tool...\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public onInputCollectorInstall(): boolean {\r\n    if (!this.isEnabled)\r\n      return false;\r\n\r\n    this.onEventCommon();\r\n\r\n    const tool = IModelApp.toolAdmin.activeTool;\r\n    if (tool && !(tool instanceof InputCollector))\r\n      this.saveState(this.savedStateInputCollector); // Save AccuDraw state of tool being suspended...\r\n\r\n    this.currentState = CurrentState.Inactive; // Default to inactive for input collectors.\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public onInputCollectorExit(): boolean {\r\n    if (!this.isEnabled)\r\n      return false;\r\n\r\n    this.onEventCommon();\r\n    this.restoreState(this.savedStateInputCollector); // Restore AccuDraw state of suspended tool...\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public saveState(stateBuffer: SavedState): void {\r\n    stateBuffer.state = this.currentState;\r\n    stateBuffer.mode = this.compassMode;\r\n    stateBuffer.rotationMode = this.rotationMode;\r\n    stateBuffer.axes.setFrom(this.axes);\r\n    stateBuffer.origin.setFrom(this.origin);\r\n    stateBuffer.auxRotationPlane = this.flags.auxRotationPlane;\r\n    stateBuffer.contextRotMode = this.flags.contextRotMode;\r\n    stateBuffer.fixedOrg = this.flags.fixedOrg;\r\n    stateBuffer.ignoreDataButton = true;\r\n    stateBuffer.ignoreFlags = 0;\r\n  }\r\n\r\n  /** @internal */\r\n  public restoreState(stateBuffer: SavedState): void {\r\n    if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.Disable)) {\r\n      this.currentState = stateBuffer.state;\r\n    }\r\n\r\n    if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.SetOrigin)) {\r\n      this.origin.setFrom(stateBuffer.origin);\r\n      this.planePt.setFrom(stateBuffer.origin);\r\n    }\r\n\r\n    if (0 === (stateBuffer.ignoreFlags & AccuDrawFlags.SetRMatrix)) {\r\n      this.axes.setFrom(stateBuffer.axes);\r\n      this.setRotationMode(stateBuffer.rotationMode);\r\n      this.flags.auxRotationPlane = stateBuffer.auxRotationPlane;\r\n      this.flags.contextRotMode = stateBuffer.contextRotMode;\r\n    }\r\n\r\n    this.flags.fixedOrg = stateBuffer.fixedOrg;\r\n    this.setCompassMode(stateBuffer.mode);\r\n    this.updateRotation();\r\n\r\n    if (stateBuffer.ignoreDataButton)\r\n      this.flags.ignoreDataButton = (this.flags.inDataPoint ? true : false);\r\n  }\r\n\r\n  private getCompassPlanePoint(point: Point3d, vp: Viewport): boolean {\r\n    point.setFrom(this.origin); // Isn't this just planePt?!? Maybe at display time it is not setup yet?!?\r\n    if (this._fieldLocked[ItemField.Z_Item] && vp.view.is3d()) {\r\n      if (0.0 !== this.delta.z && !(this.delta.z < Constants.SMALL_ANGLE && this.delta.z > -Constants.SMALL_ANGLE)) {\r\n        point.addScaledInPlace(this.axes.z, this.delta.z);\r\n        return true;\r\n      }\r\n    }\r\n    return false;\r\n  }\r\n\r\n  private getDisplayTransform(vp: Viewport): Transform {\r\n    const rMatrix = (!this.flags.animateRotation || 0.0 === this._percentChanged) ? this.axes.toMatrix3d() : this.lastAxes.toMatrix3d();\r\n    const origin = new Point3d(); // Compass origin is adjusted by active z-lock...\r\n    this.getCompassPlanePoint(origin, vp);\r\n    const scale = vp.pixelsFromInches(this._compassSizeInches) * vp.getPixelSizeAtPoint(origin);\r\n    rMatrix.transposeInPlace();\r\n    rMatrix.scaleColumns(scale, scale, scale, rMatrix);\r\n    return Transform.createRefs(origin, rMatrix);\r\n  }\r\n\r\n  private setIndexingTolerance(vp: Viewport) {\r\n    const origin = new Point3d(); // Compass origin is adjusted by active z-lock...\r\n    this.getCompassPlanePoint(origin, vp);\r\n    this._tolerance = vp.pixelsFromInches(this._indexToleranceInches) * vp.getPixelSizeAtPoint(origin);\r\n    if (Constants.SMALL_ANGLE > this._tolerance)\r\n      this._tolerance = Constants.SMALL_ANGLE;\r\n  }\r\n\r\n  private displayAlignments(graphic: GraphicBuilder, vp: Viewport): void {\r\n    const bgColor = vp.view.backgroundColor;\r\n    const colorIndex = this._indexColor.adjustForContrast(bgColor, 130);\r\n    const origin = new Point3d(); // Compass origin is adjusted by active z-lock...\r\n    // For non-zero Z value draw indicator line from plane point to compass origin...\r\n    if (this.getCompassPlanePoint(origin, vp)) {\r\n      const colorZ = this._frameColor.adjustForContrast(bgColor, 155);\r\n      graphic.setSymbology(colorZ, colorZ, 2);\r\n      graphic.addLineString([origin, this.origin]);\r\n      graphic.setSymbology(colorZ, colorZ, 4);\r\n      graphic.addPointString([this.origin]);\r\n    }\r\n\r\n    // Get snap point from AccuSnap/Tentative or use raw point...\r\n    let distance = 0.0;\r\n    let snapPt = this._rawPoint;\r\n\r\n    const snap = TentativeOrAccuSnap.getCurrentSnap();\r\n    if (snap) {\r\n      snapPt = snap.snapPoint;\r\n      distance = this.point.distance(snapPt);\r\n    }\r\n\r\n    const isRectMode = (CompassMode.Rectangular === this.compassMode);\r\n    const offsetSnap = ((TentativeOrAccuSnap.isHot || IModelApp.tentativePoint.isActive) && ((this.locked) || (distance > 0.0)));\r\n\r\n    // XY Offset:\r\n    if (offsetSnap) {\r\n      if (isRectMode) {\r\n        const vec = this.point.vectorTo(this._rawPointOnPlane);\r\n        const xOffset = vec.dotProduct(this.axes.x);\r\n        const yOffset = vec.dotProduct(this.axes.y);\r\n        const xIsOffset = (Math.abs(xOffset) > 1.0);\r\n        const yIsOffset = (Math.abs(yOffset) > 1.0);\r\n\r\n        if (xIsOffset) {\r\n          if (yIsOffset) {  /* both */\r\n            const pts: Point3d[] = [\r\n              this.point,\r\n              this.point.plusScaled(this.axes.y, yOffset),\r\n              this._rawPointOnPlane,\r\n              this.point.plusScaled(this.axes.x, xOffset)];\r\n            pts[4] = pts[0];\r\n            graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\r\n            graphic.addLineString(pts);\r\n          } else {  /* just X */\r\n            graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\r\n            graphic.addLineString([this.point, this._rawPointOnPlane]);\r\n          }\r\n        } else if (yIsOffset) {  /* just Y */\r\n          graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\r\n          graphic.addLineString([this.point, this._rawPointOnPlane]);\r\n        }\r\n      }\r\n    }\r\n\r\n    const isOnCompassPlane = (!vp.view.is3d() || this.flags.pointIsOnPlane || this.isZLocked(vp));\r\n\r\n    // Z Offset:\r\n    if (offsetSnap) {\r\n      if (isOnCompassPlane) {\r\n        if (isRectMode) {\r\n          const zOffset = snapPt.distance(this._rawPointOnPlane);\r\n          if (zOffset > Constants.SMALL_ANGLE || zOffset < -Constants.SMALL_ANGLE) {\r\n            graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\r\n            graphic.addLineString([this._rawPointOnPlane, this._rawPoint]);\r\n          }\r\n        } else {\r\n          graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\r\n          graphic.addLineString([this.point, this._rawPoint]);\r\n        }\r\n      }\r\n    }\r\n\r\n    // Fat Point:\r\n    if (offsetSnap) {\r\n      graphic.setSymbology(colorIndex, colorIndex, 8);\r\n      graphic.addPointString([this.point]);\r\n    }\r\n\r\n    let axisIsIndexed = false;\r\n\r\n    // Axis Indexing:\r\n    if (isRectMode) {\r\n      if ((this.indexed & LockedStates.XY_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))\r\n        axisIsIndexed = true;\r\n    } else {\r\n      if ((this.indexed & LockedStates.ANGLE_BM || this.locked & LockedStates.ANGLE_BM) && (this.flags.pointIsOnPlane || this._fieldLocked[ItemField.Z_Item]))\r\n        axisIsIndexed = true;\r\n    }\r\n\r\n    if (axisIsIndexed) {\r\n      graphic.setSymbology(colorIndex, colorIndex, 4);\r\n      graphic.addLineString([this.point, this.planePt]);\r\n    }\r\n\r\n    // Distance Indexing:\r\n    if (this.indexed & LockedStates.DIST_BM) {\r\n      const len = this._tolerance; // Show tick mark based on _GetIndexToleranceInches for length...\r\n      let vec: Vector3d;\r\n\r\n      if (isRectMode) {\r\n        let index = this.indexed & LockedStates.XY_BM;\r\n\r\n        if (!index)\r\n          index = this.locked & LockedStates.XY_BM;\r\n\r\n        vec = (index === LockedStates.X_BM) ? this.axes.x : this.axes.y;\r\n      } else {\r\n        const deltaVec = this.origin.vectorTo(this.point);\r\n        vec = this.axes.z.crossProduct(deltaVec);\r\n        vec.normalizeInPlace();\r\n      }\r\n\r\n      graphic.setSymbology(colorIndex, colorIndex, 3);\r\n      graphic.addLineString([this.point.plusScaled(vec, len), this.point.plusScaled(vec, -len)]);\r\n    }\r\n\r\n    // XY Lock:\r\n    if (isRectMode && !axisIsIndexed) {\r\n      const locked = this.locked & LockedStates.XY_BM;\r\n\r\n      if ((0 !== locked) && isOnCompassPlane) {\r\n        const pts: Point3d[] = [this.point, this.point, this.point];\r\n\r\n        if (locked & LockedStates.X_BM)\r\n          pts[2].setFrom(this.planePt.plusScaled(this.axes.x, this.delta.x));\r\n\r\n        if (locked & LockedStates.Y_BM)\r\n          pts[0].setFrom(this.planePt.plusScaled(this.axes.y, this.delta.y));\r\n\r\n        switch (locked) {\r\n          case LockedStates.X_BM:\r\n            graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\r\n            graphic.addLineString([pts[1], pts[2]]);\r\n            break;\r\n\r\n          case LockedStates.Y_BM:\r\n            graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\r\n            graphic.addLineString([pts[0], pts[1]]);\r\n            break;\r\n\r\n          case LockedStates.XY_BM:\r\n            graphic.setSymbology(colorIndex, colorIndex, 2, LinePixels.Code5);\r\n            graphic.addLineString(pts);\r\n            break;\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public testDecorationHit(id: string): boolean { return id === this._acsPickId; }\r\n  /** @internal */\r\n  public getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined {\r\n    if (!hit.viewport.viewFlags.acsTriad)\r\n      return undefined;\r\n    const geomData = GeomJson.Writer.toIModelJson(PointString3d.create(hit.viewport.view.auxiliaryCoordinateSystem.getOrigin()));\r\n    if (undefined === geomData)\r\n      return undefined;\r\n    const acsGeom: GeometryStreamProps = [geomData];\r\n    return acsGeom;\r\n  }\r\n\r\n  /** @internal */\r\n  public decorate(context: DecorateContext) {\r\n    if (context.viewport.viewFlags.acsTriad) {\r\n      context.viewport.view.auxiliaryCoordinateSystem.display(context, (ACSDisplayOptions.CheckVisible | ACSDisplayOptions.Active));\r\n      if (undefined === this._acsPickId)\r\n        this._acsPickId = context.viewport.iModel.transientIds.next;\r\n      const acsPickBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, this._acsPickId);\r\n      const color = ColorDef.blue.adjustForContrast(context.viewport.view.backgroundColor, 50);\r\n      acsPickBuilder.setSymbology(color, color, 6);\r\n      acsPickBuilder.addPointString([context.viewport.view.auxiliaryCoordinateSystem.getOrigin()]);\r\n      context.addDecorationFromBuilder(acsPickBuilder);\r\n    }\r\n\r\n    // Make sure this is cleared even if we do nothing...redraw might have been to make compass go away...\r\n    this.flags.redrawCompass = false;\r\n\r\n    // Check that AccuDraw is enabled...\r\n    if (!this.isActive)\r\n      return;\r\n\r\n    const vp = context.viewport!;\r\n    if (this.currentView !== vp) // Do nothing if AccuDraw is not enabled for this view...\r\n      return;\r\n\r\n    this.setIndexingTolerance(vp);\r\n\r\n    // Display indexing lines, distance locks, etc. without compass transform...\r\n    let builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\r\n    this.displayAlignments(builder, vp);\r\n    context.addDecorationFromBuilder(builder);\r\n\r\n    // Create a new graphics with the compass transform and scale so that compass size is 1.0...\r\n    builder = context.createGraphicBuilder(GraphicType.WorldOverlay, this.getDisplayTransform(vp));\r\n\r\n    const hasFocus = this.hasInputFocus;\r\n    const bgColor = vp.view.backgroundColor;\r\n    const frameColor = (hasFocus ? this._frameColor : this._frameColorNoFocus).adjustForContrast(bgColor, 155);\r\n    const fillColor = (hasFocus ? this._fillColor : this._fillColorNoFocus).adjustForContrast(bgColor, 75);\r\n    const xColor = (hasFocus ? this._xColor : this._frameColorNoFocus).adjustForContrast(bgColor, 155);\r\n    const yColor = (hasFocus ? this._yColor : this._frameColorNoFocus).adjustForContrast(bgColor, 155);\r\n    const shadowColor = frameColor;\r\n\r\n    // Display compass frame...\r\n    builder.setSymbology(shadowColor, fillColor, 1);\r\n    const center = Point3d.createZero();\r\n\r\n    if (this.flags.animateRotation || 0.0 === this._percentChanged) {\r\n      if (CompassMode.Polar === this.compassMode) {\r\n        const ellipse = Arc3d.createXYEllipse(center, 1, 1);\r\n        builder.addArc(ellipse, true, true);\r\n        builder.addArc(ellipse, false, false);\r\n      } else {\r\n        const pts: Point3d[] = [\r\n          new Point3d(-1.0, 1.0, 0.0),\r\n          new Point3d(1.0, 1.0, 0.0),\r\n          new Point3d(1.0, -1.0, 0.0),\r\n          new Point3d(-1.0, -1.0, 0.0)];\r\n        pts[4] = pts[0].clone();\r\n        builder.addShape(pts);\r\n        builder.addLineString(pts);\r\n      }\r\n    } else {\r\n      let nSides, radius;\r\n      const minSides = 7, maxSides = 24, factor = 1.0 / 5.0;\r\n\r\n      // if currently animating change to polar need to get larger radius...go between 1.0 && 1.0 * sqrt (2.0)\r\n      if (CompassMode.Polar === this.compassMode) {\r\n        nSides = minSides + Math.floor(maxSides * this._percentChanged);\r\n        radius = 1.0 + factor - (factor * this._percentChanged);\r\n      } else {\r\n        nSides = (maxSides - Math.floor(maxSides * this._percentChanged)) + minSides;\r\n        radius = 1.0 + (factor * this._percentChanged);\r\n      }\r\n\r\n      let angle = 0.0; const delta = (Math.PI * 2) / nSides;\r\n      const pts: Point3d[] = [];\r\n\r\n      for (let iSide = 0; iSide < nSides; iSide++ , angle += delta)\r\n        pts[iSide] = new Point3d(radius * Math.cos(angle), radius * Math.sin(angle), 0.0);\r\n      pts[nSides] = pts[0].clone();\r\n\r\n      builder.addShape(pts);\r\n      builder.addLineString(pts);\r\n    }\r\n\r\n    // Display sticky z-lock indicator as frame inset...\r\n    if (this._fieldLocked[ItemField.Z_Item] && this.stickyZLock && vp.view.is3d()) {\r\n      builder.setSymbology(frameColor, fillColor, 1);\r\n\r\n      if (CompassMode.Polar === this.compassMode) {\r\n        const ellipse = Arc3d.createXYEllipse(center, .5, .5);\r\n        builder.addArc(ellipse, false, false);\r\n      } else {\r\n        const pts: Point3d[] = [\r\n          new Point3d(-0.5, 0.5, 0.0),\r\n          new Point3d(0.5, 0.5, 0.0),\r\n          new Point3d(0.5, -0.5, 0.0),\r\n          new Point3d(-0.5, -0.5, 0.0)];\r\n        pts[4] = pts[0].clone();\r\n        builder.addLineString(pts);\r\n      }\r\n    }\r\n\r\n    // Display compass center mark...\r\n    builder.setSymbology(frameColor, frameColor, 8);\r\n    builder.addPointString([center]);\r\n\r\n    // Display positive \"X\" tick...\r\n    builder.setSymbology(xColor, xColor, 4);\r\n    builder.addLineString([new Point3d(1.2, 0.0, 0.0), new Point3d(0.8, 0.0, 0.0)]);\r\n\r\n    // Display negative \"X\" tick...\r\n    builder.setSymbology(frameColor, frameColor, 1);\r\n    builder.addLineString([new Point3d(-1.2, 0.0, 0.0), new Point3d(-0.8, 0.0, 0.0)]);\r\n\r\n    // Display positive \"Y\" tick...\r\n    builder.setSymbology(yColor, yColor, 4);\r\n    builder.addLineString([new Point3d(0.0, 1.2, 0.0), new Point3d(0.0, 0.8, 0.0)]);\r\n\r\n    // Display negative \"Y\" tick...\r\n    builder.setSymbology(frameColor, frameColor, 1);\r\n    builder.addLineString([new Point3d(0.0, -1.2, 0.0), new Point3d(0.0, -0.8, 0.0)]);\r\n\r\n    context.addDecorationFromBuilder(builder); // add compass as world overlay decorator\r\n  }\r\n\r\n  private checkRotation(): void {\r\n    this.updateRotation();\r\n\r\n    if (RotationMode.View === this.rotationMode || !this.flags.lockedRotation)\r\n      return;\r\n\r\n    const vp = this.currentView;\r\n    if (!vp || vp.isCameraOn)\r\n      return;\r\n\r\n    const viewZRoot = vp.rotation.getRow(2);\r\n    if (!this.axes.z.isPerpendicularTo(viewZRoot))\r\n      return;\r\n\r\n    const preferY = (Math.abs(this.axes.x.dotProduct(viewZRoot)) < Math.abs(this.axes.y.dotProduct(viewZRoot)));\r\n\r\n    // NOTE: Cycle rotation to get one that isn't edge-on...\r\n    switch (this.rotationMode) {\r\n      case RotationMode.Top:\r\n        this.setRotationMode(preferY ? RotationMode.Front : RotationMode.Side);\r\n        break;\r\n      case RotationMode.Front:\r\n        this.setRotationMode(preferY ? RotationMode.Top : RotationMode.Side);\r\n        break;\r\n      case RotationMode.Side:\r\n        this.setRotationMode(preferY ? RotationMode.Top : RotationMode.Front);\r\n        break;\r\n      case RotationMode.ACS:\r\n        switch (this.flags.auxRotationPlane) {\r\n          case RotationMode.Top:\r\n            this.flags.auxRotationPlane = preferY ? RotationMode.Front : RotationMode.Side;\r\n            break;\r\n          case RotationMode.Front:\r\n            this.flags.auxRotationPlane = preferY ? RotationMode.Top : RotationMode.Side;\r\n            break;\r\n          case RotationMode.Side:\r\n            this.flags.auxRotationPlane = preferY ? RotationMode.Top : RotationMode.Front;\r\n            break;\r\n          default:\r\n            return;\r\n        }\r\n        break;\r\n      default:\r\n        return;\r\n    }\r\n\r\n    this.updateRotation();\r\n    this.flags.baseRotation = this.rotationMode;\r\n  }\r\n\r\n  private saveLockedCoords(): void {\r\n    if (CompassMode.Polar === this.compassMode) {\r\n      if (this._fieldLocked[ItemField.DIST_Item])\r\n        this.saveCoordinate(ItemField.DIST_Item, this._distance);\r\n      if (this._fieldLocked[ItemField.ANGLE_Item])\r\n        this.saveCoordinate(ItemField.ANGLE_Item, this._angle);\r\n    } else {\r\n      if (this._fieldLocked[ItemField.X_Item])\r\n        this.saveCoordinate(ItemField.X_Item, this.delta.x);\r\n      if (this._fieldLocked[ItemField.Y_Item])\r\n        this.saveCoordinate(ItemField.Y_Item, this.delta.y);\r\n    }\r\n\r\n    const vp = this.currentView;\r\n    if (vp && vp.view.is3d()) {\r\n      if (this._fieldLocked[ItemField.Z_Item])\r\n        this.saveCoordinate(ItemField.Z_Item, this.delta.z);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public onCompassModeChange(): void { }\r\n  /** @internal */\r\n  public onRotationModeChange(): void { }\r\n  /** @internal */\r\n  public onFieldLockChange(_index: ItemField) { }\r\n  /** @internal */\r\n  public onFieldValueChange(_index: ItemField) { }\r\n  /** @internal */\r\n  public get hasInputFocus() { return true; }\r\n  /** @internal */\r\n  public setFocusItem(_index: ItemField) { }\r\n\r\n  private static getMinPolarMag(origin: Point3d): number {\r\n    return (1.0e-12 * (1.0 + origin.magnitude()));\r\n  }\r\n\r\n  /** projects cursor onto plane in view, or returns an error */\r\n  private constructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, perpendicular: boolean): BentleyStatus {\r\n    let fromPtP: Point3d;\r\n    let dotProduct: number;\r\n    let distance: number;\r\n    let projectionVector = new Vector3d();\r\n\r\n    if (perpendicular) {\r\n      if (AccuDraw.useACSContextRotation(vp, true)) { // Project along ACS axis to AccuDraw plane...\r\n        const rMatrix = vp.getAuxCoordRotation(AccuDraw._tempRot);\r\n        const axes = ThreeAxes.createFromMatrix3d(rMatrix);\r\n        this.accountForAuxRotationPlane(axes, this.flags.auxRotationPlane);\r\n        linePlaneIntersect(outPtP, inPtP, axes.z, pointOnPlaneP, normalVectorP, false);\r\n      } else {\r\n        projectionVector = inPtP.vectorTo(pointOnPlaneP);\r\n        distance = projectionVector.dotProduct(normalVectorP);\r\n        inPtP.plusScaled(normalVectorP, distance, outPtP);\r\n      }\r\n    } else {\r\n      const isCamera = vp.isCameraOn;\r\n      if (vp.view.is3d() && isCamera) {\r\n        const cameraPos = vp.view.getEyePoint();\r\n        fromPtP = cameraPos;\r\n        fromPtP.vectorTo(inPtP, projectionVector).normalizeInPlace();\r\n      } else {\r\n        const rMatrix = vp.rotation;\r\n        fromPtP = inPtP;\r\n        rMatrix.getRow(2, projectionVector);\r\n      }\r\n\r\n      dotProduct = projectionVector.dotProduct(normalVectorP);\r\n\r\n      if (Math.abs(dotProduct) < Constants.SMALL_DELTA)\r\n        return BentleyStatus.ERROR; // PARALLEL;\r\n\r\n      distance = (normalVectorP.dotProduct(pointOnPlaneP) - normalVectorP.dotProduct(fromPtP)) / dotProduct;\r\n\r\n      if (isCamera && distance < Constants.SMALL_DELTA)\r\n        return BentleyStatus.ERROR; // BEHIND_EYE_POINT;\r\n\r\n      fromPtP.plusScaled(projectionVector, distance, outPtP);\r\n    }\r\n\r\n    return BentleyStatus.SUCCESS;\r\n  }\r\n\r\n  /** @internal */\r\n  public softConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean {\r\n    if (!vp.isPointAdjustmentRequired) {\r\n      outPtP.setFrom(inPtP);\r\n      return true;\r\n    }\r\n\r\n    if (isSnap) {\r\n      outPtP.setFrom(inPtP);\r\n      const delta = pointOnPlaneP.vectorTo(outPtP);\r\n      return (Math.abs(normalVectorP.dotProduct(delta)) < Constants.SMALL_DELTA);\r\n    }\r\n    if (BentleyStatus.SUCCESS !== this.constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, false)) {\r\n      const viewNormal = vp.rotation.getRow(2);\r\n      this.constructionPlane(outPtP, inPtP, pointOnPlaneP, viewNormal, vp, false);\r\n      this.constructionPlane(outPtP, outPtP, pointOnPlaneP, normalVectorP, vp, true);\r\n      return false;\r\n    }\r\n    return true;\r\n  }\r\n\r\n  /** @internal */\r\n  public hardConstructionPlane(outPtP: Point3d, inPtP: Point3d, pointOnPlaneP: Point3d, normalVectorP: Vector3d, vp: Viewport, isSnap: boolean): boolean {\r\n    if (!vp.isPointAdjustmentRequired) {\r\n      outPtP.setFrom(inPtP);\r\n      return true;\r\n    }\r\n\r\n    if (BentleyStatus.SUCCESS !== this.constructionPlane(outPtP, inPtP, pointOnPlaneP, normalVectorP, vp, isSnap)) {\r\n      const viewNormal = vp.rotation.getRow(2);\r\n      this.constructionPlane(outPtP, inPtP, pointOnPlaneP, viewNormal, vp, false);\r\n      this.constructionPlane(outPtP, outPtP, pointOnPlaneP, normalVectorP, vp, true);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  private static allowAxisIndexing(pointIsOnPlane: boolean): boolean {\r\n    // NOTE: Normally we don't want indexing overriding a hot snap location. The\r\n    //       exception to this is nearest snap. If the nearest snap is in the plane\r\n    //       of the AccuDraw compass, it is confusing not having axis indexing.\r\n    if (!TentativeOrAccuSnap.isHot)\r\n      return true;\r\n\r\n    if (!pointIsOnPlane)\r\n      return false;\r\n\r\n    const snapDetail = IModelApp.accuSnap.getCurrSnapDetail();\r\n    return (undefined !== snapDetail && (SnapMode.Nearest === snapDetail.snapMode));\r\n  }\r\n\r\n  private applyDistanceRoundOff(distance: number, vp: Viewport): number | undefined {\r\n    if (!this._distanceRoundOff.active || !this._distanceRoundOff.units.size)\r\n      return undefined;\r\n\r\n    let roundValue = this._distanceRoundOff.units.values().next().value;\r\n\r\n    if (this._distanceRoundOff.units.size > 1) {\r\n      // NOTE: Set isn't ordered, find smallest entry...\r\n      this._distanceRoundOff.units.forEach((thisRoundValue) => {\r\n        if (thisRoundValue < roundValue)\r\n          roundValue = thisRoundValue;\r\n      });\r\n\r\n      if (vp.viewDelta.magnitudeXY() < roundValue)\r\n        return undefined; // Smallest rounding value is larger than view...don't use...\r\n\r\n      const smallScreenDist = 0.0787402; // ~2 mm...\r\n      const pixelSize = vp.getPixelSizeAtPoint(this.origin);\r\n      const screenDist = vp.pixelsFromInches(smallScreenDist) * pixelSize;\r\n\r\n      this._distanceRoundOff.units.forEach((thisRoundValue) => {\r\n        if (thisRoundValue > roundValue && thisRoundValue < screenDist)\r\n          roundValue = thisRoundValue;\r\n      });\r\n    }\r\n\r\n    if (roundValue <= 0.0)\r\n      return undefined;\r\n\r\n    return roundValue * Math.floor((distance / roundValue) + 0.5);\r\n  }\r\n\r\n  private applyAngleRoundOff(angle: number, distance: number, vp: Viewport): number | undefined {\r\n    if (!this._angleRoundOff.active || !this._angleRoundOff.units.size)\r\n      return undefined;\r\n\r\n    let roundValue = this._angleRoundOff.units.values().next().value;\r\n\r\n    if (this._angleRoundOff.units.size > 1) {\r\n      // NOTE: Set isn't ordered, find smallest entry...\r\n      this._angleRoundOff.units.forEach((thisRoundValue) => {\r\n        if (thisRoundValue < roundValue)\r\n          roundValue = thisRoundValue;\r\n      });\r\n\r\n      const circumference = 2.0 * Math.PI * distance;\r\n      const roundDist = circumference / ((2.0 * Math.PI) / roundValue);\r\n\r\n      if (vp.viewDelta.magnitudeXY() < roundDist)\r\n        return undefined; // Smallest rounding value is larger than view...don't use...\r\n\r\n      const smallScreenDist = 0.0787402; // ~2 mm...\r\n      const pixelSize = vp.getPixelSizeAtPoint(this.origin);\r\n      const screenDist = vp.pixelsFromInches(smallScreenDist) * pixelSize;\r\n\r\n      this._angleRoundOff.units.forEach((thisRoundValue) => {\r\n        const thisRoundDist = circumference / ((2.0 * Math.PI) / thisRoundValue);\r\n        if (thisRoundValue > roundValue && thisRoundDist < screenDist)\r\n          roundValue = thisRoundValue;\r\n      });\r\n    }\r\n\r\n    if (roundValue <= 0.0)\r\n      return undefined;\r\n\r\n    return roundValue * Math.floor((angle / roundValue) + 0.5);\r\n  }\r\n\r\n  /** @internal */\r\n  public fixPointPolar(vp: Viewport): void {\r\n    let angleChanged = false;\r\n    let distChanged = false;\r\n    const zLocked = this.isZLocked(vp);\r\n    const xyCorrection = new Point3d();\r\n\r\n    this.planePt.setFrom(this.origin);\r\n\r\n    if (zLocked && !(this.delta.z < Constants.SMALL_ANGLE && this.delta.z > -Constants.SMALL_ANGLE))\r\n      this.planePt.addScaledInPlace(this.axes.z, this.delta.z);\r\n\r\n    if (this.locked & LockedStates.VEC_BM) {\r\n      if (!TentativeOrAccuSnap.isHot) {\r\n        const normVec = new Vector3d();\r\n        this.planeByVectorAndView(normVec, this.vector, vp);\r\n        this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, normVec, vp, false);\r\n      } else {\r\n        this._rawPointOnPlane.setFrom(this._rawPoint);\r\n        this.flags.pointIsOnPlane = false;\r\n      }\r\n    } else {\r\n      if (zLocked) {\r\n        this.hardConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, TentativeOrAccuSnap.isHot);\r\n        this.flags.pointIsOnPlane = true;\r\n      } else {\r\n        this.flags.pointIsOnPlane = (this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, TentativeOrAccuSnap.isHot) || !!(this.locked & LockedStates.XY_BM));\r\n      }\r\n    }\r\n\r\n    let delta: Vector3d;\r\n    if (zLocked)\r\n      delta = this.planePt.vectorTo(this._rawPointOnPlane);\r\n    else\r\n      delta = this.origin.vectorTo(this._rawPointOnPlane);\r\n\r\n    const minPolarMag = AccuDraw.getMinPolarMag(this.origin);\r\n\r\n    let mag: number;\r\n    if (this.locked & LockedStates.VEC_BM) {\r\n      mag = delta.dotProduct(this.vector);\r\n      xyCorrection.x -= delta.x - mag * this.vector.x;\r\n      xyCorrection.y -= delta.y - mag * this.vector.y;\r\n      xyCorrection.z -= delta.z - mag * this.vector.z;\r\n      this.vector.scale(mag, delta);\r\n      if (mag < 0.0)\r\n        mag = -mag;\r\n      if (mag < minPolarMag) {\r\n        this.handleDegeneratePolarCase();\r\n        return;\r\n      }\r\n\r\n      this.flags.pointIsOnPlane = (Math.abs(this.axes.z.dotProduct(delta)) < Constants.SMALL_DELTA);\r\n    } else {\r\n      mag = delta.magnitude();\r\n      if (mag < minPolarMag) {\r\n        this.handleDegeneratePolarCase();\r\n        return;\r\n      }\r\n    }\r\n\r\n    const newPt = this._rawPointOnPlane.plus(xyCorrection);\r\n    xyCorrection.setZero();\r\n\r\n    // measure angle\r\n    const rotVec = new Point3d();\r\n    rotVec.x = this.axes.x.dotProduct(delta);\r\n\r\n    // NOTE: Always return angle relative to compass plane...used to return \"angle out of plane\" for points off plane.\r\n    rotVec.y = this.axes.y.dotProduct(delta);\r\n    this._angle = Math.atan2(rotVec.y, rotVec.x);\r\n\r\n    // constrain angle\r\n    if (this.flags.pointIsOnPlane && !(this.locked & LockedStates.VEC_BM)) {\r\n      if (!TentativeOrAccuSnap.isHot) {\r\n        const newAngle = this.applyAngleRoundOff(this._angle, mag, vp);\r\n        if (undefined !== newAngle) {\r\n          angleChanged = true;\r\n          this._angle = newAngle;\r\n          xyCorrection.x += Math.cos(this._angle) * mag - rotVec.x;\r\n          xyCorrection.y += Math.sin(this._angle) * mag - rotVec.y;\r\n          rotVec.x = Math.cos(this._angle) * mag;\r\n          rotVec.y = Math.sin(this._angle) * mag;\r\n        }\r\n      }\r\n\r\n      if (this.locked & LockedStates.X_BM || (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane) && (rotVec.x < this._tolerance && rotVec.x > - this._tolerance) && !this.flags.indexLocked && this.axisIndexing)) {\r\n        this.indexed |= LockedStates.X_BM; // indexed in X\r\n\r\n        xyCorrection.x -= rotVec.x;\r\n        rotVec.x = 0.0;\r\n\r\n        if (TentativeOrAccuSnap.isHot)\r\n          xyCorrection.z -= delta.dotProduct(this.axes.z);\r\n\r\n        this._angle = (rotVec.y < 0.0) ? -Math.PI / 2.0 : Math.PI / 2.0;\r\n        angleChanged = true;\r\n      }\r\n\r\n      if (this.locked & LockedStates.Y_BM || (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane) && (rotVec.y < this._tolerance && rotVec.y > -this._tolerance) && !this.flags.indexLocked && this.axisIndexing)) {\r\n        if (this.indexed & LockedStates.X_BM) { // both indexed\r\n          this.handleDegeneratePolarCase();\r\n          return;\r\n        }\r\n\r\n        this.indexed |= LockedStates.Y_BM; // indexed in Y\r\n        xyCorrection.y -= rotVec.y;\r\n\r\n        if (TentativeOrAccuSnap.isHot)\r\n          xyCorrection.z -= delta.dotProduct(this.axes.z);\r\n\r\n        rotVec.y = 0.0;\r\n        this._angle = (rotVec.x < 0.0) ? Math.PI : 0.0;\r\n        angleChanged = true;\r\n      }\r\n\r\n      if (angleChanged) {\r\n        this.axes.x.scale(rotVec.x, delta);\r\n        delta.addScaledInPlace(this.axes.y, rotVec.y);\r\n        mag = delta.magnitude();\r\n        if (mag < minPolarMag) {\r\n          this.handleDegeneratePolarCase();\r\n          return;\r\n        }\r\n      }\r\n    }\r\n\r\n    // constrain distance\r\n    const oldMag = mag;\r\n\r\n    if (this.locked & LockedStates.DIST_BM) { // distance locked\r\n      mag = this._distance;\r\n      distChanged = true;\r\n      this.indexed &= ~LockedStates.DIST_BM;\r\n    } else if (!TentativeOrAccuSnap.isHot) { // if non-snap, try rounding and aligning\r\n      const newDist = this.applyDistanceRoundOff(mag, vp);\r\n      if (undefined !== newDist) {\r\n        distChanged = true;\r\n        mag = newDist;\r\n      }\r\n\r\n      if (Geometry.isDistanceWithinTol(mag - this._lastDistance, this._tolerance) && !this.flags.indexLocked && this.distanceIndexing) {\r\n        this.indexed |= LockedStates.DIST_BM; // distance indexed\r\n        mag = this._lastDistance;\r\n        distChanged = true;\r\n      }\r\n    }\r\n\r\n    // project to corrected point\r\n    newPt.plus3Scaled(this.axes.x, xyCorrection.x, this.axes.y, xyCorrection.y, this.axes.z, xyCorrection.z, newPt);\r\n\r\n    // display index highlight even if snapped\r\n    if (TentativeOrAccuSnap.isHot && this.flags.pointIsOnPlane) {\r\n      if (Math.abs(rotVec.x) < Constants.SMALL_ANGLE)\r\n        this.indexed |= LockedStates.X_BM;\r\n      else if (Math.abs(rotVec.y) < Constants.SMALL_ANGLE)\r\n        this.indexed |= LockedStates.Y_BM;\r\n    }\r\n\r\n    if (distChanged) {\r\n      if (mag < minPolarMag && mag > -minPolarMag) {\r\n        this.handleDegeneratePolarCase();\r\n        return;\r\n      }\r\n\r\n      // adjust corrected point for distance indexing\r\n      newPt.addScaledInPlace(delta, mag / oldMag - 1.0);\r\n      delta.scaleInPlace(mag / oldMag);\r\n    }\r\n\r\n    // save corrected point\r\n    this.point.setFrom(newPt);\r\n\r\n    // finish up\r\n    this._distance = mag;\r\n\r\n    if (!(this.locked & LockedStates.VEC_BM))\r\n      delta.scale(1.0 / mag, this.vector);\r\n\r\n    if (this.locked & LockedStates.XY_BM)\r\n      this.indexed |= this.locked;\r\n\r\n    if (!zLocked)\r\n      this.delta.z = (this.flags.pointIsOnPlane) ? 0.0 : delta.dotProduct(this.axes.z);\r\n  }\r\n\r\n  /** @internal */\r\n  public fixPointRectangular(vp: Viewport): void {\r\n    const zLocked = this.isZLocked(vp);\r\n    const xyCorrection = new Vector3d();\r\n\r\n    this.planePt.setFrom(this.origin);\r\n    this.indexed = 0;\r\n\r\n    if (zLocked) {\r\n      this.flags.pointIsOnPlane = (this.delta.z < Constants.SMALL_ANGLE && this.delta.z > -Constants.SMALL_ANGLE);\r\n      if (!this.flags.pointIsOnPlane)\r\n        this.planePt.addScaledInPlace(this.axes.z, this.delta.z);\r\n      this.hardConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.planePt, this.axes.z, vp, TentativeOrAccuSnap.isHot);\r\n    } else {\r\n      this.flags.pointIsOnPlane = this.softConstructionPlane(this._rawPointOnPlane, this._rawPoint, this.origin, this.axes.z, vp, TentativeOrAccuSnap.isHot);\r\n    }\r\n\r\n    const trueDelta = this.origin.vectorTo(this._rawPointOnPlane);\r\n    this._rawDelta.x = trueDelta.dotProduct(this.axes.x);\r\n    this._xIsNegative = (this._rawDelta.x < -Constants.SMALL_ANGLE);\r\n\r\n    this._rawDelta.y = trueDelta.dotProduct(this.axes.y);\r\n    this._yIsNegative = (this._rawDelta.y < -Constants.SMALL_ANGLE);\r\n\r\n    if (!zLocked)\r\n      this.delta.z = (this.flags.pointIsOnPlane) ? 0.0 : trueDelta.dotProduct(this.axes.z);\r\n\r\n    if (AccuDraw.allowAxisIndexing(this.flags.pointIsOnPlane)) {\r\n      if (!(this.locked & LockedStates.X_BM)) { // not locked in x\r\n        const roundedDeltaX = this.applyDistanceRoundOff(this._rawDelta.x, vp); // round x\r\n        if (undefined !== roundedDeltaX) {\r\n          xyCorrection.x = roundedDeltaX - this._rawDelta.x;\r\n          this._rawDelta.x = roundedDeltaX;\r\n        }\r\n\r\n        if (this._rawDelta.x < this._tolerance && this._rawDelta.x > -this._tolerance &&\r\n          !this.flags.indexLocked && this.axisIndexing) { // index x\r\n          this.indexed |= LockedStates.X_BM; // indexed in X\r\n          xyCorrection.x -= this._rawDelta.x;\r\n          this._rawDelta.x = 0.0;\r\n        }\r\n      }\r\n      if (!(this.locked & LockedStates.Y_BM)) {\r\n        const roundedDeltaY = this.applyDistanceRoundOff(this._rawDelta.y, vp); // round y\r\n        if (undefined !== roundedDeltaY) {\r\n          xyCorrection.y = roundedDeltaY - this._rawDelta.y;\r\n          this._rawDelta.y = roundedDeltaY;\r\n        }\r\n\r\n        if (this._rawDelta.y < this._tolerance && this._rawDelta.y > -this._tolerance &&\r\n          !this.flags.indexLocked && this.axisIndexing) { // index y\r\n          this.indexed |= LockedStates.Y_BM; // indexed in Y\r\n          xyCorrection.y -= this._rawDelta.y;\r\n          this._rawDelta.y = 0.0;\r\n        }\r\n      }\r\n    }\r\n\r\n    if (this.locked & LockedStates.X_BM) {\r\n      if (this.rawDeltaIsValid(this._rawDelta.x)) {\r\n        // cursor changed sides, reverse value\r\n        if ((this.delta.x < -Constants.SMALL_ANGLE) !== this._xIsNegative &&\r\n          this.smartKeyin && this._keyinStatus[ItemField.X_Item] === KeyinStatus.Partial &&\r\n          !this._xIsExplicit)\r\n          this.delta.x = -this.delta.x;\r\n      }\r\n\r\n      xyCorrection.x = this.delta.x - this._rawDelta.x;\r\n    } else {\r\n      const lastDist = (this._rawDelta.x < 0.0) ? (-this._lastDistance) : this._lastDistance;\r\n\r\n      if (!TentativeOrAccuSnap.isHot && ((this.locked & LockedStates.Y_BM) || (this.indexed & LockedStates.Y_BM)) && !(this.indexed & LockedStates.X_BM) &&\r\n        Geometry.isDistanceWithinTol(this._rawDelta.x - lastDist, this._tolerance) &&\r\n        !this.flags.indexLocked && this.distanceIndexing) {\r\n        xyCorrection.x += lastDist - this._rawDelta.x;\r\n        this.delta.x = lastDist;\r\n        this.indexed |= LockedStates.DIST_BM;\r\n      } else {\r\n        this.delta.x = this._rawDelta.x;\r\n      }\r\n    }\r\n\r\n    if (this.locked & LockedStates.Y_BM) {\r\n      if (this.rawDeltaIsValid(this._rawDelta.y)) {\r\n        // cursor changed sides, reverse value\r\n        if ((this.delta.y < -Constants.SMALL_ANGLE) !== this._yIsNegative &&\r\n          this.smartKeyin && this._keyinStatus[ItemField.Y_Item] === KeyinStatus.Partial &&\r\n          !this._yIsExplicit)\r\n          this.delta.y = -this.delta.y;\r\n      }\r\n\r\n      xyCorrection.y = this.delta.y - this._rawDelta.y;\r\n    } else {\r\n      const lastDist = (this._rawDelta.y < Constants.SMALL_ANGLE) ? - this._lastDistance : this._lastDistance;\r\n\r\n      if (!TentativeOrAccuSnap.isHot && ((this.locked & LockedStates.X_BM) || (this.indexed & LockedStates.X_BM)) && !(this.indexed & LockedStates.Y_BM) &&\r\n        Geometry.isDistanceWithinTol(this._rawDelta.y - lastDist, this._tolerance) &&\r\n        !this.flags.indexLocked && this.distanceIndexing) {\r\n        xyCorrection.y += lastDist - this._rawDelta.y;\r\n        this.delta.y = lastDist;\r\n        this.indexed |= LockedStates.DIST_BM;\r\n      } else {\r\n        this.delta.y = this._rawDelta.y;\r\n      }\r\n    }\r\n\r\n    this._rawPointOnPlane.plus2Scaled(this.axes.x, xyCorrection.x, this.axes.y, xyCorrection.y, this.point);\r\n\r\n    if (zLocked && !this.flags.pointIsOnPlane)\r\n      this.hardConstructionPlane(this.point, this.point, this.planePt, this.axes.z, vp, TentativeOrAccuSnap.isHot);\r\n\r\n    if ((this.locked & LockedStates.X_BM && this.delta.x === 0.0) || (this.locked & LockedStates.Y_BM && this.delta.y === 0.0)) {\r\n      this.indexed |= this.locked; // to display index highlight\r\n    } else if (TentativeOrAccuSnap.isHot) {\r\n      if (Math.abs(this.delta.x) < Constants.SMALL_ANGLE)\r\n        this.indexed |= LockedStates.X_BM;\r\n      else if (Math.abs(this.delta.y) < Constants.SMALL_ANGLE)\r\n        this.indexed |= LockedStates.Y_BM;\r\n    }\r\n\r\n    const lock = this.locked & LockedStates.XY_BM;\r\n    const index = this.indexed & LockedStates.XY_BM;\r\n\r\n    if (lock === LockedStates.Y_BM && index !== LockedStates.X_BM) {\r\n      if (this._keyinStatus[ItemField.Y_Item] !== KeyinStatus.Dynamic) {\r\n        if (Math.abs(this._rawDelta.x) < this._threshold)\r\n          return;\r\n      }\r\n\r\n      this.newFocus = ItemField.X_Item;\r\n      this.dontMoveFocus = false;\r\n    } else if (lock === LockedStates.X_BM && index !== LockedStates.Y_BM) {\r\n      if (this._keyinStatus[ItemField.X_Item] !== KeyinStatus.Dynamic) {\r\n        if (Math.abs(this._rawDelta.y) < this._threshold)\r\n          return;\r\n      }\r\n\r\n      this.newFocus = ItemField.Y_Item;\r\n      this.dontMoveFocus = false;\r\n    } else {\r\n      this.newFocus = ((Math.abs(this._rawDelta.x) > Math.abs(this._rawDelta.y)) ? ItemField.X_Item : ItemField.Y_Item);\r\n    }\r\n  }\r\n\r\n  private fixPoint(pointActive: Point3d, vp: ScreenViewport): void {\r\n    if (this.isActive && ((vp !== this.currentView) || this.flags.rotationNeedsUpdate)) {\r\n      this.currentView = vp;\r\n\r\n      if (!(this.locked & LockedStates.ANGLE_BM || this._fieldLocked[ItemField.Z_Item])) {\r\n        // origin not locked down...may change when vie changes...\r\n        if (!this.flags.haveValidOrigin)\r\n          this.setDefaultOrigin(vp);\r\n\r\n        // in a view based rotation, and the view has changed, so update the rotation...\r\n        if (!this.flags.lockedRotation) {\r\n          this.updateRotation();\r\n          this.flags.rotationNeedsUpdate = false;\r\n        }\r\n      }\r\n    }\r\n    if (this.isInactive || this.isDeactivated) {\r\n      this.point.setFrom(pointActive);\r\n      this.currentView = vp;\r\n      this.processHints();\r\n      return;\r\n    }\r\n    if (this.isActive) {\r\n      this._rawPoint.setFrom(pointActive);\r\n      this.currentView = vp;\r\n      this.flags.dialogNeedsUpdate = true;\r\n\r\n      if (TentativeOrAccuSnap.isHot && CompassMode.Polar === this.compassMode)\r\n        this.indexed = this.locked;\r\n      else\r\n        this.indexed = LockedStates.NONE_LOCKED;\r\n\r\n      if (CompassMode.Polar === this.compassMode)\r\n        this.fixPointPolar(vp);\r\n      else\r\n        this.fixPointRectangular(vp);\r\n\r\n      pointActive.setFrom(this.point);\r\n    } else if (CompassMode.Rectangular === this.compassMode) {\r\n      if (this._fieldLocked[ItemField.X_Item])\r\n        pointActive.x = this.delta.x;\r\n\r\n      if (this._fieldLocked[ItemField.Y_Item])\r\n        pointActive.y = this.delta.y;\r\n\r\n      if (this._fieldLocked[ItemField.Z_Item])\r\n        pointActive.z = this.delta.z;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public refreshDecorationsAndDynamics(): void {\r\n    // Immediately process hints and show dynamics using adjusted point when not called from button down...\r\n    if (!this.flags.inDataPoint)\r\n      this.processHints();\r\n\r\n    // Make sure AccuDraw updates its decorations...\r\n    if (undefined !== this.currentView)\r\n      this.currentView.invalidateDecorations();\r\n\r\n    // Make sure active tool updates its dynamics. NOTE: Need point adjusted for new locks, etc.\r\n    IModelApp.toolAdmin.updateDynamics(undefined, undefined, true);\r\n  }\r\n\r\n  /** @internal */\r\n  public upgradeToActiveState(): boolean {\r\n    if (!this.isEnabled)\r\n      return false;\r\n\r\n    this.onEventCommon();\r\n\r\n    if (!this.isInactive)\r\n      return false;\r\n\r\n    const vp = this.currentView;\r\n    if (!vp)\r\n      return false;\r\n\r\n    // NOTE: If ACS Plane lock setup initial and base rotation to ACS...\r\n    if (vp && AccuDraw.useACSContextRotation(vp, false)) {\r\n      this.setRotationMode(RotationMode.ACS);\r\n      this.flags.baseRotation = RotationMode.ACS;\r\n      this.flags.auxRotationPlane = RotationMode.Top;\r\n    }\r\n\r\n    if (this.published.flags & AccuDrawFlags.SmartRotation) {\r\n      const snap = TentativeOrAccuSnap.getCurrentSnap(false);\r\n      if (undefined !== snap) {\r\n        const rotation = AccuDraw.getSnapRotation(snap, vp);\r\n        if (undefined !== rotation) {\r\n          this.setContextRotation(rotation, true, false);\r\n          this.changeBaseRotationMode(RotationMode.Context);\r\n        }\r\n      }\r\n    }\r\n\r\n    this.checkRotation();\r\n\r\n    // Compass will jump to correct location when fixPoint is called...but we don't want to see the jump...\r\n    if (!this.flags.haveValidOrigin)\r\n      this.setDefaultOrigin(vp);\r\n\r\n    // Initialize rawPoint data...invalid for alignments until next fixPoint...\r\n    this._rawPoint.setFrom(this.point);\r\n    this._rawPointOnPlane.setFrom(this.point);\r\n\r\n    // Upgrade state to enabled...want compass to display...\r\n    this.currentState = CurrentState.Active;\r\n\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public downgradeInactiveState(): boolean {\r\n    if (!this.isEnabled)\r\n      return false;\r\n    this.onEventCommon();\r\n    if (!this.isActive)\r\n      return false;\r\n    // Downgrade state back to inactive...\r\n    this.currentState = CurrentState.Inactive;\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public onBeginDynamics(): boolean { return this.upgradeToActiveState(); }\r\n  /** @internal */\r\n  public onEndDynamics(): boolean { return this.downgradeInactiveState(); }\r\n\r\n  /** Implemented by sub-classes to update ui fields to show current deltas or coordinates when inactive.\r\n   * Should also choose active x or y input field in rectangular mode based on cursor position when\r\n   * axis isn't locked to support \"smart lock\".\r\n   * @internal\r\n   */\r\n  public onMotion(_ev: BeButtonEvent): void { }\r\n\r\n  /** @internal */\r\n  public onPreButtonEvent(ev: BeButtonEvent): boolean {\r\n    if (BeButton.Reset === ev.button && !ev.isDown && !ev.isDragging) {\r\n      if (IModelApp.tentativePoint.isActive && this.isActive) {\r\n        IModelApp.tentativePoint.clear(true);\r\n        this.refreshDecorationsAndDynamics();\r\n        return true;\r\n      }\r\n\r\n      if (this.isEnabled)\r\n        this.onEventCommon();\r\n      return false;\r\n    }\r\n\r\n    if (BeButton.Data !== ev.button || !ev.isDown || !this.isEnabled)\r\n      return false;\r\n\r\n    this.onEventCommon();\r\n    this.flags.inDataPoint = true;\r\n    if (this.currentState < CurrentState.Inactive)\r\n      return false;\r\n    if (!this.currentView)\r\n      this.currentView = ev.viewport;\r\n    this.updateRotation();\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public onPostButtonEvent(ev: BeButtonEvent): boolean {\r\n    if (BeButton.Data !== ev.button || !ev.isDown || !this.isEnabled)\r\n      return false;\r\n\r\n    this.onEventCommon();\r\n\r\n    if (this.flags.ignoreDataButton) {\r\n      // NOTE: Ignore this data point, was used to terminate a viewing command or input collector...\r\n      this.flags.ignoreDataButton = false;\r\n    } else if (!this.flags.fixedOrg && this.currentState >= CurrentState.Inactive) {\r\n      /* set origin to last point placed unless its being set elsewhere */\r\n      if (((!this.contextSensitive &&\r\n        !(this.published.flags & (AccuDrawFlags.AlwaysSetOrigin ^ AccuDrawFlags.SetOrigin))) ||\r\n        !(this.published.flags & AccuDrawFlags.SetOrigin))) {\r\n        this.published.flags |= AccuDrawFlags.SetOrigin;\r\n\r\n        if (this.currentState >= CurrentState.Inactive)\r\n          this.published.origin.setFrom(ev.point);\r\n        else\r\n          this.published.origin.setFrom(this.point);\r\n      }\r\n\r\n      this.saveLockedCoords();\r\n      this.processHints();\r\n\r\n      if (this.currentState >= CurrentState.Inactive)\r\n        this.updateRotation();\r\n    }\r\n\r\n    this.flags.inDataPoint = false;\r\n    this.flags.indexLocked = false;\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public onTentative(): boolean {\r\n    if (this.isActive || this.isInactive)\r\n      this.grabInputFocus(); // AccuDraw gets input focus on a tentative\r\n\r\n    return false;\r\n  }\r\n\r\n  private intersectXYCurve(snap: SnapDetail, curve: CurvePrimitive, usePointOnSnap: boolean) {\r\n    if (undefined === this.currentView)\r\n      return;\r\n\r\n    const curveSegment = snap.getCurvePrimitive(); // Get single segment of linestring/shape...\r\n    if (undefined === curveSegment)\r\n      return;\r\n\r\n    const worldToView = this.currentView.worldToViewMap.transform0;\r\n    const detail = CurveCurve.intersectionProjectedXY(worldToView, usePointOnSnap ? curveSegment : curve, true, usePointOnSnap ? curve : curveSegment, true);\r\n    if (0 === detail.dataA.length)\r\n      return;\r\n\r\n    let closeIndex = 0;\r\n    if (detail.dataA.length > 1) {\r\n      const snapPt = worldToView.multiplyPoint3d(snap.getPoint(), 1);\r\n      let lastDist: number | undefined;\r\n\r\n      for (let i = 0; i < detail.dataA.length; i++) {\r\n        const testPt = worldToView.multiplyPoint3d(detail.dataA[i].point, 1);\r\n        const testDist = snapPt.realDistanceXY(testPt);\r\n\r\n        if (undefined !== testDist && (undefined === lastDist || testDist < lastDist)) {\r\n          lastDist = testDist;\r\n          closeIndex = i;\r\n        }\r\n      }\r\n    }\r\n\r\n    snap.setSnapPoint(detail.dataA[closeIndex].point, SnapHeat.NotInRange);\r\n  }\r\n\r\n  private intersectLine(snap: SnapDetail, linePt: Point3d, unitVec: Vector3d) {\r\n    const vec = Vector3d.createStartEnd(linePt, snap.getPoint());\r\n    const endPt = linePt.plusScaled(unitVec, vec.dotProduct(unitVec));\r\n    const cpLine = LineSegment3d.create(linePt, endPt);\r\n    this.intersectXYCurve(snap, cpLine, true); // Get point on snapped curve, not AccuDraw axis. Snap point isn't required to be in AccuDraw plane when Z isn't locked.\r\n  }\r\n\r\n  private intersectCircle(snap: SnapDetail, center: Point3d, normal: Vector3d, radius: number) {\r\n    const matrix = Matrix3d.createRigidHeadsUp(normal);\r\n    const vector0 = matrix.columnX();\r\n    const vector90 = matrix.columnY();\r\n    vector0.scaleToLength(radius, vector0);\r\n    vector90.scaleToLength(radius, vector90);\r\n    const cpArc = Arc3d.create(center, vector0, vector90);\r\n    this.intersectXYCurve(snap, cpArc, false); // Get point on AccuDraw distance circle, not snapped curve. Want to preserve distance constraint with apparent intersection in XY.\r\n  }\r\n\r\n  /** @internal */\r\n  public onSnap(snap: SnapDetail): boolean {\r\n    // If accudraw is locked, adjust near snap point to be the nearest point on this element, CONSTRAINED by the accudraw lock.\r\n    if (!this.isActive || !this.locked)\r\n      return false;\r\n\r\n    if (SnapMode.Nearest !== snap.snapMode)\r\n      return false;\r\n\r\n    if (!snap.primitive)\r\n      return false;\r\n\r\n    switch (this.locked) {\r\n      case LockedStates.VEC_BM: {\r\n        this.intersectLine(snap, this.origin, this.vector);\r\n        break;\r\n      }\r\n\r\n      case LockedStates.X_BM: {\r\n        const refPt = (CompassMode.Rectangular === this.compassMode) ? this.planePt.plusScaled(this.axes.x, this.delta.x) : this.origin;\r\n        this.intersectLine(snap, refPt, this.axes.y);\r\n        break;\r\n      }\r\n\r\n      case LockedStates.Y_BM: {\r\n        const refPt = (CompassMode.Rectangular === this.compassMode) ? this.planePt.plusScaled(this.axes.y, this.delta.y) : this.origin;\r\n        this.intersectLine(snap, refPt, this.axes.x);\r\n        break;\r\n      }\r\n\r\n      case LockedStates.DIST_BM: {\r\n        this.intersectCircle(snap, this.origin, this.axes.z, this._distance);\r\n        break;\r\n      }\r\n    }\r\n\r\n    return false;\r\n  }\r\n\r\n  /** @internal */\r\n  public onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void {\r\n    // In case previous is closing, always update AccuDraw to current view...\r\n    if (undefined !== this.currentView && this.currentView === previous)\r\n      this.currentView = current;\r\n\r\n    // Reset AccuDraw when iModel or view type changes...\r\n    if (undefined !== current && undefined !== previous &&\r\n      (current.view.classFullName === previous.view.classFullName) &&\r\n      (current.view.iModel === previous.view.iModel))\r\n      return;\r\n\r\n    this.currentView = undefined;\r\n    this.flags.redrawCompass = false;\r\n\r\n    this.flags.baseRotation = RotationMode.View;\r\n    this.flags.auxRotationPlane = RotationMode.Top;\r\n    this.flags.rotationNeedsUpdate = true;\r\n\r\n    this.flags.haveValidOrigin = false;\r\n    this.flags.indexLocked = false;\r\n    this.flags.bearingFixToPlane2D = false;\r\n\r\n    this.setRotationMode(RotationMode.View);\r\n    this.updateRotation();\r\n\r\n    this.saveState(this.savedStateViewTool);\r\n    this.saveState(this.savedStateInputCollector);\r\n  }\r\n\r\n  private doProcessHints(): void {\r\n    if (!this.floatingOrigin) {\r\n      if (this.published.flags & AccuDrawFlags.SetOrigin)\r\n        this.unlockAllFields();\r\n      return;\r\n    }\r\n\r\n    // Set Context Origin\r\n    if (this.published.flags & AccuDrawFlags.SetOrigin) {\r\n      if (this.floatingOrigin) {\r\n        this.origin.setFrom(this.published.origin);\r\n        this.point.setFrom(this.origin);\r\n        this.planePt.setFrom(this.origin);\r\n      }\r\n      this.flags.haveValidOrigin = true;\r\n      this.setLastPoint(this.origin);\r\n      this.unlockAllFields();\r\n      this.updateRotation();\r\n    }\r\n\r\n    if (!this.contextSensitive)\r\n      return;\r\n\r\n    // Mode -- Polar or Rectangular\r\n    if (this.published.flags & (AccuDrawFlags.SetModePolar | AccuDrawFlags.SetModeRect)) {\r\n      if (this.compassMode !== ((this.published.flags & AccuDrawFlags.SetModePolar) ? CompassMode.Polar : CompassMode.Rectangular))\r\n        this.changeCompassMode();\r\n    }\r\n\r\n    // Fixed Origin\r\n    if (this.published.flags & AccuDrawFlags.FixedOrigin)\r\n      this.flags.fixedOrg = true;\r\n\r\n    // Save Distance\r\n    if (this.published.flags & (AccuDrawFlags.SetDistance | AccuDrawFlags.LockDistance))\r\n      this.saveCoordinate(ItemField.DIST_Item, this.published.distance);\r\n\r\n    const vp = this.currentView;\r\n    // Do Context Rotation\r\n    if (this.published.flags & AccuDrawFlags.SetRMatrix) {\r\n      this.axes.fromMatrix3d(this.published.rMatrix);\r\n      this.flags.lockedRotation = true;\r\n      this.flags.contextRotMode = ContextMode.Locked;\r\n      this.setRotationMode(RotationMode.Context);\r\n      this.updateRotation();\r\n    } else if (this.published.flags & AccuDrawFlags.SetXAxis) {\r\n      this.axes.x.setFrom(this.published.vector);\r\n      this.flags.contextRotMode = ContextMode.XAxis;\r\n      this.setRotationMode(RotationMode.Context);\r\n      this.updateRotation();\r\n    } else if (this.published.flags & AccuDrawFlags.SetXAxis2) {\r\n      this.axes.x.setFrom(this.published.vector);\r\n      this.flags.contextRotMode = ContextMode.XAxis2;\r\n      this.setRotationMode(RotationMode.Context);\r\n      this.updateRotation();\r\n    } else if (this.published.flags & AccuDrawFlags.SetNormal) {\r\n      if (vp && vp.view.is3d()) {\r\n        this.axes.z.setFrom(this.published.vector);\r\n        this.flags.contextRotMode = ContextMode.ZAxis;\r\n        this.setRotationMode(RotationMode.Context);\r\n        this.updateRotation();\r\n      }\r\n    } else if (this.published.flags & AccuDrawFlags.OrientACS) {\r\n      this.flags.lockedRotation = true;\r\n      this.flags.baseRotation = RotationMode.ACS;\r\n      this.setRotationMode(RotationMode.ACS);\r\n      this.updateRotation();\r\n    } else if (this.isInactive || (this.published.flags & AccuDrawFlags.OrientDefault)) {\r\n      this.setRotationMode(this.flags.baseRotation);\r\n      this.updateRotation();\r\n    }\r\n\r\n    // Lock Items\r\n    switch (this.compassMode) {\r\n      case CompassMode.Polar:\r\n        if (this.published.flags & AccuDrawFlags.LockDistance) {\r\n          this._distance = this.published.distance;\r\n          this.distanceLock(true, true);\r\n        }\r\n\r\n        if (this.published.flags & AccuDrawFlags.LockAngle) {\r\n          this.updateVector(this.published.angle);\r\n          this.indexed = LockedStates.NONE_LOCKED;\r\n          this.angleLock();\r\n          this.saveCoordinate(ItemField.ANGLE_Item, this.published.angle);\r\n        }\r\n        break;\r\n\r\n      case CompassMode.Rectangular:\r\n        if ((this.published.flags & AccuDrawFlags.Lock_X)) {\r\n          this.locked |= LockedStates.X_BM;\r\n          this.delta.x = this.published.delta.x;\r\n          this.setFieldLock(ItemField.X_Item, true);\r\n          this.saveCoordinate(ItemField.X_Item, this.published.delta.x);\r\n        }\r\n\r\n        if ((this.published.flags & AccuDrawFlags.Lock_Y)) {\r\n          this.locked |= LockedStates.Y_BM;\r\n          this.delta.y = this.published.delta.y;\r\n          this.setFieldLock(ItemField.Y_Item, true);\r\n          this.saveCoordinate(ItemField.Y_Item, this.published.delta.y);\r\n        }\r\n\r\n        if ((this.published.flags & AccuDrawFlags.Lock_Z)) {\r\n          if (vp && vp.view.is3d()) {\r\n            this.delta.z = this.published.delta.z;\r\n            this.setFieldLock(ItemField.Z_Item, true);\r\n            this.saveCoordinate(ItemField.Z_Item, this.published.delta.z);\r\n          }\r\n        }\r\n        break;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  public processHints(): void {\r\n    if (!this.published.flags || !this.isEnabled)\r\n      return;\r\n\r\n    if (this.published.flags & AccuDrawFlags.Disable) {\r\n      this.published.flags = 0;\r\n      this.currentState = CurrentState.Deactivated;\r\n      return;\r\n    }\r\n    const setFocus: boolean = !!(this.published.flags & AccuDrawFlags.SetFocus);\r\n    const smartRotation: boolean = !!(this.published.flags & AccuDrawFlags.SmartRotation);\r\n    this.doProcessHints();\r\n    this.published.zero();\r\n    if (smartRotation && this.isInactive) // Preserve smart rotation hint until when/if AccuDraw is enabled for the current tool...\r\n      this.published.flags = AccuDrawFlags.SmartRotation;\r\n    if (this.isEnabled || setFocus)\r\n      this.grabInputFocus();\r\n  }\r\n}\r\n\r\n/** AccuDrawHintBuilder is a Tool helper class that facilitates AccuDraw interaction.\r\n * Accudraw is an aide for entering coordinate data.\r\n * The tool does not directly change the current AccuDraw state; the tool's job is merely\r\n * to supply \"hints\" to AccuDraw regarding its preferred AccuDraw configuration for the\r\n * current tool state. User settings such as \"Context Sensitivity\" and \"Floating Origin\"\r\n * affect how/which hints get applied.\r\n * @see [Using AccuDraw]($docs/learning/frontend/primitivetools.md#AccuDraw)*\r\n * @beta\r\n */\r\nexport class AccuDrawHintBuilder {\r\n  private _flagOrigin = false;\r\n  private _flagNormal = false;\r\n  private _flagRotation = false;\r\n  private _flagXAxis = false;\r\n  private _flagXAxis2 = false;\r\n  private _flagDistance = false;\r\n  private _flagAngle = false;\r\n  private _flagModePolar = false;\r\n  private _flagModeRectangular = false;\r\n  private _origin?: Point3d;\r\n  private _axis?: Vector3d;\r\n  private _rMatrix?: Matrix3d;\r\n  private _distance = 0;\r\n  private _angle = 0;\r\n\r\n  public setOriginFixed = false;\r\n  public setOriginAlways = false;\r\n  public setLockDistance = false;\r\n  public setLockAngle = false;\r\n  public setLockX = false;\r\n  public setLockY = false;\r\n  public setLockZ = false;\r\n  public enableSmartRotation = false;\r\n  public setOrigin(origin: Point3d) { this._origin = origin.clone(); this._flagOrigin = true; }\r\n  public setRotation(rMatrix: Matrix3d) { this._rMatrix = rMatrix.clone(); this._flagRotation = true; this._flagXAxis = this._flagNormal = false; }\r\n  public setXAxis(xAxis: Vector3d) { this._axis = xAxis.clone(); this._flagXAxis = true; this._flagRotation = this._flagNormal = this._flagXAxis2 = false; }\r\n  public setXAxis2(xAxis: Vector3d) { this._axis = xAxis.clone(); this._flagXAxis2 = true; this._flagRotation = this._flagNormal = this._flagXAxis = false; }\r\n  public setNormal(normal: Vector3d) { this._axis = normal.clone(); this._flagNormal = true; this._flagRotation = this._flagXAxis = this._flagXAxis2 = false; }\r\n  public setModePolar() { this._flagModePolar = true; this._flagModeRectangular = false; }\r\n  public setModeRectangular() { this._flagModeRectangular = true; this._flagModePolar = false; }\r\n  public setDistance(distance: number) { this._distance = distance; this._flagDistance = true; }\r\n  public setAngle(angle: number) { this._angle = angle; this._flagAngle = true; }\r\n\r\n  /* Enable AccuDraw for the current tool without sending any hints */\r\n  public static activate() { IModelApp.accuDraw.activate; }\r\n  /* Disable AccuDraw for the current tool */\r\n  public static deactivate() { IModelApp.accuDraw.deactivate; }\r\n\r\n  /**\r\n   * Calls AccuDraw.setContext using the current builder state.\r\n   * @return true if hints were successfully sent.\r\n   */\r\n  public sendHints(activate = true): boolean {\r\n    let flags = 0;\r\n    if (this._flagOrigin) flags |= AccuDrawFlags.SetOrigin;\r\n    if (this.setOriginFixed) flags |= AccuDrawFlags.FixedOrigin;\r\n    if (this.setOriginAlways) flags |= AccuDrawFlags.AlwaysSetOrigin;\r\n    if (this._flagRotation) flags |= AccuDrawFlags.SetRMatrix;\r\n    if (this._flagXAxis) flags |= AccuDrawFlags.SetXAxis;\r\n    if (this._flagXAxis2) flags |= AccuDrawFlags.SetXAxis2;\r\n    if (this._flagNormal) flags |= AccuDrawFlags.SetNormal;\r\n    if (this._flagModePolar) flags |= AccuDrawFlags.SetModePolar;\r\n    if (this._flagModeRectangular) flags |= AccuDrawFlags.SetModeRect;\r\n    if (this.setLockDistance) flags |= AccuDrawFlags.LockDistance;\r\n    if (this.setLockAngle) flags |= AccuDrawFlags.LockAngle;\r\n    if (this.setLockX) flags |= AccuDrawFlags.Lock_X;\r\n    if (this.setLockY) flags |= AccuDrawFlags.Lock_Y;\r\n    if (this.setLockZ) flags |= AccuDrawFlags.Lock_Z;\r\n    if (this.enableSmartRotation) flags |= AccuDrawFlags.SmartRotation;\r\n\r\n    const accuDraw = IModelApp.accuDraw;\r\n    if (BentleyStatus.SUCCESS !== accuDraw.setContext(flags, this._origin, this._flagRotation ? this._rMatrix : this._axis, undefined, this._flagDistance ? this._distance : undefined, this._flagAngle ? this._angle : undefined))\r\n      return false; // Not enabled for this session...\r\n\r\n    if (activate)\r\n      accuDraw.activate(); // If not already enabled (ex. dynamics not started) most/all callers would want to enable it now (optional activate arg provided just in case)...\r\n\r\n    return true;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module LocatingElements */\n\nimport { Point3d, Point2d, XAndY, Vector3d, CurveCurve, IModelJson as GeomJson } from \"@bentley/geometry-core\";\nimport { Viewport, ScreenViewport } from \"./Viewport\";\nimport { BeButtonEvent, BeTouchEvent, BeButton, InputSource } from \"./tools/Tool\";\nimport { SnapStatus, LocateAction, LocateResponse, HitListHolder, ElementLocateManager, LocateFilterStatus } from \"./ElementLocateManager\";\nimport { SpriteLocation, Sprite, IconSprites } from \"./Sprites\";\nimport { DecorateContext } from \"./ViewContext\";\nimport { HitDetail, HitList, SnapMode, SnapDetail, HitSource, HitDetailType, HitPriority, IntersectDetail, SnapHeat, HitGeomType } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { BeDuration } from \"@bentley/bentleyjs-core\";\nimport { Decorator } from \"./ViewManager\";\nimport { SnapRequestProps } from \"@bentley/imodeljs-common\";\nimport { CanvasDecoration } from \"./rendering\";\n\n/** Virtual cursor for using AccuSnap with touch input.\n * @internal\n */\nexport class TouchCursor implements CanvasDecoration {\n  public position = new Point3d();\n  protected _offsetPosition = new Point3d();\n  protected _size: number;\n  protected _yOffset: number;\n  protected _isSelected = false;\n  protected _isDragging = false;\n  protected _inTouchTap = false;\n\n  protected constructor(vp: ScreenViewport) {\n    this._size = vp.pixelsFromInches(0.3);\n    this._yOffset = this._size * 1.75;\n  }\n\n  protected setPosition(vp: Viewport, worldLocation: Point3d): boolean {\n    const pt4 = vp.worldToView4d(worldLocation);\n    if (pt4.w > 1.0 || pt4.w < 0) // outside of frustum.\n      return false;\n\n    const viewLocation = pt4.realPoint();\n    if (undefined === viewLocation || !vp.viewRect.containsPoint(viewLocation))\n      return false; // outside this viewport rect\n\n    viewLocation.x = Math.floor(viewLocation.x) + 0.5; viewLocation.y = Math.floor(viewLocation.y) + 0.5; viewLocation.z = 0.0;\n    const offsetLocation = new Point3d(viewLocation.x, viewLocation.y - this._yOffset, viewLocation.z);\n    if (!vp.viewRect.containsPoint(offsetLocation))\n      return false; // outside this viewport rect\n\n    this.position.setFrom(viewLocation);\n    this._offsetPosition.setFrom(offsetLocation);\n    vp.invalidateDecorations();\n    return true;\n  }\n\n  protected drawHandle(ctx: CanvasRenderingContext2D, filled: boolean): void {\n    ctx.beginPath();\n    ctx.moveTo(-this._size, 0);\n    ctx.bezierCurveTo(-this._size, -this._size * 0.85, -this._size * 0.6, -this._yOffset * 0.6, 0, -this._yOffset * 0.8);\n    ctx.bezierCurveTo(this._size * 0.6, -this._yOffset * 0.6, this._size, -this._size * 0.85, this._size, 0);\n    ctx.arc(0, 0, this._size, 0, Math.PI);\n    if (filled) ctx.fill();\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.arc(0, 0, this._size * 0.75, 0, 2 * Math.PI);\n    ctx.stroke();\n\n    ctx.beginPath();\n    ctx.moveTo(-this._size * 0.4, 0);\n    ctx.lineTo(this._size * 0.4, 0);\n    ctx.moveTo(-this._size * 0.4, this._size * 0.25);\n    ctx.lineTo(this._size * 0.4, this._size * 0.25);\n    ctx.stroke();\n  }\n\n  public drawDecoration(ctx: CanvasRenderingContext2D): void {\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = \"rgba(0,0,0,.75)\";\n    ctx.fillStyle = \"white\";\n    ctx.strokeRect(-2, -(this._yOffset + 2), 5, 5);\n    ctx.fillRect(-1, -(this._yOffset + 1), 3, 3);\n\n    ctx.lineWidth = 3.5;\n    ctx.lineCap = \"round\";\n    ctx.fillStyle = this._isSelected ? \"rgba(35,187,252,.25)\" : \"rgba(255,215,0,.25)\";\n    ctx.shadowColor = \"black\";\n    ctx.shadowBlur = 10;\n    this.drawHandle(ctx, true);\n\n    ctx.lineWidth = 1.5;\n    ctx.strokeStyle = this._isSelected ? \"rgba(35,187,252,.75)\" : \"rgba(255,215,0,.75)\";\n    ctx.shadowBlur = 0;\n    this.drawHandle(ctx, false);\n  }\n\n  protected isSelected(pt: XAndY): boolean { return this.position.distance(Point3d.create(pt.x, pt.y)) < this._size; }\n  public isButtonHandled(ev: BeButtonEvent): boolean { return (BeButton.Data === ev.button && InputSource.Touch === ev.inputSource && !this._inTouchTap); }\n\n  public doTouchMove(ev: BeTouchEvent): boolean {\n    if (undefined === ev.viewport || !ev.isSingleTouch)\n      return false;\n    if (!this._isDragging || !this.setPosition(ev.viewport, ev.point))\n      return false;\n    ev.viewPoint = this._offsetPosition;\n    IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // tslint:disable-line:no-floating-promises\n    return true;\n  }\n\n  public doTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean {\n    if (undefined === ev.viewport || !ev.isSingleTouch)\n      return false;\n    return (this._isDragging = this.isSelected(startEv.viewPoint));\n  }\n\n  public doTouchStart(ev: BeTouchEvent): void {\n    this._isSelected = ev.isSingleTouch && this.isSelected(ev.viewPoint);\n    if (undefined !== ev.viewport)\n      ev.viewport.invalidateDecorations();\n  }\n\n  public doTouchEnd(ev: BeTouchEvent): void {\n    this._isSelected = this._isDragging = false;\n    if (undefined !== ev.viewport)\n      ev.viewport.invalidateDecorations();\n  }\n\n  public async doTouchTap(ev: BeTouchEvent): Promise<boolean> {\n    if (undefined === ev.viewport || !ev.isSingleTouch || 1 !== ev.tapCount)\n      return false;\n    if (!this.isSelected(ev.viewPoint)) {\n      if (!this.setPosition(ev.viewport, ev.point))\n        return false;\n      ev.viewPoint = this._offsetPosition;\n      IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // tslint:disable-line:no-floating-promises\n      return false;\n    }\n    ev.viewPoint = this._offsetPosition;\n    this._inTouchTap = true;\n    await IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev);\n    this._inTouchTap = false;\n    return true;\n  }\n\n  public static createFromTouchTap(ev: BeTouchEvent): TouchCursor | undefined {\n    if (undefined === ev.viewport || !ev.isSingleTouch || 1 !== ev.tapCount)\n      return undefined;\n    const touchCursor = new TouchCursor(ev.viewport);\n    if (!touchCursor.setPosition(ev.viewport, ev.point) && !touchCursor.setPosition(ev.viewport, ev.viewport.view.getCenter()))\n      return undefined;\n    ev.viewPoint = touchCursor._offsetPosition;\n    IModelApp.toolAdmin.convertTouchMoveToMotion(ev); // tslint:disable-line:no-floating-promises\n    return touchCursor;\n  }\n}\n\n/** AccuSnap is an aide for snapping to interesting points on elements or decorations as the cursor moves over them.\n * @see [Using AccuSnap]($docs/learning/frontend/primitivetools.md#AccuSnap)\n * @public\n */\nexport class AccuSnap implements Decorator {\n  /** Currently active hit */\n  public currHit?: HitDetail;\n  /** Current list of hits. */\n  public aSnapHits?: HitList<HitDetail>;\n  /** Views that need to be flashed */\n  public readonly needFlash = new Set<Viewport>();\n  /** Views that are already flashed */\n  public readonly areFlashed = new Set<Viewport>();\n  /** The \"+\" that indicates where the snap point is */\n  public readonly cross = new SpriteLocation();\n  /** The icon that indicates what type of snap is active */\n  public readonly icon = new SpriteLocation();\n  /** The icon that indicates an error */\n  public readonly errorIcon = new SpriteLocation();\n  /** Reason key for last error */\n  public errorKey?: string;\n  /** localized message explaining why last error was generated. */\n  public explanation?: string;\n  /** Number of times \"suppress\" has been called -- unlike suspend this is not automatically cleared by tools */\n  private _suppressed = 0;\n  /** Time motion stopped. */\n  private _motionStopTime = 0;\n  /** Location of cursor when we last checked for motion */\n  private readonly _lastCursorPos = new Point2d();\n  /** @internal */\n  public readonly toolState = new AccuSnap.ToolState();\n  /** @internal */\n  protected _settings = new AccuSnap.Settings();\n  /** @internal */\n  public touchCursor?: TouchCursor;\n  /** Current request for tooltip message. */\n  private _toolTipPromise?: Promise<string | HTMLElement>;\n\n  /** @internal */\n  public onInitialized() { }\n  private get _searchDistance(): number { return this.isLocateEnabled ? 1.0 : this._settings.searchDistance; }\n  private get _hotDistanceInches(): number { return IModelApp.locateManager.apertureInches * this._settings.hotDistanceFactor; }\n  /** Whether locate of elements under the cursor is enabled by the current InteractiveTool.\n   * @public\n   */\n  public get isLocateEnabled(): boolean { return this.toolState.locate; }\n  /** Whether snapping to elements under the cursor is enabled by the current InteractiveTool.\n   * @public\n   */\n  public get isSnapEnabled(): boolean { return this.toolState.enabled; }\n  /** Whether the user setting for snapping is enabled. Snapping is done only when both the user and current InteractiveTool have enabled it.\n   * @public\n   */\n  public get isSnapEnabledByUser(): boolean { return this._settings.enableFlag; }\n  private isFlashed(view: Viewport): boolean { return (this.areFlashed.has(view)); }\n  private needsFlash(view: Viewport): boolean { return (this.needFlash.has(view)); }\n  private setNeedsFlash(view: Viewport) { this.needFlash.add(view); this.clearIsFlashed(view); view.invalidateDecorations(); }\n  private setIsFlashed(view: Viewport) { this.areFlashed.add(view); }\n  private clearIsFlashed(view: Viewport) { this.areFlashed.delete(view); }\n  private static toSnapDetail(hit?: HitDetail): SnapDetail | undefined { return (hit && hit instanceof SnapDetail) ? hit : undefined; }\n  /** @internal */\n  public getCurrSnapDetail(): SnapDetail | undefined { return AccuSnap.toSnapDetail(this.currHit); }\n  /** Determine whether there is a current hit that is *hot*. */\n  public get isHot(): boolean { const currSnap = this.getCurrSnapDetail(); return !currSnap ? false : currSnap.isHot; }\n\n  /** @internal */\n  public destroy(): void { this.currHit = undefined; this.aSnapHits = undefined; }\n  private get _doSnapping(): boolean { return this.isSnapEnabled && this.isSnapEnabledByUser && !this._isSnapSuspended; }\n  private get _isSnapSuspended(): boolean { return (0 !== this._suppressed || 0 !== this.toolState.suspended); }\n\n  /** Get the current snap divisor to use to use for SnapMode.NearestKeypoint.\n   * @public\n   */\n  public get keypointDivisor() { return 2; }\n\n  /** Get the current active SnapModes. SnapMode position determines priority, with the first entry being the highest. The SnapDetail will be returned for the first SnapMode that produces a hot snap.\n   * @public\n   */\n  public getActiveSnapModes(): SnapMode[] {\n    const snaps: SnapMode[] = [];\n    snaps.push(SnapMode.NearestKeypoint);\n    return snaps;\n  }\n\n  /** Can be implemented by a subclass of AccuSnap to implement a SnapMode override that applies only to the next point.\n   * This method will be called whenever a new tool is installed and on button events.\n   * @internal\n   */\n  public synchSnapMode(): void { }\n\n  /** Check whether current tentative snap has valid curve geometry for finding extended intersections. */\n  private get _searchForExtendedIntersections(): boolean {\n    const snap = IModelApp.tentativePoint.getCurrSnap();\n    return (undefined !== snap && undefined !== snap.primitive);\n  }\n\n  /**\n   * Check to see whether its appropriate to generate an AccuSnap point, given the current user\n   * and command settings, and whether a tentative point is currently active.\n   */\n  public get isActive(): boolean {\n    // Unless we're snapping in intersect mode (to find extended intersections), skip if tentative point active...\n    if (IModelApp.tentativePoint.isActive) {\n      if (!this._doSnapping || !this._searchForExtendedIntersections)\n        return false;\n      const snaps = this.getActiveSnapModes();\n      for (const snap of snaps) { if (snap === SnapMode.Intersection) return true; }\n      return false;\n    }\n\n    return this._doSnapping || this.isLocateEnabled;\n  }\n\n  private initializeForCheckMotion(): void {\n    this._lastCursorPos.setFrom(IModelApp.toolAdmin.currentInputState.lastMotion);\n  }\n\n  /** Clear the current AccuSnap info. */\n  public clear(): void { this.setCurrHit(undefined); }\n  /** @internal */\n  public setCurrHit(newHit?: HitDetail): void {\n    const newSnap = AccuSnap.toSnapDetail(newHit);\n    const currSnap = this.getCurrSnapDetail();\n    const sameElem = (undefined !== newHit && newHit.isSameHit(this.currHit));\n    const sameHit = (sameElem && !newSnap);\n    const sameSnap = (sameElem && undefined !== newSnap && undefined !== currSnap);\n    const samePt = (sameHit || (sameSnap && newSnap!.snapPoint.isAlmostEqual(currSnap!.snapPoint)));\n    const sameHot = (sameHit || (sameSnap && (this.isHot === newSnap!.isHot)));\n    const sameBaseSnapMode = (!newSnap || !currSnap || newSnap.snapMode === currSnap.snapMode);\n    const sameType = (sameHot && (!currSnap || (currSnap.getHitType() === newHit!.getHitType())));\n\n    // see if it is the same point on the same element, the hot flags are the same multiple snaps, and the snap modes are the same\n    if (samePt && sameType && sameBaseSnapMode) {\n      // we know that nothing about the screen could change, just save the new hit and return to avoid screen flash\n      this.currHit = newHit;\n      return;\n    }\n\n    this.erase();\n\n    // if we hit the same element with the same \"hotness\" as last time, we don't need to erase it\n    //  multiple snaps: but only if the old and new snap modes are the same\n    if (!sameHot || !sameBaseSnapMode) {\n      this.unFlashViews();\n      this.setFlashHit(newHit);\n    }\n\n    // if we didn't get a new hit, we're done\n    if (undefined === (this.currHit = newHit))\n      return;\n\n    // draw sprites for this hit\n    this.showSnapSprite();\n  }\n\n  /** flash a hit in a single view. */\n  private flashHitInView(hit: HitDetail, context: DecorateContext) {\n    const viewport = context.viewport;\n    if (!viewport || !this.hitShouldBeHilited(hit) || !this.needsFlash(viewport))\n      return;\n\n    hit.draw(context);\n    this.setIsFlashed(viewport);\n  }\n\n  private setNeedsFlashView(view: Viewport) {\n    if (!this.isFlashed(view) && !this.needsFlash(view))\n      this.setNeedsFlash(view);\n  }\n\n  /** flash a hit in its view. */\n  private setFlashHit(hit?: HitDetail): void {\n    if (hit !== undefined && this.hitShouldBeHilited(hit))\n      this.setNeedsFlashView(hit.viewport!);\n  }\n\n  /** @internal */\n  public erase(): void {\n    this.clearToolTip(undefined); // make sure there's no tooltip up.\n    this.clearSprites(); // remove all sprites from the screen\n  }\n\n  /** @internal */\n  public showElemInfo(viewPt: XAndY, vp: ScreenViewport, hit: HitDetail): void {\n    if (IModelApp.viewManager.doesHostHaveFocus && undefined === this._toolTipPromise) {\n      const promise = IModelApp.toolAdmin.getToolTip(hit);\n      this._toolTipPromise = promise;\n      promise.then((msg) => { // tslint:disable-line:no-floating-promises\n        // Ignore response if we're no longer interested in this tooltip.\n        if (this._toolTipPromise === promise)\n          this.showLocateMessage(viewPt, vp, msg);\n      });\n    }\n  }\n\n  private showLocateMessage(viewPt: XAndY, vp: ScreenViewport, msg: HTMLElement | string) {\n    if (IModelApp.viewManager.doesHostHaveFocus)\n      vp.openToolTip(msg, viewPt);\n  }\n\n  /** @internal */\n  public displayToolTip(viewPt: XAndY, vp: ScreenViewport, uorPt?: Point3d): void {\n    // if the tooltip is already displayed, or if user doesn't want it, quit.\n    if (0 === this._motionStopTime || !this._settings.toolTip || !IModelApp.notifications.isToolTipSupported || IModelApp.notifications.isToolTipOpen)\n      return;\n\n    const accuSnapHit = this.currHit;\n    const tpHit = IModelApp.tentativePoint.getCurrSnap();\n\n    // if we don't have either an AccuSnap or a tentative point hit, quit.\n    if (!accuSnapHit && !tpHit && !this.errorIcon.isActive)\n      return;\n\n    // when the tentative button is first pressed, we pass nullptr for uorPt so that we can know to show the tooltip more quickly.\n    const timeout = (undefined === tpHit || undefined !== uorPt ? this._settings.toolTipDelay : BeDuration.fromSeconds(.1));\n\n    // have we waited long enough to show the balloon?\n    if ((this._motionStopTime + timeout.milliseconds) > Date.now())\n      return;\n\n    this._motionStopTime = 0; // If application chooses to not display tool tip, make sure we don't ask again until we see another motion/motion stopped...\n    let theHit: HitDetail | undefined;\n\n    // determine which type of hit\n    if (tpHit) {\n      if (uorPt) {\n        // see if he came back somewhere near the currently snapped element\n        const aperture = (this._settings.stickyFactor * vp.pixelsFromInches(IModelApp.locateManager.apertureInches) / 2.0) + 1.5;\n        if (!IModelApp.locateManager.picker.testHit(tpHit, vp, uorPt, aperture, IModelApp.locateManager.options))\n          return;\n      }\n      theHit = tpHit;\n    } else {\n      theHit = accuSnapHit;\n    }\n\n    // if we're currently showing an error, get the error message...otherwise display hit info...\n    if (!this.errorIcon.isActive && theHit) {\n      this.showElemInfo(viewPt, vp, theHit);\n      return;\n    }\n\n    // If we have an error explanation...use it as is!\n    if (this.explanation) {\n      this.showLocateMessage(viewPt, vp, this.explanation);\n      return;\n    }\n\n    // if we don't have an explanation yet, translate the error code.\n    if (!this.errorKey)\n      return;\n\n    this.explanation = IModelApp.i18n.translate(this.errorKey);\n    if (!this.explanation)\n      return;\n\n    // Get the \"best\" rejected hit to augment the error explanation with the hit info...\n    if (!theHit)\n      theHit = this.aSnapHits ? this.aSnapHits.hits[0] : undefined;\n\n    this.showLocateMessage(viewPt, vp, this.explanation);\n  }\n\n  /** @internal */\n  public clearToolTip(ev?: BeButtonEvent): void {\n    // Throw away any stale request for a tooltip message\n    this._toolTipPromise = undefined;\n    if (!IModelApp.notifications.isToolTipOpen)\n      return;\n\n    if (ev && (5 > ev.viewPoint.distanceXY(IModelApp.notifications.toolTipLocation)))\n      return;\n\n    IModelApp.notifications.clearToolTip();\n  }\n\n  /** Display the sprites for the current snap to indicate its position on the screen and what snap mode it represents. */\n  private showSnapSprite(): void {\n    const snap = this.getCurrSnapDetail();\n    if (!snap)\n      return;\n\n    const crossPt = snap.snapPoint;\n    const viewport = snap.viewport!;\n    const crossSprite = IconSprites.getSpriteFromUrl(snap.isHot ? \"sprites/SnapCross.png\" : \"sprites/SnapUnfocused.png\");\n\n    this.cross.activate(crossSprite, viewport, crossPt);\n\n    const snapSprite = snap.sprite;\n    if (snapSprite)\n      this.icon.activate(snapSprite, viewport, AccuSnap.adjustIconLocation(viewport, crossPt, snapSprite.size));\n  }\n\n  private static adjustIconLocation(vp: Viewport, input: Point3d, iconSize: XAndY): Point3d {\n    const out = vp.worldToView(input);\n    out.x += (iconSize.x / 3.0);\n    out.y -= (iconSize.y * 1.3);\n    return vp.viewToWorld(out, out);\n  }\n\n  /** try to indicate what's wrong with the current point (why we're not snapping). */\n  private showSnapError(out: LocateResponse, ev: BeButtonEvent) {\n    this.explanation = out.explanation;\n    this.errorKey = out.reason;\n    this.errorIcon.deactivate();\n\n    const vp = ev.viewport!;\n    let errorSprite: Sprite | undefined;\n    switch (out.snapStatus) {\n      case SnapStatus.FilteredByApp:\n        errorSprite = IconSprites.getSpriteFromUrl(\"sprites/SnapAppFiltered.png\");\n        break;\n\n      case SnapStatus.FilteredByAppQuietly:\n        this.errorKey = undefined;\n        break;\n\n      case SnapStatus.NotSnappable:\n        errorSprite = IconSprites.getSpriteFromUrl(\"sprites/SnapNotSnappable.png\");\n        this.errorKey = ElementLocateManager.getFailureMessageKey(\"NotSnappable\");\n        break;\n    }\n\n    if (!errorSprite)\n      return;\n\n    const spriteSize = errorSprite.size;\n    const pt = AccuSnap.adjustIconLocation(vp, ev.rawPoint, spriteSize);\n\n    this.errorIcon.activate(errorSprite, vp, pt);\n  }\n\n  private clearSprites() {\n    this.errorIcon.deactivate();\n    this.cross.deactivate();\n    this.icon.deactivate();\n  }\n\n  /** determine whether a hit should be hilited or not. */\n  private hitShouldBeHilited(hit: HitDetail | undefined): boolean {\n    if (!hit)\n      return false;\n\n    if (hit.isModelHit)\n      return false;       // Avoid annoying flashing of reality models.\n\n    const snap = AccuSnap.toSnapDetail(hit);\n    return !snap || snap.isHot || this._settings.hiliteColdHits;\n  }\n\n  private unFlashViews() {\n    this.needFlash.clear();\n    this.areFlashed.forEach((vp) => {\n      vp.setFlashed(undefined, 0.0);\n    });\n    this.areFlashed.clear();\n  }\n\n  /** @internal */\n  public adjustPointIfHot(pt: Point3d, view: Viewport): void {\n    const currSnap = this.getCurrSnapDetail();\n\n    if (!currSnap || !currSnap.isHot || view !== currSnap.viewport)\n      return;\n\n    pt.setFrom(currSnap.adjustedPoint);\n  }\n\n  /** Implemented by sub-classes to update ui to show current enabled state.\n   * @internal\n   */\n  public onEnabledStateChange(_isEnabled: boolean, _wasEnabled: boolean) { }\n\n  /** @internal */\n  public getHitAndList(holder: HitListHolder): HitDetail | undefined {\n    const hit = this.currHit;\n    if (hit) {\n      holder.setHitList(this.aSnapHits);\n      this.aSnapHits = undefined;\n    }\n    return hit;\n  }\n\n  private initCmdState() { this.toolState.suspended = 0; }\n\n  /** @internal */\n  public suspend(doSuspend: boolean) {\n    const previousDoSnapping = this._doSnapping;\n    if (doSuspend)\n      this.toolState.suspended++;\n    else if (this.toolState.suspended > 0)\n      this.toolState.suspended--;\n\n    this.onEnabledStateChange(this._doSnapping, previousDoSnapping);\n  }\n\n  /** @internal */\n  public suppress(doSuppress: boolean): number {\n    const previousDoSnapping = this._doSnapping;\n    if (doSuppress)\n      this._suppressed++;\n    else if (this._suppressed > 0)\n      this._suppressed--;\n\n    this.onEnabledStateChange(this._doSnapping, previousDoSnapping);\n    return this._suppressed;\n  }\n\n  /** Turn AccuSnap on or off */\n  public enableSnap(yesNo: boolean) {\n    const previousDoSnapping = this._doSnapping;\n    this.toolState.enabled = yesNo;\n    if (!yesNo) {\n      this.clear();\n      if (undefined !== this.touchCursor) {\n        this.touchCursor = undefined;\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n      }\n    }\n    this.onEnabledStateChange(this._doSnapping, previousDoSnapping);\n  }\n\n  /** @internal */\n  public intersectXY(tpSnap: SnapDetail, second: SnapDetail): IntersectDetail | undefined {\n    // Get single segment curve from each snap to intersect...\n    const tpSegment = tpSnap.getCurvePrimitive();\n    if (undefined === tpSegment)\n      return undefined;\n    const segment = second.getCurvePrimitive();\n    if (undefined === segment)\n      return undefined;\n\n    const worldToView = second.viewport.worldToViewMap.transform0;\n    const detail = CurveCurve.intersectionProjectedXY(worldToView, tpSegment, true, segment, true);\n    if (0 === detail.dataA.length)\n      return undefined;\n\n    let closeIndex = 0;\n    if (detail.dataA.length > 1) {\n      const snapPt = worldToView.multiplyPoint3d(HitGeomType.Point === tpSnap.geomType && HitGeomType.Point !== second.geomType ? second.getPoint() : tpSnap.getPoint(), 1); // Don't check distance from arc centers...\n      let lastDist: number | undefined;\n\n      for (let i = 0; i < detail.dataA.length; i++) {\n        const testPt = worldToView.multiplyPoint3d(detail.dataA[i].point, 1);\n        const testDist = snapPt.realDistanceXY(testPt);\n\n        if (undefined !== testDist && (undefined === lastDist || testDist < lastDist)) {\n          lastDist = testDist;\n          closeIndex = i;\n        }\n      }\n    }\n\n    const intersect = new IntersectDetail(tpSnap, SnapHeat.InRange, detail.dataA[closeIndex].point, segment, second.sourceId); // Should be ok to share hit detail with tentative...\n    intersect.primitive = tpSegment; // Just save single segment that was intersected for line strings/shapes...\n\n    return intersect;\n  }\n\n  /** @internal */\n  public static async requestSnap(thisHit: HitDetail, snapModes: SnapMode[], hotDistanceInches: number, keypointDivisor: number, hitList?: HitList<HitDetail>, out?: LocateResponse): Promise<SnapDetail | undefined> {\n    if (undefined !== thisHit.subCategoryId) {\n      const appearance = thisHit.viewport.getSubCategoryAppearance(thisHit.subCategoryId);\n      if (appearance.dontSnap) {\n        if (out) out.snapStatus = SnapStatus.NotSnappable;\n        return undefined;\n      }\n    }\n\n    const requestProps: SnapRequestProps = {\n      id: thisHit.sourceId,\n      testPoint: thisHit.testPoint,\n      closePoint: thisHit.hitPoint,\n      worldToView: thisHit.viewport.worldToViewMap.transform0.toJSON(),\n      viewFlags: thisHit.viewport.viewFlags,\n      snapModes,\n      snapAperture: thisHit.viewport.pixelsFromInches(hotDistanceInches),\n      snapDivisor: keypointDivisor,\n      subCategoryId: thisHit.subCategoryId,\n      geometryClass: thisHit.geometryClass,\n    };\n\n    if (!thisHit.isElementHit) {\n      const thisGeom = IModelApp.viewManager.getDecorationGeometry(thisHit);\n      if (undefined === thisGeom) {\n        if (out) out.snapStatus = SnapStatus.NoSnapPossible;\n        return undefined;\n      }\n      requestProps.decorationGeometry = [{ id: thisHit.sourceId, geometryStream: thisGeom }];\n    }\n\n    if (snapModes.includes(SnapMode.Intersection)) {\n      if (undefined !== hitList) {\n        for (const hit of hitList.hits) {\n          if (thisHit.sourceId === hit.sourceId)\n            continue;\n\n          if (!hit.isElementHit) {\n            const geom = IModelApp.viewManager.getDecorationGeometry(hit);\n            if (undefined === geom)\n              continue;\n            if (undefined === requestProps.decorationGeometry)\n              requestProps.decorationGeometry = [{ id: thisHit.sourceId, geometryStream: geom }];\n            else\n              requestProps.decorationGeometry.push({ id: thisHit.sourceId, geometryStream: geom });\n          }\n\n          if (undefined === requestProps.intersectCandidates)\n            requestProps.intersectCandidates = [hit.sourceId];\n          else\n            requestProps.intersectCandidates.push(hit.sourceId);\n\n          if (5 === requestProps.intersectCandidates.length)\n            break; // Search for intersection with a few of the next best hits...\n        }\n      }\n\n      if (1 === snapModes.length && undefined === requestProps.intersectCandidates) {\n        if (out) out.snapStatus = SnapStatus.NoSnapPossible;\n        return undefined; // Don't make back end request when only doing intersection snap when we don't have another hit to intersect with...\n      }\n    }\n\n    const result = await thisHit.viewport.iModel.requestSnap(requestProps);\n\n    if (out) out.snapStatus = result.status;\n    if (result.status !== SnapStatus.Success)\n      return undefined;\n\n    const snap = new SnapDetail(thisHit, result.snapMode!, result.heat!, result.snapPoint!);\n    snap.setCurvePrimitive(undefined !== result.curve ? GeomJson.Reader.parse(result.curve) : undefined, undefined, result.geomType);\n    if (undefined !== result.parentGeomType)\n      snap.parentGeomType = result.parentGeomType;\n    if (undefined !== result.hitPoint)\n      snap.hitPoint.setFromJSON(result.hitPoint); // Update hitPoint from readPixels with exact point location corrected to surface/edge geometry...\n    if (undefined !== result.normal)\n      snap.normal = Vector3d.fromJSON(result.normal);\n\n    if (SnapMode.Intersection !== snap.snapMode)\n      return snap;\n\n    if (undefined === result.intersectId)\n      return undefined;\n\n    const otherPrimitive = (undefined !== result.intersectCurve ? GeomJson.Reader.parse(result.intersectCurve) : undefined);\n    if (undefined === otherPrimitive)\n      return undefined;\n\n    const intersect = new IntersectDetail(snap, snap.heat, snap.snapPoint, otherPrimitive, result.intersectId);\n    return intersect;\n  }\n\n  private async getAccuSnapDetail(hitList: HitList<HitDetail>, out: LocateResponse): Promise<SnapDetail | undefined> {\n    const thisHit = hitList.getNextHit();\n    if (undefined === thisHit)\n      return undefined;\n\n    const filterStatus = (this.isLocateEnabled ? IModelApp.locateManager.filterHit(thisHit, LocateAction.AutoLocate, out) : LocateFilterStatus.Accept);\n    if (LocateFilterStatus.Accept !== filterStatus) {\n      out.snapStatus = SnapStatus.FilteredByApp;\n      return undefined;\n    }\n\n    let snapModes: SnapMode[];\n    if (IModelApp.tentativePoint.isActive) {\n      snapModes = [];\n      snapModes.push(SnapMode.Nearest); // Special case: isActive only allows snapping with tentative to find extended intersections...\n    } else {\n      snapModes = this.getActiveSnapModes(); // Get the list of point snap modes to consider\n    }\n\n    const thisSnap = await AccuSnap.requestSnap(thisHit, snapModes, this._hotDistanceInches, this.keypointDivisor, hitList, out);\n    if (undefined === thisSnap)\n      return undefined;\n\n    if (IModelApp.tentativePoint.isActive) {\n      const tpSnap = IModelApp.tentativePoint.getCurrSnap();\n      if (undefined === tpSnap)\n        return undefined;\n      const intersectSnap = this.intersectXY(tpSnap, thisSnap);\n      if (undefined === intersectSnap)\n        return undefined;\n      hitList.setCurrentHit(thisHit);\n      return intersectSnap;\n    }\n\n    IModelApp.accuDraw.onSnap(thisSnap); // AccuDraw can adjust nearest snap to intersection of circle (polar distance lock) or line (axis lock) with snapped to curve...\n    hitList.setCurrentHit(thisHit);\n    return thisSnap;\n  }\n\n  private findHits(ev: BeButtonEvent, force: boolean = false): SnapStatus {\n    // When using AccuSnap to locate elements, we have to start with the datapoint adjusted\n    // for locks and not the raw point. Otherwise, when grid/unit lock are on, we locate elements by\n    // points not on the grid. This causes them to be \"pulled\" off the grid when they are accepted. On\n    // the other hand, when NOT locating, we need to use the raw point so we can snap to elements\n    // away from the grid.\n\n    const testPoint = this.isLocateEnabled ? ev.point : ev.rawPoint;\n    const vp = ev.viewport!;\n    const picker = IModelApp.locateManager.picker;\n    const options = IModelApp.locateManager.options.clone(); // Copy to avoid changing out from under active Tool...\n\n    // NOTE: Since TestHit will use the same HitSource as the input hit we only need to sets this for DoPick...\n    options.hitSource = this.isSnapEnabled ? HitSource.AccuSnap : HitSource.MotionLocate;\n\n    let aperture = (vp.pixelsFromInches(IModelApp.locateManager.apertureInches) / 2.0) + 1.5;\n    this.initializeForCheckMotion();\n    aperture *= this._searchDistance;\n\n    if (0 === picker.doPick(vp, testPoint, aperture, options)) {\n      this.aSnapHits = undefined; // Clear any previous hit list so reset won't cycle through hits cursor is no longer over, etc.\n      return SnapStatus.NoElements;\n    }\n\n    this.aSnapHits = picker.getHitList(true); // take ownership of the pickElem hit list.\n\n    // see if we should keep the current hit\n    const canBeSticky = !force && this.aSnapHits.length > 1 && this.currHit && (HitDetailType.Intersection !== this.currHit.getHitType() && this.currHit.priority < HitPriority.PlanarSurface);\n    if (canBeSticky) {\n      for (let iHit = 1; iHit < this.aSnapHits.length; ++iHit) {\n        const thisHit = this.aSnapHits.hits[iHit];\n        if (!thisHit.isSameHit(this.currHit))\n          continue;\n        this.aSnapHits.removeHit(iHit);\n        this.aSnapHits.insertHit(0, thisHit);\n        break;\n      }\n    }\n\n    return SnapStatus.Success;\n  }\n\n  private async findLocatableHit(ev: BeButtonEvent, newSearch: boolean, out: LocateResponse): Promise<HitDetail | undefined> {\n    out.snapStatus = SnapStatus.NoElements;\n\n    if (newSearch) {\n      this.aSnapHits = undefined;\n      // search for new hits, but if the cursor is still close to the current hit, don't throw away list.\n      if (SnapStatus.Success !== (out.snapStatus = this.findHits(ev)))\n        return undefined;\n    } else {\n      if (!this.aSnapHits) {\n        out.snapStatus = SnapStatus.NoElements;\n        return undefined;\n      }\n    }\n\n    const thisList = this.aSnapHits!;\n    let thisHit: HitDetail | undefined;\n    const ignore = new LocateResponse();\n    // keep looking through hits until we find one that is accu-snappable.\n    while (undefined !== (thisHit = thisList.getNextHit())) {\n      if (LocateFilterStatus.Accept === await IModelApp.locateManager.filterHit(thisHit, LocateAction.AutoLocate, out))\n        return thisHit;\n\n      // we only care about the status of the first hit.\n      out.snapStatus = SnapStatus.FilteredByApp;\n      out = ignore;\n    }\n\n    // Reset current hit index to go back to first hit on next AccuSnap reset event...\n    thisList.resetCurrentHit();\n    return undefined;\n  }\n\n  /** When in auto-locate mode, advance to the next hit without searching again.\n   * @internal\n   */\n  public async resetButton(): Promise<SnapStatus> {\n    let hit: HitDetail | undefined;\n    const out = new LocateResponse();\n    out.snapStatus = SnapStatus.Disabled;\n\n    this.clearToolTip(undefined);\n\n    const ev = new BeButtonEvent();\n    IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n\n    if (this._doSnapping) {\n      // if we don't have any more candidate hits, get a new list at the current location\n      if (!this.aSnapHits || (0 === this.aSnapHits.length)) {\n        out.snapStatus = this.findHits(ev);\n        hit = (SnapStatus.Success !== out.snapStatus) ? undefined : await this.getAccuSnapDetail(this.aSnapHits!, out);\n      } else {\n        // drop the current hit from the list and then retest the list (without the dropped hit) to find the new snap\n        this.aSnapHits.removeCurrentHit();\n        hit = await this.getAccuSnapDetail(this.aSnapHits, out);\n      }\n    } else if (this.isLocateEnabled) {\n      hit = await this.findLocatableHit(ev, false, out); // get next AccuSnap path (or undefined)\n    }\n\n    // set the current hit\n    if (hit || this.currHit)\n      this.setCurrHit(hit);\n\n    // indicate errors\n    this.showSnapError(out, ev);\n    return out.snapStatus;\n  }\n\n  /** Find the best snap point according to the current cursor location\n   * @internal\n   */\n  public async onMotion(ev: BeButtonEvent): Promise<void> {\n    this.clearToolTip(ev);\n    const out = new LocateResponse();\n    out.snapStatus = SnapStatus.Disabled;\n\n    let hit: HitDetail | undefined;\n    if (this.isActive) {\n      if (this._doSnapping) {\n        out.snapStatus = this.findHits(ev);\n        hit = (SnapStatus.Success !== out.snapStatus) ? undefined : await this.getAccuSnapDetail(this.aSnapHits!, out);\n      } else if (this.isLocateEnabled) {\n        hit = await this.findLocatableHit(ev, true, out);\n      }\n    }\n\n    // set the current hit and display the sprite (based on snap's KeypointType)\n    if (hit || this.currHit)\n      this.setCurrHit(hit);\n\n    // indicate errors\n    this.showSnapError(out, ev);\n\n    if (undefined !== this.touchCursor && InputSource.Mouse === ev.inputSource) {\n      this.touchCursor = undefined;\n      IModelApp.viewManager.invalidateDecorationsAllViews();\n    }\n  }\n\n  /** @internal */\n  public onMotionStopped(_ev: BeButtonEvent): void { this._motionStopTime = Date.now(); }\n  /** @internal */\n  public async onNoMotion(ev: BeButtonEvent) { this.displayToolTip(ev.viewPoint, ev.viewport!, ev.rawPoint); return Promise.resolve(); }\n\n  /** @internal */\n  public onPreButtonEvent(ev: BeButtonEvent): boolean { return (undefined !== this.touchCursor) ? this.touchCursor.isButtonHandled(ev) : false; }\n  /** @internal */\n  public onTouchStart(ev: BeTouchEvent): void { if (undefined !== this.touchCursor) this.touchCursor.doTouchStart(ev); }\n  /** @internal */\n  public onTouchEnd(ev: BeTouchEvent): void { if (undefined !== this.touchCursor && 0 === ev.touchCount) this.touchCursor.doTouchEnd(ev); }\n  /** @internal */\n  public onTouchCancel(ev: BeTouchEvent): void { if (undefined !== this.touchCursor) this.touchCursor.doTouchEnd(ev); }\n  /** @internal */\n  public onTouchMove(ev: BeTouchEvent): boolean { return (undefined !== this.touchCursor) ? this.touchCursor.doTouchMove(ev) : false; }\n  /** @internal */\n  public onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): boolean { return (undefined !== this.touchCursor) ? this.touchCursor.doTouchMoveStart(ev, startEv) : false; }\n\n  /** @internal */\n  public async onTouchTap(ev: BeTouchEvent): Promise<boolean> {\n    if (undefined !== this.touchCursor)\n      return this.touchCursor.doTouchTap(ev);\n    if (!this._doSnapping)\n      return false;\n    return (undefined !== (this.touchCursor = TouchCursor.createFromTouchTap(ev)));\n  }\n\n  private flashElements(context: DecorateContext): void {\n    const viewport = context.viewport!;\n    if (this.currHit) {\n      if (this.needsFlash(viewport))\n        this.flashHitInView(this.currHit, context);\n      return;\n    }\n\n    const hit = IModelApp.tentativePoint.getCurrSnap();\n    if (hit)\n      hit.draw(context);\n  }\n\n  /** @internal */\n  public decorate(context: DecorateContext): void {\n    if (undefined !== this.touchCursor)\n      context.addCanvasDecoration(this.touchCursor, true);\n\n    this.flashElements(context);\n\n    if (this.cross.isActive) {\n      this.cross.decorate(context);\n      this.icon.decorate(context);\n    }\n\n    this.errorIcon.decorate(context);\n  }\n\n  private clearElemFromHitList(element: string) {\n    if (this.aSnapHits)\n      this.aSnapHits.removeHitsFrom(element);\n  }\n\n  /** @internal */\n  public clearIfElement(sourceId: string): void {\n    this.clearElemFromHitList(sourceId);\n\n    const hit = this.currHit;\n    if (hit && hit.sourceId === sourceId) {\n      this.destroy();\n    }\n  }\n\n  /** Enable locating elements.\n   * @public\n   */\n  public enableLocate(yesNo: boolean) { this.toolState.locate = yesNo; }\n\n  /** Called whenever a new [[Tool]] is started.\n   * @internal\n   */\n  public onStartTool(): void {\n    this.initCmdState();\n    this.enableSnap(false);\n    this.enableLocate(false);\n    IModelApp.tentativePoint.clear(true);\n  }\n\n  /**\n   * Force AccuSnap to reevaluate the snap at the current cursor location.\n   * This is useful of an application changes the snap mode and wants AccuSnap to choose it immediately, without\n   * requiring the user to move the mouse.\n   * @internal\n   */\n  public async reEvaluate() {\n    if (this.getCurrSnapDetail()) {\n      const ev = new BeButtonEvent();\n      IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n      return this.onMotion(ev);\n    }\n  }\n}\n\n/** @internal */\nexport class TentativeOrAccuSnap {\n  public static get isHot(): boolean { return IModelApp.accuSnap.isHot || IModelApp.tentativePoint.isSnapped; }\n\n  public static getCurrentSnap(checkIsHot: boolean = true): SnapDetail | undefined {\n    // Checking for a hot AccuSnap hit before checking tentative is probably necessary for extended intersections?\n    if (IModelApp.accuSnap.isHot)\n      return IModelApp.accuSnap.getCurrSnapDetail();\n\n    if (IModelApp.tentativePoint.isSnapped)\n      return IModelApp.tentativePoint.currSnap;\n\n    return (checkIsHot ? undefined : IModelApp.accuSnap.getCurrSnapDetail());\n  }\n\n  public static getCurrentPoint(): Point3d {\n    if (IModelApp.accuSnap.isHot) {\n      const snap = IModelApp.accuSnap.getCurrSnapDetail();\n      if (snap)\n        return snap.adjustedPoint;\n    }\n\n    return IModelApp.tentativePoint.getPoint();\n  }\n\n  public static getCurrentView(): ScreenViewport | undefined {\n    const snap = IModelApp.accuSnap.getCurrSnapDetail();\n    return snap ? snap.viewport : IModelApp.tentativePoint.viewport;\n  }\n}\n\n/** @public */\nexport namespace AccuSnap {\n  export class ToolState {\n    public enabled = false;\n    public locate = false;\n    public suspended = 0;\n    public setFrom(other: ToolState): void {\n      this.enabled = other.enabled;\n      this.locate = other.locate;\n      this.suspended = other.suspended;\n    }\n    public clone(): ToolState { const val = new ToolState(); val.setFrom(this); return val; }\n  }\n\n  export class Settings {\n    public hotDistanceFactor = 1.2;\n    public stickyFactor = 1.0;\n    public searchDistance = 2.0;\n    public hiliteColdHits = true;\n    public enableFlag = true;\n    public toolTip = true;\n    public toolTipDelay = BeDuration.fromSeconds(.5); // delay before tooltip pops up\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\n\nimport { AuxCoordSystemProps, AuxCoordSystem2dProps, AuxCoordSystem3dProps, BisCodeSpec, Code, IModel, Npc, ColorDef, LinePixels } from \"@bentley/imodeljs-common\";\nimport { Angle, Point3d, Point2d, Vector3d, YawPitchRollAngles, XYAndZ, XAndY, Matrix3d, Transform, Arc3d, AngleSweep } from \"@bentley/geometry-core\";\nimport { JsonUtils } from \"@bentley/bentleyjs-core\";\nimport { ElementState } from \"./EntityState\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { ViewState } from \"./ViewState\";\nimport { DecorateContext } from \"./ViewContext\";\nimport { GraphicBuilder, GraphicType } from \"./render/GraphicBuilder\";\nimport { Viewport, CoordSystem } from \"./Viewport\";\n\n/** @public */\nexport enum ACSType {\n  None = 0,\n  Rectangular = 1,\n  Cylindrical = 2,\n  Spherical = 3,\n}\n\n/** @public */\nexport enum ACSDisplayOptions {\n  None = 0, // used for testing individual bits.\n  Active = (1 << 0),\n  Deemphasized = (1 << 1),\n  Hilite = (1 << 2),\n  CheckVisible = (1 << 3),\n  Dynamics = (1 << 4),\n}\n\nconst enum ACSDisplaySizes {\n  TriadSizeInches = 0.6,\n  ArrowBaseStart = 0.3,\n  ArrowBaseWidth = 0.2,\n  ArrowTipEnd = 1.25,\n  ArrowTipStart = 0.85,\n  ArrowTipFlange = 0.75,\n  ArrowTipWidth = 0.4,\n  ZAxisLength = 0.65,\n  LabelStart = 0.4,\n  LabelEnd = 0.8,\n  LabelWidth = 0.15,\n}\n\n/** The state of an AuxCoordSystem element in the frontend\n * @public\n */\nexport abstract class AuxCoordSystemState extends ElementState implements AuxCoordSystemProps {\n  /** @internal */\n  public static get className() { return \"AuxCoordSystem\"; }\n  public type: number;\n  public description?: string;\n\n  public static fromProps(props: AuxCoordSystemProps, iModel: IModelConnection): AuxCoordSystemState {\n    const name = props.classFullName.toLowerCase();\n    if (name.endsWith(\"system2d\"))\n      return new AuxCoordSystem2dState(props, iModel);\n\n    if (name.endsWith(\"system3d\"))\n      return new AuxCoordSystem3dState(props, iModel);\n\n    return new AuxCoordSystemSpatialState(props, iModel);\n  }\n\n  /** Create a new AuxCoordSystemState.\n   * @param acsName the name for the new AuxCoordSystem\n   * @param iModel the iModel for which the ACS applies.\n   * @note call this method with the appropriate subclass (e.g. AuxCoordSystemSpatialState, AuxCoordSystem2dState, etc), not on AuxCoordSystemState directly\n   */\n  public static createNew(acsName: string, iModel: IModelConnection): AuxCoordSystemState {\n    const myCode = new Code({ spec: BisCodeSpec.auxCoordSystemSpatial, scope: IModel.dictionaryId.toString(), value: acsName });\n    return new AuxCoordSystemSpatialState({ model: IModel.dictionaryId, code: myCode, classFullName: this.classFullName }, iModel);\n  }\n\n  public constructor(props: AuxCoordSystemProps, iModel: IModelConnection) {\n    super(props, iModel);\n    this.type = JsonUtils.asInt(props.type, ACSType.None);\n    this.description = props.description;\n  }\n  public toJSON(): AuxCoordSystemProps {\n    const val = super.toJSON() as AuxCoordSystemProps;\n    val.type = this.type;\n    val.description = this.description;\n    return val;\n  }\n\n  public isValidForView(view: ViewState): boolean {\n    if (view.isSpatialView())\n      return this instanceof AuxCoordSystemSpatialState;\n    return (view.is3d() === this.is3d);\n  }\n\n  public abstract getOrigin(result?: Point3d): Point3d;\n  public abstract setOrigin(val: XYAndZ | XAndY): void;\n  /** get a *copy of* the rotation matrix for this ACS. */\n  public abstract getRotation(result?: Matrix3d): Matrix3d;\n  public abstract setRotation(val: Matrix3d): void;\n  public get is3d(): boolean { return this instanceof AuxCoordSystem3dState; }\n\n  public drawGrid(context: DecorateContext): void {\n    // Called for active ACS when grid orientation is GridOrientationType::ACS.\n    const view = context.viewport.view;\n    const fixedRepsAuto = Point2d.create(); // limit grid to project extents\n    context.drawStandardGrid(this.getOrigin(), this.getRotation(), view.getGridSpacing(), view.getGridsPerRef(), false, fixedRepsAuto);\n  }\n\n  /** Returns the value, clamped to the supplied range. */\n  private static limitRange(min: number, max: number, val: number): number { return Math.max(min, Math.min(max, val)); }\n\n  /**\n   * Given an origin point, returns whether the point falls within the view or not. If adjustOrigin is set to true, a point outside\n   * the view will be modified to fall within the appropriate range.\n   */\n  public static isOriginInView(drawOrigin: Point3d, viewport: Viewport, adjustOrigin: boolean): boolean {\n    const testPtView = viewport.worldToView(drawOrigin);\n    const frustum = viewport.getFrustum(CoordSystem.View);\n    const screenRange = Point3d.create();\n    screenRange.x = frustum.points[Npc._000].distance(frustum.points[Npc._100]);\n    screenRange.y = frustum.points[Npc._000].distance(frustum.points[Npc._010]);\n    screenRange.z = frustum.points[Npc._000].distance(frustum.points[Npc._001]);\n\n    // Check if current acs origin is outside view...\n    const inView = (!((testPtView.x < 0 || testPtView.x > screenRange.x) || (testPtView.y < 0 || testPtView.y > screenRange.y)));\n\n    if (!adjustOrigin)\n      return inView;\n\n    if (!inView) {\n      const offset = viewport.pixelsFromInches(ACSDisplaySizes.TriadSizeInches);\n      testPtView.x = AuxCoordSystemState.limitRange(offset, screenRange.x - offset, testPtView.x);\n      testPtView.y = AuxCoordSystemState.limitRange(offset, screenRange.y - offset, testPtView.y);\n    }\n\n    // Limit point to NPC box to prevent triad from being clipped from display...\n    const originPtNpc = viewport.viewToNpc(testPtView);\n    originPtNpc.x = AuxCoordSystemState.limitRange(0, 1, originPtNpc.x);\n    originPtNpc.y = AuxCoordSystemState.limitRange(0, 1, originPtNpc.y);\n    originPtNpc.z = AuxCoordSystemState.limitRange(0, 1, originPtNpc.z);\n    viewport.npcToView(originPtNpc, testPtView);\n    viewport.viewToWorld(testPtView, drawOrigin);\n\n    return inView;\n  }\n\n  private getAdjustedColor(inColor: ColorDef, isFill: boolean, viewport: Viewport, options: ACSDisplayOptions): ColorDef {\n    const color = new ColorDef();\n\n    if ((options & ACSDisplayOptions.Hilite) !== ACSDisplayOptions.None) {\n      color.setFrom(viewport.hilite.color);\n    } else if ((options & ACSDisplayOptions.Active) !== ACSDisplayOptions.None) {\n      color.setFrom(inColor.equals(ColorDef.white) ? viewport.getContrastToBackgroundColor() : inColor);\n    } else {\n      color.colors.r = 150;\n      color.colors.g = 150;\n      color.colors.b = 150;\n      color.colors.t = 0;\n    }\n\n    color.adjustForContrast(viewport.view.backgroundColor);\n\n    if (isFill)\n      color.setTransparency((options & (ACSDisplayOptions.Deemphasized | ACSDisplayOptions.Dynamics)) !== ACSDisplayOptions.None ? 225 : 200);\n    else\n      color.setTransparency((options & ACSDisplayOptions.Deemphasized) !== ACSDisplayOptions.None ? 150 : 75);\n\n    return color;\n  }\n\n  private addAxisLabel(builder: GraphicBuilder, axis: number, options: ACSDisplayOptions, vp: Viewport) {\n    const color = ColorDef.white;\n    const lineColor = this.getAdjustedColor(color, false, vp, options);\n    builder.setSymbology(lineColor, lineColor, 2);\n\n    const linePts1: Point3d[] = [];\n    if (0 === axis) {\n      linePts1[0] = Point3d.create(ACSDisplaySizes.LabelStart, -ACSDisplaySizes.LabelWidth);\n      linePts1[1] = Point3d.create(ACSDisplaySizes.LabelEnd, ACSDisplaySizes.LabelWidth);\n    } else {\n      linePts1[0] = Point3d.create(0.0, ACSDisplaySizes.LabelStart);\n      linePts1[1] = Point3d.create(0.0, (ACSDisplaySizes.LabelStart + ACSDisplaySizes.LabelEnd) * 0.5);\n    }\n    builder.addLineString(linePts1);\n\n    const linePts2: Point3d[] = []; // NOTE: Don't use same point array, addPointString/addLineString don't deep copy...\n    if (0 === axis) {\n      linePts2[0] = Point3d.create(ACSDisplaySizes.LabelStart, ACSDisplaySizes.LabelWidth);\n      linePts2[1] = Point3d.create(ACSDisplaySizes.LabelEnd, -ACSDisplaySizes.LabelWidth);\n    } else {\n      linePts2[0] = Point3d.create(ACSDisplaySizes.LabelWidth, ACSDisplaySizes.LabelEnd);\n      linePts2[1] = Point3d.create(0.0, (ACSDisplaySizes.LabelStart + ACSDisplaySizes.LabelEnd) * 0.5);\n      linePts2[2] = Point3d.create(-ACSDisplaySizes.LabelWidth, ACSDisplaySizes.LabelEnd);\n    }\n    builder.addLineString(linePts2);\n  }\n\n  private addAxis(builder: GraphicBuilder, axis: number, options: ACSDisplayOptions, vp: Viewport) {\n    const color = (0 === axis ? ColorDef.red : (1 === axis ? ColorDef.green : ColorDef.blue));\n    const lineColor = this.getAdjustedColor(color, false, vp, options);\n    const fillColor = this.getAdjustedColor(color, true, vp, options);\n\n    if (axis === 2) {\n      builder.setSymbology(lineColor, lineColor, 6);\n      builder.addPointString([Point3d.create(0.0, 0.0, ACSDisplaySizes.ZAxisLength)]); // NOTE: ACS origin point will be drawn separately as a pickable world decoration...\n\n      const linePts2: Point3d[] = [Point3d.create(), Point3d.create()]; // NOTE: Don't use same point array, addPointString/addLineString don't deep copy...\n      linePts2[1].z = ACSDisplaySizes.ZAxisLength;\n      builder.setSymbology(lineColor, lineColor, 1, (options & ACSDisplayOptions.Dynamics) === ACSDisplayOptions.None ? LinePixels.Solid : LinePixels.Code2);\n      builder.addLineString(linePts2);\n\n      const scale = ACSDisplaySizes.ArrowTipWidth / 2;\n      const center = Point3d.create();\n      const viewRMatrix = vp.rotation;\n\n      const xVec = viewRMatrix.getRow(0);\n      const yVec = viewRMatrix.getRow(1);\n\n      builder.placement.matrix.multiplyTransposeVectorInPlace(xVec);\n      builder.placement.matrix.multiplyTransposeVectorInPlace(yVec);\n\n      xVec.normalize(xVec);\n      yVec.normalize(yVec);\n\n      const ellipse = Arc3d.createScaledXYColumns(center, Matrix3d.createColumns(xVec, yVec, Vector3d.create()), scale, scale, AngleSweep.createStartEnd(Angle.createRadians(0), Angle.createRadians(Math.PI * 2)));\n      builder.addArc(ellipse, false, false);\n\n      builder.setBlankingFill(fillColor);\n      builder.addArc(ellipse, true, true);\n      return;\n    }\n\n    const shapePts: Point3d[] = [];\n    shapePts[0] = Point3d.create(ACSDisplaySizes.ArrowTipEnd, 0.0);\n    shapePts[1] = Point3d.create(ACSDisplaySizes.ArrowTipFlange, ACSDisplaySizes.ArrowTipWidth);\n    shapePts[2] = Point3d.create(ACSDisplaySizes.ArrowTipStart, ACSDisplaySizes.ArrowBaseWidth);\n    shapePts[3] = Point3d.create(ACSDisplaySizes.ArrowBaseStart, ACSDisplaySizes.ArrowBaseWidth);\n    shapePts[4] = Point3d.create(ACSDisplaySizes.ArrowBaseStart, -ACSDisplaySizes.ArrowBaseWidth);\n    shapePts[5] = Point3d.create(ACSDisplaySizes.ArrowTipStart, -ACSDisplaySizes.ArrowBaseWidth);\n    shapePts[6] = Point3d.create(ACSDisplaySizes.ArrowTipFlange, -ACSDisplaySizes.ArrowTipWidth);\n    shapePts[7] = shapePts[0].clone();\n    if (1 === axis) { shapePts.forEach((tmpPt) => { tmpPt.set(tmpPt.y, tmpPt.x); }); }\n\n    builder.setSymbology(lineColor, lineColor, 1, (options & ACSDisplayOptions.Dynamics) === ACSDisplayOptions.None ? LinePixels.Solid : LinePixels.Code2);\n    builder.addLineString(shapePts);\n\n    this.addAxisLabel(builder, axis, options, vp);\n\n    builder.setBlankingFill(fillColor);\n    builder.addShape(shapePts);\n  }\n\n  /** Returns a GraphicBuilder for this AuxCoordSystemState. */\n  private createGraphicBuilder(context: DecorateContext, options: ACSDisplayOptions): GraphicBuilder {\n    const checkOutOfView = (options & ACSDisplayOptions.CheckVisible) !== ACSDisplayOptions.None;\n    const drawOrigin = this.getOrigin();\n\n    if (checkOutOfView && !AuxCoordSystemState.isOriginInView(drawOrigin, context.viewport, true))\n      options = options | ACSDisplayOptions.Deemphasized;\n\n    let pixelSize = context.viewport.pixelsFromInches(ACSDisplaySizes.TriadSizeInches);\n\n    if ((options & ACSDisplayOptions.Deemphasized) !== ACSDisplayOptions.None)\n      pixelSize *= 0.8;\n    else if ((options & ACSDisplayOptions.Active) !== ACSDisplayOptions.None)\n      pixelSize *= 0.9;\n\n    const exagg = context.viewport.view.getAspectRatioSkew();\n    const scale = context.getPixelSizeAtPoint(drawOrigin) * pixelSize;\n    const rMatrix = this.getRotation();\n    rMatrix.inverse(rMatrix);\n    rMatrix.scaleRows(scale, scale / exagg, scale, rMatrix);\n    const transform = Transform.createOriginAndMatrix(drawOrigin, rMatrix);\n\n    const builder = context.createGraphicBuilder(GraphicType.WorldOverlay, transform);\n    const vp = context.viewport;\n    this.addAxis(builder, 0, options, vp);\n    this.addAxis(builder, 1, options, vp);\n    this.addAxis(builder, 2, options, vp);\n    return builder;\n  }\n\n  public display(context: DecorateContext, options: ACSDisplayOptions) {\n    const builder = this.createGraphicBuilder(context, options);\n    if (undefined !== builder)\n      context.addDecorationFromBuilder(builder);\n  }\n}\n\n/** The state of an AuxCoordSystem2d element in the frontend\n * @public\n */\nexport class AuxCoordSystem2dState extends AuxCoordSystemState implements AuxCoordSystem2dProps {\n  /** @internal */\n  public static get className() { return \"AuxCoordSystem2d\"; }\n  public readonly origin: Point2d;\n  public angle: number; // in degrees\n  private readonly _rMatrix: Matrix3d;\n\n  constructor(props: AuxCoordSystem2dProps, iModel: IModelConnection) {\n    super(props, iModel);\n    this.origin = Point2d.fromJSON(props.origin);\n    this.angle = JsonUtils.asDouble(props.angle);\n    this._rMatrix = Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createDegrees(this.angle))!;\n  }\n\n  public toJSON(): AuxCoordSystem2dProps {\n    const val = super.toJSON() as AuxCoordSystem2dProps;\n    val.origin = this.origin;\n    val.angle = this.angle;\n    return val;\n  }\n\n  public getOrigin(result?: Point3d): Point3d { return Point3d.createFrom(this.origin, result); }\n  public setOrigin(val: XYAndZ | XAndY): void { this.origin.setFrom(val); }\n  public getRotation(result?: Matrix3d): Matrix3d { return this._rMatrix.clone(result); }\n  public setRotation(val: Matrix3d): void {\n    this._rMatrix.setFrom(val);\n    this.angle = YawPitchRollAngles.createFromMatrix3d(val)!.yaw.degrees;\n  }\n}\n\n/** The state of an AuxCoordSystem3d element in the frontend\n * @public\n */\nexport class AuxCoordSystem3dState extends AuxCoordSystemState implements AuxCoordSystem3dProps {\n  /** @internal */\n  public static get className() { return \"AuxCoordSystem3d\"; }\n  public readonly origin: Point3d;\n  public yaw: number; // in degrees\n  public pitch: number; // in degrees\n  public roll: number; // in degrees\n  private readonly _rMatrix: Matrix3d;\n\n  constructor(props: AuxCoordSystem3dProps, iModel: IModelConnection) {\n    super(props, iModel);\n    this.origin = Point3d.fromJSON(props.origin);\n    this.yaw = JsonUtils.asDouble(props.yaw);\n    this.pitch = JsonUtils.asDouble(props.pitch);\n    this.roll = JsonUtils.asDouble(props.roll);\n    const angles = new YawPitchRollAngles(Angle.createDegrees(this.yaw), Angle.createDegrees(this.pitch), Angle.createDegrees(this.roll));\n    this._rMatrix = angles.toMatrix3d();\n  }\n\n  public toJSON(): AuxCoordSystem3dProps {\n    const val = super.toJSON() as AuxCoordSystem3dProps;\n    val.origin = this.origin;\n    val.yaw = this.yaw;\n    val.pitch = this.pitch;\n    val.roll = this.roll;\n    return val;\n  }\n\n  public getOrigin(result?: Point3d): Point3d { return Point3d.createFrom(this.origin, result); }\n  public setOrigin(val: XYAndZ | XAndY): void { this.origin.setFrom(val); }\n  public getRotation(result?: Matrix3d): Matrix3d { return this._rMatrix.clone(result); }\n  public setRotation(rMatrix: Matrix3d): void {\n    this._rMatrix.setFrom(rMatrix);\n    const angles = YawPitchRollAngles.createFromMatrix3d(rMatrix)!;\n    this.yaw = angles.yaw.degrees;\n    this.pitch = angles.pitch.degrees;\n    this.roll = angles.roll.degrees;\n  }\n}\n\n/** The state of an AuxCoordSystemSpatial element in the frontend\n * @public\n */\nexport class AuxCoordSystemSpatialState extends AuxCoordSystem3dState {\n  /** @internal */\n  public static get className() { return \"AuxCoordSystemSpatial\"; }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\nimport { Id64, Id64Arg, Id64String } from \"@bentley/bentleyjs-core\";\nimport { ElementState } from \"./EntityState\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { CategorySelectorProps } from \"@bentley/imodeljs-common\";\n\n/** A set of Categories to be displayed in a [[ViewState]].\n * Elements belonging to categories not specified in the category selector will not be drawn in the view.\n * By default, geometry belonging to any [[SubCategory]] of a visible Category is also visible in the view,\n * unless the [[SubCategoryAppearance]] or [[SubCategoryOverride]] specifies that it should be invisible.\n * @note To change the set of categories visible in a [[ViewState]] currently associated with a [[Viewport]],\n * use [[ViewState.changeCategoryDisplay]] to ensure the view updates appropriately on screen.\n * @see [[Category]]\n * @public\n */\nexport class CategorySelectorState extends ElementState {\n  /** @internal */\n  public static get className() { return \"CategorySelector\"; }\n  public categories: Set<string> = new Set<string>();\n  constructor(props: CategorySelectorProps, iModel: IModelConnection) {\n    super(props, iModel);\n    if (props.categories)\n      props.categories.forEach((cat) => this.categories.add(cat));\n  }\n\n  public toJSON(): CategorySelectorProps {\n    const val = super.toJSON() as CategorySelectorProps;\n    val.categories = [];\n    this.categories.forEach((cat) => val.categories.push(cat));\n    return val;\n  }\n\n  /** Returns true if this category selector is logically equivalent to the specified category selector.\n   * Two category selectors are logically equivalent if they have the same name and Id and contain the same set of category Ids.\n   */\n  public equalState(other: CategorySelectorState): boolean {\n    if (this.categories.size !== other.categories.size || this.name !== other.name || this.id !== other.id)\n      return false;\n\n    const otherIter = other.categories.keys();\n    let otherRes = otherIter.next();\n    for (let thisIter = this.categories.keys(), thisRes = thisIter.next(); !thisRes.done; thisRes = thisIter.next(), otherRes = otherIter.next()) {\n      if (thisRes.value !== otherRes.value)\n        return false;\n    }\n\n    return true;\n  }\n\n  /** The name of this CategorySelector */\n  public get name(): string { return this.code.getValue(); }\n\n  /** Determine whether this CategorySelector includes the specified categoryId string */\n  public has(id: Id64String): boolean { return this.categories.has(id.toString()); }\n\n  /** Determine whether this CategorySelector includes the specified category */\n  public isCategoryViewed(categoryId: Id64String): boolean { return this.has(categoryId); }\n\n  /** Add one or more categories to this CategorySelector */\n  public addCategories(arg: Id64Arg): void {\n    Id64.forEach(arg, (id) => this.categories.add(id));\n  }\n\n  /** Remove one or more categories from this CategorySelector */\n  public dropCategories(arg: Id64Arg) {\n    Id64.forEach(arg, (id) => this.categories.delete(id));\n  }\n\n  /** Add or remove categories from this CategorySelector.\n   * @param arg The categories to add or remove\n   * @param add If true, categories will be added; otherwise they will be removed.\n   */\n  public changeCategoryDisplay(arg: Id64Arg, add: boolean): void { if (add) this.addCategories(arg); else this.dropCategories(arg); }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\nimport { ContextRealityModelProps, CartographicRange } from \"@bentley/imodeljs-common\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { IModelApp } from \"./IModelApp\";\nimport { AuthorizedFrontendRequestContext } from \"./FrontendRequestContext\";\nimport { TileTreeModelState, SpatialModelState } from \"./ModelState\";\nimport { TileTree, TileTreeState } from \"./tile/TileTree\";\nimport { RealityModelTileTree, RealityModelTileClient, RealityModelTileUtils } from \"./tile/RealityModelTileTree\";\nimport { RealityDataServicesClient, RealityData, AccessToken } from \"@bentley/imodeljs-clients\";\nimport { Id64String } from \"@bentley/bentleyjs-core\";\n\n/** @internal */\nexport class ContextRealityModelState implements TileTreeModelState {\n  protected _tilesetUrl: string;\n  protected _name: string;\n  protected _tileTreeState: TileTreeState;\n  protected _iModel: IModelConnection;\n  protected _modelId: Id64String;\n  protected _jsonProperties: { [key: string]: any };\n  constructor(props: ContextRealityModelProps, iModel: IModelConnection) {\n    this._name = props.name ? props.name : \"\";\n    this._tilesetUrl = props.tilesetUrl;\n    this._tileTreeState = iModel.getContextRealityModelTileTree(this._tilesetUrl);\n    this._modelId = this._tileTreeState.modelId;\n    this._iModel = iModel;\n    this._jsonProperties = { classifiers: props.classifiers };\n  }\n  public get name() { return this._name; }\n  public get url() { return this._tilesetUrl; }\n  public get tileTree(): TileTree | undefined { return this._tileTreeState.tileTree; }\n  public get loadStatus(): TileTree.LoadStatus { return this._tileTreeState.loadStatus; }\n  public get treeModelId(): Id64String { return this._modelId; }\n  public get jsonProperties() { return this._jsonProperties; }\n  public get iModel() { return this._iModel; }\n  public loadTree(_edgesRequired: boolean, _animationId?: Id64String): TileTree.LoadStatus {\n    const tileTreeState = this._tileTreeState;\n    if (TileTree.LoadStatus.NotLoaded !== tileTreeState.loadStatus)\n      return tileTreeState.loadStatus;\n\n    tileTreeState.loadStatus = TileTree.LoadStatus.Loading;\n\n    RealityModelTileTree.loadRealityModelTileTree(this._tilesetUrl, undefined, tileTreeState);\n    return tileTreeState.loadStatus;\n  }\n\n  private static async getAccessToken(): Promise<AccessToken | undefined> {\n    if (!IModelApp.authorizationClient || !IModelApp.authorizationClient.hasSignedIn)\n      return undefined; // Not signed in\n    let accessToken: AccessToken;\n    try {\n      accessToken = await IModelApp.authorizationClient.getAccessToken();\n    } catch (error) {\n      return undefined;\n    }\n    return accessToken;\n  }\n\n  /**\n   * Indicates if the reality model overlaps the project extent\n   * @returns a bool that indicates if the model and the reality data overlap\n   */\n  public async intersectsProjectExtents(): Promise<boolean> {\n    if (undefined === this._iModel.ecefLocation)\n      return false;\n\n    const accessToken = await ContextRealityModelState.getAccessToken();\n    if (!accessToken)\n      return false;\n\n    const client = new RealityModelTileClient(this._tilesetUrl, accessToken);\n    const json = await client.getRootDocument(this._tilesetUrl);\n    let tileTreeRange, tileTreeTransform;\n    if (json === undefined ||\n      undefined === json.root ||\n      undefined === (tileTreeRange = RealityModelTileUtils.rangeFromBoundingVolume(json.root.boundingVolume)) ||\n      undefined === (tileTreeTransform = RealityModelTileUtils.transformFromJson(json.root.transform)))\n      return false;\n\n    const treeCartographicRange = new CartographicRange(tileTreeRange, tileTreeTransform);\n    const projectCartographicRange = new CartographicRange(this._iModel.projectExtents, this._iModel.ecefLocation.getTransform());\n\n    return treeCartographicRange.intersectsRange(projectCartographicRange);\n  }\n  /**\n   * Gets a tileset's tile data blob key url\n   * @param other Another ContextRealityModelState object to compare with self.\n   * @returns a bool that indicates if the two match\n   */\n  public matches(other: ContextRealityModelState) {\n    return other.name === this.name && other.url === this.url;\n  }\n  /**\n   * Returns a list of reality data associated to the given CONNECT project\n   * @param projectId id of associated connect project\n   * @param modelCartographicRange optional cartographic range of the model that can limit the spatial range for the search\n   * @returns a list of reality model properties associated with the project\n   */\n  public static async findAvailableRealityModels(projectid: string, modelCartographicRange?: CartographicRange | undefined): Promise<ContextRealityModelProps[]> { return ContextRealityModelState.findAvailableUnattachedRealityModels(projectid, undefined, modelCartographicRange); }\n\n  /**\n   * Returns a list of reality data associated to the given CONNECT project - but filters out any reality sets that are directly attached to the iModel.\n   * @param projectId id of associated connect project\n   * @param iModel the iModel -- reality data sets attached to this model will be excluded from the returned list.\n   * @param modelCartographicRange optional cartographic range of the model that can limit the spatial range for the search\n   * @returns a list of reality model properties associated with the project\n   */\n  public static async findAvailableUnattachedRealityModels(projectid: string, iModel?: IModelConnection, modelCartographicRange?: CartographicRange | undefined): Promise<ContextRealityModelProps[]> {\n    const availableRealityModels: ContextRealityModelProps[] = [];\n\n    const accessToken: AccessToken | undefined = await ContextRealityModelState.getAccessToken();\n    if (!accessToken)\n      return availableRealityModels;\n\n    const requestContext = await AuthorizedFrontendRequestContext.create();\n    requestContext.enter();\n\n    const client = new RealityDataServicesClient();\n\n    let realityData: RealityData[];\n    if (modelCartographicRange) {\n      const iModelRange = modelCartographicRange.getLongitudeLatitudeBoundingBox();\n      realityData = await client.getRealityDataInProjectOverlapping(requestContext, projectid, iModelRange);\n    } else {\n      realityData = await client.getRealityDataInProject(requestContext, projectid);\n    }\n    requestContext.enter();\n\n    // Get set of URLs that are directly attached to the model.\n    const modelRealityDataIds = new Set<string>();\n    if (iModel) {\n      const query = { from: SpatialModelState.classFullName, wantPrivate: false };\n      const props = await iModel.models.queryProps(query);\n      for (const prop of props)\n        if (prop.jsonProperties !== undefined && prop.jsonProperties.tilesetUrl) {\n          const realityDataId = client.getRealityDataIdFromUrl(prop.jsonProperties.tilesetUrl);\n          if (realityDataId)\n            modelRealityDataIds.add(realityDataId);\n        }\n    }\n\n    // We obtain the reality data name, and RDS URL for each RD returned.\n    for (const currentRealityData of realityData) {\n      let realityDataName: string = \"\";\n      let validRd: boolean = true;\n      if (currentRealityData.name && currentRealityData.name !== \"\") {\n        realityDataName = currentRealityData.name as string;\n      } else if (currentRealityData.rootDocument) {\n        // In case root document contains a relative path we only keep the filename\n        const rootDocParts = (currentRealityData.rootDocumentb as string).split(\"/\");\n        realityDataName = rootDocParts[rootDocParts.length - 1];\n      } else {\n        // This case would not occur normally but if it does the RD is considered invalid\n        validRd = false;\n      }\n\n      // If the RealityData is valid then we add it to the list.\n      if (currentRealityData.id && validRd === true) {\n        const url = await client.getRealityDataUrl(requestContext, projectid, currentRealityData.id as string);\n        requestContext.enter();\n        if (!modelRealityDataIds.has(currentRealityData.id as string))\n          availableRealityModels.push({ tilesetUrl: url, name: realityDataName, description: (currentRealityData.description ? currentRealityData.description : \"\") });\n      }\n    }\n    return availableRealityModels;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { LogLevel } from \"@bentley/bentleyjs-core\";\r\nimport { DevToolsRpcInterface, IModelToken, DevToolsStatsOptions } from \"@bentley/imodeljs-common\";\r\n\r\n/**\r\n * Results of the ping test\r\n * @internal\r\n */\r\nexport interface PingTestResult {\r\n  /** Minimum time for the ping response. Set to undefined if any one ping didn't get a response. */\r\n  min: number | undefined;\r\n  /** Maximum time for the ping response, Set to undefined if any one ping didn't get a response. */\r\n  max: number | undefined;\r\n  /** Average time for the ping response. Set to undefined if any one ping didn't get a response. */\r\n  avg: number | undefined;\r\n}\r\n\r\n/**\r\n * Internal diagnostic utility for backends\r\n * @internal\r\n */\r\nexport class DevTools {\r\n\r\n  /** Create a new connection with a specific backend instance.\r\n   * @param iModelToken The iModelToken that identifies that backend instance.\r\n   * Supply a dummy token if contacting the backend without the Orchestrator.\r\n   */\r\n  public static connectToBackendInstance(iModelToken: IModelToken): DevTools {\r\n    return new DevTools(iModelToken);\r\n  }\r\n\r\n  /** Constructor */\r\n  private constructor(private readonly _iModelToken: IModelToken) {\r\n  }\r\n\r\n  /** Measures the round trip times for one or more pings to the backend\r\n   * @param count Number of pings to send to the backend\r\n   * @return Result of ping test.\r\n   */\r\n  public async ping(count: number): Promise<PingTestResult> {\r\n    const pings = new Array<Promise<number | undefined>>(count);\r\n\r\n    const pingFn = async (): Promise<number> => {\r\n      const start = Date.now();\r\n      await DevToolsRpcInterface.getClient().ping(this._iModelToken.toJSON());\r\n      return Promise.resolve(Date.now() - start);\r\n    };\r\n\r\n    for (let ii = 0; ii < count; ii++)\r\n      pings[ii] = pingFn().catch(() => Promise.resolve(undefined));\r\n\r\n    const pingTimes: Array<number | undefined> = await Promise.all(pings);\r\n\r\n    const min: number | undefined = pingTimes.reduce((acc: number | undefined, curr: number | undefined) => {\r\n      if (!acc) return curr;\r\n      if (!curr) return acc;\r\n      return Math.min(acc, curr);\r\n    }, undefined);\r\n\r\n    const max: number | undefined = pingTimes.reduce((acc: number | undefined, curr: number | undefined) => {\r\n      if (typeof acc === \"undefined\") return undefined;\r\n      if (!curr) return curr;\r\n      return Math.max(acc, curr);\r\n    }, 0);\r\n\r\n    const total: number | undefined = pingTimes.reduce((acc: number | undefined, curr: number | undefined) => {\r\n      if (typeof acc === \"undefined\") return undefined;\r\n      if (!curr) return undefined;\r\n      return acc + curr;\r\n    }, 0);\r\n\r\n    const avg = total ? total / count : undefined;\r\n    return { min, max, avg };\r\n  }\r\n\r\n  /** Returns JSON object with backend statistics */\r\n  public async stats(options: DevToolsStatsOptions = DevToolsStatsOptions.FormatUnits): Promise<any> {\r\n    return DevToolsRpcInterface.getClient().stats(this._iModelToken.toJSON(), options);\r\n  }\r\n\r\n  // Returns JSON object with backend versions (application and iModelJs)\r\n  public async versions(): Promise<any> {\r\n    return DevToolsRpcInterface.getClient().versions(this._iModelToken.toJSON());\r\n  }\r\n\r\n  /** Sets up a log level at the backend and returns the old log level */\r\n  public async setLogLevel(inLoggerCategory: string, newLevel: LogLevel): Promise<LogLevel | undefined> {\r\n    return DevToolsRpcInterface.getClient().setLogLevel(this._iModelToken.toJSON(), inLoggerCategory, newLevel);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\nimport {\n  ViewFlags,\n  ColorDef,\n  DisplayStyleProps,\n  RenderTexture,\n  SubCategoryOverride,\n  SkyBoxProps,\n  SkyBoxImageType,\n  SkyCubeProps,\n  EnvironmentProps,\n  GroundPlane,\n  DisplayStyleSettings,\n  DisplayStyle3dSettings,\n  BackgroundMapProps,\n  AnalysisStyle,\n  ContextRealityModelProps,\n  Cartographic,\n} from \"@bentley/imodeljs-common\";\nimport { ElementState } from \"./EntityState\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { JsonUtils, Id64, Id64String, assert } from \"@bentley/bentleyjs-core\";\nimport { RenderSystem, TextureImage, AnimationBranchStates } from \"./render/System\";\nimport { BackgroundMapProvider } from \"./tile/WebMapTileTree\";\nimport { TileTreeModelState } from \"./ModelState\";\nimport { Plane3dByOriginAndUnitNormal, Vector3d, Point3d } from \"@bentley/geometry-core\";\nimport { ContextRealityModelState } from \"./ContextRealityModelState\";\nimport { RenderScheduleState } from \"./RenderScheduleState\";\nimport { Viewport } from \"./Viewport\";\nimport { SpatialClassification } from \"./SpatialClassification\";\nimport { calculateSolarDirection } from \"./SolarCalculate\";\n\n/** A DisplayStyle defines the parameters for 'styling' the contents of a [[ViewState]]\n * @note If the DisplayStyle is associated with a [[ViewState]] which is being rendered inside a [[Viewport]], modifying\n * the DisplayStyle directly will generally not result in immediately visible changes on the screen.\n * [[ViewState]] provides APIs which forward to the DisplayStyle API and also ensure the screen is updated promptly.\n * @public\n */\nexport abstract class DisplayStyleState extends ElementState implements DisplayStyleProps {\n  /** @internal */\n  public static get className() { return \"DisplayStyle\"; }\n  private _backgroundMap: BackgroundMapProvider;\n  private _contextRealityModels: ContextRealityModelState[];\n  private _analysisStyle?: AnalysisStyle;\n  private _scheduleScript?: RenderScheduleState.Script;\n\n  /** The container for this display style's settings. */\n  public abstract get settings(): DisplayStyleSettings;\n\n  /** Construct a new DisplayStyleState from its JSON representation.\n   * @param props JSON representation of the display style.\n   * @param iModel IModelConnection containing the display style.\n   */\n  constructor(props: DisplayStyleProps, iModel: IModelConnection) {\n    super(props, iModel);\n    const styles = this.jsonProperties.styles;\n    const backgroundMap = undefined !== styles ? styles.backgroundMap : undefined;\n    const mapProps = undefined !== backgroundMap ? backgroundMap : {};\n    this._backgroundMap = new BackgroundMapProvider(mapProps, iModel);\n    this._contextRealityModels = [];\n\n    if (styles) {\n      if (styles.contextRealityModels)\n        for (const contextRealityModel of styles.contextRealityModels)\n          this._contextRealityModels.push(new ContextRealityModelState(contextRealityModel, this.iModel));\n\n      if (styles.analysisStyle)\n        this._analysisStyle = AnalysisStyle.fromJSON(styles.analysisStyle);\n      if (styles.scheduleScript)\n        this._scheduleScript = RenderScheduleState.Script.fromJSON(this.id, this.iModel, styles.scheduleScript);\n    }\n  }\n\n  /** Modify the background map display settings.\n   * @param mapProps JSON representation of the new settings.\n   * @see [[ViewFlags.backgroundMap]] for toggling display of the map.\n   * @note Currently the behavior of this method is not ideal.\n   *  - If this display style is associated with a Viewport, you must call Viewport.invalidateScene for the view to display the new map.\n   *  - Any properties omitted from `mapProps` will be reset to their defaults.\n   *  - All loaded tiles will be discarded and new ones will be requested, even if only changing the groundBias.\n   * @alpha\n   */\n  public setBackgroundMap(mapProps: BackgroundMapProps): void {\n    if (!this.backgroundMap.equalsProps(mapProps)) {\n      this._backgroundMap = new BackgroundMapProvider(mapProps, this.iModel);\n      this.settings.backgroundMap = mapProps;\n    }\n  }\n\n  /** @internal */\n  public forEachContextRealityModel(func: (model: TileTreeModelState) => void): void {\n    for (const contextRealityModel of this._contextRealityModels) { func(contextRealityModel); }\n  }\n\n  /** @internal */\n  public async loadContextRealityModels(): Promise<void> {\n    const classifierIds = new Set<Id64String>();\n    for (const contextRealityModel of this._contextRealityModels) {\n      const classifier = SpatialClassification.getClassifierProps(contextRealityModel);\n      if (undefined !== classifier)\n        classifierIds.add(classifier.modelId);\n    }\n    return SpatialClassification.loadClassifiers(classifierIds, this.iModel);\n  }\n  /** Performs logical comparison against another display style. Two display styles are logically equivalent if they have the same name, Id, and settings.\n   * @param other The display style to which to compare.\n   * @returns true if the specified display style is logically equivalent to this display style - i.e., both styles have the same values for all of their settings.\n   */\n  public equalState(other: DisplayStyleState): boolean {\n    if (this.name !== other.name || this.id !== other.id)\n      return false;\n    else\n      return JSON.stringify(this.settings) === JSON.stringify(other.settings);\n  }\n\n  /** @internal */\n  public get backgroundMap() { return this._backgroundMap; }\n\n  /** The name of this DisplayStyle */\n  public get name(): string { return this.code.getValue(); }\n\n  /** Settings controlling display of analytical models.\n   * @note Do not modify the style in place. Clone it and pass the clone to the setter.\n   */\n  public get analysisStyle(): AnalysisStyle | undefined { return this._analysisStyle; }\n  public set analysisStyle(style: AnalysisStyle | undefined) {\n    if (undefined === style) {\n      this._analysisStyle = undefined;\n    } else {\n      if (undefined === this._analysisStyle)\n        this._analysisStyle = AnalysisStyle.fromJSON(style);\n      else\n        this._analysisStyle.copyFrom(style);\n    }\n\n    this.jsonProperties.analysisStyle = this._analysisStyle;\n  }\n\n  /** @internal */\n  public get scheduleScript(): RenderScheduleState.Script | undefined { return this._scheduleScript; }\n\n  /** @internal */\n  public getAnimationBranches(scheduleTime: number): AnimationBranchStates | undefined { return this._scheduleScript === undefined ? undefined : this._scheduleScript.getAnimationBranches(scheduleTime); }\n\n  /** Note - do not push or remove members from contextRealityModelsProperty - use add/remove so that the json properties are kept in synch properly.\n   * @internal\n   */\n  public get contextRealityModels(): ContextRealityModelState[] { return this._contextRealityModels; }\n  /** @internal */\n  public set contextRealityModels(contextRealityModels: ContextRealityModelState[]) { this._contextRealityModels = contextRealityModels; }\n  /** @internal */\n  public addContextRealityModel(contextRealityModel: ContextRealityModelProps, iModel: IModelConnection) {\n    this._contextRealityModels.push(new ContextRealityModelState(contextRealityModel, iModel));\n    if (undefined === this.jsonProperties.contextRealityModels)\n      this.jsonProperties.contextRealityModels = [];\n\n    this.jsonProperties.contextRealityModels.push(contextRealityModel);\n  }\n  /** @internal */\n  public removeContextRealityModel(index: number) {\n    if (index >= this._contextRealityModels.length || !Array.isArray(this.jsonProperties.contextRealityModels) || index >= this.jsonProperties.contextRealityModels.length) {\n      assert(false);\n      return;\n    }\n    this._contextRealityModels.splice(index, 1);\n    this.jsonProperties.contextRealityModels.splice(index, 1);\n  }\n\n  /** @internal */\n  public containsContextRealityModel(contextRealityModel: ContextRealityModelState) {\n    for (const curr of this._contextRealityModels)\n      if (curr.matches(contextRealityModel))\n        return true;\n\n    return false;\n  }\n\n  /** The ViewFlags associated with this style.\n   * @note If this style is associated with a [[ViewState]] attached to a [[Viewport]], use [[ViewState.viewFlags]] to modify the ViewFlags to ensure\n   * the changes are promptly visible on the screen.\n   */\n  public get viewFlags(): ViewFlags { return this.settings.viewFlags; }\n  public set viewFlags(flags: ViewFlags) { this.settings.viewFlags = flags; }\n\n  /** The background color for this DisplayStyle */\n  public get backgroundColor(): ColorDef { return this.settings.backgroundColor; }\n  public set backgroundColor(val: ColorDef) { this.settings.backgroundColor = val; }\n\n  /** The color used to draw geometry in monochrome mode.\n   * @see [[ViewFlags.monochrome]] for enabling monochrome mode.\n   */\n  public get monochromeColor(): ColorDef { return this.settings.monochromeColor; }\n  public set monochromeColor(val: ColorDef) { this.settings.monochromeColor = val; }\n\n  /** @internal */\n  public get backgroundMapPlane(): Plane3dByOriginAndUnitNormal | undefined { return this.viewFlags.backgroundMap ? this.backgroundMap.getPlane() : undefined; }\n\n  /** Returns true if this is a 3d display style. */\n  public is3d(): this is DisplayStyle3dState { return this instanceof DisplayStyle3dState; }\n\n  /** Customize the way geometry belonging to a [[SubCategory]] is drawn by this display style.\n   * @param id The ID of the SubCategory whose appearance is to be overridden.\n   * @param ovr The overrides to apply to the [[SubCategoryAppearance]].\n   * @note If this style is associated with a [[ViewState]] attached to a [[Viewport]], use [[ViewState.overrideSubCategory]] to ensure\n   * the changes are promptly visible on the screen.\n   * @see [[dropSubCategoryOverride]]\n   */\n  public overrideSubCategory(id: Id64String, ovr: SubCategoryOverride) { this.settings.overrideSubCategory(id, ovr); }\n\n  /** Remove any [[SubCategoryOverride]] applied to a [[SubCategoryAppearance]] by this style.\n   * @param id The ID of the [[SubCategory]].\n   * @note If this style is associated with a [[ViewState]] attached to a [[Viewport]], use [[ViewState.dropSubCategoryOverride]] to ensure\n   * the changes are promptly visible on the screen.\n   * @see [[overrideSubCategory]]\n   */\n  public dropSubCategoryOverride(id: Id64String) { this.settings.dropSubCategoryOverride(id); }\n\n  /** Returns true if an [[SubCategoryOverride]s are defined by this style. */\n  public get hasSubCategoryOverride() { return this.settings.hasSubCategoryOverride; }\n\n  /** Obtain the overrides applied to a [[SubCategoryAppearance]] by this style.\n   * @param id The ID of the [[SubCategory]].\n   * @returns The corresponding SubCategoryOverride, or undefined if the SubCategory's appearance is not overridden.\n   * @see [[overrideSubCategory]]\n   */\n  public getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined { return this.settings.getSubCategoryOverride(id); }\n}\n\n/** A display style that can be applied to 2d views.\n * @public\n */\nexport class DisplayStyle2dState extends DisplayStyleState {\n  /** @internal */\n  public static get className() { return \"DisplayStyle2d\"; }\n  private readonly _settings: DisplayStyleSettings;\n\n  public get settings(): DisplayStyleSettings { return this._settings; }\n\n  constructor(props: DisplayStyleProps, iModel: IModelConnection) {\n    super(props, iModel);\n    this._settings = new DisplayStyleSettings(this.jsonProperties);\n  }\n}\n\n/** ###TODO: Generalize this into something like a PromiseOrValue<T> type which can contain\n * either a Promise<T> or a resolved T.\n * This is used to avoid flickering when loading skybox - don't want to load asynchronously unless we have to.\n * @internal\n */\nexport type SkyBoxParams = Promise<SkyBox.CreateParams | undefined> | SkyBox.CreateParams | undefined;\n\n/** The SkyBox is part of an [[Environment]] drawn in the background of spatial views to provide context.\n * Several types of skybox are supported:\n *  - A cube with a texture image mapped to each face;\n *  - A sphere with a single texture image mapped to its surface;\n *  - A sphere with a [[Gradient]] mapped to its surface.\n * @public\n */\nexport abstract class SkyBox implements SkyBoxProps {\n  /** Whether or not the skybox should be displayed. */\n  public display: boolean = false;\n\n  protected constructor(sky?: SkyBoxProps) {\n    this.display = undefined !== sky && JsonUtils.asBool(sky.display, false);\n  }\n\n  public toJSON(): SkyBoxProps {\n    return { display: this.display };\n  }\n\n  /** Instantiate a [[SkyBox]] from its JSON representation. */\n  public static createFromJSON(json?: SkyBoxProps): SkyBox {\n    let imageType = SkyBoxImageType.None;\n    if (undefined !== json && undefined !== json.image && undefined !== json.image.type)\n      imageType = json.image.type;\n\n    let skybox: SkyBox | undefined;\n    switch (imageType) {\n      case SkyBoxImageType.Spherical:\n        skybox = SkySphere.fromJSON(json!);\n        break;\n      case SkyBoxImageType.Cube:\n        skybox = SkyCube.fromJSON(json!);\n        break;\n      case SkyBoxImageType.Cylindrical: // ###TODO...\n        break;\n    }\n\n    return undefined !== skybox ? skybox : new SkyGradient(json);\n  }\n\n  /** @internal */\n  public abstract loadParams(_system: RenderSystem, _iModel: IModelConnection): SkyBoxParams;\n}\n\n/** The SkyBox is part of an [[Environment]] drawn in the background of spatial views to provide context.\n * Several types of skybox are supported:\n *  - A cube with a texture image mapped to each face;\n *  - A sphere with a single texture image mapped to its surface;\n *  - A sphere with a [[Gradient]] mapped to its surface.\n * @public\n */\nexport namespace SkyBox {\n  /** Parameters defining a spherical [[SkyBox]].\n   * @public\n   */\n  export class SphereParams {\n    public constructor(public readonly texture: RenderTexture, public readonly rotation: number) { }\n  }\n\n  /** Parameters used by the [[RenderSystem]] to instantiate a [[SkyBox]].\n   * @public\n   */\n  export class CreateParams {\n    public readonly gradient?: SkyGradient;\n    public readonly sphere?: SphereParams;\n    public readonly cube?: RenderTexture;\n    public readonly zOffset: number;\n\n    private constructor(zOffset: number, gradient?: SkyGradient, sphere?: SphereParams, cube?: RenderTexture) {\n      this.gradient = gradient;\n      this.sphere = sphere;\n      this.cube = cube;\n      this.zOffset = zOffset;\n    }\n\n    public static createForGradient(gradient: SkyGradient, zOffset: number) { return new CreateParams(zOffset, gradient); }\n    public static createForSphere(sphere: SphereParams, zOffset: number) { return new CreateParams(zOffset, undefined, sphere); }\n    public static createForCube(cube: RenderTexture) { return new CreateParams(0.0, undefined, undefined, cube); }\n  }\n}\n\n/** A [[SkyBox]] drawn as a sphere with a gradient mapped to its interior surface.\n * @see [[SkyBox.createFromJSON]]\n * @public\n */\nexport class SkyGradient extends SkyBox {\n  /** If true, a 2-color gradient is used (ground & sky colors only), if false a 4-color gradient is used, defaults to false. */\n  public readonly twoColor: boolean = false;\n  /** The color of the sky (for 4-color gradient is sky color at horizon), defaults to (143, 205, 255). */\n  public readonly skyColor: ColorDef;\n  /** The color of the ground (for 4-color gradient is ground color at horizon), defaults to (120, 143, 125). */\n  public readonly groundColor: ColorDef;\n  /** For 4-color gradient is color of sky at zenith (shown when looking straight up), defaults to (54, 117, 255). */\n  public readonly zenithColor: ColorDef;\n  /** For 4-color gradient is color of ground at nadir (shown when looking straight down), defaults to (40, 15, 0). */\n  public readonly nadirColor: ColorDef;\n  /** Controls speed of gradient change from skyColor to zenithColor (4-color SkyGradient only), defaults to 4.0. */\n  public readonly skyExponent: number = 4.0;\n  /** Controls speed of gradient change from groundColor to nadirColor (4-color SkyGradient only), defaults to 4.0. */\n  public readonly groundExponent: number = 4.0;\n\n  /** Construct a SkyGradient from its JSON representation. */\n  public constructor(sky?: SkyBoxProps) {\n    super(sky);\n\n    sky = sky ? sky : {};\n    this.twoColor = JsonUtils.asBool(sky.twoColor, false);\n    this.groundExponent = JsonUtils.asDouble(sky.groundExponent, 4.0);\n    this.skyExponent = JsonUtils.asDouble(sky.skyExponent, 4.0);\n    this.groundColor = (undefined !== sky.groundColor) ? ColorDef.fromJSON(sky.groundColor) : ColorDef.from(120, 143, 125);\n    this.zenithColor = (undefined !== sky.zenithColor) ? ColorDef.fromJSON(sky.zenithColor) : ColorDef.from(54, 117, 255);\n    this.nadirColor = (undefined !== sky.nadirColor) ? ColorDef.fromJSON(sky.nadirColor) : ColorDef.from(40, 15, 0);\n    this.skyColor = (undefined !== sky.skyColor) ? ColorDef.fromJSON(sky.skyColor) : ColorDef.from(143, 205, 255);\n  }\n\n  public toJSON(): SkyBoxProps {\n    const val = super.toJSON();\n\n    val.twoColor = this.twoColor ? true : undefined;\n    val.groundExponent = this.groundExponent !== 4.0 ? this.groundExponent : undefined;\n    val.skyExponent = this.skyExponent !== 4.0 ? this.skyExponent : undefined;\n\n    val.groundColor = this.groundColor.toJSON();\n    val.zenithColor = this.zenithColor.toJSON();\n    val.nadirColor = this.nadirColor.toJSON();\n    val.skyColor = this.skyColor.toJSON();\n\n    return val;\n  }\n\n  /** @internal */\n  public loadParams(_system: RenderSystem, iModel: IModelConnection): SkyBoxParams {\n    return SkyBox.CreateParams.createForGradient(this, iModel.globalOrigin.z);\n  }\n}\n\n/** A [[SkyBox]] drawn as a sphere with an image mapped to its interior surface.\n * @see [[SkyBox.createFromJSON]]\n * @public\n */\nexport class SkySphere extends SkyBox {\n  /** The Id of a persistent texture element stored in the iModel which supplies the skybox image. */\n  public textureId: Id64String;\n\n  private constructor(textureId: Id64String, display?: boolean) {\n    super({ display });\n    this.textureId = textureId;\n  }\n\n  /** Create a [[SkySphere]] from its JSON representation.\n   * @param json: The JSON representation\n   * @returns A SkySphere, or undefined if the JSON lacks a valid texture Id.\n   */\n  public static fromJSON(json: SkyBoxProps): SkySphere | undefined {\n    const textureId = Id64.fromJSON(undefined !== json.image ? json.image.texture : undefined);\n    return undefined !== textureId && Id64.isValid(textureId) ? new SkySphere(textureId, json.display) : undefined;\n  }\n\n  public toJSON(): SkyBoxProps {\n    const val = super.toJSON();\n    val.image = {\n      type: SkyBoxImageType.Spherical,\n      texture: this.textureId,\n    };\n    return val;\n  }\n\n  /** @internal */\n  public loadParams(system: RenderSystem, iModel: IModelConnection): SkyBoxParams {\n    const rotation = 0.0; // ###TODO: from where do we obtain rotation?\n    const createParams = (tex?: RenderTexture) => undefined !== tex ? SkyBox.CreateParams.createForSphere(new SkyBox.SphereParams(tex, rotation), iModel.globalOrigin.z) : undefined;\n    const texture = system.findTexture(this.textureId, iModel);\n    if (undefined !== texture)\n      return createParams(texture);\n    else\n      return system.loadTexture(this.textureId, iModel).then((tex) => createParams(tex));\n  }\n}\n\n/** A [[SkyBox]] drawn as a cube with an image mapped to each of its interior faces.\n * Each member specifies the Id of a persistent texture element stored in the iModel\n * from which the image mapped to the corresponding face is obtained.\n * @see [[SkyBox.createFromJSON]].\n * @public\n */\nexport class SkyCube extends SkyBox implements SkyCubeProps {\n  /** Id of a persistent texture element stored in the iModel to use for the front side of the skybox cube. */\n  public readonly front: Id64String;\n  /** Id of a persistent texture element stored in the iModel to use for the back side of the skybox cube. */\n  public readonly back: Id64String;\n  /** Id of a persistent texture element stored in the iModel to use for the top of the skybox cube. */\n  public readonly top: Id64String;\n  /** Id of a persistent texture element stored in the iModel to use for the bottom of the skybox cube. */\n  public readonly bottom: Id64String;\n  /** Id of a persistent texture element stored in the iModel to use for the front right of the skybox cube. */\n  public readonly right: Id64String;\n  /** Id of a persistent texture element stored in the iModel to use for the left side of the skybox cube. */\n  public readonly left: Id64String;\n\n  private constructor(front: Id64String, back: Id64String, top: Id64String, bottom: Id64String, right: Id64String, left: Id64String, display?: boolean) {\n    super({ display });\n    this.front = front;\n    this.back = back;\n    this.top = top;\n    this.bottom = bottom;\n    this.right = right;\n    this.left = left;\n  }\n\n  /** Use [[SkyCube.create]].\n   * @internal\n   */\n  public static fromJSON(skyboxJson: SkyBoxProps): SkyCube | undefined {\n    const image = skyboxJson.image;\n    const json = (undefined !== image && image.type === SkyBoxImageType.Cube ? image.textures : undefined) as SkyCubeProps;\n    if (undefined === json)\n      return undefined;\n\n    return this.create(Id64.fromJSON(json.front), Id64.fromJSON(json.back), Id64.fromJSON(json.top), Id64.fromJSON(json.bottom), Id64.fromJSON(json.right), Id64.fromJSON(json.left), skyboxJson.display);\n  }\n\n  public toJSON(): SkyBoxProps {\n    const val = super.toJSON();\n    val.image = {\n      type: SkyBoxImageType.Cube,\n      textures: {\n        front: this.front,\n        back: this.back,\n        top: this.top,\n        bottom: this.bottom,\n        right: this.right,\n        left: this.left,\n      },\n    };\n    return val;\n  }\n\n  /** Create and return a SkyCube. (Calls the SkyCube constructor after validating the Ids passed in for the images.)\n   * @param front The Id of the image to use for the front side of the sky cube.\n   * @param back The Id of the image to use for the back side of the sky cube.\n   * @param top The Id of the image to use for the top side of the sky cube.\n   * @param bottom The Id of the image to use for the bottom side of the sky cube.\n   * @param right The Id of the image to use for the right side of the sky cube.\n   * @param left The Id of the image to use for the left side of the sky cube.\n   * @returns A SkyCube, or undefined if any of the supplied texture Ids are invalid.\n   * @note All Ids must refer to a persistent texture element stored in the iModel.\n   */\n  public static create(front: Id64String, back: Id64String, top: Id64String, bottom: Id64String, right: Id64String, left: Id64String, display?: boolean): SkyCube | undefined {\n    if (!Id64.isValid(front) || !Id64.isValid(back) || !Id64.isValid(top) || !Id64.isValid(bottom) || !Id64.isValid(right) || !Id64.isValid(left))\n      return undefined;\n    else\n      return new SkyCube(front, back, top, bottom, right, left, display);\n  }\n\n  /** @internal */\n  public loadParams(system: RenderSystem, iModel: IModelConnection): SkyBoxParams {\n    // ###TODO: We never cache the actual texture *images* used here to create a single cubemap texture...\n    const textureIds = new Set<string>([this.front, this.back, this.top, this.bottom, this.right, this.left]);\n    const promises = new Array<Promise<TextureImage | undefined>>();\n    for (const textureId of textureIds)\n      promises.push(system.loadTextureImage(textureId, iModel));\n\n    return Promise.all(promises).then((images) => {\n      // ###TODO there's gotta be a simpler way to map the unique images back to their texture Ids...\n      const idToImage = new Map<string, HTMLImageElement>();\n      let index = 0;\n      for (const textureId of textureIds) {\n        const image = images[index++];\n        if (undefined === image || undefined === image.image)\n          return undefined;\n        else\n          idToImage.set(textureId, image.image);\n      }\n\n      const params = new RenderTexture.Params(undefined, RenderTexture.Type.SkyBox);\n      const textureImages = [\n        idToImage.get(this.front)!, idToImage.get(this.back)!, idToImage.get(this.top)!,\n        idToImage.get(this.bottom)!, idToImage.get(this.right)!, idToImage.get(this.left)!,\n      ];\n\n      const texture = system.createTextureFromCubeImages(textureImages[0], textureImages[1], textureImages[2], textureImages[3], textureImages[4], textureImages[5], iModel, params);\n      return undefined !== texture ? SkyBox.CreateParams.createForCube(texture) : undefined;\n    }).catch((_err) => {\n      return undefined;\n    });\n  }\n}\n\n/** Describes the [[SkyBox]] and [[GroundPlane]] associated with a [[DisplayStyle3dState]].\n * @public\n */\nexport class Environment implements EnvironmentProps {\n  public readonly sky: SkyBox;\n  public readonly ground: GroundPlane;\n\n  /** Construct from JSON representation. */\n  public constructor(json?: EnvironmentProps) {\n    this.sky = SkyBox.createFromJSON(undefined !== json ? json.sky : undefined);\n    this.ground = new GroundPlane(undefined !== json ? json.ground : undefined);\n  }\n\n  public toJSON(): EnvironmentProps {\n    return {\n      sky: this.sky.toJSON(),\n      ground: this.ground.toJSON(),\n    };\n  }\n}\n\nfunction isSameSkyBox(a: SkyBoxProps | undefined, b: SkyBoxProps | undefined): boolean {\n  if (undefined === a || undefined === b)\n    return undefined === a && undefined === b;\n  return JSON.stringify(a) === JSON.stringify(b);\n}\n\n/** A [[DisplayStyleState]] that can be applied to spatial views.\n * @public\n */\nexport class DisplayStyle3dState extends DisplayStyleState {\n  /** @internal */\n  public static get className() { return \"DisplayStyle3d\"; }\n  private _skyBoxParams?: SkyBox.CreateParams;\n  private _skyBoxParamsLoaded?: boolean;\n  private _environment?: Environment;\n  private _settings: DisplayStyle3dSettings;\n  private _sunDirection?: Vector3d;\n\n  /** @internal */\n  public clone(iModel: IModelConnection): this {\n    const clone = super.clone(iModel);\n    if (undefined === iModel || this.iModel === iModel) {\n      clone._skyBoxParams = this._skyBoxParams;\n      clone._skyBoxParamsLoaded = this._skyBoxParamsLoaded;\n    }\n\n    return clone;\n  }\n\n  public get settings(): DisplayStyle3dSettings { return this._settings; }\n\n  public constructor(props: DisplayStyleProps, iModel: IModelConnection) {\n    super(props, iModel);\n    this._settings = new DisplayStyle3dSettings(this.jsonProperties);\n    const styles = this.jsonProperties.styles;\n    if (styles.sceneLights && styles.sceneLights.sunDir)\n      this._sunDirection = Vector3d.fromJSON(styles.sceneLights.sunDir);\n  }\n\n  /** The [[SkyBox]] and [[GroundPlane]] settings for this style. */\n  public get environment(): Environment {\n    if (undefined === this._environment)\n      this._environment = new Environment(this.settings.environment);\n\n    return this._environment;\n  }\n  public set environment(env: Environment) {\n    const prevEnv = this.settings.environment;\n    this.settings.environment = env.toJSON();\n    this._environment = undefined;\n\n    // Regenerate the skybox if the sky settings have changed\n    if (undefined !== this._skyBoxParamsLoaded && !isSameSkyBox(env.sky, prevEnv.sky)) {\n      // NB: We only reset _skyBoxParamsLoaded - keep the previous skybox (if any) to continue drawing until the new one (if any) is ready\n      this._skyBoxParamsLoaded = undefined;\n    }\n  }\n\n  private onLoadSkyBoxParams(params?: SkyBox.CreateParams, vp?: Viewport): void {\n    this._skyBoxParams = params;\n    this._skyBoxParamsLoaded = true;\n    if (undefined !== vp)\n      vp.invalidateDecorations();\n  }\n\n  /** Attempts to create textures for the sky of the environment, and load it into the sky. Returns true on success, and false otherwise.\n   * @internal\n   */\n  public loadSkyBoxParams(system: RenderSystem, vp?: Viewport): SkyBox.CreateParams | undefined {\n    if (undefined === this._skyBoxParamsLoaded) {\n      const params = this.environment.sky.loadParams(system, this.iModel);\n      if (undefined === params || params instanceof SkyBox.CreateParams) {\n        this.onLoadSkyBoxParams(params, vp);\n      } else {\n        this._skyBoxParamsLoaded = false; // indicates we're currently loading them.\n        params.then((result?: SkyBox.CreateParams) => this.onLoadSkyBoxParams(result, vp)).catch((_err) => this.onLoadSkyBoxParams(undefined));\n      }\n    }\n\n    return this._skyBoxParams;\n  }\n  /** @beta */\n  public get sunDirection() { return this._sunDirection; }\n\n  /** set the solar direction based on time value\n   * @param time The time in unix time milliseconds.\n   * @beta\n   */\n  public setSunTime(time: number) {\n    let cartoCenter;\n    if (this.iModel.isGeoLocated) {\n      const projectExtents = this.iModel.projectExtents;\n      const projectCenter = Point3d.createAdd2Scaled(projectExtents.low, .5, projectExtents.high, .5);\n      cartoCenter = this.iModel.spatialToCartographicFromEcef(projectCenter);\n    } else {\n      cartoCenter = Cartographic.fromDegrees(-75.17035, 39.954927, 0.0);\n    }\n\n    this._sunDirection = calculateSolarDirection(new Date(time), cartoCenter);\n\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module LocatingElements */\n\nimport { Id64 } from \"@bentley/bentleyjs-core\";\nimport { Point2d, Point3d } from \"@bentley/geometry-core\";\nimport { HitDetail, HitList, HitPriority, HitSource } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { Pixel } from \"./rendering\";\nimport { InputSource, InteractiveTool } from \"./tools/Tool\";\nimport { ScreenViewport, Viewport, ViewRect } from \"./Viewport\";\n\n/** The possible actions for which a locate filter can be called.\n * @public\n */\nexport enum LocateAction {\n  Identify = 0,\n  AutoLocate = 1,\n}\n\n/** Values to return from a locate filter.\n * Return `Reject` to indicate the element is unacceptable.\n * @public\n */\nexport enum LocateFilterStatus {\n  Accept = 0,\n  Reject = 1,\n}\n\n/** @public */\nexport enum SnapStatus {\n  Success = 0,\n  Aborted = 1,\n  NoElements = 2,\n  Disabled = 100,\n  NoSnapPossible = 200,\n  NotSnappable = 300,\n  FilteredByApp = 600,\n  FilteredByAppQuietly = 700,\n}\n\n/** Options that customize the way element location (i.e. *picking*) works.\n * @public\n */\nexport class LocateOptions {\n  /** If true, also test graphics from view decorations. */\n  public allowDecorations = false;\n  /** If true, also test graphics with non-locatable flag set. */\n  public allowNonLocatable = false;\n  /** Maximum number of hits to return. */\n  public maxHits = 20;\n  /** The [[HitSource]] identifying the caller. */\n  public hitSource = HitSource.DataPoint;\n  /** Make a copy of this LocateOptions. */\n  public clone(): LocateOptions {\n    const other = new LocateOptions();\n    other.allowDecorations = this.allowDecorations;\n    other.allowNonLocatable = this.allowNonLocatable;\n    other.maxHits = this.maxHits;\n    other.hitSource = this.hitSource;\n    return other;\n  }\n  public setFrom(other: LocateOptions): void {\n    this.allowDecorations = other.allowDecorations;\n    this.allowNonLocatable = other.allowNonLocatable;\n    this.maxHits = other.maxHits;\n    this.hitSource = other.hitSource;\n  }\n  public init() { this.allowDecorations = this.allowNonLocatable = false; this.maxHits = 20; this.hitSource = HitSource.DataPoint; }\n}\n\n/** @public */\nexport class LocateResponse {\n  public snapStatus = SnapStatus.Success;\n  public reason?: string;\n  public explanation = \"\";\n}\n\n/** @public */\nexport interface HitListHolder {\n  setHitList(list: HitList<HitDetail> | undefined): void;\n}\n\n/** @public */\nexport class ElementPicker {\n  public viewport?: Viewport;\n  public readonly pickPointWorld = new Point3d();\n  public hitList?: HitList<HitDetail>;\n\n  public empty() {\n    this.pickPointWorld.setZero();\n    this.viewport = undefined;\n    if (this.hitList)\n      this.hitList.empty();\n    else\n      this.hitList = new HitList<HitDetail>();\n  }\n\n  /** return the HitList for the last Pick performed. Optionally allows the caller to take ownership of the list. */\n  public getHitList(takeOwnership: boolean): HitList<HitDetail> {\n    const list = this.hitList!;\n    if (takeOwnership)\n      this.hitList = undefined;\n    return list;\n  }\n\n  public getNextHit(): HitDetail | undefined { return this.hitList ? this.hitList.getNextHit() : undefined; }\n\n  /** Return a hit from the list of hits created the last time pickElements was called. */\n  public getHit(i: number): HitDetail | undefined { return this.hitList ? this.hitList.getHit(i) : undefined; }\n\n  public resetCurrentHit(): void { if (this.hitList) this.hitList.resetCurrentHit(); }\n\n  private getPixelPriority(pixel: Pixel.Data) {\n    switch (pixel.type) {\n      case Pixel.GeometryType.Surface:\n        return Pixel.Planarity.Planar === pixel.planarity ? HitPriority.PlanarSurface : HitPriority.NonPlanarSurface;\n      case Pixel.GeometryType.Linear:\n        return HitPriority.WireEdge;\n      case Pixel.GeometryType.Edge:\n        return Pixel.Planarity.Planar === pixel.planarity ? HitPriority.PlanarEdge : HitPriority.NonPlanarEdge;\n      case Pixel.GeometryType.Silhouette:\n        return HitPriority.SilhouetteEdge;\n      default:\n        return HitPriority.Unknown;\n    }\n  }\n\n  private comparePixel(pixel1: Pixel.Data, pixel2: Pixel.Data, distXY1: number, distXY2: number) {\n    const priority1 = this.getPixelPriority(pixel1);\n    const priority2 = this.getPixelPriority(pixel2);\n    if (priority1 < priority2) return -1;\n    if (priority1 > priority2) return 1;\n    if (distXY1 < distXY2) return -1;\n    if (distXY1 > distXY2) return 1;\n    if (pixel1.distanceFraction > pixel2.distanceFraction) return -1;\n    if (pixel1.distanceFraction < pixel2.distanceFraction) return 1;\n    return 0;\n  }\n\n  /** Generate a list of elements that are close to a given point.\n   * @returns The number of hits in the hitList of this object.\n   */\n  public doPick(vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): number {\n    if (this.hitList && this.hitList.length > 0 && vp === this.viewport && pickPointWorld.isAlmostEqual(this.pickPointWorld)) {\n      this.hitList.resetCurrentHit();\n      return this.hitList.length;\n    }\n\n    this.empty(); // empty the hit list\n    this.viewport = vp;\n    this.pickPointWorld.setFrom(pickPointWorld);\n\n    const pickPointView = vp.worldToView(pickPointWorld);\n    const testPointView = new Point2d(Math.floor(pickPointView.x + 0.5), Math.floor(pickPointView.y + 0.5));\n    const pixelRadius = Math.floor(pickRadiusView + 0.5);\n    const rect = new ViewRect(testPointView.x - pixelRadius, testPointView.y - pixelRadius, testPointView.x + pixelRadius, testPointView.y + pixelRadius);\n    let result: number = 0;\n    vp.readPixels(rect, Pixel.Selector.All, (pixels) => {\n      if (undefined === pixels)\n        return;\n\n      const elmHits = new Map<string, Point2d>();\n      const testPoint = Point2d.createZero();\n      for (testPoint.x = testPointView.x - pixelRadius; testPoint.x <= testPointView.x + pixelRadius; ++testPoint.x) {\n        for (testPoint.y = testPointView.y - pixelRadius; testPoint.y <= testPointView.y + pixelRadius; ++testPoint.y) {\n          const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n          if (undefined === pixel || undefined === pixel.elementId || Id64.isInvalid(pixel.elementId))\n            continue; // no geometry at this location...\n          const distXY = testPointView.distance(testPoint);\n          if (distXY > pixelRadius)\n            continue; // ignore corners. it's a locate circle not square...\n          const oldPoint = elmHits.get(pixel.elementId);\n          if (undefined !== oldPoint) {\n            if (this.comparePixel(pixel, pixels.getPixel(oldPoint.x, oldPoint.y), distXY, testPointView.distance(oldPoint)) < 0)\n              oldPoint.setFrom(testPoint); // new hit is better, update location...\n          } else {\n            elmHits.set(pixel.elementId, testPoint.clone());\n          }\n        }\n      }\n      if (0 === elmHits.size)\n        return;\n\n      for (const elmPoint of elmHits.values()) {\n        const pixel = pixels.getPixel(elmPoint.x, elmPoint.y);\n        if (undefined === pixel || undefined === pixel.elementId)\n          continue;\n        const hitPointWorld = vp.getPixelDataWorldPoint(pixels, elmPoint.x, elmPoint.y);\n        if (undefined === hitPointWorld)\n          continue;\n        const hit = new HitDetail(pickPointWorld, vp, options.hitSource, hitPointWorld, pixel.elementId, this.getPixelPriority(pixel), testPointView.distance(elmPoint), pixel.distanceFraction, pixel.subCategoryId, pixel.geometryClass);\n        this.hitList!.addHit(hit);\n        if (this.hitList!.hits.length > options.maxHits)\n          this.hitList!.hits.length = options.maxHits; // truncate array...\n      }\n      result = this.hitList!.length;\n    }, !options.allowNonLocatable);\n\n    return result;\n  }\n\n  public testHit(hit: HitDetail, vp: ScreenViewport, pickPointWorld: Point3d, pickRadiusView: number, options: LocateOptions): boolean {\n    if (0 === this.doPick(vp, pickPointWorld, pickRadiusView, options))\n      return false;\n\n    return this.hitList!.hits.some((thisHit) => hit.isSameHit(thisHit));\n  }\n}\n\n/** @public */\nexport class ElementLocateManager {\n  public hitList?: HitList<HitDetail>;\n  public currHit?: HitDetail;\n  public readonly options = new LocateOptions();\n  public readonly picker = new ElementPicker();\n\n  /** get the full message key for a locate failure  */\n  public static getFailureMessageKey(key: string) { return \"LocateFailure.\" + key; }\n  public onInitialized() { }\n  public get apertureInches() { return 0.11; }\n  public get touchApertureInches() { return 0.22; }\n\n  public clear(): void { this.setCurrHit(undefined); }\n  public setHitList(list?: HitList<HitDetail>) { this.hitList = list; }\n  public setCurrHit(hit?: HitDetail): void { this.currHit = hit; }\n  public getNextHit(): HitDetail | undefined { return this.hitList ? this.hitList.getNextHit() : undefined; }\n\n  /** return the current path from either the snapping logic or the pre-locating systems. */\n  public getPreLocatedHit(): HitDetail | undefined {\n    // NOTE: Check AccuSnap first as Tentative is used to build intersect snap. For normal snaps when a Tentative is active there should be no AccuSnap.\n    let preLocated = IModelApp.accuSnap.getHitAndList(this);\n\n    if (!preLocated && !!(preLocated = IModelApp.tentativePoint.getHitAndList(this))) {\n      const vp = preLocated.viewport!;\n      this.picker.empty(); // Get new hit list at hit point; want reset to cycle hits using adjusted point location...\n      this.picker.doPick(vp, preLocated.getPoint(), (vp.pixelsFromInches(this.apertureInches) / 2.0) + 1.5, this.options);\n      this.setHitList(this.picker.getHitList(true));\n    }\n\n    if (this.hitList)\n      this.hitList.resetCurrentHit();\n\n    return preLocated;\n  }\n\n  public async filterHit(hit: HitDetail, _action: LocateAction, out: LocateResponse): Promise<LocateFilterStatus> {\n    // Tools must opt-in to locate of transient geometry as it requires special treatment.\n    if (!this.options.allowDecorations && !hit.isElementHit) {\n      out.reason = ElementLocateManager.getFailureMessageKey(\"Transient\");\n      return LocateFilterStatus.Reject;\n    }\n\n    if (undefined !== hit.subCategoryId) {\n      const appearance = hit.viewport.getSubCategoryAppearance(hit.subCategoryId);\n      if (appearance.dontLocate) {\n        out.reason = ElementLocateManager.getFailureMessageKey(\"NotLocatable\");\n        return LocateFilterStatus.Reject;\n      }\n    }\n\n    const tool = IModelApp.toolAdmin.activeTool;\n    if (!(tool && tool instanceof InteractiveTool))\n      return LocateFilterStatus.Accept;\n\n    const status = await tool.filterHit(hit, out);\n    if (LocateFilterStatus.Reject === status)\n      out.reason = ElementLocateManager.getFailureMessageKey(\"ByApp\");\n\n    return status;\n  }\n\n  public initLocateOptions() { this.options.init(); }\n  public initToolLocate() {\n    this.initLocateOptions();\n    this.clear();\n    this.picker.empty();\n    IModelApp.tentativePoint.clear(true);\n  }\n\n  private async _doLocate(response: LocateResponse, newSearch: boolean, testPoint: Point3d, vp: ScreenViewport | undefined, source: InputSource, filterHits: boolean): Promise<HitDetail | undefined> {\n    if (!vp)\n      return;\n\n    // the \"newSearch\" flag indicates whether the caller wants us to conduct a new search at the testPoint, or just continue returning paths from the previous search.\n    if (newSearch) {\n      const hit = this.getPreLocatedHit();\n\n      // if we're snapped to something, that path has the highest priority and becomes the active hit.\n      if (hit) {\n        if (!filterHits || LocateFilterStatus.Accept === await this.filterHit(hit, LocateAction.Identify, response))\n          return hit;\n\n        response = new LocateResponse(); // we have the reason and explanation we want.\n      }\n\n      this.picker.empty();\n      this.picker.doPick(vp, testPoint, (vp.pixelsFromInches(InputSource.Touch === source ? this.touchApertureInches : this.apertureInches) / 2.0) + 1.5, this.options);\n\n      const hitList = this.picker.getHitList(true);\n      this.setHitList(hitList);\n    }\n\n    let newHit: HitDetail | undefined;\n    while (undefined !== (newHit = this.getNextHit())) {\n      if (!filterHits || LocateFilterStatus.Accept === await this.filterHit(newHit, LocateAction.Identify, response))\n        return newHit;\n      response = new LocateResponse(); // we have the reason and explanation we want.\n    }\n\n    return undefined;\n  }\n\n  public async doLocate(response: LocateResponse, newSearch: boolean, testPoint: Point3d, view: ScreenViewport | undefined, source: InputSource, filterHits = true): Promise<HitDetail | undefined> {\n    response.reason = ElementLocateManager.getFailureMessageKey(\"NoElements\");\n    response.explanation = \"\";\n\n    const hit = await this._doLocate(response, newSearch, testPoint, view, source, filterHits);\n    this.setCurrHit(hit);\n\n    // if we found a hit, remove it from the list of remaining hits near the current search point.\n    if (hit && this.hitList)\n      this.hitList.removeHitsFrom(hit.sourceId);\n    return hit;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { FeatureOverrideProvider, Viewport } from \"./Viewport\";\nimport { ColorDef, ColorDefProps, RgbColor } from \"@bentley/imodeljs-common\";\nimport { Id64Set, Id64Arg, Id64 } from \"@bentley/bentleyjs-core\";\nimport { FeatureSymbology } from \"./rendering\";\n\n/** Whether override includes both color and alpha, only color, or only alpha.\n * @internal\n */\nexport enum FeatureOverrideType { ColorOnly, AlphaOnly, ColorAndAlpha }\n\n/** @internal */\nexport interface AppearanceOverrideProps {\n  overrideType?: FeatureOverrideType;\n  color?: ColorDefProps;\n  ids?: Id64Set;\n}\n\n/** @internal */\nexport interface EmphasizeElementsProps {\n  neverDrawn?: Id64Set;\n  alwaysDrawn?: Id64Set;\n  isAlwaysDrawnExclusive?: boolean;\n  alwaysDrawnExclusiveEmphasized?: Id64Set;\n  defaultAppearance?: FeatureSymbology.AppearanceProps;\n  appearanceOverride?: AppearanceOverrideProps[];\n}\n\n/** An implementation of [[FeatureOverrideProvider]] for emphasizing selected elements through simple color/transparency appearance overrides.\n * @internal\n */\nexport class EmphasizeElements implements FeatureOverrideProvider {\n  private _defaultAppearance?: FeatureSymbology.Appearance;\n  private _emphasizeIsolated?: Id64Set;\n  private _overrideAppearance?: Map<number, Id64Set>;\n\n  /** Establish active feature overrides to emphasize elements and apply color/transparency overrides.\n   * @see [[Viewport.featureOverrideProvider]]\n   */\n  public addFeatureOverrides(overrides: FeatureSymbology.Overrides, vp: Viewport): void {\n    const emphasizedElements = this.getEmphasizedElements(vp);\n    if (undefined !== emphasizedElements) {\n      overrides.setDefaultOverrides(this._defaultAppearance!);\n      const app = FeatureSymbology.Appearance.defaults;\n      emphasizedElements.forEach((id) => { overrides.overrideElement(id, app); });\n    }\n    const overriddenElements = this.getOverriddenElements();\n    if (undefined !== overriddenElements) {\n      if (undefined !== this._defaultAppearance)\n        overrides.setDefaultOverrides(this._defaultAppearance);\n      for (const [key, ids] of overriddenElements) {\n        const ovrApp = this.createAppearanceFromKey(key);\n        ids.forEach((id) => { overrides.overrideElement(id, ovrApp); });\n      }\n    }\n  }\n\n  /** @internal */\n  protected createAppearanceFromKey(key: number): FeatureSymbology.Appearance {\n    if (key < 0)\n      return FeatureSymbology.Appearance.fromTransparency(Math.abs(key));\n    const color = ColorDef.fromJSON(key);\n    if (0 === color.getAlpha())\n      return FeatureSymbology.Appearance.fromRgb(color); // Fully transparent signifies to use color only...\n    return FeatureSymbology.Appearance.fromRgba(color);\n  }\n\n  /** Get override key from color and override type */\n  public createOverrideKey(color: ColorDef, override: FeatureOverrideType): number | undefined {\n    const colorValues = color.colors;\n    switch (override) {\n      case FeatureOverrideType.ColorAndAlpha:\n        return 255 === colorValues.t ? undefined : color.tbgr; // Hiding elements should be done using neverDrawn, not transparency...\n      case FeatureOverrideType.ColorOnly:\n        return ColorDef.from(colorValues.r, colorValues.g, colorValues.b, 255).tbgr;\n      case FeatureOverrideType.AlphaOnly:\n        return -(colorValues.t / 255);\n    }\n  }\n\n  /** Get color and override type for the given key. */\n  public getOverrideFromKey(key: number, color: ColorDef): FeatureOverrideType {\n    if (key < 0) {\n      color.setFrom(ColorDef.from(0, 0, 0, 255 * Math.abs(key)));\n      return FeatureOverrideType.AlphaOnly;\n    }\n    color.setFrom(ColorDef.fromJSON(key));\n    if (0 === color.getAlpha()) {\n      color.setAlpha(255);\n      return FeatureOverrideType.ColorOnly;\n    }\n    return FeatureOverrideType.ColorAndAlpha;\n  }\n\n  /** Get the current default appearance such as used by emphasizeElements. */\n  public get defaultAppearance(): FeatureSymbology.Appearance | undefined { return this._defaultAppearance; }\n\n  /** Set the current default appearance for use with overrideElements when not using emphasizeElements. */\n  public set defaultAppearance(appearance: FeatureSymbology.Appearance | undefined) { this._defaultAppearance = appearance; }\n\n  /** Create default appearance to use for emphasizeElements when not supplied by caller. */\n  public createDefaultAppearance(): FeatureSymbology.Appearance {\n    return FeatureSymbology.Appearance.fromJSON({\n      rgb: new RgbColor(0xe4, 0xe4, 0xe4),\n      transparency: 0.8,\n      nonLocatable: true,\n    });\n  }\n\n  /** Get the IDs of the currently never drawn elements. */\n  public getNeverDrawnElements(vp: Viewport): Id64Set | undefined { return (undefined !== vp.neverDrawn && 0 !== vp.neverDrawn.size ? vp.neverDrawn : undefined); }\n  /** Get the IDs of the currently always drawn elements. */\n  public getAlwaysDrawnElements(vp: Viewport): Id64Set | undefined { return (undefined !== vp.alwaysDrawn && 0 !== vp.alwaysDrawn.size ? vp.alwaysDrawn : undefined); }\n  /** Get the IDs of the currently hidden elements. */\n  public getHiddenElements(vp: Viewport): Id64Set | undefined { return this.getNeverDrawnElements(vp); }\n  /** Get the IDs of the currently isolated elements. */\n  public getIsolatedElements(vp: Viewport): Id64Set | undefined { return (vp.isAlwaysDrawnExclusive ? this.getAlwaysDrawnElements(vp) : undefined); }\n  /** Get the IDs of the currently emphasized isolated elements. */\n  public getEmphasizedIsolatedElements(): Id64Set | undefined { return (undefined !== this._defaultAppearance && undefined !== this._emphasizeIsolated && 0 !== this._emphasizeIsolated.size ? this._emphasizeIsolated : undefined); }\n  /** Get the IDs of the currently emphasized elements. */\n  public getEmphasizedElements(vp: Viewport): Id64Set | undefined { return (undefined !== this.getEmphasizedIsolatedElements() ? this._emphasizeIsolated : (undefined !== this._defaultAppearance && !vp.isAlwaysDrawnExclusive ? this.getAlwaysDrawnElements(vp) : undefined)); }\n  /** Get the map of current elements with color/transparency overrides. */\n  public getOverriddenElements(): Map<number, Id64Set> | undefined { return (undefined !== this._overrideAppearance && 0 !== this._overrideAppearance.size ? this._overrideAppearance : undefined); }\n  /** Get the IDs of current elements with the specified color/transparency override. */\n  public getOverriddenElementsByKey(key: number): Id64Set | undefined { return (undefined !== this._overrideAppearance ? this._overrideAppearance.get(key) : undefined); }\n\n  /** Clear never drawn elements.\n   * @return false if nothing to clear.\n   */\n  public clearNeverDrawnElements(vp: Viewport): boolean {\n    if (undefined === this.getNeverDrawnElements(vp))\n      return false;\n    vp.clearNeverDrawn();\n    return true;\n  }\n\n  /** Clear always drawn elements.\n   * @return false if nothing to clear.\n   */\n  public clearAlwaysDrawnElements(vp: Viewport): boolean {\n    if (undefined === this.getAlwaysDrawnElements(vp))\n      return false;\n    vp.clearAlwaysDrawn();\n    return true;\n  }\n\n  /** Clear hidden elements.\n   * @return false if nothing to clear.\n   */\n  public clearHiddenElements(vp: Viewport): boolean {\n    return this.clearNeverDrawnElements(vp);\n  }\n\n  /** Clear isolated elements.\n   * @return false if nothing to clear.\n   */\n  public clearIsolatedElements(vp: Viewport): boolean {\n    if (undefined === this.getIsolatedElements(vp))\n      return false;\n    if (this.clearEmphasizedIsolatedElements(vp, true))\n      return true;\n    return this.clearAlwaysDrawnElements(vp);\n  }\n\n  /** Clear emphasized elements.\n   * @return false if nothing to clear.\n   */\n  public clearEmphasizedElements(vp: Viewport): boolean {\n    if (undefined === this.getEmphasizedElements(vp))\n      return false;\n    if (this.clearEmphasizedIsolatedElements(vp, false))\n      return true;\n    if (!this.clearAlwaysDrawnElements(vp))\n      return false;\n    this._defaultAppearance = undefined;\n    return true;\n  }\n\n  /** Clear emphasized isolated elements.\n   * @return false if nothing to clear.\n   */\n  public clearEmphasizedIsolatedElements(vp: Viewport, setToAlwaysDrawn: boolean): boolean {\n    const emphasizedIsolated = this.getEmphasizedIsolatedElements();\n    this._emphasizeIsolated = undefined; // Always clear in case default appearance was unset...\n    if (undefined === emphasizedIsolated)\n      return false;\n    if (setToAlwaysDrawn && this.setAlwaysDrawnElements(emphasizedIsolated, vp, false))\n      return true;\n    this._defaultAppearance = undefined;\n    vp.setFeatureOverrideProviderChanged();\n    return true;\n  }\n\n  /** Clear elements with color/transparency overrides. Specify key to clear only a single override.\n   * @return false if nothing to clear.\n   */\n  public clearOverriddenElements(vp: Viewport, key?: number): boolean {\n    if (undefined === this._overrideAppearance)\n      return false;\n    if (undefined !== key) {\n      if (!this._overrideAppearance.delete(key))\n        return false;\n    } else {\n      this._overrideAppearance = undefined;\n    }\n    vp.setFeatureOverrideProviderChanged();\n    return true;\n  }\n\n  /** @internal */\n  protected updateIdSet(ids: Id64Arg, replace: boolean, existingIds?: Id64Set): Id64Set | undefined {\n    const newIds = new Set<string>();\n    Id64.toIdSet(ids).forEach((id) => { newIds.add(id); });\n    if (0 === newIds.size)\n      return undefined;\n    const oldSize = (!replace && undefined !== existingIds ? existingIds.size : 0);\n    if (0 !== oldSize && undefined !== existingIds)\n      for (const id of existingIds)\n        newIds.add(id);\n    if (oldSize === newIds.size)\n      return undefined;\n    return newIds;\n  }\n\n  /** Set the element IDs to be never drawn.\n   * @param ids The IDs of the elements to never draw.\n   * @param vp The viewport.\n   * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.\n   * @return true if overrides were changed.\n   * @see [[Viewport.neverDrawn]]\n   * @internal\n   */\n  public setNeverDrawnElements(ids: Id64Arg, vp: Viewport, replace: boolean = true): boolean {\n    const hiddenIds = this.updateIdSet(ids, replace, vp.neverDrawn);\n    if (undefined === hiddenIds)\n      return false;\n    vp.setNeverDrawn(hiddenIds);\n    return true;\n  }\n\n  /** Set the element IDs to be always drawn.\n   * @param ids The IDs of the elements to always draw.\n   * @param vp The viewport.\n   * @param exclusive If true, *only* the specified elements will be drawn.\n   * @param replace true to replace currently always drawn elements (if any) or false to add to the existing set.\n   * @return true if overrides were changed.\n   * @see [[Viewport.alwaysDrawn]]\n   * @see [[Viewport.isAlwaysDrawnExclusive]]\n   * @internal\n   */\n  public setAlwaysDrawnElements(ids: Id64Arg, vp: Viewport, exclusive: boolean = true, replace: boolean = true): boolean {\n    const visibleIds = this.updateIdSet(ids, replace, vp.alwaysDrawn);\n    if (undefined === visibleIds)\n      return false;\n    vp.setAlwaysDrawn(visibleIds, exclusive);\n    return true;\n  }\n\n  /** Set the element IDs to be never drawn.\n   * @param ids The IDs of the elements to never draw.\n   * @param vp The viewport.\n   * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.\n   * @return true if overrides were changed.\n   * @see [[Viewport.neverDrawn]]\n   */\n  public hideElements(ids: Id64Arg, vp: Viewport, replace: boolean = false): boolean {\n    return this.setNeverDrawnElements(ids, vp, replace);\n  }\n\n  /** Set the currently selected elements to be never drawn.\n   * @param vp The viewport.\n   * @param replace true to replace currently hidden elements (if any) or false to add to the existing set.\n   * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.\n   * @return true if overrides were changed.\n   * @see [[Viewport.neverDrawn]]\n   */\n  public hideSelectedElements(vp: Viewport, replace: boolean = false, clearSelection: boolean = true): boolean {\n    const selection = vp.view.iModel.selectionSet;\n    if (!selection.isActive || !this.hideElements(selection.elements, vp, replace))\n      return false;\n    if (clearSelection)\n      selection.emptyAll();\n    return true;\n  }\n\n  /** Set the element IDs to be always drawn exclusively.\n   * @param ids The IDs of the elements to always draw.\n   * @param vp The viewport.\n   * @param replace true to replace currently isolated elements (if any) or false to add to the existing set.\n   * @return true if overrides were changed.\n   * @see [[Viewport.alwaysDrawn]]\n   * @see [[Viewport.isAlwaysDrawnExclusive]]\n   */\n  public isolateElements(ids: Id64Arg, vp: Viewport, replace: boolean = true): boolean {\n    const wasEmphasized = (undefined !== this.getEmphasizedElements(vp));\n    if (!this.setAlwaysDrawnElements(ids, vp, true, replace))\n      return false;\n    if (wasEmphasized)\n      this._defaultAppearance = this._emphasizeIsolated = undefined; // Don't clear defaultAppearance unless it was established by emphasize...\n    return true;\n  }\n\n  /** Set the currently selected elements to be always drawn exclusively.\n   * @param vp The viewport.\n   * @param replace true to replace currently isolated elements (if any) or false to add to the existing set.\n   * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.\n   * @return true if overrides were changed.\n   * @see [[Viewport.alwaysDrawn]]\n   * @see [[Viewport.isAlwaysDrawnExclusive]]\n   */\n  public isolateSelectedElements(vp: Viewport, replace: boolean = true, clearSelection: boolean = true): boolean {\n    const selection = vp.view.iModel.selectionSet;\n    if (!selection.isActive || !this.isolateElements(selection.elements, vp, replace))\n      return false;\n    if (clearSelection)\n      selection.emptyAll();\n    return true;\n  }\n\n  /** Set the element IDs to be always drawn normally with all other elements in the view overridden to draw using a default appearance..\n   * @param ids The IDs of the elements to always draw.\n   * @param vp The viewport.\n   * @param defaultAppearance Optional default appearance, uses non-locatable transparent grey if not specified.\n   * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.\n   * @return true if overrides were changed.\n   * @see [[Viewport.alwaysDrawn]]\n   * @see [[Viewport.isAlwaysDrawnExclusive]]\n   */\n  public emphasizeElements(ids: Id64Arg, vp: Viewport, defaultAppearance?: FeatureSymbology.Appearance, replace: boolean = true): boolean {\n    if (undefined !== this.getIsolatedElements(vp)) {\n      const emphasizeIds = this.updateIdSet(ids, replace, this._emphasizeIsolated);\n      if (undefined === emphasizeIds)\n        return false;\n      this._emphasizeIsolated = emphasizeIds;\n      vp.setFeatureOverrideProviderChanged();\n    } else {\n      if (!this.setAlwaysDrawnElements(ids, vp, false, replace))\n        return false;\n      this._emphasizeIsolated = undefined;\n    }\n    this._defaultAppearance = (undefined === defaultAppearance ? this.createDefaultAppearance() : defaultAppearance);\n    return true;\n  }\n\n  /** Set the currently selected elements to be always drawn normally with all other elements in the view overridden to draw using a default appearance.\n   * @param vp The viewport.\n   * @param defaultAppearance Optional default appearance, uses transparent grey if not specified.\n   * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.\n   * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.\n   * @return true if overrides were changed.\n   * @see [[Viewport.alwaysDrawn]]\n   * @see [[Viewport.isAlwaysDrawnExclusive]]\n   */\n  public emphasizeSelectedElements(vp: Viewport, defaultAppearance?: FeatureSymbology.Appearance, replace: boolean = true, clearSelection: boolean = true): boolean {\n    const selection = vp.view.iModel.selectionSet;\n    if (!selection.isActive || !this.emphasizeElements(selection.elements, vp, defaultAppearance, replace))\n      return false;\n\n    if (clearSelection)\n      selection.emptyAll();\n\n    return true;\n  }\n\n  /** Set the element IDs to display with a color/transparency override.\n   * @param ids The IDs of the elements.\n   * @param vp The viewport.\n   * @param color ColorDef to specify override rgb and alpha.\n   * @param override Whether to use color and alpha, only color, or only alpha from the supplied ColorDef.\n   * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.\n   * @return true if overrides were changed.\n   * @see [[Viewport.featureOverrideProvider]]\n   */\n  public overrideElements(ids: Id64Arg, vp: Viewport, color: ColorDef, override: FeatureOverrideType = FeatureOverrideType.ColorOnly, replace: boolean = false): boolean {\n    const ovrKey = this.createOverrideKey(color, override);\n    if (undefined === ovrKey)\n      return false;\n\n    const overrideIds = new Set<string>();\n    Id64.toIdSet(ids).forEach((id) => { overrideIds.add(id); });\n    if (0 === overrideIds.size)\n      return false;\n\n    const existingIds = (!replace ? this.getOverriddenElementsByKey(ovrKey) : undefined);\n    const oldSize = (undefined !== existingIds ? existingIds.size : 0);\n    if (0 !== oldSize && undefined !== existingIds)\n      for (const id of existingIds)\n        overrideIds.add(id);\n\n    if (oldSize === overrideIds.size)\n      return false;\n\n    if (undefined === this._overrideAppearance) {\n      this._overrideAppearance = new Map<number, Id64Set>();\n    } else {\n      for (const [key, otherIds] of this._overrideAppearance) {\n        if (key === ovrKey) // Make sure these ids are unique to this color/transparency key...\n          continue;\n\n        Id64.toIdSet(ids).forEach((id) => { otherIds.delete(id); });\n        if (0 !== otherIds.size)\n          continue;\n\n        this._overrideAppearance.delete(key);\n      }\n    }\n\n    this._overrideAppearance.set(ovrKey, overrideIds);\n    vp.setFeatureOverrideProviderChanged();\n\n    return true;\n  }\n\n  /** Set the currently selected elements to display with a color/transparency override.\n   * @param vp The viewport.\n   * @param color ColorDef to specify override rgb and alpha.\n   * @param override Whether to use color and alpha, only color, or only alpha from the supplied ColorDef.\n   * @param replace true to replace currently overridden elements (if any) or false to add to the existing set.\n   * @param clearSelection true to clear current selection after setting appearance override, false to leave selected.\n   * @return true if overrides were changed.\n   * @see [[Viewport.featureOverrideProvider]]\n   */\n  public overrideSelectedElements(vp: Viewport, color: ColorDef, override: FeatureOverrideType = FeatureOverrideType.ColorOnly, replace: boolean = false, clearSelection: boolean = true): boolean {\n    const selection = vp.view.iModel.selectionSet;\n    if (!selection.isActive || !this.overrideElements(selection.elements, vp, color, override, replace))\n      return false;\n    if (clearSelection)\n      selection.emptyAll();\n    return true;\n  }\n\n  /** @return true if provider is currently overriding the display of any elements. */\n  public isActive(vp: Viewport): boolean { return (undefined !== this.getNeverDrawnElements(vp) || undefined !== this.getAlwaysDrawnElements(vp) || undefined !== this.getOverriddenElements()); }\n\n  public toJSON(vp: Viewport): EmphasizeElementsProps {\n    const props: EmphasizeElementsProps = {};\n    const neverDrawn = this.getNeverDrawnElements(vp);\n    if (undefined !== neverDrawn)\n      props.neverDrawn = new Set(neverDrawn);\n    const alwaysDrawn = this.getAlwaysDrawnElements(vp);\n    if (undefined !== alwaysDrawn)\n      props.alwaysDrawn = new Set(alwaysDrawn);\n    if (vp.isAlwaysDrawnExclusive)\n      props.isAlwaysDrawnExclusive = true; // isolate\n    const alwaysDrawnExclusiveEmphasized = this.getEmphasizedIsolatedElements();\n    if (undefined !== alwaysDrawnExclusiveEmphasized)\n      props.alwaysDrawnExclusiveEmphasized = new Set(alwaysDrawnExclusiveEmphasized);\n    if (undefined !== this.defaultAppearance)\n      props.defaultAppearance = this.defaultAppearance; // emphasize (or specifically set for override)\n    const overriddenElements = this.getOverriddenElements();\n    if (undefined !== overriddenElements) {\n      const appearanceOverride: AppearanceOverrideProps[] = [];\n      const color = new ColorDef();\n      for (const [key, ovrIds] of overriddenElements) {\n        const overrideType = this.getOverrideFromKey(key, color);\n        const ids = new Set(ovrIds);\n        appearanceOverride.push({ overrideType, color, ids });\n      }\n      props.appearanceOverride = appearanceOverride;\n    }\n    return props;\n  }\n\n  public fromJSON(props: EmphasizeElementsProps, vp: Viewport): boolean {\n    let changed = false;\n    if (undefined !== props.neverDrawn && this.setNeverDrawnElements(props.neverDrawn, vp, true))\n      changed = true;\n    if (undefined !== props.alwaysDrawn && this.setAlwaysDrawnElements(props.alwaysDrawn, vp, undefined !== props.isAlwaysDrawnExclusive && props.isAlwaysDrawnExclusive))\n      changed = true;\n    if (undefined !== props.alwaysDrawnExclusiveEmphasized)\n      this._emphasizeIsolated = props.alwaysDrawnExclusiveEmphasized; // changed status determined by setAlwaysDrawnElements...\n    if (undefined !== props.defaultAppearance)\n      this.defaultAppearance = FeatureSymbology.Appearance.fromJSON(props.defaultAppearance); // changed status determined by setAlwaysDrawnElements or overrideElements...\n    if (undefined !== props.appearanceOverride) {\n      for (const ovrApp of props.appearanceOverride) {\n        if (undefined === ovrApp.ids)\n          continue;\n        if (this.overrideElements(ovrApp.ids, vp, ColorDef.fromJSON(ovrApp.color), ovrApp.overrideType, true))\n          changed = true;\n      }\n    }\n    return changed;\n  }\n\n  /** Get current [[Viewport.featureOverrideProvider]] if it's an instance of EmphasizeElements. */\n  public static get(vp: Viewport): EmphasizeElements | undefined {\n    return (vp.featureOverrideProvider instanceof EmphasizeElements ? vp.featureOverrideProvider : undefined);\n  }\n\n  /** Get or replace current [[Viewport.featureOverrideProvider]] with an instance of EmphasizeElements. */\n  public static getOrCreate(vp: Viewport): EmphasizeElements {\n    let provider = vp.featureOverrideProvider instanceof EmphasizeElements ? vp.featureOverrideProvider : undefined;\n    if (undefined === provider) {\n      provider = new EmphasizeElements();\n      vp.featureOverrideProvider = provider;\n    }\n    return provider;\n  }\n\n  /** Clear current [[Viewport.featureOverrideProvider]] if it's an instance of EmphasizeElements. */\n  public static clear(vp: Viewport, inactiveOnly: boolean = false) {\n    const provider = vp.featureOverrideProvider instanceof EmphasizeElements ? vp.featureOverrideProvider : undefined;\n    if (undefined === provider || (inactiveOnly && provider.isActive))\n      return;\n    vp.clearNeverDrawn();\n    vp.clearAlwaysDrawn();\n    vp.featureOverrideProvider = undefined;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module ElementState */\n\nimport { Id64, Id64String, GuidString } from \"@bentley/bentleyjs-core\";\nimport { EntityProps, Code, ElementProps, RelatedElement } from \"@bentley/imodeljs-common\";\nimport { IModelConnection } from \"./IModelConnection\";\n\n/** The \"state\" of an Entity as represented in a web browser. Every subclass of EntityState handles one BIS class.\n * @public\n */\nexport class EntityState implements EntityProps {\n  /** The name of the BIS schema for this class.\n   * @note Subclasses from other than the BisCore domain must override the static member \"schemaName\" with their schema name.\n   */\n  public static get schemaName() { return \"BisCore\"; }\n\n  private get _ctor(): typeof EntityState { return this.constructor as typeof EntityState; }\n\n  /** The name of the BIS class associated with this class.\n   * @note Every subclass of EntityState **MUST** override this method to identify its BIS class.\n   * Failure to do so will ordinarily result in an error when the class is registered, since there may only\n   * be one JavaScript class for a given BIS class (usually the errant class will collide with its superclass.)\n   */\n  public static get className() { return \"Entity\"; }\n\n  /** The name of the BIS class associated with this class. */\n  public get className(): string { return this._ctor.className; }\n\n  /** The Id of this Entity. May be invalid if the Entity has not yet been saved in the database. */\n  public readonly id: Id64String;\n  /** The iModel from which this Entity was loaded */\n  public readonly iModel: IModelConnection;\n  /** The full class name in the form \"schema:class\". */\n  public readonly classFullName: string;\n  /** Optional [json properties]($docs/bis/intro/element-fundamentals.md#jsonproperties) of this Entity. */\n  public readonly jsonProperties: { [key: string]: any };\n\n  /** Constructor for EntityState\n   * @param props the properties of the Entity for this EntityState\n   * @param iModel the iModel from which this EntityState is to be constructed\n   * @param _state source EntityState for clone\n   */\n  constructor(props: EntityProps, iModel: IModelConnection, _state?: EntityState) {\n    this.classFullName = props.classFullName;\n    this.iModel = iModel;\n    this.id = Id64.fromJSON(props.id);\n    this.jsonProperties = props.jsonProperties ? JSON.parse(JSON.stringify(props.jsonProperties)) : {}; // make sure we have our own copy\n  }\n\n  /** @internal */\n  public toJSON(): EntityProps {\n    const val: any = {};\n    val.classFullName = this.classFullName;\n    if (Id64.isValid(this.id))\n      val.id = this.id;\n    if (this.jsonProperties && Object.keys(this.jsonProperties).length > 0)\n      val.jsonProperties = this.jsonProperties;\n    return val;\n  }\n\n  /** Return true if this EntityState is equal to another one. */\n  public equals(other: this): boolean { return JSON.stringify(this.toJSON()) === JSON.stringify(other.toJSON()); }\n\n  /** Make an independent copy of this EntityState */\n  public clone(iModel?: IModelConnection): this { return new this._ctor(this.toJSON(), iModel ? iModel : this.iModel, this) as this; }\n\n  /** Get full BIS class name of this Entity in the form \"SchemaName:ClassName\".  */\n  public static get classFullName(): string { return this.schemaName + \":\" + this.className; }\n}\n\n/** The \"state\" of an Element as represented in a web browser.\n * @public\n */\nexport class ElementState extends EntityState implements ElementProps {\n  /** @internal */\n  public static get className() { return \"Element\"; }\n\n  /** The ModelId of the [Model]($docs/bis/intro/model-fundamentals.md) containing this element */\n  public readonly model: Id64String;\n  /** The [Code]($docs/bis/intro/codes.md) for this element */\n  public readonly code: Code;\n  /** The parent Element of this, or undefined if no parent. */\n  public readonly parent?: RelatedElement;\n  /** A [FederationGuid]($docs/bis/intro/element-fundamentals.md#federationguid) assigned to this element by some other federated database */\n  public readonly federationGuid?: GuidString;\n  /** A [user-assigned label]($docs/bis/intro/element-fundamentals.md#userlabel) for this element. */\n  public readonly userLabel?: string;\n\n  constructor(props: ElementProps, iModel: IModelConnection) {\n    super(props, iModel);\n    this.code = Code.fromJSON(props.code);\n    this.model = RelatedElement.idFromJson(props.model);\n    this.parent = RelatedElement.fromJSON(props.parent);\n    this.federationGuid = props.federationGuid;\n    this.userLabel = props.userLabel;\n  }\n\n  /** @internal */\n  public toJSON(): ElementProps {\n    const val = super.toJSON() as ElementProps;\n    if (Id64.isValid(this.code.spec))\n      val.code = this.code;\n    val.model = this.model;\n    val.parent = this.parent;\n    val.federationGuid = this.federationGuid;\n    val.userLabel = this.userLabel;\n    return val;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Logging */\r\n\r\n/** Logger categories used by this package\r\n * @note All logger categories in this package start with the `imodeljs-frontend` prefix.\r\n * @see [Logger]($bentley)\r\n * @public\r\n */\r\nexport enum FrontendLoggerCategory {\r\n  Package = \"imodeljs-frontend\",\r\n\r\n  /** The logger category used by the [[FrontendRequestContext]] class and other related classes. */\r\n  FrontendRequestContext = \"imodeljs-frontend.FrontendRequestContext\",\r\n\r\n  /** The logger category used by the [[IModelConnection]] class and other related classes. */\r\n  IModelConnection = \"imodeljs-frontend.IModelConnection\",\r\n\r\n  /** The logger category used by OIDC-related functions in the browser. */\r\n  OidcBrowserClient = \"imodeljs-frontend.OidcBrowserClient\",\r\n\r\n  /** The logger category used by OIDC-related functions on iOS. */\r\n  OidcIOSClient = \"imodeljs-frontend.OidcIOSClient\",\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Utils */\r\n\r\nimport { AuthStatus, BentleyError, ClientRequestContext, Guid, Logger } from \"@bentley/bentleyjs-core\";\r\nimport { AccessToken, AuthorizedClientRequestContext } from \"@bentley/imodeljs-clients\";\r\nimport { IModelApp } from \"./IModelApp\";\r\nimport { FrontendLoggerCategory } from \"./FrontendLoggerCategory\";\r\n\r\nconst loggerCategory: string = FrontendLoggerCategory.FrontendRequestContext;\r\n\r\n/**\r\n * Provides some generic context for downstream server applications to get details of a request that\r\n * originated at the frontend. The context is meant for use in applications that require authorization.\r\n * @see FrontendRequestContext\r\n * @public\r\n */\r\nexport class AuthorizedFrontendRequestContext extends AuthorizedClientRequestContext {\r\n\r\n  /**\r\n   * Create a new context for agent applications or long running frontend operations to pass to various services\r\n   * @see [[AuthorizedFrontendRequestContext.create]] to create the request based on the authorization information supplied to IModelHost.\r\n   */\r\n  public constructor(accessToken: AccessToken, activityId: string = Guid.createValue()) {\r\n    super(accessToken, activityId, IModelApp.applicationId, IModelApp.applicationVersion, IModelApp.sessionId);\r\n  }\r\n\r\n  /**\r\n   * Create a new context for agent applications or long running frontend operations to pass to various services that require\r\n   * authorization. Uses the authorization information supplied to IModelHost to setup an accessToken within the context.\r\n   * @throws [[BentleyError]] if the application cannot be authorized.\r\n   * @see [[IModelApp.authorizationClient]] to setup authorization for the frontend application.\r\n   */\r\n  public static async create(activityId: string = Guid.createValue()): Promise<AuthorizedFrontendRequestContext> {\r\n    if (!IModelApp.authorizationClient)\r\n      throw new BentleyError(AuthStatus.Error, \"IModelApp.authorizationClient not initialized\", Logger.logError, loggerCategory);\r\n    if (!IModelApp.authorizationClient.hasSignedIn)\r\n      throw new BentleyError(AuthStatus.Error, \"Not signed in\", Logger.logError, loggerCategory);\r\n\r\n    const accessToken: AccessToken = await IModelApp.authorizationClient.getAccessToken();\r\n    return new AuthorizedFrontendRequestContext(accessToken, activityId);\r\n  }\r\n\r\n}\r\n\r\n/**\r\n * Provides generic context for downstream server applications to get details of a request that\r\n * originated at the frontend. The context is meant for use in applications that do NOT require authorization.\r\n * @see AuthorizedFrontendRequestContext\r\n * @public\r\n */\r\nexport class FrontendRequestContext extends ClientRequestContext {\r\n  /** Create a new context for agent applications or long running frontend operations to pass to various services */\r\n  public constructor(activityId: string = Guid.createValue()) {\r\n    super(activityId, IModelApp.applicationId, IModelApp.applicationVersion, IModelApp.sessionId);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport * as Fuse from \"fuse.js\";\n\n/** @public */\nexport class FuzzySearch<T> {\n\n  /** Override to provide non-standard FuseOptions for searches where the a single word pattern is used */\n  public onGetSingleWordSearchOptions(): Fuse.FuseOptions<T> {\n    return {\n      shouldSort: true,\n      threshold: 0.40,\n      location: 0,\n      distance: 100,\n      maxPatternLength: 32,\n      minMatchCharLength: 2,\n      includeMatches: true,\n      includeScore: true,\n    };\n  }\n\n  /** Override to provide non-standard FuseOptions for searches where the a multiple word pattern is used */\n  public onGetMultiWordSearchOptions(): Fuse.FuseOptions<T> {\n    return {\n      shouldSort: true,\n      threshold: 0.40,\n      tokenize: true,\n      matchAllTokens: true,\n      maxPatternLength: 32,\n      minMatchCharLength: 2,\n      includeMatches: true,\n      includeScore: true,\n    };\n  }\n\n  /** Call to conduct a fuzzy search of searchedObjects, looking at the 'key' member of each such object\n   * @param searchedObjects An array of objects to search.\n   * @param keys The name of the members to search in the searchedObjects.\n   * @param pattern The pattern for which each searchedObject is searched.\n   * @return FuzzySearchResults.\n   */\n  public search(searchedObjects: T[], keys: Array<keyof T>, pattern: string): FuzzySearchResults<T> {\n    if (!pattern || pattern.length < 2)\n      return new FuzzySearchResults<T>(undefined);\n\n    // it is a multi-word pattern if there's a space other than at the end of the pattern.\n    const spaceIndex: number = pattern.indexOf(\" \");\n    const multiWord: boolean = (-1 !== spaceIndex) && (spaceIndex !== (pattern.length - 1));\n    const options: Fuse.FuseOptions<T> = multiWord ? this.onGetMultiWordSearchOptions() : this.onGetSingleWordSearchOptions();\n    options.keys = keys;\n    const fuse = new Fuse(searchedObjects, options);\n    let results: any[] = fuse.search(pattern);\n\n    // We need to set the threshold fairly high to get results when the user misspells words (otherwise they are not returned),\n    // but doing that results in matches that don't make sense when there are \"good\" matches. So we discard matches where the match\n    // score increases by a large amount between results.\n    let checkScoreDelta: boolean = false;\n    let averageScoreDeltaThreshold = 1;\n    if (results.length > 30) {\n      averageScoreDeltaThreshold = ((results[results.length - 1].score - results[0].score) / results.length) * 10;\n      if (averageScoreDeltaThreshold > 0.01)\n        checkScoreDelta = true;\n    }\n\n    // Sometimes fuse returns results in the array where the matches array is empty. That seems like a bug to me, but it happens when\n    // the input  is something like \"fjt\" and the string it matches is \"fit\". If we have more than three actual matches, we just truncate the set when we see one.\n    // The other use for this loop is to truncate when we see a dramatic increase in the score. The ones after are unlikely\n    // to be useful, so we truncate the results when we hit that point also.\n    for (let resultIndex = 0; resultIndex < results.length; resultIndex++) {\n      const thisResult = results[resultIndex];\n      if (0 === thisResult.matches.length) {\n        // here we have a result with no matches. If we have other matches, just discard this and the rest.\n        if (resultIndex > 2) {\n          results = results.slice(0, resultIndex);\n          break;\n        }\n        // otherwise we want to keep this result, but we have to add the matched value to the object because we can't get it from the matches array.\n        // we assume it came from the first key (usually there's only one anyway).\n\n        thisResult.matchedValue = thisResult.item[keys[0]];\n        thisResult.matchedKey = keys[0];\n      }\n\n      if (checkScoreDelta && (resultIndex > 0)) {\n        const resultScore = results[resultIndex].score;\n        if (resultScore < 0.101)\n          continue;\n        if ((resultScore - results[resultIndex - 1].score) > averageScoreDeltaThreshold) {\n          results = results.slice(0, resultIndex);\n          break;\n        }\n      }\n    }\n\n    // put the functions on each result so it fulfils the FuzzySearchResult interface.\n    for (const thisResult of results) {\n      thisResult.getResult = getResult.bind(thisResult);\n      thisResult.getBoldMask = getBoldMask.bind(thisResult);\n      thisResult.getMatchedKey = getMatchedKey.bind(thisResult);\n      thisResult.getMatchedValue = getMatchedValue.bind(thisResult);\n    }\n    return new FuzzySearchResults<T>(results);\n  }\n}\n\n/** Interface implemented by objects returned while iterating through FuzzySearchResults\n * @public\n */\nexport interface FuzzySearchResult<T> {\n  /** Return the current result object */\n  getResult(): T;\n\n  /** Return the key found in this result object */\n  getMatchedKey(): string;\n\n  /** Return the value matched in this result object */\n  getMatchedValue(): string;\n\n  /** Return a boolean array that contains true for each letter in the matched value that was matched part of the search pattern */\n  getBoldMask(): boolean[];\n}\n\n/** Added to each result to support the FuzzySearchResult interface. */\nfunction getResult(this: any) { return this.item; }\n\n/** Added to each result to support the FuzzySearchResult interface. */\nfunction getMatchedKey(this: any): string { return (this.matches.length > 0) ? this.matches[0].key : this.matchedKey; }\n\n/** Added to each result to support the FuzzySearchResult interface. */\nfunction getMatchedValue(this: any): string { return (this.matches.length > 0) ? this.matches[0].value : this.matchedValue; }\n\n/** this function is added to each result to support the FuzzySearchResult interface. */\nfunction getBoldMask(this: any): boolean[] | undefined {\n  if (this.boldMask)\n    return this.boldMask;\n\n  // if we had no matches, we return a bold mask with all false.\n  if (0 === this.matches.length) {\n    const noBoldMask = new Array<boolean>(this.matchedValue.length);\n    noBoldMask.fill(false);\n    return this.boldMask = noBoldMask;\n  }\n\n  // we have some matched portions.\n  const thisMatchedString: string = this.matches[0].value;\n  const valueLength = thisMatchedString.length;\n  const boldMask: boolean[] = new Array<boolean>(valueLength);\n  boldMask.fill(false);\n  const indicesArray: number[][] = this.matches[0].indices;\n  indicesArray.forEach((set: number[]) => {\n    for (let start = set[0], end = set[1]; start <= end; start++) {\n      boldMask[start] = true;\n    }\n  });\n  // cache it so if someone asks again we don't have to recalculate it.\n  return this.boldMask = boldMask;\n}\n\n/**\n * This class is used to return the results of FuzzySearch.search. It is iterable, with each iteration\n * returning an object implementing the FuzzySearchResult interface.\n * @public\n */\nexport class FuzzySearchResults<T> implements Iterable<T> {\n  public results: any[];\n\n  constructor(results: any[] | undefined) {\n    this.results = [];\n    if (results)\n      this.results = results;\n  }\n\n  public [Symbol.iterator](): any { return new FuzzySearchResultsIterator(this); }\n\n  public get length(): number { return this.results.length; }\n\n  public getResult(resultIndex: number): FuzzySearchResult<T> | undefined {\n    if ((resultIndex < 0) || (resultIndex > this.results.length))\n      return undefined;\n    return this.results[resultIndex];\n  }\n}\nclass FuzzySearchResultsIterator<T> {\n  public counter: number;\n  public fsr: FuzzySearchResults<T>;\n\n  constructor(fsr: FuzzySearchResults<T>) {\n    this.fsr = fsr;\n    this.counter = 0;\n  }\n\n  public next: any = () => {\n    return {\n      done: this.counter === this.fsr.results.length,\n      value: this.fsr.results[this.counter++] as FuzzySearchResult<T>,\n    };\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { IModelConnection } from \"./IModelConnection\";\r\nimport {\r\n  IModelReadRpcInterface,\r\n  PointWithStatus, IModelCoordinatesRequestProps, IModelCoordinatesResponseProps, GeoCoordinatesRequestProps, GeoCoordinatesResponseProps, GeoCoordStatus,\r\n} from \"@bentley/imodeljs-common\";\r\nimport { XYZProps } from \"@bentley/geometry-core\";\r\n\r\n/** Response to a request to obtain imodel coordinates from cache.\r\n * @internal\r\n */\r\nexport interface CachedIModelCoordinatesResponseProps {\r\n  /** An array of the same length as the input array, with undefined entries at indices corresponding to points not found in cache. */\r\n  result: Array<PointWithStatus | undefined>;\r\n  /** An array of points in the input array which were not found in the cache, or undefined if all points were found in the cache. */\r\n  missing?: XYZProps[];\r\n}\r\n\r\n// this class is used to cache results from conversion of geoCoordinates to IModelCoordinates.\r\nclass GCtoIMCResultCache {\r\n  // see fast-memoize npm package where the author demonstrated that an object is the fastest\r\n  //     lookup (faster than Map), and JSON.stringify is the fastest serializer.\r\n  private _cache: any;\r\n  private _iModel: IModelConnection;\r\n  private _sourceDatum: string;\r\n\r\n  constructor(iModel: IModelConnection, sourceDatum: string) {\r\n    this._iModel = iModel;\r\n    this._cache = {};\r\n    this._sourceDatum = sourceDatum;\r\n  }\r\n\r\n  /** @internal */\r\n  public findInCache(geoPoints: XYZProps[]): CachedIModelCoordinatesResponseProps {\r\n    const result: Array<PointWithStatus | undefined> = [];\r\n    let missing: XYZProps[] | undefined;\r\n    for (const geoPoint of geoPoints) {\r\n      const key = JSON.stringify(geoPoint);\r\n      const imodelCoord = this._cache[key];\r\n      result.push(imodelCoord);\r\n      if (undefined === imodelCoord) {\r\n        if (undefined === missing)\r\n          missing = [];\r\n\r\n        missing.push(geoPoint);\r\n      }\r\n    }\r\n\r\n    return { result, missing };\r\n  }\r\n\r\n  public async findInCacheOrRequest(request: IModelCoordinatesRequestProps): Promise<IModelCoordinatesResponseProps> {\r\n    const response: IModelCoordinatesResponseProps = { iModelCoords: [], fromCache: 0 };\r\n    let missing: XYZProps[] | undefined;\r\n\r\n    // Index by cache key to obtain index in input array.\r\n    const originalPositions: any = {};\r\n\r\n    for (let iPoint: number = 0; iPoint < request.geoCoords.length; ++iPoint) {\r\n      const thisGeoCoord: XYZProps = request.geoCoords[iPoint];\r\n\r\n      // we use the JSON string as the key into our cache of previously returned results.\r\n      const thisCacheKey: string = JSON.stringify(thisGeoCoord);\r\n\r\n      // put something in each output that corresponds to the input.\r\n      if (this._cache[thisCacheKey]) {\r\n        response.iModelCoords.push(this._cache[thisCacheKey]);\r\n      } else {\r\n        if (undefined === missing)\r\n          missing = [];\r\n\r\n        // add this geoCoord to the request we are going to send.\r\n        missing.push(thisGeoCoord);\r\n\r\n        // keep track of the original position of this point.\r\n        originalPositions[thisCacheKey] = iPoint;\r\n\r\n        // mark the response as pending.\r\n        response.iModelCoords.push({ p: [0, 0, 0], s: GeoCoordStatus.Pending });\r\n      }\r\n    }\r\n\r\n    // if none are missing from the cache, resolve the promise immediately\r\n    if (undefined === missing) {\r\n      response.fromCache = request.geoCoords.length;\r\n    } else {\r\n      // keep track of how many came from the cache (mostly for tests).\r\n      response.fromCache = request.geoCoords.length - missing.length;\r\n\r\n      // Avoiding requesting too many points at once, exceeding max request length (this definition of \"too many\" should be safely conservative)\r\n      const maxPointsPerRequest = 200;\r\n      const promises: Array<Promise<void>> = [];\r\n      for (let i = 0; i < missing.length; i += maxPointsPerRequest) {\r\n        const remainingRequest = { sourceDatum: this._sourceDatum, geoCoords: missing.slice(i, i + maxPointsPerRequest) };\r\n        const promise = IModelReadRpcInterface.getClient().getIModelCoordinatesFromGeoCoordinates(this._iModel.iModelToken.toJSON(), JSON.stringify(remainingRequest)).then((remainingResponse) => {\r\n          // put the responses into the cache, and fill in the output response for each\r\n          for (let iResponse: number = 0; iResponse < remainingResponse.iModelCoords.length; ++iResponse) {\r\n            const thisPoint: PointWithStatus = remainingResponse.iModelCoords[iResponse];\r\n\r\n            // put the answer in the cache.\r\n            const thisGeoCoord: XYZProps = remainingRequest!.geoCoords[iResponse];\r\n            const thisCacheKey: string = JSON.stringify(thisGeoCoord);\r\n            this._cache[thisCacheKey] = thisPoint;\r\n\r\n            // transfer the answer stored in remainingResponse to the correct position in the overall response.\r\n            const responseIndex = originalPositions[thisCacheKey];\r\n            response.iModelCoords[responseIndex] = thisPoint;\r\n          }\r\n        });\r\n\r\n        promises.push(promise);\r\n      }\r\n\r\n      await Promise.all(promises);\r\n    }\r\n\r\n    return Promise.resolve(response);\r\n  }\r\n}\r\n\r\n// this class is used to cache results from conversion of IModelCoordinates to GeoCoordinates.\r\nclass IMCtoGCResultCache {\r\n  // see fast-memoize npm package where the author demonstrated that an object is the fastest\r\n  //     lookup (faster than Map), and JSON.stringify is the fastest serializer.\r\n  private _cache: any;\r\n  private _iModel: IModelConnection;\r\n  private _targetDatum: string;\r\n\r\n  constructor(iModel: IModelConnection, targetDatum: string) {\r\n    this._iModel = iModel;\r\n    this._cache = {};\r\n    this._targetDatum = targetDatum;\r\n  }\r\n\r\n  public async findInCacheOrRequest(request: GeoCoordinatesRequestProps): Promise<GeoCoordinatesResponseProps> {\r\n    let missing: boolean = false;\r\n    const response: GeoCoordinatesResponseProps = { geoCoords: [], fromCache: 0 };\r\n    let remainingRequest: GeoCoordinatesRequestProps | undefined;\r\n    const originalPositions: number[] = [];\r\n\r\n    for (let iPoint: number = 0; iPoint < request.iModelCoords.length; ++iPoint) {\r\n      const thisIModelCoord: XYZProps = request.iModelCoords[iPoint];\r\n\r\n      // we use the JSON string as the key into our cache of previously returned results.\r\n      const thisCacheKey: string = JSON.stringify(thisIModelCoord);\r\n\r\n      // put something in each output that corresponds to the input.\r\n      if (this._cache[thisCacheKey]) {\r\n        response.geoCoords.push(this._cache[thisCacheKey]);\r\n      } else {\r\n        if (!remainingRequest)\r\n          remainingRequest = { targetDatum: this._targetDatum, iModelCoords: [] };\r\n\r\n        // add this geoCoord to the request we are going to send.\r\n        remainingRequest.iModelCoords.push(thisIModelCoord);\r\n        // keep track of the original position of this point.\r\n        originalPositions.push(iPoint);\r\n\r\n        // mark the response as pending.\r\n        response.geoCoords.push({ p: [0, 0, 0], s: GeoCoordStatus.Pending });\r\n\r\n        missing = true;\r\n      }\r\n    }\r\n\r\n    // if none are missing from the cache, resolve the promise immediately\r\n    if (!missing) {\r\n      response.fromCache = request.iModelCoords.length;\r\n      return Promise.resolve(response);\r\n    } else {\r\n      // keep track of how many came from the cache (mostly for tests).\r\n      response.fromCache = request.iModelCoords.length - originalPositions.length;\r\n      const remainingResponse = await IModelReadRpcInterface.getClient().getGeoCoordinatesFromIModelCoordinates(this._iModel.iModelToken.toJSON(), JSON.stringify(remainingRequest));\r\n      // put the responses into the cache, and fill in the output response for each\r\n      for (let iResponse: number = 0; iResponse < remainingResponse.geoCoords.length; ++iResponse) {\r\n        const thisPoint: PointWithStatus = remainingResponse.geoCoords[iResponse];\r\n\r\n        // transfer the answer stored in remainingResponse to the correct position in the overall response.\r\n        const responseIndex = originalPositions[iResponse];\r\n        response.geoCoords[responseIndex] = thisPoint;\r\n\r\n        // put the answer in the cache.\r\n        const thisIModelCoord: XYZProps = remainingRequest!.iModelCoords[iResponse];\r\n        const thisCacheKey: string = JSON.stringify(thisIModelCoord);\r\n        this._cache[thisCacheKey] = thisPoint;\r\n      }\r\n      return Promise.resolve(response);\r\n    }\r\n  }\r\n}\r\n\r\n/** The GeoConverter class communicates with the backend to convert longitude/latitude coordinates to iModel coordinates and vice-versa\r\n * @internal\r\n */\r\nexport class GeoConverter {\r\n  private _datum: string;\r\n  private _gCtoIMCResultCache: GCtoIMCResultCache;\r\n  private _iMCtoGCResultCache: IMCtoGCResultCache;\r\n  constructor(iModel: IModelConnection, datum: string) {\r\n    this._datum = datum;\r\n    this._gCtoIMCResultCache = new GCtoIMCResultCache(iModel, datum);\r\n    this._iMCtoGCResultCache = new IMCtoGCResultCache(iModel, datum);\r\n  }\r\n\r\n  public async getIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): Promise<IModelCoordinatesResponseProps> {\r\n    const requestProps: IModelCoordinatesRequestProps = { sourceDatum: this._datum, geoCoords: geoPoints };\r\n    return this._gCtoIMCResultCache.findInCacheOrRequest(requestProps);\r\n  }\r\n\r\n  public getCachedIModelCoordinatesFromGeoCoordinates(geoPoints: XYZProps[]): CachedIModelCoordinatesResponseProps {\r\n    return this._gCtoIMCResultCache.findInCache(geoPoints);\r\n  }\r\n\r\n  public async getGeoCoordinatesFromIModelCoordinates(iModelPoints: XYZProps[]): Promise<GeoCoordinatesResponseProps> {\r\n    const requestProps: GeoCoordinatesRequestProps = { targetDatum: this._datum, iModelCoords: iModelPoints };\r\n    return this._iMCtoGCResultCache.findInCacheOrRequest(requestProps);\r\n  }\r\n}\r\n\r\n/** The Geographic Services available for an [[IModelConnection]].\r\n * @internal\r\n */\r\nexport class GeoServices {\r\n  private _iModel: IModelConnection;\r\n\r\n  constructor(iModel: IModelConnection) {\r\n    this._iModel = iModel;\r\n  }\r\n\r\n  public getConverter(datum?: string): GeoConverter {\r\n    return new GeoConverter(this._iModel, datum ? datum : \"\");\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module LocatingElements */\nimport { Point3d, Vector3d, CurvePrimitive, XYZProps, Transform, Arc3d, LineSegment3d, LineString3d, Path } from \"@bentley/geometry-core\";\nimport { ScreenViewport } from \"./Viewport\";\nimport { Sprite, IconSprites } from \"./Sprites\";\nimport { IModelApp } from \"./IModelApp\";\nimport { Id64 } from \"@bentley/bentleyjs-core\";\nimport { DecorateContext } from \"./ViewContext\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { LinePixels, GeometryClass } from \"@bentley/imodeljs-common\";\n\n/** @public */\nexport enum SnapMode {\n  Nearest = 1,\n  NearestKeypoint = 1 << 1,\n  MidPoint = 1 << 2,\n  Center = 1 << 3,\n  Origin = 1 << 4,\n  Bisector = 1 << 5,\n  Intersection = 1 << 6,\n}\n\n/** @public */\nexport enum SnapHeat {\n  None = 0,\n  NotInRange = 1,   // \"of interest\", but out of range\n  InRange = 2,\n}\n\n/** The procedure that generated this Hit.\n * @public\n */\nexport enum HitSource {\n  None = 0,\n  FromUser = 1,\n  MotionLocate = 2,\n  AccuSnap = 3,\n  TentativeSnap = 4,\n  DataPoint = 5,\n  Application = 6,\n  EditAction = 7,\n  EditActionSS = 8,\n}\n\n/** What was being tested to generate this hit. This is not the element or\n * GeometricPrimitive that generated the Hit, it is an indication of whether it is an edge or interior hit.\n * @public\n */\nexport enum HitGeomType {\n  None = 0,\n  Point = 1,\n  Segment = 2,\n  Curve = 3,\n  Arc = 4,\n  Surface = 5,\n}\n\n/** Classification of GeometricPrimitive that generated the Hit.\n * @public\n */\nexport enum HitParentGeomType {\n  None = 0,\n  Wire = 1,\n  Sheet = 2,\n  Solid = 3,\n  Mesh = 4,\n  Text = 5,\n}\n\n/** @public */\nexport enum HitPriority {\n  WireEdge = 0,\n  PlanarEdge = 1,\n  NonPlanarEdge = 2,\n  SilhouetteEdge = 3,\n  PlanarSurface = 4,\n  NonPlanarSurface = 5,\n  Unknown = 6,\n}\n\n/** @public */\nexport enum HitDetailType {\n  Hit = 1,\n  Snap = 2,\n  Intersection = 3,\n}\n\n/** A HitDetail stores the result when locating geometry displayed in a view.\n * It holds an approximate location on an element (or decoration) from a *pick*.\n * @public\n */\nexport class HitDetail {\n  /** Create a new HitDetail from the inputs to and results of a locate operation.\n   * @param testPoint The world coordinate space point that was used as the locate point.\n   * @param viewport The view the locate operation was performed in.\n   * @param hitSource The procedure that requested the locate operation.\n   * @param hitPoint The approximate world coordinate location on the geometry identified by this HitDetail.\n   * @param sourceId The source of the geometry, either a persistent element id or pickable decoration id.\n   * @param priority The hit geometry priority/classification.\n   * @param distXY The xy distance to hit in view coordinates.\n   * @param distFraction The near plane distance fraction to hit.\n   * @param subCategoryId The SubCategory for a persistent element hit.\n   * @param geometryClass The GeometryClass for a persistent element hit.\n   */\n  public constructor(public readonly testPoint: Point3d, public readonly viewport: ScreenViewport, public readonly hitSource: HitSource,\n    public readonly hitPoint: Point3d, public readonly sourceId: string, public readonly priority: HitPriority, public readonly distXY: number, public readonly distFraction: number,\n    public readonly subCategoryId?: string, public readonly geometryClass?: GeometryClass) { }\n\n  /** Get the type of HitDetail.\n   * @returns HitDetailType.Hit if this is a HitDetail, HitDetailType.Snap if it is a SnapDetail\n   */\n  public getHitType(): HitDetailType { return HitDetailType.Hit; }\n\n  /** Get the *hit point* for this HitDetail. Returns the approximate point on the element that caused the hit when not a SnapDetail or IntersectDetail.\n   * For a snap that is *hot*, the *exact* point on the Element for the snap mode is returned, otherwise the close point on the hit geometry is returned.\n   */\n  public getPoint(): Point3d { return this.hitPoint; }\n\n  /** Determine if this HitPoint is from the same source as another HitDetail. */\n  public isSameHit(otherHit?: HitDetail): boolean { return (undefined !== otherHit && this.sourceId === otherHit.sourceId); }\n  /** Return whether sourceId is for a persistent element and not a pickable decoration. */\n  public get isElementHit(): boolean { return !Id64.isInvalid(this.sourceId) && !Id64.isTransient(this.sourceId); }\n  // return whether the sourceId is for a model (reality models etc.)\n  public get isModelHit(): boolean { return this.viewport.iModel.models.getLoaded(this.sourceId) !== undefined; }\n  /** Create a deep copy of this HitDetail */\n  public clone(): HitDetail { const val = new HitDetail(this.testPoint, this.viewport, this.hitSource, this.hitPoint, this.sourceId, this.priority, this.distXY, this.distFraction, this.subCategoryId, this.geometryClass); return val; }\n\n  /** Draw this HitDetail as a Decoration. Causes the picked element to *flash* */\n  public draw(_context: DecorateContext) { this.viewport.setFlashed(this.sourceId, 0.25); }\n\n  /** Get the tooltip content for this HitDetail.\n   * Calls the backend method [Element.getToolTipMessage]($backend), and replaces all instances of `${localizeTag}` with localized string from IModelApp.i18n.\n   */\n  public async getToolTip(): Promise<HTMLElement | string> {\n    if (!this.isElementHit)\n      return IModelApp.viewManager.getDecorationToolTip(this);\n\n    const msg: string[] = await this.viewport.iModel.getToolTipMessage(this.sourceId); // wait for the locate message(s) from the backend\n    // now combine all the lines into one string, replacing any instances of ${tag} with the translated versions.\n    // Add \"<br>\" at the end of each line to cause them to come out on separate lines in the tooltip.\n    let out = \"\";\n    msg.forEach((line) => out += IModelApp.i18n.translateKeys(line) + \"<br>\");\n    const div = document.createElement(\"div\");\n    div.innerHTML = out;\n    return div;\n  }\n}\n\n/** A SnapDetail is generated from the result of [IModelDb.requestSnap]($backend) call. In addition to the HitDetail about the reason the element was *picked*,\n * it holds the *exact* point on the element from the snapping logic, plus additional information that varies with the type of element and snap mode.\n * @public\n */\nexport class SnapDetail extends HitDetail {\n  /** A sprite to show the user the type of snap performed */\n  public sprite?: Sprite;\n  /** HitPoint adjusted by snap */\n  public readonly snapPoint: Point3d;\n  /** AccuSnap/AccuDraw can adjust the point after the snap. */\n  public readonly adjustedPoint: Point3d;\n  /** Curve primitive for snap. */\n  public primitive?: CurvePrimitive;\n  /** Surface normal at snapPoint */\n  public normal?: Vector3d;\n  /** The HitGeomType of this SnapDetail */\n  public geomType?: HitGeomType;\n  /** The HitGeomType of this SnapDetail */\n  public parentGeomType?: HitParentGeomType;\n\n  /** Constructor for SnapDetail.\n   * @param from The HitDetail that created this snap\n   * @param snapMode The SnapMode used to create this SnapDetail\n   * @param heat The SnapHeat of this SnapDetail\n   * @param snapPoint The snapped point in the element\n   */\n  public constructor(from: HitDetail, public snapMode: SnapMode = SnapMode.Nearest, public heat: SnapHeat = SnapHeat.None, snapPoint?: XYZProps) {\n    super(from.testPoint, from.viewport, from.hitSource, from.hitPoint, from.sourceId, from.priority, from.distXY, from.distFraction, from.subCategoryId, from.geometryClass);\n    this.snapPoint = Point3d.fromJSON(snapPoint ? snapPoint : from.hitPoint);\n    this.adjustedPoint = this.snapPoint.clone();\n    this.sprite = IconSprites.getSpriteFromUrl(SnapDetail.getSnapSpriteUrl(snapMode));\n  }\n\n  /** Returns `HitDetailType.Snap` */\n  public getHitType(): HitDetailType { return HitDetailType.Snap; }\n  /** Get the snap point if this SnapDetail is *hot*, the pick point otherwise. */\n  public getPoint(): Point3d { return this.isHot ? this.snapPoint : super.getPoint(); }\n  /** Return true if the pick point was closer than [SnapRequestProps.snapAperture]($common) from the generated snap point. */\n  public get isHot(): boolean { return this.heat !== SnapHeat.None; }\n  /** Determine whether the [[adjustedPoint]] is different than the [[snapPoint]]. This happens, for example, when points are adjusted for grids, acs plane snap, and AccuDraw. */\n  public get isPointAdjusted(): boolean { return !this.adjustedPoint.isExactEqual(this.snapPoint); }\n  /** Change the snap point. */\n  public setSnapPoint(point: Point3d, heat: SnapHeat) { this.snapPoint.setFrom(point); this.adjustedPoint.setFrom(point); this.heat = heat; }\n\n  /** Set curve primitive and HitGeometryType for this SnapDetail. */\n  public setCurvePrimitive(primitive?: CurvePrimitive, localToWorld?: Transform, geomType?: HitGeomType): void {\n    this.primitive = primitive;\n    this.geomType = undefined;\n\n    // Only HitGeomType.Point and HitGeomType.Surface are valid without a curve primitive.\n    if (undefined === this.primitive) {\n      if (HitGeomType.Point === geomType || HitGeomType.Surface === geomType)\n        this.geomType = geomType;\n      return;\n    }\n\n    if (undefined !== localToWorld)\n      this.primitive.tryTransformInPlace(localToWorld);\n\n    if (this.primitive instanceof Arc3d)\n      this.geomType = HitGeomType.Arc;\n    else if (this.primitive instanceof LineSegment3d)\n      this.geomType = HitGeomType.Segment;\n    else if (this.primitive instanceof LineString3d)\n      this.geomType = HitGeomType.Segment;\n    else\n      this.geomType = HitGeomType.Curve;\n\n    // Set curve primitive geometry type override...\n    //  - HitGeomType.Point with arc/ellipse denotes center.\n    //  - HitGeomType.Surface with any curve primitive denotes an interior hit.\n    if (undefined !== geomType && HitGeomType.None !== geomType)\n      this.geomType = geomType;\n  }\n\n  /** Make a copy of this SnapDetail. */\n  public clone(): SnapDetail {\n    const val = new SnapDetail(this, this.snapMode, this.heat, this.snapPoint);\n    val.sprite = this.sprite;\n    val.geomType = this.geomType;\n    val.parentGeomType = this.parentGeomType;\n    val.adjustedPoint.setFrom(this.adjustedPoint);\n    if (undefined !== this.primitive)\n      val.primitive = this.primitive.clone() as CurvePrimitive;\n    if (undefined !== this.normal)\n      val.normal = this.normal.clone();\n    return val;\n  }\n\n  public getCurvePrimitive(singleSegment: boolean = true): CurvePrimitive | undefined {\n    if (!singleSegment || undefined === this.primitive)\n      return this.primitive;\n\n    if (this.primitive instanceof LineString3d) {\n      const ls = this.primitive as LineString3d;\n      if (ls.points.length > 2) {\n        const loc = ls.closestPoint(this.snapPoint, false);\n        const nSegments = ls.points.length - 1;\n        const uSegRange = (1.0 / nSegments);\n        let segmentNo = Math.floor(loc.fraction / uSegRange);\n        if (segmentNo >= nSegments)\n          segmentNo = nSegments - 1;\n        return LineSegment3d.create(ls.points[segmentNo], ls.points[segmentNo + 1]);\n      }\n    }\n\n    return this.primitive;\n  }\n\n  public draw(context: DecorateContext) {\n    if (undefined !== this.primitive) {\n      let singleSegment = false;\n      switch (this.snapMode) {\n        case SnapMode.Center:\n        case SnapMode.Origin:\n        case SnapMode.Bisector:\n          break; // Snap point for these is computed using entire linestring, not just the hit segment...\n\n        default: {\n          singleSegment = true;\n          break;\n        }\n      }\n\n      const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n      const outline = context.viewport.hilite.color.adjustForContrast(context.viewport.view.backgroundColor, 50);\n      const centerLine = context.viewport.hilite.color.adjustForContrast(outline, 175);\n      const path = Path.create(this.getCurvePrimitive(singleSegment)!);\n\n      builder.setSymbology(outline, outline, 6);\n      builder.addPath(path);\n\n      builder.setSymbology(centerLine, centerLine, 2);\n      builder.addPath(path);\n\n      context.addDecorationFromBuilder(builder);\n      return;\n    }\n    super.draw(context);\n  }\n\n  private static getSnapSpriteUrl(snapType: SnapMode): string {\n    switch (snapType) {\n      case SnapMode.Nearest: return \"sprites/SnapPointOn.png\";\n      case SnapMode.NearestKeypoint: return \"sprites/SnapKeypoint.png\";\n      case SnapMode.MidPoint: return \"sprites/SnapMidpoint.png\";\n      case SnapMode.Center: return \"sprites/SnapCenter.png\";\n      case SnapMode.Origin: return \"sprites/SnapOrigin.png\";\n      case SnapMode.Bisector: return \"sprites/SnapBisector.png\";\n      case SnapMode.Intersection: return \"sprites/SnapIntersection.png\";\n    }\n    return \"\";\n  }\n}\n\n/** @public */\nexport class IntersectDetail extends SnapDetail {\n  public constructor(from: SnapDetail, heat: SnapHeat = SnapHeat.None, snapPoint: XYZProps, public readonly otherPrimitive: CurvePrimitive, public readonly otherId: string) {\n    super(from, SnapMode.Intersection, heat, snapPoint);\n    this.primitive = from.primitive;\n    this.normal = from.normal; // Preserve normal from primary snap location for AccuDraw smart rotation...\n  }\n\n  public draw(context: DecorateContext) {\n    if (undefined !== this.primitive && undefined !== this.otherPrimitive) {\n      const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n      const outline = context.viewport.hilite.color.adjustForContrast(context.viewport.view.backgroundColor, 50);\n      const centerLine = context.viewport.hilite.color.adjustForContrast(outline, 175);\n      const path1 = Path.create(this.primitive);\n      const path2 = Path.create(this.otherPrimitive);\n\n      builder.setSymbology(outline, outline, 6);\n      builder.addPath(path1);\n      builder.addPath(path2);\n\n      builder.setSymbology(centerLine, centerLine, 2);\n      builder.addPath(path1);\n      builder.setSymbology(centerLine, centerLine, 2, LinePixels.Code2);\n      builder.addPath(path2);\n\n      context.addDecorationFromBuilder(builder);\n      return;\n    }\n    super.draw(context);\n  }\n}\n\n/** The result of a \"locate\" is a sorted list of objects that satisfied the search criteria (a HitList). Earlier hits in the list\n * are somehow *better* than those later on.\n * @public\n */\nexport class HitList<T extends HitDetail> {\n  public hits: T[] = [];\n  public currHit = -1;\n  public get length(): number { return this.hits.length; }\n  public empty(): void { this.hits.length = 0; this.currHit = -1; }\n  public resetCurrentHit(): void { this.currHit = -1; }\n\n  /** Get a hit from a particular index into a HitList\n   * return the requested hit from the HitList or undefined\n   */\n  public getHit(hitNum: number): T | undefined {\n    if (hitNum < 0) hitNum = this.length - 1;\n    return (hitNum >= this.length) ? undefined : this.hits[hitNum];\n  }\n\n  /** When setting one or more indices to undefined you must call dropNulls afterwards */\n  public setHit(i: number, p: T | undefined): void {\n    if (i < 0 || i >= this.length)\n      return;\n    this.hits[i] = p!;\n  }\n\n  public dropNulls(): void {\n    const hits = this.hits;\n    this.hits = [];\n    for (const hit of hits)\n      this.hits.push(hit);\n  }\n\n  public getNextHit(): T | undefined { this.currHit++; return this.getCurrentHit(); }\n  public getCurrentHit(): T | undefined { return -1 === this.currHit ? undefined : this.getHit(this.currHit); }\n\n  public setCurrentHit(hit: T): void {\n    this.resetCurrentHit();\n    for (let thisHit; undefined !== (thisHit = this.getNextHit());) {\n      if (thisHit === hit)\n        return;\n    }\n  }\n\n  /** remove the current hit from the list. */\n  public removeCurrentHit() { this.removeHit(this.currHit); }\n\n  /** remove a hit in the list. */\n  public removeHit(hitNum: number) {\n    if (hitNum < 0)                   // Support -1 == END\n      hitNum = this.length - 1;\n\n    if (hitNum <= this.currHit)\n      this.currHit = -1;\n\n    if (hitNum >= this.length)        // Locate calls GetNextHit, which increments currHit, until it goes beyond the end of size of the array.\n      return;                         // Then Reset call RemoteCurrentHit, which passes in currHit. When it is out of range, we do nothing.\n\n    this.hits.splice(hitNum, 1);\n  }\n\n  /** search through list and remove any hits that contain a specified element id. */\n  public removeHitsFrom(sourceId: string): boolean {\n    let removedOne = false;\n\n    // walk backwards through list so we don't have to worry about what happens on remove\n    for (let i = this.length - 1; i >= 0; i--) {\n      const thisHit = this.hits[i];\n      if (thisHit && sourceId === thisHit.sourceId) {\n        removedOne = true;\n        this.removeHit(i);\n      }\n    }\n    return removedOne;\n  }\n\n  private getPriorityZOverride(priority: HitPriority): number {\n    switch (priority) {\n      case HitPriority.WireEdge:\n      case HitPriority.PlanarEdge:\n      case HitPriority.NonPlanarEdge:\n        return 0;\n      case HitPriority.SilhouetteEdge:\n        return 1;\n      case HitPriority.PlanarSurface:\n      case HitPriority.NonPlanarSurface:\n        return 2;\n      default:\n        return 3;\n    }\n  }\n\n  /** compare two hits for insertion into list. */\n  public compare(hit1: HitDetail | undefined, hit2: HitDetail | undefined): -1 | 1 | 0 {\n    if (!hit1 || !hit2)\n      return 0;\n\n    const zOverride1 = this.getPriorityZOverride(hit1.priority);\n    const zOverride2 = this.getPriorityZOverride(hit2.priority);\n\n    // Prefer edges over surfaces, this is more important than z because we know the edge isn't obscured...\n    if (zOverride1 < zOverride2) return -1;\n    if (zOverride1 > zOverride2) return 1;\n\n    // Compare xy distance from pick point, prefer hits closer to center...\n    if (hit1.distXY < hit2.distXY) return -1;\n    if (hit1.distXY > hit2.distXY) return 1;\n\n    // Compare distance fraction, prefer hits closer to eye...\n    if (hit1.distFraction > hit2.distFraction) return -1;\n    if (hit1.distFraction < hit2.distFraction) return 1;\n\n    // Compare geometry class, prefer path/region hits over surface hits when all else is equal...\n    if (hit1.priority < hit2.priority) return -1;\n    if (hit1.priority > hit2.priority) return 1;\n\n    return 0;\n  }\n\n  /** Add a new hit to the list. Hits are sorted according to their priority and distance. */\n  public addHit(newHit: T): number {\n    if (0 === this.hits.length) {\n      this.hits.push(newHit);\n      return 0;\n    }\n    let index = 0;\n    for (; index < this.hits.length; ++index) {\n      const oldHit = this.hits[index];\n      const comparison = this.compare(newHit, oldHit);\n      if (comparison < 0)\n        break;\n    }\n\n    this.hits.splice(index, 0, newHit);\n    return index;\n  }\n\n  /** Insert a new hit into the list at the supplied index. */\n  public insertHit(i: number, hit: T): void {\n    if (i < 0 || i >= this.length)\n      this.hits.push(hit);\n    else\n      this.hits.splice(i, 0, hit);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module IModelApp */\n\nimport { dispose, Guid, GuidString, ClientRequestContext, SerializedClientRequestContext, Logger } from \"@bentley/bentleyjs-core\";\nimport {\n  AccessToken, ConnectSettingsClient, IModelClient, IModelHubClient,\n  SettingsAdmin, IAuthorizationClient, IncludePrefix,\n} from \"@bentley/imodeljs-clients\";\nimport { IModelError, IModelStatus, RpcConfiguration, RpcRequest } from \"@bentley/imodeljs-common\";\nimport { I18N, I18NOptions } from \"@bentley/imodeljs-i18n\";\nimport { AccuSnap } from \"./AccuSnap\";\nimport { AccuDraw } from \"./AccuDraw\";\nimport { ElementLocateManager } from \"./ElementLocateManager\";\nimport { NotificationManager } from \"./NotificationManager\";\nimport { QuantityFormatter } from \"./QuantityFormatter\";\nimport { FrontendRequestContext } from \"./FrontendRequestContext\";\nimport { RenderSystem } from \"./render/System\";\nimport { System } from \"./render/webgl/System\";\nimport { TentativePoint } from \"./TentativePoint\";\nimport { ToolRegistry } from \"./tools/Tool\";\nimport { ToolAdmin } from \"./tools/ToolAdmin\";\nimport { ViewManager } from \"./ViewManager\";\nimport { WebGLRenderCompatibilityInfo } from \"./RenderCompatibility\";\nimport { TileAdmin } from \"./tile/TileAdmin\";\nimport { EntityState } from \"./EntityState\";\nimport { TerrainProvider } from \"./TerrainProvider\";\n\nimport * as idleTool from \"./tools/IdleTool\";\nimport * as selectTool from \"./tools/SelectTool\";\nimport * as pluginTool from \"./tools/PluginTool\";\nimport * as viewTool from \"./tools/ViewTool\";\nimport * as clipViewTool from \"./tools/ClipViewTool\";\nimport * as measureTool from \"./tools/MeasureTool\";\nimport * as modelState from \"./ModelState\";\nimport * as sheetState from \"./Sheet\";\nimport * as viewState from \"./ViewState\";\nimport * as displayStyleState from \"./DisplayStyleState\";\nimport * as modelselector from \"./ModelSelectorState\";\nimport * as categorySelectorState from \"./CategorySelectorState\";\nimport * as auxCoordState from \"./AuxCoordSys\";\nimport { FrontendLoggerCategory } from \"./FrontendLoggerCategory\";\ndeclare var BUILD_SEMVER: string;\n\n/** Options that can be supplied to [[IModelApp.startup]] to customize frontend behavior.\n * @public\n */\nexport interface IModelAppOptions {\n  /** If present, supplies the [[IModelClient]] for this session. */\n  imodelClient?: IModelClient;\n  /** If present, supplies the Id of this application. Applications must set this to the Bentley Global Product Registry Id (GPRID) for usage logging. */\n  applicationId?: string;\n  /** If present, supplies the version of this application. Must be set for usage logging. */\n  applicationVersion?: string;\n  /** If present, supplies the [[SettingsAdmin]] for this session. */\n  settings?: SettingsAdmin;\n  /** If present, supplies the [[ViewManager]] for this session. */\n  viewManager?: ViewManager;\n  /** If present, supplies the [[TileAdmin]] for this session.\n   * @alpha\n   */\n  tileAdmin?: TileAdmin;\n  /** If present, supplies the [[NotificationManager]] for this session. */\n  notifications?: NotificationManager;\n  /** If present, supplies the [[ToolAdmin]] for this session. */\n  toolAdmin?: ToolAdmin;\n  /** If present, supplies the [[AccuDraw]] for this session.\n   * @internal\n   */\n  accuDraw?: AccuDraw;\n  /** If present, supplies the [[AccuSnap]] for this session. */\n  accuSnap?: AccuSnap;\n  /** If present, supplies the [[I18N]] for this session. May be either an I18N instance or an I18NOptions used to create an I18N */\n  i18n?: I18N | I18NOptions;\n  /** If present, supplies the authorization information for various frontend APIs */\n  authorizationClient?: IAuthorizationClient;\n  /** @internal */\n  sessionId?: GuidString;\n  /** @internal */\n  locateManager?: ElementLocateManager;\n  /** @internal */\n  tentativePoint?: TentativePoint;\n  /** @internal */\n  quantityFormatter?: QuantityFormatter;\n  /** @internal */\n  renderSys?: RenderSystem | RenderSystem.Options;\n  /** @internal */\n  terrainProvider?: TerrainProvider;\n}\n\n/**\n * Global singleton that connects the user interface with the iModel.js services. There can be only one IModelApp active in a session. All\n * members of IModelApp are static, and it serves as a singleton object for gaining access to session information.\n *\n * Before any interactive operations may be performed by the `@bentley/imodeljs-frontend package`, [[IModelApp.startup]] must be called.\n * Applications may customize the frontend behavior of iModel.js by supplying options to [[IModelApp.startup]].\n *\n * @public\n */\nexport class IModelApp {\n  private static _initialized = false;\n  private static _accuDraw: AccuDraw;\n  private static _accuSnap: AccuSnap;\n  private static _applicationId: string;\n  private static _applicationVersion: string;\n  private static _i18n: I18N;\n  private static _imodelClient: IModelClient;\n  private static _locateManager: ElementLocateManager;\n  private static _notifications: NotificationManager;\n  private static _quantityFormatter: QuantityFormatter;\n  private static _renderSystem?: RenderSystem;\n  private static _settings: SettingsAdmin;\n  private static _tentativePoint: TentativePoint;\n  private static _tileAdmin: TileAdmin;\n  private static _toolAdmin: ToolAdmin;\n  private static _terrainProvider?: TerrainProvider;\n  private static _viewManager: ViewManager;\n\n  // No instances or subclasses of IModelApp may be created. All members are static and must be on the singleton object IModelApp.\n  private constructor() { }\n\n  /** Provides authorization information for various frontend APIs */\n  public static authorizationClient?: IAuthorizationClient;\n  /** The [[ToolRegistry]] for this session. */\n  public static readonly tools = new ToolRegistry();\n  /** A uniqueId for this session */\n  public static sessionId: GuidString;\n  /** The [[RenderSystem]] for this session. */\n  public static get renderSystem(): RenderSystem { return this._renderSystem!; }\n  /** The [[ViewManager]] for this session. */\n  public static get viewManager(): ViewManager { return this._viewManager; }\n  /** The [[NotificationManager]] for this session. */\n  public static get notifications(): NotificationManager { return this._notifications; }\n  /** The [[TileAdmin]] for this session.\n   * @alpha\n   */\n  public static get tileAdmin(): TileAdmin { return this._tileAdmin; }\n  /** The [[QuantityFormatter]] for this session.\n   * @alpha\n   */\n  public static get quantityFormatter(): QuantityFormatter { return this._quantityFormatter; }\n  /** The [[ToolAdmin]] for this session. */\n  public static get toolAdmin(): ToolAdmin { return this._toolAdmin; }\n  /** The [[AccuDraw]] for this session.\n   * @internal\n   */\n  public static get accuDraw(): AccuDraw { return this._accuDraw; }\n  /** The [[AccuSnap]] for this session. */\n  public static get accuSnap(): AccuSnap { return this._accuSnap; }\n  /** @internal */\n  public static get locateManager(): ElementLocateManager { return this._locateManager; }\n  /** @internal */\n  public static get tentativePoint(): TentativePoint { return this._tentativePoint; }\n  /** The [[I18N]] for this session. */\n  public static get i18n(): I18N { return this._i18n; }\n  /** The [[SettingsAdmin]] for this session. */\n  public static get settings(): SettingsAdmin { return this._settings; }\n  /** The Id of this application. Applications must set this to the Global Product Registry ID (GPRID) for usage logging. */\n  public static get applicationId(): string { return this._applicationId; }\n  /** The version of this application. Must be set for usage logging. */\n  public static get applicationVersion(): string { return this._applicationVersion; }\n  /** @internal */\n  public static get initialized() { return this._initialized; }\n  /** The [[IModelClient]] for this session. */\n  public static get iModelClient(): IModelClient { return this._imodelClient; }\n  /** @internal */\n  public static get hasRenderSystem() { return this._renderSystem !== undefined && this._renderSystem.isValid; }\n  /** @internal */\n  public static get terrainProvider() { return this._terrainProvider; }\n\n  /** Map of classFullName to EntityState class */\n  private static _entityClasses = new Map<string, typeof EntityState>();\n\n  /** Register all of the subclasses of EntityState from a module.\n   * @internal\n   */\n  public static registerModuleEntities(moduleObj: any) {\n    for (const thisMember in moduleObj) {\n      if (!thisMember)\n        continue;\n\n      const thisEntityState = moduleObj[thisMember];\n      if (thisEntityState.prototype instanceof EntityState) {\n        this.registerEntityState(thisEntityState.classFullName, thisEntityState);\n      }\n    }\n  }\n\n  /** Register an EntityState class by its classFullName\n   * @internal\n   */\n  public static registerEntityState(classFullName: string, classType: typeof EntityState) {\n    const lowerName = classFullName.toLowerCase();\n    if (this._entityClasses.has(lowerName)) {\n      const errMsg = \"Class \" + classFullName + \" is already registered. Make sure static schemaName and className members are correct on class \" + classType.name;\n      Logger.logError(FrontendLoggerCategory.IModelConnection, errMsg);\n      throw new Error(errMsg);\n    }\n\n    this._entityClasses.set(lowerName, classType);\n  }\n\n  /** @internal */\n  public static lookupEntityClass(classFullName: string) { return this._entityClasses.get(classFullName.toLowerCase()); }\n\n  /**\n   * Obtain WebGL rendering compatibility information for the client system.  This information describes whether the client meets the\n   * minimum rendering capabilities.  It also describes whether the system lacks any optional capabilities that could improve quality\n   * and/or performance.\n   * @beta\n   */\n  public static queryRenderCompatibility(): WebGLRenderCompatibilityInfo { return System.queryRenderCompatibility(); }\n\n  /**\n   * This method must be called before any iModel.js frontend services are used.\n   * In your code, somewhere before you use any iModel.js services, call [[IModelApp.startup]]. E.g.:\n   * ``` ts\n   * IModelApp.startup( {applicationId: myAppId, i18n: myi18Opts} );\n   * ```\n   * @param opts The options for configuring IModelApp\n   */\n  public static startup(opts?: IModelAppOptions): void {\n    opts = opts ? opts : {};\n\n    if (this._initialized)\n      throw new IModelError(IModelStatus.AlreadyLoaded, \"startup may only be called once\");\n\n    // Setup a current context for all requests that originate from this frontend\n    const requestContext = new FrontendRequestContext();\n    requestContext.enter();\n\n    this._initialized = true;\n\n    // Initialize basic application details before log messages are sent out\n    this.sessionId = (opts.sessionId !== undefined) ? opts.sessionId : Guid.createValue();\n    this._applicationId = (opts.applicationId !== undefined) ? opts.applicationId : \"2686\";  // Default to product id of iModel.js\n    this._applicationVersion = (opts.applicationVersion !== undefined) ? opts.applicationVersion : (typeof (BUILD_SEMVER) !== \"undefined\" ? BUILD_SEMVER : \"\");\n    this.authorizationClient = opts.authorizationClient;\n\n    this._imodelClient = (opts.imodelClient !== undefined) ? opts.imodelClient : new IModelHubClient();\n\n    this._setupRpcRequestContext();\n\n    // get the localization system set up so registering tools works. At startup, the only namespace is the system namespace.\n    this._i18n = (opts.i18n instanceof I18N) ? opts.i18n : new I18N(\"iModelJs\", opts.i18n);\n\n    const tools = this.tools; // first register all the core tools. Subclasses may choose to override them.\n    const coreNamespace = this.i18n.registerNamespace(\"CoreTools\");\n    tools.registerModule(selectTool, coreNamespace);\n    tools.registerModule(idleTool, coreNamespace);\n    tools.registerModule(viewTool, coreNamespace);\n    tools.registerModule(clipViewTool, coreNamespace);\n    tools.registerModule(measureTool, coreNamespace);\n    tools.registerModule(pluginTool, coreNamespace);\n\n    this.registerEntityState(EntityState.classFullName, EntityState);\n    this.registerModuleEntities(modelState);\n    this.registerModuleEntities(sheetState);\n    this.registerModuleEntities(viewState);\n    this.registerModuleEntities(displayStyleState);\n    this.registerModuleEntities(modelselector);\n    this.registerModuleEntities(categorySelectorState);\n    this.registerModuleEntities(auxCoordState);\n\n    this._renderSystem = (opts.renderSys instanceof RenderSystem) ? opts.renderSys : this.createRenderSys(opts.renderSys);\n\n    // the startup function may have already allocated any of these members, so first test whether they're present\n    this._settings = (opts.settings !== undefined) ? opts.settings : new ConnectSettingsClient(this.applicationId);\n    this._viewManager = (opts.viewManager !== undefined) ? opts.viewManager : new ViewManager();\n    this._tileAdmin = (opts.tileAdmin !== undefined) ? opts.tileAdmin : TileAdmin.create();\n    this._notifications = (opts.notifications !== undefined) ? opts.notifications : new NotificationManager();\n    this._toolAdmin = (opts.toolAdmin !== undefined) ? opts.toolAdmin : new ToolAdmin();\n    this._accuDraw = (opts.accuDraw !== undefined) ? opts.accuDraw : new AccuDraw();\n    this._accuSnap = (opts.accuSnap !== undefined) ? opts.accuSnap : new AccuSnap();\n    this._locateManager = (opts.locateManager !== undefined) ? opts.locateManager : new ElementLocateManager();\n    this._tentativePoint = (opts.tentativePoint !== undefined) ? opts.tentativePoint : new TentativePoint();\n    this._quantityFormatter = (opts.quantityFormatter !== undefined) ? opts.quantityFormatter : new QuantityFormatter();\n    this._terrainProvider = opts.terrainProvider;       // TBD... (opts.terrainProvider !== undefined) ? opts.terrainProvider : new WorldTerrainProvider();\n\n    this.renderSystem.onInitialized();\n    this.viewManager.onInitialized();\n    this.toolAdmin.onInitialized();\n    this.accuDraw.onInitialized();\n    this.accuSnap.onInitialized();\n    this.locateManager.onInitialized();\n    this.tentativePoint.onInitialized();\n    if (this._terrainProvider) this._terrainProvider.onInitialized();\n  }\n\n  /** Must be called before the application exits to release any held resources. */\n  public static shutdown() {\n    if (this._initialized) {\n      this.toolAdmin.onShutDown();\n      this.viewManager.onShutDown();\n      this.tileAdmin.onShutDown();\n      this._renderSystem = dispose(this._renderSystem);\n      this._entityClasses.clear();\n      this._initialized = false;\n    }\n  }\n\n  /** @internal */\n  public static createRenderSys(opts?: RenderSystem.Options): RenderSystem { return System.create(opts); }\n\n  private static _setupRpcRequestContext() {\n    RpcConfiguration.requestContext.getId = (_request: RpcRequest): string => {\n      const id = ClientRequestContext.current.useContextForRpc ? ClientRequestContext.current.activityId : Guid.createValue(); // Use any context explicitly set for an RPC call if possible\n      ClientRequestContext.current.useContextForRpc = false; // Reset flag so it doesn't get used inadvertently for next RPC call\n      return id;\n    };\n\n    RpcConfiguration.requestContext.serialize = async (_request: RpcRequest): Promise<SerializedClientRequestContext> => {\n      const id = _request.id;\n\n      let authorization: string | undefined;\n      let userId: string | undefined;\n      if (IModelApp.authorizationClient) {\n        // todo: need to subscribe to token change events to avoid getting the string equivalent and compute length\n        const accessToken: AccessToken = await IModelApp.authorizationClient.getAccessToken();\n        authorization = accessToken.toTokenString(IncludePrefix.Yes);\n        userId = accessToken.getUserInfo()!.id;\n      }\n      return {\n        id,\n        applicationId: this.applicationId,\n        applicationVersion: this.applicationVersion,\n        sessionId: this.sessionId,\n        authorization,\n        userId,\n      };\n    };\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module IModelConnection */\n\nimport { assert, BeEvent, BentleyStatus, Id64, Id64Arg, Id64Set, Id64String, Logger, OpenMode, TransientIdSequence, DbResult } from \"@bentley/bentleyjs-core\";\nimport { Angle, Point3d, Range3dProps, XYAndZ } from \"@bentley/geometry-core\";\nimport {\n  AxisAlignedBox3d, Cartographic, CodeSpec, ElementProps, EntityQueryParams, FontMap, GeoCoordStatus, ImageSourceFormat, IModel, IModelError,\n  IModelNotFoundResponse, IModelReadRpcInterface, IModelStatus, IModelToken, IModelVersion, IModelWriteRpcInterface,\n  ModelProps, ModelQueryParams, RpcNotFoundResponse, RpcOperation, RpcRequest, RpcRequestEvent, SnapRequestProps, SnapResponseProps,\n  SnapshotIModelRpcInterface, ThumbnailProps, TileTreeProps, ViewDefinitionProps, ViewQueryParams, WipRpcInterface, IModelProps, QueryResponse, QueryPriority, QueryQuota, QueryLimit, QueryResponseStatus,\n} from \"@bentley/imodeljs-common\";\nimport { EntityState } from \"./EntityState\";\nimport { GeoServices } from \"./GeoServices\";\nimport { IModelApp } from \"./IModelApp\";\nimport { FrontendLoggerCategory } from \"./FrontendLoggerCategory\";\nimport { ModelState } from \"./ModelState\";\nimport { HiliteSet, SelectionSet } from \"./SelectionSet\";\nimport { ViewState } from \"./ViewState\";\nimport { AuthorizedFrontendRequestContext } from \"./FrontendRequestContext\";\nimport { SubCategoriesCache } from \"./SubCategoriesCache\";\nimport { TileTreeState } from \"./tile/TileTree\";\n\nconst loggerCategory: string = FrontendLoggerCategory.IModelConnection;\n\n/** A connection to an iModel database hosted on the backend.\n * @public\n */\nexport class IModelConnection extends IModel {\n  /** The [[OpenMode]] used for this IModelConnection. */\n  public readonly openMode: OpenMode;\n  /** The [[ModelState]]s in this IModelConnection. */\n  public readonly models: IModelConnection.Models;\n  /** The [[ElementState]]s in this IModelConnection. */\n  public readonly elements: IModelConnection.Elements;\n  /** The [[CodeSpec]]s in this IModelConnection. */\n  public readonly codeSpecs: IModelConnection.CodeSpecs;\n  /** The [[ViewState]]s in this IModelConnection. */\n  public readonly views: IModelConnection.Views;\n  /** The set of currently hilited elements for this IModelConnection.\n   * @alpha\n   */\n  public readonly hilited: HiliteSet;\n  /** The set of currently selected elements for this IModelConnection. */\n  public readonly selectionSet: SelectionSet;\n  /** The set of Tiles for this IModelConnection.\n   * @internal\n   */\n  public readonly tiles: IModelConnection.Tiles;\n  /** A cache of information about SubCategories chiefly used for rendering.\n   * @internal\n   */\n  public readonly subcategories: SubCategoriesCache;\n  /** Generator for unique Ids of transient graphics for this IModelConnection. */\n  public readonly transientIds = new TransientIdSequence();\n  /** The Geographic location services available for this iModelConnection\n   * @internal\n   */\n  public readonly geoServices: GeoServices;\n  /** @internal Whether it has already been determined that this iModelConnection does not have a map projection. */\n  protected _noGcsDefined?: boolean;\n  /** The maximum time (in milliseconds) to wait before timing out the request to open a connection to a new iModel */\n  public static connectionTimeout: number = 10 * 60 * 1000;\n\n  /** Check the [[openMode]] of this IModelConnection to see if it was opened read-only. */\n  public get isReadonly(): boolean { return this.openMode === OpenMode.Readonly; }\n\n  /** Check if the IModelConnection is still open. Returns false after [[IModelConnection.close]] has been called.\n   * @alpha\n   */\n  public get isOpen(): boolean { return undefined !== (this._token as any); }\n\n  /** Check if the IModelConnection has been closed. Returns true after [[IModelConnection.close]] has been called.\n   * @alpha\n   */\n  public get isClosed(): boolean { return !this.isOpen; }\n\n  /** Event called immediately before an IModelConnection is closed.\n   * @note Be careful not to perform any asynchronous operations on the IModelConnection because it will close before they are processed.\n   */\n  public static readonly onClose = new BeEvent<(_imodel: IModelConnection) => void>();\n\n  /** The font map for this IModelConnection. Only valid after calling #loadFontMap and waiting for the returned promise to be fulfilled. */\n  public fontMap?: FontMap;\n\n  /** Load the FontMap for this IModelConnection.\n   * @returns Returns a Promise<FontMap> that is fulfilled when the FontMap member of this IModelConnection is valid.\n   */\n  public async loadFontMap(): Promise<FontMap> {\n    return this.fontMap || (this.fontMap = new FontMap(JSON.parse(await IModelReadRpcInterface.getClient().readFontJson(this.iModelToken.toJSON()))));\n  }\n  /** The set of Context Reality Model tile trees for this IModelConnection.\n   * @internal\n   */\n  private _contextRealityModelTileTrees = new Map<string, TileTreeState>();\n  /** Get the context reality model tile tree for a URL.\n   * @internal\n   */\n  public getContextRealityModelTileTree(url: string): TileTreeState {\n    const found = this._contextRealityModelTileTrees.get(url);\n    if (found !== undefined)\n      return found;\n    const tileTree = new TileTreeState(this, true, this.transientIds.next);\n    this._contextRealityModelTileTrees.set(url, tileTree);\n    return tileTree;\n  }\n\n  /** Find the first registered base class of the given EntityState className. This class will \"handle\" the State for the supplied className.\n   * @param className The full name of the class of interest.\n   * @param defaultClass If no base class of the className is registered, return this value.\n   * @note this method is async since it may have to query the server to get the class hierarchy.\n   */\n  public async findClassFor<T extends typeof EntityState>(className: string, defaultClass: T | undefined): Promise<T | undefined> {\n    let ctor = IModelApp.lookupEntityClass(className) as T | undefined;\n    if (undefined !== ctor)\n      return ctor;\n\n    // it's not registered, we need to query its class hierarchy.\n    ctor = defaultClass; // in case we cant find a registered class that handles this class\n\n    // wait until we get the full list of base classes from backend\n    const baseClasses = await IModelReadRpcInterface.getClient().getClassHierarchy(this.iModelToken.toJSON(), className);\n    // walk through the list until we find a registered base class\n    baseClasses.some((baseClass: string) => {\n      const test = IModelApp.lookupEntityClass(baseClass) as T | undefined;\n      if (test === undefined)\n        return false; // nope, not registered\n\n      ctor = test; // found it, save it\n      IModelApp.registerEntityState(className, ctor); // and register the fact that our starting class is handled by this subclass.\n      return true; // stop\n    });\n    return ctor; // either the baseClass handler or defaultClass if we didn't find a registered baseClass\n  }\n\n  private constructor(iModel: IModelProps, openMode: OpenMode) {\n    super(IModelToken.fromJSON(iModel.iModelToken!));\n    super.initialize(iModel.name!, iModel);\n    this.openMode = openMode;\n    this.models = new IModelConnection.Models(this);\n    this.elements = new IModelConnection.Elements(this);\n    this.codeSpecs = new IModelConnection.CodeSpecs(this);\n    this.views = new IModelConnection.Views(this);\n    this.selectionSet = new SelectionSet(this);\n    this.hilited = new HiliteSet(this);\n    this.tiles = new IModelConnection.Tiles(this);\n    this.subcategories = new SubCategoriesCache(this);\n    this.geoServices = new GeoServices(this);\n  }\n\n  /** Open an IModelConnection to an iModel. It's recommended that every open call be matched with a corresponding call to close. */\n  public static async open(contextId: string, iModelId: string, openMode: OpenMode = OpenMode.Readonly, version: IModelVersion = IModelVersion.latest()): Promise<IModelConnection> {\n    if (!IModelApp.initialized)\n      throw new IModelError(BentleyStatus.ERROR, \"Call IModelApp.startup() before calling open\");\n\n    const requestContext = await AuthorizedFrontendRequestContext.create();\n    requestContext.enter();\n\n    const changeSetId: string = await version.evaluateChangeSet(requestContext, iModelId, IModelApp.iModelClient);\n    requestContext.enter();\n\n    const iModelToken = new IModelToken(undefined, contextId, iModelId, changeSetId, openMode);\n\n    const openResponse: IModelProps = await IModelConnection.callOpen(requestContext, iModelToken, openMode);\n    requestContext.enter();\n\n    const connection = new IModelConnection(openResponse, openMode);\n    RpcRequest.notFoundHandlers.addListener(connection._reopenConnectionHandler);\n\n    return connection;\n  }\n\n  private static async callOpen(requestContext: AuthorizedFrontendRequestContext, iModelToken: IModelToken, openMode: OpenMode): Promise<IModelProps> {\n    requestContext.enter();\n\n    // Try opening the iModel repeatedly accommodating any pending responses from the backend.\n    // Waits for an increasing amount of time (but within a range) before checking on the pending request again.\n    const connectionRetryIntervalRange = { min: 100, max: 5000 }; // in milliseconds\n    let connectionRetryInterval = Math.min(connectionRetryIntervalRange.min, IModelConnection.connectionTimeout);\n\n    let openForReadOperation: RpcOperation | undefined;\n    let openForWriteOperation: RpcOperation | undefined;\n    if (openMode === OpenMode.Readonly) {\n      openForReadOperation = RpcOperation.lookup(IModelReadRpcInterface, \"openForRead\");\n      if (!openForReadOperation)\n        throw new IModelError(BentleyStatus.ERROR, \"IModelReadRpcInterface.openForRead() is not available\");\n      openForReadOperation.policy.retryInterval = () => connectionRetryInterval;\n    } else {\n      openForWriteOperation = RpcOperation.lookup(IModelWriteRpcInterface, \"openForWrite\");\n      if (!openForWriteOperation)\n        throw new IModelError(BentleyStatus.ERROR, \"IModelWriteRpcInterface.openForWrite() is not available\");\n      openForWriteOperation.policy.retryInterval = () => connectionRetryInterval;\n    }\n\n    Logger.logTrace(loggerCategory, `Received open request in IModelConnection.open`, () => iModelToken);\n    Logger.logTrace(loggerCategory, `Setting retry interval in IModelConnection.open`, () => ({ ...iModelToken, connectionRetryInterval }));\n\n    const startTime = Date.now();\n\n    const removeListener = RpcRequest.events.addListener((type: RpcRequestEvent, request: RpcRequest) => {\n      if (type !== RpcRequestEvent.PendingUpdateReceived)\n        return;\n      if (!(openForReadOperation && request.operation === openForReadOperation) && !(openForWriteOperation && request.operation === openForWriteOperation))\n        return;\n\n      requestContext.enter();\n      Logger.logTrace(loggerCategory, \"Received pending open notification in IModelConnection.open\", () => iModelToken);\n\n      const connectionTimeElapsed = Date.now() - startTime;\n      if (connectionTimeElapsed > IModelConnection.connectionTimeout) {\n        Logger.logError(loggerCategory, `Timed out opening connection in IModelConnection.open (took longer than ${IModelConnection.connectionTimeout} milliseconds)`, () => iModelToken);\n        throw new IModelError(BentleyStatus.ERROR, \"Opening a connection was timed out\"); // NEEDS_WORK: More specific error status\n      }\n\n      connectionRetryInterval = Math.min(connectionRetryIntervalRange.max, connectionRetryInterval * 2, IModelConnection.connectionTimeout - connectionTimeElapsed);\n      if (request.retryInterval !== connectionRetryInterval) {\n        request.retryInterval = connectionRetryInterval;\n        Logger.logTrace(loggerCategory, `Adjusted open connection retry interval to ${request.retryInterval} milliseconds in IModelConnection.open`, () => iModelToken);\n      }\n    });\n\n    let openPromise: Promise<IModelProps>;\n    requestContext.useContextForRpc = true;\n    if (openMode === OpenMode.ReadWrite)\n      openPromise = IModelWriteRpcInterface.getClient().openForWrite(iModelToken.toJSON());\n    else\n      openPromise = IModelReadRpcInterface.getClient().openForRead(iModelToken.toJSON());\n\n    let openResponse: IModelProps;\n    try {\n      openResponse = await openPromise;\n    } finally {\n      requestContext.enter();\n      Logger.logTrace(loggerCategory, \"Completed open request in IModelConnection.open\", () => iModelToken);\n      removeListener();\n    }\n\n    return openResponse;\n  }\n\n  private _reopenConnectionHandler = async (request: RpcRequest<RpcNotFoundResponse>, response: IModelNotFoundResponse, resubmit: () => void, reject: (reason: any) => void) => {\n    if (!(response instanceof IModelNotFoundResponse))\n      return;\n\n    const iModelToken: IModelToken = request.parameters[0];\n    if (this._token.key !== iModelToken.key)\n      return; // The handler is called for a different connection than this\n\n    const requestContext: AuthorizedFrontendRequestContext = await AuthorizedFrontendRequestContext.create(request.id); // Reuse activityId\n    requestContext.enter();\n\n    Logger.logTrace(loggerCategory, \"Attempting to reopen connection\", () => iModelToken);\n\n    try {\n      const openResponse: IModelProps = await IModelConnection.callOpen(requestContext, iModelToken, this.openMode);\n      this._token = IModelToken.fromJSON(openResponse.iModelToken!);\n    } catch (error) {\n      reject(error.message);\n    } finally {\n      requestContext.enter();\n    }\n\n    Logger.logTrace(loggerCategory, \"Resubmitting original request after reopening connection\", () => iModelToken);\n    request.parameters[0] = this._token; // Modify the token of the original request before resubmitting it.\n    resubmit();\n  }\n\n  /** Close this IModelConnection\n   * In the case of ReadWrite connections ensure all changes are pushed to the iModelHub before making this call -\n   * any un-pushed changes are lost after the close.\n   */\n  public async close(): Promise<void> {\n    if (!this.iModelToken)\n      return;\n\n    const requestContext = await AuthorizedFrontendRequestContext.create();\n    requestContext.enter();\n\n    RpcRequest.notFoundHandlers.removeListener(this._reopenConnectionHandler);\n    IModelConnection.onClose.raiseEvent(this);\n    this.models.onIModelConnectionClose();  // free WebGL resources if rendering\n\n    requestContext.useContextForRpc = true;\n    const closePromise = IModelReadRpcInterface.getClient().close(this.iModelToken.toJSON()); // Ensure the method isn't await-ed right away.\n    try {\n      await closePromise;\n    } finally {\n      (this._token as any) = undefined; // prevent closed connection from being reused\n      this.subcategories.onIModelConnectionClose();\n    }\n  }\n\n  /** Open an IModelConnection to a read-only iModel *snapshot* (not managed by iModelHub) from a file name that is resolved by the backend.\n   * This method is intended for desktop or mobile applications and should not be used for web applications.\n   * @beta\n   */\n  public static async openSnapshot(fileName: string): Promise<IModelConnection> {\n    const openResponse: IModelProps = await SnapshotIModelRpcInterface.getClient().openSnapshot(fileName);\n    Logger.logTrace(loggerCategory, \"IModelConnection.openSnapshot\", () => ({ fileName }));\n    return new IModelConnection(openResponse, OpenMode.Readonly);\n  }\n\n  /** Close this IModelConnection to a read-only iModel *snapshot*.\n   * @beta\n   */\n  public async closeSnapshot(): Promise<void> {\n    if (!this.iModelToken)\n      return;\n\n    IModelConnection.onClose.raiseEvent(this);\n    this.models.onIModelConnectionClose();  // free WebGL resources if rendering\n    try {\n      await SnapshotIModelRpcInterface.getClient().closeSnapshot(this.iModelToken.toJSON());\n    } finally {\n      (this._token as any) = undefined; // prevent closed connection from being reused\n      this.subcategories.onIModelConnectionClose();\n    }\n  }\n\n  /** Compute number of rows that would be returned by the ECSQL.\n   *\n   * See also:\n   * - [ECSQL Overview]($docs/learning/backend/ExecutingECSQL)\n   * - [Code Examples]($docs/learning/backend/ECSQLCodeExamples)\n   *\n   * @param ecsql The ECSQL statement to execute\n   * @param bindings The values to bind to the parameters (if the ECSQL has any).\n   * Pass an *array* of values if the parameters are *positional*.\n   * Pass an *object of the values keyed on the parameter name* for *named parameters*.\n   * The values in either the array or object must match the respective types of the parameters.\n   * See \"[iModel.js Types used in ECSQL Parameter Bindings]($docs/learning/ECSQLParameterTypes)\" for details.\n   * @returns Return row count.\n   * @throws [IModelError]($common) If the statement is invalid\n   */\n  public async queryRowCount(ecsql: string, bindings?: any[] | object): Promise<number> {\n    for await (const row of this.query(`select count(*) nRows from (${ecsql})`, bindings)) {\n      return row.nRows;\n    }\n    Logger.logTrace(loggerCategory, \"IModelConnection.queryRowCount\", () => ({ ...this.iModelToken, ecsql, bindings }));\n    throw new IModelError(DbResult.BE_SQLITE_ERROR, \"Failed to get row count\");\n  }\n\n  /** Execute a query against this ECDb but restricted by quota and limit settings. This is intended to be used internally\n   * The result of the query is returned as an array of JavaScript objects where every array element represents an\n   * [ECSQL row]($docs/learning/ECSQLRowFormat).\n   *\n   * See also:\n   * - [ECSQL Overview]($docs/learning/backend/ExecutingECSQL)\n   * - [Code Examples]($docs/learning/backend/ECSQLCodeExamples)\n   *\n   * @param ecsql The ECSQL statement to execute\n   * @param bindings The values to bind to the parameters (if the ECSQL has any).\n   * Pass an *array* of values if the parameters are *positional*.\n   * Pass an *object of the values keyed on the parameter name* for *named parameters*.\n   * The values in either the array or object must match the respective types of the parameters.\n   * See \"[iModel.js Types used in ECSQL Parameter Bindings]($docs/learning/ECSQLParameterTypes)\" for details.\n   * @param limitRows Specify upper limit for rows that can be returned by the query.\n   * @param quota Specify non binding quota. These values are constrained by global setting\n   * but never the less can be specified to narrow down the quota constraint for the query but staying under global settings.\n   * @param priority Specify non binding priority for the query. It can help user to adjust\n   * priority of query in queue so that small and quicker queries can be prioritized over others.\n   * @returns Returns structure containing rows and status.\n   * See [ECSQL row format]($docs/learning/ECSQLRowFormat) for details about the format of the returned rows.\n   * @internal\n   */\n  public async queryRows(ecsql: string, bindings?: any[] | object, limit?: QueryLimit, quota?: QueryQuota, priority?: QueryPriority): Promise<QueryResponse> {\n    Logger.logTrace(loggerCategory, \"IModelConnection.queryRows\", () => ({ ...this.iModelToken, ecsql, bindings, limit, quota, priority }));\n    return IModelReadRpcInterface.getClient().queryRows(this.iModelToken.toJSON(), ecsql, bindings, limit, quota, priority);\n  }\n\n  /** Execute a query and stream its results\n   * The result of the query is async iterator over the rows. The iterator will get next page automatically once rows in current page has been read.\n   * [ECSQL row]($docs/learning/ECSQLRowFormat).\n   *\n   * See also:\n   * - [ECSQL Overview]($docs/learning/backend/ExecutingECSQL)\n   * - [Code Examples]($docs/learning/backend/ECSQLCodeExamples)\n   *\n   * @param ecsql The ECSQL statement to execute\n   * @param bindings The values to bind to the parameters (if the ECSQL has any).\n   * Pass an *array* of values if the parameters are *positional*.\n   * Pass an *object of the values keyed on the parameter name* for *named parameters*.\n   * The values in either the array or object must match the respective types of the parameters.\n   * See \"[iModel.js Types used in ECSQL Parameter Bindings]($docs/learning/ECSQLParameterTypes)\" for details.\n   * @param limitRows Specify upper limit for rows that can be returned by the query.\n   * @param quota Specify non binding quota. These values are constrained by global setting\n   * but never the less can be specified to narrow down the quota constraint for the query but staying under global settings.\n   * @param priority Specify non binding priority for the query. It can help user to adjust\n   * priority of query in queue so that small and quicker queries can be prioritized over others.\n   * @returns Returns the query result as an *AsyncIterableIterator<any>*  which lazy load result as needed\n   * See [ECSQL row format]($docs/learning/ECSQLRowFormat) for details about the format of the returned rows.\n   * @throws [IModelError]($common) If there was any error while submitting, preparing or stepping into query\n   * @alpha\n   */\n  public async * query(ecsql: string, bindings?: any[] | object, limitRows?: number, quota?: QueryQuota, priority?: QueryPriority): AsyncIterableIterator<any> {\n    let result: QueryResponse;\n    let offset: number = 0;\n    let rowsToGet = limitRows ? limitRows : -1;\n    do {\n      result = await this.queryRows(ecsql, bindings, { maxRowAllowed: rowsToGet, startRowOffset: offset }, quota, priority);\n      while (result.status === QueryResponseStatus.Timeout) {\n        result = await this.queryRows(ecsql, bindings, { maxRowAllowed: rowsToGet, startRowOffset: offset }, quota, priority);\n      }\n\n      if (result.status === QueryResponseStatus.Error)\n        throw new IModelError(QueryResponseStatus.Error, \"Failed to execute ECSQL\");\n\n      if (rowsToGet > 0) {\n        rowsToGet -= result.rows.length;\n      }\n      offset += result.rows.length;\n\n      for (const row of result.rows)\n        yield row;\n\n    } while (result.status !== QueryResponseStatus.Done);\n  }\n\n  /** Query for a set of element ids that satisfy the supplied query params\n   * @param params The query parameters. The `limit` and `offset` members should be used to page results.\n   * @throws [IModelError]($common) If the generated statement is invalid or would return too many rows.\n   */\n  public async queryEntityIds(params: EntityQueryParams): Promise<Id64Set> { return new Set(await IModelReadRpcInterface.getClient().queryEntityIds(this.iModelToken.toJSON(), params)); }\n\n  /** Update the project extents of this iModel.\n   * @param newExtents The new project extents as an AxisAlignedBox3d\n   * @throws [[IModelError]] if the IModelConnection is read-only or there is a problem updating the extents.\n   */\n  public async updateProjectExtents(newExtents: AxisAlignedBox3d): Promise<void> {\n    Logger.logTrace(loggerCategory, \"IModelConnection.updateProjectExtents\", () => ({ ...this.iModelToken, newExtents }));\n    if (OpenMode.ReadWrite !== this.openMode)\n      return Promise.reject(new IModelError(IModelStatus.ReadOnly, \"IModelConnection was opened read-only\", Logger.logError));\n    return IModelWriteRpcInterface.getClient().updateProjectExtents(this.iModelToken.toJSON(), newExtents.toJSON());\n  }\n\n  /** Commit pending changes to this iModel\n   * @param description Optional description of the changes\n   * @throws [[IModelError]] if the IModelConnection is read-only or there is a problem saving changes.\n   */\n  public async saveChanges(description?: string): Promise<void> {\n    Logger.logTrace(loggerCategory, \"IModelConnection.saveChanges\", () => ({ ...this.iModelToken, description }));\n    if (OpenMode.ReadWrite !== this.openMode)\n      return Promise.reject(new IModelError(IModelStatus.ReadOnly, \"IModelConnection was opened read-only\", Logger.logError));\n    return IModelWriteRpcInterface.getClient().saveChanges(this.iModelToken.toJSON(), description);\n  }\n\n  /** WIP - Determines whether the *Change Cache file* is attached to this iModel or not.\n   * See also [Change Summary Overview]($docs/learning/ChangeSummaries)\n   * @returns Returns true if the *Change Cache file* is attached to the iModel. false otherwise\n   * @internal\n   */\n  public async changeCacheAttached(): Promise<boolean> { return WipRpcInterface.getClient().isChangeCacheAttached(this.iModelToken.toJSON()); }\n\n  /** WIP - Attaches the *Change Cache file* to this iModel if it hasn't been attached yet.\n   * A new *Change Cache file* will be created for the iModel if it hasn't existed before.\n   * See also [Change Summary Overview]($docs/learning/ChangeSummaries)\n   * @throws [IModelError]($common) if a Change Cache file has already been attached before.\n   * @internal\n   */\n  public async attachChangeCache(): Promise<void> { return WipRpcInterface.getClient().attachChangeCache(this.iModelToken.toJSON()); }\n\n  /** WIP - Detaches the *Change Cache file* to this iModel if it had been attached before.\n   * > You do not have to check whether a Change Cache file had been attached before. The\n   * > method does not do anything, if no Change Cache is attached.\n   * See also [Change Summary Overview]($docs/learning/ChangeSummaries)\n   * @internal\n   */\n  public async detachChangeCache(): Promise<void> { return WipRpcInterface.getClient().detachChangeCache(this.iModelToken.toJSON()); }\n\n  /** Request a snap from the backend. */\n  public async requestSnap(props: SnapRequestProps): Promise<SnapResponseProps> { return IModelReadRpcInterface.getClient().requestSnap(this.iModelToken.toJSON(), IModelApp.sessionId, props); }\n\n  /** Request a tooltip from the backend.  */\n  public async getToolTipMessage(id: string): Promise<string[]> { return IModelReadRpcInterface.getClient().getToolTipMessage(this.iModelToken.toJSON(), id); }\n\n  /** Convert a point in this iModel's Spatial coordinates to a [[Cartographic]] using the Geographic location services for this IModelConnection.\n   * @param spatial A point in the iModel's spatial coordinates\n   * @param result If defined, use this for output\n   * @returns A Cartographic location\n   * @throws IModelError if [[isGeoLocated]] is false or point could not be converted.\n   */\n  public async spatialToCartographicFromGcs(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic> {\n    if (undefined === this._noGcsDefined && !this.isGeoLocated)\n      this._noGcsDefined = true;\n\n    if (this._noGcsDefined)\n      throw new IModelError(IModelStatus.NoGeoLocation, \"iModel does not have a Geographic Coordinate system. It may be Geolocated with an EcefTransform\");\n\n    const geoConverter = this.geoServices.getConverter();\n    const coordResponse = await geoConverter.getGeoCoordinatesFromIModelCoordinates([spatial]);\n\n    if (this._noGcsDefined = (1 !== coordResponse.geoCoords.length || GeoCoordStatus.NoGCSDefined === coordResponse.geoCoords[0].s))\n      throw new IModelError(IModelStatus.NoGeoLocation, \"iModel does not have a Geographic Coordinate system. It may be Geolocated with an EcefTransform\");\n\n    if (GeoCoordStatus.Success !== coordResponse.geoCoords[0].s)\n      throw new IModelError(IModelStatus.BadRequest, \"Error converting spatial to cartographic\");\n\n    const longLatHeight = Point3d.fromJSON(coordResponse.geoCoords[0].p); // x is longitude in degrees, y is latitude in degrees, z is height in meters...\n    return Cartographic.fromDegrees(longLatHeight.x, longLatHeight.y, longLatHeight.z, result);\n  }\n\n  /** Convert a point in this iModel's Spatial coordinates to a [[Cartographic]] using the Geographic location services for this IModelConnection or [[IModel.ecefLocation]].\n   * @param spatial A point in the iModel's spatial coordinates\n   * @param result If defined, use this for output\n   * @returns A Cartographic location\n   * @throws IModelError if [[isGeoLocated]] is false or point could not be converted.\n   * @see [[spatialToCartographicFromGcs]]\n   * @see [[spatialToCartographicFromEcef]]\n   */\n  public async spatialToCartographic(spatial: XYAndZ, result?: Cartographic): Promise<Cartographic> {\n    if (undefined === this._noGcsDefined) {\n      try {\n        return await this.spatialToCartographicFromGcs(spatial, result);\n      } catch (error) {\n        if (!this._noGcsDefined)\n          throw error;\n      }\n    }\n    return (this._noGcsDefined ? this.spatialToCartographicFromEcef(spatial, result) : this.spatialToCartographicFromGcs(spatial, result));\n  }\n\n  /** Convert a [[Cartographic]] to a point in this iModel's Spatial coordinates using the Geographic location services for this IModelConnection.\n   * @param cartographic A cartographic location\n   * @param result If defined, use this for output\n   * @returns A point in this iModel's spatial coordinates\n   * @throws IModelError if [[isGeoLocated]] is false or cartographic location could not be converted.\n   */\n  public async cartographicToSpatialFromGcs(cartographic: Cartographic, result?: Point3d): Promise<Point3d> {\n    if (undefined === this._noGcsDefined && !this.isGeoLocated)\n      this._noGcsDefined = true;\n\n    if (this._noGcsDefined)\n      throw new IModelError(IModelStatus.NoGeoLocation, \"iModel does not have a Geographic Coordinate system. It may be Geolocated with an EcefTransform\");\n\n    const geoConverter = this.geoServices.getConverter();\n    const geoCoord = Point3d.create(Angle.radiansToDegrees(cartographic.longitude), Angle.radiansToDegrees(cartographic.latitude), cartographic.height); // x is longitude in degrees, y is latitude in degrees, z is height in meters...\n    const coordResponse = await geoConverter.getIModelCoordinatesFromGeoCoordinates([geoCoord]);\n\n    if (this._noGcsDefined = (1 !== coordResponse.iModelCoords.length || GeoCoordStatus.NoGCSDefined === coordResponse.iModelCoords[0].s))\n      throw new IModelError(IModelStatus.NoGeoLocation, \"iModel does not have a Geographic Coordinate system. It may be Geolocated with an EcefTransform\");\n\n    if (GeoCoordStatus.Success !== coordResponse.iModelCoords[0].s)\n      throw new IModelError(IModelStatus.BadRequest, \"Error converting cartographic to spatial\");\n\n    result = result ? result : Point3d.createZero();\n    result.setFromJSON(coordResponse.iModelCoords[0].p);\n    return result;\n  }\n\n  /** Convert a [[Cartographic]] to a point in this iModel's Spatial coordinates using the Geographic location services for this IModelConnection or [[IModel.ecefLocation]].\n   * @param cartographic A cartographic location\n   * @param result If defined, use this for output\n   * @returns A point in this iModel's spatial coordinates\n   * @throws IModelError if [[isGeoLocated]] is false or cartographic location could not be converted.\n   * @see [[cartographicToSpatialFromGcs]]\n   * @see [[cartographicToSpatialFromEcef]]\n   */\n  public async cartographicToSpatial(cartographic: Cartographic, result?: Point3d): Promise<Point3d> {\n    if (undefined === this._noGcsDefined) {\n      try {\n        return await this.cartographicToSpatialFromGcs(cartographic, result);\n      } catch (error) {\n        if (!this._noGcsDefined)\n          throw error;\n      }\n    }\n    return (this._noGcsDefined ? this.cartographicToSpatialFromEcef(cartographic, result) : this.cartographicToSpatialFromGcs(cartographic, result));\n  }\n}\n\n/** @public */\nexport namespace IModelConnection {\n\n  /** The id/name/class of a ViewDefinition. Returned by [[IModelConnection.Views.getViewList]] */\n  export interface ViewSpec {\n    /** The element id of the ViewDefinition. This string may be passed to [[IModelConnection.Views.load]]. */\n    id: string;\n    /** The name of the view. This string may be used to create a list with the possible view names. */\n    name: string;\n    /** The fullClassName of the ViewDefinition. Useful for sorting the list of views. */\n    class: string;\n  }\n\n  /** The collection of loaded ModelState objects for an [[IModelConnection]]. */\n  export class Models {\n    /** The set of loaded models for this IModelConnection, indexed by Id. */\n    public loaded = new Map<string, ModelState>();\n\n    /** @internal */\n    constructor(private _iModel: IModelConnection) { }\n\n    /** The Id of the [RepositoryModel]($backend). */\n    public get repositoryModelId(): string { return \"0x1\"; }\n\n    /** Get a batch of [[ModelProps]] given a list of Model ids. */\n    public async getProps(modelIds: Id64Arg): Promise<ModelProps[]> {\n      return IModelReadRpcInterface.getClient().getModelProps(this._iModel.iModelToken.toJSON(), [...Id64.toIdSet(modelIds)]);\n    }\n\n    /** Find a ModelState in the set of loaded Models by ModelId. */\n    public getLoaded(id: string): ModelState | undefined { return this.loaded.get(id); }\n\n    /** load a set of Models by Ids. After calling this method, you may get the ModelState objects by calling getLoadedModel. */\n    public async load(modelIds: Id64Arg): Promise<void> {\n      const notLoaded = new Set<string>();\n      Id64.forEach(modelIds, (id) => {\n        if (undefined === this.getLoaded(id))\n          notLoaded.add(id);\n      });\n\n      if (notLoaded.size === 0)\n        return; // all requested models are already loaded\n\n      try {\n        const propArray = await this.getProps(notLoaded);\n        for (const props of propArray) {\n          const ctor = await this._iModel.findClassFor(props.classFullName, ModelState);\n          const modelState = new ctor!(props, this._iModel); // create a new instance of the appropriate ModelState subclass\n          this.loaded.set(modelState.id, modelState as ModelState); // save it in loaded set\n        }\n      } catch (err) { }  // ignore error, we had nothing to do.\n    }\n\n    /** Query for a set of model ranges by ModelIds. */\n    public async queryModelRanges(modelIds: Id64Arg): Promise<Range3dProps[]> {\n      return IModelReadRpcInterface.getClient().queryModelRanges(this._iModel.iModelToken.toJSON(), [...Id64.toIdSet(modelIds)]);\n    }\n\n    /** Query for a set of ModelProps of the specified ModelQueryParams.\n     * @param queryParams The query parameters. The `limit` and `offset` members should be used to page results.\n     * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.\n     */\n    public async queryProps(queryParams: ModelQueryParams): Promise<ModelProps[]> {\n      const params: ModelQueryParams = Object.assign({}, queryParams); // make a copy\n      params.from = queryParams.from || ModelState.classFullName; // use \"BisCore:Model\" as default class name\n      params.where = queryParams.where || \"\";\n      if (!queryParams.wantPrivate) {\n        if (params.where.length > 0) params.where += \" AND \";\n        params.where += \"IsPrivate=FALSE \";\n      }\n      if (!queryParams.wantTemplate) {\n        if (params.where.length > 0) params.where += \" AND \";\n        params.where += \"IsTemplate=FALSE \";\n      }\n      return IModelReadRpcInterface.getClient().queryModelProps(this._iModel.iModelToken.toJSON(), params);\n    }\n\n    /** Asynchronously stream ModelProps using the specified ModelQueryParams.\n     * @alpha This method will replace IModelConnection.Models.queryProps as soon as auto-paging support is added\n     */\n    public async * query(queryParams: ModelQueryParams): AsyncIterableIterator<ModelProps> {\n      // NOTE: this implementation has the desired API signature, but its implementation must be improved to actually page results\n      const modelPropsArray: ModelProps[] = await this.queryProps(queryParams);\n      for (const modelProps of modelPropsArray) {\n        yield modelProps;\n      }\n    }\n\n    /** Code to run when the IModelConnection has closed. */\n    public onIModelConnectionClose() {\n      this.loaded.forEach((value: ModelState) => {\n        value.onIModelConnectionClose();\n      });\n    }\n  }\n\n  /** The collection of Elements for an [[IModelConnection]]. */\n  export class Elements {\n    /** @internal */\n    public constructor(private _iModel: IModelConnection) { }\n\n    /** The Id of the [root subject element]($docs/bis/intro/glossary.md#subject-root) for this iModel. */\n    public get rootSubjectId(): Id64String { return \"0x1\"; }\n\n    /** Get a set of element ids that satisfy a query */\n    public async queryIds(params: EntityQueryParams): Promise<Id64Set> { return this._iModel.queryEntityIds(params); }\n\n    /** Get an array of [[ElementProps]] given one or more element ids. */\n    public async getProps(arg: Id64Arg): Promise<ElementProps[]> {\n      return IModelReadRpcInterface.getClient().getElementProps(this._iModel.iModelToken.toJSON(), [...Id64.toIdSet(arg)]);\n    }\n\n    /** Get an array  of [[ElementProps]] that satisfy a query\n     * @param params The query parameters. The `limit` and `offset` members should be used to page results.\n     * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.\n     */\n    public async queryProps(params: EntityQueryParams): Promise<ElementProps[]> {\n      return IModelReadRpcInterface.getClient().queryElementProps(this._iModel.iModelToken.toJSON(), params);\n    }\n  }\n\n  /** The collection of [[CodeSpec]] entities for an [[IModelConnection]]. */\n  export class CodeSpecs {\n    private _loaded?: CodeSpec[];\n\n    /** @internal */\n    constructor(private _iModel: IModelConnection) { }\n\n    /** Loads all CodeSpec from the remote IModelDb. */\n    private async _loadAllCodeSpecs(): Promise<void> {\n      if (this._loaded)\n        return;\n\n      this._loaded = [];\n      const codeSpecArray: any[] = await IModelReadRpcInterface.getClient().getAllCodeSpecs(this._iModel.iModelToken.toJSON());\n      for (const codeSpec of codeSpecArray) {\n        this._loaded.push(new CodeSpec(this._iModel, Id64.fromString(codeSpec.id), codeSpec.name, codeSpec.jsonProperties));\n      }\n    }\n\n    /** Look up a CodeSpec by Id.\n     * @param codeSpecId The Id of the CodeSpec to load\n     * @returns The CodeSpec with the specified Id\n     * @throws [[IModelError]] if the Id is invalid or if no CodeSpec with that Id could be found.\n     */\n    public async getById(codeSpecId: Id64String): Promise<CodeSpec> {\n      if (!Id64.isValid(codeSpecId))\n        return Promise.reject(new IModelError(IModelStatus.InvalidId, \"Invalid codeSpecId\", Logger.logWarning, loggerCategory, () => ({ codeSpecId })));\n\n      await this._loadAllCodeSpecs(); // ensure all codeSpecs have been downloaded\n      const found: CodeSpec | undefined = this._loaded!.find((codeSpec: CodeSpec) => codeSpec.id === codeSpecId);\n      if (!found)\n        return Promise.reject(new IModelError(IModelStatus.NotFound, \"CodeSpec not found\", Logger.logWarning, loggerCategory));\n\n      return found;\n    }\n\n    /** Look up a CodeSpec by name.\n     * @param name The name of the CodeSpec to load\n     * @returns The CodeSpec with the specified name\n     * @throws [[IModelError]] if no CodeSpec with the specified name could be found.\n     */\n    public async getByName(name: string): Promise<CodeSpec> {\n      await this._loadAllCodeSpecs(); // ensure all codeSpecs have been downloaded\n      const found: CodeSpec | undefined = this._loaded!.find((codeSpec: CodeSpec) => codeSpec.name === name);\n      if (!found)\n        return Promise.reject(new IModelError(IModelStatus.NotFound, \"CodeSpec not found\", Logger.logWarning, loggerCategory));\n\n      return found;\n    }\n  }\n\n  /** The collection of views for an [[IModelConnection]]. */\n  export class Views {\n    /** @internal */\n    constructor(private _iModel: IModelConnection) { }\n\n    /** Query for an array of ViewDefinitionProps\n     * @param queryParams Query parameters specifying the views to return. The `limit` and `offset` members should be used to page results.\n     * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.\n     */\n    public async queryProps(queryParams: ViewQueryParams): Promise<ViewDefinitionProps[]> {\n      const params: ViewQueryParams = Object.assign({}, queryParams); // make a copy\n      params.from = queryParams.from || ViewState.classFullName; // use \"BisCore:ViewDefinition\" as default class name\n      params.where = queryParams.where || \"\";\n      if (queryParams.wantPrivate === undefined || !queryParams.wantPrivate) {\n        if (params.where.length > 0) params.where += \" AND \";\n        params.where += \"IsPrivate=FALSE \";\n      }\n      const viewProps = await IModelReadRpcInterface.getClient().queryElementProps(this._iModel.iModelToken.toJSON(), params);\n      assert((viewProps.length === 0) || (\"categorySelectorId\" in viewProps[0]), \"invalid view definition\");  // spot check that the first returned element is-a ViewDefinitionProps\n      return viewProps as ViewDefinitionProps[];\n    }\n\n    /** Get an array of the ViewSpecs for all views in this IModel that satisfy a ViewQueryParams.\n     *\n     * This is typically used to create a list for UI.\n     *\n     * For example:\n     * ```ts\n     * [[include:IModelConnection.Views.getViewList]]\n     * ```\n     * @param queryParams The parameters for the views to find. The `limit` and `offset` members should be used to page results.\n     * @throws [IModelError]($common) If the generated statement is invalid or would return too many props.\n     */\n    public async getViewList(queryParams: ViewQueryParams): Promise<ViewSpec[]> {\n      const views: ViewSpec[] = [];\n      const viewProps: ViewDefinitionProps[] = await this.queryProps(queryParams);\n      viewProps.forEach((viewProp) => { views.push({ id: viewProp.id as string, name: viewProp.code!.value!, class: viewProp.classFullName }); });\n      return views;\n    }\n\n    /** Query the ID of the default view associated with this iModel. Applications can choose to use this as the default view to which to open a viewport upon startup, or the initial selection\n     * within a view selection dialog, or similar purposes.\n     * @returns the ID of the default view, or an invalid ID if no default view is defined.\n     */\n    public async queryDefaultViewId(): Promise<Id64String> {\n      return IModelReadRpcInterface.getClient().getDefaultViewId(this._iModel.iModelToken.toJSON());\n    }\n\n    /** Load a [[ViewState]] object from the specified [[ViewDefinition]] id. */\n    public async load(viewDefinitionId: Id64String): Promise<ViewState> {\n      const viewProps = await IModelReadRpcInterface.getClient().getViewStateData(this._iModel.iModelToken.toJSON(), viewDefinitionId);\n      const className = viewProps.viewDefinitionProps.classFullName;\n      const ctor = await this._iModel.findClassFor<typeof EntityState>(className, undefined) as typeof ViewState | undefined;\n      if (undefined === ctor)\n        return Promise.reject(new IModelError(IModelStatus.WrongClass, \"Invalid ViewState class\", Logger.logError, loggerCategory, () => viewProps));\n\n      const viewState = ctor.createFromProps(viewProps, this._iModel)!;\n      await viewState.load(); // loads models for ModelSelector\n      return viewState;\n    }\n\n    /** Get a thumbnail for a view.\n     * @param viewId The id of the view of the thumbnail.\n     * @returns A Promise of the ThumbnailProps.\n     * @throws `Error` exception if no thumbnail exists.\n     */\n    public async getThumbnail(viewId: Id64String): Promise<ThumbnailProps> {\n      const val = await IModelReadRpcInterface.getClient().getViewThumbnail(this._iModel.iModelToken.toJSON(), viewId.toString());\n      const intVals = new Uint16Array(val.buffer);\n      return { format: intVals[1] === ImageSourceFormat.Jpeg ? \"jpeg\" : \"png\", width: intVals[2], height: intVals[3], image: new Uint8Array(val.buffer, 8, intVals[0]) };\n    }\n\n    /** Save a thumbnail for a view.\n     * @param viewId The id of the view for the thumbnail.\n     * @param thumbnail The thumbnail data to save.\n     * @returns A void Promise\n     * @throws `Error` exception if the thumbnail wasn't successfully saved.\n     */\n    public async saveThumbnail(viewId: Id64String, thumbnail: ThumbnailProps): Promise<void> {\n      const id = Id64.fromString(viewId.toString());\n      const val = new Uint8Array(thumbnail.image.length + 16);  // include the viewId and metadata in the binary transfer by allocating a new buffer 16 bytes larger than the image size\n      new Uint16Array(val.buffer).set([thumbnail.image.length, thumbnail.format === \"jpeg\" ? ImageSourceFormat.Jpeg : ImageSourceFormat.Png, thumbnail.width, thumbnail.height]); // metadata at offset 0\n      const low32 = Id64.getLowerUint32(id);\n      const high32 = Id64.getUpperUint32(id);\n      new Uint32Array(val.buffer, 8).set([low32, high32]); // viewId is 8 bytes starting at offset 8\n      new Uint8Array(val.buffer, 16).set(thumbnail.image); // image data at offset 16\n      return IModelWriteRpcInterface.getClient().saveThumbnail(this._iModel.iModelToken.toJSON(), val);\n    }\n  }\n\n  /** Provides access to tiles associated with an IModelConnection\n   * @internal\n   */\n  export class Tiles {\n    private _iModel: IModelConnection;\n    constructor(iModel: IModelConnection) { this._iModel = iModel; }\n    public async getTileTreeProps(id: string): Promise<TileTreeProps> { return IModelApp.tileAdmin.requestTileTreeProps(this._iModel, id); }\n    public async getTileContent(treeId: string, contentId: string): Promise<Uint8Array> { return IModelApp.tileAdmin.requestTileContent(this._iModel, treeId, contentId); }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { ImageSource, ImageSourceFormat, ImageBuffer, ImageBufferFormat } from \"@bentley/imodeljs-common\";\nimport { Point2d } from \"@bentley/geometry-core\";\n\ninterface Rgba {\n  r: number;\n  g: number;\n  b: number;\n  a: number;\n}\n\nconst scratchRgba = { r: 0, g: 0, b: 0, a: 0 };\n\nfunction rgbaFromAlpha(rgba: Rgba, src: Uint8Array, idx: number): number {\n  rgba.r = rgba.g = rgba.b = rgba.a = src[idx];\n  return idx + 1;\n}\n\nfunction rgbaFromRgb(rgba: Rgba, src: Uint8Array, idx: number): number {\n  rgba.r = src[idx + 0];\n  rgba.g = src[idx + 1];\n  rgba.b = src[idx + 2];\n  rgba.a = 255;\n  return idx + 3;\n}\n\nfunction rgbaFromRgba(rgba: Rgba, src: Uint8Array, idx: number): number {\n  rgbaFromRgb(rgba, src, idx);\n  rgba.a = src[idx + 3];\n  return idx + 4;\n}\n\n/** Creates a canvas element with the same dimensions and contents as the ImageBuffer. */\nfunction imageBufferToCanvas(buffer: ImageBuffer): HTMLCanvasElement | undefined {\n  const canvas = document.createElement(\"canvas\");\n  if (null === canvas)\n    return undefined;\n\n  canvas.width = buffer.width;\n  canvas.height = buffer.height;\n\n  const context = canvas.getContext(\"2d\");\n  if (null === context)\n    return undefined;\n\n  const imageData = context.createImageData(buffer.width, buffer.height);\n  const extractRgba = ImageBufferFormat.Alpha === buffer.format ? rgbaFromAlpha : (ImageBufferFormat.Rgb === buffer.format ? rgbaFromRgb : rgbaFromRgba);\n\n  const bufferData = buffer.data;\n  let i = 0;\n  let j = 0;\n  const rgba = scratchRgba;\n  while (i < bufferData.length) {\n    i = extractRgba(rgba, bufferData, i);\n    imageData.data[j + 0] = rgba.r;\n    imageData.data[j + 1] = rgba.g;\n    imageData.data[j + 2] = rgba.b;\n    imageData.data[j + 3] = rgba.a;\n    j += 4;\n  }\n\n  context.putImageData(imageData, 0, 0);\n  return canvas;\n}\n\n/** Get a string describing the mime type associated with an ImageSource format.\n * @public\n */\nexport function getImageSourceMimeType(format: ImageSourceFormat): string {\n\n  switch (format) {\n    case ImageSourceFormat.Jpeg:\n      return \"image/jpeg\";\n    case ImageSourceFormat.Png:\n      return \"image/png\";\n    case ImageSourceFormat.Svg:\n      return \"image/svg+xml;charset=utf-8\";\n  }\n  return \"\";\n}\n\n/** Get the ImageSourceFormat corresponding to the mime type string, or undefined if the string does not identify a supported ImageSourceFormat.\n * @public\n */\nexport function getImageSourceFormatForMimeType(mimeType: string): ImageSourceFormat | undefined {\n  switch (mimeType) {\n    case \"image/jpeg\": return ImageSourceFormat.Jpeg;\n    case \"image/png\": return ImageSourceFormat.Png;\n    case \"image/svg+xml;charset=utf-8\": return ImageSourceFormat.Svg;\n    default: return undefined;\n  }\n}\n\n/** Extract an html Image element from a binary jpeg or png.\n * @param source The ImageSource containing the binary jpeg or png data.\n * @returns a Promise which resolves to an HTMLImageElement containing the uncompressed bitmap image in RGBA format.\n * @public\n */\nexport async function imageElementFromImageSource(source: ImageSource): Promise<HTMLImageElement> {\n  const blob = new Blob([source.data], { type: getImageSourceMimeType(source.format) });\n  return imageElementFromUrl(URL.createObjectURL(blob));\n}\n\n/** Create an html Image element from a URL.\n * @param url The URL pointing to the image data.\n * @returns A Promise resolving to an HTMLImageElement when the image data has been loaded from the URL.\n * @public\n */\nexport async function imageElementFromUrl(url: string): Promise<HTMLImageElement> {\n  return new Promise((resolve: (image: HTMLImageElement) => void, reject) => {\n    const image = new Image();\n    image.onload = () => resolve(image);\n    image.onerror = reject;\n    image.src = url;\n  });\n}\n\n/**\n * Extract the dimensions of the jpeg or png data encoded in an ImageSource.\n * @param source The ImageSource containing the binary jpeg or png data.\n * @returns a Promise resolving to a Point2d of which x corresponds to the integer width of the uncompressed bitmap and y to the height.\n * @public\n */\nexport async function extractImageSourceDimensions(source: ImageSource): Promise<Point2d> {\n  return imageElementFromImageSource(source).then((image) => new Point2d(image.naturalWidth, image.naturalHeight));\n}\n\n/**\n * Produces a data url in \"image/png\" format from the contents of an ImageBuffer.\n * @param buffer The ImageBuffer, of any format.\n * @returns a data url as a string suitable for setting as the `src` property of an HTMLImageElement, or undefined if the url could not be created.\n * @public\n */\nexport function imageBufferToPngDataUrl(buffer: ImageBuffer): string | undefined {\n  // The default format (and the only format required to be supported) for toDataUrl() is \"image/png\".\n  const canvas = imageBufferToCanvas(buffer);\n  return undefined !== canvas ? canvas.toDataURL() : undefined;\n}\n\n/**\n * Converts the contents of an ImageBuffer to PNG format.\n * @param buffer The ImageBuffer, of any format.\n * @returns a base64-encoded string representing the image as a PNG, or undefined if the conversion failed.\n * @public\n */\nexport function imageBufferToBase64EncodedPng(buffer: ImageBuffer): string | undefined {\n  const urlPrefix = \"data:image/png;base64,\";\n  const url = imageBufferToPngDataUrl(buffer);\n  if (undefined === url || !url.startsWith(urlPrefix))\n    return undefined;\n\n  return url.substring(urlPrefix.length);\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Views */\r\n\r\nimport { Point2d, Point3d, XAndY, XYAndZ, Range1d, Range1dProps, Geometry, Matrix4d } from \"@bentley/geometry-core\";\r\nimport { imageElementFromUrl } from \"./ImageUtil\";\r\nimport { DecorateContext } from \"./ViewContext\";\r\nimport { CanvasDecoration } from \"./render/System\";\r\nimport { ViewRect, Viewport } from \"./Viewport\";\r\nimport { BeButtonEvent } from \"./tools/Tool\";\r\nimport { ColorDef } from \"@bentley/imodeljs-common\";\r\nimport { ToolTipOptions } from \"./NotificationManager\";\r\n\r\n/** The types that may be used for Markers\r\n * @public\r\n */\r\nexport type MarkerImage = HTMLImageElement | HTMLCanvasElement | HTMLVideoElement | ImageBitmap;\r\n\r\n/** @public */\r\nexport type MarkerFillStyle = string | CanvasGradient | CanvasPattern;\r\n\r\n/** @public */\r\nexport type MarkerTextAlign = \"left\" | \"right\" | \"center\" | \"start\" | \"end\";\r\n\r\n/** @public */\r\nexport type MarkerTextBaseline = \"top\" | \"hanging\" | \"middle\" | \"alphabetic\" | \"ideographic\" | \"bottom\";\r\n\r\n/** A Marker is a [[CanvasDecoration]], whose position follows a fixed location in world space.\r\n * Markers draw on top of all scene graphics, and show visual cues about locations of interest.\r\n * @see [Markers]($docs/learning/frontend/Markers)\r\n * @public\r\n */\r\nexport class Marker implements CanvasDecoration {\r\n  protected _scaleFactor?: Point2d;\r\n  protected _scaleFactorRange?: Range1d;\r\n\r\n  /** Whether this marker is currently enabled. If false, this Marker is not displayed. */\r\n  public visible = true;\r\n  /** Whether this marker is currently hilited or not. */\r\n  protected _isHilited = false;\r\n  /** The color for the shadowBlur when this Marker is hilited */\r\n  protected _hiliteColor?: ColorDef;\r\n  /** The location of this Marker in world coordinates. */\r\n  public worldLocation: Point3d;\r\n  /** The size of this Marker, in pixels. */\r\n  public size: Point2d;\r\n  /** The current position for the marker, in view coordinates (pixels). This value will be updated by calls to [[setPosition]]. */\r\n  public position: Point3d;\r\n  /** The current rectangle for the marker, in view coordinates (pixels). This value will be updated by calls to [[setPosition]]. */\r\n  public readonly rect = new ViewRect();\r\n  /** An image to draw for this Marker. If undefined, no image is shown. See https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/drawImage.  */\r\n  public image?: MarkerImage;\r\n  /** The offset for [[image]], in pixels, from the *center* of this Marker. If undefined, (0,0). */\r\n  public imageOffset?: XAndY;\r\n  /** The size of [[image]], in pixels. If undefined, use [[size]]. */\r\n  public imageSize?: XAndY;\r\n  /** A text Label for this Marker. If undefined, no label is displayed. */\r\n  public label?: string;\r\n  /** The offset for [[label]], in pixels, from the *center* of this Marker. If undefined, (0,0). */\r\n  public labelOffset?: XAndY;\r\n  /** The color for [[label]]. See  https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/fillStyle. If undefined, \"white\". */\r\n  public labelColor?: MarkerFillStyle;\r\n  /** The text alignment for [[label]]. See https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textAlign. If undefined, \"center\" */\r\n  public labelAlign?: MarkerTextAlign;\r\n  /** The text baseline for [[label]]. See https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/textBaseline. If undefined, \"middle\" */\r\n  public labelBaseline?: MarkerTextBaseline;\r\n  /** The font for [[label]]. See https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/font. */\r\n  public labelFont?: string;\r\n  /** The title string to show in the ToolTip when the pointer is over this Marker. See [[NotificationManager.openToolTip]] */\r\n  public title?: HTMLElement | string;\r\n  /** The ToolTipOptions to use for [[title]]. */\r\n  public tooltipOptions?: ToolTipOptions;\r\n\r\n  /** Return true to display [[image]], if present. */\r\n  public get wantImage() { return true; }\r\n\r\n  /** Implement this function to draw onto the CanvasRenderingContext2D when this Marker is displayed. The [0,0] point will be the center of the Marker. */\r\n  public drawFunc?(ctx: CanvasRenderingContext2D): void;\r\n\r\n  /** Called when the mouse pointer enters this Marker. */\r\n  public onMouseEnter(ev: BeButtonEvent) { this._isHilited = true; this._hiliteColor = ev.viewport!.hilite.color; }\r\n\r\n  /** Called when the mouse pointer leaves this Marker. */\r\n  public onMouseLeave() { this._isHilited = false; }\r\n\r\n  /** Called when the mouse pointer moves over this Marker */\r\n  public onMouseMove(ev: BeButtonEvent): void {\r\n    if (this.title)\r\n      ev.viewport!.openToolTip(this.title, ev.viewPoint, this.tooltipOptions);\r\n  }\r\n  /** Called when a mouse button is pressed over this Marker. */\r\n  public onMouseButton?(_ev: BeButtonEvent): boolean;\r\n\r\n  /** Determine whether the point is within this Marker.  */\r\n  public pick(pt: XAndY): boolean { return this.rect.containsPoint(pt); }\r\n\r\n  /** Establish a range of scale factors to increases and decrease the size of this Marker based on its distance from the camera.\r\n   * @param range The minimum and maximum scale factors to be applied to the size of this Marker based on its distance from the camera. `range.Low` is the scale factor\r\n   * for Markers at the back of the view frustum and `range.high` is the scale factor at the front of the view frustum.\r\n   * @note Marker size scaling is only applied in views with the camera enabled. It has no effect on orthographic views.\r\n   */\r\n  public setScaleFactor(range: Range1dProps) {\r\n    this._scaleFactorRange = Range1d.fromJSON(range);\r\n    this._scaleFactor = Point2d.create(1, 1);\r\n  }\r\n\r\n  /** Constructor for Marker\r\n   * @param worldLocation The location of this Marker in world coordinates.\r\n   * @param size The size of this Marker in pixels.\r\n   */\r\n  constructor(worldLocation: XYAndZ, size: XAndY) {\r\n    this.worldLocation = Point3d.createFrom(worldLocation);\r\n    this.size = Point2d.createFrom(size);\r\n    this.position = new Point3d();\r\n  }\r\n\r\n  /** Make a new Marker at the same position and size as this Marker.\r\n   * Thew new Marker will share the world location and size objects, but will be otherwise blank.\r\n   */\r\n  public static makeFrom<T extends Marker>(other: Marker, ...args: any[]): T {\r\n    const out = new (this as any)(other.worldLocation, other.size, ...args) as T;\r\n    out.rect.setFrom(other.rect);\r\n    out.position.setFrom(other.position);\r\n    if (other._scaleFactor)\r\n      out._scaleFactor = Point2d.createFrom(other._scaleFactor);\r\n    out._scaleFactorRange = other._scaleFactorRange;\r\n    return out;\r\n  }\r\n\r\n  /** When a Marker is displayed in its hilited state, this method is called first. If it returns true, no further action is taken.\r\n   * Otherwise the Marker's normal drawing operations are also called. By default, this method adds a shadowBlur effect and increases\r\n   * the size of the Marker by 25%.\r\n   * @return true to stop drawing this Marker\r\n   */\r\n  protected drawHilited(ctx: CanvasRenderingContext2D) {\r\n    ctx.shadowBlur = 30;\r\n    ctx.shadowColor = this._hiliteColor ? this._hiliteColor.toHexString() : \"white\";\r\n    ctx.scale(1.25, 1.25);\r\n    return false;\r\n  }\r\n\r\n  /** Called during frame rendering to display this Marker onto the supplied context. */\r\n  public drawDecoration(ctx: CanvasRenderingContext2D): void {\r\n    if (this._isHilited && this.drawHilited(ctx))\r\n      return;\r\n\r\n    if (this._scaleFactor !== undefined)\r\n      ctx.scale(this._scaleFactor.x, this._scaleFactor.y);\r\n\r\n    // first call the \"drawFunc\" if defined. This means it will be below the image and label if they overlap\r\n    if (undefined !== this.drawFunc)\r\n      this.drawFunc(ctx);\r\n\r\n    // next draw the image, if defined and desired\r\n    if (this.wantImage && this.image !== undefined) {\r\n      const size = this.imageSize ? this.imageSize : this.size;\r\n      const offset = new Point2d(size.x / 2, size.y / 2);\r\n      if (this.imageOffset)\r\n        offset.plus(this.imageOffset, offset);\r\n      ctx.drawImage(this.image, -offset.x, -offset.y, size.x, size.y);\r\n    }\r\n\r\n    // lastly, draw the label, if defined. This puts it on top of all other graphics for this Marker.\r\n    if (this.label !== undefined) {\r\n      ctx.textAlign = this.labelAlign ? this.labelAlign : \"center\";\r\n      ctx.textBaseline = this.labelBaseline ? this.labelBaseline : \"middle\";\r\n      ctx.font = this.labelFont ? this.labelFont : \"14px san-serif\";\r\n      ctx.fillStyle = this.labelColor ? this.labelColor : \"white\";\r\n      ctx.fillText(this.label, this.labelOffset ? -this.labelOffset.x : 0, this.labelOffset ? -this.labelOffset.y : 0);\r\n    }\r\n  }\r\n\r\n  /** Set the [[image]] for this marker.\r\n   * @param image Either a [[MarkerImage]] or a Promise for a [[MarkerImage]]. If a Promise is supplied, the [[image]] member is set\r\n   * when the Promise resolves.\r\n   */\r\n  public setImage(image: MarkerImage | Promise<MarkerImage>) {\r\n    if (image instanceof Promise)\r\n      image.then((resolvedImage) => this.image = resolvedImage); // tslint:disable-line:no-floating-promises\r\n    else\r\n      this.image = image;\r\n  }\r\n\r\n  /** Set the image for this Marker from a URL. */\r\n  public setImageUrl(url: string) { this.setImage(imageElementFromUrl(url)); }\r\n\r\n  /** Set the position (in pixels) for this Marker in the supplied Viewport, based on its worldLocation.\r\n   * @return true if the Marker is visible and its new position is inside the Viewport.\r\n   */\r\n  public setPosition(vp: Viewport): boolean {\r\n    if (!this.visible) // if we're turned off, skip\r\n      return false;\r\n\r\n    const pt4 = vp.worldToView4d(this.worldLocation);\r\n    if (pt4.w > 1.0 || pt4.w < 0) // outside of frustum.\r\n      return false;\r\n\r\n    pt4.realPoint(this.position);\r\n    if (!vp.viewRect.containsPoint(this.position))\r\n      return false; // outside this viewport rect\r\n\r\n    const origin = this.position;\r\n    const sizeX = this.size.x / 2;\r\n    const sizeY = this.size.y / 2;\r\n    this.rect.init(origin.x - sizeX, origin.y - sizeY, origin.x + sizeX, origin.y + sizeY);\r\n\r\n    // if there's a scale factor active, calculate it now.\r\n    if (this._scaleFactor && this._scaleFactorRange) {\r\n      let scale = 1.0;\r\n      if (vp.isCameraOn) {\r\n        const range = this._scaleFactorRange;\r\n        scale = Geometry.clamp(range.low + ((1 - pt4.w) * range.length()), .4, 2.0);\r\n        this.rect.scaleAboutCenter(scale, scale);\r\n      }\r\n      this._scaleFactor.set(scale, scale);\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /** Add this Marker to the supplied Decorate context. */\r\n  public addMarker(context: DecorateContext) { context.addCanvasDecoration(this); }\r\n\r\n  /** Set the position and ddd this Marker to the supplied DecorateContext, if it's visible.\r\n   * This method should be called from your implementation of [[Decorator.decorate]]. It will set this Marker's position based the\r\n   * Viewport from the context, and add this this Marker to the supplied DecorateContext.\r\n   * @param context The DecorateContext for the Marker\r\n   */\r\n  public addDecoration(context: DecorateContext) {\r\n    if (this.setPosition(context.viewport))\r\n      this.addMarker(context);\r\n  }\r\n}\r\n\r\n/** A cluster of one or more Markers that overlap one another in the view. The cluster's screen position is taken from its first entry.\r\n * Clusters also have a Marker themselves, that represents the whole group. The cluster marker isn't created until all entries have been added.\r\n * @public\r\n */\r\nexport class Cluster<T extends Marker> {\r\n  public readonly rect: ViewRect;\r\n  public clusterMarker?: Marker;\r\n\r\n  public constructor(public readonly markers: T[]) {\r\n    this.rect = markers[0].rect;\r\n    this.markers = markers;\r\n  }\r\n}\r\n\r\n/** A *set* of Markers that are logically related, such that they *cluster* when they overlap one another in screen space.\r\n * In that case, a *cluster marker* is drawn instead of the overlapping Markers.\r\n * @public\r\n */\r\nexport abstract class MarkerSet<T extends Marker> {\r\n  /** @internal */\r\n  protected _entries: Array<T | Cluster<T>> = []; // this is an array that holds either Markers or a cluster of markers.\r\n  /** @internal */\r\n  protected readonly _worldToViewMap = Matrix4d.createZero();\r\n\r\n  /** The minimum number of Markers that must overlap before they are clustered. Otherwise they are each drawn individually. Default is 1 (always create a cluster.) */\r\n  public minimumClusterSize = 1;\r\n  /** The set of Markers in this MarkerSet. Add your [[Marker]]s into this. */\r\n  public readonly markers = new Set<T>();\r\n\r\n  /** Implement this method to create a new Marker that is shown as a *stand-in* for a Cluster of Markers that overlap one another.\r\n   * @param cluster The [[Cluster]] that the new Marker will represent.\r\n   * @returns The Marker that will be displayed to represent the Cluster.\r\n   * @note You must create a new Marker each time this method is called.\r\n   */\r\n  protected abstract getClusterMarker(cluster: Cluster<T>): Marker;\r\n\r\n  /** This method should be called from [[Decorator.decorate]]. It will add this this MarkerSet to the supplied DecorateContext.\r\n   * This method implements the logic that turns overlapping Markers into a Cluster.\r\n   * @param context The DecorateContext for the Markers\r\n   */\r\n  public addDecoration(context: DecorateContext) {\r\n    const vp = context.viewport;\r\n    const entries = this._entries;\r\n\r\n    // Don't recreate the entries array if the view hasn't changed. This is important for performance, but also necessary for hilite of\r\n    // clusters (otherwise they're recreated continually and never hilited.) */\r\n    if (!this._worldToViewMap.isAlmostEqual(vp.worldToViewMap.transform0)) {\r\n      this._worldToViewMap.setFrom(vp.worldToViewMap.transform0);\r\n      entries.length = 0;   // start over.\r\n      // loop through all of the Markers in the MarkerSet.\r\n      for (const marker of this.markers) {\r\n        // establish the screen position for this marker. If it's not in view, setPosition returns false\r\n        if (!marker.setPosition(vp))\r\n          continue;\r\n\r\n        let added = false;\r\n        for (let i = 0; i < entries.length; ++i) { // loop through all of the currently visible markers/clusters\r\n          const entry = entries[i];\r\n          if (marker.rect.overlaps(entry.rect)) { // does new Marker overlap with this entry?\r\n            added = true; // yes, we're going to save it as a Cluster\r\n            if (entry instanceof Cluster) { // is the entry already a Cluster?\r\n              entry.markers.push(marker); // yes, just add this to the existing cluster\r\n            } else {\r\n              entries[i] = new Cluster([entry, marker]); // no, make a new Cluster holding both\r\n            }\r\n            break; // this Marker has been handled, we can stop looking for overlaps\r\n          }\r\n        }\r\n        if (!added)\r\n          entries.push(marker); // there was no overlap, save this Marker to be drawn\r\n      }\r\n    }\r\n\r\n    // we now have an array of Markers and Clusters, add them to context\r\n    for (const entry of entries) {\r\n      if (entry instanceof Cluster) { // is this entry a Cluster?\r\n        if (entry.markers.length <= this.minimumClusterSize) { // yes, does it have more than the minimum number of entries?\r\n          entry.markers.forEach((marker) => marker.addMarker(context)); // no, just draw all of its Markers\r\n        } else {\r\n          // yes, get and draw the Marker for this Cluster\r\n          if (undefined === entry.clusterMarker) // have we already created this cluster marker?\r\n            entry.clusterMarker = this.getClusterMarker(entry); // no, get it now.\r\n          entry.clusterMarker.addMarker(context);\r\n        }\r\n      } else {\r\n        entry.addMarker(context); // entry is a non-overlapping Marker, draw it.\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\n\nimport { Id64, Id64Arg, Id64String } from \"@bentley/bentleyjs-core\";\nimport { ElementState } from \"./EntityState\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { ModelSelectorProps } from \"@bentley/imodeljs-common\";\nimport { SpatialClassification } from \"./SpatialClassification\";\n\n/** The state of a [ModelSelector]($backend). It holds a set of ids of GeometricModels for a [[SpatialViewState]].\n * It defines the set of [[ModelState]]s drawn within the view as a set of IDs.\n * @public\n */\nexport class ModelSelectorState extends ElementState {\n  /** @internal */\n  public static get className() { return \"ModelSelector\"; }\n\n  /** The set of ModelIds of this ModelSelectorState */\n  public readonly models = new Set<string>();\n  constructor(props: ModelSelectorProps, iModel: IModelConnection) {\n    super(props, iModel);\n    if (props.models)\n      props.models.forEach((model) => this.models.add(model));\n  }\n\n  /** The name of this ModelSelector */\n  public get name(): string { return this.code.getValue(); }\n\n  public toJSON(): ModelSelectorProps {\n    const val: any = super.toJSON();\n    val.models = [];\n    this.models.forEach((model) => val.models.push(model));\n    return val;\n  }\n\n  /** Determine if this model selector is logically equivalent to the specified model selector. Two model selectors are logically equivalent is\n   * they have the same name and Id and contain the same set of models.\n   * @param other The model selector to which to compare.\n   * @returns true if the model selectors are logically equivalent.\n   * @public\n   */\n  public equalState(other: ModelSelectorState): boolean {\n    if (this.models.size !== other.models.size || this.id !== other.id || this.name !== other.name)\n      return false;\n\n    const otherIter = other.models.keys();\n    let otherRes = otherIter.next();\n    for (let thisIter = this.models.keys(), thisRes = thisIter.next(); !thisRes.done; thisRes = thisIter.next(), otherRes = otherIter.next()) {\n      if (thisRes.value !== otherRes.value)\n        return false;\n    }\n\n    return true;\n  }\n\n  /** Add one or more models to this ModelSelectorState */\n  public addModels(arg: Id64Arg): void {\n    Id64.forEach(arg, (id) => this.models.add(id));\n  }\n\n  /** Drop one or more models from this ModelSelectorState */\n  public dropModels(arg: Id64Arg): void {\n    Id64.forEach(arg, (id) => this.models.delete(id));\n  }\n\n  /** Determine whether this ModelSelectorState includes the specified modelId value */\n  public has(id: string): boolean { return this.models.has(id); }\n\n  /** Determine whether this ModelSelectorState includes the specified modelId */\n  public containsModel(modelId: Id64String): boolean { return this.has(modelId.toString()); }\n\n  /** Make sure all models referenced by this ModelSelectorState are loaded. */\n  public async load(): Promise<void> {\n\n    return this.iModel.models.load(this.models).then(async (_) => SpatialClassification.loadModelClassifiers(this.models, this.iModel));\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module ModelState */\n\nimport { dispose, Id64, Id64String, JsonUtils, IModelStatus } from \"@bentley/bentleyjs-core\";\nimport { Point2d, Range3d } from \"@bentley/geometry-core\";\nimport { BatchType, GeometricModel2dProps, ModelProps, RelatedElement, TileTreeProps } from \"@bentley/imodeljs-common\";\nimport { EntityState } from \"./EntityState\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { IModelTile } from \"./tile/IModelTile\";\nimport { RealityModelTileTree } from \"./tile/RealityModelTileTree\";\nimport { TileTree, TileTreeState } from \"./tile/TileTree\";\n\n/** Represents the front-end state of a [Model]($backend).\n * @public\n */\nexport class ModelState extends EntityState implements ModelProps {\n  /** @internal */\n  public static get className() { return \"Model\"; }\n  public readonly modeledElement: RelatedElement;\n  public readonly name: string;\n  public parentModel: Id64String;\n  public readonly isPrivate: boolean;\n  public readonly isTemplate: boolean;\n\n  constructor(props: ModelProps, iModel: IModelConnection) {\n    super(props, iModel);\n    this.modeledElement = RelatedElement.fromJSON(props.modeledElement)!;\n    this.name = props.name ? props.name : \"\";\n    this.parentModel = Id64.fromJSON(props.parentModel)!; // NB! Must always match the model of the modeledElement!\n    this.isPrivate = JsonUtils.asBool(props.isPrivate);\n    this.isTemplate = JsonUtils.asBool(props.isTemplate);\n  }\n\n  /** Add all custom-handled properties of a Model to a json object. */\n  public toJSON(): ModelProps {\n    const val = super.toJSON() as ModelProps;\n    val.modeledElement = this.modeledElement;\n    val.parentModel = this.parentModel;\n    val.name = this.name;\n    if (this.isPrivate)\n      val.isPrivate = this.isPrivate;\n    if (this.isTemplate)\n      val.isTemplate = this.isTemplate;\n    return val;\n  }\n\n  /** Determine whether this is a GeometricModel */\n  public get isGeometricModel(): boolean { return false; }\n\n  /** Attempts to cast this model to a geometric model. */\n  public get asGeometricModel(): GeometricModelState | undefined { return undefined; }\n  /** Attempts to cast this model to a 3d geometric model. */\n  public get asGeometricModel3d(): GeometricModel3dState | undefined { return undefined; }\n  /** Attempts to cast this model to a 2d geometric model. */\n  public get asGeometricModel2d(): GeometricModel2dState | undefined { return undefined; }\n\n  /** Executes just before the containing IModelConnection is closed to perform any necessary cleanup.\n   * @internal\n   */\n  public onIModelConnectionClose() { }\n}\n\n/** Interface adopted by an object which can supply a tile tree for display within a [[ViewState]].\n * Typically tile trees are obtained from geometric models, but they may also originate from display style settings\n * such as a background map provider or a set of \"context\" reality models not directly embedded into the iModel.\n * An application typically does not interact directly with tile trees; instead it interacts with a [[ViewState]] or [[Viewport]] which\n * coordinates with tile trees on its behalf.\n * @alpha\n */\nexport interface TileTreeModelState {\n  /** If the tile tree is loaded, returns it.\n   * @see [[load]]\n   * @internal\n   */\n  readonly tileTree: TileTree | undefined;\n  /** @internal */\n  readonly loadStatus: TileTree.LoadStatus;\n  /** @internal */\n  readonly treeModelId: Id64String; // Model Id, or transient Id if not a model (context reality model)\n  /** @internal */\n  readonly jsonProperties: { [key: string]: any };\n  /** @internal */\n  readonly iModel: IModelConnection;\n  /** If no attempt has yet been made to load the tile tree, enqueue it for asynchronous loading.\n   * @param edgesRequired If true, the loaded tile tree will include graphics for edges of surfaces.\n   * @param animationId The Id of the source animation node, if any.\n   * @returns The current load status of the tile tree.\n   * @note This function is *not* asynchronous, but may trigger an internal asynchronous operation.\n   * @see [[TileTreeModelState.loadStatus]] to query the current state of the tile tree's loading operation.\n   * @internal\n   */\n  loadTree(edgesRequired: boolean, animationId?: Id64String): TileTree.LoadStatus;\n}\n\n/** Represents the front-end state of a [GeometricModel]($backend).\n * The contents of a GeometricModelState can be rendered inside a [[Viewport]].\n * @public\n */\nexport abstract class GeometricModelState extends ModelState /* implements TileTreeModelState */ {\n  /** @internal */\n  public static get className() { return \"GeometricModel\"; }\n\n  private _modelRange?: Range3d;\n  /** @internal */\n  protected _tileTreeState: TileTreeState = new TileTreeState(this.iModel, !this.is2d, this.id);\n  /** @internal */\n  protected _classifierTileTreeState: TileTreeState = new TileTreeState(this.iModel, !this.is2d, this.id);\n\n  /** Returns true if this is a 3d model (a [[GeometricModel3dState]]). */\n  public abstract get is3d(): boolean;\n  /** @internal */\n  public get asGeometricModel(): GeometricModelState { return this; }\n  /** Returns true if this is a 2d model (a [[GeometricModel2dState]]). */\n  public get is2d(): boolean { return !this.is3d; }\n\n  /** @internal */\n  public get tileTree(): TileTree | undefined { return this._tileTreeState.tileTree; }\n  /** @internal */\n  public get classifierTileTree(): TileTree | undefined { return this._classifierTileTreeState.tileTree; }\n\n  /** @internal */\n  public get loadStatus(): TileTree.LoadStatus { return this._tileTreeState.loadStatus; }\n  public set loadStatus(status: TileTree.LoadStatus) { this._tileTreeState.loadStatus = status; }\n\n  /** @internal */\n  public get isGeometricModel(): boolean { return true; }\n  /** @internal */\n  public get treeModelId(): Id64String { return this.id; }\n\n  /** @internal */\n  public loadTree(edgesRequired: boolean, animationId?: Id64String): TileTree.LoadStatus {\n    // If this is a reality model, its tile tree is obtained from reality data service URL.\n    if (undefined !== this.jsonProperties.tilesetUrl) {\n      if (TileTree.LoadStatus.NotLoaded === this.loadStatus) {\n        this.loadStatus = TileTree.LoadStatus.Loading;\n        RealityModelTileTree.loadRealityModelTileTree(this.jsonProperties.tilesetUrl, this.jsonProperties.tilesetToDbTransform, this._tileTreeState);\n      }\n\n      return this.loadStatus;\n    }\n\n    return this.loadTileTree({ type: BatchType.Primary, edgesRequired, animationId });\n  }\n\n  /** @internal */\n  public loadClassifierTileTree(type: BatchType.PlanarClassifier | BatchType.VolumeClassifier, expansion: number): TileTree.LoadStatus {\n    return this.loadTileTree({ type, expansion });\n  }\n\n  /** @internal */\n  public loadTileTree(treeId: IModelTile.TreeId): TileTree.LoadStatus {\n    // Determine which tree we want, and invalidate if incompatible with supplied options.\n    let state: TileTreeState;\n    let allowInstancing = false;\n    let batchType: BatchType;\n    let edgesRequired = false;\n    let animationId: Id64String | undefined;\n    if (treeId.type === BatchType.Primary) {\n      batchType = BatchType.Primary;\n      edgesRequired = treeId.edgesRequired;\n      animationId = treeId.animationId;\n      state = this._tileTreeState;\n      if ((edgesRequired && state.edgesOmitted) || animationId !== state.animationId)\n        state.clearTileTree();\n\n      if (undefined === treeId.animationId)\n        allowInstancing = true;\n    } else {\n      state = this._classifierTileTreeState;\n      batchType = treeId.type;\n      if (state.classifierExpansion !== treeId.expansion) {\n        state.clearTileTree();\n        state.classifierExpansion = treeId.expansion;\n      }\n    }\n\n    // If we've already tried to load, return current status.\n    if (TileTree.LoadStatus.NotLoaded !== state.loadStatus)\n      return state.loadStatus;\n\n    // Enqueue the tree for loading.\n    state.loadStatus = TileTree.LoadStatus.Loading;\n\n    const id = IModelTile.treeIdToString(this.id, treeId);\n    this.iModel.tiles.getTileTreeProps(id).then((result: TileTreeProps) => {\n      const loader = new IModelTile.Loader(this.iModel, result.formatVersion, batchType, edgesRequired, allowInstancing);\n      result.rootTile.contentId = loader.rootContentId;\n      state.setTileTree(result, loader);\n\n      state.edgesOmitted = !edgesRequired;\n      state.animationId = animationId;\n\n      IModelApp.viewManager.onNewTilesReady();\n    }).catch((err) => {\n      // Retry in case of timeout; otherwise fail.\n      if (err.errorNumber && err.errorNumber === IModelStatus.ServerTimeout)\n        state.loadStatus = TileTree.LoadStatus.NotLoaded;\n      else\n        state.loadStatus = TileTree.LoadStatus.NotFound;\n\n      IModelApp.viewManager.onNewTilesReady();\n    });\n\n    return state.loadStatus;\n  }\n\n  /** @internal */\n  public onIModelConnectionClose() {\n    dispose(this._tileTreeState.tileTree);  // we do not track if we are disposed...catch this at the tileTree level\n    super.onIModelConnectionClose();\n  }\n\n  /** Query for the union of the ranges of all the elements in this GeometricModel. */\n  public async queryModelRange(): Promise<Range3d> {\n    if (undefined === this._modelRange) {\n      const ranges = await this.iModel.models.queryModelRanges(this.id);\n      this._modelRange = Range3d.fromJSON(ranges[0]);\n    }\n    return this._modelRange!;\n  }\n}\n\n/** Represents the front-end state of a [GeometricModel2d]($backend).\n * @public\n */\nexport class GeometricModel2dState extends GeometricModelState implements GeometricModel2dProps {\n  /** @internal */\n  public static get className() { return \"GeometricModel2d\"; }\n  /** @internal */\n  public readonly globalOrigin: Point2d;\n\n  constructor(props: GeometricModel2dProps, iModel: IModelConnection) {\n    super(props, iModel);\n    this.globalOrigin = Point2d.fromJSON(props.globalOrigin);\n  }\n\n  /** @internal */\n  public get is3d(): boolean { return false; }\n  /** @internal */\n  public get asGeometricModel2d(): GeometricModel2dState { return this; }\n\n  public toJSON(): GeometricModel2dProps {\n    const val = super.toJSON() as GeometricModel2dProps;\n    val.globalOrigin = this.globalOrigin;\n    return val;\n  }\n}\n\n/** Represents the front-end state of a [GeometricModel3d]($backend).\n * @public\n */\nexport class GeometricModel3dState extends GeometricModelState {\n  /** @internal */\n  public static get className() { return \"GeometricModel3d\"; }\n  /** @internal */\n  public get is3d(): boolean { return true; }\n  /** @internal */\n  public get asGeometricModel3d(): GeometricModel3dState { return this; }\n}\n\n/** Represents the front-end state of a [SheetModel]($backend).\n * @public\n */\nexport class SheetModelState extends GeometricModel2dState {\n  /** @internal */\n  public static get className() { return \"SheetModel\"; }\n}\n\n/** Represents the front-end state of a [SpatialModel]($backend).\n * @public\n */\nexport class SpatialModelState extends GeometricModel3dState {\n  /** @internal */\n  public static get className() { return \"SpatialModel\"; }\n}\n\n/** Represents the front-end state of a [PhysicalModel]($backend).\n * @public\n */\nexport class PhysicalModelState extends SpatialModelState {\n  /** @internal */\n  public static get className() { return \"PhysicalModel\"; }\n}\n\n/** Represents the front-end state of a [SpatialLocationModel]($backend).\n * @public\n */\nexport class SpatialLocationModelState extends SpatialModelState {\n  /** @internal */\n  public static get className() { return \"SpatialLocationModel\"; }\n}\n\n/** Represents the front-end state of a [DrawingModel]($backend).\n * @public\n */\nexport class DrawingModelState extends GeometricModel2dState {\n  /** @internal */\n  public static get className() { return \"DrawingModel\"; }\n}\n\n/** Represents the front-end state of a [SectionDrawingModel]($backend).\n * @public\n */\nexport class SectionDrawingModelState extends DrawingModelState {\n  /** @internal */\n  public static get className() { return \"SectionDrawingModel\"; }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nimport { RenderSystem, RenderTarget, AnimationBranchStates } from \"./rendering\";\nimport { IModelApp, IModelAppOptions } from \"./IModelApp\";\nimport { ViewRect } from \"./Viewport\";\n\n/**\n * A RenderTarget for applications that must run in environments where WebGL is not present.\n * This is typically used in tests.\n * @internal\n */\nexport class NullTarget extends RenderTarget {\n  public get animationFraction(): number { return 0; }\n  public set animationFraction(_fraction: number) { }\n  public get renderSystem() { return undefined as any; }\n  public get cameraFrustumNearScaleLimit(): number { return 0; }\n  public get viewRect(): ViewRect { return new ViewRect(); }\n  public get wantInvertBlackBackground(): boolean { return false; }\n  public get animationBranches(): AnimationBranchStates | undefined { return undefined; }\n  public set animationBranches(_branches: AnimationBranchStates | undefined) { }\n  public onDestroy(): void { }\n  public reset(): void { }\n  public changeScene(): void { }\n  public changeBackgroundMap(): void { }\n  public changeDynamics(): void { }\n  public changeDecorations(): void { }\n  public changeRenderPlan(): void { }\n  public drawFrame(_sceneMilSecElapsed?: number): void { }\n  public overrideFeatureSymbology(): void { }\n  public setHiliteSet(): void { }\n  public setFlashed(): void { }\n  public setViewRect(): void { }\n  public onResized(): void { }\n  public dispose(): void { }\n  public updateViewRect(): boolean { return false; }\n  public readPixels(): void { }\n  public readImage() { return undefined; }\n\n}\n\n/**\n * A RenderSystem for applications that must run in environments where WebGL is not present.\n * This is typically used in tests.\n * @internal\n */\nexport class NullRenderSystem extends RenderSystem {\n  public get isValid(): boolean { return false; }\n  public createTarget() { return new NullTarget(); }\n  public createOffscreenTarget() { return new NullTarget(); }\n  public createGraphicBuilder() { return undefined as any; }\n  public createGraphicList() { return undefined as any; }\n  public createGraphicBranch() { return undefined as any; }\n  public createBatch() { return undefined as any; }\n  public dispose() { }\n  public constructor() { super(); }\n}\n\n/**\n * A class for applications that must run in environments where WebGL is not present.\n * This is typically used in tests.\n * @internal\n */\nexport class NoRenderApp {\n  public static startup(opts?: IModelAppOptions) {\n    opts = opts ? opts : {};\n    opts.renderSys = new NullRenderSystem();\n    IModelApp.startup(opts);\n\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Notifications */\nimport { Point2d, XAndY } from \"@bentley/geometry-core\";\nimport { IModelApp } from \"./IModelApp\";\nimport { BeDuration } from \"@bentley/bentleyjs-core\";\n\n/** Describes the type and behavior of a [[NotifyMessageDetails]].\n * @public\n */\nexport enum OutputMessageType {\n  /** Temporary message box that displays at the bottom of the screen. */\n  Toast = 0,\n  Pointer = 1,\n  Sticky = 2,\n  InputField = 3,\n  /** Modal message box. */\n  Alert = 4,\n}\n\n/** Classifies a [[NotifyMessageDetails]] by its level of importance.\n * @public\n */\nexport enum OutputMessagePriority {\n  None = 0,\n  Error = 10,\n  Warning = 11,\n  Info = 12,\n  Debug = 13,\n  Fatal = 17,\n}\n\n/** Describes the alert behavior of a [[NotifyMessageDetails]].\n * @public\n */\nexport enum OutputMessageAlert {\n  None = 0,\n  Dialog = 1,\n  Balloon = 2,\n}\n\n/** Relative Position for setPointerTypeDetails\n * @public\n */\nexport enum RelativePosition {\n  Left = 0,\n  Top = 1,\n  Right = 2,\n  Bottom = 3,\n  TopLeft = 4,\n  TopRight = 5,\n  BottomLeft = 6,\n  BottomRight = 7,\n}\n\n/** Reason for ending the activity message via endActivityMessage\n * @public\n */\nexport enum ActivityMessageEndReason {\n  Completed = 0,\n  Cancelled = 1,\n}\n\n/** Describes the set of buttons displayed in a message box opened using [[NotificationManager.openMessageBox]].\n * @public\n */\nexport enum MessageBoxType {\n  OkCancel,\n  Ok,\n  LargeOk,\n  MediumAlert,\n  YesNoCancel,\n  YesNo,\n}\n\n/** Describes the icon displayed in a messagebox opened using [[NotificationManager.openMessageBox]].\n * @public\n */\nexport enum MessageBoxIconType {\n  NoSymbol = 0,   // Means Don't draw Symbol\n  Information = 1,   // Lower Case i\n  Question = 2,   // Question Mark\n  Warning = 3,   // Exclamation Point\n  Critical = 4,   // Stop Sign\n}\n\n/** Describes the possible return values produced when the user clicks a button in a messagebox opened using [[NotificationManager.openMessageBox]].\n * @public\n */\nexport enum MessageBoxValue {\n  Apply = 1,\n  Reset = 2,\n  Ok = 3,\n  Cancel = 4,\n  Default = 5,\n  Yes = 6,\n  No = 7,\n  Retry = 8,\n  Stop = 9,\n  Help = 10,\n  YesToAll = 11,\n  NoToAll = 12,\n}\n\n/** Describes the behavior of a tooltip created using [[NotificationManager.openToolTip]].\n * @public\n */\nexport interface ToolTipOptions {\n  duration?: BeDuration;\n  placement?: string;\n}\n\n/** Describes a message to be displayed to the user.\n * @beta\n */\nexport class NotifyMessageDetails {\n  public displayTime = BeDuration.fromSeconds(3.5);\n  public viewport?: HTMLElement;\n  public inputField?: HTMLElement;\n  public displayPoint?: Point2d;\n  public relativePosition = RelativePosition.TopRight;\n\n  /** Constructor\n   *  @param priority        The priority this message should be accorded by the NotificationManager.\n   *  @param briefMsg        A short message that conveys the simplest explanation of the issue.\n   *  @param detailedMsg     A comprehensive message that explains the issue in detail and potentially offers a solution.\n   *  @param msgType         The type of message.\n   *  @param openAlert       Whether an alert box should be displayed or not, and if so what kind.\n   */\n  public constructor(public priority: OutputMessagePriority, public briefMessage: string, public detailedMessage?: string, public msgType = OutputMessageType.Toast, public openAlert = OutputMessageAlert.None) { }\n\n  /** Set OutputMessageType.Pointer message details.\n   * @param viewport            Viewport over which to display the Pointer type message.\n   * @param displayPoint        Point at which to display the Pointer type message.\n   * @param relativePosition    Position relative to displayPoint at which to display the Pointer type message.\n   */\n  public setPointerTypeDetails(viewport: HTMLElement, displayPoint: XAndY, relativePosition = RelativePosition.TopRight) {\n    this.viewport = viewport;\n    this.displayPoint = Point2d.fromJSON(displayPoint);\n    this.relativePosition = relativePosition;\n    this.msgType = OutputMessageType.Pointer;\n  }\n\n  /** Set OutputMessageType.InputField message details.\n   * @param inputField            Input field that message pertains. The message will be shown just below this input field element.\n   */\n  public setInputFieldTypeDetails(inputField: HTMLElement) {\n    this.inputField = inputField;\n    this.msgType = OutputMessageType.InputField;\n  }\n}\n\n/** Specifies the details of an activity message to be displayed to the user.\n * @public\n */\nexport class ActivityMessageDetails {\n  public wasCancelled = false;\n\n  /**\n   * @param showProgressBar         Indicates whether to show the progress bar in the activity message dialog.\n   * @param showPercentInMessage    Indicates whether to show the percentage complete in the activity message text.\n   * @param supportsCancellation    Indicates whether to show the Cancel button, giving the user the ability to cancel the operation.\n   * @param showDialogInitially     Indicates whether to show the activity message dialog initially. User can click status bar to open it.\n   */\n  public constructor(public showProgressBar: boolean, public showPercentInMessage: boolean, public supportsCancellation: boolean, public showDialogInitially: boolean = true) { }\n\n  /** Called from NotificationAdmin when the user cancels the activity. */\n  public onActivityCancelled() { this.wasCancelled = true; }\n\n  /** Called from NotificationAdmin when the activity completes successfully. */\n  public onActivityCompleted() { this.wasCancelled = false; }\n}\n\n/** The NotificationManager controls the interaction with the user for prompts, error messages, and alert dialogs.\n * Implementations of the NotificationManager may present the information in different ways. For example, in\n * non-interactive sessions, these messages may be saved to a log file or simply discarded.\n * @public\n */\nexport class NotificationManager {\n  public readonly toolTipLocation = new Point2d();\n\n  /** Output a prompt, given an i18n key. */\n  public outputPromptByKey(key: string) { this.outputPrompt(IModelApp.i18n.translate(key)); }\n\n  /** Output a localized prompt to the user. A 'prompt' indicates an action the user should take to proceed.\n   * @param _prompt The localized string with the prompt message.\n   */\n  public outputPrompt(_prompt: string) { }\n\n  /** Output a message and/or alert to the user.\n   * @beta\n   */\n  public outputMessage(_message: NotifyMessageDetails) { }\n\n  /** Output a MessageBox and wait for response from the user.\n   * @param _mbType       The MessageBox type.\n   * @param _message      The message to display.\n   * @param _icon         The MessageBox icon type.\n   * @return the response from the user.\n   */\n  public async openMessageBox(_mbType: MessageBoxType, _message: string, _icon: MessageBoxIconType): Promise<MessageBoxValue> { return Promise.resolve(MessageBoxValue.Ok); }\n\n  /**\n   * Set up for activity messages.\n   * @param _details  The activity message details.\n   * @return true if the message was displayed, false if an invalid priority is specified.\n   */\n  public setupActivityMessage(_details: ActivityMessageDetails) { return true; }\n\n  /**\n   * Output an activity message to the user.\n   * @param _messageText The message text.\n   * @param _percentComplete The percentage of completion.\n   * @return true if the message was displayed, false if the message could not be displayed.\n   */\n  public outputActivityMessage(_messageText: string, _percentComplete: number) { return true; }\n\n  /**\n   * End an activity message.\n   * @param _reason The reason for the end of the Activity Message.\n   * @return true if the message was ended successfully, false if the activityMessage could not be ended.\n   */\n  public endActivityMessage(_reason: ActivityMessageEndReason) { return true; }\n\n  /** Return true if _showTooltip has an implementation and will display a tooltip. */\n  public get isToolTipSupported(): boolean { return false; }\n\n  /** Return true if the tooltip is currently open. */\n  public get isToolTipOpen(): boolean { return false; }\n\n  /** Implement to display a tooltip message at the specified location.\n   * @beta\n   */\n  protected _showToolTip(_htmlElement: HTMLElement, _message: HTMLElement | string, _location?: XAndY, _options?: ToolTipOptions): void { }\n\n  /** Show a tooltip window. Saves tooltip location for AccuSnap to test if cursor has moved far enough away to close tooltip.\n   * @param htmlElement The HTMLElement that that anchors the toolTip.\n   * @param message What to display inside the ToolTip. May be a string or an HTMLElement.\n   * @param location An optional location, relative to the origin of _htmlElement, for the ToolTip. If undefined, center of _htmlElement\n   * @param options Options that supply additional information about how the ToolTip should function.\n   * @note If message is an HTMLElement, the notification manager will display the HTMLElement verbatim. This can represent a security\n   * risk if any part the element is created from user input. Applications should be careful to *sanitize* any such input before\n   * creating an HTMLElement to pass to this method.\n   * @beta\n   */\n  public openToolTip(_htmlElement: HTMLElement, message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions): void {\n    this.toolTipLocation.setFrom(location);\n    this._showToolTip(_htmlElement, message, location, options);\n  }\n\n  /** Clear the tooltip if it is currently open. */\n  public clearToolTip(): void { }\n\n  /** Close message created with [[OutputMessageType.Pointer]]. */\n  public closePointerMessage(): void { }\n\n  /** Close message created with [[OutputMessageType.InputField]]. */\n  public closeInputFieldMessage(): void { }\n\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Plugins */\r\nimport * as semver from \"semver\";\r\nimport { IModelApp } from \"./IModelApp\";\r\nimport { NotifyMessageDetails, OutputMessageAlert, OutputMessagePriority, OutputMessageType } from \"./NotificationManager\";\r\nimport { Logger } from \"@bentley/bentleyjs-core\";\r\n\r\nconst loggerCategory = \"imodeljs-frontend.Plugin\";\r\n\r\ntype resolveFunc = ((arg: any) => void);\r\ntype rejectFunc = ((arg: Error) => void);\r\n\r\n/**\r\n * Base Plugin class for writing a demand-loaded module.\r\n * @see [[PluginAdmin]] for a description of how Plugins are loaded.\r\n * @see [Plugins]($docs/learning/frontend/plugins.md)\r\n * @public\r\n */\r\nexport abstract class Plugin {\r\n  /**\r\n   * Constructor for base Plugin class\r\n   * @param name - the name of the plugin. When you use the buildIModelJsModule build script, this argument is filled in as the PLUGIN_NAME constant by webpack\r\n   * @param versionsRequired - the versions of iModel.js system modules that this Plugin requires. When you use the buildIModelJsModule build script, this argument\r\n   * is filled in as the IMODELJS_VERSIONS_REQUIRED constant by webpack.\r\n   * @note Typically, a Plugin subclass is instantiated and registered with top-level JavaScript statements like these:\r\n   * ```ts\r\n   *  const myPlugin = new MyPlugin(PLUGIN_NAME, IMODELJS_VERSIONS_REQUIRED);\r\n   *  PluginAdmin.register(myPlugin);\r\n   * ```\r\n   */\r\n  public constructor(public name: string, public versionsRequired: string) {\r\n  }\r\n\r\n  /**\r\n   * Method called when the Plugin is first loaded.\r\n   * @param _args arguments that were passed to PluginAdmin.loadPlugin. The first argument is the plugin name.\r\n   */\r\n  public onLoad(_args: string[]): void {\r\n  }\r\n\r\n  /**\r\n   * Method called immediately following the call to onLoad when the Plugin is first loaded, and also once for\r\n   * each additional call to PluginAdmin.loadPlugin for the same Plugin.\r\n   * @param _args arguments that were passed to PluginAdmin.loadPlugin. The first argument is the plugin name.\r\n   */\r\n  public abstract onExecute(_args: string[]): void;\r\n}\r\n\r\n// this private class represents a Plugin that we are attempting to load.\r\nclass PendingPlugin {\r\n  public resolve: resolveFunc | undefined = undefined;\r\n  public reject: rejectFunc | undefined = undefined;\r\n  public promise: Promise<Plugin>;\r\n\r\n  public constructor(private _packageName: string, public args?: string[]) {\r\n    this.promise = new Promise(this.executor.bind(this));\r\n  }\r\n\r\n  public executor(resolve: resolveFunc, reject: rejectFunc) {\r\n    this.resolve = resolve;\r\n    this.reject = reject;\r\n\r\n    const head = document.getElementsByTagName(\"head\")[0];\r\n    if (!head)\r\n      reject(new Error(\"no head element found\"));\r\n\r\n    // create the script element. handle onload and onerror.\r\n    const scriptElement = document.createElement(\"script\");\r\n\r\n    scriptElement.onerror = (ev) => {\r\n      scriptElement.onload = null;\r\n      reject(new Error(\"can't load \" + this._packageName + \" : \" + ev));\r\n    };\r\n\r\n    scriptElement.async = true;\r\n    scriptElement.src = this._packageName;\r\n    head.insertBefore(scriptElement, head.lastChild);\r\n  }\r\n}\r\n\r\n/**\r\n * Controls loading of Plugins and calls methods on newly loaded or reloaded Plugins\r\n * @public\r\n */\r\nexport class PluginAdmin {\r\n  private static _pendingPlugins: Map<string, PendingPlugin> = new Map<string, PendingPlugin>();\r\n  private static _registeredPlugins: Map<string, Plugin> = new Map<string, Plugin>();\r\n\r\n  /**\r\n   * Retrieves a previously loaded Plugin.\r\n   * @param pluginName\r\n   */\r\n  public static getPlugin(pluginName: string): Promise<Plugin> | undefined {\r\n    // strip off .js if necessary\r\n    pluginName = PluginAdmin.getPluginName(pluginName);\r\n    const plugin = PluginAdmin._registeredPlugins.get(pluginName);\r\n    if (plugin)\r\n      return Promise.resolve(plugin);\r\n    const pluginPromise = PluginAdmin._pendingPlugins.get(pluginName);\r\n    if (pluginPromise) {\r\n      return pluginPromise.promise;\r\n    }\r\n    return undefined;\r\n  }\r\n\r\n  // returns an array of strings with version mismatch errors, or undefined if the versions of all modules are usable.\r\n  private static checkIModelJsVersions(versionsRequired: string): string[] | undefined {\r\n    // make sure we're in a browser-like environment\r\n    if ((typeof window === \"undefined\") || !window) {\r\n      return [IModelApp.i18n.translate(\"iModelJs:PluginErrors.FrontEndOnly\")];\r\n    }\r\n    const versionsLoaded: Map<string, string> = (window as any).iModelJsVersions;\r\n    if (!versionsLoaded) {\r\n      return [IModelApp.i18n.translate(\"iModelJs:PluginErrors.NoVersionsLoaded\")];\r\n    }\r\n\r\n    // make sure the versionsRequired string isn't empty.\r\n    if (!versionsRequired || (0 === versionsRequired.length)) {\r\n      return [IModelApp.i18n.translate(\"iModelJs:PluginErrors.WebpackedIncorrectly\")];\r\n    }\r\n\r\n    // make sure versionsRequired is a JSON string.\r\n    const errorMessages: string[] = [];\r\n    try {\r\n      const versionsRequiredObject: any = JSON.parse(versionsRequired);\r\n      for (const moduleName of Object.getOwnPropertyNames(versionsRequiredObject)) {\r\n        // bwc doesn't set its version, so we have to ignore it for now.\r\n        if (moduleName === \"bwc\") {\r\n          continue;\r\n        }\r\n        const versionRequired: string = versionsRequiredObject[moduleName];\r\n        if (!versionRequired || \"string\" !== typeof (versionRequired)) {\r\n          errorMessages.push(IModelApp.i18n.translate(\"iModelJs:PluginErrors.NoVersionSpecified\", { moduleName }));\r\n        } else {\r\n          const versionLoaded = versionsLoaded.get(moduleName);\r\n          if (!versionLoaded) {\r\n            errorMessages.push(IModelApp.i18n.translate(\"iModelJs:PluginErrors.ModuleNotLoaded\", { moduleName }));\r\n          } else {\r\n            // check version required vs. version loaded.\r\n            if (!semver.satisfies(versionLoaded, versionRequired)) {\r\n              errorMessages.push(IModelApp.i18n.translate(\"iModelJs:PluginErrors.VersionMismatch\", { versionLoaded, moduleName, versionRequired }));\r\n            }\r\n          }\r\n        }\r\n      }\r\n    } catch (err) {\r\n      return [IModelApp.i18n.translate(\"iModelJs:PluginErrors.WebpackedIncorrectly\")];\r\n    }\r\n    return (errorMessages.length > 0) ? errorMessages : undefined;\r\n  }\r\n\r\n  private static getPluginName(packageName: string) {\r\n    if (packageName.endsWith(\".js\"))\r\n      return packageName.substr(0, packageName.length - 3);\r\n    return packageName;\r\n  }\r\n\r\n  /**\r\n   * Loads a Plugin\r\n   * @param packageName the name of the JavaScript file to be loaded from the web server.\r\n   * @param args arguments that will be passed to the Plugin.onLoaded and Plugin.onExecute methods. If the first argument is not the plugin name, the plugin name will be prepended to the args array.\r\n   */\r\n  public static async loadPlugin(packageName: string, args?: string[]): Promise<Plugin> {\r\n    // see if it is already loaded.\r\n    const pluginName: string = PluginAdmin.getPluginName(packageName);\r\n\r\n    // make sure there's an args and make sure the first element is the plugin name.\r\n    if (!args) {\r\n      args = [pluginName];\r\n    } else {\r\n      if ((args.length < 1) || (args[0] !== pluginName)) {\r\n        const newArray: string[] = [pluginName];\r\n        args = newArray.concat(args);\r\n      }\r\n    }\r\n\r\n    const pendingPlugin = PluginAdmin._pendingPlugins.get(pluginName);\r\n    if (undefined !== pendingPlugin) {\r\n      // it has been loaded (or at least we have started to load it) already. If it is registered, call its reload method. (Otherwise reload called when we're done the initial load)\r\n      const registeredPlugin = PluginAdmin._registeredPlugins.get(pluginName);\r\n      if (registeredPlugin) {\r\n        registeredPlugin.onExecute(args);\r\n      }\r\n      return pendingPlugin.promise;\r\n    }\r\n\r\n    // set it up to load.\r\n    const newPendingPlugin: PendingPlugin = new PendingPlugin(packageName, args);\r\n\r\n    // Javascript-ish saving of the arguments in the promise, so we can call reload with them.\r\n    PluginAdmin._pendingPlugins.set(pluginName, newPendingPlugin);\r\n    return newPendingPlugin.promise;\r\n  }\r\n\r\n  /**\r\n   * Registers a Plugin with the PluginAdmin. This method is called by the Plugin when it is first loaded.\r\n   * This method verifies that the required versions of the iModel.js system modules are loaded. If those\r\n   * requirements are met, then the onLoad and onExecute methods of the Plugin will be called (@see [[Plugin]]).\r\n   * If not, no further action is taken and the Plugin is not active.\r\n   * @param plugin a newly instantiated subclass of Plugin.\r\n   * @returns an array of error messages. The array will be empty if the load is successful, otherwise it is a list of one or more problems.\r\n   */\r\n  public static register(plugin: Plugin): string[] | undefined {\r\n    const errorMessages = PluginAdmin.checkIModelJsVersions(plugin.versionsRequired);\r\n    if (errorMessages) {\r\n      // report load errors to the user.\r\n      let allDetails: string = \"\";\r\n      for (const thisMessage of errorMessages) {\r\n        allDetails = allDetails.concat(thisMessage, \"\\n\");\r\n      }\r\n      const briefMessage = IModelApp.i18n.translate(\"iModelJs:PluginErrors.VersionErrors\", { pluginName: plugin.name });\r\n      const errorDetails = new NotifyMessageDetails(OutputMessagePriority.Info, briefMessage, allDetails, OutputMessageType.Alert, OutputMessageAlert.Balloon);\r\n      IModelApp.notifications.outputMessage(errorDetails);\r\n\r\n      Logger.logError(loggerCategory, plugin.name + \" failed to load. Error=\" + allDetails);\r\n      return errorMessages;\r\n    }\r\n    PluginAdmin._registeredPlugins.set(plugin.name, plugin);\r\n\r\n    // log successful load after plugin is registered.\r\n    Logger.logInfo(loggerCategory, plugin.name + \" loaded\");\r\n\r\n    // retrieve the args we saved in the pendingPlugin.\r\n    let args: string[] | undefined;\r\n    const pendingPlugin = PluginAdmin._pendingPlugins.get(plugin.name);\r\n    if (pendingPlugin) {\r\n      pendingPlugin.resolve!(plugin);\r\n      args = pendingPlugin.args;\r\n    }\r\n\r\n    if (!args)\r\n      args = [plugin.name];\r\n\r\n    plugin.onLoad(args);\r\n    plugin.onExecute(args);\r\n    return undefined;\r\n  }\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nimport { BentleyError, BentleyStatus } from \"@bentley/bentleyjs-core\";\nimport { BadUnit, Parser, ParserSpec, ParseResult, Format, Formatter, FormatterSpec, UnitConversion, UnitProps, UnitsProvider, BasicUnit } from \"@bentley/imodeljs-quantity\";\nimport { IModelApp } from \"./IModelApp\";\n\n/** Class that implements the minimum UnitConversion interface to provide information needed to convert unit values.\n * @alpha\n */\nexport class ConversionData implements UnitConversion {\n  public factor: number = 1.0;\n  public offset: number = 0.0;\n}\n\n// interface use to define unit conversions to a base used for a unitFamily\ninterface ConversionDef {\n  numerator: number;\n  denominator: number;\n  offset: number;\n}\n\n// Temporary interface use to define structure of the unit definitions in this example.\ninterface UnitDefinition {\n  readonly name: string;\n  readonly unitFamily: string;\n  readonly displayLabel: string;\n  readonly altDisplayLabels: string[];\n  readonly conversion: ConversionDef;\n}\n\n// cSpell:ignore MILLIINCH, MICROINCH, MILLIFOOT\n// Set of supported units - this information will come from Schema-based units once the EC package is ready to provide this information.\nconst unitData: UnitDefinition[] = [\n  // Angles ( base unit radian )\n  { name: \"Units.RAD\", unitFamily: \"Units.ANGLE\", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"rad\", altDisplayLabels: [\"radian\"] },\n  // 1 rad = 180.0/PI \n  { name: \"Units.ARC_DEG\", unitFamily: \"Units.ANGLE\", conversion: { numerator: 180.0, denominator: 3.1415926535897932384626433832795, offset: 0.0 }, displayLabel: \"\", altDisplayLabels: [\"deg\", \"^\"] },\n  { name: \"Units.ARC_MINUTE\", unitFamily: \"Units.ANGLE\", conversion: { numerator: 10800.0, denominator: 3.14159265358979323846264338327950, offset: 0.0 }, displayLabel: \"'\", altDisplayLabels: [\"min\"] },\n  { name: \"Units.ARC_SECOND\", unitFamily: \"Units.ANGLE\", conversion: { numerator: 648000.0, denominator: 3.1415926535897932384626433832795, offset: 0.0 }, displayLabel: '\"', altDisplayLabels: [\"sec\"] },\n  { name: \"Units.GRAD\", unitFamily: \"Units.ANGLE\", conversion: { numerator: 200, denominator: 3.1415926535897932384626433832795, offset: 0.0 }, displayLabel: \"grad\", altDisplayLabels: [\"gd\"] },\n  // Time ( base unit second )\n  { name: \"Units.S\", unitFamily: \"Units.TIME\", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"s\", altDisplayLabels: [\"sec\"] },\n  { name: \"Units.MIN\", unitFamily: \"Units.TIME\", conversion: { numerator: 1.0, denominator: 60.0, offset: 0.0 }, displayLabel: \"min\", altDisplayLabels: [] },\n  { name: \"Units.HR\", unitFamily: \"Units.TIME\", conversion: { numerator: 1.0, denominator: 3600.0, offset: 0.0 }, displayLabel: \"h\", altDisplayLabels: [\"hr\"] },\n  { name: \"Units.DAY\", unitFamily: \"Units.TIME\", conversion: { numerator: 1.0, denominator: 86400.0, offset: 0.0 }, displayLabel: \"days\", altDisplayLabels: [\"day\"] },\n  { name: \"Units.WEEK\", unitFamily: \"Units.TIME\", conversion: { numerator: 1.0, denominator: 604800.0, offset: 0.0 }, displayLabel: \"weeks\", altDisplayLabels: [\"week\"] },\n  // 1 sec = 1/31536000.0 yr\n  { name: \"Units.YR\", unitFamily: \"Units.TIME\", conversion: { numerator: 1.0, denominator: 31536000.0, offset: 0.0 }, displayLabel: \"years\", altDisplayLabels: [\"year\"] },\n  // Length( base unit length )\n  { name: \"Units.M\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"m\", altDisplayLabels: [\"meter\"] },\n  { name: \"Units.MM\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1000.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"mm\", altDisplayLabels: [\"MM\"] },\n  { name: \"Units.CM\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 100.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"cm\", altDisplayLabels: [\"CM\"] },\n  { name: \"Units.DM\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 10.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"dm\", altDisplayLabels: [\"DM\"] },\n  { name: \"Units.KM\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1.0, denominator: 1000.0, offset: 0.0 }, displayLabel: \"km\", altDisplayLabels: [\"KM\"] },\n  { name: \"Units.UM\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1000000.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"m\", altDisplayLabels: [] },\n  { name: \"Units.MILLIINCH\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1000.0, denominator: 0.0254, offset: 0.0 }, displayLabel: \"mil\", altDisplayLabels: [] },\n  { name: \"Units.MICROINCH\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1000000.0, denominator: 0.0254, offset: 0.0 }, displayLabel: \"in\", altDisplayLabels: [] },\n  { name: \"Units.MILLIFOOT\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1000.0, denominator: 0.3048, offset: 0.0 }, displayLabel: \"mft\", altDisplayLabels: [] },\n  // 1 m = 1/0.0254 \"\n  { name: \"Units.IN\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1.0, denominator: 0.0254, offset: 0.0 }, displayLabel: \"in\", altDisplayLabels: [\"IN\", \"\\\"\"] },\n  { name: \"Units.FT\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1.0, denominator: 0.3048, offset: 0.0 }, displayLabel: \"ft\", altDisplayLabels: [\"F\", \"FT\", \"'\"] },\n  { name: \"Units.YRD\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1.0, denominator: 0.9144, offset: 0.0 }, displayLabel: \"yd\", altDisplayLabels: [\"YRD\", \"yrd\"] },\n  { name: \"Units.MILE\", unitFamily: \"Units.LENGTH\", conversion: { numerator: 1.0, denominator: 1609.344, offset: 0.0 }, displayLabel: \"mi\", altDisplayLabels: [\"mile\", \"Miles\", \"Mile\"] },\n\n  { name: \"Units.SQ_FT\", unitFamily: \"Units.AREA\", conversion: { numerator: 1.0, denominator: .09290304, offset: 0.0 }, displayLabel: \"ft\", altDisplayLabels: [\"sf\"] },\n  { name: \"Units.SQ_M\", unitFamily: \"Units.AREA\", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"m\", altDisplayLabels: [] },\n\n  { name: \"Units.CUB_FT\", unitFamily: \"Units.AREA\", conversion: { numerator: 1.0, denominator: 0.028316847, offset: 0.0 }, displayLabel: \"ft\", altDisplayLabels: [\"cf\"] },\n  { name: \"Units.CUB_M\", unitFamily: \"Units.AREA\", conversion: { numerator: 1.0, denominator: 1.0, offset: 0.0 }, displayLabel: \"m\", altDisplayLabels: [] },\n];\n\n/** Defines standard format types for tools that need to display measurements to user.\n * @alpha\n */\nexport enum QuantityType { Length = 1, Angle = 2, Area = 3, Volume = 4, LatLong = 5, Coordinate = 6 }\n\n// The following provide default formats for different the QuantityTypes. It is important to note that these default should reference\n// units that are available from the registered units provider.\nconst defaultsFormats = {\n  metric: [{\n    type: 1/*Length*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \" \",\n        units: [\n          {\n            label: \"m\",\n            name: \"Units.M\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 4,\n      type: \"Decimal\",\n    },\n  }, {\n    type: 2/*Angle*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \"\",\n        units: [\n          {\n            label: \"\",\n            name: \"Units.ARC_DEG\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 2,\n      type: \"Decimal\",\n      uomSeparator: \"\",\n    },\n  }, {\n    type: 3/*Area*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \" \",\n        units: [\n          {\n            label: \"m\",\n            name: \"Units.SQ_M\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 4,\n      type: \"Decimal\",\n    },\n  }, {\n    type: 4/*Volume*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \" \",\n        units: [\n          {\n            label: \"m\",\n            name: \"Units.CUB_M\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 4,\n      type: \"Decimal\",\n    },\n  }, {\n    type: 5/*LatLong*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \"\",\n        units: [\n          {\n            label: \"\",\n            name: \"Units.ARC_DEG\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 6,\n      type: \"Decimal\",\n      uomSeparator: \"\",\n    },\n  }, {\n    type: 6/*Coordinate*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \" \",\n        units: [\n          {\n            label: \"m\",\n            name: \"Units.M\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 2,\n      type: \"Decimal\",\n    },\n  },\n  ],\n  imperial: [{\n    type: 1/*Length*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \"-\",\n        units: [{ label: \"'\", name: \"Units.FT\" }, { label: \"\\\"\", name: \"Units.IN\" }],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 8,\n      type: \"Fractional\",\n      uomSeparator: \"\",\n    },\n  }, {\n    type: 2/*Angle*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \"\",\n        units: [\n          {\n            label: \"\",\n            name: \"Units.ARC_DEG\",\n          },\n          {\n            label: \"'\",\n            name: \"Units.ARC_MINUTE\",\n          },\n          {\n            label: \"\\\"\",\n            name: \"Units.ARC_SECOND\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 2,\n      type: \"Decimal\",\n      uomSeparator: \"\",\n    },\n  }, {\n    type: 3/*Area*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \" \",\n        units: [\n          {\n            label: \"ft\",\n            name: \"Units.SQ_FT\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 4,\n      type: \"Decimal\",\n    },\n  }, {\n    type: 4/*Volume*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \" \",\n        units: [\n          {\n            label: \"ft\",\n            name: \"Units.CUB_FT\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 4,\n      type: \"Decimal\",\n    },\n  }, {\n    type: 5/*LatLong*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \"\",\n        units: [\n          {\n            label: \"\",\n            name: \"Units.ARC_DEG\",\n          },\n          {\n            label: \"'\",\n            name: \"Units.ARC_MINUTE\",\n          },\n          {\n            label: \"\\\"\",\n            name: \"Units.ARC_SECOND\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 0,\n      type: \"Decimal\",\n      uomSeparator: \"\",\n    },\n  }, {\n    type: 6/*Coordinate*/, format: {\n      composite: {\n        includeZero: true,\n        spacer: \" \",\n        units: [\n          {\n            label: \"ft\",\n            name: \"Units.FT\",\n          },\n        ],\n      },\n      formatTraits: [\"keepSingleZero\", \"showUnitLabel\"],\n      precision: 2,\n      type: \"Decimal\",\n    },\n  },\n  ],\n};\n\n/** Formats quantity values into strings.\n * @alpha\n */\nexport class QuantityFormatter implements UnitsProvider {\n  protected _activeSystemIsImperial = true;\n  protected _formatSpecsByKoq = new Map<string, FormatterSpec[]>();\n  protected _imperialFormatsByType = new Map<QuantityType, Format>();\n  protected _metricFormatsByType = new Map<QuantityType, Format>();\n  protected _imperialFormatSpecsByType = new Map<QuantityType, FormatterSpec>();\n  protected _metricFormatSpecsByType = new Map<QuantityType, FormatterSpec>();\n  protected _imperialParserSpecsByType = new Map<QuantityType, ParserSpec>();\n  protected _metricUnitParserSpecsByType = new Map<QuantityType, ParserSpec>();\n\n  /** Find a unit given the unitLabel. */\n  public async findUnit(unitLabel: string, unitFamily?: string): Promise<UnitProps> {\n    for (const entry of unitData) {\n      if (unitFamily) {\n        if (entry.unitFamily !== unitFamily)\n          continue;\n      }\n      if (entry.displayLabel === unitLabel || entry.name === unitLabel) {\n        const unitProps = new BasicUnit(entry.name, entry.displayLabel, entry.unitFamily, entry.altDisplayLabels);\n        return Promise.resolve(unitProps);\n      }\n\n      if (entry.altDisplayLabels && entry.altDisplayLabels.length > 0) {\n        if (entry.altDisplayLabels.findIndex((ref) => ref === unitLabel) !== -1) {\n          const unitProps = new BasicUnit(entry.name, entry.displayLabel, entry.unitFamily, entry.altDisplayLabels);\n          return Promise.resolve(unitProps);\n        }\n      }\n    }\n\n    return Promise.resolve(new BadUnit());\n  }\n\n  /** find all units given unitFamily */\n  public async getUnitsByFamily(unitFamily: string): Promise<UnitProps[]> {\n    const units: UnitProps[] = [];\n    for (const entry of unitData) {\n      if (entry.unitFamily !== unitFamily)\n        continue;\n      units.push(new BasicUnit(entry.name, entry.displayLabel, entry.unitFamily, entry.altDisplayLabels));\n    }\n    return Promise.resolve(units);\n  }\n\n  protected findUnitDefinition(name: string): UnitDefinition | undefined {\n    for (const entry of unitData) {\n      if (entry.name === name)\n        return entry;\n    }\n\n    return undefined;\n  }\n\n  /** Find a unit given the unit's unique name. */\n  public async findUnitByName(unitName: string): Promise<UnitProps> {\n    const unitDataEntry = this.findUnitDefinition(unitName);\n    if (unitDataEntry) {\n      return Promise.resolve(new BasicUnit(unitDataEntry.name, unitDataEntry.displayLabel, unitDataEntry.unitFamily, unitDataEntry.altDisplayLabels));\n    }\n    return Promise.resolve(new BadUnit());\n  }\n\n  /** Return the information needed to convert a value between two different units.  The units should be from the same unitFamily. */\n  public async getConversion(fromUnit: UnitProps, toUnit: UnitProps): Promise<UnitConversion> {\n    const fromUnitData = this.findUnitDefinition(fromUnit.name);\n    const toUnitData = this.findUnitDefinition(toUnit.name);\n\n    if (fromUnitData && toUnitData) {\n      const deltaOffset = toUnitData.conversion.offset - fromUnitData.conversion.offset;\n      const deltaNumerator = toUnitData.conversion.numerator * fromUnitData.conversion.denominator;\n      const deltaDenominator = toUnitData.conversion.denominator * fromUnitData.conversion.numerator;\n\n      const conversion = new ConversionData();\n      conversion.factor = deltaNumerator / deltaDenominator;\n      conversion.offset = deltaOffset;\n      return Promise.resolve(conversion);\n    }\n\n    return Promise.resolve(new ConversionData());\n  }\n\n  /** method used to load format for KOQ into cache */\n  protected async loadKoqFormatSpecs(koq: string): Promise<void> {\n    if (koq.length === 0)\n      return Promise.reject(new Error(\"bad koq specification\"));\n\n    if (!this._formatSpecsByKoq.has(koq)) {\n      // get koq and get formats from it\n    }\n\n    return Promise.reject(new Error(\"not yet implemented\"));\n  }\n\n  /** Async method to return the array of presentation formats for the specified KOQ */\n  protected async getKoqFormatterSpecsAsync(koq: string, useImperial: boolean): Promise<FormatterSpec[] | undefined> {\n    if (koq.length === 0 && useImperial)\n      return Promise.reject(new Error(\"bad koq specification\"));\n\n    return Promise.resolve(this._formatSpecsByKoq.get(koq));\n  }\n\n  /** Async method to return the 'active' FormatSpec for the specified KOQ */\n  protected async getKoqFormatterSpec(koq: string, useImperial: boolean): Promise<FormatterSpec | undefined> {\n    if (koq.length === 0 && useImperial)\n      return Promise.reject(new Error(\"bad koq specification\"));\n\n    const formatterSpecArray = await Promise.resolve(this._formatSpecsByKoq.get(koq));\n    if (formatterSpecArray && formatterSpecArray.length > 0) {\n      const activeFormatIndex = 0; // TODO - get active format based on user selected format or default format\n      return Promise.resolve(formatterSpecArray[activeFormatIndex]);\n    }\n\n    return Promise.reject(new Error(\"not yet implemented\"));\n  }\n\n  /** Method used to get cached FormatterSpec or undefined if FormatterSpec is unavailable */\n  protected findKoqFormatterSpec(koq: string, useImperial: boolean): FormatterSpec | undefined {\n    if (koq.length === 0 && useImperial)\n      return undefined;\n\n    throw new Error(\"not yet implemented\");\n  }\n\n  protected async loadStdFormat(type: QuantityType, imperial: boolean): Promise<Format> {\n    let formatData: any;\n\n    const formatArray = imperial ? defaultsFormats.imperial : defaultsFormats.metric;\n    for (const entry of formatArray) {\n      if (entry.type === type as number) {\n        formatData = entry.format;\n        const format = new Format(\"stdFormat\");\n        await format.fromJson(this, formatData);\n        return Promise.resolve(format);\n      }\n    }\n    throw new BentleyError(BentleyStatus.ERROR, \"IModelApp must define a formatsProvider class to provide formats for tools\");\n  }\n\n  protected async getFormatByQuantityType(type: QuantityType, imperial: boolean): Promise<Format> {\n    const activeMap = imperial ? this._imperialFormatsByType : this._metricFormatsByType;\n\n    let format = activeMap.get(type);\n    if (format)\n      return Promise.resolve(format);\n\n    format = await this.loadStdFormat(type, imperial);\n    if (format) {\n      activeMap.set(type, format);\n      return Promise.resolve(format);\n    }\n\n    throw new BentleyError(BentleyStatus.ERROR, \"IModelApp must define a formatsProvider class to provide formats for tools\");\n  }\n\n  /** Async request to get the 'persistence' unit from the UnitsProvider. For a tool this 'persistence' unit is the unit being used by the tool internally. */\n  protected async getUnitByQuantityType(type: QuantityType): Promise<UnitProps> {\n    switch (type) {\n      case QuantityType.Angle:\n      case QuantityType.LatLong:\n        return this.findUnitByName(\"Units.RAD\");\n      case QuantityType.Area:\n        return this.findUnitByName(\"Units.SQ_M\");\n      case QuantityType.Volume:\n        return this.findUnitByName(\"Units.M\");\n      case QuantityType.Coordinate:\n      case QuantityType.Length:\n      default:\n        return this.findUnitByName(\"Units.M\");\n    }\n  }\n\n  /** Asynchronous call to loadParsingSpecsForQuantityTypes. This method caches all the ParserSpecs so they can be quickly accessed. */\n  protected async loadParsingSpecsForQuantityTypes(useImperial: boolean): Promise<void> {\n    const typeArray: QuantityType[] = [QuantityType.Length, QuantityType.Angle, QuantityType.Area, QuantityType.Volume, QuantityType.LatLong, QuantityType.Coordinate];\n    const activeMap = useImperial ? this._imperialParserSpecsByType : this._metricUnitParserSpecsByType;\n    activeMap.clear();\n\n    for (const quantityType of typeArray) {\n      const formatPromise = this.getFormatByQuantityType(quantityType, useImperial);\n      const unitPromise = this.getUnitByQuantityType(quantityType);\n      const [format, outUnit] = await Promise.all([formatPromise, unitPromise]);\n      const parserSpec = await ParserSpec.create(format, this, outUnit);\n      activeMap.set(quantityType, parserSpec);\n    }\n    return Promise.resolve();\n  }\n\n  /** Asynchronous call to loadFormatSpecsForQuantityTypes. This method caches all the FormatSpec so they can be quickly accessed. */\n  protected async loadFormatSpecsForQuantityTypes(useImperial: boolean): Promise<void> {\n    const typeArray: QuantityType[] = [QuantityType.Length, QuantityType.Angle, QuantityType.Area, QuantityType.Volume, QuantityType.LatLong, QuantityType.Coordinate];\n    const activeMap = useImperial ? this._imperialFormatSpecsByType : this._metricFormatSpecsByType;\n    activeMap.clear();\n\n    for (const quantityType of typeArray) {\n      const formatPromise = this.getFormatByQuantityType(quantityType, useImperial);\n      const unitPromise = this.getUnitByQuantityType(quantityType);\n      const [format, unit] = await Promise.all([formatPromise, unitPromise]);\n      const spec = await FormatterSpec.create(format.name, format, this, unit);\n      activeMap.set(quantityType, spec);\n    }\n    return Promise.resolve();\n  }\n\n  /** Synchronous call to get a FormatterSpec of a QuantityType. If the FormatterSpec is not yet cached an undefined object is returned. The\n   * cache is populated by the async call loadFormatSpecsForQuantityTypes.\n   */\n  public findFormatterSpecByQuantityType(type: QuantityType, imperial?: boolean): FormatterSpec | undefined {\n    const useImperial = undefined !== imperial ? imperial : this._activeSystemIsImperial;\n    const activeMap = useImperial ? this._imperialFormatSpecsByType : this._metricFormatSpecsByType;\n    if (activeMap.size === 0) {\n      // trigger a load so it will become available\n      this.loadFormatSpecsForQuantityTypes(useImperial); // tslint:disable-line:no-floating-promises\n      return undefined;\n    }\n\n    return activeMap.get(type);\n  }\n\n  /** Asynchronous Call to get a FormatterSpec of a QuantityType.\n   * @param type        One of the built-in quantity types supported.\n   * @param imperial    Optional parameter to determine if the imperial or metric format should be returned. If undefined then the setting is taken from the formatter.\n   * @return A promise to return a FormatterSpec.\n   */\n  public async getFormatterSpecByQuantityType(type: QuantityType, imperial?: boolean): Promise<FormatterSpec> {\n    const useImperial = undefined !== imperial ? imperial : this._activeSystemIsImperial;\n    const activeMap = useImperial ? this._imperialFormatSpecsByType : this._metricFormatSpecsByType;\n    if (activeMap.size > 0)\n      return Promise.resolve(activeMap.get(type) as FormatterSpec);\n\n    return this.loadFormatSpecsForQuantityTypes(useImperial)\n      .then(async () => {\n        if (activeMap.size > 0) {\n          const spec = activeMap.get(type);\n          if (spec)\n            return Promise.resolve(spec as FormatterSpec);\n        }\n        return Promise.reject(new BentleyError(BentleyStatus.ERROR, \"Unable to load FormatSpecs\"));\n      });\n  }\n\n  /** Synchronous call to get a ParserSpec for a QuantityType. If the ParserSpec is not yet cached an undefined object is returned. The\n   * cache is populated by the async call loadFormatSpecsForQuantityTypes.\n   */\n  public findParserSpecByQuantityType(type: QuantityType, imperial?: boolean): ParserSpec | undefined {\n    const useImperial = undefined !== imperial ? imperial : this._activeSystemIsImperial;\n    const activeMap = useImperial ? this._imperialParserSpecsByType : this._metricUnitParserSpecsByType;\n    if (activeMap.size === 0) {\n      // trigger a load so it will become available\n      this.loadParsingSpecsForQuantityTypes(useImperial); // tslint:disable-line:no-floating-promises\n      return undefined;\n    }\n    return activeMap.get(type);\n  }\n\n  /** Asynchronous Call to get a ParserSpec for a QuantityType.\n   * @param type        One of the built-in quantity types supported.\n   * @param imperial    Optional parameter to determine if the imperial or metric format should be returned. If undefined then the setting is taken from the formatter.\n   * @return A promise to return a ParserSpec.\n   */\n  public async getParserSpecByQuantityType(type: QuantityType, imperial?: boolean): Promise<ParserSpec> {\n    const useImperial = undefined !== imperial ? imperial : this._activeSystemIsImperial;\n    const activeMap = useImperial ? this._imperialParserSpecsByType : this._metricUnitParserSpecsByType;\n    if (activeMap.size > 0)\n      return Promise.resolve(activeMap.get(type) as ParserSpec);\n\n    return this.loadParsingSpecsForQuantityTypes(useImperial)\n      .then(async () => {\n        if (activeMap.size > 0) {\n          const spec = activeMap.get(type);\n          if (spec)\n            return Promise.resolve(spec as ParserSpec);\n        }\n        return Promise.reject(new BentleyError(BentleyStatus.ERROR, \"Unable to load ParserSpec\"));\n      });\n  }\n\n  /** Generates a formatted string for a quantity given its format spec.\n   * @param magnitude       The magnitude of the quantity.\n   * @param formatSpec      The format specification. See methods getFormatterSpecByQuantityType and findFormatterSpecByQuantityType.\n   * @return the formatted string.\n   */\n  public formatQuantity(magnitude: number, formatSpec: FormatterSpec): string {\n    return Formatter.formatQuantity(magnitude, formatSpec);\n  }\n\n  /** Parse input string into quantity given the ParserSpec\n   * @param inString       The magnitude of the quantity.\n   * @param parserSpec     The parse specification the defines the expected format of the string and the conversion to the output unit.\n   * @return ParseResult object containing either the parsed value or an error value if unsuccessful.\n   */\n  public parseIntoQuantityValue(inString: string, parserSpec: ParserSpec): ParseResult {\n    return Parser.parseQuantityString(inString, parserSpec);\n  }\n\n  /** Set the flag to return either metric or imperial formats. This call also makes an async request to refresh the cached formats. */\n  public async loadFormatAndParsingMaps(useImperial: boolean): Promise<void> {\n    const formatPromise = this.loadFormatSpecsForQuantityTypes(useImperial);\n    const parsePromise = this.loadParsingSpecsForQuantityTypes(useImperial);\n    await Promise.all([formatPromise, parsePromise]); // tslint:disable-line:no-floating-promises\n  }\n\n  /** Set the flag to return either metric or imperial formats. This call also makes an async request to refresh the cached formats. */\n  public set useImperialFormats(useImperial: boolean) {\n    IModelApp.toolAdmin.startDefaultTool();\n    this._activeSystemIsImperial = useImperial;\n    this.loadFormatAndParsingMaps(useImperial); // tslint:disable-line:no-floating-promises\n  }\n\n  /** Return true if Tool Quantities are to be displayed in Imperial units. If false Metric units are to used. */\n  public get useImperialFormats(): boolean { return this._activeSystemIsImperial; }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module IModelApp */\r\n\r\n/** A specific WebGL rendering feature.\r\n * @beta\r\n */\r\nexport enum WebGLFeature {\r\n  /**\r\n   * This feature allows transparency to occur more efficiently.  The renderer will require less passes to achieve\r\n   * transparency due to the presence of enough renderable attachments.\r\n   */\r\n  MrtTransparency = \"mrt transparency\",\r\n  /**\r\n   * This feature allows picking to occur more efficiently.  The renderer will require less passes to achieve picking\r\n   * due to the presence of enough renderable attachments.\r\n   */\r\n  MrtPick = \"mrt pick\",\r\n  /**\r\n   * This feature provides the renderer a large enough range of element indices for drawing to happen properly.\r\n   */\r\n  UintElementIndex = \"uint element index\",\r\n  /**\r\n   * This feature allows transparency to achieve the optimal quality.  Without this feature, transparency will \"wash out\"\r\n   * more easily.\r\n   */\r\n  FloatRendering = \"float rendering\",\r\n  /**\r\n   * This feature allows for the display of non-3D classification data and solar shadows.\r\n   */\r\n  DepthTexture = \"depth texture\",\r\n  /**\r\n   * This feature allows instancing of geometry in order to optimize rendering speed.\r\n   */\r\n  Instancing = \"instancing\",\r\n  /**\r\n   * This feature indicates that the system has enough texture units available for the shaders to run properly.\r\n   */\r\n  MinimalTextureUnits = \"minimal texture units\",\r\n}\r\n\r\n/** Describes the state of render compatibility.\r\n * @beta\r\n */\r\nexport enum WebGLRenderCompatibilityStatus {\r\n  /**\r\n   * Signifies that everything is ideal: context created successfully, all required and optional features are available,\r\n   * and browser did not signal a major performance caveat.\r\n   */\r\n  AllOkay,\r\n  /**\r\n   * Signifies that the base requirements of compatibility are met but at least some optional features are missing.\r\n   * Consult the contents of [[WebGLRenderCompatibilityInfo.missingOptionalFeatures]].\r\n   */\r\n  MissingOptionalFeatures,\r\n  /**\r\n   * Signifies that the base requirements of compatibility are met but WebGL reported a major performance caveat.  The browser\r\n   * has likely fallen back to software rendering due to lack of a usable GPU.\r\n   * Consult [[WebGLRenderCompatibilityInfo.contextErrorMessage]] for a possible description of what went wrong.\r\n   * There could also be some missing optional features; consult the contents of [[WebGLRenderCompatibilityInfo.missingOptionalFeatures]].\r\n   */\r\n  MajorPerformanceCaveat,\r\n  /**\r\n   * Signifies that the base requirements of compatibility are not met; rendering cannot occur.\r\n   * Consult the contents of [[WebGLRenderCompatibilityInfo.missingRequiredFeatures]].\r\n   */\r\n  MissingRequiredFeatures,\r\n  /**\r\n   * Signifies an inability to create either a canvas or a WebGL rendering context; rendering cannot occur.  Consult\r\n   * [[WebGLRenderCompatibilityInfo.contextErrorMessage]] for a possible description of what went wrong.\r\n   */\r\n  CannotCreateContext,\r\n}\r\n\r\n/** WebGL rendering compatibility information returned by [[IModelApp.queryRenderCompatibility]].\r\n * @beta\r\n */\r\nexport interface WebGLRenderCompatibilityInfo {\r\n  /**\r\n   * Describes the overall status of rendering compatibility.\r\n   */\r\n  status: WebGLRenderCompatibilityStatus;\r\n  /**\r\n   * An array containing required features that are unsupported by this system.\r\n   */\r\n  missingRequiredFeatures: WebGLFeature[];\r\n  /**\r\n   * An array containing optional features that are unsupported by this system.  These are features that could provide\r\n   * a performance and/or quality benefit.\r\n   */\r\n  missingOptionalFeatures: WebGLFeature[];\r\n  /**\r\n   * Possible supplemental details describing why a context could not be created (due to performance caveat or other reason).\r\n   */\r\n  contextErrorMessage?: string;\r\n}\r\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Views */\r\n\r\nimport { RenderSchedule, RgbColor } from \"@bentley/imodeljs-common\";\r\nimport { Range1d, Transform, Point3d, Vector3d, Matrix3d, Plane3dByOriginAndUnitNormal, ClipPlane, ClipPrimitive, ClipVector, ConvexClipPlaneSet, UnionOfConvexClipPlaneSets, Point4d } from \"@bentley/geometry-core\";\r\nimport { Id64String, Id64 } from \"@bentley/bentleyjs-core\";\r\nimport { FeatureSymbology } from \"./render/FeatureSymbology\";\r\nimport { IModelApp } from \"./IModelApp\";\r\nimport { IModelConnection } from \"./IModelConnection\";\r\nimport { AnimationBranchStates, AnimationBranchState, RenderClipVolume } from \"./render/System\";\r\n\r\n/** @internal */\r\nexport namespace RenderScheduleState {\r\n  class Interval {\r\n    constructor(public index0: number = 0, public index1: number = 0, public fraction: number = 0.0) { }\r\n    public init(index0: number, index1: number, fraction: number) { this.index0 = index0; this.index1 = index1; this.fraction = fraction; }\r\n  }\r\n  function interpolate(value0: number, value1: number, fraction: number) {\r\n    return value0 + fraction * (value1 - value0);\r\n  }\r\n  export class TimelineEntry implements RenderSchedule.TimelineEntryProps {\r\n    public time: number;\r\n    public interpolation: number;\r\n    constructor(props: RenderSchedule.TimelineEntryProps) {\r\n      this.time = props.time;\r\n      this.interpolation = props.interpolation;\r\n    }\r\n  }\r\n  export class VisibilityEntry extends TimelineEntry implements RenderSchedule.VisibilityEntryProps {\r\n    public value: number = 100.0;\r\n    constructor(props: RenderSchedule.VisibilityEntryProps) {\r\n      super(props);\r\n      this.value = props.value;\r\n    }\r\n  }\r\n  export class ColorEntry extends TimelineEntry implements RenderSchedule.ColorEntryProps {\r\n    public value: { red: number, green: number, blue: number };\r\n    constructor(props: RenderSchedule.ColorEntryProps) {\r\n      super(props);\r\n      this.value = props.value;\r\n    }\r\n  }\r\n\r\n  export class TransformEntry extends TimelineEntry implements RenderSchedule.TransformEntryProps {\r\n    public value: RenderSchedule.TransformProps;\r\n    constructor(props: RenderSchedule.TransformEntryProps) {\r\n      super(props);\r\n      this.value = props.value;\r\n    }\r\n  }\r\n  export class CuttingPlaneEntry extends TimelineEntry implements RenderSchedule.CuttingPlaneEntryProps {\r\n    public value: RenderSchedule.CuttingPlaneProps;\r\n    constructor(props: RenderSchedule.CuttingPlaneEntryProps) {\r\n      super(props);\r\n      this.value = props.value;\r\n    }\r\n  }\r\n  export class ElementTimeline implements RenderSchedule.ElementTimelineProps {\r\n    public currentClip?: RenderClipVolume;\r\n    public elementIds: Id64String[];\r\n    public batchId: number;\r\n    public visibilityTimeline?: VisibilityEntry[];\r\n    public colorTimeline?: ColorEntry[];\r\n    public transformTimeline?: TransformEntry[];\r\n    public cuttingPlaneTimeline?: CuttingPlaneEntry[];\r\n    public get isValid() { return this.elementIds.length > 0 && (Array.isArray(this.visibilityTimeline) && this.visibilityTimeline.length > 0) || (Array.isArray(this.colorTimeline) && this.colorTimeline.length > 0); }\r\n    private constructor(elementIds: Id64String[], batchId: number) { this.elementIds = elementIds; this.batchId = batchId; }\r\n    public static fromJSON(json?: RenderSchedule.ElementTimelineProps): ElementTimeline {\r\n      if (!json)\r\n        return new ElementTimeline([], 0);\r\n\r\n      const val = new ElementTimeline(json.elementIds, json.batchId);\r\n      if (json.visibilityTimeline) {\r\n        val.visibilityTimeline = [];\r\n        json.visibilityTimeline.forEach((entry) => val.visibilityTimeline!.push(new VisibilityEntry(entry)));\r\n      }\r\n      if (json.colorTimeline) {\r\n        val.colorTimeline = [];\r\n        json.colorTimeline.forEach((entry) => val.colorTimeline!.push(new ColorEntry(entry)));\r\n      }\r\n      if (json.transformTimeline) {\r\n        val.transformTimeline = [];\r\n        json.transformTimeline.forEach((entry) => val.transformTimeline!.push(new TransformEntry(entry)));\r\n      }\r\n      if (json.cuttingPlaneTimeline) {\r\n        val.cuttingPlaneTimeline = [];\r\n        json.cuttingPlaneTimeline.forEach((entry) => val.cuttingPlaneTimeline!.push(new CuttingPlaneEntry(entry)));\r\n      }\r\n      return val;\r\n    }\r\n    public get duration() {\r\n      const duration = Range1d.createNull();\r\n      if (this.visibilityTimeline) this.visibilityTimeline.forEach((entry) => duration.extendX(entry.time));\r\n      if (this.colorTimeline) this.colorTimeline.forEach((entry) => duration.extendX(entry.time));\r\n      if (this.transformTimeline) this.transformTimeline.forEach((entry) => duration.extendX(entry.time));\r\n      if (this.cuttingPlaneTimeline) this.cuttingPlaneTimeline.forEach((entry) => duration.extendX(entry.time));\r\n\r\n      return duration;\r\n    }\r\n    public get containsFeatureOverrides() { return undefined !== this.visibilityTimeline || undefined !== this.colorTimeline; }\r\n    public get containsAnimation() { return undefined !== this.transformTimeline || undefined !== this.cuttingPlaneTimeline; }\r\n\r\n    private static findTimelineInterval(interval: Interval, time: number, timeline?: TimelineEntry[]) {\r\n      if (!timeline || timeline.length === 0)\r\n        return false;\r\n\r\n      if (time < timeline[0].time) {\r\n        interval.init(0, 0, 0);\r\n        return true;\r\n      }\r\n      const last = timeline.length - 1;\r\n      if (time >= timeline[last].time) {\r\n        interval.init(last, last, 0.0);\r\n        return true;\r\n      }\r\n      let i: number;\r\n      for (i = 0; i < last; i++)\r\n        if (timeline[i].time <= time && timeline[i + 1].time >= time) {\r\n          interval.init(i, i + 1, timeline[i].interpolation === 2 ? ((time - timeline[i].time) / (timeline[i + 1].time - timeline[i].time)) : 0.0);\r\n          break;\r\n        }\r\n      return true;\r\n    }\r\n\r\n    public getVisibilityOverride(time: number, interval: Interval): number {\r\n      if (!ElementTimeline.findTimelineInterval(interval, time, this.visibilityTimeline) && this.visibilityTimeline![interval.index0].value !== null)\r\n        return 100.0;\r\n      const timeline = this.visibilityTimeline!;\r\n      let visibility = timeline[interval.index0].value;\r\n      if (visibility === undefined || visibility === null)\r\n        return 100.0;\r\n\r\n      if (interval.fraction > 0)\r\n        visibility = interpolate(visibility, timeline[interval.index1].value, interval.fraction);\r\n\r\n      return visibility;\r\n    }\r\n\r\n    public getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number, interval: Interval, batchId: number) {\r\n      let colorOverride, transparencyOverride;\r\n\r\n      const visibility = this.getVisibilityOverride(time, interval);\r\n      if (visibility <= 0) {\r\n        overrides.setAnimationNodeNeverDrawn(batchId);\r\n        return;\r\n      }\r\n      if (visibility <= 100)\r\n        transparencyOverride = 1.0 - visibility / 100.0;\r\n\r\n      if (ElementTimeline.findTimelineInterval(interval, time, this.colorTimeline) && this.colorTimeline![interval.index0].value !== null) {\r\n        const entry0 = this.colorTimeline![interval.index0].value;\r\n        if (interval.fraction > 0) {\r\n          const entry1 = this.colorTimeline![interval.index1].value;\r\n          colorOverride = new RgbColor(interpolate(entry0.red, entry1.red, interval.fraction), interpolate(entry0.green, entry1.green, interval.fraction), interpolate(entry0.blue, entry1.blue, interval.fraction));\r\n        } else\r\n          colorOverride = new RgbColor(entry0.red, entry0.green, entry0.blue);\r\n      }\r\n\r\n      if (colorOverride || transparencyOverride)\r\n        overrides.overrideAnimationNode(batchId, FeatureSymbology.Appearance.fromJSON({ rgb: colorOverride, transparency: transparencyOverride }));\r\n    }\r\n    public getAnimationTransform(time: number, interval: Interval): Transform | undefined {\r\n      if (!ElementTimeline.findTimelineInterval(interval, time, this.transformTimeline) || this.transformTimeline![interval.index0].value === null)\r\n        return undefined;\r\n\r\n      if (interval.index0 < 0)\r\n        return Transform.createIdentity();\r\n\r\n      const timeline = this.transformTimeline!;\r\n      const value = timeline[interval.index0].value;\r\n      const transform = Transform.fromJSON(value.transform);\r\n      if (interval.fraction > 0.0) {\r\n        const value1 = timeline[interval.index1].value;\r\n        if (value1.pivot !== null && value1.orientation !== null && value1.position !== null) {\r\n          const q0 = Point4d.fromJSON(value.orientation), q1 = Point4d.fromJSON(value1.orientation);\r\n          const sum = Point4d.interpolateQuaternions(q0, interval.fraction, q1);\r\n          const interpolatedMatrix = Matrix3d.createFromQuaternion(sum);\r\n          const position0 = Vector3d.fromJSON(value.position), position1 = Vector3d.fromJSON(value1.position);\r\n          const pivot = Vector3d.fromJSON(value.pivot);\r\n          const pre = Transform.createTranslation(pivot);\r\n          const post = Transform.createTranslation(position0.interpolate(interval.fraction, position1));\r\n          const product = post.multiplyTransformMatrix3d(interpolatedMatrix);\r\n          transform.setFromJSON(product.multiplyTransformTransform(pre));\r\n        } else {\r\n          const transform1 = Transform.fromJSON(value1.transform);\r\n          const q0 = transform.matrix.inverse()!.toQuaternion(), q1 = transform1.matrix.inverse()!.toQuaternion();\r\n          const sum = Point4d.interpolateQuaternions(q0, interval.fraction, q1);\r\n          const interpolatedMatrix = Matrix3d.createFromQuaternion(sum);\r\n\r\n          const origin = Vector3d.createFrom(transform.origin), origin1 = Vector3d.createFrom(transform1.origin);\r\n          transform.setFromJSON({ origin: origin.interpolate(interval.fraction, origin1), matrix: interpolatedMatrix });\r\n        }\r\n      }\r\n      return transform;\r\n    }\r\n\r\n    public getAnimationClip(time: number, interval: Interval): RenderClipVolume | undefined {\r\n      if (this.currentClip) {\r\n        this.currentClip.dispose();\r\n        this.currentClip = undefined;\r\n      }\r\n      if (!ElementTimeline.findTimelineInterval(interval, time, this.cuttingPlaneTimeline) || this.cuttingPlaneTimeline![interval.index0].value === null)\r\n        return undefined;\r\n\r\n      const timeline = this.cuttingPlaneTimeline!;\r\n      const value = timeline[interval.index0].value;\r\n      if (!value)\r\n        return undefined;\r\n\r\n      const position = Point3d.fromJSON(value.position);\r\n      const direction = Vector3d.fromJSON(value.direction);\r\n      if (interval.fraction > 0.0) {\r\n        const value1 = timeline[interval.index1].value;\r\n        position.interpolate(interval.fraction, Point3d.fromJSON(value1.position), position);\r\n        direction.interpolate(interval.fraction, Vector3d.fromJSON(value1.direction), direction);\r\n      } else {\r\n        if (value.hidden || value.visible)\r\n          return undefined;\r\n      }\r\n\r\n      direction.normalizeInPlace();\r\n      const plane = Plane3dByOriginAndUnitNormal.create(position, direction);\r\n      const clipPlane = ClipPlane.createPlane(plane!);\r\n      const clipPlaneSet = UnionOfConvexClipPlaneSets.createConvexSets([ConvexClipPlaneSet.createPlanes([clipPlane])]);\r\n      const clipPrimitive = ClipPrimitive.createCapture(clipPlaneSet);\r\n      const clipVector = ClipVector.createCapture([clipPrimitive]);\r\n\r\n      this.currentClip = IModelApp.renderSystem.createClipVolume(clipVector);\r\n      return this.currentClip;\r\n    }\r\n  }\r\n\r\n  export class ModelTimeline implements RenderSchedule.ModelTimelineProps {\r\n    public modelId: Id64String;\r\n    public elementTimelines: ElementTimeline[] = [];\r\n    public containsFeatureOverrides: boolean = false;\r\n    public containsAnimation: boolean = false;\r\n    private constructor(modelId: Id64String) { this.modelId = modelId; }\r\n    public get duration() {\r\n      const duration = Range1d.createNull();\r\n      this.elementTimelines.forEach((element) => duration.extendRange(element.duration));\r\n      return duration;\r\n    }\r\n\r\n    public static fromJSON(json?: RenderSchedule.ModelTimelineProps) {\r\n      if (!json)\r\n        return new ModelTimeline(\"\");\r\n\r\n      const value = new ModelTimeline(json.modelId);\r\n      if (json.elementTimelines)\r\n        json.elementTimelines.forEach((element) => {\r\n          const elementTimeline = ElementTimeline.fromJSON(element);\r\n          value.elementTimelines.push(elementTimeline);\r\n          if (elementTimeline.containsFeatureOverrides)\r\n            value.containsFeatureOverrides = true;\r\n          if (elementTimeline.containsAnimation)\r\n            value.containsAnimation = true;\r\n        });\r\n\r\n      return value;\r\n    }\r\n    public getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number) { const interval = new Interval(); this.elementTimelines.forEach((entry) => entry.getSymbologyOverrides(overrides, time, interval, entry.batchId)); }\r\n    public forEachAnimatedId(idFunction: (id: Id64String) => void): void {\r\n      if (this.containsAnimation) {\r\n        for (const timeline of this.elementTimelines)\r\n          if (timeline.containsAnimation)\r\n            for (const id of timeline.elementIds)\r\n              idFunction(id);\r\n      }\r\n    }\r\n    public getAnimationBranches(branches: AnimationBranchStates, scheduleTime: number) {\r\n      const interval = new Interval();\r\n      for (let i = 0; i < this.elementTimelines.length; i++) {\r\n        const elementTimeline = this.elementTimelines[i];\r\n        if (elementTimeline.getVisibilityOverride(scheduleTime, interval) <= 0.0) {\r\n          branches.set(this.modelId + \"_Node_\" + (i + 1).toString(), new AnimationBranchState(undefined, undefined, true));\r\n        } else {\r\n          const transform = elementTimeline.getAnimationTransform(scheduleTime, interval);\r\n          const clip = elementTimeline.getAnimationClip(scheduleTime, interval);\r\n          if (transform || clip)\r\n            branches.set(this.modelId + \"_Node_\" + (i + 1).toString(), new AnimationBranchState(transform, clip));\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  export class Script {\r\n    public modelTimelines: ModelTimeline[] = [];\r\n    public iModel: IModelConnection;\r\n    public displayStyleId: Id64String;\r\n\r\n    constructor(displayStyleId: Id64String, iModel: IModelConnection) { this.displayStyleId = displayStyleId; this.iModel = iModel; }\r\n    public static fromJSON(displayStyleId: Id64String, iModel: IModelConnection, modelTimelines: RenderSchedule.ModelTimelineProps[]): Script | undefined {\r\n      const value = new Script(displayStyleId, iModel);\r\n      modelTimelines.forEach((entry) => value.modelTimelines.push(ModelTimeline.fromJSON(entry)));\r\n      return value;\r\n    }\r\n    public get containsAnimation() {\r\n      for (const modelTimeline of this.modelTimelines)\r\n        if (modelTimeline.containsAnimation)\r\n          return true;\r\n      return false;\r\n    }\r\n    public getAnimationBranches(scheduleTime: number): AnimationBranchStates | undefined {\r\n      if (!this.containsAnimation)\r\n        return undefined;\r\n\r\n      const animationBranches = new Map<string, AnimationBranchState>();\r\n      this.modelTimelines.forEach((modelTimeline) => modelTimeline.getAnimationBranches(animationBranches, scheduleTime));\r\n      return animationBranches;\r\n    }\r\n\r\n    public get duration() {\r\n      const duration = Range1d.createNull();\r\n      this.modelTimelines.forEach((model) => duration.extendRange(model.duration));\r\n      return duration;\r\n    }\r\n\r\n    public get containsFeatureOverrides() {\r\n      let containsFeatureOverrides = false;\r\n      this.modelTimelines.forEach((entry) => { if (entry.containsFeatureOverrides) containsFeatureOverrides = true; });\r\n      return containsFeatureOverrides;\r\n    }\r\n\r\n    public getSymbologyOverrides(overrides: FeatureSymbology.Overrides, time: number) {\r\n      this.modelTimelines.forEach((entry) => entry.getSymbologyOverrides(overrides, time));\r\n    }\r\n    public getModelAnimationId(modelId: Id64String): Id64String | undefined {\r\n      if (Id64.isTransient(modelId))\r\n        return undefined;\r\n\r\n      for (const modelTimeline of this.modelTimelines)\r\n        if (modelTimeline.modelId === modelId && modelTimeline.containsAnimation)\r\n          return this.displayStyleId;\r\n\r\n      return undefined;\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module SelectionSet */\nimport { BeEvent, Id64String, Id64, Id64Arg } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { IModelApp } from \"./IModelApp\";\n\n/** Identifies the type of changes made to the [[SelectionSet]] to produce a [[SelectionSetEvent]].\n * @public\n */\nexport enum SelectionSetEventType {\n  /** Elements have been added to the set. */\n  Add,\n  /** Elements have been removed from the set. */\n  Remove,\n  /** Some elements have been added to the set and others have been removed. */\n  Replace,\n  /** All elements are about to be removed from the set. */\n  Clear,\n}\n\n/** Passed to [[SelectionSet.onChanged]] event listeners when elements are added to the selection set.\n * @public\n */\nexport interface SelectAddEvent {\n  type: SelectionSetEventType.Add;\n  /** The Ids of the elements added to the set. */\n  added: Id64Arg;\n  /** The affected SelectionSet. */\n  set: SelectionSet;\n}\n\n/** Passed to [[SelectionSet.onChanged]] event listeners when elements are removed from the selection set.\n * @public\n */\nexport interface SelectRemoveEvent {\n  /** The type of operation that produced this event. */\n  type: SelectionSetEventType.Remove | SelectionSetEventType.Clear;\n  /** The element Ids removed from the set. */\n  removed: Id64Arg;\n  /** The affected SelectionSet. */\n  set: SelectionSet;\n}\n\n/** Passed to [[SelectionSet.onChanged]] event listeners when elements are simultaneously added to and removed from the selection set.\n * @public\n */\nexport interface SelectReplaceEvent {\n  type: SelectionSetEventType.Replace;\n  /** The element Ids added to the set. */\n  added: Id64Arg;\n  /** The element Ids removed from the set. */\n  removed: Id64Arg;\n  /** The affected SelectionSet. */\n  set: SelectionSet;\n}\n\n/** Payload sent to [[SelectionSet.onChanged]] event listeners to describe how the contents of the set have changed.\n * The `type` property of the event serves as a type assertion. For example, the following code will output the added and/or removed Ids:\n *  ```ts\n *  processSelectionSetEvent(ev: SelectionSetEvent): void {\n *    if (SelectionSetEventType.Add === ev.type || SelectionSetEventType.Replace === ev.type)\n *      console.log(\"Added \" + ev.added.size + \" elements\");\n *\n *    if (SelectionSetEventType.Add !== ev.type)\n *      console.log(\"Removed \" + ev.removed.size + \" elements\");\n *  }\n *  ```\n * @public\n */\nexport type SelectionSetEvent = SelectAddEvent | SelectRemoveEvent | SelectReplaceEvent;\n\n/** Tracks a set of hilited entities. When the set changes, notifies ViewManager so that symbology overrides can be updated in active Viewports.\n * @internal\n */\nclass HilitedIds extends Id64.Uint32Set {\n  protected _iModel: IModelConnection;\n  protected _changing = false;\n\n  public constructor(iModel: IModelConnection) {\n    super();\n    this._iModel = iModel;\n  }\n\n  public add(low: number, high: number) {\n    super.add(low, high);\n    this.onChanged();\n  }\n\n  public delete(low: number, high: number) {\n    super.delete(low, high);\n    this.onChanged();\n  }\n\n  public clear() {\n    super.clear();\n    this.onChanged();\n  }\n\n  public addIds(ids: Id64Arg) {\n    this.change(() => super.addIds(ids));\n  }\n\n  public deleteIds(ids: Id64Arg) {\n    this.change(() => super.deleteIds(ids));\n  }\n\n  protected onChanged() {\n    if (!this._changing)\n      IModelApp.viewManager.onSelectionSetChanged(this._iModel);\n  }\n\n  protected change(func: () => void) {\n    const changing = this._changing;\n    this._changing = false;\n    func();\n    this._changing = changing;\n    this.onChanged();\n  }\n}\n\n/** Keeps the set of hilited elements in sync with the selection set.\n * @internal\n */\nclass HilitedElementIds extends HilitedIds {\n  private _removeListener?: () => void;\n\n  public constructor(iModel: IModelConnection, syncWithSelectionSet = true) {\n    super(iModel);\n    this.wantSyncWithSelectionSet = syncWithSelectionSet;\n  }\n\n  public get wantSyncWithSelectionSet(): boolean { return undefined !== this._removeListener; }\n  public set wantSyncWithSelectionSet(want: boolean) {\n    if (want === this.wantSyncWithSelectionSet)\n      return;\n\n    if (want) {\n      const set = this._iModel.selectionSet;\n      this._removeListener = set.onChanged.addListener((ev) => this.change(() => this.processSelectionSetEvent(ev)));\n      this.processSelectionSetEvent({\n        set,\n        type: SelectionSetEventType.Add,\n        added: set.elements,\n      });\n    } else {\n      this._removeListener!();\n      this._removeListener = undefined;\n    }\n  }\n\n  private processSelectionSetEvent(ev: SelectionSetEvent): void {\n    if (SelectionSetEventType.Add !== ev.type)\n      this.deleteIds(ev.removed);\n\n    if (ev.type === SelectionSetEventType.Add || ev.type === SelectionSetEventType.Replace)\n      this.addIds(ev.added);\n  }\n}\n\n/** A set of *hilited* elements for an [[IModelConnection]], by element id.\n * Hilited elements are displayed with a customizable hilite effect within a [[Viewport]].\n * The set exposes 3 types of elements in 3 separate collections: geometric elements, subcategories, and geometric models.\n * @note Typically, elements are hilited by virtue of their presence in the IModelConnection's [[SelectionSet]]. The HiliteSet allows additional\n * elements to be displayed with the hilite effect without adding them to the [[SelectionSet]].\n * @see [Hilite.Settings]($common) for customization of the hilite effect.\n * @alpha\n */\nexport class HiliteSet {\n  private readonly _elements: HilitedElementIds;\n\n  public readonly subcategories: Id64.Uint32Set;\n  public readonly models: Id64.Uint32Set;\n  public get elements(): Id64.Uint32Set { return this._elements; }\n\n  /** Construct a HiliteSet\n   * @param iModel The iModel containing the entities to be hilited.\n   * @param syncWithSelectionSet If true, the contents of the `elements` set will be synchronized with those in the `iModel`'s [[SelectionSet]].\n   */\n  public constructor(public iModel: IModelConnection, syncWithSelectionSet = true) {\n    this._elements = new HilitedElementIds(iModel, syncWithSelectionSet);\n    this.subcategories = new HilitedIds(iModel);\n    this.models = new HilitedIds(iModel);\n  }\n\n  /** Control whether the hilited elements will be synchronized with the contents of the [[SelectionSet]].\n   * By default they are synchronized. Applications that override this take responsibility for managing the set of hilited entities.\n   * When turning synchronization off, the contents of the HiliteSet will remain unchanged.\n   * When turning synchronization on, the current contents of the HiliteSet will be preserved, and the contents of the selection set will be added to them.\n   */\n  public get wantSyncWithSelectionSet(): boolean { return this._elements.wantSyncWithSelectionSet; }\n  public set wantSyncWithSelectionSet(want: boolean) { this._elements.wantSyncWithSelectionSet = want; }\n\n  /** Remove all elements from the hilited set. */\n  public clear() {\n    this.elements.clear();\n    this.subcategories.clear();\n    this.models.clear();\n  }\n\n  public get isEmpty(): boolean { return this.elements.isEmpty && this.subcategories.isEmpty && this.models.isEmpty; }\n\n  /** Toggle the hilited state of one or more elements.\n   * @param arg the ID(s) of the elements whose state is to be toggled.\n   * @param onOff True to add the elements to the hilited set, false to remove them.\n   */\n  public setHilite(arg: Id64Arg, onOff: boolean): void {\n    if (onOff)\n      Id64.forEach(arg, (id) => this.elements.addId(id));\n    else\n      Id64.forEach(arg, (id) => this.elements.deleteId(id));\n\n    IModelApp.viewManager.onSelectionSetChanged(this.iModel);\n  }\n}\n\n/** A set of *currently selected* elements for an IModelConnection.\n * Selected elements are displayed with a customizable hilite effect within a [[Viewport]].\n * @see [Hilite.Settings]($common) for customization of the hilite effect.\n * @public\n */\nexport class SelectionSet {\n  private _elements = new Set<string>();\n\n  /** The IDs of the selected elements.\n   * @note Do not modify this set directly. Instead, use methods like [[SelectionSet.add]].\n   */\n  public get elements(): Set<string> { return this._elements; }\n\n  /** Called whenever elements are added or removed from this SelectionSet */\n  public readonly onChanged = new BeEvent<(ev: SelectionSetEvent) => void>();\n\n  public constructor(public iModel: IModelConnection) { }\n\n  private sendChangedEvent(ev: SelectionSetEvent) {\n    IModelApp.viewManager.onSelectionSetChanged(this.iModel);\n    this.onChanged.raiseEvent(ev);\n  }\n\n  /** Get the number of entries in this selection set. */\n  public get size() { return this.elements.size; }\n\n  /** Check whether there are any selected elements. */\n  public get isActive() { return this.size !== 0; }\n\n  /** Return true if elemId is in this SelectionSet.\n   * @see [[isSelected]]\n   */\n  public has(elemId?: string) { return !!elemId && this.elements.has(elemId); }\n\n  /** Query whether an Id is in the selection set.\n   * @see [[has]]\n   */\n  public isSelected(elemId?: Id64String): boolean { return !!elemId && this.elements.has(elemId); }\n\n  /** Clear current selection set.\n   * @note raises the [[onChanged]] event with [[SelectionSetEventType.Clear]].\n   */\n  public emptyAll(): void {\n    if (!this.isActive)\n      return;\n\n    const removed = this._elements;\n    this._elements = new Set<string>();\n    this.sendChangedEvent({ set: this, type: SelectionSetEventType.Clear, removed });\n  }\n\n  /**\n   * Add one or more Ids to the current selection set.\n   * @param elem The set of Ids to add.\n   * @returns true if any elements were added.\n   */\n  public add(elem: Id64Arg): boolean {\n    return this._add(elem);\n  }\n\n  private _add(elem: Id64Arg, sendEvent = true): boolean {\n    const oldSize = this.elements.size;\n    Id64.forEach(elem, (id) => this.elements.add(id));\n    const changed = oldSize !== this.elements.size;\n    if (sendEvent && changed)\n      this.sendChangedEvent({ type: SelectionSetEventType.Add, set: this, added: elem });\n\n    return changed;\n  }\n\n  /**\n   * Remove one or more Ids from the current selection set.\n   * @param elem The set of Ids to remove.\n   * @returns true if any elements were removed.\n   */\n  public remove(elem: Id64Arg): boolean {\n    return this._remove(elem);\n  }\n\n  private _remove(elem: Id64Arg, sendEvent = true): boolean {\n    const oldSize = this.elements.size;\n    Id64.forEach(elem, (id) => this.elements.delete(id));\n    const changed = oldSize !== this.elements.size;\n    if (sendEvent && changed)\n      this.sendChangedEvent({ type: SelectionSetEventType.Remove, set: this, removed: elem });\n\n    return changed;\n  }\n\n  /**\n   * Add one set of Ids, and remove another set of Ids. Any Ids that are in both sets are removed.\n   * @returns True if any Ids were either added or removed.\n   */\n  public addAndRemove(adds: Id64Arg, removes: Id64Arg): boolean {\n    const added = this._add(adds, false);\n    const removed = this._remove(removes, false);\n\n    if (added && removed)\n      this.sendChangedEvent({ type: SelectionSetEventType.Replace, set: this, added: adds, removed: removes });\n    else if (added)\n      this.sendChangedEvent({ type: SelectionSetEventType.Add, set: this, added: adds });\n    else if (removed)\n      this.sendChangedEvent({ type: SelectionSetEventType.Remove, set: this, removed: removes });\n\n    return (added || removed);\n  }\n\n  /** Invert the state of a set of Ids in the SelectionSet */\n  public invert(elem: Id64Arg): boolean {\n    const elementsToAdd = new Set<string>();\n    const elementsToRemove = new Set<string>();\n    Id64.forEach(elem, (id) => {\n      if (this.elements.has(id))\n        elementsToRemove.add(id);\n      else\n        elementsToAdd.add(id);\n    });\n\n    return this.addAndRemove(elementsToAdd, elementsToRemove);\n  }\n\n  /** Change selection set to be the supplied set of Ids. */\n  public replace(elem: Id64Arg): void {\n    if (areEqual(this.elements, elem))\n      return;\n\n    const removed = this._elements;\n    this._elements = new Set<string>();\n    this._add(elem, false);\n\n    if (0 < removed.size) {\n      Id64.forEach(elem, (id) => {\n        if (removed.has(id))\n          removed.delete(id);\n      });\n    }\n\n    this.sendChangedEvent({ type: SelectionSetEventType.Replace, set: this, added: elem, removed });\n  }\n}\n\nfunction areEqual(lhs: Set<string>, rhs: Id64Arg): boolean {\n  // Size is unreliable if input can contain duplicates...\n  if (Array.isArray(rhs))\n    rhs = Id64.toIdSet(rhs);\n\n  if (lhs.size !== Id64.sizeOf(rhs))\n    return false;\n\n  return Id64.iterate(rhs, (id) => lhs.has(id));\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\n\nimport { assert, BeDuration, dispose, Id64String, Id64, Id64Array, JsonUtils } from \"@bentley/bentleyjs-core\";\nimport { Angle, ClipVector, Constant, IndexedPolyface, IndexedPolyfaceVisitor, Matrix3d, Point2d, Point3d, Range2d, Range3d, Transform } from \"@bentley/geometry-core\";\nimport {\n  ColorDef, ElementAlignedBox2d, ElementAlignedBox3d, Feature, FeatureTable, Gradient, GraphicParams, ImageBuffer,\n  Placement2d, RenderMode, RenderTexture, SheetProps, TileProps, TileTreeProps, ViewAttachmentProps, ViewDefinition2dProps, ViewFlag,\n  ViewFlags, ViewStateProps,\n} from \"@bentley/imodeljs-common\";\nimport { CategorySelectorState } from \"./CategorySelectorState\";\nimport { DisplayStyle2dState } from \"./DisplayStyleState\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { FeatureSymbology } from \"./render/FeatureSymbology\";\nimport { GraphicBuilder, GraphicType } from \"./render/GraphicBuilder\";\nimport { GraphicList, PackedFeatureTable, RenderClipVolume, RenderGraphic, RenderPlan, RenderTarget } from \"./render/System\";\nimport { Tile, TileLoader, TileTree } from \"./tile/TileTree\";\nimport { TileRequest } from \"./tile/TileRequest\";\nimport { DecorateContext, SceneContext } from \"./ViewContext\";\nimport { CoordSystem, OffScreenViewport, Viewport, ViewRect } from \"./Viewport\";\nimport { SpatialViewState, ViewState, ViewState2d, ViewState3d } from \"./ViewState\";\n\n/** Describes the geometry and styling of a sheet border decoration.\n * The sheet border decoration mimics a sheet of paper with a drop shadow.\n * @internal\n */\nexport class SheetBorder {\n  private _rect: Point2d[];\n  private _shadow: Point2d[];\n  private _gradient: Gradient.Symb;\n\n  private constructor(rect: Point2d[], shadow: Point2d[], gradient: Gradient.Symb) {\n    this._rect = rect;\n    this._shadow = shadow;\n    this._gradient = gradient;\n  }\n\n  /** Create a new sheet border. If a context is supplied, points are transformed to view coordinates. */\n  public static create(width: number, height: number, context?: DecorateContext) {\n    // Rect\n    const rect: Point3d[] = [\n      Point3d.create(0, height),\n      Point3d.create(0, 0),\n      Point3d.create(width, 0),\n      Point3d.create(width, height),\n      Point3d.create(0, height)];\n    if (context) {\n      context.viewport.worldToViewArray(rect);\n    }\n\n    // Shadow\n    const shadowWidth = .01 * Math.sqrt(width * width + height * height);\n    const shadow: Point3d[] = [\n      Point3d.create(shadowWidth, 0),\n      Point3d.create(shadowWidth, -shadowWidth),\n      Point3d.create(width + shadowWidth, -shadowWidth),\n      Point3d.create(width + shadowWidth, height - shadowWidth),\n      Point3d.create(width, height - shadowWidth),\n      Point3d.create(width, 0),\n      Point3d.create(shadowWidth, 0),\n    ];\n    if (context) {\n      context.viewport.worldToViewArray(shadow);\n    }\n\n    // Gradient\n    const gradient = new Gradient.Symb();\n    gradient.mode = Gradient.Mode.Linear;\n    gradient.angle = Angle.createDegrees(-45);\n    gradient.keys = [{ value: 0, color: ColorDef.from(25, 25, 25) }, { value: 0.5, color: ColorDef.from(150, 150, 150) }];\n\n    // Copy over points\n    // ### TODO: Allow for conversion of 2d points array to view coordinates from world coordinates to avoid these copies?..\n    const rect2d: Point2d[] = [];\n    for (const point of rect)\n      rect2d.push(Point2d.createFrom(point));\n    const shadow2d: Point2d[] = [];\n    for (const point of shadow)\n      shadow2d.push(Point2d.createFrom(point));\n\n    return new SheetBorder(rect2d, shadow2d, gradient);\n  }\n\n  public getRange(): Range2d {\n    const range = Range2d.createArray(this._rect);\n    const shadowRange = Range2d.createArray(this._shadow);\n    range.extendRange(shadowRange);\n    return range;\n  }\n\n  /** Add this border to the given GraphicBuilder. */\n  public addToBuilder(builder: GraphicBuilder) {\n    const lineColor = ColorDef.black;\n    const fillColor = ColorDef.black;\n\n    const params = new GraphicParams();\n    params.setFillColor(fillColor);\n    params.gradient = this._gradient;\n\n    builder.activateGraphicParams(params);\n    builder.addShape2d(this._shadow, RenderTarget.frustumDepth2d);\n\n    builder.setSymbology(lineColor, fillColor, 2);\n    builder.addLineString2d(this._rect, 0);\n  }\n}\n\n/** @internal */\nexport namespace Attachments {\n  /** @internal */\n  export class AttachmentViewport extends OffScreenViewport {\n    public rendering: boolean = false;\n    public toParent: Transform = Transform.createIdentity();  // attachment NPC to sheet world\n    private _texture?: RenderTexture;\n    private _sceneDepth: number = 0xffffffff;\n    private _scene?: GraphicList;\n\n    public get texture(): RenderTexture | undefined { return this._texture; }\n\n    public createScene(currentState: State): State {\n      if (currentState === State.Empty || currentState === State.Ready) {\n        assert(false);    // these are end states\n        return currentState;\n      }\n\n      if (this._changeFlags.areFeatureOverridesDirty) {\n        const ovrs = new FeatureSymbology.Overrides(this.view);\n        this.target.overrideFeatureSymbology(ovrs);\n        this._changeFlags.clear();\n      }\n\n      if (!this.sync.isValidController)\n        this.setupFromView();\n\n      this._scene = [];\n      const sceneContext = this.createSceneContext();\n      this.view.createScene(sceneContext);\n\n      sceneContext.requestMissingTiles();\n\n      // The scene is ready when (1) all required TileTree roots have been created and (2) all required tiles have finished loading\n      if (!this.view.areAllTileTreesLoaded || sceneContext.hasMissingTiles)\n        return State.Loading;\n\n      return State.Ready;\n    }\n\n    public renderImage(): ImageBuffer | undefined {\n      if (!this.sync.isValidRenderPlan) {\n        this.target.changeRenderPlan(RenderPlan.createFromViewport(this));\n        this.sync.setValidRenderPlan();\n      }\n\n      this.target.changeScene(this._scene! /* TODO: Pass view state's active volume... */);\n      this.renderFrame();\n\n      this._texture = undefined;\n      return this.readImage();\n    }\n\n    public renderTexture() {\n      const image = this.renderImage();\n      if (image === undefined)\n        return;   // image most likely consisted entirely of background pixels... don't bother creating graphic\n\n      const params = new RenderTexture.Params(undefined, RenderTexture.Type.TileSection);\n      this._texture = this.target.renderSystem.createTextureFromImageBuffer(image, this.view.iModel, params);\n      assert(this._texture !== undefined);\n    }\n\n    public setSceneDepth(depth: number, tree: Tree3d) {\n      if (this._sceneDepth !== depth) {\n        // Ensure that if we return to this depth and need to produce more tile graphics, we first recreate the scene at that depth...\n        if (0xffffffff !== this._sceneDepth && tree.getState(this._sceneDepth) === State.Ready)\n          tree.setState(this._sceneDepth, State.NotLoaded);\n\n        // Discard any tiles/graphics used for previous level-of-detail - we'll generate them at the new LOD\n        this.sync.invalidateScene();\n        // ###TODO this.view.cancelAllTileLoads();\n\n        this._sceneDepth = depth;\n        let dim = QUERY_SHEET_TILE_PIXELS;\n        dim = dim * Math.pow(2, depth); // doubling the rect dimensions for every level of depth\n        this.setRect(new ViewRect(0, 0, dim, dim), true);\n      }\n    }\n\n    // override\n    public get isAspectRatioLocked(): boolean { return true; }\n  }\n\n  /**\n   * Describes the location of a tile within the range of a quad subdivided in four parts.\n   * @internal\n   */\n  export const enum Tile3dPlacement { // tslint:disable-line:no-const-enum\n    UpperLeft,\n    UpperRight,\n    LowerLeft,\n    LowerRight,\n    Root,   // root placement is for root tile of a tree: a single placement representing entire image (not subdivided)\n  }\n\n  /**\n   * Describes the state of the scene for a given level of the tile tree. All tiles on a given level use the same scene to generate their graphics.\n   * @internal\n   */\n  export const enum State { // tslint:disable-line:no-const-enum\n    NotLoaded,  // We haven't tried to create the scene for this level of the tree\n    Empty,      // This level of the tree has an empty scene\n    Loading,    // All of the roots for this level of the tree have been created and we are loading their tiles\n    Ready,      // All of the tiles required for this level of the tree are ready for rendering\n  }\n\n  const QUERY_SHEET_TILE_PIXELS: number = 512;\n\n  /** @internal */\n  abstract class AttachmentTileLoader extends TileLoader {\n    public abstract get is3dAttachment(): boolean;\n    public tileRequiresLoading(_params: Tile.Params): boolean { return true; }\n    public get priority(): Tile.LoadPriority { return Tile.LoadPriority.Primary; }\n    public async getChildrenProps(_parent: Tile): Promise<TileProps[]> { assert(false); return Promise.resolve([]); }\n    public async requestTileContent(_tile: Tile): Promise<TileRequest.Response> {\n      // ###TODO?\n      return Promise.resolve(undefined);\n    }\n  }\n\n  /** @internal */\n  class TileLoader2d extends AttachmentTileLoader {\n    private readonly _viewFlagOverrides: ViewFlag.Overrides;\n\n    public constructor(view: ViewState) {\n      super();\n\n      // ###TODO: Why do 2d views have camera lights enabled?\n      this._viewFlagOverrides = new ViewFlag.Overrides(view.viewFlags);\n      this._viewFlagOverrides.setShowCameraLights(false);\n    }\n\n    public get maxDepth() { return 1; }\n    public get viewFlagOverrides() { return this._viewFlagOverrides; }\n    public get is3dAttachment(): boolean { return false; }\n  }\n\n  /** @internal */\n  class TileLoader3d extends AttachmentTileLoader {\n    /** DEBUG ONLY - Setting this to true will result in only sheet tile polys being drawn, and not the textures they contain. */\n    private static _DEBUG_NO_TEXTURES = false;\n    // ----------------------------------------------------------------------------------\n    private static _viewFlagOverrides = new ViewFlag.Overrides(ViewFlags.fromJSON({\n      renderMode: RenderMode.SmoothShade,\n      noCameraLights: true,\n      noSourceLights: true,\n      noSolarLight: true,\n      noTexture: TileLoader3d._DEBUG_NO_TEXTURES,\n    }));\n\n    public get maxDepth() { return 32; }\n    public get viewFlagOverrides() { return TileLoader3d._viewFlagOverrides; }\n    public get is3dAttachment(): boolean { return true; }\n  }\n\n  /** @internal */\n  export class Tile2d extends Tile {\n    public constructor(root: Tree2d, range: ElementAlignedBox2d) {\n      const params: Tile.Params = {\n        root,\n        contentId: \"\",\n        range: new Range3d(0, 0, -RenderTarget.frustumDepth2d, range.high.x, range.high.y, RenderTarget.frustumDepth2d),\n        maximumSize: 512,  // does not matter... have no children\n        isLeaf: true,\n      };\n\n      super(params);\n      this.setIsReady();\n    }\n\n    public get hasChildren(): boolean { return false; }\n    public get hasGraphics(): boolean { return true; }\n\n    public drawGraphics(args: Tile.DrawArgs) {\n      const myRoot = this.root as Tree2d;\n      const viewRoot = myRoot.viewRoot;\n\n      const drawArgs = viewRoot.createDrawArgs(args.context);\n      drawArgs.location.setFrom(myRoot.drawingToAttachment);\n      drawArgs.clipVolume = myRoot.graphicsClip;\n      drawArgs.graphics.setViewFlagOverrides(this.root.viewFlagOverrides);\n      drawArgs.graphics.symbologyOverrides = myRoot.symbologyOverrides;\n\n      viewRoot.draw(drawArgs);\n    }\n  }\n\n  /** @internal */\n  export class Tile3d extends Tile {\n    /** DEBUG ONLY - This member will cause the sheet tile polyfaces to draw along with the underlying textures. */\n    private static _DRAW_DEBUG_POLYFACE_GRAPHICS: boolean = false;\n    // ------------------------------------------------------------------------------------------\n    private _tilePolyfaces: IndexedPolyface[] = [];\n\n    private constructor(root: Tree3d, parent: Tile3d | undefined, tileRange: ElementAlignedBox3d) {\n      super({\n        root,\n        contentId: \"\",\n        range: tileRange,\n        maximumSize: .5 * Math.sqrt(2 * QUERY_SHEET_TILE_PIXELS * QUERY_SHEET_TILE_PIXELS),\n        isLeaf: true,\n        parent,\n      });\n    }\n\n    public static create(root: Tree3d, parent: Tile3d | undefined, placement: Tile3dPlacement): Tile3d {\n      let fullRange: Range3d;\n      if (parent !== undefined)\n        fullRange = parent.range.clone();\n      else\n        fullRange = root.getRootRange();\n\n      const mid = fullRange.low.interpolate(0.5, fullRange.high);\n      const range = new Range3d();\n      switch (placement) {\n        case Tile3dPlacement.UpperLeft:\n          range.extend(mid);\n          range.extend(Point3d.create(fullRange.low.x, fullRange.high.y, 0));\n          break;\n        case Tile3dPlacement.UpperRight:\n          range.extend(mid);\n          range.extend(fullRange.high);\n          break;\n        case Tile3dPlacement.LowerLeft:\n          range.extend(fullRange.low);\n          range.extend(mid);\n          break;\n        case Tile3dPlacement.LowerRight:\n          range.extend(Point3d.create(fullRange.high.x, fullRange.low.y, 0));\n          range.extend(mid);\n          break;\n        case Tile3dPlacement.Root:\n        default:\n          range.extendRange(fullRange);\n          break;\n      }\n      range.low.z = 0;\n      range.high.z = 1;\n\n      return new Tile3d(root, parent, range);\n    }\n\n    /** Get the root tile tree cast to a Tree3d. */\n    private get _rootAsTree3d(): Tree3d { return this.root as Tree3d; }\n    /** Get the load state from the owner attachment's array at this tile's depth. */\n    private getState(): State { return this._rootAsTree3d.getState(this.depth - 1); }\n    /** Set the load state of the owner attachment's array at this tile's depth. */\n    private setState(state: State) { this._rootAsTree3d.setState(this.depth - 1, state); }\n\n    // override\n    public get hasGraphics(): boolean { return this.isReady; }\n    // override\n    public get hasChildren(): boolean { return true; }  // << means that \"there are children and creation may be necessary\"... NOT \"definitely have children in children list\"\n\n    // override\n    public selectTiles(selected: Tile[], args: Tile.DrawArgs, _numSkipped: number = 0): Tile.SelectParent { return this.select(selected, args); }\n\n    private select(selected: Tile[], args: Tile.DrawArgs, _numSkipped: number = 0): Tile.SelectParent {\n      if (this.depth === 1)\n        this._rootAsTree3d.viewport.rendering = false;\n\n      if (this.isNotFound)\n        return Tile.SelectParent.No;  // indicates no elements in this tile's range (or some unexpected error occurred during scene creation)\n\n      const vis = this.computeVisibility(args);\n      if (vis === Tile.Visibility.OutsideFrustum) {\n        this.unloadChildren(args.purgeOlderThan);\n        return Tile.SelectParent.No;\n      }\n\n      const tooCoarse = Tile.Visibility.TooCoarse === vis;\n      const children = tooCoarse ? this.prepareChildren() : undefined;\n\n      if (children !== undefined) {\n        const initialSize = selected.length;\n        this._childrenLastUsed = args.now;\n        for (const child of children) {\n          if (child.selectTiles(selected, args) === Tile.SelectParent.Yes) {\n            // At lease one of the selected children is not ready to draw. If the parent (this) is drawable, draw in place of all the children.\n            selected.length = initialSize;\n            if (this.isReady) {\n              selected.push(this);\n              return Tile.SelectParent.No;\n            } else {\n              // This tile isn't ready to draw either. Try drawing its own parent in its place.\n              return Tile.SelectParent.Yes;\n            }\n          }\n        }\n        return Tile.SelectParent.No;\n      }\n\n      // This tile is of appropriate resolution to draw. Enqueue it for loading if necessary.\n      if (!this.isReady) {\n        if (this._tilePolyfaces.length === 0) {\n          this.createPolyfaces(args.context);   // graphicsClip on tree must be set before creating polys (the polys that represent the tile)\n          if (this._tilePolyfaces.length === 0) {\n            this.setNotFound();\n            return Tile.SelectParent.No;\n          }\n        }\n        this.createGraphics(args.context);\n      }\n\n      if (this.isReady) {\n        selected.push(this);\n        this.unloadChildren(args.purgeOlderThan);\n        return Tile.SelectParent.No;\n      }\n\n      // Inform the sheet view state that it needs to recreate the scene next frame\n      this._rootAsTree3d.sheetView.markAttachment3dSceneIncomplete();\n\n      // Tell parent to render in this tile's place until it becomes ready to draw\n      return Tile.SelectParent.Yes;\n    }\n\n    public createPolyfaces(context: SceneContext) {\n      const system = context.target.renderSystem;\n\n      // ### TODO: an optimization could be to make the texture non-square to save on space (make match cropped tile aspect ratio)\n\n      // set up initial corner values (before cropping to clip)\n      const tree = this._rootAsTree3d;\n\n      // Set up initial corner values (before cropping to clip). Range must already be set up (range = unclipped range)\n      const east = this.range.low.x;\n      const west = this.range.high.x;\n      const north = this.range.low.y;\n      const south = this.range.high.y;\n      const corners: Point3d[] = [\n        Point3d.create(east, north, tree.biasDistance),\n        Point3d.create(west, north, tree.biasDistance),\n        Point3d.create(west, south, tree.biasDistance),\n        Point3d.create(east, south, tree.biasDistance),\n      ];\n\n      // first create the polys for the tile so we can get the range (create graphics from polys later)\n      const clip = undefined !== tree.graphicsClip ? tree.graphicsClip.clipVector : undefined;\n      this._tilePolyfaces = system.createSheetTilePolyfaces(corners, clip);\n    }\n\n    public createGraphics(context: SceneContext) {\n      const tree = this._rootAsTree3d;\n      let currentState = this.getState();\n\n      // \"Ready\" state is a valid situation. It means another tile created the scene for this level of detail. We will use that scene.\n      // However, this means we would be using the texture for that other tile, which is not what we want. We must recreate the texture.\n\n      assert(currentState !== State.Empty);\n      if (currentState === State.Empty) {\n        this.setNotFound();\n        return;\n      }\n\n      const system = context.target.renderSystem;\n      const viewport = tree.viewport;\n\n      if (currentState !== State.Ready) {\n        viewport.setSceneDepth(this.depth - 1, tree);\n        viewport.setupFromView();\n\n        // Create the scene and if the scene is complete, mark the state as ready\n        currentState = viewport.createScene(currentState);\n        this.setState(currentState);\n      }\n\n      switch (currentState) {\n        case State.NotLoaded:\n        case State.Loading:\n          return;\n        case State.Empty:\n          this.setNotFound();\n          return;\n        case State.Ready: {\n          // Only render one tile per frame - otherwise we swamp the renderer and introduce lag\n          if (!viewport.rendering) {\n            viewport.rendering = true;\n\n            // render the texture then create graphics from the polys and the rendered texture\n            const frustumToRestore = viewport.getFrustum();\n\n            // Scene rect does not match this. That rect increases with depth. This rect is constant, because it is the rect of the final texture\n            const dim = QUERY_SHEET_TILE_PIXELS;\n            viewport.setRect(new ViewRect(0, 0, dim, dim));\n\n            // Change the frustum so it looks at only the visible (after clipping) portion of the scene.\n            // Also only look at the relevant corner of the scene\n            const frust = viewport.getFrustum(CoordSystem.Npc);\n            frust.initFromRange(this.range);  // use unclipped range of tile to change the frustum (this is what we're looking at)\n\n            const rootToNpc = viewport.viewFrustum.worldToNpcMap;\n            rootToNpc.transform1.multiplyPoint3dArrayQuietNormalize(frust.points);\n            viewport.setupViewFromFrustum(frust);\n\n            viewport.renderTexture();\n            if (viewport.texture === undefined) {\n              this.setNotFound();\n            } else {\n              let graphic = system.createGraphicList(system.createSheetTile(viewport.texture, this._tilePolyfaces, this._rootAsTree3d.tileColor));\n              graphic = system.createBatch(graphic, this._rootAsTree3d.featureTable, this.contentRange);\n              this.setContent({ graphic, contentRange: this.contentRange });\n            }\n\n            // restore frustum\n            viewport.setupViewFromFrustum(frustumToRestore);\n          }\n\n          break;\n        }\n      }\n    }\n\n    public prepareChildren(): Tile[] | undefined {\n      if (this._children === undefined)\n        this._children = [];\n      if (this._children.length === 0) {\n        const childTileUL = Tile3d.create(this._rootAsTree3d, this, Tile3dPlacement.UpperLeft);\n        const childTileUR = Tile3d.create(this._rootAsTree3d, this, Tile3dPlacement.UpperRight);\n        const childTileLL = Tile3d.create(this._rootAsTree3d, this, Tile3dPlacement.LowerLeft);\n        const childTileLR = Tile3d.create(this._rootAsTree3d, this, Tile3dPlacement.LowerRight);\n        this._children.push(childTileUL);\n        this._children.push(childTileUR);\n        this._children.push(childTileLL);\n        this._children.push(childTileLR);\n      }\n      return this._children.length === 0 ? undefined : this._children;\n    }\n\n    public drawGraphics(args: Tile.DrawArgs) {\n      super.drawGraphics(args);\n      if (!Tile3d._DRAW_DEBUG_POLYFACE_GRAPHICS) {\n        return;\n      }\n\n      const polys = this._tilePolyfaces;\n      if (polys.length === 0)\n        return;\n\n      const lineColor = ColorDef.blue.clone();\n      const fillColor = ColorDef.green.clone();\n      fillColor.setAlpha(0x88);\n      lineColor.setAlpha(0xff);\n      const builder = args.context.createSceneGraphicBuilder();\n      builder.setSymbology(lineColor, fillColor, 2);\n      for (const poly of polys) {\n        const polyVisitor = IndexedPolyfaceVisitor.create(poly, 0);\n        while (polyVisitor.moveToNextFacet()) {\n          const lineString: Point3d[] = [];\n          for (let i = 0; i < 3; i++)\n            lineString.push(polyVisitor.getPoint(i)!);\n          if (lineString.length > 0)\n            lineString.push(lineString[0].clone()); // close the loop\n          builder.addLineString(lineString);\n        }\n      }\n\n      args.graphics.add(builder.finish());\n    }\n  }\n\n  /** @internal */\n  export abstract class Tree extends TileTree {\n    public graphicsClip?: RenderClipVolume;\n\n    public dispose(): void {\n      super.dispose();\n      this.graphicsClip = dispose(this.graphicsClip);\n    }\n\n    public constructor(loader: AttachmentTileLoader, iModel: IModelConnection, modelId: Id64String) {\n      // The root tile set here does not matter, as it will be overwritten by the Tree2d and Tree3d constructors\n      const isLeaf = loader.is3dAttachment;\n      const is3d = false; // NB: The attachment is 3d. The attachment tiles are 2d.\n      const props: TileTreeProps = {\n        id: modelId,\n        rootTile: {\n          contentId: \"\",\n          range: {\n            low: { x: 0, y: 0, z: 0 },\n            high: { x: 0, y: 0, z: 0 },\n          },\n          maximumSize: 512,\n          isLeaf,\n        },\n        location: Transform.identity.toJSON(),\n      };\n      const params = TileTree.paramsFromJSON(props, iModel, is3d, loader, modelId);\n      super(params);\n    }\n  }\n\n  /** @internal */\n  export class Tree2d extends Tree {\n    public readonly view: ViewState2d;\n    public readonly viewRoot: TileTree;\n    public readonly drawingToAttachment: Transform;\n    public readonly symbologyOverrides: FeatureSymbology.Overrides;\n\n    private constructor(iModel: IModelConnection, attachment: Attachment2d, view: ViewState2d, viewRoot: TileTree) {\n      super(new TileLoader2d(view), iModel, attachment.id);\n\n      this.view = view;\n      this.viewRoot = viewRoot;\n\n      this.symbologyOverrides = new FeatureSymbology.Overrides(view);\n\n      const attachRange = attachment.placement.calculateRange();\n      const attachWidth = attachRange.high.x - attachRange.low.x;\n      const attachHeight = attachRange.high.y - attachRange.low.y;\n\n      const viewExtents = view.getExtents();\n      const scale = Point2d.create(attachWidth / viewExtents.x, attachHeight / viewExtents.y);\n\n      const worldToAttachment = Point3d.createFrom(attachment.placement.origin);\n      worldToAttachment.z = RenderTarget.depthFromDisplayPriority(attachment.displayPriority);\n\n      const location = Transform.createOriginAndMatrix(worldToAttachment, Matrix3d.createIdentity());\n      this.location.setFrom(location);\n\n      const aspectRatioSkew = view.getAspectRatioSkew();\n      this.drawingToAttachment = Transform.createOriginAndMatrix(Point3d.create(), view.getRotation());\n      this.drawingToAttachment.matrix.scaleColumns(scale.x, aspectRatioSkew * scale.y, 1, this.drawingToAttachment.matrix);\n      const translation = viewRoot.location.origin.cloneAsPoint3d();\n      const viewOrg = view.getOrigin().minus(translation);\n      this.drawingToAttachment.multiplyPoint3d(viewOrg, viewOrg);\n      translation.plus(viewOrg, viewOrg);\n      viewOrg.z = 0;\n      const viewOrgToAttachment = worldToAttachment.minus(viewOrg);\n      translation.plus(viewOrgToAttachment, translation);\n      this.drawingToAttachment.origin.setFrom(translation);\n\n      this.expirationTime = BeDuration.fromSeconds(15);\n\n      // The renderer needs the unclipped range of the attachment to produce polys to be rendered as clip mask...\n      // (Containment tests can also be more efficiently performed if boundary range is specified)\n      const clipTf = location.inverse();\n      if (clipTf !== undefined) {\n        const clip = attachment.getOrCreateClip(clipTf);\n        this.clipVolume = IModelApp.renderSystem.createClipVolume(clip);\n        if (undefined !== this.clipVolume)\n          clipTf.multiplyRange(attachRange, this.clipVolume.clipVector.boundingRange);\n      }\n\n      const sheetToDrawing = this.drawingToAttachment.inverse();\n      if (sheetToDrawing !== undefined) {\n        const graphicsClip = attachment.getOrCreateClip(sheetToDrawing);\n        sheetToDrawing.multiplyRange(attachRange, graphicsClip.boundingRange);\n        this.graphicsClip = IModelApp.renderSystem.createClipVolume(graphicsClip);\n      }\n\n      this._rootTile = new Tile2d(this, attachment.placement.bbox);\n    }\n\n    /** Create a Tree2d tile tree for a 2d attachment. Returns a Tree2d if the model tile tree is ready. Otherwise, returns the status of the tiles. */\n    public static create(attachment: Attachment2d): State {\n      const view = attachment.view as ViewState2d;\n      const viewedModel = view.getViewedModel();\n      if (!viewedModel)\n        return State.Empty;\n\n      switch (viewedModel.loadTree(true)) {\n        case TileTree.LoadStatus.Loaded:\n          assert(undefined !== viewedModel.tileTree);\n          attachment.tree = new Tree2d(viewedModel.iModel, attachment, view, viewedModel.tileTree!);\n          return State.Ready;\n        case TileTree.LoadStatus.Loading:\n          return State.Loading;\n        default:\n          return State.Empty;\n      }\n    }\n  }\n\n  /** @internal */\n  class TileColorSequence {\n    private _index: number = 0;\n    private readonly _colors: number[] = [\n      0xff0000,\n      0x00ff00,\n      0x0000ff,\n      0x7fff00,\n      0x7f00ff,\n      0x007fff,\n      0xff7f00,\n      0xff007f,\n      0x00ff7f,\n    ];\n\n    public get next(): ColorDef {\n      if (this._index >= this._colors.length)\n        this._index = 0;\n\n      const color = new ColorDef(this._colors[this._index]);\n      color.setAlpha(0x7f);\n      this._index++;\n      return color;\n    }\n  }\n\n  const tileColorSequence = new TileColorSequence();\n\n  /** @internal */\n  export class Tree3d extends Tree {\n    public readonly tileColor: ColorDef;\n    public readonly biasDistance: number; // distance in z to position tile in parent viewport's z-buffer (should be obtained by calling DepthFromDisplayPriority)\n    public readonly viewport: AttachmentViewport;\n    public readonly sheetView: SheetViewState;\n    public readonly attachment: Attachment3d;\n    public readonly featureTable: PackedFeatureTable;\n\n    private constructor(sheetView: SheetViewState, attachment: Attachment3d, sceneContext: SceneContext, viewport: AttachmentViewport, view: ViewState3d) {\n      super(new TileLoader3d(), view.iModel, Id64.invalid);\n\n      this.tileColor = tileColorSequence.next;\n      const featureTable = new FeatureTable(1);\n      featureTable.insert(new Feature(attachment.id));\n      this.featureTable = PackedFeatureTable.pack(featureTable);\n\n      this.viewport = viewport;\n      this.sheetView = sheetView;\n      this.attachment = attachment;\n\n      let scale: Point2d;\n\n      // We use square tiles.. if the view's aspect ratio isn't square, expand the short side in tile NPC space. We'll clip out the extra area below.\n      const aspect = view.getAspectRatio();\n      if (aspect < 1)\n        scale = Point2d.create(1 / aspect, 1);\n      else\n        scale = Point2d.create(1, aspect);\n\n      // now expand the frustum in one direction so that the view is square (so we can use square tiles)\n      const dim = QUERY_SHEET_TILE_PIXELS;\n      this.viewport.setRect(new ViewRect(0, 0, dim, dim));\n      this.viewport.setupFromView();\n\n      const frust = this.viewport.getFrustum(CoordSystem.Npc).transformBy(Transform.createOriginAndMatrix(Point3d.create(), Matrix3d.createScale(scale.x, scale.y, 1)));\n      this.viewport.npcToWorldArray(frust.points);\n      this.viewport.setupViewFromFrustum(frust);\n\n      const style = view.displayStyle;\n\n      // Override the background color. This is to match v8, but there should probably be an option in the \"Details\" about whether to do this or not.\n      const bgColor = sheetView.displayStyle.backgroundColor.clone();\n      // Set fully-transparent so that we discard background pixels (probably no point to the above line any more...)\n      bgColor.setAlpha(0);\n      style.backgroundColor.setFrom(bgColor);\n\n      // turn off skybox and groundplane\n      if (view.isSpatialView()) {\n        const spatial = view as SpatialViewState;\n        const env = spatial.getDisplayStyle3d().environment;\n        env.ground.display = false;\n        env.sky.display = false;\n      }\n\n      const range = attachment.placement.calculateRange();\n      this.biasDistance = RenderTarget.depthFromDisplayPriority(attachment.displayPriority);\n\n      range.getNpcToWorldRangeTransform(this.viewport.toParent);\n      this.viewport.toParent.matrix.scaleColumns(scale.x, scale.y, 1, this.viewport.toParent.matrix);\n\n      const fromParent = this.viewport.toParent.inverse();\n      if (fromParent !== undefined) {\n        const graphicsClip = attachment.getOrCreateClip(fromParent);\n        this.graphicsClip = IModelApp.renderSystem.createClipVolume(graphicsClip);\n      }\n\n      this._rootTile = Tile3d.create(this, undefined, Tile3dPlacement.Root);\n      (this._rootTile as Tile3d).createPolyfaces(sceneContext);    // graphics clip must be set before creating polys (the polys that represent the tile)\n\n      this.location.setFrom(this.viewport.toParent.clone());\n      this.expirationTime = BeDuration.fromSeconds(15);\n    }\n\n    public static create(sheetView: SheetViewState, attachment: Attachment3d, sceneContext: SceneContext): Tree3d {\n      const view = attachment.view as ViewState3d;\n      const viewport = AttachmentViewport.create(view) as AttachmentViewport;\n      return new Tree3d(sheetView, attachment, sceneContext, viewport, view);\n    }\n\n    /** Get the load state from the owner attachment's array at this tile's depth. */\n    public getState(depth: number): State { return this.attachment.getState(depth); }\n    /** Set the load state of the owner attachment's array at this tile's depth. */\n    public setState(depth: number, state: State) { this.attachment.setState(depth, state); }\n\n    /** Get the range for the root tile of this tile tree. */\n    public getRootRange(result?: Range3d): Range3d {\n      const tileSize = 1;\n      const east = 0;\n      const west = east + tileSize;\n      const north = 0;\n      const south = north + tileSize;\n\n      const corners: Point3d[] = [\n        Point3d.create(east, north, this.biasDistance),\n        Point3d.create(west, north, this.biasDistance),\n        Point3d.create(east, south, this.biasDistance),\n        Point3d.create(west, south, this.biasDistance),\n      ];\n\n      return Range3d.createArray(corners, result);\n    }\n  }\n\n  /** @internal */\n  export abstract class Attachment {\n    /** DEBUG ONLY - The color of the attachment bounding box if drawn. */\n    public static readonly DEBUG_BOUNDING_BOX_COLOR: ColorDef = ColorDef.red;\n    // ---------------------------------------------------\n    public id: Id64String;\n    public readonly view: ViewState;\n    public scale: number;\n    public placement: Placement2d;\n    public clip: ClipVector;\n    public displayPriority: number;\n    protected _tree?: Tree;\n\n    protected constructor(props: ViewAttachmentProps, view: ViewState) {\n      this.id = Id64.fromJSON(props.id);\n      this.view = view;\n      this.displayPriority = 0;\n      let scale: number | undefined;\n      let placement: Placement2d | undefined;\n      const jsonProps = props.jsonProperties;\n\n      if (props.placement)\n        placement = Placement2d.fromJSON(props.placement);\n\n      if (jsonProps !== undefined) {\n        scale = jsonProps.scale !== undefined ? JsonUtils.asDouble(jsonProps.scale) : undefined;\n        this.clip = jsonProps.clip !== undefined ? ClipVector.fromJSON(jsonProps.clip) : ClipVector.createEmpty();\n        this.displayPriority = JsonUtils.asInt(props.jsonProperties.displayPriority);\n      } else {\n        this.clip = ClipVector.createEmpty();\n      }\n      this.clip.parseClipPlanes();\n\n      // Compute placement from scale, or scale from placement if necessary\n      if (scale === undefined && placement === undefined) {\n        scale = 1;\n        placement = Attachment.computePlacement(view, Point2d.create(), scale);\n      } else if (scale === undefined) {\n        scale = Attachment.computeScale(view, placement!);\n      } else if (placement === undefined) {\n        placement = Attachment.computePlacement(view, Point2d.create(), scale);\n      }\n\n      this.scale = scale;\n      this.placement = placement!;\n    }\n\n    /** Returns true if this attachment is a 2d view attachment. */\n    public abstract get is2d(): boolean;\n    /** Returns true if this attachment has a defined tile tree and is ready to be drawn. */\n    public get isReady(): boolean { return this._tree !== undefined; }\n    /** Returns the tile tree corresponding to this attachment, which may be 2d or 3d. Returns undefined if the tree has not been loaded. */\n    public get tree(): Tree | undefined { return this._tree; }\n    /** Sets the reference to the tile tree corresponding to this attachment view's model. */\n    public set tree(tree: Tree | undefined) { this._tree = tree; }\n\n    /** Given a view and placement, compute a scale for an attachment. */\n    private static computeScale(view: ViewState, placement: Placement2d): number {\n      return view.getExtents().x / placement.bbox.xLength();\n    }\n\n    /** Given a view and an origin point, compute a placement for an attachment. */\n    private static computePlacement(view: ViewState, origin: Point2d, scale: number): Placement2d {\n      const viewExtents = view.getExtents();\n      const box = new Range2d();\n      box.low.setZero();\n      box.high.x = viewExtents.x / scale;\n      box.high.y = viewExtents.y / scale;\n\n      return new Placement2d(origin, Angle.createDegrees(0), box);\n    }\n\n    /** Load the tile tree for this attachment. Returns an Attachment.State to indicate success (Ready, Loading), or failure (Empty, NotLoaded, etc). */\n    public abstract load(sheetView: SheetViewState, sceneContext: SceneContext): State;\n\n    /** Remove the clip vector from this view attachment. */\n    public clearClipping() { this.clip.clear(); }\n\n    /** Create a boundary clip vector around this attachment. */\n    private createBoundaryClip(): ClipVector {\n      const range = this.placement.calculateRange();\n      const box: Point3d[] = [\n        Point3d.create(range.low.x, range.low.y),\n        Point3d.create(range.high.x, range.low.y),\n        Point3d.create(range.high.x, range.high.y),\n        Point3d.create(range.low.x, range.high.y),\n        Point3d.create(range.low.x, range.low.y),\n      ];\n      const clip = ClipVector.createEmpty();\n      clip.appendShape(box);\n      return clip;\n    }\n\n    /** Returns a clone of the current clipping if it is defined and not null. Otherwise, attempt to create a new stored boundary clipping. */\n    public getOrCreateClip(transform?: Transform): ClipVector {\n      if (!this.clip.isValid)\n        this.clip = this.createBoundaryClip();\n\n      const clipReturn = this.clip.clone();\n      if (transform !== undefined)\n        clipReturn.transformInPlace(transform);\n      return clipReturn;\n    }\n\n    /** DEBUG ONLY - Draw a border around this attachment using its placement. */\n    public debugDrawBorder(context: SceneContext) {\n      const origin = this.placement.origin;\n      const bbox = this.placement.bbox;\n      const rect: Point2d[] = [\n        Point2d.create(origin.x, origin.y),\n        Point2d.create(origin.x + bbox.high.x, origin.y),\n        Point2d.create(origin.x + bbox.high.x, origin.y + bbox.high.y),\n        Point2d.create(origin.x, origin.y + bbox.high.y),\n        Point2d.create(origin.x, origin.y)];\n\n      const builder = context.createSceneGraphicBuilder();\n      builder.setSymbology(Attachment.DEBUG_BOUNDING_BOX_COLOR, Attachment.DEBUG_BOUNDING_BOX_COLOR, 2);\n      builder.addLineString2d(rect, 0);\n      const attachmentBorder = builder.finish();\n      context.outputGraphic(attachmentBorder);\n    }\n  }\n\n  /** @internal */\n  export class Attachment2d extends Attachment {\n    public constructor(props: ViewAttachmentProps, view: ViewState2d) {\n      super(props, view);\n    }\n\n    public get is2d(): boolean { return true; }\n    public load(_sheetView: SheetViewState, _sceneContext: SceneContext): State {\n      if (this.tree === undefined)\n        return Tree2d.create(this);\n      else\n        return State.Ready;\n    }\n  }\n\n  /** @internal */\n  export class Attachment3d extends Attachment {\n    private _states: State[];  // per level of the tree\n\n    public constructor(props: ViewAttachmentProps, view: ViewState3d) {\n      super(props, view);\n      this._states = [];\n    }\n\n    public get is2d(): boolean { return false; }\n\n    /** Returns the load state of this attachment's tile tree at a given depth. */\n    public getState(depth: number): State { return depth < this._states.length ? this._states[depth] : State.NotLoaded; }\n\n    /** Sets the state of this attachment's tile tree at a given depth. */\n    public setState(depth: number, state: State) {\n      while (this._states.length < depth + 1)\n        this._states.push(State.NotLoaded);  // Fill any gaps\n      this._states[depth] = state;\n    }\n\n    public load(sheetView: SheetViewState, sceneContext: SceneContext): State {\n      if (this._tree === undefined)\n        this._tree = Tree3d.create(sheetView, this, sceneContext);\n      return State.Ready;\n    }\n  }\n\n  /** @internal */\n  export class AttachmentList {\n    public readonly list: Attachment[] = [];\n    private _allReady: boolean = true;\n\n    public constructor() { }\n\n    /** The number of attachments in this list. */\n    public get length(): number { return this.list.length; }\n\n    /** Returns true if all attachments in this list have defined tile trees. */\n    public get allReady(): boolean { return this._allReady; }\n\n    /** Clear this list of attachments. */\n    public clear() {\n      this.list.length = 0;\n      this._allReady = true;\n    }\n\n    /** Add an attachment to this list of attachments. */\n    public add(attachment: Attachment) {\n      this._allReady = this._allReady && attachment.isReady;\n      this.list.push(attachment);\n    }\n\n    /** Drop an attachment from this list by reference. */\n    public drop(attachment: Attachment) {\n      const idx = this.list.indexOf(attachment);\n      if (idx !== -1)\n        this.list.splice(idx, 1);\n      this.updateAllReady();\n    }\n\n    /** Update the flag on this attachments list recording whether or not all attachments are ready to be drawn. */\n    private updateAllReady() {\n      this._allReady = true;\n      for (const attachment of this.list) {\n        if (!attachment.isReady) {\n          this._allReady = false;\n          break;\n        }\n      }\n    }\n\n    /**\n     * Load the tile tree for the attachment at the given index. Returns the resulting load status. If the load reported\n     * anything other than \"Ready\" or \"Loading\", the load failed and the attachment has been removed from the list.\n     */\n    public load(idx: number, sheetView: SheetViewState, sceneContext: SceneContext): State {\n      assert(idx < this.length);\n\n      const attachment = this.list[idx];\n\n      // Load the attachment. On failure, remove it from the array\n      const loadStatus = attachment.load(sheetView, sceneContext);\n      if (loadStatus !== State.Ready && loadStatus !== State.Loading)\n        this.list.splice(idx, 1);\n\n      this.updateAllReady();\n      return loadStatus;\n    }\n  }\n}\n\n/** A view of a [SheetModel](@backend).\n * @public\n */\nexport class SheetViewState extends ViewState2d {\n  /** @internal */\n  public static get className() { return \"SheetViewDefinition\"; }\n  public static createFromProps(viewStateData: ViewStateProps, iModel: IModelConnection): ViewState | undefined {\n    const cat = new CategorySelectorState(viewStateData.categorySelectorProps, iModel);\n    const displayStyleState = new DisplayStyle2dState(viewStateData.displayStyleProps, iModel);\n    // use \"new this\" so subclasses are correct\n    return new this(viewStateData.viewDefinitionProps as ViewDefinition2dProps, iModel, cat, displayStyleState, viewStateData.sheetProps!, viewStateData.sheetAttachments!);\n  }\n\n  public constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState, sheetProps: SheetProps, attachments: Id64Array) {\n    super(props, iModel, categories, displayStyle);\n    if (categories instanceof SheetViewState) {\n      // we are coming from clone...\n      this.sheetSize = categories.sheetSize.clone();\n      this._attachmentIds = categories._attachmentIds;\n      this._attachments = categories._attachments;\n    } else {\n      this.sheetSize = Point2d.create(sheetProps.width, sheetProps.height);\n      this._attachmentIds = [];\n      attachments.forEach((idProp) => this._attachmentIds.push(idProp));\n      this._attachments = new Attachments.AttachmentList();\n    }\n  }\n\n  /** The width and height of the sheet in world coordinates. */\n  public readonly sheetSize: Point2d;\n  private _attachmentIds: Id64Array;\n  private _attachments: Attachments.AttachmentList;\n  private _all3dAttachmentTilesLoaded: boolean = true;\n\n  /** @internal */\n  public get defaultExtentLimits() { return { min: Constant.oneMillimeter, max: this.sheetSize.magnitude() * 10 }; }\n\n  /** Manually mark this SheetViewState as having to re-create its scene due to still-loading tiles for 3d attachments. This is called directly from the attachment tiles.\n   * @internal\n   */\n  public markAttachment3dSceneIncomplete() {\n    // NB: 2d attachments will draw to completion once they have a tile tree... but 3d attachments create new tiles for each\n    // depth, and therefore report directly to the ViewState whether or not new tiles are being loaded\n    this._all3dAttachmentTilesLoaded = false;\n  }\n\n  /** Load the size and attachment for this sheet, as well as any other 2d view state characteristics.\n   * @internal\n   */\n  public async load(): Promise<void> {\n    await super.load();\n\n    // Set the size of the sheet\n    const model = this.getViewedModel();\n    if (model === undefined)\n      return;\n\n    this._attachments.clear();\n\n    // Query all of the attachment properties using their ids\n    const attachmentPropList = await this.iModel.elements.getProps(this._attachmentIds) as ViewAttachmentProps[];\n\n    // For each ViewAttachmentProps, load the view that the attachment references. Once the view is loaded, officially construct the attachment & add it to the array.\n    for (const attachmentProps of attachmentPropList) {\n      this.iModel.views.load(attachmentProps.view.id).then((view: ViewState) => { // tslint:disable-line:no-floating-promises\n        if (view.is3d())\n          this._attachments.add(new Attachments.Attachment3d(attachmentProps, view as ViewState3d));\n        else\n          this._attachments.add(new Attachments.Attachment2d(attachmentProps, view as ViewState2d));\n      });\n    }\n  }\n\n  /** If any attachments have not yet been loaded or are waiting on tiles, invalidate the scene.\n   * @internal\n   */\n  public onRenderFrame(_viewport: Viewport) {\n    if (!this._attachments.allReady || !this._all3dAttachmentTilesLoaded)\n      _viewport.sync.invalidateScene();\n  }\n\n  /** Adds the Sheet view to the scene, along with any of this sheet's attachments.\n   * @internal\n   */\n  public createScene(context: SceneContext) {\n    // This will be set to false by the end of the function if any 3d attachments are waiting on tiles...\n    this._all3dAttachmentTilesLoaded = true;\n\n    super.createScene(context);\n\n    if (!this._attachments.allReady) {\n      let i = 0;\n      while (i < this._attachments.length) {\n        const loadStatus = this._attachments.load(i, this, context);\n\n        // If load fails, attachment gets dropped from the list\n        if (loadStatus === Attachments.State.Ready || loadStatus === Attachments.State.Loading)\n          i++;\n      }\n    }\n\n    // Draw all attachments that have a status of ready\n    for (const attachment of this._attachments.list)\n      if (attachment.isReady)\n        attachment.tree!.drawScene(context);\n  }\n\n  /** Create a sheet border decoration graphic. */\n  private createBorder(width: number, height: number, context: DecorateContext): RenderGraphic {\n    const border = SheetBorder.create(width, height, context);\n    const builder = context.createGraphicBuilder(GraphicType.ViewBackground);\n    border.addToBuilder(builder);\n    return builder.finish();\n  }\n\n  /** @internal */\n  public decorate(context: DecorateContext): void {\n    super.decorate(context);\n    if (this.sheetSize !== undefined) {\n      const border = this.createBorder(this.sheetSize.x, this.sheetSize.y, context);\n      context.setViewBackground(border);\n    }\n  }\n\n  /** @internal */\n  public computeFitRange(): Range3d {\n    const size = this.sheetSize;\n    if (0 >= size.x || 0 >= size.y)\n      return super.computeFitRange();\n    return new Range3d(0, 0, -1, size.x, size.y, 1);\n  }\n}\n","import { Cartographic } from \"@bentley/imodeljs-common\";\r\nimport { Angle, Vector3d } from \"@bentley/geometry-core\";\r\n\r\n/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\n// Code below loosely translated from  https://www.esrl.noaa.gov/gmd/grad/solcalc/\r\nfunction calcTimeJulianCent(jd: number) {\r\n  const T = (jd - 2451545.0) / 36525.0;\r\n  return T;\r\n}\r\n\r\nfunction radToDeg(angleRad: number) {\r\n  return (180.0 * angleRad / Math.PI);\r\n}\r\n\r\nfunction degToRad(angleDeg: number) {\r\n  return (Math.PI * angleDeg / 180.0);\r\n}\r\n\r\nfunction calcGeomMeanLongSun(t: number) {\r\n  let L0 = 280.46646 + t * (36000.76983 + t * (0.0003032));\r\n  while (L0 > 360.0) {\r\n    L0 -= 360.0;\r\n  }\r\n  while (L0 < 0.0) {\r\n    L0 += 360.0;\r\n  }\r\n  return L0;\t\t// in degrees\r\n}\r\n\r\nfunction calcGeomMeanAnomalySun(t: number) {\r\n  const M = 357.52911 + t * (35999.05029 - 0.0001537 * t);\r\n  return M;\t\t// in degrees\r\n}\r\n\r\nfunction calcEccentricityEarthOrbit(t: number) {\r\n  const e = 0.016708634 - t * (0.000042037 + 0.0000001267 * t);\r\n  return e;\t\t// unitless\r\n}\r\n\r\nfunction calcSunEqOfCenter(t: number) {\r\n  const m = calcGeomMeanAnomalySun(t);\r\n  const mrad = degToRad(m);\r\n  const sinm = Math.sin(mrad);\r\n  const sin2m = Math.sin(mrad + mrad);\r\n  const sin3m = Math.sin(mrad + mrad + mrad);\r\n  const C = sinm * (1.914602 - t * (0.004817 + 0.000014 * t)) + sin2m * (0.019993 - 0.000101 * t) + sin3m * 0.000289;\r\n  return C;\t\t// in degrees\r\n}\r\n\r\nfunction calcSunTrueLong(t: number) {\r\n  const l0 = calcGeomMeanLongSun(t);\r\n  const c = calcSunEqOfCenter(t);\r\n  const O = l0 + c;\r\n  return O;\t\t// in degrees\r\n}\r\n\r\nfunction calcSunApparentLong(t: number) {\r\n  const o = calcSunTrueLong(t);\r\n  const omega = 125.04 - 1934.136 * t;\r\n  const lambda = o - 0.00569 - 0.00478 * Math.sin(degToRad(omega));\r\n  return lambda;\t\t// in degrees\r\n}\r\n\r\nfunction calcMeanObliquityOfEcliptic(t: number) {\r\n  const seconds = 21.448 - t * (46.8150 + t * (0.00059 - t * (0.001813)));\r\n  const e0 = 23.0 + (26.0 + (seconds / 60.0)) / 60.0;\r\n  return e0;\t\t// in degrees\r\n}\r\n\r\nfunction calcObliquityCorrection(t: number) {\r\n  const e0 = calcMeanObliquityOfEcliptic(t);\r\n  const omega = 125.04 - 1934.136 * t;\r\n  const e = e0 + 0.00256 * Math.cos(degToRad(omega));\r\n  return e;\t\t// in degrees\r\n}\r\n\r\nfunction calcSunDeclination(t: number) {\r\n  const e = calcObliquityCorrection(t);\r\n  const lambda = calcSunApparentLong(t);\r\n\r\n  const sint = Math.sin(degToRad(e)) * Math.sin(degToRad(lambda));\r\n  const theta = radToDeg(Math.asin(sint));\r\n  return theta;\t\t// in degrees\r\n}\r\n\r\nfunction calcEquationOfTime(t: number) {\r\n  const epsilon = calcObliquityCorrection(t);\r\n  const l0 = calcGeomMeanLongSun(t);\r\n  const e = calcEccentricityEarthOrbit(t);\r\n  const m = calcGeomMeanAnomalySun(t);\r\n\r\n  let y = Math.tan(degToRad(epsilon) / 2.0);\r\n  y *= y;\r\n\r\n  const sin2l0 = Math.sin(2.0 * degToRad(l0));\r\n  const sinm = Math.sin(degToRad(m));\r\n  const cos2l0 = Math.cos(2.0 * degToRad(l0));\r\n  const sin4l0 = Math.sin(4.0 * degToRad(l0));\r\n  const sin2m = Math.sin(2.0 * degToRad(m));\r\n\r\n  const eTime = y * sin2l0 - 2.0 * e * sinm + 4.0 * e * y * sinm * cos2l0 - 0.5 * y * y * sin4l0 - 1.25 * e * e * sin2m;\r\n  return radToDeg(eTime) * 4.0;\t// in minutes of time\r\n}\r\n\r\nfunction calcAzEl(T: number, localTime: number, latitude: number, longitude: number, zone: number): { azimuth: number, elevation: number } {\r\n  const eqTime = calcEquationOfTime(T);\r\n  const theta = calcSunDeclination(T);\r\n  const solarTimeFix = eqTime + 4.0 * longitude - 60.0 * zone;\r\n  let trueSolarTime = localTime + solarTimeFix;\r\n  while (trueSolarTime > 1440)\r\n    trueSolarTime -= 1440;\r\n\r\n  let hourAngle = trueSolarTime / 4.0 - 180.0;\r\n  if (hourAngle < -180) {\r\n    hourAngle += 360.0;\r\n  }\r\n  const haRad = degToRad(hourAngle);\r\n  let csz = Math.sin(degToRad(latitude)) * Math.sin(degToRad(theta)) + Math.cos(degToRad(latitude)) * Math.cos(degToRad(theta)) * Math.cos(haRad);\r\n  if (csz > 1.0) {\r\n    csz = 1.0;\r\n  } else if (csz < -1.0) {\r\n    csz = -1.0;\r\n  }\r\n  const zenith = radToDeg(Math.acos(csz));\r\n  const azDenom = (Math.cos(degToRad(latitude)) * Math.sin(degToRad(zenith)));\r\n  let azimuth;\r\n  if (Math.abs(azDenom) > 0.001) {\r\n    let azRad = ((Math.sin(degToRad(latitude)) * Math.cos(degToRad(zenith))) - Math.sin(degToRad(theta))) / azDenom;\r\n    if (Math.abs(azRad) > 1.0) {\r\n      if (azRad < 0) {\r\n        azRad = -1.0;\r\n      } else {\r\n        azRad = 1.0;\r\n      }\r\n    }\r\n    azimuth = 180.0 - radToDeg(Math.acos(azRad));\r\n    if (hourAngle > 0.0) {\r\n      azimuth = -azimuth;\r\n    }\r\n  } else {\r\n    if (latitude > 0.0) {\r\n      azimuth = 180.0;\r\n    } else {\r\n      azimuth = 0.0;\r\n    }\r\n  }\r\n  if (azimuth < 0.0) {\r\n    azimuth += 360.0;\r\n  }\r\n  return { azimuth, elevation: 90 - zenith };\r\n}\r\n\r\nfunction calculateJulianDay(date: Date) {\r\n  return Math.floor(date.getTime() / 86400000) + 2440587.5;    // https://stackoverflow.com/questions/11759992/calculating-jdayjulian-day-in-javascript\r\n}\r\n/** @beta\r\n * calculate solar angles (in radians) based at a given date/time and location.\r\n */\r\nexport function calculateSolarAngles(date: Date, location: Cartographic): { azimuth: number, elevation: number } {\r\n  const jDay = calculateJulianDay(date);\r\n  const latitude = Angle.radiansToDegrees(location.latitude);\r\n  const longitude = Angle.radiansToDegrees(location.longitude);\r\n  const utcMinutes = date.getUTCHours() * 60 + date.getUTCMinutes() + date.getUTCSeconds() / 60;\r\n  const zone = Math.floor(.5 + longitude / 15.0); // date.getTimeZoneOffset mixes in DST.\r\n  const localMinutes = utcMinutes + zone * 60;\r\n  const jTotal = jDay + utcMinutes / 1440.0;\r\n  const T = calcTimeJulianCent(jTotal);\r\n  return calcAzEl(T, localMinutes, latitude, longitude, zone);\r\n}\r\n\r\n/** @beta\r\n * calculate solar direction based at a given date/time and location.\r\n */\r\nexport function calculateSolarDirection(date: Date, location: Cartographic): Vector3d {\r\n  const azimuthElevation = calculateSolarAngles(date, location);\r\n  const azimuth = Angle.degreesToRadians(azimuthElevation.azimuth);\r\n  const elevation = Angle.degreesToRadians(azimuthElevation.elevation);\r\n  const cosElevation = Math.cos(elevation);\r\n  const sinElevation = Math.sin(elevation);\r\n\r\n  return Vector3d.create(-Math.sin(azimuth) * cosElevation, -Math.cos(azimuth) * cosElevation, -sinElevation);\r\n}\r\n\r\nfunction dateFromUtcMinutes(date: Date, utcMinutes: number) {\r\n  const utcHours = Math.floor(utcMinutes / 60.0);\r\n  const output = new Date(date);\r\n  output.setUTCHours(utcHours);\r\n  output.setUTCMinutes(Math.floor(.5 + utcMinutes - 60.0 * utcHours));\r\n  output.setUTCSeconds(0);\r\n  return output;\r\n}\r\nfunction calcSunriseUtcMinutes(rise: boolean, lat: number, longitude: number, jDay: number) {\r\n  const t = calcTimeJulianCent(jDay);\r\n  const eqTime = calcEquationOfTime(t);\r\n  const solarDec = calcSunDeclination(t);\r\n  const latRad = degToRad(lat);\r\n  const sdRad = degToRad(solarDec);\r\n  const hAarg = (Math.cos(degToRad(90.833)) / (Math.cos(latRad) * Math.cos(sdRad)) - Math.tan(latRad) * Math.tan(sdRad));\r\n  const hourAngle = Math.acos(hAarg);\r\n  const delta = longitude + radToDeg(rise ? hourAngle : - hourAngle);\r\n  return 720 - (4.0 * delta) - eqTime;\t// in UTC minutes\r\n}\r\n/** @beta\r\n * calculate solar sunrise or sunset for a given day and location.\r\n */\r\nexport function calculateSunriseOrSunset(date: Date, location: Cartographic, sunrise: boolean): Date {\r\n  const jDay = calculateJulianDay(date);\r\n  const longitude = Angle.radiansToDegrees(location.longitude);\r\n  const latitude = Angle.radiansToDegrees(location.latitude);\r\n  const utcMinutes = calcSunriseUtcMinutes(sunrise, latitude, longitude, jDay);\r\n  return sunrise ? dateFromUtcMinutes(date, utcMinutes) : dateFromUtcMinutes(date, calcSunriseUtcMinutes(sunrise, latitude, longitude, jDay + utcMinutes / 1440));\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module SpatialClassification */\nimport { Id64String, Id64Arg, Id64, assert } from \"@bentley/bentleyjs-core\";\nimport { GeometricModelState, TileTreeModelState } from \"./ModelState\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { SceneContext } from \"./ViewContext\";\nimport { BatchType, SpatialClassificationProps } from \"@bentley/imodeljs-common\";\nimport { RenderClassifierModel, ClassifierType } from \"./render/System\";\nimport { IModelApp } from \"./IModelApp\";\n\n/** Geometry may be classified by its spatial location.  This is typically used to classify reality models.\n * A volume classifier classifies on all space within a closed mesh.  A planar classifier classifies within a\n * planar region swept perpendicular to its plane.\n * @beta\n */\nexport namespace SpatialClassification {\n\n  /** @internal */\n  async function usePlanar(model: GeometricModelState): Promise<boolean> {\n    const range = await model.queryModelRange();\n    const depthMax = 1.0E-2;\n    return range.high.z - range.low.z < depthMax;\n  }\n\n  /** @internal */\n  export async function createClassifier(id: Id64String, iModel: IModelConnection): Promise<RenderClassifierModel | undefined> {\n    const classifierModel = iModel.models.getLoaded(id) as GeometricModelState;\n    if (undefined === classifierModel) {\n      assert(false, \"classifier not loaded\");\n      return undefined;\n    }\n    return new RenderClassifierModel(await usePlanar(classifierModel) ? ClassifierType.Planar : ClassifierType.Volume);\n  }\n\n  /** @internal */\n  export function getClassifierProps(model: TileTreeModelState): SpatialClassificationProps.Properties | undefined {\n    if (model.jsonProperties.classifiers !== undefined) {\n      for (const classifier of model.jsonProperties.classifiers) {\n        if (classifier.isActive)\n          return new SpatialClassificationProps.Properties(classifier);\n\n      }\n    }\n    return undefined;\n  }\n\n  /** @internal */\n  export async function loadModelClassifiers(modelIdArg: Id64Arg, iModel: IModelConnection): Promise<void> {\n    const classifiersToLoad = new Set<string>();\n    Id64.forEach(modelIdArg, (modelId) => {\n      const model = iModel.models.getLoaded(modelId) as GeometricModelState;\n      if (undefined !== model) {\n        const props = getClassifierProps(model);\n        if (undefined !== props)\n          classifiersToLoad.add(props.modelId);\n      }\n    });\n\n    return loadClassifiers(classifiersToLoad, iModel);\n  }\n\n  /** @internal */\n  export async function loadClassifiers(classifierIdArg: Id64Arg, iModel: IModelConnection): Promise<void> {\n    const classifierIds = Id64.toIdSet(classifierIdArg);\n    await iModel.models.load(classifierIds).then(async (_) => {\n      for (const classifierId of classifierIds)\n        await SpatialClassification.createClassifier(classifierId, iModel).then((classifier) => { if (classifier) IModelApp.renderSystem.addSpatialClassificationModel(classifierId, classifier, iModel); });\n    });\n  }\n\n  /** @internal */\n  export function addModelClassifierToScene(classifiedModel: TileTreeModelState, context: SceneContext): void {\n    const classifierProps = getClassifierProps(classifiedModel);\n    if (undefined !== classifierProps) {\n      const classifier = IModelApp.renderSystem.getSpatialClassificationModel(classifierProps.modelId, classifiedModel.iModel);\n      if (undefined !== classifier) {\n        const classifierModel = classifiedModel.iModel.models.getLoaded(classifierProps.modelId) as GeometricModelState;\n        if (undefined !== classifierModel) {\n          const isPlanar = ClassifierType.Planar === classifier.type;\n          const batchType = isPlanar ? BatchType.PlanarClassifier : BatchType.VolumeClassifier;\n\n          classifierModel.loadClassifierTileTree(batchType, classifierProps.expand);\n          if (undefined === classifierModel.classifierTileTree)\n            return;\n\n          context.modelClassifiers.set(classifiedModel.treeModelId, classifierProps.modelId);\n          if (isPlanar) {\n            if (!context.getPlanarClassifier(classifierProps.modelId))\n              context.setPlanarClassifier(classifierProps.modelId, IModelApp.renderSystem.createPlanarClassifier(classifierProps, classifierModel.classifierTileTree, classifiedModel, context)!);\n          } else {\n            classifierModel.classifierTileTree.drawScene(context);\n          }\n        }\n      }\n    }\n  }\n\n  /** Get active spatial classifier\n   * @alpha\n   */\n  export function getActiveSpatialClassifier(model: TileTreeModelState): number {\n    if (model.jsonProperties !== undefined && model.jsonProperties.classifiers !== undefined) {\n      for (let index = 0; index < model.jsonProperties.classifiers.length; index++) {\n        if (model.jsonProperties.classifiers[index].isActive)\n          return index;\n      }\n    }\n    return -1;\n  }\n\n  /** Get spatial classifier at  index\n   * @alpha\n   */\n  export function getSpatialClassifier(model: TileTreeModelState, index: number): SpatialClassificationProps.Properties | undefined {\n    if (index < 0 || undefined === model.jsonProperties.classifiers || index >= model.jsonProperties.classifiers.length)\n      return undefined;\n\n    return new SpatialClassificationProps.Properties(model.jsonProperties.classifiers[index]);\n  }\n\n  /** Set the spatial classifier at index\n   * @alpha\n   */\n  export function setSpatialClassifier(model: TileTreeModelState, index: number, classifier: SpatialClassificationProps.Properties) {\n    if (index < 0 || undefined === model.jsonProperties.classifiers || index >= model.jsonProperties.classifiers.length)\n      return;\n\n    model.jsonProperties.classifiers[index] = classifier;\n  }\n\n  /** Set the active spatial classifier by index\n   * @alpha\n   */\n  export async function setActiveSpatialClassifier(model: TileTreeModelState, classifierIndex: number, active: boolean) {\n    const classifiers = model.jsonProperties.classifiers;\n    if (classifiers !== undefined)\n      for (let index = 0; index < classifiers.length; index++)\n        if (false !== (classifiers[index].isActive = (classifierIndex === index && active)))\n          await SpatialClassification.loadModelClassifiers(model.treeModelId, model.iModel);\n  }\n\n  /** Add a spatial classifier\n   * @alpha\n   */\n  export function addSpatialClassifier(model: TileTreeModelState, classifier: SpatialClassificationProps.PropertiesProps) {\n    if (undefined === model.jsonProperties.classifiers)\n      model.jsonProperties.classifiers = [];\n\n    model.jsonProperties.classifiers.push(classifier);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\n\nimport { Point2d, Point3d, XYAndZ } from \"@bentley/geometry-core\";\nimport { ImageSource } from \"@bentley/imodeljs-common\";\nimport { imageElementFromImageSource, imageElementFromUrl } from \"./ImageUtil\";\nimport { CanvasDecoration } from \"./render/System\";\nimport { DecorateContext } from \"./ViewContext\";\nimport { ScreenViewport } from \"./Viewport\";\n\n/** Sprites are small raster images that are drawn *on top* of Viewports by a ViewDecoration.\n * Their purpose is to draw the user's attention to something of importance.\n *\n * There are two classes in the Sprites subsystem: Sprite (a Sprite image) and SpriteLocation.\n * Sprite are the images that define the way a type of sprite looks and are generally\n * loaded one time and saved for the rest of a session. A SpriteLocation defines the current\n * position of a single Sprite in a Viewport.\n *\n * A SpriteLocation can be either active or inactive. It becomes active by specifying a location\n * (an x,y point) and a Sprite to draw at that point. A Sprite\n * can be used many times by many SpriteLocations and a single SpriteLocation can\n * change both position and which Sprite is shown at that position over time.\n * @public\n */\nexport class Sprite {\n  /** The image for this Sprite. If undefined, the Spite is not valid. */\n  public image?: HTMLImageElement;\n  /** The size of this Sprite. If not loaded, value is not meaningful. */\n  public readonly size = new Point2d();\n  /** Promise fulfilled when this sprite is loaded. */\n  public loadPromise: Promise<HTMLImageElement>;\n  /** The offset to the middle of this Sprite. If not loaded, value is not meaningful. */\n  public get offset(): Point2d { return new Point2d(Math.round(this.size.x) / 2, Math.round(this.size.y / 2)); }\n  /** Whether this sprite has be successfully loaded. */\n  public get isLoaded(): boolean { return undefined !== this.image; }\n\n  /** construct a Sprite from an ImageSource or a Url\n   * @param src The ImageSource holding an image to create the texture for this Sprite, or the url of the image\n   */\n  constructor(src: ImageSource | string) {\n    this.loadPromise = (typeof src === \"string\") ? imageElementFromUrl(src) : imageElementFromImageSource(src);\n    this.loadPromise.then((image) => { // tslint:disable-line:no-floating-promises\n      this.image = image;\n      this.size.set(image.naturalWidth, image.naturalHeight);\n    });\n  }\n}\n\n/** Icon sprites are loaded from .png files in the assets directory of imodeljs-native.\n * They are cached by name, and the cache is cleared when the ToolAdmin is shut down.\n * @public\n */\nexport class IconSprites {\n  private static readonly _sprites = new Map<string, Sprite>();\n\n  /** Look up an IconSprite by url. If not loaded, create and load it.\n   * @param spriteUrl The url of an image to load for this Sprite.\n   */\n  public static getSpriteFromUrl(spriteUrl: string): Sprite {\n    let sprite = this._sprites.get(spriteUrl);\n    if (!sprite) {\n      sprite = new Sprite(spriteUrl);\n      this._sprites.set(spriteUrl, sprite);\n    }\n    return sprite;\n  }\n\n  /** Empty the cache, disposing all existing Sprites. */\n  public static emptyAll() { this._sprites.clear(); }\n}\n\n/** A Sprite location. Sprites generally move around on the screen and this object holds the current location\n * and current Sprite within a ScreenViewport. SpriteLocations can be either inactive (not visible) or active.\n *\n * A SpriteLocation can also specify that a Sprite should be drawn partially transparent.\n * @public\n */\nexport class SpriteLocation implements CanvasDecoration {\n  private _viewport?: ScreenViewport;\n  private _sprite?: Sprite;\n  private _alpha?: number;\n  /** The current position of this sprite in view coordinates.\n   * @see [[CanvasDecoration.position]]\n   */\n  public readonly position = new Point3d();\n  public get isActive(): boolean { return this._viewport !== undefined; }\n\n  /** Activate this SpriteLocation to show a Sprite at a location in a single ScreenViewport.\n   * This call does not display the Sprite. Rather, subsequent calls to [[decorate]] from  will show the Sprite.\n   * This SpriteLocation remains active until [[deactivate]] is called.\n   * @param sprite The Sprite to draw at this SpriteLocation\n   * @param viewport The Viewport onto which the Sprite is drawn\n   * @param locationWorld The position, in world coordinates\n   * @param alpha Optional alpha for the Sprite. Must be a number between 0 (fully transparent) and 1 (fully opaque).\n   */\n  public activate(sprite: Sprite, viewport: ScreenViewport, locationWorld: XYAndZ, alpha?: number): void {\n    this._sprite = sprite;\n    this._alpha = alpha;\n    this._viewport = viewport;\n    viewport.worldToView(locationWorld, this.position);\n    sprite.loadPromise.then(() => { // tslint:disable-line:no-floating-promises\n      if (this._viewport === viewport) // was this deactivated while we were loading?\n        viewport.invalidateDecorations();\n    });\n  }\n\n  /** Turn this SpriteLocation off so it will no longer show. */\n  public deactivate() {\n    if (!this.isActive)\n      return;\n    this._viewport!.invalidateDecorations();\n    this._viewport = undefined;\n  }\n\n  /** Draw this sprite onto the supplied canvas.\n   * @see [[CanvasDecoration.drawDecoration]]\n   */\n  public drawDecoration(ctx: CanvasRenderingContext2D): void {\n    const sprite = this._sprite!;\n    if (undefined === sprite.image)\n      return;\n\n    if (undefined !== this._alpha)\n      ctx.globalAlpha = this._alpha;\n\n    ctx.drawImage(sprite.image, -sprite.offset.x, -sprite.offset.y);\n  }\n\n  /** If this SpriteLocation is active and the supplied DecorateContext is for its Viewport, add the Sprite to decorations. */\n  public decorate(context: DecorateContext) {\n    if (context.viewport === this._viewport)\n      context.addCanvasDecoration(this);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\nimport { Matrix3d } from \"@bentley/geometry-core\";\n\n/** Describes a set of commonly-used view rotations.\n * @public\n */\nexport enum StandardViewId {\n  /** Any rotation which does not match one of the standard rotations.\n   * Invalid as an argument to StandardView.getStandardRotation() - used as a return value only.\n   */\n  NotStandard = -1,\n  Top = 0,\n  Bottom = 1,\n  Left = 2,\n  Right = 3,\n  Front = 4,\n  Back = 5,\n  Iso = 6,\n  RightIso = 7,\n}\n\nlet standardViewMatrices: Matrix3d[] | undefined;\n\nfunction getMatrices(): Matrix3d[] {\n  if (undefined !== standardViewMatrices)\n    return standardViewMatrices;\n\n  standardViewMatrices = [];\n\n  standardViewMatrices[StandardViewId.Top] = Matrix3d.identity;\n  standardViewMatrices[StandardViewId.Bottom] = Matrix3d.createRowValues(1, 0, 0, 0, -1, 0, 0, 0, -1);\n  standardViewMatrices[StandardViewId.Left] = Matrix3d.createRowValues(0, -1, 0, 0, 0, 1, -1, 0, 0);\n  standardViewMatrices[StandardViewId.Right] = Matrix3d.createRowValues(0, 1, 0, 0, 0, 1, 1, 0, 0);\n  standardViewMatrices[StandardViewId.Front] = Matrix3d.createRowValues(1, 0, 0, 0, 0, 1, 0, -1, 0);\n  standardViewMatrices[StandardViewId.Back] = Matrix3d.createRowValues(-1, 0, 0, 0, 0, 1, 0, 1, 0);\n  standardViewMatrices[StandardViewId.Iso] = Matrix3d.createRowValues(\n    0.707106781186548, -0.70710678118654757, 0.00000000000000000,\n    0.408248290463863, 0.40824829046386302, 0.81649658092772603,\n    -0.577350269189626, -0.57735026918962573, 0.57735026918962573);\n  standardViewMatrices[StandardViewId.RightIso] = Matrix3d.createRowValues(\n    0.707106781186548, 0.70710678118654757, 0.00000000000000000,\n    -0.408248290463863, 0.40824829046386302, 0.81649658092772603,\n    0.577350269189626, -0.57735026918962573, 0.57735026918962573);\n\n  standardViewMatrices.forEach((mat) => Object.freeze(mat));\n  return standardViewMatrices;\n}\n\n/** Supplies access to a set of commonly-used view rotations.\n * @public\n */\nexport class StandardView {\n  public static get top(): Matrix3d { return this.getStandardRotation(StandardViewId.Top); }\n  public static get bottom(): Matrix3d { return this.getStandardRotation(StandardViewId.Bottom); }\n  public static get left(): Matrix3d { return this.getStandardRotation(StandardViewId.Left); }\n  public static get right(): Matrix3d { return this.getStandardRotation(StandardViewId.Right); }\n  public static get front(): Matrix3d { return this.getStandardRotation(StandardViewId.Front); }\n  public static get back(): Matrix3d { return this.getStandardRotation(StandardViewId.Back); }\n  public static get iso(): Matrix3d { return this.getStandardRotation(StandardViewId.Iso); }\n  public static get rightIso(): Matrix3d { return this.getStandardRotation(StandardViewId.RightIso); }\n\n  /** Obtain a [[Matrix3d]] corresponding to the specified [[StandardViewId]].\n   * @param id The ID of the desired rotation.\n   * @return A rotation matrix corresponding to the requested standard view ID, or a \"top\" view rotation if the input does not correspond to a standard rotation.\n   */\n  public static getStandardRotation(id: StandardViewId): Matrix3d {\n    if (id < StandardViewId.Top || id > StandardViewId.RightIso)\n      id = StandardViewId.Top;\n\n    return getMatrices()[id];\n  }\n\n  /** Attempts to adjust the supplied rotation matrix to match the standard view rotation it most closely matches.\n   * If a matching standard rotation exists, the input matrix will be modified in-place to precisely match it.\n   * Otherwise, the input matrix will be unmodified.\n   * @param matrix The rotation matrix to adjust.\n   */\n  public static adjustToStandardRotation(matrix: Matrix3d): void {\n    getMatrices().some((test) => {\n      if (test.maxDiff(matrix) > 1.0e-7)\n        return false;\n\n      matrix.setFrom(test);\n      return true;\n    });\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport {\r\n  assert,\r\n  Id64,\r\n  Id64Arg,\r\n  Id64Set,\r\n  Id64String,\r\n} from \"@bentley/bentleyjs-core\";\r\nimport { SubCategoryAppearance } from \"@bentley/imodeljs-common\";\r\nimport { IModelConnection } from \"./IModelConnection\";\r\n\r\n/** A cancelable paginated request for subcategory information.\r\n * @see SubCategoriesCache\r\n * @internal\r\n */\r\nexport interface SubCategoriesRequest {\r\n  /** The Ids of any categories which were requested but were not yet loaded. */\r\n  readonly missingCategoryIds: Id64Set;\r\n  /** A promise which resolves to true when all of the requested categories have been loaded, or to false if not all categories were loaded.\r\n   * Categories may fail to load if the request is explicitly canceled or if the IModelConnection is closed before all categories are loaded.\r\n   */\r\n  readonly promise: Promise<boolean>;\r\n  /** Cancels the request. */\r\n  cancel(): void;\r\n}\r\n\r\nconst invalidCategoryIdEntry = new Set<string>();\r\n\r\n/** A cache of information about the subcategories contained within an [[IModelConnection]]. It is populated on demand.\r\n * @internal\r\n */\r\nexport class SubCategoriesCache {\r\n  private readonly _byCategoryId = new Map<string, Id64Set>();\r\n  private readonly _appearances = new Map<string, SubCategoryAppearance>();\r\n  private readonly _imodel: IModelConnection;\r\n\r\n  public constructor(imodel: IModelConnection) { this._imodel = imodel; }\r\n\r\n  /** Get the Ids of all subcategories belonging to the category with the specified Id, or undefined if no such information is present. */\r\n  public getSubCategories(categoryId: string): Id64Set | undefined { return this._byCategoryId.get(categoryId); }\r\n\r\n  /** Get the base appearance of the subcategory with the specified Id, or undefined if no such information is present. */\r\n  public getSubCategoryAppearance(subCategoryId: Id64String): SubCategoryAppearance | undefined { return this._appearances.get(subCategoryId.toString()); }\r\n\r\n  /** Request that the subcategory information for all of the specified categories is loaded.\r\n   * If all such information has already been loaded, returns undefined.\r\n   * Otherwise, dispatches an asynchronous request to load those categories which are not already loaded and returns a cancellable request object\r\n   * containing the corresponding promise and the set of categories still to be loaded.\r\n   */\r\n  public load(categoryIds: Id64Arg): SubCategoriesRequest | undefined {\r\n    let missing: Id64Set | undefined;\r\n    Id64.forEach(categoryIds, (catId) => {\r\n      if (undefined === this._byCategoryId.get(catId)) {\r\n        if (undefined === missing)\r\n          missing = new Set<string>();\r\n\r\n        missing.add(catId);\r\n      }\r\n    });\r\n\r\n    if (undefined === missing)\r\n      return undefined;\r\n\r\n    const request = new SubCategoriesCache.Request(missing, this._imodel);\r\n    const promise = request.dispatch().then((result?: SubCategoriesCache.Result) => {\r\n      if (undefined !== result)\r\n        this.processResults(result, missing!);\r\n\r\n      return !request.wasCanceled;\r\n    });\r\n\r\n    return {\r\n      missingCategoryIds: missing,\r\n      promise,\r\n      cancel: () => request.cancel(),\r\n    };\r\n  }\r\n\r\n  public clear(): void {\r\n    this._byCategoryId.clear();\r\n    this._appearances.clear();\r\n  }\r\n\r\n  public onIModelConnectionClose(): void {\r\n    this.clear();\r\n  }\r\n\r\n  private static createSubCategoryAppearance(json?: any) {\r\n    let props: SubCategoryAppearance | undefined;\r\n    if (\"string\" === typeof json && 0 < json.length)\r\n      props = JSON.parse(json);\r\n\r\n    return new SubCategoryAppearance(props);\r\n  }\r\n\r\n  private processResults(result: SubCategoriesCache.Result, missing: Id64Set): void {\r\n    for (const row of result)\r\n      this.add(row.parentId as string, row.id as string, SubCategoriesCache.createSubCategoryAppearance(row.appearance));\r\n\r\n    // Ensure that any category Ids which returned no results (e.g., non-existent category, invalid Id, etc) are still recorded so they are not repeatedly re-requested\r\n    for (const id of missing)\r\n      if (undefined === this._byCategoryId.get(id))\r\n        this._byCategoryId.set(id, invalidCategoryIdEntry);\r\n  }\r\n\r\n  private add(categoryId: string, subCategoryId: string, appearance: SubCategoryAppearance) {\r\n    let set = this._byCategoryId.get(categoryId);\r\n    if (undefined === set)\r\n      this._byCategoryId.set(categoryId, set = new Set<string>());\r\n\r\n    set.add(subCategoryId);\r\n    this._appearances.set(subCategoryId, appearance);\r\n  }\r\n}\r\n\r\n/** This namespace and the types within it are exported strictly for use in tests.\r\n * @internal\r\n */\r\nexport namespace SubCategoriesCache {\r\n  export interface ResultRow {\r\n    parentId: Id64String;\r\n    id: Id64String;\r\n    appearance: SubCategoryAppearance.Props;\r\n  }\r\n\r\n  export type Result = ResultRow[];\r\n\r\n  export class Request {\r\n    private readonly _imodel: IModelConnection;\r\n    private readonly _ecsql: string[] = [];\r\n    private readonly _result: Result = [];\r\n    private _canceled = false;\r\n    private _curECSqlIndex = 0;\r\n\r\n    public get wasCanceled() { return this._canceled || this._imodel.isClosed; }\r\n\r\n    public constructor(categoryIds: Set<string>, imodel: IModelConnection, maxCategoriesPerQuery = 200) {\r\n      this._imodel = imodel;\r\n\r\n      const catIds = [...categoryIds];\r\n      while (catIds.length !== 0) {\r\n        const end = (catIds.length > maxCategoriesPerQuery) ? maxCategoriesPerQuery : catIds.length;\r\n        const where = catIds.splice(0, end).join(\",\");\r\n        this._ecsql.push(\"SELECT ECInstanceId as id, Parent.Id as parentId, Properties as appearance FROM BisCore.SubCategory WHERE Parent.Id IN (\" + where + \")\");\r\n      }\r\n    }\r\n\r\n    public cancel() { this._canceled = true; }\r\n\r\n    public async dispatch(): Promise<Result | undefined> {\r\n      if (this.wasCanceled || this._curECSqlIndex >= this._ecsql.length) // handle case of empty category Id set...\r\n        return undefined;\r\n\r\n      try {\r\n        const ecsql = this._ecsql[this._curECSqlIndex];\r\n        for await (const row of this._imodel.query(ecsql)) {\r\n          this._result.push(row);\r\n          if (this.wasCanceled)\r\n            return undefined;\r\n        }\r\n      } catch (_) {\r\n        // ###TODO: detect cases in which retry is warranted\r\n        // Note that currently, if we succeed in obtaining some pages of results and fail to retrieve another page, we will end up processing the\r\n        // incomplete results. Since we're not retrying, that's the best we can do.\r\n      }\r\n\r\n      // Finished with current ECSql query. Dispatch the next if one exists.\r\n      if (++this._curECSqlIndex < this._ecsql.length) {\r\n        if (this.wasCanceled)\r\n          return undefined;\r\n        else\r\n          return this.dispatch();\r\n      }\r\n\r\n      // Even if we were canceled, we've retrieved all the rows. Might as well process them to prevent another request for some of the same rows from being enqueued.\r\n      return this._result;\r\n    }\r\n  }\r\n\r\n  export type QueueFunc = () => void;\r\n\r\n  export class QueueEntry {\r\n    public readonly categoryIds: Id64Set;\r\n    public readonly funcs: QueueFunc[];\r\n\r\n    public constructor(categoryIds: Id64Set, func: QueueFunc) {\r\n      this.categoryIds = categoryIds;\r\n      this.funcs = [func];\r\n    }\r\n  }\r\n\r\n  /** A \"queue\" of SubCategoriesRequests, which consists of between 0 and 2 entries. Each entry specifies the set of category IDs to be loaded and a list of functions to be executed\r\n   * when loading is completed. This is used to enforce ordering of operations upon subcategories despite the need to asynchronously load them. It incidentally also provides an\r\n   * opportunity to reduce the number of backend requests by batching consecutive requests.\r\n   * Chiefly used by [[Viewport]].\r\n   * @internal\r\n   */\r\n  export class Queue {\r\n    /* NB: Members marked protected for use in tests only. */\r\n    protected _current?: QueueEntry;\r\n    protected _next?: QueueEntry;\r\n    protected _request?: SubCategoriesRequest;\r\n    protected _disposed = false;\r\n\r\n    /** Push a request onto the queue. The requested categories will be loaded if necessary, and then\r\n     * the supplied function will be invoked. Any previously-pushed requests are guaranteed to be processed before this one.\r\n     */\r\n    public push(cache: SubCategoriesCache, categoryIds: Id64Arg, func: QueueFunc): void {\r\n      if (this._disposed)\r\n        return;\r\n      else if (undefined === this._current)\r\n        this.pushCurrent(cache, categoryIds, func);\r\n      else\r\n        this.pushNext(categoryIds, func);\r\n    }\r\n\r\n    /** Cancel all requests and empty the queue. */\r\n    public dispose(): void {\r\n      if (undefined !== this._request) {\r\n        assert(undefined !== this._current);\r\n        this._request.cancel();\r\n        this._request = undefined;\r\n      }\r\n\r\n      this._current = this._next = undefined;\r\n      this._disposed = true;\r\n    }\r\n\r\n    public get isEmpty(): boolean {\r\n      return undefined === this._current && undefined === this._next;\r\n    }\r\n\r\n    private pushCurrent(cache: SubCategoriesCache, categoryIds: Id64Arg, func: QueueFunc): void {\r\n      assert(undefined === this._next);\r\n      assert(undefined === this._current);\r\n      assert(undefined === this._request);\r\n\r\n      this._request = cache.load(categoryIds);\r\n      if (undefined === this._request) {\r\n        // All requested categories are already loaded.\r\n        func();\r\n        return;\r\n      } else {\r\n        // We need to load the requested categories before invoking the function.\r\n        this.processCurrent(cache, new QueueEntry(Id64.toIdSet(categoryIds, true), func));\r\n      }\r\n    }\r\n\r\n    private processCurrent(cache: SubCategoriesCache, entry: QueueEntry): void {\r\n      assert(undefined !== this._request);\r\n      assert(undefined === this._current);\r\n      assert(undefined === this._next);\r\n\r\n      this._current = entry;\r\n      this._request!.promise.then((completed: boolean) => { // tslint:disable-line:no-floating-promises\r\n        if (this._disposed)\r\n          return;\r\n\r\n        // Invoke all the functions which were awaiting this set of categories.\r\n        assert(undefined !== this._current);\r\n        if (completed)\r\n          for (const func of this._current!.funcs)\r\n            func();\r\n\r\n        this._request = undefined;\r\n        this._current = undefined;\r\n\r\n        // If we have more requests, process them.\r\n        const next = this._next;\r\n        this._next = undefined;\r\n        if (undefined !== next) {\r\n          this._request = cache.load(next.categoryIds);\r\n          if (undefined === this._request) {\r\n            // All categories loaded.\r\n            for (const func of next.funcs)\r\n              func();\r\n          } else {\r\n            // We need to load the requested categories before invoking the pending functions.\r\n            this.processCurrent(cache, next);\r\n          }\r\n        }\r\n      });\r\n    }\r\n\r\n    private pushNext(categoryIds: Id64Arg, func: QueueFunc): void {\r\n      assert(undefined !== this._current);\r\n      assert(undefined !== this._request);\r\n\r\n      if (undefined === this._next) {\r\n        // We have a request currently in process and none pending.\r\n        // We could potentially determine that this request doesn't require any categories that are not already loaded or being loaded by the current request.\r\n        // But we will find that out (synchronously) when current request completes, unless more requests come in. Probably not worth it.\r\n        this._next = new QueueEntry(Id64.toIdSet(categoryIds, true), func);\r\n      } else {\r\n        // We have a request currently in process, and one or more pending. Append this one to the pending.\r\n        this._next.funcs.push(func);\r\n        Id64.forEach(categoryIds, (categoryId) => {\r\n          this._next!.categoryIds.add(categoryId);\r\n        });\r\n      }\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module LocatingElements */\n\nimport { Point3d } from \"@bentley/geometry-core\";\nimport { ScreenViewport } from \"./Viewport\";\nimport { BeButtonEvent, BeButton } from \"./tools/Tool\";\nimport { HitList, SnapDetail, SnapHeat, HitDetail, HitSource, SnapMode, HitPriority } from \"./HitDetail\";\nimport { DecorateContext } from \"./ViewContext\";\nimport { HitListHolder } from \"./ElementLocateManager\";\nimport { IModelApp } from \"./IModelApp\";\nimport { AccuSnap } from \"./AccuSnap\";\nimport { ViewManip, ViewHandleType } from \"./tools/ViewTool\";\n\n/** @public */\nexport class TentativePoint {\n  public isActive = false;\n  public currSnap?: SnapDetail;\n  public tpHits?: HitList<HitDetail>;\n  private get _hotDistanceInches(): number { return 0.21; }\n  private readonly _point: Point3d = new Point3d();\n  private readonly _rawPoint: Point3d = new Point3d();\n  private readonly _viewPoint: Point3d = new Point3d();\n  private _tentativePromise?: Promise<SnapDetail | undefined>;\n  public viewport?: ScreenViewport;\n\n  public onInitialized() { }\n  public setHitList(list?: HitList<HitDetail>) { this.tpHits = list; }\n\n  /** @return true if the tentative point is currently active and snapped to an element. */\n  public get isSnapped(): boolean { return undefined !== this.currSnap; }\n\n  /** @return The current snap path when TentativePoint.isSnapped or undefined. */\n  public getCurrSnap(): SnapDetail | undefined { return this.currSnap; }\n\n  public getPoint(): Point3d {\n    const snap = this.currSnap;\n    return !snap ? this._point : snap.adjustedPoint;\n  }\n\n  public setPoint(point: Point3d): void {\n    this.setCurrSnap(undefined);\n    this.tpHits = undefined;\n    this._point.setFrom(point);\n  }\n\n  public clear(doErase: boolean): void {\n    if (doErase) {\n      this.removeTentative();\n      IModelApp.accuSnap.synchSnapMode();\n    }\n    IModelApp.accuSnap.destroy();\n    this.isActive = false;\n    this.setCurrSnap(undefined);\n    this.tpHits = undefined;\n  }\n\n  public removeTentative(): void {\n    this._tentativePromise = undefined;\n    if (!this.isActive)\n      return;\n    IModelApp.accuSnap.erase();\n    if (this.getCurrSnap())\n      IModelApp.viewManager.invalidateDecorationsAllViews();\n    else\n      this.viewport!.invalidateDecorations();\n    this.isActive = false;\n  }\n\n  public setCurrSnap(newSnap?: SnapDetail): void {\n    if (newSnap)\n      newSnap.setSnapPoint(newSnap.snapPoint, SnapHeat.InRange); // Reset adjustedPoint from pre-located snap and set SnapHeat...\n    this.currSnap = newSnap;\n  }\n\n  public showTentative(): void {\n    if (this.isSnapped) {\n      IModelApp.viewManager.invalidateDecorationsAllViews();\n      IModelApp.accuSnap.displayToolTip(this._viewPoint, this.viewport!, undefined); // tslint:disable-line:no-floating-promises\n    } else {\n      this.viewport!.invalidateDecorations();\n    }\n    this.isActive = true;\n  }\n\n  public getHitAndList(holder: HitListHolder): SnapDetail | undefined {\n    const hit = this.currSnap;\n    if (hit) {\n      holder.setHitList(this.tpHits);\n      this.tpHits = undefined;\n    }\n    return hit;\n  }\n\n  public onButtonEvent(ev: BeButtonEvent): void {\n    switch (ev.button) {\n      case BeButton.Data:\n        if (!ev.isDown)\n          return; // cleared on down...\n        break;\n      case BeButton.Reset:\n        if (ev.isDown)\n          return; // cleared on up...\n        break;\n      case BeButton.Middle:\n        return;\n    }\n\n    this.removeTentative();\n    IModelApp.accuSnap.synchSnapMode();\n    this.setCurrSnap(undefined);\n    this.tpHits = undefined;\n  }\n\n  public decorate(context: DecorateContext): void {\n    const viewport = context.viewport;\n    if (!this.isActive || !viewport)\n      return;\n\n    const tpSize = Math.floor(viewport.pixelsPerInch * 0.4) + 0.5;\n    const toSizeOutline = tpSize + 1;\n    const position = context.viewport.worldToView(this._point); position.x = Math.floor(position.x) + 0.5; position.y = Math.floor(position.y) + 0.5;\n    const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n      ctx.beginPath();\n      ctx.strokeStyle = \"rgba(0,0,0,.5)\";\n      ctx.lineWidth = 3;\n      ctx.moveTo(-toSizeOutline, 0);\n      ctx.lineTo(toSizeOutline, 0);\n      ctx.moveTo(0, -toSizeOutline);\n      ctx.lineTo(0, toSizeOutline);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.strokeStyle = \"white\";\n      ctx.lineWidth = 1;\n      if (!this.isSnapped) ctx.setLineDash([4, 1]);\n      ctx.shadowColor = \"black\";\n      ctx.shadowBlur = 5;\n      ctx.moveTo(-tpSize, 0);\n      ctx.lineTo(tpSize, 0);\n      ctx.moveTo(0, -tpSize);\n      ctx.lineTo(0, tpSize);\n      ctx.stroke();\n    };\n    context.addCanvasDecoration({ position, drawDecoration });\n  }\n\n  private async getSnap(newSearch: boolean): Promise<SnapDetail | undefined> {\n    // Use next hit from previous search when using tentative to cycle through hits...\n    let thisHit = (!newSearch && undefined !== this.tpHits ? this.tpHits.getNextHit() : undefined);\n\n    // Use existing AccuSnap hit list if one exists...\n    if (undefined === thisHit) {\n      this.tpHits = undefined;\n      thisHit = IModelApp.accuSnap.getHitAndList(this);\n    }\n\n    if (undefined === thisHit) {\n      // search for elements around the current raw point (search should not be affected by locks!)\n      const aperture = (2.0 * this.viewport!.pixelsFromInches(IModelApp.locateManager.apertureInches) / 2.0) + 1.5;\n      const options = IModelApp.locateManager.options.clone(); // Copy to avoid changing out from under active Tool...\n      const picker = IModelApp.locateManager.picker;\n\n      options.hitSource = HitSource.TentativeSnap;\n      if (0 === picker.doPick(this.viewport!, this._rawPoint, aperture, options))\n        return undefined;\n\n      this.tpHits = picker.getHitList(true);\n      thisHit = (undefined !== this.tpHits ? this.tpHits.getNextHit() : undefined);\n    } else if (thisHit instanceof SnapDetail) {\n      // Make the current AccuSnap the TentativePoint snap...\n      return thisHit;\n    }\n\n    if (undefined === thisHit)\n      return undefined;\n\n    const snapModes = IModelApp.accuSnap.getActiveSnapModes(); // Get the list of point snap modes to consider\n    if (1 === snapModes.length && SnapMode.Intersection === snapModes[0])\n      snapModes.push(SnapMode.Nearest); // Add nearest when doing intersection by itself to support finding extended intersections...\n\n    const thisSnap = await AccuSnap.requestSnap(thisHit, snapModes, this._hotDistanceInches, IModelApp.accuSnap.keypointDivisor, this.tpHits);\n\n    if (undefined !== thisSnap)\n      IModelApp.accuDraw.onSnap(thisSnap); // AccuDraw can adjust nearest snap to intersection of circle (polar distance lock) or line (axis lock) with snapped to curve...\n\n    return thisSnap;\n  }\n\n  private static arePointsCloseEnough(pt1: Point3d, pt2: Point3d, pixelDistance: number): boolean { return pt1.distance(pt2) < (pixelDistance + 1.5); }\n\n  public process(ev: BeButtonEvent): void {\n    if (undefined !== this._tentativePromise)\n      return;\n\n    const currTool = IModelApp.toolAdmin.viewTool;\n    if (currTool && currTool.inDynamicUpdate)\n      return; // trying to tentative snap while view is changing isn't useful...\n\n    const wasActive = this.isActive;\n    this.removeTentative(); // remove the TP cross if it is already on the screen\n    const lastPtView = this._viewPoint.clone();\n\n    this.viewport = ev.viewport!;\n    this._point.setFrom(ev.point);\n    this._rawPoint.setFrom(ev.rawPoint);\n    this._viewPoint.setFrom(ev.viewPoint);\n\n    const newSearch = (!this.isSnapped || !TentativePoint.arePointsCloseEnough(lastPtView, this._viewPoint, this.viewport!.pixelsFromInches(IModelApp.locateManager.apertureInches)));\n    const promise = this.getSnap(newSearch);\n    this._tentativePromise = promise;\n\n    promise.then((newSnap) => { // tslint:disable-line:no-floating-promises\n      // Ignore response if we're no longer interested in this tentative.\n      if (this._tentativePromise === promise) {\n        this._tentativePromise = undefined;\n        this.setCurrSnap(newSnap); // Adopt the snap as current\n        IModelApp.accuSnap.clear(); // make sure there's no AccuSnap active after a tentative point (otherwise we continually snap to it).\n        if (this.isSnapped)\n          this._point.setFrom(this.currSnap!.snapPoint);\n        else if (wasActive && newSearch)\n          this._point.setFrom(ev.rawPoint);\n        this.showTentative(); // show the TP cross\n\n        if (this.isSnapped) {\n          IModelApp.toolAdmin.adjustSnapPoint();\n        } else if (IModelApp.accuDraw.isActive) {\n          const point = this.getPoint().clone();\n          const vp = ev.viewport!;\n          if (vp.isSnapAdjustmentRequired) {\n            IModelApp.toolAdmin.adjustPointToACS(point, vp, false);\n            const hit = new HitDetail(point, vp, HitSource.TentativeSnap, point, \"\", HitPriority.Unknown, 0, 0);\n            const snap = new SnapDetail(hit);\n            this.setCurrSnap(snap);\n            IModelApp.toolAdmin.adjustSnapPoint();\n            this.setPoint(this.getPoint());\n          } else {\n            IModelApp.accuDraw.adjustPoint(point, vp, false);\n            const savePoint = point.clone();\n            IModelApp.toolAdmin.adjustPointToGrid(point, vp);\n            if (!point.isExactEqual(savePoint))\n              IModelApp.accuDraw.adjustPoint(point, vp, false);\n            this.setPoint(point);\n          }\n        } else {\n          IModelApp.toolAdmin.adjustPoint(this.getPoint(), ev.viewport!);\n        }\n\n        IModelApp.accuDraw.onTentative();\n        if (currTool && currTool instanceof ViewManip && currTool.viewHandles.hasHandle(ViewHandleType.TargetCenter))\n          currTool.updateTargetCenter(); // Change target center to tentative location...\n        else\n          IModelApp.toolAdmin.updateDynamics(); // Don't wait for motion to update tool dynamics...\n      }\n    });\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\nimport { Viewport, ScreenViewport } from \"./Viewport\";\r\nimport { TiledGraphicsProvider } from \"./TiledGraphicsProvider\";\r\nimport { IModelApp } from \"./IModelApp\";\r\n\r\n/** Terrain provider that provides tile tree for display within a [[Viewport]].\r\n * @internal\r\n */\r\nexport abstract class TerrainProvider implements TiledGraphicsProvider.Provider {\r\n  public onInitialized(): void {\r\n    IModelApp.viewManager.onViewOpen.addListener((viewport: ScreenViewport) => { viewport.addTiledGraphicsProvider(TiledGraphicsProvider.Type.Geometry, this); });\r\n  }\r\n\r\n  public abstract getTileTree(viewport: Viewport): TiledGraphicsProvider.Tree | undefined;\r\n}\r\n","import { Plane3dByOriginAndUnitNormal } from \"@bentley/geometry-core\";\r\n\r\n/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Views */\r\nimport { TileTree } from \"./tile/TileTree\";\r\nimport { Viewport } from \"./Viewport\";\r\n\r\n/** @internal */\r\nexport namespace TiledGraphicsProvider {\r\n\r\n  /** TileTree for display within a [[Viewport]].\r\n   * @internal\r\n   */\r\n  export interface Tree {\r\n    tileTree: TileTree;\r\n    plane?: Plane3dByOriginAndUnitNormal;\r\n  }\r\n\r\n  /** An object that provides a tile tree for display within a [[Viewport]].\r\n   * @internal\r\n   */\r\n  export interface Provider {\r\n    getTileTree(viewport: Viewport): TiledGraphicsProvider.Tree | undefined;\r\n  }\r\n\r\n  /** Types of TiledGraphicsProviders.\r\n   * @internal\r\n   */\r\n  export enum Type {\r\n    BackgroundMap = 0,\r\n    Geometry = 1,\r\n    Overlay = 2,\r\n  }\r\n\r\n  /** A set of TiledGraphicsProviders.\r\n   * @internal\r\n   */\r\n  export type ProviderSet = Set<TiledGraphicsProvider.Provider>;\r\n\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { Id64String, assert } from \"@bentley/bentleyjs-core\";\nimport { ConvexClipPlaneSet, CurveLocationDetail, Geometry, LineSegment3d, Matrix3d, Point2d, Point3d, Transform, Vector2d, Vector3d, XAndY, Plane3dByOriginAndUnitNormal } from \"@bentley/geometry-core\";\nimport { ColorDef, Frustum, FrustumPlanes, LinePixels, Npc, ViewFlags } from \"@bentley/imodeljs-common\";\nimport { GraphicBuilder, GraphicType } from \"./render/GraphicBuilder\";\nimport { CanvasDecoration, Decorations, GraphicBranch, GraphicList, RenderClipVolume, RenderGraphic, RenderTarget, RenderPlanarClassifier, PlanarClassifierMap, RenderSolarShadowMap } from \"./render/System\";\nimport { ScreenViewport, Viewport, ViewFrustum } from \"./Viewport\";\nimport { ViewState3d } from \"./ViewState\";\nimport { Tile } from \"./tile/TileTree\";\nimport { IModelApp } from \"./IModelApp\";\nimport { TiledGraphicsProvider } from \"./TiledGraphicsProvider\";\n\nconst gridConstants = { maxPoints: 50, maxRefs: 25, maxDotsInRow: 250, maxHorizon: 500, dotTransparency: 100, lineTransparency: 200, planeTransparency: 225 };\n\n/** Provides context for producing [[RenderGraphic]]s for drawing within a [[Viewport]].\n * @public\n */\nexport class RenderContext {\n  /** ViewFlags extracted from the context's [[Viewport]]. */\n  public readonly viewFlags: ViewFlags;\n  /** The [[Viewport]] associated with this context. */\n  public readonly viewport: Viewport;\n  /** Frustum extracted from the context's [[Viewport]]. */\n  public readonly frustum: Frustum;\n  /** Frustum planes extracted from the context's [[Viewport]]. */\n  public readonly frustumPlanes: FrustumPlanes;\n\n  constructor(vp: Viewport, frustum?: Frustum) {\n    this.viewport = vp;\n    this.viewFlags = vp.viewFlags.clone(); // viewFlags can diverge from viewport after attachment\n    this.frustum = frustum ? frustum : vp.getFrustum();\n    this.frustumPlanes = new FrustumPlanes(this.frustum);\n  }\n\n  /** Given a point in world coordinates, determine approximately how many pixels it occupies on screen based on this context's frustum. */\n  public getPixelSizeAtPoint(inPoint?: Point3d): number { return this.viewport.viewFrustum.getPixelSizeAtPoint(inPoint); }\n\n  /** @internal */\n  public get target(): RenderTarget { return this.viewport.target; }\n\n  /** @internal */\n  protected _createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder { return this.target.createGraphicBuilder(type, this.viewport, transform, id); }\n\n  /** Create a builder for creating a [[GraphicType.Scene]] [[RenderGraphic]] for rendering within this context's [[Viewport]].\n   * @param transform the local-to-world transform in which the builder's geometry is to be defined.\n   * @returns A builder for creating a [[GraphicType.Scene]] [[RenderGraphic]] for rendering within this context's [[Viewport]].\n   */\n  public createSceneGraphicBuilder(transform?: Transform): GraphicBuilder { return this._createGraphicBuilder(GraphicType.Scene, transform); }\n\n  /** @internal */\n  public createGraphicBranch(branch: GraphicBranch, location: Transform, clip?: RenderClipVolume, planarClassifier?: RenderPlanarClassifier): RenderGraphic { return this.target.renderSystem.createGraphicBranch(branch, location, clip, planarClassifier); }\n\n  /** Create a [[RenderGraphic]] which groups a set of graphics into a node in a scene graph, applying to each a transform and optional clip volume and symbology overrides.\n   * @param branch Contains the group of graphics and the symbology overrides.\n   * @param location the local-to-world transform applied to the grouped graphics.\n   * @returns A RenderGraphic suitable for drawing the scene graph node within this context's [[Viewport]].\n   * @see [[RenderSystem.createBranch]]\n   */\n  public createBranch(branch: GraphicBranch, location: Transform): RenderGraphic { return this.createGraphicBranch(branch, location); }\n}\n\n/** Provides context for an [[InteractiveTool]] to display decorations representing its current state.\n * @see [[InteractiveTool.onDynamicFrame]]\n * @public\n */\nexport class DynamicsContext extends RenderContext {\n  private _dynamics?: GraphicList;\n\n  /** Add a graphic to the list of dynamic graphics to be drawn in this context's [[Viewport]]. */\n  public addGraphic(graphic: RenderGraphic) {\n    if (undefined === this._dynamics)\n      this._dynamics = [];\n    this._dynamics.push(graphic);\n  }\n\n  /** @internal */\n  public changeDynamics(): void { this.viewport!.changeDynamics(this._dynamics); }\n}\n\n/** Provides context for a [[Decorator]] to add [[Decorations]] to be rendered within a [[Viewport]].\n * @public\n */\nexport class DecorateContext extends RenderContext {\n  /** The HTMLDivElement which overlays the [[Viewport]]'s HTMLCanvasElement, to which HTML decorations are added. */\n  public decorationDiv: HTMLDivElement;\n  /** The [[ScreenViewport]] in which this context's [[Decorations]] will be drawn. */\n  public get screenViewport(): ScreenViewport { return this.viewport as ScreenViewport; }\n  /** @internal */\n  constructor(vp: ScreenViewport, private readonly _decorations: Decorations) {\n    super(vp);\n    this.decorationDiv = vp.decorationDiv;\n  }\n\n  /** @internal */\n  public static getGridDimension(props: { nRepetitions: number, min: number }, gridSize: number, org: Point3d, dir: Point3d, points: Point3d[]): boolean {\n    // initialized only to avoid warning.\n    let distLow = 0.0;\n    let distHigh = 0.0;\n\n    for (let i = 0, n = points.length; i < n; ++i) {\n      const distance = org.vectorTo(points[i]).dotProduct(dir);\n      if (i) {\n        if (distance < distLow)\n          distLow = distance;\n        if (distance > distHigh)\n          distHigh = distance;\n      } else {\n        distLow = distHigh = distance;\n      }\n    }\n\n    if (distHigh <= distLow)\n      return false;\n\n    props.min = Math.floor(distLow / gridSize); // NOTE: Should be ok to let grid extend outside project extents since view extends padded for ground plane...\n    const max = Math.ceil(distHigh / gridSize);\n    props.nRepetitions = max - props.min;\n    props.min *= gridSize;\n\n    return true;\n  }\n\n  /** @internal */\n  public static getGridPlaneViewIntersections(planePoint: Point3d, planeNormal: Vector3d, vp: Viewport, useProjectExtents: boolean): Point3d[] {\n    const plane = Plane3dByOriginAndUnitNormal.create(planePoint, planeNormal);\n    if (undefined === plane)\n      return [];\n\n    const frust = vp.getFrustum();\n    const limitRange = useProjectExtents && vp.view.isSpatialView();\n\n    // Limit non-view aligned grid to project extents in spatial views...\n    if (limitRange) {\n      const range = vp.view.iModel.projectExtents.clone();\n      if (range.isNull)\n        return [];\n      range.intersect(frust.toRange(), range);\n      if (range.isNull)\n        return [];\n      frust.initFromRange(range);\n    }\n\n    const index = new Array<[number, number]>(\n      // lines connecting front to back\n      [Npc._000, Npc._001],\n      [Npc._100, Npc._101],\n      [Npc._010, Npc._011],\n      [Npc._110, Npc._111],\n      // around front face\n      [Npc._000, Npc._100],\n      [Npc._100, Npc._110],\n      [Npc._110, Npc._010],\n      [Npc._010, Npc._000],\n      // around back face.\n      [Npc._001, Npc._101],\n      [Npc._101, Npc._111],\n      [Npc._111, Npc._011],\n      [Npc._011, Npc._001]);\n\n    const intersections: CurveLocationDetail[] = [];\n    for (let i = 0, n = index.length; i < n; ++i) {\n      const corner1 = frust.getCorner(index[i][0]),\n        corner2 = frust.getCorner(index[i][1]);\n      const lineSegment = LineSegment3d.create(corner1, corner2);\n      lineSegment.appendPlaneIntersectionPoints(plane, intersections);\n    }\n\n    return intersections.map((cld: CurveLocationDetail) => cld.point.clone());\n  }\n\n  /** Create a builder for creating a [[RenderGraphic]] of the specified type appropriate for rendering within this context's [[Viewport]].\n   * @param type The type of builder to create.\n   * @param transform the local-to-world transform in which the builder's geometry is to be defined.\n   * @param id If the decoration is to be pickable, a unique identifier to associate with the resultant [[RenderGraphic]].\n   * @returns A builder for creating a [[RenderGraphic]] of the specified type appropriate for rendering within this context's [[Viewport]].\n   * @see [[IModelConnection.transientIds]] for obtaining an ID for a pickable decoration.\n   */\n  public createGraphicBuilder(type: GraphicType, transform?: Transform, id?: Id64String): GraphicBuilder { return this._createGraphicBuilder(type, transform, id); }\n\n  /** Calls [[GraphicBuilder.finish]] on the supplied builder to obtain a [[RenderGraphic]], then adds the graphic to the appropriate list of\n   * [[Decorations]].\n   * @param builder The builder from which to extract the graphic.\n   * @note The builder should not be used after calling this method.\n   */\n  public addDecorationFromBuilder(builder: GraphicBuilder) { this.addDecoration(builder.type, builder.finish()); }\n\n  /** Adds a graphic to the set of [[Decorations]] to be drawn in this context's [[Viewport]].\n   * @param The type of the graphic, which determines to which list of decorations it is added.\n   * @param decoration The decoration graphic to add.\n   * @note The type must match the type with which the [[RenderGraphic]]'s [[GraphicBuilder]] was constructed.\n   * @see [[DecorateContext.addDecorationFromBuilder]] for a more convenient API.\n   */\n  public addDecoration(type: GraphicType, decoration: RenderGraphic) {\n    switch (type) {\n      case GraphicType.Scene:\n        if (undefined === this._decorations.normal)\n          this._decorations.normal = [];\n        this._decorations.normal.push(decoration);\n        break;\n\n      case GraphicType.WorldDecoration:\n        if (!this._decorations.world)\n          this._decorations.world = [];\n        this._decorations.world.push(decoration);\n        break;\n\n      case GraphicType.WorldOverlay:\n        if (!this._decorations.worldOverlay)\n          this._decorations.worldOverlay = [];\n        this._decorations.worldOverlay.push(decoration);\n        break;\n\n      case GraphicType.ViewOverlay:\n        if (!this._decorations.viewOverlay)\n          this._decorations.viewOverlay = [];\n        this._decorations.viewOverlay.push(decoration);\n        break;\n    }\n  }\n\n  /** Add a [[CanvasDecoration]] to be drawn in this context's [[Viewport]]. */\n  public addCanvasDecoration(decoration: CanvasDecoration, atFront = false) {\n    if (undefined === this._decorations.canvasDecorations)\n      this._decorations.canvasDecorations = [];\n\n    const list = this._decorations.canvasDecorations;\n    if (0 === list.length || true === atFront)\n      list.push(decoration);\n    else\n      list.unshift(decoration);\n  }\n\n  /** Add an HTMLElement to be drawn as a decoration in this context's [[Viewport]]. */\n  public addHtmlDecoration(decoration: HTMLElement) { this.decorationDiv.appendChild(decoration); }\n\n  /** @internal */\n  public drawStandardGrid(gridOrigin: Point3d, rMatrix: Matrix3d, spacing: XAndY, gridsPerRef: number, isoGrid: boolean = false, fixedRepetitions?: Point2d): void {\n    const vp = this.viewport;\n\n    // rotMatrix returns new Vectors instead of references\n    const xVec = rMatrix.rowX(),\n      yVec = rMatrix.rowY(),\n      zVec = rMatrix.rowZ(),\n      viewZ = vp.rotation.getRow(2);\n\n    if (!vp.isCameraOn && Math.abs(viewZ.dotProduct(zVec)) < 0.005)\n      return;\n\n    const refScale = (0 === gridsPerRef) ? 1.0 : gridsPerRef;\n    const refSpacing = Vector2d.create(spacing.x, spacing.y).scale(refScale);\n\n    let gridOrg = new Point3d();\n    let repetitions = new Point2d();\n\n    if (undefined === fixedRepetitions || 0 === fixedRepetitions.x || 0 === fixedRepetitions.y) {\n      // expect gridOrigin and zVec to be modified from this call\n      const intersections = DecorateContext.getGridPlaneViewIntersections(gridOrigin, zVec, vp, undefined !== fixedRepetitions);\n\n      if (intersections.length < 3)\n        return;\n\n      const min = new Point2d(),\n        xProps = { nRepetitions: repetitions.x, min: min.x },\n        yProps = { nRepetitions: repetitions.y, min: min.y };\n      if (!DecorateContext.getGridDimension(xProps, refSpacing.x, gridOrigin, Point3d.createFrom(xVec), intersections) ||\n        !DecorateContext.getGridDimension(yProps, refSpacing.y, gridOrigin, Point3d.createFrom(yVec), intersections))\n        return;\n\n      // update vectors. (workaround for native passing primitives by reference)\n      repetitions.x = xProps.nRepetitions; min.x = xProps.min;\n      repetitions.y = yProps.nRepetitions; min.y = yProps.min;\n\n      gridOrg.plus3Scaled(gridOrigin, 1, xVec, min.x, yVec, min.y, gridOrg);\n    } else {\n      gridOrg = gridOrigin;\n      repetitions = fixedRepetitions;\n    }\n\n    if (0 === repetitions.x || 0 === repetitions.y)\n      return;\n\n    const gridX = xVec.scale(refSpacing.x),\n      gridY = yVec.scale(refSpacing.y);\n\n    const testPt = gridOrg.plus2Scaled(gridX, repetitions.x / 2.0, gridY, repetitions.y / 2.0);\n\n    let maxGridPts = gridConstants.maxPoints;\n    let maxGridRefs = gridConstants.maxRefs;\n\n    if (maxGridPts < 10)\n      maxGridPts = 10;\n    if (maxGridRefs < 10)\n      maxGridRefs = 10;\n\n    // values are \"per 1000 pixels\"\n    const minGridSeparationPixels = 1000 / maxGridPts,\n      minRefSeparation = 1000 / maxGridRefs;\n    let meterPerPixel = vp.getPixelSizeAtPoint(testPt);\n\n    if ((refSpacing.x / meterPerPixel) < minRefSeparation || (refSpacing.y / meterPerPixel) < minRefSeparation)\n      gridsPerRef = 0;\n\n    // Avoid z fighting with coincident geometry\n    gridOrg.plusScaled(viewZ, meterPerPixel, gridOrg); // was SumOf(DPoint2dCR point, DPoint2dCR vector, double s)\n    meterPerPixel *= refScale;\n\n    const drawDots = ((refSpacing.x / meterPerPixel) > minGridSeparationPixels) && ((refSpacing.y / meterPerPixel) > minGridSeparationPixels);\n    const builder = this.createGraphicBuilder(GraphicType.WorldDecoration, undefined, undefined);\n\n    DecorateContext.drawGrid(builder, isoGrid, drawDots, gridOrg, gridX, gridY, gridsPerRef, repetitions, vp);\n    this.addDecorationFromBuilder(builder);\n  }\n\n  /** @internal */\n  public static drawGrid(graphic: GraphicBuilder, doIsogrid: boolean, drawDots: boolean, gridOrigin: Point3d, xVec: Vector3d, yVec: Vector3d, gridsPerRef: number, repetitions: Point2d, vp: Viewport) {\n    const eyePoint = vp.worldToViewMap.transform1.columnZ();\n    const viewZ = Vector3d.createFrom(eyePoint);\n\n    const aa = Geometry.conditionalDivideFraction(1, eyePoint.w);\n    if (aa !== undefined) {\n      const xyzEye = viewZ.scale(aa);\n      viewZ.setFrom(gridOrigin.vectorTo(xyzEye));\n    }\n\n    let normResult = viewZ.normalize(viewZ);\n    if (!normResult)\n      return;\n    const zVec = xVec.crossProduct(yVec);\n    normResult = zVec.normalize(zVec);\n    if (!normResult)\n      return;\n\n    const color = vp.getContrastToBackgroundColor();\n    const lineColor = color.clone();\n    const dotColor = color.clone();\n    const planeColor = color.clone();\n    lineColor.setTransparency(gridConstants.lineTransparency);\n    dotColor.setTransparency(gridConstants.dotTransparency);\n    planeColor.setTransparency(gridConstants.planeTransparency);\n    let linePat = LinePixels.Solid;\n\n    if (viewZ.dotProduct(zVec) < 0.0) {   // Provide visual indication that grid is being viewed from the back (grid z not towards eye)...\n      planeColor.setFrom(ColorDef.red);\n      planeColor.setTransparency(gridConstants.planeTransparency);\n      linePat = LinePixels.Code2;\n    }\n\n    const gpr = gridsPerRef > 0 ? gridsPerRef : 1;\n    const rpg = 1 / gpr;\n\n    if (doIsogrid)\n      gridsPerRef = 0;  // turn off reference grid for iso\n\n    if (drawDots) {\n      const dotXVec = Vector3d.createFrom(xVec);\n      const dotYVec = Vector3d.createFrom(yVec);\n\n      dotXVec.scale(rpg, dotXVec);\n      dotYVec.scale(rpg, dotYVec);\n\n      graphic.setSymbology(dotColor, planeColor, 1);\n      DecorateContext.drawGridDots(graphic, doIsogrid, gridOrigin, dotYVec, repetitions.y * gpr, dotXVec, repetitions.x * gpr, gridsPerRef, vp);\n    }\n\n    if (0 < gridsPerRef) {\n      graphic.setSymbology(lineColor, planeColor, 1, linePat);\n      DecorateContext.drawGridRefs(graphic, gridOrigin, xVec, yVec, repetitions.x, repetitions.y);\n      DecorateContext.drawGridRefs(graphic, gridOrigin, yVec, xVec, repetitions.y, repetitions.x);\n    }\n\n    // don't draw grid plane if perpendicular to view\n    if (viewZ.isPerpendicularTo(xVec))\n      return;\n\n    // grid refs or points will give visual indication of grid plane...\n    // note: references to same points here are okay\n    const shapePoints: Point3d[] = [\n      gridOrigin,\n      gridOrigin.plusScaled(xVec, repetitions.x),\n      gridOrigin.plus2Scaled(xVec, repetitions.x, yVec, repetitions.y),\n      gridOrigin.plusScaled(yVec, repetitions.y),\n      gridOrigin,\n    ];\n\n    if (0 === gridsPerRef) {\n      graphic.setSymbology(lineColor, planeColor, 1, linePat);\n      graphic.addLineString(shapePoints);\n    }\n\n    graphic.setBlankingFill(planeColor);\n    graphic.addShape(shapePoints);\n  }\n\n  /** Private grid-specific function for computing intersections of a ray with a convex set of clipping planes. */\n  private static getClipPlaneIntersection(clipDistance: { min: number, max: number }, origin: Point3d, direction: Vector3d, convexSet: ConvexClipPlaneSet): boolean {\n    clipDistance.min = -Number.MAX_VALUE;\n    clipDistance.max = Number.MAX_VALUE;\n\n    for (let i = 0; i < 6; i++) {\n      const plane = convexSet.planes[i];\n      const vD = plane.dotProductVector(direction);\n      const vN = plane.evaluatePoint(origin);\n\n      const testValue = -vN / vD;\n      if (vD > 0.0) {\n        if (testValue > clipDistance.min)\n          clipDistance.min = testValue;\n      } else if (vD < 0.0) {\n        if (testValue < clipDistance.max)\n          clipDistance.max = testValue;\n      }\n    }\n\n    return clipDistance.min < clipDistance.max;\n  }\n\n  private static drawGridDots(graphic: GraphicBuilder, doIsoGrid: boolean, origin: Point3d, rowVec: Vector3d, rowRepetitions: number, colVec: Vector3d, colRepetitions: number, refSpacing: number, vp: Viewport) {\n    const colSpacing = colVec.magnitude();\n    const colNormal = colVec.normalize();\n    if (!colNormal)\n      return;\n\n    const points: Point3d[] = [];\n\n    const cameraOn = vp.isCameraOn;\n    let zCamera = 0.0;\n    let zCameraLimit = 0.0;\n    const viewZ = Vector3d.create();\n\n    if (cameraOn) {\n      const view = vp.view as ViewState3d;\n      const camera = view.camera;\n      const sizeLimit = gridConstants.maxHorizon * colSpacing / vp.viewDelta.x;\n\n      vp.rotation.rowZ(viewZ);\n      zCamera = viewZ.dotProduct(camera.getEyePoint());\n      zCameraLimit = zCamera - camera.focusDist * sizeLimit;\n    }\n\n    const corners = vp.getFrustum();\n    const clipPlanes: ConvexClipPlaneSet = corners.getRangePlanes(true, true, 0);\n    const clipDistance = { min: 0, max: 0 };\n    for (let i = 0; i < rowRepetitions; i++) {\n      if (0 !== refSpacing && 0 === (i % refSpacing))\n        continue;\n\n      const dotOrigin = origin.plusScaled(rowVec, i);\n      if (DecorateContext.getClipPlaneIntersection(clipDistance, dotOrigin, colNormal, clipPlanes)) {\n        if (cameraOn) {\n          const startPoint = dotOrigin.plusScaled(colNormal, clipDistance.min);\n          const endPoint = dotOrigin.plusScaled(colNormal, clipDistance.max);\n          if (viewZ.dotProduct(startPoint) < zCameraLimit && viewZ.dotProduct(endPoint) < zCameraLimit)\n            continue;\n        }\n\n        let nToDisplay = 0;\n        let jMin = Math.floor(clipDistance.min / colSpacing);\n        let jMax = Math.ceil(clipDistance.max / colSpacing);\n\n        // Choose values that result in the least amount of dots between jMin-jMax and 0-colRepetitions...\n        jMin = jMin < 0 ? 0 : jMin;\n        jMax = jMax > colRepetitions ? colRepetitions : jMax;\n\n        const isoOffset = doIsoGrid && (i & 1) ? 0.5 : 0.0;\n        for (let j = jMin; j <= jMax && nToDisplay < gridConstants.maxDotsInRow; j++) {\n          if (0 !== refSpacing && 0 === (j % refSpacing))\n            continue;\n          const point = dotOrigin.plusScaled(colVec, j + isoOffset);\n          if (cameraOn) {\n            const pointZ = viewZ.dotProduct(point);\n            if (pointZ < zCamera && pointZ > zCameraLimit)\n              points.push(point);\n          } else {\n            points.push(point);\n          }\n          nToDisplay++;\n        }\n      }\n    }\n    if (points.length !== 0)\n      graphic.addPointString(points);\n  }\n\n  private static drawGridRefs(graphic: GraphicBuilder, org: Point3d, rowVec: Vector3d, colVec: Vector3d, rowRepetitions: number, colRepetitions: number) {\n    const gridEnd = org.plusScaled(colVec, colRepetitions);\n\n    for (let i = 0; i <= rowRepetitions; i += 1) {\n      const linePoints: Point3d[] = [\n        org.plusScaled(rowVec, i),\n        gridEnd.plusScaled(rowVec, i),\n      ];\n      graphic.addLineString(linePoints);\n    }\n  }\n\n  /** Display skyBox graphic that encompasses entire scene and rotates with camera.\n   * @see [[RenderSystem.createSkyBox]].\n   */\n  public setSkyBox(graphic: RenderGraphic) { this._decorations.skyBox = graphic; }\n\n  /** Set the graphic to be displayed behind all other geometry as the background of this context's [[Viewport]]. */\n  public setViewBackground(graphic: RenderGraphic) { this._decorations.viewBackground = graphic; }\n}\n\n/** Context used to create the scene for a [[Viewport]]. The scene consists of a set of [[RenderGraphic]]s produced by the\n * [[TileTree]]s visible within the viewport. Creating the scene may result in the enqueueing of [[TileRequest]]s for [[Tile]]s which\n * should be displayed in the viewport but are not yet loaded.\n * @internal\n */\nexport class SceneContext extends RenderContext {\n  public readonly graphics: RenderGraphic[] = [];\n  public readonly backgroundGraphics: RenderGraphic[] = [];\n  public readonly missingTiles = new Set<Tile>();\n  public hasMissingTiles = false; // ###TODO for asynchronous loading of child nodes...turn those into requests too.\n  public modelClassifiers = new Map<Id64String, Id64String>();    // Model id to classifier model Id.\n  public planarClassifiers?: PlanarClassifierMap;               // Classifier model id to planar classifier.\n  public solarShadowMap?: RenderSolarShadowMap;\n  public extendedFrustumPlane?: Plane3dByOriginAndUnitNormal;\n  private _tiledGraphicsProviderType?: TiledGraphicsProvider.Type;\n\n  public constructor(vp: Viewport, frustum?: Frustum) {\n    super(vp, frustum);\n  }\n  public get viewFrustum(): ViewFrustum | undefined {\n    return (undefined !== this.extendedFrustumPlane) ? ViewFrustum.createFromViewportAndPlane(this.viewport, this.extendedFrustumPlane) : this.viewport.viewFrustum;\n  }\n\n  public outputGraphic(graphic: RenderGraphic): void {\n    if (this._tiledGraphicsProviderType !== undefined) {\n      switch (this._tiledGraphicsProviderType) {\n        case TiledGraphicsProvider.Type.BackgroundMap:\n          this.backgroundGraphics.push(graphic);\n          break;\n        default:\n          assert(false, \"currently unsupported graphics provider type\");\n      }\n    } else {\n      this.graphics.push(graphic);\n    }\n  }\n\n  public insertMissingTile(tile: Tile): void {\n    switch (tile.loadStatus) {\n      case Tile.LoadStatus.NotLoaded:\n      case Tile.LoadStatus.Queued:\n      case Tile.LoadStatus.Loading:\n        this.missingTiles.add(tile);\n        break;\n    }\n  }\n\n  public requestMissingTiles(): void {\n    IModelApp.tileAdmin.requestTiles(this.viewport, this.missingTiles);\n  }\n  public set tiledGraphicsProviderType(providerType: TiledGraphicsProvider.Type | undefined) { this._tiledGraphicsProviderType = providerType; }\n  public getPlanarClassifier(id: Id64String): RenderPlanarClassifier | undefined { return this.planarClassifiers ? this.planarClassifiers.get(id) : undefined; }\n  public setPlanarClassifier(id: Id64String, planarClassifier: RenderPlanarClassifier) {\n    if (!this.planarClassifiers)\n      this.planarClassifiers = new Map<Id64String, RenderPlanarClassifier>();\n    this.planarClassifiers.set(id, planarClassifier);\n  }\n  public getPlanarClassifierForModel(modelId: Id64String) {\n    const classifierId = this.modelClassifiers.get(modelId);\n    return undefined === classifierId ? undefined : this.getPlanarClassifier(classifierId);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\nimport { BentleyStatus, BeEvent, BeUiEvent } from \"@bentley/bentleyjs-core\";\nimport { HitDetail } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { EventController } from \"./tools/EventController\";\nimport { BeButtonEvent, EventHandled } from \"./tools/Tool\";\nimport { DecorateContext } from \"./ViewContext\";\nimport { ScreenViewport } from \"./Viewport\";\nimport { GeometryStreamProps } from \"@bentley/imodeljs-common\";\n\n/** Interface for drawing \"decorations\" into, or on top of, the active [[Viewport]]s.\n * Decorators generate [[Decorations]].\n * @public\n */\nexport interface Decorator {\n  /** Implement this method to add Decorations into the supplied DecorateContext. */\n  decorate(context: DecorateContext): void;\n\n  /** If the [[decorate]] method created pickable graphics, return true if the supplied Id is from this Decorator.\n   * @param id The Id of the currently selected pickable graphics.\n   * @returns true if 'id' belongs to this Decorator\n   */\n  testDecorationHit?(id: string): boolean;\n\n  /** If [[testDecorationHit]] returned true, implement this method to return the tooltip message for this Decorator.\n   * @param hit The HitDetail about the decoration that was picked.\n   * @returns A promise with the HTMLElement or string (that may contain HTML) with the tooltip message.\n   */\n  getDecorationToolTip?(hit: HitDetail): Promise<HTMLElement | string>;\n\n  /** If [[testDecorationHit]] returned true, implement this method to handle a button event for this Decorator.\n   * @param hit The HitDetail about the decoration that was picked.\n   * @param ev The BeButtonEvent that identified this decoration.\n   * @returns  A Promise that resolves to Yes if event completely handled by decoration and event should not be processed by the calling tool.\n   */\n  onDecorationButtonEvent?(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled>;\n\n  /** If [[testDecorationHit]] returned true, implement this method to return the snappable geometry for this Decorator. Geometry that changes with every cursor motion isn't valid for snapping.\n   * An example would be an InteractiveTool for placing a linestring. It might wish to allow snapping to accepted segments, the segment from the last accepted point to the current cursor position would not be included\n   * as snappable geometry and would just be displayed in dynamics.\n   * @param hit The HitDetail about the decoration that was picked.\n   * @returns GeometryStreamProps containing world coordinate snappable geometry for this decoration.\n   */\n  getDecorationGeometry?(hit: HitDetail): GeometryStreamProps | undefined;\n}\n\n/** Argument for [[ViewManager.onSelectedViewportChanged]]\n * @public\n */\nexport interface SelectedViewportChangedArgs {\n  current?: ScreenViewport;\n  previous?: ScreenViewport;\n}\n\n/** The ViewManager holds the list of opened views, plus the *selected view*. It also provides notifications of view open/close and suspend/resume.\n * Applications must call [[addViewport]] when new Viewports that should be associated with user events are created.\n *\n * A single ViewManager is created when [[IModelApp.startup]] is called. It can be accessed via the static member [[IModelApp.viewManager]].\n *\n * The ViewManager controls the render loop, which causes the contents of each registered [[Viewport]] to update on the screen.\n * @public\n */\nexport class ViewManager {\n  public inDynamicsMode = false;\n  public cursor = \"default\";\n  private readonly _viewports: ScreenViewport[] = [];\n  public readonly decorators: Decorator[] = [];\n  private _selectedView?: ScreenViewport;\n  private _invalidateScenes = false;\n  private _skipSceneCreation = false;\n\n  /** @internal */\n  public onInitialized() {\n    this.addDecorator(IModelApp.accuSnap);\n    this.addDecorator(IModelApp.tentativePoint);\n    this.addDecorator(IModelApp.accuDraw);\n    this.addDecorator(IModelApp.toolAdmin);\n    this.cursor = \"default\";\n  }\n\n  /** @internal */\n  public onShutDown() {\n    this._viewports.length = 0;\n    this.decorators.length = 0;\n    this._selectedView = undefined;\n  }\n\n  /** Called after the selected view changes.\n   * @param old Previously selected viewport.\n   * @param current Currently selected viewport.\n   */\n  public readonly onSelectedViewportChanged = new BeUiEvent<SelectedViewportChangedArgs>();\n\n  /** Called after a view is opened. This can happen when the iModel is first opened or when a user opens a new view. */\n  public readonly onViewOpen = new BeUiEvent<ScreenViewport>();\n\n  /** Called after a view is closed. This can happen when the iModel is closed or when a user closes an open view. */\n  public readonly onViewClose = new BeUiEvent<ScreenViewport>();\n\n  /** Called after a view is suspended. This happens when the application is minimized or, on a tablet, when the application\n   * is moved to the background.\n   */\n  public readonly onViewSuspend = new BeUiEvent<ScreenViewport>();\n\n  /** Called after a suspended view is resumed. This can happen when a minimized application is restored\n   * or, on a tablet, when the application is moved to the foreground.\n   */\n  public readonly onViewResume = new BeUiEvent<ScreenViewport>();\n\n  /** Called at the beginning of each tick of the render loop, before any viewports have been updated.\n   * The render loop is typically invoked by a requestAnimationFrame() callback. It will not be invoked if the ViewManager is tracking no viewports.\n   * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.\n   * @see [[ViewManager.onFinishRender]]\n   */\n  public readonly onBeginRender = new BeEvent<() => void>();\n\n  /** Called at the end of each tick of the render loop, after all viewports have been updated.\n   * The render loop is typically invoked by a requestAnimationFrame() callback. It will not be invoked if the ViewManager is tracking no viewports.\n   * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.\n   * @see [[ViewManager.onBeginRender]]\n   */\n  public readonly onFinishRender = new BeEvent<() => void>();\n\n  /** @internal */\n  public endDynamicsMode(): void {\n    if (!this.inDynamicsMode)\n      return;\n\n    this.inDynamicsMode = false;\n\n    const cursorVp = IModelApp.toolAdmin.cursorView;\n    if (cursorVp)\n      cursorVp.changeDynamics(undefined);\n\n    for (const vp of this._viewports) {\n      if (vp !== cursorVp)\n        vp.changeDynamics(undefined);\n    }\n  }\n\n  /** @internal */\n  public beginDynamicsMode() { this.inDynamicsMode = true; }\n\n  /** @internal */\n  public get doesHostHaveFocus(): boolean { return document.hasFocus(); }\n\n  /** Set the selected [[Viewport]] to undefined. */\n  public clearSelectedView(): void {\n    const previousVp = this.selectedView;\n    this._selectedView = undefined;\n    this.notifySelectedViewportChanged(previousVp, undefined);\n  }\n\n  /** Sets the selected [[Viewport]]. */\n  public setSelectedView(vp: ScreenViewport | undefined): BentleyStatus {\n    if (undefined === vp)\n      vp = this.getFirstOpenView();\n\n    if (vp === this.selectedView) // already the selected view\n      return BentleyStatus.SUCCESS;\n\n    if (undefined === vp) {\n      this.clearSelectedView();\n      return BentleyStatus.ERROR;\n    }\n\n    const previousVp = this.selectedView;\n    this._selectedView = vp;\n\n    this.notifySelectedViewportChanged(previousVp, vp);\n\n    if (undefined === previousVp)\n      IModelApp.toolAdmin.startDefaultTool();\n\n    return BentleyStatus.SUCCESS;\n  }\n\n  /** @internal */\n  public notifySelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void {\n    IModelApp.toolAdmin.onSelectedViewportChanged(previous, current);\n    this.onSelectedViewportChanged.emit({ previous, current });\n  }\n\n  /** The \"selected view\" is the default for certain operations.  */\n  public get selectedView(): ScreenViewport | undefined { return this._selectedView; }\n\n  /** Get the first opened view. */\n  public getFirstOpenView(): ScreenViewport | undefined { return this._viewports.length > 0 ? this._viewports[0] : undefined; }\n\n  /** Add a new Viewport to the list of opened views and create an EventController for it.\n   * @param newVp the Viewport to add\n   * @returns SUCCESS if vp was successfully added, ERROR if it was already present.\n   * @note raises onViewOpen event with newVp.\n   */\n  public addViewport(newVp: ScreenViewport): BentleyStatus {\n    if (this._viewports.includes(newVp)) // make sure its not already added\n      return BentleyStatus.ERROR;\n\n    newVp.setEventController(new EventController(newVp)); // this will direct events to the viewport\n    this._viewports.push(newVp);\n\n    this.setSelectedView(newVp);\n\n    // Start up the render loop if necessary.\n    if (1 === this._viewports.length)\n      IModelApp.toolAdmin.startEventLoop();\n\n    this.onViewOpen.emit(newVp);\n\n    return BentleyStatus.SUCCESS;\n  }\n\n  /** Remove a Viewport from the list of opened views, and optionally dispose of it.\n   * Typically a Viewport is dropped when it is no longer of any use to the application, in which case it should also be\n   * disposed of as it may hold significant GPU resources.\n   * However in some cases a Viewport may be temporarily dropped to suspend rendering; and subsequently re-added to\n   * resume rendering - for example, when the Viewport is temporarily hidden by other UI elements.\n   * In the latter case it is up to the caller to ensure the Viewport is properly disposed of when it is no longer needed.\n   * Attempting to invoke any function on a Viewport after it has been disposed is an error.\n   * @param vp the Viewport to remove.\n   * @param disposeOfViewport Whether or not to dispose of the Viewport. Defaults to true.\n   * @return SUCCESS if vp was successfully removed, ERROR if it was not present.\n   * @note raises onViewClose event with vp.\n   */\n  public dropViewport(vp: ScreenViewport, disposeOfViewport: boolean = true): BentleyStatus {\n    const index = this._viewports.indexOf(vp);\n    if (index === -1)\n      return BentleyStatus.ERROR;\n\n    this.onViewClose.emit(vp);\n\n    // make sure tools don't think the cursor is still in this viewport\n    IModelApp.toolAdmin.onMouseLeave(vp); // tslint:disable-line:no-floating-promises\n\n    vp.setEventController(undefined);\n    this._viewports.splice(index, 1);\n\n    if (this.selectedView === vp) // if removed viewport was selectedView, set it to undefined.\n      this.setSelectedView(undefined);\n\n    if (disposeOfViewport)\n      vp.dispose();\n\n    return BentleyStatus.SUCCESS;\n  }\n\n  /** Call the specified function on each [[Viewport]] registered with the ViewManager. */\n  public forEachViewport(func: (vp: ScreenViewport) => void) { this._viewports.forEach((vp) => func(vp)); }\n\n  /** Force each registered [[Viewport]] to regenerate its [[Decorations]] on the next frame. */\n  public invalidateDecorationsAllViews(): void { this.forEachViewport((vp) => vp.invalidateDecorations()); }\n  /** @internal */\n  public onSelectionSetChanged(_iModel: IModelConnection) { this.forEachViewport((vp) => vp.markSelectionSetDirty()); }\n  /** @internal */\n  public invalidateViewportScenes(): void { this.forEachViewport((vp) => vp.sync.invalidateScene()); }\n  /** @internal */\n  public validateViewportScenes(): void { this.forEachViewport((vp) => vp.sync.setValidScene()); }\n\n  /** @internal */\n  public invalidateScenes(): void { this._invalidateScenes = true; }\n  /** @internal */\n  public get sceneInvalidated(): boolean { return this._invalidateScenes; }\n  /** @internal */\n  public onNewTilesReady(): void { this.invalidateScenes(); }\n\n  /** Invoked by ToolAdmin event loop.\n   * @internal\n   */\n  public renderLoop(): void {\n    if (0 === this._viewports.length) return;\n    if (this._skipSceneCreation)\n      this.validateViewportScenes();\n    else if (this._invalidateScenes)\n      this.invalidateViewportScenes();\n\n    this._invalidateScenes = false;\n\n    const cursorVp = IModelApp.toolAdmin.cursorView;\n\n    this.onBeginRender.raiseEvent();\n\n    if (undefined === cursorVp || cursorVp.renderFrame())\n      for (const vp of this._viewports)\n        if (vp !== cursorVp && !vp.renderFrame())\n          break;\n\n    this.onFinishRender.raiseEvent();\n  }\n\n  /** Add a new [[Decorator]] to display decorations into the active views.\n   * @param decorator The new decorator to add.\n   * @throws Error if decorator is already active.\n   * @returns a function that may be called to remove this decorator (in lieu of calling [[dropDecorator]].)\n   * @see [[dropDecorator]]\n   */\n  public addDecorator(decorator: Decorator): () => void {\n    if (this.decorators.includes(decorator))\n      throw new Error(\"decorator already registered\");\n\n    this.decorators.push(decorator);\n    this.invalidateDecorationsAllViews();\n    return () => { this.dropDecorator(decorator); };\n  }\n\n  /** Drop (remove) a [[Decorator]] so it is no longer active.\n   * @param decorator The Decorator to drop.\n   * @note Does nothing if decorator is not currently active.\n   */\n  public dropDecorator(decorator: Decorator) {\n    const index = this.decorators.indexOf(decorator);\n    if (index >= 0)\n      this.decorators.splice(index, 1);\n    this.invalidateDecorationsAllViews();\n  }\n\n  /** Get the tooltip for a pickable decoration.\n   * @internal\n   */\n  public async getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string> {\n    for (const decorator of this.decorators) {\n      if (undefined !== decorator.testDecorationHit && undefined !== decorator.getDecorationToolTip && decorator.testDecorationHit(hit.sourceId))\n        return decorator.getDecorationToolTip(hit);\n    }\n    return \"\";\n  }\n\n  /** Allow a pickable decoration to handle a button event that identified it for the SelectTool.\n   * @internal\n   */\n  public async onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled> {\n    for (const decorator of IModelApp.viewManager.decorators) {\n      if (undefined !== decorator.testDecorationHit && undefined !== decorator.onDecorationButtonEvent && decorator.testDecorationHit(hit.sourceId))\n        return decorator.onDecorationButtonEvent(hit, ev);\n    }\n    return EventHandled.No;\n  }\n\n  /** Allow a pickable decoration to be snapped to by AccuSnap or TentativePoint.\n   * @internal\n   */\n  public getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined {\n    for (const decorator of IModelApp.viewManager.decorators) {\n      if (undefined !== decorator.testDecorationHit && undefined !== decorator.getDecorationGeometry && decorator.testDecorationHit(hit.sourceId))\n        return decorator.getDecorationGeometry(hit);\n    }\n    return undefined;\n  }\n\n  public get crossHairCursor(): string { return \"url(cursors/crosshair.cur), crosshair\"; }\n  public get dynamicsCursor(): string { return \"url(cursors/dynamics.cur), move\"; }\n  public get grabCursor(): string { return \"url(cursors/openHand.cur), auto\"; }\n  public get grabbingCursor(): string { return \"url(cursors/closedHand.cur), auto\"; }\n\n  /** Change the cursor shown in all Viewports.\n   * @param cursor The new cursor to display. If undefined, the default cursor is used.\n   */\n  public setViewCursor(cursor: string = \"default\") {\n    if (cursor === this.cursor)\n      return;\n\n    this.cursor = cursor;\n    if (undefined !== this.selectedView) {\n      this.selectedView.setCursor(cursor);\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\n\nimport { assert, Id64, Id64String, JsonUtils, BeTimePoint } from \"@bentley/bentleyjs-core\";\nimport {\n  Angle, AxisOrder, ClipVector, Constant, Geometry, LowAndHighXY, LowAndHighXYZ, Map4d, Matrix3d, Plane3dByOriginAndUnitNormal,\n  Point2d, Point3d, PolyfaceBuilder, Range3d, Ray3d, StrokeOptions, Transform, Vector2d, Vector3d, XAndY, XYAndZ, YawPitchRollAngles,\n} from \"@bentley/geometry-core\";\nimport {\n  AnalysisStyle, AxisAlignedBox3d, Camera, ColorDef, Frustum, GraphicParams, Npc, RenderMaterial, SpatialViewDefinitionProps,\n  SubCategoryOverride, TextureMapping, ViewDefinition2dProps, ViewDefinition3dProps, ViewDefinitionProps,\n  ViewFlags, ViewStateProps,\n} from \"@bentley/imodeljs-common\";\nimport { AuxCoordSystem2dState, AuxCoordSystem3dState, AuxCoordSystemSpatialState, AuxCoordSystemState } from \"./AuxCoordSys\";\nimport { CategorySelectorState } from \"./CategorySelectorState\";\nimport { DisplayStyle2dState, DisplayStyle3dState, DisplayStyleState } from \"./DisplayStyleState\";\nimport { ElementState } from \"./EntityState\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { ModelSelectorState } from \"./ModelSelectorState\";\nimport { GeometricModel2dState, GeometricModelState, TileTreeModelState } from \"./ModelState\";\nimport { NotifyMessageDetails, OutputMessagePriority } from \"./NotificationManager\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { RenderScheduleState } from \"./RenderScheduleState\";\nimport { StandardView, StandardViewId } from \"./StandardView\";\nimport { TileTree } from \"./tile/TileTree\";\nimport { DecorateContext, SceneContext } from \"./ViewContext\";\nimport { Viewport, ViewFrustum } from \"./Viewport\";\nimport { SpatialClassification } from \"./SpatialClassification\";\nimport { TiledGraphicsProvider } from \"./TiledGraphicsProvider\";\n\n/** Describes the orientation of the grid displayed within a [[Viewport]].\n * @public\n */\nexport enum GridOrientationType {\n  /** Oriented with the view. */\n  View = 0,\n  /** Top */\n  WorldXY = 1,\n  /** Right */\n  WorldYZ = 2,\n  /** Front */\n  WorldXZ = 3,\n  /** Oriented by the [[AuxCoordSystem]] */\n  AuxCoord = 4,\n}\n\n/** Describes the result of a viewing operation such as those exposed by [[ViewState]] and [[Viewport]].\n * @public\n */\nexport enum ViewStatus {\n  Success = 0,\n  ViewNotInitialized,\n  AlreadyAttached,\n  NotAttached,\n  DrawFailure,\n  NotResized,\n  ModelNotFound,\n  InvalidWindow,\n  MinWindow,\n  MaxWindow,\n  MaxZoom,\n  MaxDisplayDepth,\n  InvalidUpVector,\n  InvalidTargetPoint,\n  InvalidLens,\n  InvalidViewport,\n}\n\n/** Margins for white space to be left around view volumes for [[ViewState.lookAtVolume]].\n * Values mean \"fraction of view size\" and must be between 0 and .25.\n * @public\n */\nexport class MarginPercent {\n  constructor(public left: number, public top: number, public right: number, public bottom: number) {\n    const limitMargin = (val: number) => Geometry.clamp(val, 0.0, 0.25);\n    this.left = limitMargin(left);\n    this.top = limitMargin(top);\n    this.right = limitMargin(right);\n    this.bottom = limitMargin(bottom);\n  }\n}\n\n/** Describes the largest and smallest values allowed for the extents of a [[ViewState]].\n * Attempts to exceed these limits in any dimension will fail, preserving the previous extents.\n * @public\n */\nexport interface ExtentLimits {\n  /** The smallest allowed extent in any dimension. */\n  min: number;\n  /** The largest allowed extent in any dimension. */\n  max: number;\n}\n\n/** @internal */\nexport abstract class ViewStateUndo {\n  public undoTime?: BeTimePoint;\n  public abstract equalState(view: ViewState): boolean;\n}\n\n/** @internal */\nclass ViewState3dUndo extends ViewStateUndo {\n  public readonly cameraOn: boolean;\n  public readonly origin: Point3d;\n  public readonly extents: Vector3d;\n  public readonly rotation: Matrix3d;\n  public readonly camera: Camera;\n\n  public constructor(view: ViewState3d) {\n    super();\n    this.cameraOn = view.isCameraOn;\n    this.origin = view.origin.clone();\n    this.extents = view.extents.clone();\n    this.rotation = view.rotation.clone();\n    this.camera = view.camera.clone();\n  }\n\n  public equalState(view: ViewState3d): boolean {\n    return this.cameraOn === view.isCameraOn &&\n      this.origin.isAlmostEqual(view.origin) &&\n      this.extents.isAlmostEqual(view.extents) &&\n      this.rotation.isAlmostEqual(view.rotation) &&\n      (!this.cameraOn || this.camera.equals(view.camera)); // ###TODO: should this be less precise equality?\n  }\n}\n\n/** @internal */\nclass ViewState2dUndo extends ViewStateUndo {\n  public readonly origin: Point2d;\n  public readonly delta: Point2d;\n  public readonly angle: Angle;\n  public constructor(view: ViewState2d) {\n    super();\n    this.origin = view.origin.clone();\n    this.delta = view.delta.clone();\n    this.angle = view.angle.clone();\n  }\n\n  public equalState(view: ViewState2d): boolean {\n    return this.origin.isAlmostEqual(view.origin) &&\n      this.delta.isAlmostEqual(view.delta) &&\n      this.angle.isAlmostEqualNoPeriodShift(view.angle);\n  }\n}\n\n/** The front-end state of a [[ViewDefinition]] element.\n * A ViewState is typically associated with a [[Viewport]] to display the contents of the view on the screen.\n * * @see [Views]($docs/learning/frontend/Views.md)\n * @public\n */\nexport abstract class ViewState extends ElementState {\n  /** @internal */\n  public static get className() { return \"ViewDefinition\"; }\n\n  private _auxCoordSystem?: AuxCoordSystemState;\n  private _extentLimits?: ExtentLimits;\n  private _clipVector?: ClipVector;\n  public description?: string;\n  public isPrivate?: boolean;\n  /** Selects the categories that are display by this ViewState. */\n  public categorySelector: CategorySelectorState;\n  /** Selects the styling parameters for this this ViewState. */\n  public displayStyle: DisplayStyleState;\n\n  /** @internal */\n  protected constructor(props: ViewDefinitionProps, iModel: IModelConnection, categoryOrClone: CategorySelectorState, displayStyle: DisplayStyleState) {\n    super(props, iModel);\n    this.description = props.description;\n    this.isPrivate = props.isPrivate;\n    this.displayStyle = displayStyle;\n    this.categorySelector = categoryOrClone;\n    if (!(categoryOrClone instanceof ViewState))  // is this from the clone method?\n      return; // not from clone\n\n    // from clone, 3rd argument is source ViewState\n    const source = categoryOrClone as ViewState;\n    this.categorySelector = source.categorySelector.clone();\n    this.displayStyle = source.displayStyle.clone();\n    this._extentLimits = source._extentLimits;\n    this._auxCoordSystem = source._auxCoordSystem;\n    this._clipVector = source._clipVector;\n  }\n\n  /** Create a new ViewState object from a set of properties. Generally this is called internally by [[IModelConnection.Views.load]] after the properties\n   * have been read from an iModel. But, it can also be used to create a ViewState in memory, from scratch or from properties stored elsewhere.\n   */\n  public static createFromProps(_props: ViewStateProps, _iModel: IModelConnection): ViewState | undefined { return undefined; }\n\n  /** Get the ViewFlags from the [[DisplayStyleState]] of this ViewState.\n   * @note Do not modify this object directly. Instead, use the setter as follows:\n   *\n   *  ```ts\n   *  const flags = viewState.viewFlags.clone();\n   *  flags.renderMode = RenderMode.SmoothShade; // or whatever alterations are desired\n   *  viewState.viewFlags = flags;\n   *  ```ts\n   */\n  public get viewFlags(): ViewFlags { return this.displayStyle.viewFlags; }\n  /** Get the AnalysisDisplayProperties from the displayStyle of this ViewState. */\n  public get analysisStyle(): AnalysisStyle | undefined { return this.displayStyle.analysisStyle; }\n\n  /** Get the RenderSchedule.Script from the displayStyle of this viewState */\n  public get scheduleScript(): RenderScheduleState.Script | undefined { return this.displayStyle.scheduleScript; }\n\n  /** Determine whether this ViewState exactly matches another. */\n  public equals(other: this): boolean { return super.equals(other) && this.categorySelector.equals(other.categorySelector) && this.displayStyle.equals(other.displayStyle); }\n\n  public toJSON(): ViewDefinitionProps {\n    const json = super.toJSON() as ViewDefinitionProps;\n    json.categorySelectorId = this.categorySelector.id;\n    json.displayStyleId = this.displayStyle.id;\n    json.isPrivate = this.isPrivate;\n    json.description = this.description;\n    return json;\n  }\n\n  /** Asynchronously load any required data for this ViewState from the backend.\n   * @note callers should await the Promise returned by this method before using this ViewState.\n   * @see [Views]($docs/learning/frontend/Views.md)\n   */\n  public async load(): Promise<void> {\n    this._auxCoordSystem = undefined;\n    const acsId = this.getAuxiliaryCoordinateSystemId();\n    if (Id64.isValid(acsId)) {\n      const props = await this.iModel.elements.getProps(acsId);\n      this._auxCoordSystem = AuxCoordSystemState.fromProps(props[0], this.iModel);\n    }\n\n    const subcategories = this.iModel.subcategories.load(this.categorySelector.categories);\n    if (undefined !== subcategories)\n      await subcategories.promise;\n\n    return Promise.resolve();\n  }\n\n  /** @internal */\n  public get areAllTileTreesLoaded(): boolean {\n    let allLoaded = true;\n    this.forEachTileTreeModel((model) => {\n      // Loaded or NotFound qualify as \"loaded\" - either the load succeeded or failed.\n      if (model.loadStatus < TileTree.LoadStatus.Loaded)\n        allLoaded = false;\n    });\n    return allLoaded;\n  }\n\n  /** Get the name of the [[ViewDefinition]] from which this ViewState originated. */\n  public get name(): string { return this.code.getValue(); }\n\n  /** Get this view's background color. */\n  public get backgroundColor(): ColorDef { return this.displayStyle.backgroundColor; }\n\n  /** Query the symbology overrides applied to geometry belonging to a specific subcategory when rendered using this ViewState.\n   * @param id The Id of the subcategory.\n   * @return The symbology overrides applied to all geometry belonging to the specified subcategory, or undefined if no such overrides exist.\n   */\n  public getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined {\n    return this.displayStyle.getSubCategoryOverride(id);\n  }\n\n  /** @internal */\n  public isSubCategoryVisible(id: Id64String): boolean {\n    const app = this.iModel.subcategories.getSubCategoryAppearance(id);\n    if (undefined === app)\n      return false;\n\n    const ovr = this.getSubCategoryOverride(id);\n    if (undefined === ovr || undefined === ovr.invisible)\n      return !app.invisible;\n    else\n      return !ovr.invisible;\n  }\n\n  /** Returns true if this ViewState is-a [[ViewState3d]] */\n  public is3d(): this is ViewState3d { return this instanceof ViewState3d; }\n  /** Returns true if this ViewState is-a [[ViewState2d]] */\n  public is2d(): this is ViewState2d { return this instanceof ViewState2d; }\n  /** Returns true if this ViewState is-a [[SpatialViewState]] */\n  public isSpatialView(): this is SpatialViewState { return this instanceof SpatialViewState; }\n  /** Returns true if [[ViewTool]]s are allowed to operate in three dimensions on this view. */\n  public abstract allow3dManipulations(): boolean;\n  /** @internal */\n  public abstract createAuxCoordSystem(acsName: string): AuxCoordSystemState;\n  /** Get the extents of this view in [[CoordSystem.World]] coordinates. */\n  public abstract getViewedExtents(): AxisAlignedBox3d;\n  /** Compute a range in [[CoordSystem.World]] coordinates that tightly encloses the contents of this view.\n   * @see [[FitViewTool]].\n   */\n  public abstract computeFitRange(): Range3d;\n\n  /** Override this if you want to perform some logic on each iteration of the render loop.\n   * @internal\n   */\n  public abstract onRenderFrame(_viewport: Viewport): void;\n\n  /** Returns true if this view displays the contents of a [[Model]] specified by Id. */\n  public abstract viewsModel(modelId: Id64String): boolean;\n\n  /** Get the origin of this view in [[CoordSystem.World]] coordinates. */\n  public abstract getOrigin(): Point3d;\n\n  /** Get the extents of this view in [[CoordSystem.World]] coordinates. */\n  public abstract getExtents(): Vector3d;\n\n  /** Get the 3x3 ortho-normal Matrix3d for this view. */\n  public abstract getRotation(): Matrix3d;\n\n  /** Set the origin of this view in [[CoordSystem.World]] coordinates. */\n  public abstract setOrigin(viewOrg: Point3d): void;\n\n  /** Set the extents of this view in [[CoordSystem.World]] coordinates. */\n  public abstract setExtents(viewDelta: Vector3d): void;\n\n  /** Change the rotation of the view.\n   * @note viewRot must be ortho-normal. For 2d views, only the rotation angle about the z axis is used.\n   */\n  public abstract setRotation(viewRot: Matrix3d): void;\n\n  /** Execute a function on each viewed model */\n  public abstract forEachModel(func: (model: GeometricModelState) => void): void;\n\n  /** @internal */\n  public abstract saveForUndo(): ViewStateUndo;\n\n  /** @internal */\n  public abstract setFromUndo(props: ViewStateUndo): void;\n\n  /** Execute a function on each viewed model\n   * @alpha\n   */\n  public forEachTileTreeModel(func: (model: TileTreeModelState) => void): void { this.forEachModel((model: GeometricModelState) => func(model)); }\n  /** @internal */\n  public createScene(context: SceneContext): void {\n    this.forEachTileTreeModel((model: TileTreeModelState) => this.addModelToScene(model, context));\n  }\n\n  /** @internal */\n  public createBackgroundMap(context: SceneContext): void {\n    const backgroundMapProvider = this.displayStyle.backgroundMap;\n    if (undefined !== backgroundMapProvider)\n      this.createGraphicsFromProvider(context, backgroundMapProvider, TiledGraphicsProvider.Type.BackgroundMap);\n  }\n  /** @internal */\n  private createGraphicsFromProvider(context: SceneContext, provider: TiledGraphicsProvider.Provider, type: TiledGraphicsProvider.Type) {\n    const tree = provider.getTileTree(context.viewport);\n    if (tree !== undefined) {\n      context.tiledGraphicsProviderType = type;\n      context.extendedFrustumPlane = tree.plane;\n      tree.tileTree.drawScene(context);\n      context.extendedFrustumPlane = undefined;\n      context.tiledGraphicsProviderType = undefined;\n    }\n  }\n  /** @internal */\n  public createProviderGraphics(context: SceneContext): void {\n    for (let type = TiledGraphicsProvider.Type.Geometry; type <= TiledGraphicsProvider.Type.Overlay; type++) {\n      const providers = context.viewport.getTiledGraphicsProviders(type);\n      if (providers !== undefined) {\n        for (const provider of providers)\n          this.createGraphicsFromProvider(context, provider, type);\n      }\n    }\n  }\n\n  /** @internal */\n  public createClassification(context: SceneContext): void {\n    this.forEachTileTreeModel((model: TileTreeModelState) => SpatialClassification.addModelClassifierToScene(model, context));\n  }\n\n  /** @internal */\n  public createSolarShadowMap(_context: SceneContext): void { }\n\n  /** Add view-specific decorations. The base implementation draws the grid. Subclasses must invoke super.decorate()\n   * @internal\n   */\n  public decorate(context: DecorateContext): void {\n    this.drawGrid(context);\n    if (undefined !== this.displayStyle.backgroundMapPlane)\n      this.displayStyle.backgroundMap.decorate(context);\n  }\n\n  /** @internal */\n  public static getStandardViewMatrix(id: StandardViewId): Matrix3d { return StandardView.getStandardRotation(id); }\n\n  /** Orient this view to one of the [[StandardView]] rotations. */\n  public setStandardRotation(id: StandardViewId) { this.setRotation(ViewState.getStandardViewMatrix(id)); }\n\n  /** Get the target point of the view. If there is no camera, center is returned. */\n  public getTargetPoint(result?: Point3d): Point3d { return this.getCenter(result); }\n\n  /**  Get the point at the geometric center of the view. */\n  public getCenter(result?: Point3d): Point3d {\n    const delta = this.getRotation().transpose().multiplyVector(this.getExtents());\n    return this.getOrigin().plusScaled(delta, 0.5, result);\n  }\n\n  /** @internal */\n  public drawGrid(context: DecorateContext): void {\n    const vp = context.viewport;\n    if (!vp.isGridOn)\n      return;\n\n    const orientation = this.getGridOrientation();\n    if (GridOrientationType.AuxCoord < orientation) {\n      return; // NEEDSWORK...\n    }\n    if (GridOrientationType.AuxCoord === orientation) {\n      this.auxiliaryCoordinateSystem.drawGrid(context);\n      return;\n    }\n\n    const isoGrid = false;\n    const gridsPerRef = this.getGridsPerRef();\n    const spacing = Point2d.createFrom(this.getGridSpacing());\n    const origin = Point3d.create();\n    const matrix = Matrix3d.createIdentity();\n    const fixedRepsAuto = Point2d.create();\n\n    this.getGridSettings(vp, origin, matrix, orientation);\n    context.drawStandardGrid(origin, matrix, spacing, gridsPerRef, isoGrid, orientation !== GridOrientationType.View ? fixedRepsAuto : undefined);\n  }\n\n  /** @internal */\n  public computeWorldToNpc(viewRot?: Matrix3d, inOrigin?: Point3d, delta?: Vector3d, enforceFrontToBackRatio = true): { map: Map4d | undefined, frustFraction: number } {\n    if (viewRot === undefined) viewRot = this.getRotation();\n    const xVector = viewRot.rowX();\n    const yVector = viewRot.rowY();\n    const zVector = viewRot.rowZ();\n\n    if (delta === undefined) delta = this.getExtents();\n    if (inOrigin === undefined) inOrigin = this.getOrigin();\n\n    let frustFraction = 1.0;\n    let xExtent: Vector3d;\n    let yExtent: Vector3d;\n    let zExtent: Vector3d;\n    let origin: Point3d;\n\n    // Compute root vectors along edges of view frustum.\n    if (this.is3d() && this.isCameraOn) {\n      const camera = this.camera;\n      const eyeToOrigin = Vector3d.createStartEnd(camera.eye, inOrigin); // vector from origin on backplane to eye\n      viewRot.multiplyVectorInPlace(eyeToOrigin);                        // align with view coordinates.\n\n      const focusDistance = camera.focusDist;\n      let zDelta = delta.z;\n      let zBack = eyeToOrigin.z;              // Distance from eye to backplane.\n      let zFront = zBack + zDelta;            // Distance from eye to frontplane.\n\n      if (enforceFrontToBackRatio && zFront / zBack < Viewport.nearScale24) {\n        // In this case we are running up against the zBuffer resolution limitation (currently 24 bits).\n        // Set back clipping plane at 10 kilometer which gives us a front clipping plane about 3 meters.\n        // Decreasing the maximumBackClip (MicroStation uses 1 kilometer) will reduce the minimum front\n        // clip, but also reduce the back clip (so far geometry may not be visible).\n        const maximumBackClip = 10 * Constant.oneKilometer;\n        if (-zBack > maximumBackClip) {\n          zBack = -maximumBackClip;\n          eyeToOrigin.z = zBack;\n        }\n\n        zFront = zBack * Viewport.nearScale24;\n        zDelta = zFront - eyeToOrigin.z;\n      }\n\n      // z out back of eye ===> origin z coordinates are negative.  (Back plane more negative than front plane)\n      const backFraction = -zBack / focusDistance;    // Perspective fraction at back clip plane.\n      const frontFraction = -zFront / focusDistance;  // Perspective fraction at front clip plane.\n      frustFraction = frontFraction / backFraction;\n\n      // delta.x,delta.y are view rectangle sizes at focus distance.  Scale to back plane:\n      xExtent = xVector.scale(delta.x * backFraction);   // xExtent at back == delta.x * backFraction.\n      yExtent = yVector.scale(delta.y * backFraction);   // yExtent at back == delta.y * backFraction.\n\n      // Calculate the zExtent in the View coordinate system.\n      zExtent = new Vector3d(eyeToOrigin.x * (frontFraction - backFraction), eyeToOrigin.y * (frontFraction - backFraction), zDelta);\n      viewRot.multiplyTransposeVectorInPlace(zExtent);   // rotate back to root coordinates.\n\n      origin = new Point3d(\n        eyeToOrigin.x * backFraction,   // Calculate origin in eye coordinates\n        eyeToOrigin.y * backFraction,\n        eyeToOrigin.z);\n\n      viewRot.multiplyTransposeVectorInPlace(origin);  // Rotate back to root coordinates\n      origin.plus(camera.eye, origin); // Add the eye point.\n    } else {\n      origin = inOrigin;\n      xExtent = xVector.scale(delta.x);\n      yExtent = yVector.scale(delta.y);\n      zExtent = zVector.scale(delta.z);\n    }\n\n    // calculate the root-to-npc mapping (using expanded frustum)\n    return { map: Map4d.createVectorFrustum(origin, xExtent, yExtent, zExtent, frustFraction), frustFraction };\n  }\n\n  /** Calculate the world coordinate Frustum from the parameters of this ViewState.\n   * @param result Optional Frustum to hold result. If undefined a new Frustum is created.\n   * @returns The 8-point Frustum with the corners of this ViewState, or undefined if the parameters are invalid.\n   */\n  public calculateFrustum(result?: Frustum): Frustum | undefined {\n    const val = this.computeWorldToNpc();\n    if (undefined === val.map)\n      return undefined;\n\n    const box = result ? result.initNpc() : new Frustum();\n    val.map.transform1.multiplyPoint3dArrayQuietNormalize(box.points);\n    return box;\n  }\n\n  /** Initialize the origin, extents, and rotation from an existing Frustum\n   * This function is commonly used in the implementation of [[ViewTool]]s as follows:\n   *  1. Obtain the ViewState's initial frustum.\n   *  2. Modify the frustum based on user input.\n   *  3. Update the ViewState to match the modified frustum.\n   * @param frustum the input Frustum.\n   * @return Success if the frustum was successfully updated, or an appropriate error code.\n   */\n  public setupFromFrustum(inFrustum: Frustum): ViewStatus {\n    const frustum = inFrustum.clone(); // make sure we don't modify input frustum\n    frustum.fixPointOrder();\n    const frustPts = frustum.points;\n    const viewOrg = frustPts[Npc.LeftBottomRear];\n\n    // frustumX, frustumY, frustumZ are vectors along edges of the frustum. They are NOT unit vectors.\n    // X and Y should be perpendicular, and Z should be right handed.\n    const frustumX = Vector3d.createFrom(frustPts[Npc.RightBottomRear].minus(viewOrg));\n    const frustumY = Vector3d.createFrom(frustPts[Npc.LeftTopRear].minus(viewOrg));\n    const frustumZ = Vector3d.createFrom(frustPts[Npc.LeftBottomFront].minus(viewOrg));\n\n    const frustMatrix = Matrix3d.createRigidFromColumns(frustumX, frustumY, AxisOrder.XYZ);\n    if (!frustMatrix)\n      return ViewStatus.InvalidWindow;\n\n    // if we're close to one of the standard views, adjust to it to remove any \"fuzz\"\n    StandardView.adjustToStandardRotation(frustMatrix);\n\n    const xDir = frustMatrix.getColumn(0);\n    const yDir = frustMatrix.getColumn(1);\n    const zDir = frustMatrix.getColumn(2);\n\n    // set up view Rotation matrix as rows of frustum matrix.\n    const viewRot = frustMatrix.inverse();\n    if (!viewRot)\n      return ViewStatus.InvalidWindow;\n\n    // Left handed frustum?\n    const zSize = zDir.dotProduct(frustumZ);\n    if (zSize < 0.0)\n      return ViewStatus.InvalidWindow;\n\n    const viewDiagRoot = new Vector3d();\n    viewDiagRoot.plus2Scaled(xDir, xDir.dotProduct(frustumX), yDir, yDir.dotProduct(frustumY), viewDiagRoot);  // vectors on the back plane\n    viewDiagRoot.plusScaled(zDir, zSize, viewDiagRoot);       // add in z vector perpendicular to x,y\n\n    // use center of frustum and view diagonal for origin. Original frustum may not have been orthogonal\n    frustum.getCenter().plusScaled(viewDiagRoot, -0.5, viewOrg);\n\n    // delta is in view coordinates\n    const viewDelta = viewRot.multiplyVector(viewDiagRoot);\n    this.validateViewDelta(viewDelta, false);\n\n    this.setOrigin(viewOrg);\n    this.setExtents(viewDelta);\n    this.setRotation(viewRot);\n    return ViewStatus.Success;\n  }\n\n  /** Get or set the largest and smallest values allowed for the extents for this ViewState\n   * The default limits vary based on the type of view:\n   *   - Spatial view extents cannot exceed the diameter of the earth.\n   *   - Drawing view extents cannot exceed twice the longest axis of the drawing model's range.\n   *   - Sheet view extents cannot exceed ten times the paper size of the sheet.\n   * Explicitly setting the extent limits overrides the default limits.\n   * @see [[resetExtentLimits]] to restore the default limits.\n   */\n  public get extentLimits(): ExtentLimits { return undefined !== this._extentLimits ? this._extentLimits : this.defaultExtentLimits; }\n  public set extentLimits(limits: ExtentLimits) { this._extentLimits = limits; }\n\n  /** Resets the largest and smallest values allowed for the extents of this ViewState to their default values.\n   * @see [[extentLimits]].\n   */\n  public resetExtentLimits(): void { this._extentLimits = undefined; }\n\n  /** Returns the default extent limits for this ViewState. These limits are used if the [[extentLimits]] have not been explicitly overridden.\n   */\n  public abstract get defaultExtentLimits(): ExtentLimits;\n\n  public setDisplayStyle(style: DisplayStyleState) { this.displayStyle = style; }\n  public getDetails(): any { if (!this.jsonProperties.viewDetails) this.jsonProperties.viewDetails = new Object(); return this.jsonProperties.viewDetails; }\n\n  /** @internal */\n  protected adjustAspectRatio(windowAspect: number): void {\n    const extents = this.getExtents();\n    const viewAspect = extents.x / extents.y;\n    windowAspect *= this.getAspectRatioSkew();\n\n    if (Math.abs(1.0 - (viewAspect / windowAspect)) < 1.0e-9)\n      return;\n\n    const oldDelta = extents.clone();\n    if (viewAspect > windowAspect)\n      extents.y = extents.x / windowAspect;\n    else\n      extents.x = extents.y * windowAspect;\n\n    let origin = this.getOrigin();\n    const trans = Transform.createOriginAndMatrix(Point3d.createZero(), this.getRotation());\n    const newOrigin = trans.multiplyPoint3d(origin);\n\n    newOrigin.x += ((oldDelta.x - extents.x) / 2.0);\n    newOrigin.y += ((oldDelta.y - extents.y) / 2.0);\n\n    origin = trans.inverse()!.multiplyPoint3d(newOrigin);\n    this.setOrigin(origin);\n    this.setExtents(extents);\n  }\n\n  /** @internal */\n  public showFrustumErrorMessage(status: ViewStatus): void {\n    let key: string;\n    switch (status) {\n      case ViewStatus.InvalidWindow: key = \"InvalidWindow\"; break;\n      case ViewStatus.MaxWindow: key = \"MaxWindow\"; break;\n      case ViewStatus.MinWindow: key = \"MinWindow\"; break;\n      case ViewStatus.MaxZoom: key = \"MaxZoom\"; break;\n      default:\n        return;\n    }\n    IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, IModelApp.i18n.translate(\"Viewing.\" + key)));\n  }\n\n  /** @internal */\n  public validateViewDelta(delta: Vector3d, messageNeeded?: boolean): ViewStatus {\n    const limit = this.extentLimits;\n    let error = ViewStatus.Success;\n\n    const limitWindowSize = (v: number, ignoreError: boolean) => {\n      if (v < limit.min) {\n        v = limit.min;\n        if (!ignoreError)\n          error = ViewStatus.MinWindow;\n      } else if (v > limit.max) {\n        v = limit.max;\n        if (!ignoreError)\n          error = ViewStatus.MaxWindow;\n      }\n      return v;\n    };\n\n    delta.x = limitWindowSize(delta.x, false);\n    delta.y = limitWindowSize(delta.y, false);\n    delta.z = limitWindowSize(delta.z, true);   // We ignore z error messages for the sake of 2D views\n\n    if (messageNeeded && error !== ViewStatus.Success)\n      this.showFrustumErrorMessage(error);\n\n    return error;\n  }\n\n  /** Returns the view detail associated with the specified name, or undefined if none such exists.\n   * @internal\n   */\n  public peekDetail(name: string): any { return this.getDetails()[name]; }\n\n  /** Get the current value of a view detail. If not present, returns an empty object.\n   * @internal\n   */\n  public getDetail(name: string): any { const v = this.getDetails()[name]; return v ? v : {}; }\n\n  /** Change the value of a view detail.\n   * @internal\n   */\n  public setDetail(name: string, value: any) { this.getDetails()[name] = value; }\n\n  /** Remove a view detail.\n   * @internal\n   */\n  public removeDetail(name: string) { delete this.getDetails()[name]; }\n\n  /** Set the CategorySelector for this view. */\n  public setCategorySelector(categories: CategorySelectorState) { this.categorySelector = categories; }\n\n  /** get the auxiliary coordinate system state object for this ViewState. */\n  public get auxiliaryCoordinateSystem(): AuxCoordSystemState {\n    if (!this._auxCoordSystem)\n      this._auxCoordSystem = this.createAuxCoordSystem(\"\");\n    return this._auxCoordSystem;\n  }\n\n  /** Get the Id of the auxiliary coordinate system for this ViewState */\n  public getAuxiliaryCoordinateSystemId(): Id64String { return Id64.fromJSON(this.getDetail(\"acs\")); }\n\n  /** Set or clear the AuxiliaryCoordinateSystem for this view.\n   * @param acs the new AuxiliaryCoordinateSystem for this view. If undefined, no AuxiliaryCoordinateSystem will be used.\n   */\n  public setAuxiliaryCoordinateSystem(acs?: AuxCoordSystemState) {\n    this._auxCoordSystem = acs;\n    if (acs)\n      this.setDetail(\"acs\", acs.id);\n    else\n      this.removeDetail(\"acs\");\n  }\n\n  /** Determine whether the specified Category is displayed in this view */\n  public viewsCategory(id: Id64String): boolean { return this.categorySelector.isCategoryViewed(id); }\n\n  /**  Get the aspect ratio (width/height) of this view */\n  public getAspectRatio(): number { const extents = this.getExtents(); return extents.x / extents.y; }\n\n  /** Get the aspect ratio skew (x/y, usually 1.0) that is used to exaggerate one axis of the view. */\n  public getAspectRatioSkew(): number { return JsonUtils.asDouble(this.getDetail(\"aspectSkew\"), 1.0); }\n\n  /** Set the aspect ratio skew (x/y) for this view. To remove aspect ratio skew, pass 1.0 for val. */\n  public setAspectRatioSkew(val: number) {\n    if (!val || val === 1.0) {\n      this.removeDetail(\"aspectSkew\");\n    } else {\n      this.setDetail(\"aspectSkew\", val);\n    }\n  }\n\n  /** Get the unit vector that points in the view X (left-to-right) direction.\n   * @param result optional Vector3d to be used for output. If undefined, a new object is created.\n   */\n  public getXVector(result?: Vector3d): Vector3d { return this.getRotation().getRow(0, result); }\n\n  /** Get the unit vector that points in the view Y (bottom-to-top) direction.\n   * @param result optional Vector3d to be used for output. If undefined, a new object is created.\n   */\n  public getYVector(result?: Vector3d): Vector3d { return this.getRotation().getRow(1, result); }\n\n  /** Get the unit vector that points in the view Z (front-to-back) direction.\n   * @param result optional Vector3d to be used for output. If undefined, a new object is created.\n   */\n  public getZVector(result?: Vector3d): Vector3d { return this.getRotation().getRow(2, result); }\n\n  /** Set or clear the clipping volume for this view.\n   * @param clip the new clipping volume. If undefined, clipping is removed from view.\n   * @note The ViewState takes ownership of the supplied ClipVector - it should not be modified after passing it to this function.\n   */\n  public setViewClip(clip?: ClipVector) {\n    this._clipVector = clip;\n    if (clip && clip.isValid)\n      this.setDetail(\"clip\", clip.toJSON());\n    else\n      this.removeDetail(\"clip\");\n  }\n\n  /** Get the clipping volume for this view, if defined\n   * @note Do *not* modify the returned ClipVector. If you wish to change the ClipVector, clone the returned ClipVector, modify it as desired, and pass the clone to [[setViewClip]].\n   */\n  public getViewClip(): ClipVector | undefined {\n    if (undefined === this._clipVector) {\n      const clip = this.peekDetail(\"clip\");\n      this._clipVector = (undefined !== clip ? ClipVector.fromJSON(clip) : ClipVector.createEmpty());\n    }\n    return this._clipVector.isValid ? this._clipVector : undefined;\n  }\n\n  /** Set the grid settings for this view */\n  public setGridSettings(orientation: GridOrientationType, spacing: Point2d, gridsPerRef: number): void {\n    switch (orientation) {\n      case GridOrientationType.WorldYZ:\n      case GridOrientationType.WorldXZ:\n        if (!this.is3d())\n          return;\n        break;\n    }\n\n    const details = this.getDetails();\n    JsonUtils.setOrRemoveNumber(details, \"gridOrient\", orientation, GridOrientationType.WorldXY);\n    JsonUtils.setOrRemoveNumber(details, \"gridPerRef\", gridsPerRef, 10);\n    JsonUtils.setOrRemoveNumber(details, \"gridSpaceX\", spacing.x, 1.0);\n    JsonUtils.setOrRemoveNumber(details, \"gridSpaceY\", spacing.y, spacing.x);\n  }\n\n  /** Populate the given origin and rotation with information from the grid settings from the grid orientation. */\n  public getGridSettings(vp: Viewport, origin: Point3d, rMatrix: Matrix3d, orientation: GridOrientationType) {\n    // start with global origin (for spatial views) and identity matrix\n    rMatrix.setIdentity();\n    origin.setFrom(vp.view.isSpatialView() ? vp.view.iModel.globalOrigin : Point3d.create());\n\n    switch (orientation) {\n      case GridOrientationType.View: {\n        const centerWorld = Point3d.create(0.5, 0.5, 0.5);\n        vp.npcToWorld(centerWorld, centerWorld);\n\n        rMatrix.setFrom(vp.rotation);\n        rMatrix.multiplyXYZtoXYZ(origin, origin);\n        origin.z = centerWorld.z;\n        rMatrix.multiplyTransposeVectorInPlace(origin);\n        break;\n      }\n      case GridOrientationType.WorldXY:\n        break;\n      case GridOrientationType.WorldYZ: {\n        const rowX = rMatrix.getRow(0);\n        const rowY = rMatrix.getRow(1);\n        const rowZ = rMatrix.getRow(2);\n        rMatrix.setRow(0, rowY);\n        rMatrix.setRow(1, rowZ);\n        rMatrix.setRow(2, rowX);\n        break;\n      }\n      case GridOrientationType.WorldXZ: {\n        const rowX = rMatrix.getRow(0);\n        const rowY = rMatrix.getRow(1);\n        const rowZ = rMatrix.getRow(2);\n        rMatrix.setRow(0, rowX);\n        rMatrix.setRow(1, rowZ);\n        rMatrix.setRow(2, rowY);\n        break;\n      }\n    }\n  }\n\n  /** Get the grid settings for this view */\n  public getGridOrientation(): GridOrientationType { return JsonUtils.asInt(this.getDetail(\"gridOrient\"), GridOrientationType.WorldXY); }\n  public getGridsPerRef(): number { return JsonUtils.asInt(this.getDetail(\"gridPerRef\"), 10); }\n  public getGridSpacing(): XAndY {\n    const x = JsonUtils.asInt(this.getDetail(\"gridSpaceX\"), 1.0);\n    return { x, y: JsonUtils.asInt(this.getDetail(\"gridSpaceY\"), x) };\n  }\n\n  /** Change the volume that this view displays, keeping its current rotation.\n   * @param volume The new volume, in world-coordinates, for the view. The resulting view will show all of worldVolume, by fitting a\n   * view-axis-aligned bounding box around it. For views that are not aligned with the world coordinate system, this will sometimes\n   * result in a much larger volume than worldVolume.\n   * @param aspect The X/Y aspect ratio of the view into which the result will be displayed. If the aspect ratio of the volume does not\n   * match aspect, the shorter axis is lengthened and the volume is centered. If aspect is undefined, no adjustment is made.\n   * @param margin The amount of \"white space\" to leave around the view volume (which essentially increases the volume\n   * of space shown in the view.) If undefined, no additional white space is added.\n   * @note for 2d views, only the X and Y values of volume are used.\n   */\n  public lookAtVolume(volume: LowAndHighXYZ | LowAndHighXY, aspect?: number, margin?: MarginPercent) {\n    const rangeBox = Frustum.fromRange(volume).points;\n    this.getRotation().multiplyVectorArrayInPlace(rangeBox);\n    return this.lookAtViewAlignedVolume(Range3d.createArray(rangeBox), aspect, margin);\n  }\n\n  /** Look at a volume of space defined by a range in view local coordinates, keeping its current rotation.\n   * @param volume The new volume, in view-coordinates, for the view. The resulting view will show all of volume.\n   * @param aspect The X/Y aspect ratio of the view into which the result will be displayed. If the aspect ratio of the volume does not\n   * match aspect, the shorter axis is lengthened and the volume is centered. If aspect is undefined, no adjustment is made.\n   * @param margin The amount of \"white space\" to leave around the view volume (which essentially increases the volume\n   * of space shown in the view.) If undefined, no additional white space is added.\n   * @see lookAtVolume\n   */\n  public lookAtViewAlignedVolume(volume: Range3d, aspect?: number, margin?: MarginPercent) {\n    if (volume.isNull) // make sure volume is valid\n      return;\n\n    const viewRot = this.getRotation();\n    const newOrigin = volume.low.clone();\n    let newDelta = Vector3d.createStartEnd(volume.low, volume.high);\n\n    const minimumDepth = Constant.oneMillimeter;\n    if (newDelta.z < minimumDepth) {\n      newOrigin.z -= (minimumDepth - newDelta.z) / 2.0;\n      newDelta.z = minimumDepth;\n    }\n\n    let origNewDelta = newDelta.clone();\n\n    const isCameraOn: boolean = this.is3d() && this.isCameraOn;\n    if (isCameraOn) {\n      // If the camera is on, the only way to guarantee we can see the entire volume is to set delta at the front plane, not focus plane.\n      // That generally causes the view to be too large (objects in it are too small), since we can't tell whether the objects are at\n      // the front or back of the view. For this reason, don't attempt to add any \"margin\" to camera views.\n    } else if (margin) {\n      // compute how much space we'll need for both of X and Y margins in root coordinates\n      const wPercent = margin.left + margin.right;\n      const hPercent = margin.top + margin.bottom;\n\n      const marginHorizontal = wPercent / (1 - wPercent) * newDelta.x;\n      const marginVert = hPercent / (1 - hPercent) * newDelta.y;\n\n      // compute left and bottom margins in root coordinates\n      const marginLeft = margin.left / (1 - wPercent) * newDelta.x;\n      const marginBottom = margin.bottom / (1 - hPercent) * newDelta.y;\n\n      // add the margins to the range\n      newOrigin.x -= marginLeft;\n      newOrigin.y -= marginBottom;\n      newDelta.x += marginHorizontal;\n      newDelta.y += marginVert;\n\n      // don't fix the origin due to changes in delta here\n      origNewDelta = newDelta.clone();\n    } else {\n      newDelta.scale(1.04, newDelta); // default \"dilation\"\n    }\n\n    if (isCameraOn) {\n      // make sure that the zDelta is large enough so that entire model will be visible from any rotation\n      const diag = newDelta.magnitudeXY();\n      if (diag > newDelta.z)\n        newDelta.z = diag;\n    }\n\n    this.validateViewDelta(newDelta, true);\n\n    this.setExtents(newDelta);\n    if (aspect)\n      this.adjustAspectRatio(aspect);\n\n    newDelta = this.getExtents();\n\n    newOrigin.x -= (newDelta.x - origNewDelta.x) / 2.0;\n    newOrigin.y -= (newDelta.y - origNewDelta.y) / 2.0;\n    newOrigin.z -= (newDelta.z - origNewDelta.z) / 2.0;\n\n    viewRot.multiplyTransposeVectorInPlace(newOrigin);\n    this.setOrigin(newOrigin);\n\n    if (!this.is3d())\n      return;\n\n    const cameraDef: Camera = this.camera;\n    cameraDef.validateLens();\n    // move the camera back so the entire x,y range is visible at front plane\n    const frontDist = Math.max(newDelta.x, newDelta.y) / (2.0 * Math.tan(cameraDef.getLensAngle().radians / 2.0));\n    const backDist = frontDist + newDelta.z;\n\n    cameraDef.setFocusDistance(frontDist); // do this even if the camera isn't currently on.\n    this.centerEyePoint(backDist); // do this even if the camera isn't currently on.\n    this.verifyFocusPlane(); // changes delta/origin\n  }\n\n  private addModelToScene(model: TileTreeModelState, context: SceneContext): void {\n    const animId = undefined !== this.scheduleScript ? this.scheduleScript.getModelAnimationId(model.treeModelId) : undefined;\n    model.loadTree(context.viewFlags.edgesRequired(), animId);\n    if (undefined !== model.tileTree)\n      model.tileTree.drawScene(context);\n  }\n\n  /** Set the rotation of this ViewState to the supplied rotation, by rotating it about a point.\n   * @param rotation The new rotation matrix for this ViewState.\n   * @param point The point to rotate about. If undefined, use the [[getTargetPoint]].\n   */\n  public setRotationAboutPoint(rotation: Matrix3d, point?: Point3d): void {\n    if (undefined === point)\n      point = this.getTargetPoint();\n\n    const inverse = rotation.clone().inverse();\n    if (undefined === inverse)\n      return;\n\n    const targetMatrix = inverse.multiplyMatrixMatrix(this.getRotation());\n    const worldTransform = Transform.createFixedPointAndMatrix(point, targetMatrix);\n    const frustum = this.calculateFrustum();\n    if (undefined !== frustum) {\n      frustum.multiply(worldTransform);\n      this.setupFromFrustum(frustum);\n    }\n  }\n}\n\n/** Defines the state of a view of 3d models.\n * @see [ViewState Parameters]($docs/learning/frontend/views#viewstate-parameters)\n * @public\n */\nexport abstract class ViewState3d extends ViewState {\n  /** @internal */\n  public static get className() { return \"ViewDefinition3d\"; }\n  /** True if the camera is valid. */\n  protected _cameraOn: boolean;\n  /** The lower left back corner of the view frustum. */\n  public readonly origin: Point3d;\n  /** The extent of the view frustum. */\n  public readonly extents: Vector3d;\n  /** Rotation of the view frustum. */\n  public readonly rotation: Matrix3d;\n  /** The camera used for this view. */\n  public readonly camera: Camera;\n  /** Minimum distance for front plane */\n  public forceMinFrontDist = 0.0;\n  public onRenderFrame(_viewport: Viewport): void { }\n  public allow3dManipulations(): boolean { return true; }\n  public constructor(props: ViewDefinition3dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState) {\n    super(props, iModel, categories, displayStyle);\n    this._cameraOn = JsonUtils.asBool(props.cameraOn);\n    this.origin = Point3d.fromJSON(props.origin);\n    this.extents = Vector3d.fromJSON(props.extents);\n    this.rotation = YawPitchRollAngles.fromJSON(props.angles).toMatrix3d();\n    assert(this.rotation.isRigid());\n    this.camera = new Camera(props.camera);\n  }\n\n  /** @internal */\n  public saveForUndo(): ViewStateUndo { return new ViewState3dUndo(this); }\n\n  /** @internal */\n  public setFromUndo(val: ViewState3dUndo) {\n    this._cameraOn = val.cameraOn;\n    this.origin.setFrom(val.origin);\n    this.extents.setFrom(val.extents);\n    this.rotation.setFrom(val.rotation);\n    this.camera.setFrom(val.camera);\n  }\n\n  public toJSON(): ViewDefinition3dProps {\n    const val = super.toJSON() as ViewDefinition3dProps;\n    val.cameraOn = this._cameraOn;\n    val.origin = this.origin;\n    val.extents = this.extents;\n    val.angles = YawPitchRollAngles.createFromMatrix3d(this.rotation)!.toJSON();\n    val.camera = this.camera;\n    return val;\n  }\n\n  public get isCameraOn(): boolean { return this._cameraOn; }\n  public setupFromFrustum(frustum: Frustum): ViewStatus {\n    const stat = super.setupFromFrustum(frustum);\n    if (ViewStatus.Success !== stat)\n      return stat;\n\n    this.turnCameraOff();\n    const frustPts = frustum.points;\n\n    // use comparison of back, front plane X sizes to indicate camera or flat view ...\n    const xBack = frustPts[Npc.LeftBottomRear].distance(frustPts[Npc.RightBottomRear]);\n    const xFront = frustPts[Npc.LeftBottomFront].distance(frustPts[Npc.RightBottomFront]);\n\n    const flatViewFractionTolerance = 1.0e-6;\n    if (xFront > xBack * (1.0 + flatViewFractionTolerance))\n      return ViewStatus.InvalidWindow;\n\n    // see if the frustum is tapered, and if so, set up camera eyepoint and adjust viewOrg and delta.\n    const compression = xFront / xBack;\n    if (compression >= (1.0 - flatViewFractionTolerance))\n      return ViewStatus.Success;\n\n    // the frustum has perspective, turn camera on\n    let viewOrg = frustPts[Npc.LeftBottomRear];\n    const viewDelta = this.getExtents().clone();\n    const zDir = this.getZVector();\n    const frustumZ = viewOrg.vectorTo(frustPts[Npc.LeftBottomFront]);\n    const frustOrgToEye = frustumZ.scale(1.0 / (1.0 - compression));\n    const eyePoint = viewOrg.plus(frustOrgToEye);\n\n    const backDistance = frustOrgToEye.dotProduct(zDir);         // distance from eye to back plane of frustum\n    const focusDistance = backDistance - (viewDelta.z / 2.0);\n    const focalFraction = focusDistance / backDistance;           // ratio of focus plane distance to back plane distance\n\n    viewOrg = eyePoint.plus2Scaled(frustOrgToEye, -focalFraction, zDir, focusDistance - backDistance);    // now project that point onto back plane\n    viewDelta.x *= focalFraction;                                  // adjust view delta for x and y so they are also at focus plane\n    viewDelta.y *= focalFraction;\n\n    this.setEyePoint(eyePoint);\n    this.setFocusDistance(focusDistance);\n    this.setOrigin(viewOrg);\n    this.setExtents(viewDelta);\n    this.setLensAngle(this.calcLensAngle());\n    this.enableCamera();\n    return ViewStatus.Success;\n  }\n\n  protected static calculateMaxDepth(delta: Vector3d, zVec: Vector3d): number {\n    const depthRatioLimit = 1.0E8;          // Limit for depth Ratio.\n    const maxTransformRowRatio = 1.0E5;\n    const minXYComponent = Math.min(Math.abs(zVec.x), Math.abs(zVec.y));\n    const maxDepthRatio = (0.0 === minXYComponent) ? depthRatioLimit : Math.min((maxTransformRowRatio / minXYComponent), depthRatioLimit);\n    return Math.max(delta.x, delta.y) * maxDepthRatio;\n  }\n\n  public getOrigin(): Point3d { return this.origin; }\n  public getExtents(): Vector3d { return this.extents; }\n  public getRotation(): Matrix3d { return this.rotation; }\n  public setOrigin(origin: XYAndZ) { this.origin.setFrom(origin); }\n  public setExtents(extents: XYAndZ) { this.extents.setFrom(extents); }\n  public setRotation(rot: Matrix3d) { this.rotation.setFrom(rot); }\n  /** @internal */\n  protected enableCamera(): void { if (this.supportsCamera()) this._cameraOn = true; }\n  public supportsCamera(): boolean { return true; }\n  public minimumFrontDistance() { return Math.max(15.2 * Constant.oneCentimeter, this.forceMinFrontDist); }\n  public isEyePointAbove(elevation: number): boolean { return !this._cameraOn ? (this.getZVector().z > 0) : (this.getEyePoint().z > elevation); }\n\n  public getDisplayStyle3d() { return this.displayStyle as DisplayStyle3dState; }\n\n  /** Turn the camera off for this view. After this call, the camera parameters in this view definition are ignored and views that use it will\n   * display with an orthographic (infinite focal length) projection of the view volume from the view direction.\n   * @note To turn the camera back on, call #lookAt\n   */\n  public turnCameraOff() { this._cameraOn = false; }\n\n  /** Determine whether the camera is valid for this view */\n  public get isCameraValid() { return this.camera.isValid; }\n\n  /** Calculate the lens angle formed by the current delta and focus distance */\n  public calcLensAngle(): Angle {\n    const maxDelta = Math.max(this.extents.x, this.extents.y);\n    return Angle.createRadians(2.0 * Math.atan2(maxDelta * 0.5, this.camera.getFocusDistance()));\n  }\n\n  /** Get the target point of the view. If there is no camera, view center is returned. */\n  public getTargetPoint(result?: Point3d): Point3d {\n    if (!this._cameraOn)\n      return super.getTargetPoint(result);\n\n    const viewZ = this.getRotation().getRow(2);\n    return this.getEyePoint().plusScaled(viewZ, -1.0 * this.getFocusDistance(), result);\n  }\n\n  /** Position the camera for this view and point it at a new target point.\n   * @param eyePoint The new location of the camera.\n   * @param targetPoint The new location to which the camera should point. This becomes the center of the view on the focus plane.\n   * @param upVector A vector that orients the camera's \"up\" (view y). This vector must not be parallel to the vector from eye to target.\n   * @param newExtents  The new size (width and height) of the view rectangle. The view rectangle is on the focus plane centered on the targetPoint.\n   * If newExtents is undefined, the existing size is unchanged.\n   * @param frontDistance The distance from the eyePoint to the front plane. If undefined, the existing front distance is used.\n   * @param backDistance The distance from the eyePoint to the back plane. If undefined, the existing back distance is used.\n   * @returns A [[ViewStatus]] indicating whether the camera was successfully positioned.\n   * @note If the aspect ratio of viewDelta does not match the aspect ratio of a Viewport into which this view is displayed, it will be\n   * adjusted when the [[Viewport]] is synchronized from this view.\n   */\n  public lookAt(eyePoint: XYAndZ, targetPoint: XYAndZ, upVector: Vector3d, newExtents?: XAndY, frontDistance?: number, backDistance?: number): ViewStatus {\n    const eye = new Point3d(eyePoint.x, eyePoint.y, eyePoint.z);\n    const yVec = upVector.normalize();\n    if (!yVec) // up vector zero length?\n      return ViewStatus.InvalidUpVector;\n\n    const zVec = Vector3d.createStartEnd(targetPoint, eye); // z defined by direction from eye to target\n    const focusDist = zVec.normalizeWithLength(zVec).mag; // set focus at target point\n    const minFrontDist = this.minimumFrontDistance();\n\n    if (focusDist <= minFrontDist) // eye and target are too close together\n      return ViewStatus.InvalidTargetPoint;\n\n    const xVec = new Vector3d();\n    if (yVec.crossProduct(zVec).normalizeWithLength(xVec).mag < Geometry.smallMetricDistance)\n      return ViewStatus.InvalidUpVector;    // up is parallel to z\n\n    if (zVec.crossProduct(xVec).normalizeWithLength(yVec).mag < Geometry.smallMetricDistance)\n      return ViewStatus.InvalidUpVector;\n\n    // we now have rows of the rotation matrix\n    const rotation = Matrix3d.createRows(xVec, yVec, zVec);\n\n    backDistance = backDistance ? backDistance : this.getBackDistance();\n    frontDistance = frontDistance ? frontDistance : this.getFrontDistance();\n\n    const delta = newExtents ? new Vector3d(Math.abs(newExtents.x), Math.abs(newExtents.y), this.extents.z) : this.extents.clone();\n\n    frontDistance = Math.max(frontDistance!, (.5 * Constant.oneMeter));\n    backDistance = Math.max(backDistance!, focusDist + (.5 * Constant.oneMeter));\n\n    if (backDistance < focusDist) // make sure focus distance is in front of back distance.\n      backDistance = focusDist + Constant.oneMillimeter;\n\n    if (frontDistance > focusDist)\n      frontDistance = focusDist - minFrontDist;\n\n    if (frontDistance < minFrontDist)\n      frontDistance = minFrontDist;\n\n    delta.z = (backDistance - frontDistance);\n\n    const frontDelta = delta.scale(frontDistance / focusDist);\n    const stat = this.validateViewDelta(frontDelta, false); // validate window size on front (smallest) plane\n    if (ViewStatus.Success !== stat)\n      return stat;\n\n    if (delta.z > ViewState3d.calculateMaxDepth(delta, zVec)) // make sure we're not zoomed out too far\n      return ViewStatus.MaxDisplayDepth;\n\n    // The origin is defined as the lower left of the view rectangle on the focus plane, projected to the back plane.\n    // Start at eye point, and move to center of back plane, then move left half of width. and down half of height\n    const origin = eye.plus3Scaled(zVec, -backDistance!, xVec, -0.5 * delta.x, yVec, -0.5 * delta.y);\n\n    this.setEyePoint(eyePoint);\n    this.setRotation(rotation);\n    this.setFocusDistance(focusDist);\n    this.setOrigin(origin);\n    this.setExtents(delta);\n    this.setLensAngle(this.calcLensAngle());\n    this.enableCamera();\n    return ViewStatus.Success;\n  }\n\n  /** Position the camera for this view and point it at a new target point, using a specified lens angle.\n   * @param eyePoint The new location of the camera.\n   * @param targetPoint The new location to which the camera should point. This becomes the center of the view on the focus plane.\n   * @param upVector A vector that orients the camera's \"up\" (view y). This vector must not be parallel to the vector from eye to target.\n   * @param fov The angle, in radians, that defines the field-of-view for the camera. Must be between .0001 and pi.\n   * @param frontDistance The distance from the eyePoint to the front plane. If undefined, the existing front distance is used.\n   * @param backDistance The distance from the eyePoint to the back plane. If undefined, the existing back distance is used.\n   * @returns [[ViewStatus]] indicating whether the camera was successfully positioned.\n   * @note The aspect ratio of the view remains unchanged.\n   */\n  public lookAtUsingLensAngle(eyePoint: Point3d, targetPoint: Point3d, upVector: Vector3d, fov: Angle, frontDistance?: number, backDistance?: number): ViewStatus {\n    const focusDist = eyePoint.vectorTo(targetPoint).magnitude();   // Set focus at target point\n\n    if (focusDist <= Constant.oneMillimeter)       // eye and target are too close together\n      return ViewStatus.InvalidTargetPoint;\n\n    if (fov.radians < .0001 || fov.radians > Math.PI)\n      return ViewStatus.InvalidLens;\n\n    const extent = 2.0 * Math.tan(fov.radians / 2.0) * focusDist;\n    const delta = Vector2d.create(this.extents.x, this.extents.y);\n    const longAxis = Math.max(delta.x, delta.y);\n    delta.scale(extent / longAxis, delta);\n\n    return this.lookAt(eyePoint, targetPoint, upVector, delta, frontDistance, backDistance);\n  }\n\n  /** Move the camera relative to its current location by a distance in camera coordinates.\n   * @param distance to move camera. Length is in world units, direction relative to current camera orientation.\n   * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n   */\n  public moveCameraLocal(distance: Vector3d): ViewStatus {\n    const distWorld = this.getRotation().multiplyTransposeVector(distance);\n    return this.moveCameraWorld(distWorld);\n  }\n\n  /** Move the camera relative to its current location by a distance in world coordinates.\n   * @param distance in world units.\n   * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n   */\n  public moveCameraWorld(distance: Vector3d): ViewStatus {\n    if (!this._cameraOn) {\n      this.origin.plus(distance, this.origin);\n      return ViewStatus.Success;\n    }\n\n    const newTarget = this.getTargetPoint().plus(distance);\n    const newEyePt = this.getEyePoint().plus(distance);\n    return this.lookAt(newEyePt, newTarget, this.getYVector());\n  }\n\n  /** Rotate the camera from its current location about an axis relative to its current orientation.\n   * @param angle The angle to rotate the camera.\n   * @param axis The axis about which to rotate the camera. The axis is a direction relative to the current camera orientation.\n   * @param aboutPt The point, in world coordinates, about which the camera is rotated. If aboutPt is undefined, the camera rotates in place\n   *  (i.e. about the current eyePoint).\n   * @note Even though the axis is relative to the current camera orientation, the aboutPt is in world coordinates, \\b not relative to the camera.\n   * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n   */\n  public rotateCameraLocal(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus {\n    const axisWorld = this.getRotation().multiplyTransposeVector(axis);\n    return this.rotateCameraWorld(angle, axisWorld, aboutPt);\n  }\n\n  /** Rotate the camera from its current location about an axis in world coordinates.\n   * @param angle The angle to rotate the camera.\n   * @param axis The world-based axis (direction) about which to rotate the camera.\n   * @param aboutPt The point, in world coordinates, about which the camera is rotated. If aboutPt is undefined, the camera rotates in place\n   *  (i.e. about the current eyePoint).\n   * @returns Status indicating whether the camera was successfully positioned. See values at [[ViewStatus]] for possible errors.\n   */\n  public rotateCameraWorld(angle: Angle, axis: Vector3d, aboutPt?: Point3d): ViewStatus {\n    const about = aboutPt ? aboutPt : this.getEyePoint();\n    const rotation = Matrix3d.createRotationAroundVector(axis, angle);\n    if (!rotation)\n      return ViewStatus.InvalidUpVector;    // Invalid axis given\n    const trans = Transform.createFixedPointAndMatrix(about, rotation);\n    const newTarget = trans.multiplyPoint3d(this.getTargetPoint());\n    const upVec = rotation!.multiplyVector(this.getYVector());\n    return this.lookAt(this.getEyePoint(), newTarget, upVec);\n  }\n\n  /** Get the distance from the eyePoint to the front plane for this view. */\n  public getFrontDistance(): number { return this.getBackDistance() - this.extents.z; }\n\n  /** Get the distance from the eyePoint to the back plane for this view. */\n  public getBackDistance(): number {\n    // backDist is the z component of the vector from the origin to the eyePoint .\n    const eyeOrg = this.origin.vectorTo(this.getEyePoint());\n    this.getRotation().multiplyVector(eyeOrg, eyeOrg);\n    return eyeOrg.z;\n  }\n\n  /** Place the eyepoint of the camera so it is aligned with the center of the view. This removes any 1-point perspective skewing that may be\n   * present in the current view.\n   * @param backDistance If defined, the new the distance from the eyepoint to the back plane. Otherwise the distance from the\n   * current eyepoint is used.\n   */\n  public centerEyePoint(backDistance?: number): void {\n    const eyePoint = this.getExtents().scale(0.5);\n    eyePoint.z = backDistance ? backDistance : this.getBackDistance();\n    const eye = this.getRotation().multiplyTransposeXYZ(eyePoint.x, eyePoint.y, eyePoint.z);\n    this.camera.setEyePoint(this.getOrigin().plus(eye));\n  }\n\n  /** Center the focus distance of the camera halfway between the front plane and the back plane, keeping the eyepoint,\n   * lens angle, rotation, back distance, and front distance unchanged.\n   * @note The focus distance, origin, and delta values are modified, but the view encloses the same volume and appears visually unchanged.\n   */\n  public centerFocusDistance(): void {\n    const backDist = this.getBackDistance();\n    const frontDist = this.getFrontDistance();\n    const eye = this.getEyePoint();\n    const target = eye.plusScaled(this.getZVector(), frontDist - backDist);\n    this.lookAtUsingLensAngle(eye, target, this.getYVector(), this.getLensAngle(), frontDist, backDist);\n  }\n\n  /** Ensure the focus plane lies between the front and back planes. If not, center it. */\n  public verifyFocusPlane(): void {\n    if (!this._cameraOn)\n      return;\n\n    let backDist = this.getBackDistance();\n    const frontDist = backDist - this.extents.z;\n    const camera = this.camera;\n    const extents = this.extents;\n    const rot = this.rotation;\n\n    if (backDist <= 0.0 || frontDist <= 0.0) {\n      // the camera location is invalid. Set it based on the view range.\n      const tanAngle = Math.tan(camera.lens.radians / 2.0);\n      backDist = extents.z / tanAngle;\n      camera.setFocusDistance(backDist / 2);\n      this.centerEyePoint(backDist);\n      return;\n    }\n\n    const focusDist = camera.focusDist;\n    if (focusDist > frontDist && focusDist < backDist)\n      return;\n\n    // put it halfway between front and back planes\n    camera.setFocusDistance((extents.z / 2.0) + frontDist);\n\n    // moving the focus plane means we have to adjust the origin and delta too (they're on the focus plane, see diagram above)\n    const ratio = camera.focusDist / focusDist;\n    extents.x *= ratio;\n    extents.y *= ratio;\n    camera.eye.plus3Scaled(rot.rowZ(), -backDist, rot.rowX(), -0.5 * extents.x, rot.rowY(), -0.5 * extents.y, this.origin); // this centers the camera too\n  }\n\n  /** Get the current location of the eyePoint for camera in this view. */\n  public getEyePoint(): Point3d { return this.camera.eye; }\n\n  /** Get the lens angle for this view. */\n  public getLensAngle(): Angle { return this.camera.lens; }\n\n  /** Set the lens angle for this view.\n   *  @param angle The new lens angle in radians. Must be greater than 0 and less than pi.\n   *  @note This does not change the view's current field-of-view. Instead, it changes the lens that will be used if the view\n   *  is subsequently modified and the lens angle is used to position the eyepoint.\n   *  @note To change the field-of-view (i.e. \"zoom\") of a view, pass a new viewDelta to #lookAt\n   */\n  public setLensAngle(angle: Angle): void { this.camera.setLensAngle(angle); }\n\n  /** Change the location of the eyePoint for the camera in this view.\n   * @param pt The new eyepoint.\n   * @note This method is generally for internal use only. Moving the eyePoint arbitrarily can result in skewed or illegal perspectives.\n   * The most common method for user-level camera positioning is #lookAt.\n   */\n  public setEyePoint(pt: XYAndZ): void { this.camera.setEyePoint(pt); }\n\n  /** Set the focus distance for this view.\n   *  @note Changing the focus distance changes the plane on which the delta.x and delta.y values lie. So, changing focus distance\n   *  without making corresponding changes to delta.x and delta.y essentially changes the lens angle, causing a \"zoom\" effect\n   */\n  public setFocusDistance(dist: number): void { this.camera.setFocusDistance(dist); }\n\n  /**  Get the distance from the eyePoint to the focus plane for this view. */\n  public getFocusDistance(): number { return this.camera.focusDist; }\n  public createAuxCoordSystem(acsName: string): AuxCoordSystemState { return AuxCoordSystem3dState.createNew(acsName, this.iModel); }\n\n  public decorate(context: DecorateContext): void {\n    super.decorate(context);\n    this.drawSkyBox(context);\n    this.drawGroundPlane(context);\n  }\n\n  /** @internal */\n  protected drawSkyBox(context: DecorateContext): void {\n    const style3d = this.getDisplayStyle3d();\n    if (!style3d.environment.sky.display)\n      return;\n\n    const vp = context.viewport;\n    const skyBoxParams = style3d.loadSkyBoxParams(vp.target.renderSystem, vp);\n    if (undefined !== skyBoxParams) {\n      const skyBoxGraphic = IModelApp.renderSystem.createSkyBox(skyBoxParams);\n      context.setSkyBox(skyBoxGraphic!);\n    }\n  }\n\n  /** Returns the ground elevation taken from the environment added with the global z position of this imodel. */\n  public getGroundElevation(): number {\n    const env = this.getDisplayStyle3d().environment;\n    return env.ground.elevation + this.iModel.globalOrigin.z;\n  }\n\n  /** Return the ground extents, which will originate either from the viewport frustum or the extents of the imodel. */\n  public getGroundExtents(vp?: Viewport): AxisAlignedBox3d {\n    const displayStyle = this.getDisplayStyle3d();\n    const extents = new Range3d();\n    if (!displayStyle.environment.ground.display)\n      return extents; // Ground plane is not enabled\n\n    const elevation = this.getGroundElevation();\n\n    if (undefined !== vp) {\n      const viewRay = Ray3d.create(Point3d.create(), vp.rotation.rowZ());\n      const xyPlane = Plane3dByOriginAndUnitNormal.create(Point3d.create(0, 0, elevation), Vector3d.create(0, 0, 1));\n\n      // first determine whether the ground plane is displayed in the view\n      const worldFrust = vp.getFrustum();\n      for (const point of worldFrust.points) {\n        viewRay.origin = point;   // We never modify the reference\n        const xyzPoint = Point3d.create();\n        const param = viewRay.intersectionWithPlane(xyPlane!, xyzPoint);\n        if (param === undefined)\n          return extents;   // View does not show ground plane\n      }\n    }\n\n    extents.setFrom(this.iModel.projectExtents);\n    extents.low.z = extents.high.z = elevation;\n\n    const center = extents.low.interpolate(.5, extents.high);\n\n    const radius = extents.low.distance(extents.high);\n    extents.setNull();\n    extents.extendPoint(center);  // Extents now contains single point\n    extents.low.addScaledInPlace(Vector3d.create(-1, -1, -1), radius);\n    extents.high.addScaledInPlace(Vector3d.create(1, 1, 1), radius);\n    extents.low.z = extents.high.z = elevation;\n    return extents;\n  }\n\n  /** @internal */\n  protected drawGroundPlane(context: DecorateContext): void {\n    const extents = this.getGroundExtents(context.viewport);\n    if (extents.isNull)\n      return;\n\n    const ground = this.getDisplayStyle3d().environment.ground;\n    if (!ground.display)\n      return;\n\n    const points: Point3d[] = [extents.low.clone(), extents.low.clone(), extents.high.clone(), extents.high.clone()];\n    points[1].x = extents.high.x;\n    points[3].x = extents.low.x;\n\n    const aboveGround = this.isEyePointAbove(extents.low.z);\n    const gradient = ground.getGroundPlaneGradient(aboveGround);\n    const texture = context.viewport.target.renderSystem.getGradientTexture(gradient, this.iModel);\n    if (!texture)\n      return;\n\n    const matParams = new RenderMaterial.Params();\n    matParams.diffuseColor = ColorDef.white;\n    matParams.shadows = false;\n    matParams.ambient = 1;\n    matParams.diffuse = 0;\n\n    const mapParams = new TextureMapping.Params();\n    const transform = new TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0);\n    mapParams.textureMatrix = transform;\n    mapParams.textureMatrix.setTransform();\n    matParams.textureMapping = new TextureMapping(texture, mapParams);\n    const material = context.viewport.target.renderSystem.createMaterial(matParams, this.iModel);\n    if (!material)\n      return;\n\n    const params = new GraphicParams();\n    params.setLineColor(gradient.keys[0].color);\n    params.setFillColor(ColorDef.white);  // Fill should be set to opaque white for gradient texture...\n    params.material = material;\n\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration);\n    builder.activateGraphicParams(params);\n\n    /// ### TODO: Until we have more support in geometry package for tracking UV coordinates of higher level geometry\n    // we will use a PolyfaceBuilder here to add the ground plane as a quad, claim the polyface, and then send that to the GraphicBuilder\n    const strokeOptions = new StrokeOptions();\n    strokeOptions.needParams = true;\n    const polyfaceBuilder = PolyfaceBuilder.create(strokeOptions);\n    polyfaceBuilder.toggleReversedFacetFlag();\n    const uvParams: Point2d[] = [Point2d.create(0, 0), Point2d.create(1, 0), Point2d.create(1, 1), Point2d.create(0, 1)];\n    polyfaceBuilder.addQuadFacet(points, uvParams);\n    const polyface = polyfaceBuilder.claimPolyface(false);\n\n    builder.addPolyface(polyface, true);\n    context.addDecorationFromBuilder(builder);\n  }\n}\n\n/** Defines a view of one or more SpatialModels.\n * The list of viewed models is stored by the ModelSelector.\n * @public\n */\nexport class SpatialViewState extends ViewState3d {\n  /** @internal */\n  public static get className() { return \"SpatialViewDefinition\"; }\n  public modelSelector: ModelSelectorState;\n\n  public static createFromProps(props: ViewStateProps, iModel: IModelConnection): ViewState | undefined {\n    const cat = new CategorySelectorState(props.categorySelectorProps, iModel);\n    const displayStyleState = new DisplayStyle3dState(props.displayStyleProps, iModel);\n    const modelSelectorState = new ModelSelectorState(props.modelSelectorProps!, iModel);\n\n    // use \"new this\" so subclasses are correct.\n    return new this(props.viewDefinitionProps as SpatialViewDefinitionProps, iModel, cat, displayStyleState, modelSelectorState);\n  }\n\n  constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, arg3: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState) {\n    super(props, iModel, arg3, displayStyle);\n    this.modelSelector = modelSelector;\n    if (arg3 instanceof SpatialViewState) { // from clone\n      this.modelSelector = arg3.modelSelector.clone();\n    }\n  }\n\n  public equals(other: this): boolean { return super.equals(other) && this.modelSelector.equals(other.modelSelector); }\n\n  public createAuxCoordSystem(acsName: string): AuxCoordSystemState { return AuxCoordSystemSpatialState.createNew(acsName, this.iModel); }\n  public get defaultExtentLimits() { return { min: Constant.oneMillimeter, max: Constant.diameterOfEarth }; }\n\n  public computeFitRange(): AxisAlignedBox3d {\n    // Loop over the current models in the model selector with loaded tile trees and union their ranges\n    const range = new Range3d();\n    this.forEachTileTreeModel((model: TileTreeModelState) => {   // ...if we don't want to fit context reality models this should cal forEachSpatialTileTreeModel...\n      const tileTree = model.tileTree;\n      if (tileTree !== undefined && tileTree.rootTile !== undefined) {\n        const contentRange = tileTree.rootTile.computeWorldContentRange();\n        assert(!contentRange.isNull);\n        assert(contentRange.intersectsRange(this.iModel.projectExtents));\n\n        range.extendRange(contentRange);\n      }\n    });\n\n    if (range.isNull)\n      range.setFrom(this.getViewedExtents());\n\n    range.ensureMinLengths(1.0);\n\n    return range;\n  }\n\n  public getViewedExtents(): AxisAlignedBox3d {\n    const extents = Range3d.fromJSON<AxisAlignedBox3d>(this.iModel.projectExtents);\n    extents.scaleAboutCenterInPlace(1.0001); // projectExtents. lying smack up against the extents is not excluded by frustum...\n    extents.extendRange(this.getGroundExtents());\n    return extents;\n  }\n\n  public toJSON(): SpatialViewDefinitionProps {\n    const val = super.toJSON() as SpatialViewDefinitionProps;\n    val.modelSelectorId = this.modelSelector.id;\n    return val;\n  }\n  public async load(): Promise<void> {\n    await super.load();\n    await this.displayStyle.loadContextRealityModels();\n    return this.modelSelector.load();\n  }\n  public viewsModel(modelId: Id64String): boolean { return this.modelSelector.containsModel(modelId); }\n  public clearViewedModels() { this.modelSelector.models.clear(); }\n  public addViewedModel(id: Id64String) { this.modelSelector.addModels(id); }\n  public removeViewedModel(id: Id64String) { this.modelSelector.dropModels(id); }\n\n  public forEachModel(func: (model: GeometricModelState) => void) {\n    for (const modelId of this.modelSelector.models) {\n      const model = this.iModel.models.getLoaded(modelId);\n      const model3d = undefined !== model ? model.asGeometricModel3d : undefined;\n      if (undefined !== model3d)\n        func(model3d);\n    }\n  }\n\n  /** @alpha */\n  public forEachTileTreeModel(func: (model: TileTreeModelState) => void): void {\n    this.displayStyle.forEachContextRealityModel((model: TileTreeModelState) => func(model));\n    this.forEachModel((model: TileTreeModelState) => func(model));\n  }\n\n  /** @internal */\n  public createSolarShadowMap(context: SceneContext): void {\n    context.solarShadowMap = undefined;\n    const displayStyle = this.getDisplayStyle3d();\n    if (IModelApp.renderSystem.options.displaySolarShadows && this.viewFlags.shadows && displayStyle !== undefined) {\n      const backgroundMapPlane = this.displayStyle.backgroundMapPlane;\n      const viewFrustum = (undefined === backgroundMapPlane) ? context.viewFrustum : ViewFrustum.createFromViewportAndPlane(context.viewport, backgroundMapPlane);\n      const solarDirection = displayStyle.sunDirection ? displayStyle.sunDirection : Vector3d.create(-1, -1, -1).normalize();\n      if (undefined !== viewFrustum) {\n        context.solarShadowMap = IModelApp.renderSystem.getSolarShadowMap(viewFrustum.getFrustum(), solarDirection!, displayStyle.settings.solarShadowsSettings, this.modelSelector, this.categorySelector, this.iModel);\n        context.solarShadowMap!.collectGraphics(context);\n      }\n    }\n  }\n}\n\n/** Defines a spatial view that displays geometry on the image plane using a parallel orthographic projection.\n * @public\n */\nexport class OrthographicViewState extends SpatialViewState {\n  /** @internal */\n  public static get className() { return \"OrthographicViewDefinition\"; }\n\n  constructor(props: SpatialViewDefinitionProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle3dState, modelSelector: ModelSelectorState) { super(props, iModel, categories, displayStyle, modelSelector); }\n\n  public supportsCamera(): boolean { return false; }\n}\n\n/** Defines the state of a view of a single 2d model.\n * @public\n */\nexport abstract class ViewState2d extends ViewState {\n  /** @internal */\n  public static get className() { return \"ViewDefinition2d\"; }\n  public readonly origin: Point2d;\n  public readonly delta: Point2d;\n  public readonly angle: Angle;\n  public readonly baseModelId: Id64String;\n  private _viewedExtents?: AxisAlignedBox3d;\n\n  public constructor(props: ViewDefinition2dProps, iModel: IModelConnection, categories: CategorySelectorState, displayStyle: DisplayStyle2dState) {\n    super(props, iModel, categories, displayStyle);\n    this.origin = Point2d.fromJSON(props.origin);\n    this.delta = Point2d.fromJSON(props.delta);\n    this.angle = Angle.fromJSON(props.angle);\n    this.baseModelId = Id64.fromJSON(props.baseModelId);\n  }\n\n  public toJSON(): ViewDefinition2dProps {\n    const val = super.toJSON() as ViewDefinition2dProps;\n    val.origin = this.origin;\n    val.delta = this.delta;\n    val.angle = this.angle;\n    val.baseModelId = this.baseModelId;\n    return val;\n  }\n\n  /** @internal */\n  public saveForUndo(): ViewStateUndo { return new ViewState2dUndo(this); }\n\n  /** @internal */\n  public setFromUndo(val: ViewState2dUndo) {\n    this.origin.setFrom(val.origin);\n    this.delta.setFrom(val.delta);\n    this.angle.setFrom(val.angle);\n  }\n\n  /** Return the model for this 2d view. */\n  public getViewedModel(): GeometricModel2dState | undefined {\n    const model = this.iModel.models.getLoaded(this.baseModelId);\n    if (model && !(model instanceof GeometricModel2dState))\n      return undefined;\n\n    return model;\n  }\n\n  public computeFitRange(): Range3d { return this.getViewedExtents(); }\n  public getViewedExtents(): AxisAlignedBox3d {\n    if (undefined === this._viewedExtents) {\n      const model = this.iModel.models.getLoaded(this.baseModelId) as GeometricModelState;\n      if (undefined !== model && model.isGeometricModel && undefined !== model.tileTree) {\n        this._viewedExtents = Range3d.create(model.tileTree.range.low, model.tileTree.range.high);\n        model.tileTree.location.multiplyRange(this._viewedExtents, this._viewedExtents);\n      }\n    }\n\n    return undefined !== this._viewedExtents ? this._viewedExtents : new Range3d();\n  }\n\n  public onRenderFrame(_viewport: Viewport): void { }\n  public async load(): Promise<void> {\n    await super.load();\n    return this.iModel.models.load(this.baseModelId);\n  }\n\n  public allow3dManipulations(): boolean { return false; }\n  public getOrigin() { return new Point3d(this.origin.x, this.origin.y); }\n  public getExtents() { return new Vector3d(this.delta.x, this.delta.y); }\n  public getRotation() { return Matrix3d.createRotationAroundVector(Vector3d.unitZ(), this.angle)!; }\n  public setExtents(delta: Vector3d) { this.delta.set(delta.x, delta.y); }\n  public setOrigin(origin: Point3d) { this.origin.set(origin.x, origin.y); }\n  public setRotation(rot: Matrix3d) { const xColumn = rot.getColumn(0); this.angle.setRadians(Math.atan2(xColumn.y, xColumn.x)); }\n  public viewsModel(modelId: Id64String) { return this.baseModelId.toString() === modelId.toString(); }\n  public forEachModel(func: (model: GeometricModelState) => void) {\n    const model = this.iModel.models.getLoaded(this.baseModelId);\n    const model2d = undefined !== model ? model.asGeometricModel2d : undefined;\n    if (undefined !== model2d)\n      func(model2d);\n  }\n  public createAuxCoordSystem(acsName: string): AuxCoordSystemState { return AuxCoordSystem2dState.createNew(acsName, this.iModel); }\n}\n\n/** A view of a DrawingModel\n * @public\n */\nexport class DrawingViewState extends ViewState2d {\n  /** @internal */\n  public static get className() { return \"DrawingViewDefinition\"; }\n  // Computed from the tile tree range once the tile tree is available; cached thereafter to avoid recomputing.\n  private _modelLimits?: ExtentLimits;\n\n  public static createFromProps(props: ViewStateProps, iModel: IModelConnection): ViewState | undefined {\n    const cat = new CategorySelectorState(props.categorySelectorProps, iModel);\n    const displayStyleState = new DisplayStyle2dState(props.displayStyleProps, iModel);\n    // use \"new this\" so subclasses are correct\n    return new this(props.viewDefinitionProps as ViewDefinition2dProps, iModel, cat, displayStyleState);\n  }\n\n  public get defaultExtentLimits() {\n    if (undefined !== this._modelLimits)\n      return this._modelLimits;\n\n    const model = this.getViewedModel();\n    const tree = undefined !== model ? model.tileTree : undefined;\n    if (undefined === tree)\n      return { min: Constant.oneMillimeter, max: Constant.diameterOfEarth };\n\n    this._modelLimits = { min: Constant.oneMillimeter, max: 2.0 * tree.range.maxLength() };\n    return this._modelLimits;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Views */\n\nimport { assert, BeDuration, BeEvent, BeTimePoint, compareStrings, dispose, Id64, Id64Arg, Id64Set, Id64String, IDisposable, SortedArray, StopWatch } from \"@bentley/bentleyjs-core\";\nimport {\n  Angle, AngleSweep, Arc3d, AxisOrder, Constant, Geometry, LowAndHighXY, LowAndHighXYZ, Map4d,\n  Matrix3d, Plane3dByOriginAndUnitNormal, Point2d, Point3d, Point4d, Range3d, Ray3d, SmoothTransformBetweenFrusta, Transform, Vector3d, XAndY, XYAndZ, XYZ,\n} from \"@bentley/geometry-core\";\nimport {\n  AnalysisStyle, AntiAliasPref, Camera, ColorDef, ElementProps, Frustum, Hilite, ImageBuffer, Npc, NpcCenter, NpcCorners,\n  Placement2d, Placement2dProps, Placement3d, PlacementProps, SubCategoryAppearance, SubCategoryOverride, ViewFlags,\n} from \"@bentley/imodeljs-common\";\nimport { AuxCoordSystemState } from \"./AuxCoordSys\";\nimport { DisplayStyleState } from \"./DisplayStyleState\";\nimport { ElementPicker, LocateOptions } from \"./ElementLocateManager\";\nimport { HitDetail, SnapDetail } from \"./HitDetail\";\nimport { IModelApp } from \"./IModelApp\";\nimport { IModelConnection } from \"./IModelConnection\";\nimport { ToolTipOptions } from \"./NotificationManager\";\nimport { FeatureSymbology } from \"./render/FeatureSymbology\";\nimport { GraphicType } from \"./render/GraphicBuilder\";\nimport { Decorations, GraphicList, Pixel, RenderPlan, RenderTarget } from \"./render/System\";\nimport { StandardView, StandardViewId } from \"./StandardView\";\nimport { SubCategoriesCache } from \"./SubCategoriesCache\";\nimport { Tile } from \"./tile/TileTree\";\nimport { EventController } from \"./tools/EventController\";\nimport { DecorateContext, SceneContext } from \"./ViewContext\";\nimport { GridOrientationType, MarginPercent, ViewState, ViewStatus, ViewStateUndo, ViewState2d } from \"./ViewState\";\nimport { ToolSettings } from \"./tools/Tool\";\nimport { TiledGraphicsProvider } from \"./TiledGraphicsProvider\";\n\n/** An object which customizes the appearance of Features within a [[Viewport]].\n * Only one FeatureOverrideProvider may be associated with a viewport at a time. Setting a new FeatureOverrideProvider replaces any existing provider.\n *\n * If the provider's internal state changes such that the Viewport should recompute the symbology overrides, the provider should notify the viewport by\n * calling [[Viewport.setFeatureOverrideProviderChanged]].\n * @see [[Viewport.featureOverrideProvider]]\n * @public\n */\nexport interface FeatureOverrideProvider {\n  /** Add to the supplied `overrides` any symbology overrides to be applied to the specified `viewport`. */\n  addFeatureOverrides(overrides: FeatureSymbology.Overrides, viewport: Viewport): void;\n}\n\n/** Viewport synchronization flags. Synchronization is handled internally - do not use directly.\n * @internal\n */\nexport class SyncFlags {\n  private _decorations = false;\n  private _scene = false;\n  private _renderPlan = false;\n  private _controller = false;\n  private _rotatePoint = false;\n  private _animationFraction = false;\n  private _redrawPending = false;\n  public get isValidDecorations(): boolean { return this._decorations; }\n  public get isValidScene(): boolean { return this._scene; }\n  public get isValidController(): boolean { return this._controller; }\n  public get isValidRenderPlan(): boolean { return this._renderPlan; }\n  public get isValidRotatePoint(): boolean { return this._rotatePoint; }\n  public get isValidAnimationFraction(): boolean { return this._animationFraction; }\n  public get isRedrawPending(): boolean { return this._redrawPending; }\n  public invalidateDecorations(): void { this._decorations = false; }\n  public invalidateScene(): void { this._scene = false; this.invalidateDecorations(); this.invalidateAnimationFraction(); }\n  public invalidateRenderPlan(): void { this._renderPlan = false; this.invalidateScene(); }\n  public invalidateController(): void { this._controller = false; this.invalidateRenderPlan(); }\n  public invalidateRotatePoint(): void { this._rotatePoint = false; }\n  public invalidateAnimationFraction(): void { this._animationFraction = false; }\n  public invalidateRedrawPending(): void { this._redrawPending = false; }\n  public setValidDecorations(): void { this._decorations = true; }\n  public setValidScene(): void { this._scene = true; }\n  public setValidController(): void { this._controller = true; }\n  public setValidRenderPlan(): void { this._renderPlan = true; }\n  public setValidRotatePoint(): void { this._rotatePoint = true; }\n  public setValidAnimationFraction(): void { this._animationFraction = true; }\n  public setRedrawPending(): void { this._redrawPending = true; }\n  public initFrom(other: SyncFlags): void { this._decorations = other._decorations; this._scene = other._scene; this._renderPlan = other._renderPlan; this._controller = other._controller; this._rotatePoint = other._rotatePoint; this._animationFraction = other._animationFraction; this._redrawPending = other._redrawPending; }\n}\n\n/** @see [[ChangeFlags]]\n * @beta\n */\nexport enum ChangeFlag {\n  None = 0,\n  AlwaysDrawn = 1 << 0,\n  NeverDrawn = 1 << 1,\n  ViewedCategories = 1 << 2,\n  ViewedModels = 1 << 3,\n  DisplayStyle = 1 << 4,\n  FeatureOverrideProvider = 1 << 5,\n  ViewedCategoriesPerModel = 1 << 6,\n  All = 0x0fffffff,\n  Overrides = ChangeFlag.All & ~ChangeFlag.ViewedModels,\n  Initial = ChangeFlag.ViewedCategories | ChangeFlag.ViewedModels | ChangeFlag.DisplayStyle,\n}\n\n/** Viewport event synchronization flags. Used primarily for tracking changes which affect the viewport's [[FeatureSymbology.Overrides]].\n * Each time [[Viewport.renderFrame]] is invoked, the effects of any changes to these flags will be applied, and corresponding events dispatched.\n * An individual flag is true if the corresponding Viewport state has changed and needs to be synchronized.\n * @beta\n */\nexport class ChangeFlags {\n  private _flags: ChangeFlag;\n\n  /** The set of always drawn elements has changed. */\n  public get alwaysDrawn() { return this.isSet(ChangeFlag.AlwaysDrawn); }\n  public setAlwaysDrawn() { this.set(ChangeFlag.AlwaysDrawn); }\n  /** The set of never drawn elements has changed. */\n  public get neverDrawn() { return this.isSet(ChangeFlag.NeverDrawn); }\n  public setNeverDrawn() { this.set(ChangeFlag.NeverDrawn); }\n  /** The set of displayed categories has changed. */\n  public get viewedCategories() { return this.isSet(ChangeFlag.ViewedCategories); }\n  public setViewedCategories() { this.set(ChangeFlag.ViewedCategories); }\n  /** The set of displayed models has changed. */\n  public get viewedModels() { return this.isSet(ChangeFlag.ViewedModels); }\n  public setViewedModels() { this.set(ChangeFlag.ViewedModels); }\n  /** The display style or its settings such as [ViewFlags]($common) have changed. */\n  public get displayStyle() { return this.isSet(ChangeFlag.DisplayStyle); }\n  public setDisplayStyle() { this.set(ChangeFlag.DisplayStyle); }\n  /** The [[FeatureOverrideProvider]] has changed, or its internal state has changed such that its overrides must be recomputed. */\n  public get featureOverrideProvider() { return this.isSet(ChangeFlag.FeatureOverrideProvider); }\n  public setFeatureOverrideProvider() { this.set(ChangeFlag.FeatureOverrideProvider); }\n  /** The [[PerModelCategoryVisibility.Overrides]] associated with the viewport have changed.\n   * @alpha\n   */\n  public get viewedCategoriesPerModel() { return this.isSet(ChangeFlag.ViewedCategoriesPerModel); }\n  public setViewedCategoriesPerModel() { this.set(ChangeFlag.ViewedCategoriesPerModel); }\n\n  public constructor(flags = ChangeFlag.Initial) { this._flags = flags; }\n\n  /** Return true if any of the specified flags are set. */\n  public isSet(flags: ChangeFlag): boolean { return 0 !== (this._flags & flags); }\n  /** Return true if all of the specified flags are set. */\n  public areAllSet(flags: ChangeFlag): boolean { return flags === (this._flags & flags); }\n  /** Set all of the specified flags. */\n  public set(flags: ChangeFlag): void { this._flags |= flags; }\n  /** Clear all of the specified flags. By default, clears all flags. */\n  public clear(flags: ChangeFlag = ChangeFlag.All): void { this._flags &= ~flags; }\n  /** Returns true if any flag affecting FeatureSymbology.Overrides is set. */\n  public get areFeatureOverridesDirty() { return this.isSet(ChangeFlag.Overrides); }\n  /** Returns true if any flag is set. */\n  public get hasChanges() { return this.isSet(ChangeFlag.All); }\n\n  public get value(): ChangeFlag { return this._flags; }\n}\n\n/** A rectangle in integer view coordinates with (0,0) corresponding to the top-left corner of the view.\n *\n * Increasing **x** moves from left to right, and increasing **y** moves from top to bottom.\n * @public\n */\nexport class ViewRect {\n  private _left!: number;\n  private _top!: number;\n  private _right!: number;\n  private _bottom!: number;\n\n  /** Construct a new ViewRect. */\n  public constructor(left = 0, top = 0, right = 0, bottom = 0) { this.init(left, top, right, bottom); }\n  /** The leftmost side of this ViewRect.  */\n  public get left(): number { return this._left; }\n  public set left(val: number) { this._left = Math.floor(val); }\n  /** The topmost side of this ViewRect. */\n  public get top(): number { return this._top; }\n  public set top(val: number) { this._top = Math.floor(val); }\n  /** The rightmost side of this ViewRect. */\n  public get right(): number { return this._right; }\n  public set right(val: number) { this._right = Math.floor(val); }\n  /** The bottommost side of this ViewRect. */\n  public get bottom(): number { return this._bottom; }\n  public set bottom(val: number) { this._bottom = Math.floor(val); }\n  /** True if this ViewRect has an area > 0. */\n  public get isNull(): boolean { return this.right <= this.left || this.bottom <= this.top; }\n  /** True if `!isNull` */\n  public get isValid(): boolean { return !this.isNull; }\n  /** The width (right-left) of this ViewRect. */\n  public get width() { return this.right - this.left; }\n  public set width(width: number) { this.right = this.left + width; }\n  /** The height (bottom-top) of this ViewRect. */\n  public get height() { return this.bottom - this.top; }\n  public set height(height: number) { this.bottom = this.top + height; }\n  /** The aspect ratio (width/height) of this ViewRect. */\n  public get aspect() { return this.isNull ? 1.0 : this.width / this.height; }\n  /** The area (width*height) of this ViewRect. */\n  public get area() { return this.isNull ? 0 : this.width * this.height; }\n  /** Initialize this ViewRect from its left/top/right/bottom parameters. */\n  public init(left: number, top: number, right: number, bottom: number) { this.left = left; this.bottom = bottom, this.right = right; this.top = top; }\n  /** Initialize this ViewRect from two points.\n   * @param topLeft The top-left corner.\n   * @param bottomRight The bottom-right corner.\n   */\n  public initFromPoints(topLeft: XAndY, bottomRight: XAndY): void { this.init(topLeft.x, topLeft.y, bottomRight.x, bottomRight.y); }\n  /** Initialize this ViewRect from a range.\n   * @param input The Range to use. `input.low` defines the top-left and `input.high` defines the bottom-right.\n   */\n  public initFromRange(input: LowAndHighXY): void { this.initFromPoints(input.low, input.high); }\n  /** Return true is this ViewRect is exactly equal to another ViewRect.\n   * @param other The other ViewRect to compare\n   */\n  public equals(other: ViewRect): boolean { return this.left === other.left && this.right === other.right && this.bottom === other.bottom && this.top === other.top; }\n  /** Initialize this ViewRect from another ViewRect. */\n  public setFrom(other: ViewRect): void { this.init(other.left, other.top, other.right, other.bottom); }\n  /** Duplicate this ViewRect.\n   * @param result Optional ViewRect for result. If undefined, a new ViewRect is created.\n   */\n  public clone(result?: ViewRect): ViewRect {\n    if (undefined !== result) {\n      result.setFrom(this);\n      return result;\n    }\n    return new ViewRect(this.left, this.top, this.right, this.bottom);\n  }\n  public extend(other: ViewRect) {\n    if (this.left > other.left) this.left = other.left;\n    if (this.top > other.top) this.top = other.top;\n    if (this.right < other.right) this.right = other.right;\n    if (this.bottom < other.bottom) this.bottom = other.bottom;\n  }\n\n  /** Inset this ViewRect by values in the x and y directions. Positive values make the ViewRect smaller, and negative values will make it larger.\n   * @param deltaX The distance to inset the ViewRect in the x direction.\n   * @param deltaY The distance to inset the ViewRect in the y direction.\n   */\n  public inset(deltaX: number, deltaY: number): void {\n    if (this.width - 2 * deltaX <= 0 || this.height - 2 * deltaY <= 0) {\n      this.init(0, 0, 0, 0);\n      return;\n    }\n    this._left += deltaX;\n    this._right -= deltaX;\n    this._top += deltaY;\n    this._bottom -= deltaY;\n  }\n\n  /** Inset this ViewRect by the same value in all directions.\n   * @param offset The distance to inset this ViewRect. Positive values will make this ViewRect smaller and negative values will make it larger.\n   * @note The inset operation can cause a previously valid ViewRect to become invalid.\n   */\n  public insetUniform(offset: number): void { this.inset(offset, offset); }\n\n  /** Scale this ViewRect about its center by the supplied scale factors. */\n  public scaleAboutCenter(xScale: number, yScale: number): void {\n    const w = this.width;\n    const h = this.height;\n    const xDelta = (w - (w * xScale)) * 0.5;\n    const yDelta = (h - (h * yScale)) * 0.5;\n    this.inset(xDelta, yDelta);\n  }\n\n  /** Inset this ViewRect by a percentage of its current width.\n   * @param percent The percentage of this ViewRect's width to inset in all directions.\n   * @note The ViewRect will become smaller (or larger, if percent is negative) by `percent * width * 2` in each direction, since each side is moved by that distance.\n   * @see [[inset]]\n   */\n  public insetByPercent(percent: number): void { this.insetUniform(this.width * percent); }\n\n  /** Determine if this ViewRect is entirely contained within the bounds of another ViewRect. */\n  public isContained(other: ViewRect): boolean { return this.left >= other.left && this.right <= other.right && this.bottom <= other.bottom && this.top >= other.top; }\n\n  /** Return true if the supplied point is contained in this ViewRect.\n   * @param point The point to test.\n   * @note if the point is exactly on the left or top edges, this method returns true. If the point is exactly on the right or bottom edge, it returns false.\n   */\n  public containsPoint(point: XAndY): boolean { return point.x >= this.left && point.x < this.right && point.y >= this.top && point.y < this.bottom; }\n\n  /** Determine whether this ViewRect overlaps another. */\n  public overlaps(other: ViewRect): boolean { return this.left <= other.right && this.top <= other.bottom && this.right >= other.left && this.bottom >= other.top; }\n\n  /** Return a ViewRect that is the overlap (intersection) of this ViewRect and another ViewRect.\n   * If the two ViewRects are equal, their value is the result. Otherwise, the result will always be smaller than either of them.\n   */\n  public computeOverlap(other: ViewRect, out?: ViewRect): ViewRect | undefined {\n    const maxOrgX = Math.max(this.left, other.left);\n    const maxOrgY = Math.max(this.top, other.top);\n    const minCrnX = Math.min(this.right, other.right);\n    const minCrnY = Math.min(this.bottom, other.bottom);\n\n    if (maxOrgX > minCrnX || maxOrgY > minCrnY)\n      return undefined;\n\n    const result = undefined !== out ? out : new ViewRect();\n    result.left = maxOrgX;\n    result.right = minCrnX;\n    result.top = maxOrgY;\n    result.bottom = minCrnY;\n    return result;\n  }\n}\n\n/** The minimum and maximum values for the z-depth of a rectangle of screen space.\n * Values are in [[CoordSystem.Npc]] so they will be between 0 and 1.0.\n * @public\n */\nexport interface DepthRangeNpc {\n  /** The value closest to the back. */\n  minimum: number;\n  /** The value closest to the front. */\n  maximum: number;\n}\n\n/** Coordinate system types\n * @public\n */\nexport enum CoordSystem {\n  /** Coordinates are relative to the origin of the viewing rectangle.\n   * x and y values correspond to pixels within that rectangle, with (x=0,y=0) corresponding to the top-left corner.\n   */\n  View,\n\n  /** Coordinates are in [Normalized Plane Coordinates]($docs/learning/glossary.md#npc). NPC is a coordinate system\n   * for frustums in which each dimension [x,y,z] is normalized to hold values between 0.0 and 1.0.\n   * [0,0,0] corresponds to the left-bottom-rear and [1,1,1] to the right-top-front of the frustum.\n   */\n  Npc,\n\n  /** Coordinates are in the coordinate system of the models in the view. For SpatialViews, this is the iModel's spatial coordinate system.\n   * For 2d views, it is the coordinate system of the GeometricModel2d that the view shows.\n   */\n  World,\n}\n\n/** Object to animate a Frustum transition of a viewport. The [[Viewport]] will show as many frames as necessary during the supplied duration.\n * @see [[Viewport.animateFrustumChange]]\n */\nclass Animator {\n  private readonly _currFrustum = new Frustum();\n  private _startTime?: BeTimePoint;\n  private _interpolator?: SmoothTransformBetweenFrusta;\n  private moveToTime(time: number) { this.interpolateFrustum(time / this.totalTime.milliseconds); }\n\n  /** Construct a new Animator.\n   * @param totalTime The duration of the animation.\n   * @param viewport The Viewport to animate.\n   * @param startFrustum The Viewport's starting Frustum at the beginning of the animation.\n   * @param endFrustum The Viewport's ending Frustum after the animation.\n   */\n  public constructor(public totalTime: BeDuration, public viewport: Viewport, public startFrustum: Frustum, public endFrustum: Frustum) {\n    this._interpolator = SmoothTransformBetweenFrusta.create(startFrustum.points, endFrustum.points);\n  }\n\n  private interpolateFrustum(fraction: number): void {\n    this._interpolator!.fractionToWorldCorners(fraction, this._currFrustum.points);\n    this.viewport.setupViewFromFrustum(this._currFrustum);\n  }\n\n  /**\n   * Move to the appropriate frame, based on the current time, for the current animation.\n   * @return true when finished to terminate the animation.\n   */\n  public animate(): boolean {\n    if (!this._interpolator) {\n      this.viewport.setupViewFromFrustum(this.endFrustum);\n      return true;\n    }\n\n    const currTime = BeTimePoint.now();\n    if (!this._startTime)\n      this._startTime = currTime;\n\n    const totalTimeMillis = this.totalTime.milliseconds;\n    const endTime = this._startTime.milliseconds + totalTimeMillis;\n\n    if (endTime <= currTime.milliseconds) {\n      this.moveToTime(totalTimeMillis);\n      return true;\n    }\n\n    let done = false;\n    let index = currTime.milliseconds - this._startTime.milliseconds;\n    if (index > totalTimeMillis) {\n      done = true;\n      index = totalTimeMillis;\n    }\n\n    this.moveToTime(index);\n    return done;\n  }\n\n  /** Abort this animation, moving immediately to the final frame. */\n  public interrupt(): void {\n    if (this._startTime)\n      this.moveToTime(this.totalTime.milliseconds); // We've been interrupted after animation began. Skip to the final animation state\n  }\n}\n\n/** Status for [[ViewportAnimator.animate]].\n * @public\n */\nexport enum RemoveMe { No = 0, Yes = 1 }\n\n/** An object to animate a transition of a [[Viewport]].\n * Only one animator may be associated with a viewport at a time. Registering a new\n * animator replaces any existing animator.\n * The animator's animate() function will be invoked just prior to the rendering of each frame.\n * The return value of animate() indicates whether to keep the animator active or to remove it.\n * The animator may also be removed in response to certain changes to the viewport - e.g., when\n * the viewport is closed, or its view controller changed, etc.\n * @public\n */\nexport interface ViewportAnimator {\n  /** Apply animation to the viewport. Return `RemoveMe.Yes` when animation is completed, causing the animator to be removed from the viewport. */\n  animate(viewport: Viewport): RemoveMe;\n\n  /** Invoked when this ViewportAnimator is removed from the viewport, e.g. because it was replaced by a new animator, the viewport was closed -\n   * that is, for any reason other than returning RemoveMe.Yes from animate()\n   */\n  onInterrupted(viewport: Viewport): void;\n}\n\n/** A ViewportAnimator that animates decorations. While the animator is\n * active, decorations will be invalidated on each frame. The animator's\n * animateDecorations() function will be invoked to update any animation state; then\n * decorations will be re-requested and rendered.\n * @alpha\n */\nexport class DecorationAnimator implements ViewportAnimator {\n  private _start: BeTimePoint;\n  private _stop: BeTimePoint;\n\n  constructor(duration: BeDuration) {\n    this._start = BeTimePoint.now();\n    this._stop = this._start.plus(duration);\n  }\n\n  /** Override to update animation state, which can then be used on the next call to produce decorations.\n   * @param viewport The viewport being animated\n   * @param durationPercent The ratio of duration elapsed, in [0.0,1.0]\n   * @returns RemoveMe.Yes to immediately remove this animator, RemoveMe::No to continue animating until duration elapsed or animator interrupted.\n   * If this animator is interrupted, this function will be immediately invoked with durationPercent=1.0.\n   */\n  public animateDecorations(_viewport: Viewport, _durationPercent: number): RemoveMe { return RemoveMe.No; }\n\n  public animate(vp: Viewport): RemoveMe {\n    vp.invalidateDecorations();\n    const total = this._stop.milliseconds - this._start.milliseconds;\n    const elapsed = BeTimePoint.now().milliseconds - this._start.milliseconds;\n    const ratio = Math.min(elapsed / total, 1.0);\n    const removeMe = this.animateDecorations(vp, ratio);\n    return (RemoveMe.Yes === removeMe || ratio === 1.0) ? RemoveMe.Yes : RemoveMe.No;\n  }\n\n  public onInterrupted(vp: Viewport): void {\n    vp.invalidateDecorations();\n    this.animateDecorations(vp, 1.0);\n  }\n}\n\n/** Options that control how operations that change a view work.\n * @public\n */\nexport interface ViewChangeOptions {\n  /** Whether to save the result of this change into the view undo stack. Default is yes. */\n  saveInUndo?: boolean;\n  /** Whether the change should be animated or not. Default is yes. */\n  animateFrustumChange?: boolean;\n  /** Amount of time for animation. Default = `ToolSettings.animationTime` */\n  animationTime?: BeDuration;\n  /** The percentage of the view to leave blank around the edges. */\n  marginPercent?: MarginPercent;\n}\n\n/** Options to allow changing the view rotation with zoomTo methods.\n * @public\n */\nexport interface ZoomToOptions {\n  /** Set view rotation from standard view identifier. */\n  standardViewId?: StandardViewId;\n  /** Set view rotation relative to placement of first element or props entry. */\n  placementRelativeId?: StandardViewId;\n  /** Set view rotation from Matrix3d. */\n  viewRotation?: Matrix3d;\n}\n\n/** Options for changing the viewed Model of a 2d view via [[Viewport.changeViewedModel2d]]\n * @public\n */\nexport interface ChangeViewedModel2dOptions {\n  /** If true, perform a \"fit view\" operation after changing to the new 2d model. */\n  doFit?: boolean;\n}\n\n/** Supplies facilities for interacting with a [[Viewport]]'s frustum.\n * @internal\n */\nexport class ViewFrustum {\n  private static get2dFrustumDepth() { return Constant.oneMeter; }\n\n  private readonly _viewCorners: Range3d = new Range3d();\n  private readonly _aspectRatioLocked: boolean;\n  /** @internal */\n  public frustFraction: number = 1.0;\n  /** Maximum ratio of frontplane to backplane distance for 24 bit zbuffer */\n  public static nearScale24 = 0.0003;\n\n  /** View origin, potentially expanded */\n  public readonly viewOrigin = new Point3d();\n  /** View delta, potentially expanded */\n  public readonly viewDelta = new Vector3d();\n  /** View origin (from ViewState, unexpanded) */\n  public readonly viewOriginUnexpanded = new Point3d();\n  /** View delta (from ViewState, unexpanded) */\n  public readonly viewDeltaUnexpanded = new Vector3d();\n  /** View rotation matrix (copied from ViewState) */\n  public readonly rotation = new Matrix3d();\n  /** @internal */\n  public readonly worldToViewMap = Map4d.createIdentity();\n  /** @internal */\n  public readonly worldToNpcMap = Map4d.createIdentity();\n\n  /** @internal */\n  public readonly zClipAdjusted: boolean = false;    // were the view z clip planes adjusted due to front/back clipping off?\n  /** @internal */\n  public readonly invalidFrustum: boolean = false;\n\n  private _view: ViewState;\n\n  /** The ViewState for this Viewport */\n  public get view(): ViewState { return this._view; }\n  public set view(view: ViewState) { this._view = view; }\n\n  private readonly _viewRange: ViewRect = new ViewRect();\n\n  private readonly _clientWidth: number;\n  private readonly _clientHeight: number;\n\n  private readonly _displayedPlane: Plane3dByOriginAndUnitNormal | undefined;\n\n  /** Get the rectangle of this Viewport in ViewCoordinates. */\n  private get _viewRect(): ViewRect { this._viewRange.init(0, 0, this._clientWidth, this._clientHeight); return this._viewRange; }\n\n  private static _copyOutput(from: XYZ, to?: XYZ) { let pt = from; if (to) { to.setFrom(from); pt = to; } return pt; }\n\n  /** @internal */\n  public toView(from: XYZ, to?: XYZ) { this.rotation.multiplyVectorInPlace(ViewFrustum._copyOutput(from, to)); }\n  /** @internal */\n  public fromView(from: XYZ, to?: XYZ) { this.rotation.multiplyTransposeVectorInPlace(ViewFrustum._copyOutput(from, to)); }\n\n  /** adjust the aspect ratio of the view volume to match the aspect ratio of the window of this Viewport.\n   *  modifies the point and vector given\n   *  @internal\n   */\n  protected adjustAspectRatio(origin: Point3d, delta: Vector3d) {\n    if (this._aspectRatioLocked)\n      return;\n\n    const windowAspect = this._viewRect.aspect * this.view.getAspectRatioSkew();\n    const viewAspect = delta.x / delta.y;\n\n    if (Math.abs(1.0 - (viewAspect / windowAspect)) < 1.0e-9)\n      return;\n\n    const oldDelta = delta.clone();\n    if (viewAspect > windowAspect)\n      delta.y = delta.x / windowAspect;\n    else\n      delta.x = delta.y * windowAspect;\n\n    const newOrigin = origin.clone();\n    this.toView(newOrigin);\n    newOrigin.x += ((oldDelta.x - delta.x) / 2.0);\n    newOrigin.y += ((oldDelta.y - delta.y) / 2.0);\n    this.fromView(newOrigin, origin);\n  }\n\n  /** Ensure the rotation matrix for this view is aligns the root z with the view out (i.e. a \"2d view\"). */\n  private alignWithRootZ() {\n    const zUp = Vector3d.unitZ();\n    if (zUp.isAlmostEqual(this.rotation.rowZ()))\n      return;\n    const r = this.rotation.transpose();\n    r.setColumn(2, zUp);\n    Matrix3d.createRigidFromMatrix3d(r, AxisOrder.ZXY, r);\n    r.transpose(this.rotation);\n    this.view.setRotation(this.rotation); // Don't let viewState and viewport rotation be different.\n  }\n\n  private validateCamera() {\n    const view = this.view;\n    if (!view.is3d())\n      return;\n\n    const camera = view.camera;\n    camera.validateLens();\n    if (camera.isFocusValid)\n      return;\n\n    const vDelta = view.getExtents();\n    const maxDelta = vDelta.x > vDelta.y ? vDelta.x : vDelta.y;\n    let focusDistance = maxDelta / (2.0 * Math.tan(camera.getLensAngle().radians / 2.0));\n\n    if (focusDistance < vDelta.z / 2.0)\n      focusDistance = vDelta.z / 2.0;\n\n    const eyePoint = new Point3d(vDelta.x / 2.0, vDelta.y / 2.0, (vDelta.z / 2.0) + focusDistance);\n\n    this.fromView(eyePoint);\n    eyePoint.plus(view.getOrigin(), eyePoint);\n    camera.setEyePoint(eyePoint);\n    camera.setFocusDistance(focusDistance);\n  }\n\n  /** Adjust the front and back planes to encompass the entire viewed volume */\n  private adjustZPlanes(origin: Point3d, delta: Vector3d): void {\n    const view = this.view;\n    if (!view.is3d()) // only necessary for 3d views\n      return;\n\n    let extents = view.getViewedExtents();\n\n    this.extendRangeForDisplayedPlane(extents);\n\n    if (extents.isNull)\n      return;\n\n    // convert viewed extents in world coordinates to min/max in view aligned coordinates\n    const viewTransform = Transform.createOriginAndMatrix(Point3d.createZero(), this.rotation);\n    const extFrust = Frustum.fromRange(extents);\n    extFrust.multiply(viewTransform);\n    extents = extFrust.toRange();\n\n    this.rotation.multiplyVectorInPlace(origin);       // put origin in view coordinates\n    origin.z = extents.low.z;           // set origin to back of viewed extents\n    delta.z = extents.high.z - origin.z; // and delta to front of viewed extents\n    this.rotation.multiplyTransposeVectorInPlace(origin);\n\n    if (!view.isCameraOn)\n      return;\n\n    // if the camera is on, we need to make sure that the viewed volume is not behind the eye\n    const eyeOrg = view.camera.getEyePoint().minus(origin);\n    this.rotation.multiplyVectorInPlace(eyeOrg);\n\n    // if the distance from the eye to origin in less than 1 meter, move the origin away from the eye. Usually, this means\n    // that the camera is outside the viewed extents and pointed away from it. There's nothing to see anyway.\n    if (eyeOrg.z < 1.0) {\n      this.rotation.multiplyVectorInPlace(origin);\n      origin.z -= (2.0 - eyeOrg.z);\n      this.rotation.multiplyTransposeVectorInPlace(origin);\n      delta.z = 1.0;\n      return;\n    }\n\n    // if part of the viewed extents are behind the eye, don't include that.\n    if (delta.z > eyeOrg.z)\n      delta.z = eyeOrg.z;\n  }\n\n  private extendRangeForDisplayedPlane(extents: Range3d) {\n    const view = this.view;\n    if (!view.is3d()) // only necessary for 3d views\n      return;\n\n    if (this._displayedPlane === undefined)\n      return;\n\n    const planeNormal = this._displayedPlane.getNormalRef();\n    const viewZ = this.rotation.getRow(2);\n    const onPlane = viewZ.crossProduct(planeNormal);   // vector on display plane.\n    if (onPlane.magnitude() > 1.0E-8) {\n      const intersect = new Point3d();\n      const frustum = new Frustum();\n      let includeHorizon = false;\n      const worldToNpc = this.view.computeWorldToNpc(this.rotation, this.viewOrigin, this.viewDelta, false /* if displaying background map, don't enforce front/back ratio as no Z-Buffer */).map as Map4d;\n      const minimumEyeDistance = 10.0;\n      const horizonDistance = 10000;\n      worldToNpc.transform1.multiplyPoint3dArrayQuietNormalize(frustum.points);\n\n      for (let i = 0; i < 4; i++) {\n        const frustumRay = Ray3d.createStartEnd(frustum.points[i + 4], frustum.points[i]);\n        const intersectDistance = frustumRay.intersectionWithPlane(this._displayedPlane, intersect);\n        if (intersectDistance !== undefined && (!view.isCameraOn || intersectDistance > 0.0))\n          extents.extend(intersect);\n        else includeHorizon = true;\n      }\n      if (includeHorizon) {\n        const rangeCenter = extents.fractionToPoint(.5, .5, .5);\n        const normal = onPlane.unitCrossProduct(planeNormal) as Vector3d; // on plane and parallel to view Z.\n        extents.extend(rangeCenter.plusScaled(normal, horizonDistance));\n      }\n      if (view.isCameraOn) {\n        extents.extend(view.getEyePoint().plusScaled(viewZ, -minimumEyeDistance));\n      }\n\n    } else {\n      // display plane parallel to view....\n      extents.extend(this._displayedPlane.getOriginRef().plusScaled(planeNormal, -1.0));\n      extents.extend(this._displayedPlane.getOriginRef().plusScaled(planeNormal, 1.0));\n    }\n  }\n  private calcNpcToView(): Map4d {\n    const corners = this.getViewCorners();\n    const map = Map4d.createBoxMap(NpcCorners[Npc._000], NpcCorners[Npc._111], corners.low, corners.high);\n    assert(undefined !== map, \"undefined npcToViewMap\");\n    return undefined === map ? Map4d.createIdentity() : map;\n  }\n\n  /* Get the extents of this view, in ViewCoordinates, as a Range3d */\n  public getViewCorners(): Range3d {\n    const corners = this._viewCorners;\n    const viewRect = this._viewRect;\n    corners.high.x = viewRect.right;\n    corners.low.y = viewRect.bottom;    // y's are swapped on the screen!\n    corners.low.x = 0;\n    corners.high.y = 0;\n    corners.low.z = -32767;\n    corners.high.z = 32767;\n    return corners;\n  }\n\n  private constructor(view: ViewState, clientWidth: number, clientHeight: number, aspectRatioLocked: boolean, displayedPlane?: Plane3dByOriginAndUnitNormal) {\n    this._view = view;\n    this._clientWidth = clientWidth;\n    this._clientHeight = clientHeight;\n    this._displayedPlane = displayedPlane;\n    this._aspectRatioLocked = aspectRatioLocked;\n\n    const origin = this.view.getOrigin().clone();\n    const delta = this.view.getExtents().clone();\n    this.rotation.setFrom(this.view.getRotation());\n\n    // first, make sure none of the deltas are negative\n    delta.x = Math.abs(delta.x);\n    delta.y = Math.abs(delta.y);\n    delta.z = Math.abs(delta.z);\n\n    const limits = this.view.extentLimits;\n    const clampRange = (val: number) => Math.min(Math.max(limits.min, val), limits.max);\n    delta.x = clampRange(delta.x);\n    delta.y = clampRange(delta.y);\n\n    this.adjustAspectRatio(origin, delta);\n\n    this.viewOriginUnexpanded.setFrom(origin);\n    this.viewDeltaUnexpanded.setFrom(delta);\n    this.viewOrigin.setFrom(origin);\n    this.viewDelta.setFrom(delta);\n    this.zClipAdjusted = false;\n\n    if (this.view.is3d()) {  // 3d viewport\n      if (!this.view.allow3dManipulations()) {\n        // we're in a \"2d\" view of a physical model. That means that we must have our orientation with z out of the screen with z=0 at the center.\n        this.alignWithRootZ(); // make sure we're in a z Up view\n\n        const extents = this.view.getViewedExtents();\n        if (extents.isNull) {\n          extents.low.z = -ViewFrustum.get2dFrustumDepth();\n          extents.high.z = ViewFrustum.get2dFrustumDepth();\n        }\n\n        let zMax = Math.max(Math.abs(extents.low.z), Math.abs(extents.high.z));\n        zMax = Math.max(zMax, 1.0); // make sure we have at least +-1m. Data may be purely planar\n        delta.z = 2.0 * zMax;\n        origin.z = -zMax;\n      } else {\n        if (this.view.isCameraOn)\n          this.validateCamera();\n\n        this.adjustZPlanes(origin, delta); // make sure view volume includes entire volume of view\n\n        // if the camera is on, don't allow front plane behind camera\n        if (this.view.isCameraOn) {\n          const eyeOrg = this.view.camera.getEyePoint().minus(origin); // vector from eye to origin\n          this.toView(eyeOrg);\n\n          const frontDist = eyeOrg.z - delta.z; // front distance is backDist - delta.z\n\n          // allow ViewState to specify a minimum front dist, but in no case less than 6 inches\n          const minFrontDist = Math.max(15.2 * Constant.oneCentimeter, this.view.forceMinFrontDist);\n          if (frontDist < minFrontDist) {\n            // camera is too close to front plane, move origin away from eye to maintain a minimum front distance.\n            this.toView(origin);\n            origin.z -= (minFrontDist - frontDist);\n            this.fromView(origin);\n          }\n        }\n\n        // if we moved the z planes, set the \"zClipAdjusted\" flag.\n        if (!origin.isExactEqual(this.viewOriginUnexpanded) || !delta.isExactEqual(this.viewDeltaUnexpanded))\n          this.zClipAdjusted = true;\n      }\n    } else { // 2d viewport\n      this.alignWithRootZ();\n      delta.z = 2 * ViewFrustum.get2dFrustumDepth();\n      origin.z = -ViewFrustum.get2dFrustumDepth();\n    }\n\n    this.viewOrigin.setFrom(origin);\n    this.viewDelta.setFrom(delta);\n\n    const newRootToNpc = this.view.computeWorldToNpc(this.rotation, origin, delta, undefined === displayedPlane /* if displaying background map, don't enforce front/back ratio as no Z-Buffer */);\n    if (newRootToNpc.map === undefined) { // invalid frustum\n      this.invalidFrustum = true;\n      return;\n    }\n\n    this.worldToNpcMap.setFrom(newRootToNpc.map);\n    this.frustFraction = newRootToNpc.frustFraction;\n    this.worldToViewMap.setFrom(this.calcNpcToView().multiplyMapMap(this.worldToNpcMap));\n  }\n\n  /** @internal */\n  public static createFromViewport(vp: Viewport, view?: ViewState): ViewFrustum | undefined {\n    return new ViewFrustum(view !== undefined ? view : vp.view, vp.viewRect.width, vp.viewRect.height, vp.isAspectRatioLocked);\n  }\n\n  /** @internal */\n  public static createFromViewportAndPlane(vp: Viewport, plane: Plane3dByOriginAndUnitNormal): ViewFrustum | undefined {\n    const vf = new ViewFrustum(vp.view, vp.viewRect.width, vp.viewRect.height, vp.isAspectRatioLocked, plane);\n    return vf.invalidFrustum ? undefined : vf;\n  }\n\n  /** Convert an array of points from CoordSystem.View to CoordSystem.Npc */\n  public viewToNpcArray(pts: Point3d[]): void {\n    const corners = this.getViewCorners();\n    const scrToNpcTran = Transform.createIdentity();\n    Transform.initFromRange(corners.low, corners.high, undefined, scrToNpcTran);\n    scrToNpcTran.multiplyPoint3dArrayInPlace(pts);\n  }\n  /** Convert an array of points from CoordSystem.Npc to CoordSystem.View */\n  public npcToViewArray(pts: Point3d[]): void {\n    const corners = this.getViewCorners();\n    for (const p of pts)\n      corners.fractionToPoint(p.x, p.y, p.z, p);\n  }\n  /** Convert a point from CoordSystem.View to CoordSystem.Npc\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public viewToNpc(pt: Point3d, out?: Point3d): Point3d {\n    const corners = this.getViewCorners();\n    const scrToNpcTran = Transform.createIdentity();\n    Transform.initFromRange(corners.low, corners.high, undefined, scrToNpcTran);\n    return scrToNpcTran.multiplyPoint3d(pt, out);\n  }\n  /** Convert a point from CoordSystem.Npc to CoordSystem.View\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public npcToView(pt: Point3d, out?: Point3d): Point3d {\n    const corners = this.getViewCorners();\n    return corners.fractionToPoint(pt.x, pt.y, pt.z, out);\n  }\n  /** Convert an array of points from CoordSystem.World to CoordSystem.Npc */\n  public worldToNpcArray(pts: Point3d[]): void { this.worldToNpcMap.transform0.multiplyPoint3dArrayQuietNormalize(pts); }\n  /** Convert an array of points from CoordSystem.Npc to CoordSystem.World */\n  public npcToWorldArray(pts: Point3d[]): void { this.worldToNpcMap.transform1.multiplyPoint3dArrayQuietNormalize(pts); }\n  /** Convert an array of points from CoordSystem.World to CoordSystem.View */\n  public worldToViewArray(pts: Point3d[]): void { this.worldToViewMap.transform0.multiplyPoint3dArrayQuietNormalize(pts); }\n  /** Convert an array of points from CoordSystem.World to CoordSystem.View, as Point4ds */\n  public worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void { this.worldToViewMap.transform0.multiplyPoint3dArray(worldPts, viewPts); }\n  /** Convert an array of points from CoordSystem.View to CoordSystem.World */\n  public viewToWorldArray(pts: Point3d[]) { this.worldToViewMap.transform1.multiplyPoint3dArrayQuietNormalize(pts); }\n  /** Convert an array of points from CoordSystem.View as Point4ds to CoordSystem.World */\n  public view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void { this.worldToViewMap.transform1.multiplyPoint4dArrayQuietRenormalize(viewPts, worldPts); }\n  /**\n   * Convert a point from CoordSystem.World to CoordSystem.Npc\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public worldToNpc(pt: XYAndZ, out?: Point3d): Point3d { return this.worldToNpcMap.transform0.multiplyPoint3dQuietNormalize(pt, out); }\n  /**\n   * Convert a point from CoordSystem.Npc to CoordSystem.World\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public npcToWorld(pt: XYAndZ, out?: Point3d): Point3d { return this.worldToNpcMap.transform1.multiplyPoint3dQuietNormalize(pt, out); }\n  /**\n   * Convert a point from CoordSystem.World to CoordSystem.View\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public worldToView(input: XYAndZ, out?: Point3d): Point3d { return this.worldToViewMap.transform0.multiplyPoint3dQuietNormalize(input, out); }\n  /**\n   * Convert a point from CoordSystem.World to CoordSystem.View as Point4d\n   * @param input the point to convert\n   * @param out optional location for result. If undefined, a new Point4d is created.\n   */\n  public worldToView4d(input: XYAndZ, out?: Point4d): Point4d { return this.worldToViewMap.transform0.multiplyPoint3d(input, 1.0, out); }\n  /**\n   * Convert a point from CoordSystem.View to CoordSystem.World\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public viewToWorld(input: XYAndZ, out?: Point3d): Point3d { return this.worldToViewMap.transform1.multiplyPoint3dQuietNormalize(input, out); }\n  /**\n   * Convert a point from CoordSystem.View as a Point4d to CoordSystem.View\n   * @param input the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public view4dToWorld(input: Point4d, out?: Point3d): Point3d { return this.worldToViewMap.transform1.multiplyXYZWQuietRenormalize(input.x, input.y, input.z, input.w, out); }\n\n  /** Get an 8-point Frustum corresponding to the 8 corners of the Viewport in the specified coordinate system.\n   *\n   * There are two sets of corners that may be of interest.\n   * The \"adjusted\" box is the one that is computed by examining the \"viewed extents\" and moving\n   * the front and back planes to enclose everything in the view.\n   * The \"unadjusted\" box is the one that is stored in the ViewState.\n   * @param sys Coordinate system for points\n   * @param adjustedBox If true, retrieve the adjusted box. Otherwise retrieve the box that came from the view definition.\n   * @param box optional Frustum for return value\n   * @return the view frustum\n   * @note The \"adjusted\" box may be either larger or smaller than the \"unadjusted\" box.\n   */\n  public getFrustum(sys: CoordSystem = CoordSystem.World, adjustedBox: boolean = true, box?: Frustum): Frustum {\n    box = box ? box.initNpc() : new Frustum();\n\n    // if they are looking for the \"unexpanded\" (that is before f/b clipping expansion) box, we need to get the npc\n    // coordinates that correspond to the unexpanded box in the npc space of the Expanded view (that's the basis for all\n    // of the root-based maps.)\n    if (!adjustedBox && this.zClipAdjusted) {\n      // to get unexpanded box, we have to go recompute rootToNpc from original View.\n      const ueRootToNpc = this.view.computeWorldToNpc(this.rotation, this.viewOriginUnexpanded, this.viewDeltaUnexpanded);\n      if (undefined === ueRootToNpc.map)\n        return box; // invalid frustum\n\n      // get the root corners of the unexpanded box\n      const ueRootBox = new Frustum();\n      ueRootToNpc.map.transform1.multiplyPoint3dArrayQuietNormalize(ueRootBox.points);\n\n      // and convert them to npc coordinates of the expanded view\n      this.worldToNpcArray(ueRootBox.points);\n      box.setFrom(ueRootBox);\n    }\n\n    // now convert from NPC space to the specified coordinate system.\n    switch (sys) {\n      case CoordSystem.View:\n        this.npcToViewArray(box.points);\n        break;\n\n      case CoordSystem.World:\n        this.npcToWorldArray(box.points);\n        break;\n    }\n    return box;\n  }\n\n  public getPixelSizeAtPoint(inPoint?: Point3d) {\n    const viewPt = !!inPoint ? this.worldToView(inPoint) : this.npcToView(new Point3d(0.5, 0.5, 0.5));\n    const viewPt2 = new Point3d(viewPt.x + 1.0, viewPt.y, viewPt.z);\n    return this.viewToWorld(viewPt).distance(this.viewToWorld(viewPt2));\n  }\n}\n\n/** @beta Event type for Viewport.onViewUndoRedo */\nexport enum ViewUndoEvent { Undo = 0, Redo = 1 }\n\n/** Allows the visibility of categories within a [[Viewport]] to be controlled on a per-[[ModelState]] basis.\n * If a category's visibility is overridden for a given model, then elements belonging to that category within that model will be displayed or hidden regardless of the category's inclusion in the Viewport's [[CategorySelectorState]].\n * The override affects geometry on all subcategories belonging to the overridden category. That is, if the category is overridden to be visible, then geometry on all subcategories of the category\n * will be visible, regardless of any [SubCategoryOverride]($common)s applied by the view's [[DisplayStyleState]].\n * @see [[Viewport.perModelCategoryVisibility]]\n * @beta\n */\nexport namespace PerModelCategoryVisibility {\n  /** Describes whether and how a category's visibility is overridden.\n   * @beta\n   */\n  export enum Override {\n    /** The category's visibility is not overridden; its visibility is wholly controlled by the [[Viewport]]'s [[CategorySelectorState]]. */\n    None,\n    /** The category is overridden to be visible. */\n    Show,\n    /** The category is overridden to be invisible. */\n    Hide,\n  }\n\n  /** Describes a set of per-model category visibility overrides. Changes to these overrides invoke the [[Viewport.onViewedCategoriesPerModelChanged]] event.\n   * @see [[Viewport.perModelCategoryVisibility]].\n   * @beta\n   */\n  export interface Overrides {\n    /** Returns the override state of the specified category within the specified model. */\n    getOverride(modelId: Id64String, categoryId: Id64String): Override;\n    /** Changes the override state of one or more categories for one or more models. */\n    setOverride(modelIds: Id64Arg, categoryIds: Id64Arg, override: Override): void;\n    /** Removes all overrides for the specified models, or for all models if `modelIds` is undefined. */\n    clearOverrides(modelIds?: Id64Arg): void;\n  }\n}\n\nclass PerModelCategoryVisibilityOverride {\n  public modelId: Id64String;\n  public categoryId: Id64String;\n  public visible: boolean;\n\n  public constructor(modelId: Id64String, categoryId: Id64String, visible: boolean) {\n    this.modelId = modelId;\n    this.categoryId = categoryId;\n    this.visible = visible;\n  }\n\n  public reset(modelId: Id64String, categoryId: Id64String, visible: boolean): void {\n    this.modelId = modelId;\n    this.categoryId = categoryId;\n    this.visible = visible;\n  }\n}\n\nfunction compareCategoryOverrides(lhs: PerModelCategoryVisibilityOverride, rhs: PerModelCategoryVisibilityOverride): number {\n  const cmp = compareStrings(lhs.modelId, rhs.modelId);\n  return 0 === cmp ? compareStrings(lhs.categoryId, rhs.categoryId) : cmp;\n}\n\n/** The Viewport-specific implementation of PerModelCategoryVisibility.Overrides.\n * ###TODO: Evaluate performance.\n * @internal\n */\nclass PerModelCategoryVisibilityOverrides extends SortedArray<PerModelCategoryVisibilityOverride> implements PerModelCategoryVisibility.Overrides {\n  private readonly _scratch = new PerModelCategoryVisibilityOverride(\"0\", \"0\", false);\n  private readonly _vp: Viewport;\n\n  public constructor(vp: Viewport) {\n    super(compareCategoryOverrides);\n    this._vp = vp;\n  }\n\n  public getOverride(modelId: Id64String, categoryId: Id64String): PerModelCategoryVisibility.Override {\n    this._scratch.reset(modelId, categoryId, false);\n    const ovr = this.findEqual(this._scratch);\n    if (undefined !== ovr)\n      return ovr.visible ? PerModelCategoryVisibility.Override.Show : PerModelCategoryVisibility.Override.Hide;\n    else\n      return PerModelCategoryVisibility.Override.None;\n  }\n\n  public setOverride(modelIds: Id64Arg, categoryIds: Id64Arg, override: PerModelCategoryVisibility.Override): void {\n    const ovr = this._scratch;\n    let changed = false;\n    Id64.forEach(modelIds, (modelId) => {\n      Id64.forEach(categoryIds, (categoryId) => {\n        ovr.reset(modelId, categoryId, false);\n        const index = this.indexOf(ovr);\n        if (-1 === index) {\n          if (PerModelCategoryVisibility.Override.None !== override) {\n            this.insert(new PerModelCategoryVisibilityOverride(modelId, categoryId, PerModelCategoryVisibility.Override.Show === override));\n            changed = true;\n          }\n        } else {\n          if (PerModelCategoryVisibility.Override.None === override) {\n            this._array.splice(index, 1);\n            changed = true;\n          } else if (this._array[index].visible !== (PerModelCategoryVisibility.Override.Show === override)) {\n            this._array[index].visible = (PerModelCategoryVisibility.Override.Show === override);\n            changed = true;\n          }\n        }\n      });\n    });\n\n    if (changed) {\n      this._vp.setViewedCategoriesPerModelChanged();\n\n      if (PerModelCategoryVisibility.Override.None !== override) {\n        // Ensure subcategories loaded.\n        this._vp.subcategories.push(this._vp.iModel.subcategories, categoryIds, () => this._vp.setViewedCategoriesPerModelChanged());\n      }\n    }\n  }\n\n  public clearOverrides(modelIds?: Id64Arg): void {\n    if (undefined === modelIds) {\n      if (0 < this.length) {\n        this.clear();\n        this._vp.setViewedCategoriesPerModelChanged();\n      }\n\n      return;\n    }\n\n    for (let i = 0; i < this.length; /**/) {\n      const ovr = this._array[i];\n      const removed = !Id64.iterate(modelIds, (modelId) => {\n        if (modelId === ovr.modelId) {\n          this._array.splice(i, 1);\n          this._vp.setViewedCategoriesPerModelChanged();\n          return false; // halt iteration\n        }\n\n        return true; // continue iteration\n      });\n\n      if (!removed)\n        ++i;\n    }\n  }\n\n  public addOverrides(fs: FeatureSymbology.Overrides, ovrs: Id64.Uint32Map<Id64.Uint32Set>): void {\n    const cache = this._vp.iModel.subcategories;\n\n    for (const ovr of this._array) {\n      const subcats = cache.getSubCategories(ovr.categoryId);\n      if (undefined === subcats)\n        continue;\n\n      // It's pointless to override for models which aren't displayed...except if we do this, and then someone enables that model,\n      // we would need to regenerate our symbology overrides in response. Preferably people wouldn't bother overriding models that\n      // they don't want us to draw...\n      /* if (!this._vp.view.viewsModel(ovr.modelId))\n        continue; */\n\n      // ###TODO: Avoid recomputing upper and lower portions of model ID if model ID repeated.\n      // (Array is sorted first by model ID).\n      // Also avoid computing if no effective overrides.\n      const modelLo = Id64.getLowerUint32(ovr.modelId);\n      const modelHi = Id64.getUpperUint32(ovr.modelId);\n\n      for (const subcat of subcats) {\n        const subcatLo = Id64.getLowerUint32(subcat);\n        const subcatHi = Id64.getUpperUint32(subcat);\n        const vis = fs.isSubCategoryVisible(subcatLo, subcatHi);\n        if (vis !== ovr.visible) {\n          // Only care if visibility differs from that defined for entire view\n          let entry = ovrs.get(modelLo, modelHi);\n          if (undefined === entry) {\n            entry = new Id64.Uint32Set();\n            ovrs.set(modelLo, modelHi, entry);\n          }\n\n          entry.add(subcatLo, subcatHi);\n        }\n      }\n    }\n  }\n}\n\n/** A Viewport renders the contents of one or more Models onto an `HTMLCanvasElement`.\n *\n * It holds a [[ViewState]] object that defines its viewing parameters. [[ViewTool]]s may\n * modify the ViewState object. Changes to the ViewState are only reflected in a Viewport after the\n * [[synchWithView]] method is called.\n *\n * In general, because the Viewport essentially takes control of its attached ViewState, changes to the ViewState should be made\n * indirectly through the Viewport's own API. Doing so ensures that synchronization between the Viewport and its ViewState is reliable and automatic. For example:\n *\n *   * To change the set of categories or models displayed in the Viewport, use [[Viewport.changeCategoryDisplay]] and [[Viewport.changeModelDisplay]] rather than modifying the ViewState's [[CategorySelectorState]] or [[ModelSelectorState]] directly.\n *   * To change the [ViewFlags]($common), set [[Viewport.viewFlags]] rather than modifying the ViewState's [[DisplayStyleState]] directly.\n *   * To modify the [[DisplayStyleState]]:\n *    ```ts\n *    const style = viewport.displayStyle.clone();\n *    style.backgroundColor = ColorDef.red.clone(); // or any other desired modifications\n *    viewport.displayStyle = style;\n *    ```\n *\n * As changes to ViewState are made, Viewports also hold a stack of *previous copies* of it, to allow\n * for undo/redo (i.e. *View Previous* and *View Next*) of viewing tools.\n *\n * Changes to a Viewport's state can be monitored by attaching an event listener to a variety of specific events. Most such events are\n * triggered only once per frame, just before the Viewport's contents are rendered. For example, if the following sequence of events occurs:\n *\n *   * First frame is rendered\n *   * ViewFlags are modified\n *   * ViewFlags are modified again\n *   * Second frame is rendered\n *\n * The [[Viewport.onDisplayStyleChanged]] event will be invoked exactly once, when the second frame is rendered.\n *\n * @see [[ViewManager]]\n * @public\n */\n\nexport abstract class Viewport implements IDisposable {\n  /** Event called whenever this viewport is synchronized with its [[ViewState]].\n   * @note This event is invoked *very* frequently. To avoid negatively impacting performance, consider using one of the more specific Viewport events;\n   * otherwise, avoid performing excessive computations in response to this event.\n   */\n  public readonly onViewChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called after reversing the most recent change to the Viewport from the undo stack or reapplying the most recently undone change to the Viewport from the redo stack.\n   * @beta\n   */\n  public readonly onViewUndoRedo = new BeEvent<(vp: Viewport, event: ViewUndoEvent) => void>();\n  /** Event called on the next frame after this viewport's set of always-drawn elements changes.\n   * @beta\n   */\n  public readonly onAlwaysDrawnChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called on the next frame after this viewport's set of never-drawn elements changes.\n   * @beta\n   */\n  public readonly onNeverDrawnChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called on the next frame after this viewport's [[DisplayStyleState]] or its members change.\n   * Aspects of the display style include [ViewFlags]($common), [SubCategoryOverride]($common)s, and [[Environment]] settings.\n   * @beta\n   */\n  public readonly onDisplayStyleChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called on the next frame after this viewport's set of displayed categories changes.\n   * @beta\n   */\n  public readonly onViewedCategoriesChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called on the next frame after this viewport's set of [[PerModelCategoryVisibility.Overrides]] changes.\n   * @beta\n   */\n  public readonly onViewedCategoriesPerModelChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called on the next frame after this viewport's set of displayed models changes.\n   * @beta\n   */\n  public readonly onViewedModelsChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called on the next frame after this viewport's [[FeatureOverrideProvider]] changes, or the internal state of the provider changes such that the overrides needed to be recomputed.\n   * @beta\n   */\n  public readonly onFeatureOverrideProviderChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called on the next frame after this viewport's [[FeatureSymbology.Overrides]] change.\n   * @beta\n   */\n  public readonly onFeatureOverridesChanged = new BeEvent<(vp: Viewport) => void>();\n  /** Event called on the next frame after any of the viewport's [[ChangeFlags]] changes.\n   * @beta\n   */\n  public readonly onViewportChanged = new BeEvent<(vp: Viewport, changed: ChangeFlags) => void>();\n\n  private readonly _viewportId: number;\n  private _animationFraction = 0.0;\n  private _doContinuousRendering = false;\n  private _animator?: Animator;\n  /** @internal */\n  protected _changeFlags = new ChangeFlags();\n  private _scheduleTime = 0.0;\n  private _selectionSetDirty = true;\n  private readonly _perModelCategoryVisibility = new PerModelCategoryVisibilityOverrides(this);\n\n  /** @internal */\n  public readonly subcategories = new SubCategoriesCache.Queue();\n\n  /** @internal */\n  public get scheduleTime() { return this._scheduleTime; }\n\n  /** Time the current flash started.\n   * @internal\n   */\n  public flashUpdateTime?: BeTimePoint;\n  /** Current flash intensity from [0..1]\n   * @internal\n   */\n  public flashIntensity = 0;\n  /** The length of time that the flash intensity will increase (in seconds)\n   * @internal\n   */\n  public flashDuration = 0;\n  private _flashedElem?: string;         // id of currently flashed element\n  /** Id of last flashed element.\n   * @internal\n   */\n  public lastFlashedElem?: string;\n  /** Maximum ratio of frontplane to backplane distance for 24 bit zbuffer.\n   * @internal\n   */\n  public static nearScale24 = 0.0003;\n\n  /** The number of tiles selected for display in the view as of the most recently-drawn frame.\n   * The tiles selected may not meet the desired level-of-detail for the view, instead being temporarily drawn while\n   * tiles of more appropriate level-of-detail are loaded asynchronously.\n   * @note This member should be treated as read-only - it should only be modified internally.\n   * @see Viewport.numRequestedTiles\n   * @see Viewport.numReadyTiles\n   */\n  public numSelectedTiles = 0;\n\n  /** The number of tiles which were ready and met the desired level-of-detail for display in the view as of the most recently-drawn frame.\n   * These tiles may *not* have been selected because some other (probably sibling) tiles were *not* ready for display.\n   * This is a useful metric for determining how \"complete\" the view is - e.g., one indicator of progress toward view completion can be expressed as:\n   * `  (numReadyTiles) / (numReadyTiles + numRequestedTiles)`\n   * @note This member should be treated as read-only - it should only be modified internally.\n   * @see Viewport.numSelectedTiles\n   * @see Viewport.numRequestedTiles\n   */\n  public numReadyTiles = 0;\n\n  /** Don't allow entries in the view undo buffer unless they're separated by more than this amount of time. */\n  public static undoDelay = BeDuration.fromSeconds(.5);\n  private static _nextViewportId = 1;\n\n  private _debugBoundingBoxes: Tile.DebugBoundingBoxes = Tile.DebugBoundingBoxes.None;\n  private _freezeScene = false;\n  private _viewFrustum!: ViewFrustum;\n  private _target?: RenderTarget;\n  private _fadeOutActive = false;\n  private _neverDrawn?: Id64Set;\n  private _alwaysDrawn?: Id64Set;\n  private _alwaysDrawnExclusive: boolean = false;\n  private _featureOverrideProvider?: FeatureOverrideProvider;\n  private _tiledGraphicsProviders?: Map<TiledGraphicsProvider.Type, TiledGraphicsProvider.ProviderSet>;\n  private _hilite = new Hilite.Settings();\n\n  /** @internal */\n  public get viewFrustum(): ViewFrustum { return this._viewFrustum; }\n\n  /** This viewport's rotation matrix. */\n  public get rotation(): Matrix3d { return this._viewFrustum.rotation; }\n  /** The vector between the opposite corners of this viewport's extents. */\n  public get viewDelta(): Vector3d { return this._viewFrustum.viewDelta; }\n  /** Provides conversions between world and view coordinates. */\n  public get worldToViewMap(): Map4d { return this._viewFrustum.worldToViewMap; }\n  /** @internal */\n  public get frustFraction(): number { return this._viewFrustum.frustFraction; }\n\n  /** @internal */\n  public get animationFraction(): number { return this._animationFraction; }\n  /** @internal */\n  public set animationFraction(fraction: number) {\n    this._animationFraction = fraction; this.sync.invalidateAnimationFraction();\n  }\n\n  /** @internal */\n  protected readonly _viewRange: ViewRect = new ViewRect();\n\n  /** Get the rectangle of this Viewport in [[CoordSystem.View]] coordinates. */\n  public abstract get viewRect(): ViewRect;\n  /** @internal */\n  public get isAspectRatioLocked(): boolean { return false; }\n\n  /** @internal */\n  public get target(): RenderTarget {\n    assert(undefined !== this._target, \"Accessing RenderTarget of a disposed Viewport\");\n    return this._target!;\n  }\n\n  /** @internal */\n  public readonly sync = new SyncFlags();\n\n  /** The settings that control how elements are hilited in this Viewport. */\n  public get hilite(): Hilite.Settings { return this._hilite; }\n  public set hilite(hilite: Hilite.Settings) {\n    this._hilite = hilite;\n    this._selectionSetDirty = true;\n  }\n\n  /** Determine whether the Grid display is currently enabled in this Viewport.\n   * @return true if the grid display is on.\n   */\n  public get isGridOn(): boolean { return this.viewFlags.grid; }\n  /** The [ViewFlags]($common) that determine how the contents of this Viewport are rendered. */\n  public get viewFlags(): ViewFlags { return this.view.viewFlags; }\n  public set viewFlags(viewFlags: ViewFlags) {\n    if (!this.viewFlags.equals(viewFlags)) {\n      this._changeFlags.setDisplayStyle();\n      this.view.displayStyle.viewFlags = viewFlags;\n    }\n  }\n\n  /** The display style controller how the contents of this viewport are rendered.\n   * @note To ensure proper synchronization, do not directly modify the [[DisplayStyleState]] returned by the getter. Instead, create a new one (possibly by cloning this display style) and pass it to the setter.\n   */\n  public get displayStyle(): DisplayStyleState { return this.view.displayStyle; }\n  public set displayStyle(style: DisplayStyleState) {\n    this.view.displayStyle = style;\n    this._changeFlags.setDisplayStyle();\n  }\n\n  /** Remove any [[SubCategoryOverride]] for the specified subcategory.\n   * @param id The Id of the subcategory.\n   * @see [[overrideSubCategory]]\n   */\n  public dropSubCategoryOverride(id: Id64String): void {\n    this.view.displayStyle.dropSubCategoryOverride(id);\n    this._changeFlags.setDisplayStyle();\n  }\n\n  /** Override the symbology of geometry belonging to a specific subcategory when rendered within this viewport.\n   * @param id The Id of the subcategory.\n   * @param ovr The symbology overrides to apply to all geometry belonging to the specified subcategory.\n   * @see [[dropSubCategoryOverride]]\n   */\n  public overrideSubCategory(id: Id64String, ovr: SubCategoryOverride): void {\n    this.view.displayStyle.overrideSubCategory(id, ovr);\n    this._changeFlags.setDisplayStyle();\n  }\n\n  /** Query the symbology overrides applied to geometry belonging to a specific subcategory when rendered within this viewport.\n   * @param id The Id of the subcategory.\n   * @return The symbology overrides applied to all geometry belonging to the specified subcategory, or undefined if no such overrides exist.\n   * @see [[overrideSubCategory]]\n   */\n  public getSubCategoryOverride(id: Id64String): SubCategoryOverride | undefined {\n    return this.view.displayStyle.getSubCategoryOverride(id);\n  }\n\n  /** Query the symbology with which geometry belonging to a specific subcategory is rendered within this viewport.\n   * Every [[SubCategory]] defines a base symbology independent of any [[Viewport]].\n   * If a [[SubCategoryOverride]] has been applied to the subcategory within the context of this [[Viewport]], it will be applied to the subcategory's base symbology.\n   * @param id The Id of the subcategory.\n   * @return The symbology of the subcategory within this viewport, including any overrides.\n   * @see [[overrideSubCategory]]\n   */\n  public getSubCategoryAppearance(id: Id64String): SubCategoryAppearance {\n    const app = this.iModel.subcategories.getSubCategoryAppearance(id);\n    if (undefined === app)\n      return SubCategoryAppearance.defaults;\n\n    const ovr = this.getSubCategoryOverride(id);\n    return undefined !== ovr ? ovr.override(app) : app;\n  }\n\n  /** Determine whether geometry belonging to a specific SubCategory is visible in this viewport, assuming the containing Category is displayed.\n   * @param id The Id of the subcategory\n   * @returns true if the subcategory is visible in this viewport.\n   * @note Because this function does not know the Id of the containing Category, it does not check if the Category is enabled for display. The caller should check that separately if he knows the Id of the Category.\n   */\n  public isSubCategoryVisible(id: Id64String): boolean { return this.view.isSubCategoryVisible(id); }\n\n  /** Enable or disable display of elements belonging to a set of categories specified by Id.\n   * Visibility of individual subcategories belonging to a category can be controlled separately through the use of [[SubCategoryOverride]]s.\n   * By default, enabling display of a category does not affect display of subcategories thereof which have been overridden to be invisible.\n   * @param categories The Id(s) of the categories to which the change should be applied. No other categories will be affected.\n   * @param display Whether or not elements on the specified categories should be displayed in the viewport.\n   * @param enableAllSubCategories Specifies that when enabling display for a category, all of its subcategories should also be displayed even if they are overridden to be invisible.\n   */\n  public changeCategoryDisplay(categories: Id64Arg, display: boolean, enableAllSubCategories: boolean = false): void {\n    this._changeFlags.setViewedCategories();\n\n    if (!display) {\n      this.view.categorySelector.dropCategories(categories);\n      return;\n    }\n\n    this.view.categorySelector.addCategories(categories);\n    const categoryIds = Id64.toIdSet(categories);\n\n    this.updateSubCategories(categoryIds, enableAllSubCategories);\n  }\n\n  private updateSubCategories(categoryIds: Id64Arg, enableAllSubCategories: boolean): void {\n    this.subcategories.push(this.iModel.subcategories, categoryIds, () => {\n      if (enableAllSubCategories) {\n        this.enableAllSubCategories(categoryIds);\n        this._changeFlags.setViewedCategories();\n      }\n    });\n  }\n\n  private enableAllSubCategories(categoryIds: Id64Arg): void {\n    Id64.forEach(categoryIds, (categoryId) => {\n      const subCategoryIds = this.iModel.subcategories.getSubCategories(categoryId);\n      if (undefined !== subCategoryIds) {\n        for (const subCategoryId of subCategoryIds)\n          this.changeSubCategoryDisplay(subCategoryId, true);\n      }\n    });\n  }\n\n  /** @internal */\n  public getSubCategories(categoryId: Id64String): Id64Set | undefined { return this.iModel.subcategories.getSubCategories(categoryId); }\n\n  /** Change the visibility of geometry belonging to the specified subcategory when displayed in this viewport.\n   * @param subCategoryId The Id of the subcategory\n   * @param display: True to make geometry belonging to the subcategory visible within this viewport, false to make it invisible.\n   * @alpha\n   */\n  public changeSubCategoryDisplay(subCategoryId: Id64String, display: boolean): void {\n    const app = this.iModel.subcategories.getSubCategoryAppearance(subCategoryId);\n    if (undefined === app)\n      return; // category not enabled or subcategory not found\n\n    const curOvr = this.getSubCategoryOverride(subCategoryId);\n    const isAlreadyVisible = undefined !== curOvr && undefined !== curOvr.invisible ? !curOvr.invisible : !app.invisible;\n    if (isAlreadyVisible === display)\n      return;\n\n    // Preserve existing overrides - just flip the visibility flag.\n    const json = undefined !== curOvr ? curOvr.toJSON() : {};\n    json.invisible = !display;\n    this.overrideSubCategory(subCategoryId, SubCategoryOverride.fromJSON(json)); // will set the ChangeFlag appropriately\n  }\n\n  /** Returns true if this Viewport is currently displaying the model with the specified Id. */\n  public viewsModel(modelId: Id64String): boolean { return this.view.viewsModel(modelId); }\n\n  /** Attempt to change the 2d Model this Viewport is displaying, if its ViewState is a ViewState2d.\n   * @param baseModelId The Id of the new 2d Model to be displayed.\n   * @param options options that determine how the new view is displayed\n   * @note This function *only works* if the viewport is viewing a [[ViewState2d]], otherwise it does nothing. Also note that\n   * the Model of baseModelId should be the same type (Drawing or Sheet) as the current view.\n   * @note this method clones the current ViewState2d and sets its baseModelId to the supplied value. The DisplayStyle and CategorySelector remain unchanged.\n   */\n  public async changeViewedModel2d(baseModelId: Id64String, options?: ChangeViewedModel2dOptions & ViewChangeOptions): Promise<void> {\n    if (!this.view.is2d)\n      return;\n\n    const newView = this.view.clone() as ViewState2d; // start by cloning the current ViewState\n    // NOTE: the cast below is necessary since baseModelId is marked as readonly after construction.\n    //  We know this is a special case where it is safe to change it.\n    (newView.baseModelId as Id64String) = baseModelId; // change its baseModelId.\n\n    await newView.load(); // make sure new model is loaded.\n    this.changeView(newView); // switch this viewport to use new ViewState2d\n\n    if (options && options.doFit) { // optionally fit view to the extents of the new model\n      const range = await this.iModel.models.queryModelRanges([baseModelId]);\n      this.zoomToVolume(Range3d.fromJSON(range[0]), options);\n    }\n  }\n\n  /** Attempt to replace the set of models currently viewed by this viewport, if it is displaying a SpatialView\n   * @param modelIds The Ids of the models to be displayed.\n   * @returns false if this Viewport is not viewing a [[SpatialViewState]]\n   * @note This function *only works* if the viewport is viewing a [[SpatialViewState]], otherwise it does nothing.\n   */\n  public changeViewedModels(modelIds: Id64Arg): boolean {\n    if (!this.view.isSpatialView())\n      return false;\n\n    this.view.modelSelector.models.clear();\n    this.view.modelSelector.addModels(modelIds);\n\n    this._changeFlags.setViewedModels();\n    this.invalidateScene();\n\n    return true;\n  }\n\n  /** Add or remove a set of models from those models currently displayed in this viewport.\n   * @param modelIds The Ids of the models to add or remove.\n   * @param display Whether or not to display the specified models in the viewport.\n   * @returns false if this Viewport is not viewing a [[SpatialViewState]]\n   * @note This function *only works* if the viewport is viewing a [[SpatialViewState]], otherwise it does nothing.\n   */\n  public changeModelDisplay(models: Id64Arg, display: boolean): boolean {\n    if (!this.view.isSpatialView())\n      return false;\n\n    const prevSize = this.view.modelSelector.models.size;\n    if (display)\n      this.view.modelSelector.addModels(models);\n    else\n      this.view.modelSelector.dropModels(models);\n\n    if (this.view.modelSelector.models.size !== prevSize) {\n      this._changeFlags.setViewedModels();\n      this.invalidateScene();\n    }\n\n    return true;\n  }\n\n  /** @internal */\n  public get wantAntiAliasLines(): AntiAliasPref { return AntiAliasPref.Off; }\n  /** @internal */\n  public get wantAntiAliasText(): AntiAliasPref { return AntiAliasPref.Detect; }\n\n  /** Determines what type (if any) of debug graphics will be displayed to visualize [[Tile]] volumes.\n   * @see [[Tile.DebugBoundingBoxes]]\n   * @internal\n   */\n  public get debugBoundingBoxes(): Tile.DebugBoundingBoxes { return this._debugBoundingBoxes; }\n  public set debugBoundingBoxes(boxes: Tile.DebugBoundingBoxes) {\n    if (boxes !== this.debugBoundingBoxes) {\n      this._debugBoundingBoxes = boxes;\n      this.invalidateScene();\n    }\n  }\n  /** When true, the scene will never be recreated. Chiefly for debugging purposes.\n   * @internal\n   */\n  public set freezeScene(freeze: boolean) {\n    if (freeze !== this._freezeScene) {\n      this._freezeScene = freeze;\n      if (!freeze)\n        this.invalidateScene();\n    }\n  }\n\n  /** @internal */\n  public get analysisStyle(): AnalysisStyle | undefined { return this.view.analysisStyle; }\n  /** The iModel of this Viewport */\n  public get iModel(): IModelConnection { return this.view.iModel; }\n  /** @internal */\n  public get isPointAdjustmentRequired(): boolean { return this.view.is3d(); }\n  /** @internal */\n  public get isSnapAdjustmentRequired(): boolean { return IModelApp.toolAdmin.acsPlaneSnapLock && this.view.is3d(); }\n  /** @internal */\n  public get isContextRotationRequired(): boolean { return IModelApp.toolAdmin.acsContextLock; }\n\n  /** Enables or disables \"fade-out\" mode. When this mode is enabled, transparent graphics are rendered with a flat alpha weight,\n   * causing them to appear de-emphasized. This is typically used in contexts in which a handful of elements are to be emphasized in the view,\n   * while the rest of the graphics are drawn transparently.\n   */\n  public get isFadeOutActive(): boolean { return this._fadeOutActive; }\n  public set isFadeOutActive(active: boolean) {\n    if (active !== this._fadeOutActive) {\n      this._fadeOutActive = active;\n      this.invalidateRenderPlan();\n    }\n  }\n\n  /** @internal */\n  protected constructor(target: RenderTarget) {\n    this._target = target;\n    this._viewportId = Viewport._nextViewportId++;\n  }\n\n  public dispose(): void {\n    assert(undefined !== this._target, \"Double disposal of Viewport\");\n    this._target = dispose(this._target);\n    this.subcategories.dispose();\n    IModelApp.tileAdmin.forgetViewport(this);\n  }\n\n  /** Enables or disables continuous rendering. Ideally, during each render frame a Viewport will do as little work as possible.\n   * To make that possible, the viewport keeps track of what has changed about its internal state from one frame to the next.\n   * For example, if the view frustum has not changed since the previous frame, it is likely that the viewport does not need to be\n   * re-rendered at all.\n   *\n   * In some circumstances, it is desirable to bypass the logic that limits the amount of work performed each frame. A primary example\n   * is a viewport that has some animations applied to it, or when diagnostic information like frames-per-second is being monitored.\n   *\n   * @note An application which enables continuous rendering should disable it as soon as it is no longer needed.\n   */\n  public get continuousRendering(): boolean { return this._doContinuousRendering; }\n  public set continuousRendering(contRend: boolean) { this._doContinuousRendering = contRend; }\n  /** This gives each Viewport a unique ID, which can be used for comparing and sorting Viewport objects inside collections.\n   * @internal\n   */\n  public get viewportId(): number { return this._viewportId; }\n\n  /** The ViewState for this Viewport */\n  public get view(): ViewState { return this._viewFrustum.view; }\n  /** @internal */\n  public get pixelsPerInch() { /* ###TODO: This is apparently unobtainable information in a browser... */ return 96; }\n  /** @internal */\n  public get backgroundMapPlane() { return this.view.displayStyle.backgroundMapPlane; }\n\n  /** IDs of a set of elements which should not be rendered within this view.\n   * @note Do not modify this set directly - use [[setNeverDrawn]] or [[clearNeverDrawn]] instead.\n   * @note This set takes precedence over the [[alwaysDrawn]] set - if an element is present in both sets, it is never drawn.\n   */\n  public get neverDrawn(): Id64Set | undefined { return this._neverDrawn; }\n\n  /** IDs of a set of elements which should always be rendered within this view, regardless of category and subcategory visibility.\n   * If the [[isAlwaysDrawnExclusive]] flag is also set, *only* those elements in this set will be drawn.\n   * @note Do not modify this set directly - use [[setAlwaysDrawn]] or [[clearAlwaysDrawn]] instead.\n   * @note The [[neverDrawn]] set takes precedence - if an element is present in both sets, it is never drawn.\n   */\n  public get alwaysDrawn(): Id64Set | undefined { return this._alwaysDrawn; }\n\n  /** Clear the set of always-drawn elements.\n   * @see [[alwaysDrawn]]\n   */\n  public clearAlwaysDrawn(): void {\n    if ((undefined !== this.alwaysDrawn && 0 < this.alwaysDrawn.size) || this._alwaysDrawnExclusive) {\n      if (undefined !== this.alwaysDrawn)\n        this.alwaysDrawn.clear();\n\n      this._alwaysDrawnExclusive = false;\n      this._changeFlags.setAlwaysDrawn();\n    }\n  }\n\n  /** Clear the set of never-drawn elements.\n   * @see [[neverDrawn]]\n   */\n  public clearNeverDrawn(): void {\n    if (undefined !== this.neverDrawn && 0 < this.neverDrawn.size) {\n      this.neverDrawn.clear();\n      this._changeFlags.setNeverDrawn();\n    }\n  }\n\n  /** Specify the IDs of a set of elements which should never be rendered within this view.\n   * @see [[neverDrawn]].\n   */\n  public setNeverDrawn(ids: Id64Set): void {\n    this._neverDrawn = ids;\n    this._changeFlags.setNeverDrawn();\n  }\n\n  /** Specify the IDs of a set of elements which should always be rendered within this view, regardless of category and subcategory visibility.\n   * @param ids The IDs of the elements to always draw.\n   * @param exclusive If true, *only* the specified elements will be drawn.\n   * @see [[alwaysDrawn]]\n   * @see [[isAlwaysDrawnExclusive]]\n   */\n  public setAlwaysDrawn(ids: Id64Set, exclusive: boolean = false): void {\n    this._alwaysDrawn = ids;\n    this._alwaysDrawnExclusive = exclusive;\n    this._changeFlags.setAlwaysDrawn();\n  }\n\n  /** Returns true if the set of elements in the [[alwaysDrawn]] set are the *only* elements rendered within this view. */\n  public get isAlwaysDrawnExclusive(): boolean { return this._alwaysDrawnExclusive; }\n\n  /** Allows visibility of categories within this viewport to be overridden on a per-model basis.\n   * @alpha\n   */\n  public get perModelCategoryVisibility(): PerModelCategoryVisibility.Overrides { return this._perModelCategoryVisibility; }\n\n  /** Adds visibility overrides for any subcategories whose visibility differs from that defined by the view's\n   * category selector in the context of specific models.\n   * @internal\n   */\n  public addModelSubCategoryVisibilityOverrides(fs: FeatureSymbology.Overrides, ovrs: Id64.Uint32Map<Id64.Uint32Set>): void {\n    this._perModelCategoryVisibility.addOverrides(fs, ovrs);\n  }\n\n  /** Sets an object which can customize the appearance of [[Feature]]s within a viewport.\n   * If defined, the provider will be invoked whenever the overrides are determined to need updating.\n   * The overrides can be explicitly marked as needing a refresh by calling [[Viewport.setFeatureOverrideProviderChanged]]. This is typically called when\n   * the internal state of the provider changes such that the computed overrides must also change.\n   * @see [[FeatureSymbology.Overrides]]\n   */\n  public set featureOverrideProvider(provider: FeatureOverrideProvider | undefined) {\n    if (provider !== this._featureOverrideProvider) {\n      this._featureOverrideProvider = provider;\n      this.setFeatureOverrideProviderChanged();\n    }\n  }\n\n  /** Get the current FeatureOverrideProvider for this viewport if defined. */\n  public get featureOverrideProvider(): FeatureOverrideProvider | undefined {\n    return this._featureOverrideProvider;\n  }\n\n  /** Notifies this viewport that the internal state of its [[FeatureOverrideProvider]] has changed such that its\n   * [[FeatureSymbology.Overrides]] should be recomputed.\n   */\n  public setFeatureOverrideProviderChanged(): void {\n    this._changeFlags.setFeatureOverrideProvider();\n  }\n  /** Add a TiledGraphicsProvider\n   * @internal\n   */\n  public addTiledGraphicsProvider(type: TiledGraphicsProvider.Type, provider: TiledGraphicsProvider.Provider) {\n    if (undefined === this._tiledGraphicsProviders)\n      this._tiledGraphicsProviders = new Map<TiledGraphicsProvider.Type, TiledGraphicsProvider.ProviderSet>();\n\n    if (undefined === this._tiledGraphicsProviders.get(type))\n      this._tiledGraphicsProviders.set(type, new Set<TiledGraphicsProvider.Provider>());\n\n    this._tiledGraphicsProviders!.get(type)!.add(provider);\n  }\n\n  /** Remove a TiledGraphicsProvider\n   * @internal\n   */\n  public removeTiledGraphicsProvider(type: TiledGraphicsProvider.Type, provider: TiledGraphicsProvider.Provider) {\n    if (undefined !== this._tiledGraphicsProviders && undefined !== this._tiledGraphicsProviders.get(type))\n      this._tiledGraphicsProviders.get(type)!.delete(provider);\n  }\n  /** Get the tiled graphics providers for given type\n   * @internal\n   */\n  public getTiledGraphicsProviders(type: TiledGraphicsProvider.Type): TiledGraphicsProvider.ProviderSet | undefined {\n    return this._tiledGraphicsProviders ? this._tiledGraphicsProviders.get(type) : undefined;\n  }\n\n  /** @internal */\n  public setViewedCategoriesPerModelChanged(): void {\n    this._changeFlags.setViewedCategoriesPerModel();\n  }\n\n  /** @internal */\n  public markSelectionSetDirty() { this._selectionSetDirty = true; }\n\n  /** True if this is a 3d view with the camera turned on. */\n  public get isCameraOn(): boolean { return this.view.is3d() && this.view.isCameraOn; }\n  /** @internal */\n  public invalidateDecorations() { this.sync.invalidateDecorations(); }\n  /** @internal */\n  public invalidateRenderPlan() { this.sync.invalidateRenderPlan(); }\n  /** @internal */\n  public changeDynamics(dynamics: GraphicList | undefined): void {\n    this.target.changeDynamics(dynamics);\n    this.invalidateDecorations();\n  }\n\n  /** Set or clear the currently *flashed* element.\n   * @param id The Id of the element to flash. If undefined, remove (un-flash) the currently flashed element\n   * @param duration The amount of time, in seconds, the flash intensity will increase (see [[flashDuration]])\n   * @internal\n   */\n  public setFlashed(id: string | undefined, duration: number): void {\n    if (id !== this._flashedElem) {\n      this.lastFlashedElem = this._flashedElem;\n      this._flashedElem = id;\n    }\n    this.flashDuration = duration;\n  }\n\n  public get auxCoordSystem(): AuxCoordSystemState { return this.view.auxiliaryCoordinateSystem; }\n  public getAuxCoordRotation(result?: Matrix3d) { return this.auxCoordSystem.getRotation(result); }\n  public getAuxCoordOrigin(result?: Point3d) { return this.auxCoordSystem.getOrigin(result); }\n\n  /** The number of outstanding requests for tiles to be displayed in this viewport.\n   * @see Viewport.numSelectedTiles\n   */\n  public get numRequestedTiles(): number { return IModelApp.tileAdmin.getNumRequestsForViewport(this); }\n\n  /** @internal */\n  public toView(from: XYZ, to?: XYZ) { this._viewFrustum.toView(from, to); }\n  /** @internal */\n  public fromView(from: XYZ, to?: XYZ) { this._viewFrustum.fromView(from, to); }\n\n  /** Change the ViewState of this Viewport\n   * @param view a fully loaded (see discussion at [[ViewState.load]] ) ViewState\n   */\n  public changeView(view: ViewState) {\n    this.updateChangeFlags(view);\n    this.doSetupFromView(view);\n    this.invalidateScene();\n    this.sync.invalidateController();\n    this.target.reset();\n  }\n\n  /** @internal */\n  public invalidateScene(): void { this.sync.invalidateScene(); }\n\n  /** Computes the range of npc depth values for a region of the screen\n   * @param rect the rectangle to test. If undefined, test entire view\n   * @param result optional DepthRangeNpc to store the result\n   * @returns the minimum and maximum depth values within the region, or undefined.\n   */\n  public determineVisibleDepthRange(rect?: ViewRect, result?: DepthRangeNpc): DepthRangeNpc | undefined {\n    if (result) { // Null result if given\n      result.minimum = 1;\n      result.maximum = 0;\n    }\n\n    // Default to a (0, 0, 0) to (1, 1, 1) range if no range was provided\n    rect = (rect && rect.isValid) ? rect : this.viewRect;\n\n    // Determine the screen rectangle in which to query visible depth min + max\n    const readRect = rect.computeOverlap(this.viewRect);\n    if (undefined === readRect)\n      return undefined;\n\n    let retVal: DepthRangeNpc | undefined;\n    this.readPixels(readRect, Pixel.Selector.GeometryAndDistance, (pixels) => {\n      if (!pixels)\n        return;\n\n      let maximum = 0;\n      let minimum = 1;\n      const frac = this._viewFrustum.frustFraction;\n      for (let x = readRect.left; x < readRect.right; ++x) {\n        for (let y = readRect.top; y < readRect.bottom; ++y) {\n          let npcZ = pixels.getPixel(x, y).distanceFraction;\n          if (npcZ <= 0.0)\n            continue;\n\n          if (frac < 1.0)\n            npcZ *= frac / (1.0 + npcZ * (frac - 1.0));\n\n          minimum = Math.min(minimum, npcZ);\n          maximum = Math.max(maximum, npcZ);\n        }\n      }\n\n      if (maximum <= 0)\n        return;\n\n      if (undefined === result) {\n        result = { minimum, maximum };\n      } else {\n        result.minimum = minimum;\n        result.maximum = maximum;\n      }\n\n      retVal = result;\n    });\n\n    return retVal;\n  }\n\n  /** Turn the camera on if it is currently off. If the camera is already on, adjust it to use the supplied lens angle.\n   * @param lensAngle The lens angle for the camera. If undefined, use view.camera.lens.\n   * @note This method will fail if the ViewState is not 3d.\n   */\n  public turnCameraOn(lensAngle?: Angle): ViewStatus {\n    const view = this.view;\n    if (!view.is3d())\n      return ViewStatus.InvalidViewport;\n\n    if (!lensAngle)\n      lensAngle = view.camera.lens;\n\n    Camera.validateLensAngle(lensAngle);\n\n    if (view.isCameraOn)\n      return view.lookAtUsingLensAngle(view.getEyePoint(), view.getTargetPoint(), view.getYVector(), lensAngle);\n\n    // We need to figure out a new camera target. To do that, we need to know where the geometry is in the view.\n    // We use the depth of the center of the view for that.\n    let depthRange = this.determineVisibleDepthRange();\n    if (!depthRange)\n      depthRange = { minimum: 0, maximum: 1 };\n\n    const middle = depthRange.minimum + ((depthRange.maximum - depthRange.minimum) / 2.0);\n    const corners = [\n      new Point3d(0.0, 0.0, middle), // lower left, at target depth\n      new Point3d(1.0, 1.0, middle), // upper right at target depth\n      new Point3d(0.0, 0.0, depthRange.maximum), // lower left, at closest npc\n      new Point3d(1.0, 1.0, depthRange.maximum), // upper right at closest\n    ];\n\n    this.npcToWorldArray(corners);\n\n    const eye = corners[2].interpolate(0.5, corners[3]); // middle of closest plane\n    const target = corners[0].interpolate(0.5, corners[1]); // middle of halfway plane\n    const backDist = eye.distance(target) * 2.0;\n    const frontDist = view.minimumFrontDistance();\n    return view.lookAtUsingLensAngle(eye, target, view.getYVector(), lensAngle, frontDist, backDist);\n  }\n\n  /** Orient this viewport to one of the [[StandardView]] rotations. */\n  public setStandardRotation(id: StandardViewId): void {\n    this.view.setStandardRotation(id);\n    this.setupFromView();\n  }\n\n  private doSetupFromView(view: ViewState) {\n    const vf = ViewFrustum.createFromViewport(this, view);\n    if (undefined === vf)\n      return ViewStatus.InvalidViewport;\n\n    this._viewFrustum = vf;\n\n    this.sync.invalidateRenderPlan();\n    this.sync.setValidController();\n\n    this.onViewChanged.raiseEvent(this);\n    return ViewStatus.Success;\n  }\n\n  /** Establish the parameters of this Viewport from the current information in its ViewState */\n  public setupFromView(): ViewStatus {\n    return this.doSetupFromView(this.view);\n  }\n\n  /** Call [[setupFromView]] on this Viewport and optionally save previous state in view undo stack */\n  public synchWithView(_saveInUndo: boolean): void { this.setupFromView(); }\n\n  /** Convert an array of points from CoordSystem.View to CoordSystem.Npc */\n  public viewToNpcArray(pts: Point3d[]): void { this._viewFrustum.viewToNpcArray(pts); }\n  /** Convert an array of points from CoordSystem.Npc to CoordSystem.View */\n  public npcToViewArray(pts: Point3d[]): void { this._viewFrustum.npcToViewArray(pts); }\n  /** Convert a point from CoordSystem.View to CoordSystem.Npc\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public viewToNpc(pt: Point3d, out?: Point3d): Point3d { return this._viewFrustum.viewToNpc(pt, out); }\n  /** Convert a point from CoordSystem.Npc to CoordSystem.View\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public npcToView(pt: Point3d, out?: Point3d): Point3d { return this._viewFrustum.npcToView(pt, out); }\n  /** Convert an array of points from CoordSystem.World to CoordSystem.Npc */\n  public worldToNpcArray(pts: Point3d[]): void { this._viewFrustum.worldToNpcArray(pts); }\n  /** Convert an array of points from CoordSystem.Npc to CoordSystem.World */\n  public npcToWorldArray(pts: Point3d[]): void { this._viewFrustum.npcToWorldArray(pts); }\n  /** Convert an array of points from CoordSystem.World to CoordSystem.View */\n  public worldToViewArray(pts: Point3d[]): void { this._viewFrustum.worldToViewArray(pts); }\n  /** Convert an array of points from CoordSystem.World to CoordSystem.View, as Point4ds */\n  public worldToView4dArray(worldPts: Point3d[], viewPts: Point4d[]): void { this._viewFrustum.worldToView4dArray(worldPts, viewPts); }\n  /** Convert an array of points from CoordSystem.View to CoordSystem.World */\n  public viewToWorldArray(pts: Point3d[]) { this._viewFrustum.viewToWorldArray(pts); }\n  /** Convert an array of points from CoordSystem.View as Point4ds to CoordSystem.World */\n  public view4dToWorldArray(viewPts: Point4d[], worldPts: Point3d[]): void { this._viewFrustum.view4dToWorldArray(viewPts, worldPts); }\n  /** Convert a point from CoordSystem.World to CoordSystem.Npc\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public worldToNpc(pt: XYAndZ, out?: Point3d): Point3d { return this._viewFrustum.worldToNpc(pt, out); }\n  /** Convert a point from CoordSystem.Npc to CoordSystem.World\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public npcToWorld(pt: XYAndZ, out?: Point3d): Point3d { return this._viewFrustum.npcToWorld(pt, out); }\n  /** Convert a point from CoordSystem.World to CoordSystem.View\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public worldToView(input: XYAndZ, out?: Point3d): Point3d { return this._viewFrustum.worldToView(input, out); }\n  /** Convert a point from CoordSystem.World to CoordSystem.View as Point4d\n   * @param input the point to convert\n   * @param out optional location for result. If undefined, a new Point4d is created.\n   */\n  public worldToView4d(input: XYAndZ, out?: Point4d): Point4d { return this._viewFrustum.worldToView4d(input, out); }\n  /** Convert a point from CoordSystem.View to CoordSystem.World\n   * @param pt the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public viewToWorld(input: XYAndZ, out?: Point3d): Point3d { return this._viewFrustum.viewToWorld(input, out); }\n  /** Convert a point from CoordSystem.View as a Point4d to CoordSystem.View\n   * @param input the point to convert\n   * @param out optional location for result. If undefined, a new Point3d is created.\n   */\n  public view4dToWorld(input: Point4d, out?: Point3d): Point3d { return this._viewFrustum.view4dToWorld(input, out); }\n\n  /** Converts inches to pixels based on screen DPI.\n   * @Note this information may not be accurate in some browsers.\n   * @param inches the number of inches to convert\n   * @returns the corresponding number of pixels\n   */\n  public pixelsFromInches(inches: number): number { return inches * this.pixelsPerInch; }\n\n  /** Get an 8-point Frustum corresponding to the 8 corners of the Viewport in the specified coordinate system.\n   *\n   * There are two sets of corners that may be of interest.\n   * The \"adjusted\" box is the one that is computed by examining the \"viewed extents\" and moving\n   * the front and back planes to enclose everything in the view.\n   * The \"unadjusted\" box is the one that is stored in the ViewState.\n   * @param sys Coordinate system for points\n   * @param adjustedBox If true, retrieve the adjusted box. Otherwise retrieve the box that came from the view definition.\n   * @param box optional Frustum for return value\n   * @return the view frustum\n   * @note The \"adjusted\" box may be either larger or smaller than the \"unadjusted\" box.\n   */\n  public getFrustum(sys: CoordSystem = CoordSystem.World, adjustedBox: boolean = true, box?: Frustum): Frustum { return this._viewFrustum.getFrustum(sys, adjustedBox, box); }\n\n  /** Get a copy of the current (adjusted) frustum of this viewport, in world coordinates. */\n  public getWorldFrustum(box?: Frustum): Frustum { return this.getFrustum(CoordSystem.World, true, box); }\n\n  private finishViewChange(startFrust: Frustum, options?: ViewChangeOptions) {\n    options = options === undefined ? {} : options;\n    this.synchWithView(options.saveInUndo === undefined || options.saveInUndo);\n    if (options.animateFrustumChange === undefined || options.animateFrustumChange)\n      this.animateFrustumChange(startFrust, this.getFrustum(), options.animationTime);\n  }\n\n  /** Scroll the view by a given number of pixels.\n   * @param screenDist distance to scroll, in pixels\n   */\n  public scroll(screenDist: Point2d, options?: ViewChangeOptions) {\n    const view = this.view;\n    if (!view)\n      return;\n\n    const startFrust = this.getFrustum().clone();\n    if (view.is3d() && view.isCameraOn) {\n      const offset = new Vector3d(screenDist.x, screenDist.y, 0.0);\n      const frust = this.getFrustum(CoordSystem.View, false)!;\n      frust.translate(offset);\n      this.viewToWorldArray(frust.points);\n      view.setupFromFrustum(frust);\n      view.centerEyePoint();\n    } else {\n      const pts = [new Point3d(), new Point3d(screenDist.x, screenDist.y, 0)];\n      this.viewToWorldArray(pts);\n      const dist = pts[1].minus(pts[0]);\n      const newOrg = view.getOrigin().plus(dist);\n      view.setOrigin(newOrg);\n    }\n\n    this.finishViewChange(startFrust, options);\n  }\n\n  /** Zoom the view by a scale factor, placing the new center at the projection of the given point (world coordinates)\n   * on the focal plane.\n   * Updates ViewState and re-synchs Viewport. Does not save in view undo buffer.\n   */\n  public zoom(newCenter: Point3d | undefined, factor: number, options?: ViewChangeOptions): void {\n    const view = this.view;\n    if (!view)\n      return;\n\n    const startFrust = this.getFrustum().clone();\n    if (view.is3d() && view.isCameraOn) {\n      const centerNpc = newCenter ? this.worldToNpc(newCenter) : NpcCenter.clone();\n      const scaleTransform = Transform.createFixedPointAndMatrix(centerNpc, Matrix3d.createScale(factor, factor, 1.0));\n\n      const offset = centerNpc.minus(NpcCenter); // offset by difference of old/new center\n      offset.z = 0.0;     // z center stays the same.\n\n      const offsetTransform = Transform.createTranslationXYZ(offset.x, offset.y, offset.z);\n      const product = offsetTransform.multiplyTransformTransform(scaleTransform);\n\n      const frust = new Frustum();\n      product.multiplyPoint3dArrayInPlace(frust.points);\n\n      this.npcToWorldArray(frust.points);\n      view.setupFromFrustum(frust);\n      view.centerEyePoint();\n    } else {\n      // for non-camera views, do the zooming by adjusting the origin and delta directly so there can be no\n      // chance of the rotation changing due to numerical precision errors calculating it from the frustum corners.\n      const delta = view.getExtents().clone();\n      delta.x *= factor;\n      delta.y *= factor;\n\n      // first check to see whether the zoom operation results in an invalid view. If so, make sure we don't change anything\n      view.validateViewDelta(delta, true);\n\n      const center = newCenter ? newCenter.clone() : view.getCenter().clone();\n\n      if (!view.allow3dManipulations())\n        center.z = 0.0;\n\n      const newOrg = view.getOrigin().clone();\n      this.toView(newOrg);\n      this.toView(center);\n\n      view.setExtents(delta);\n\n      newOrg.x = center.x - delta.x / 2.0;\n      newOrg.y = center.y - delta.y / 2.0;\n      this.fromView(newOrg);\n      view.setOrigin(newOrg);\n    }\n\n    this.finishViewChange(startFrust, options);\n  }\n\n  /** Zoom the view to a show the tightest box around a given set of PlacementProps. Optionally, change view rotation.\n   * @param props array of PlacementProps. Will zoom to the union of the placements.\n   * @param options options that control how the view change works and whether to change view rotation.\n   */\n  public zoomToPlacementProps(placementProps: PlacementProps[], options?: ViewChangeOptions & ZoomToOptions) {\n    if (placementProps.length === 0)\n      return;\n\n    const hasAngle = (arg: any): arg is Placement2dProps => arg.angle !== undefined;\n    if (undefined !== options) {\n      if (undefined !== options.standardViewId) {\n        this.view.setStandardRotation(options.standardViewId);\n      } else if (undefined !== options.placementRelativeId) {\n        const firstProps = placementProps[0];\n        const firstPlacement = hasAngle(firstProps) ? Placement2d.fromJSON(firstProps) : Placement3d.fromJSON(firstProps);\n        const viewRotation = StandardView.getStandardRotation(options.placementRelativeId).clone();\n        viewRotation.multiplyMatrixMatrixTranspose(firstPlacement.transform.matrix, viewRotation);\n        this.view.setRotation(viewRotation);\n      } else if (undefined !== options.viewRotation) {\n        this.view.setRotation(options.viewRotation);\n      }\n    }\n\n    const viewTransform = Transform.createOriginAndMatrix(undefined, this.view.getRotation());\n    const frust = new Frustum();\n    const viewRange = new Range3d();\n    for (const props of placementProps) {\n      const placement = hasAngle(props) ? Placement2d.fromJSON(props) : Placement3d.fromJSON(props);\n      viewRange.extendArray(placement.getWorldCorners(frust).points, viewTransform);\n    }\n\n    this.view.lookAtViewAlignedVolume(viewRange, this.viewRect.aspect, options ? options.marginPercent : undefined);\n    this.finishViewChange(this.getFrustum().clone(), options);\n  }\n\n  /** Zoom the view to a show the tightest box around a given set of ElementProps. Optionally, change view rotation.\n   * @param props element props. Will zoom to the union of the placements.\n   * @param options options that control how the view change works and whether to change view rotation.\n   */\n  public zoomToElementProps(elementProps: ElementProps[], options?: ViewChangeOptions & ZoomToOptions) {\n    if (elementProps.length === 0)\n      return;\n    const placementProps: PlacementProps[] = [];\n    for (const props of elementProps) {\n      if (props.placement !== undefined && this.view.viewsModel(props.model))\n        placementProps.push(props.placement);\n    }\n    this.zoomToPlacementProps(placementProps, options);\n  }\n\n  /** Zoom the view to a show the tightest box around a given set of elements. Optionally, change view rotation.\n   * @param ids the element id(s) to include. Will zoom to the union of the placements.\n   * @param options options that control how the view change works and whether to change view rotation.\n   */\n  public async zoomToElements(ids: Id64Arg, options?: ViewChangeOptions & ZoomToOptions): Promise<void> {\n    this.zoomToElementProps(await this.iModel.elements.getProps(ids), options);\n  }\n\n  /** Zoom the view to a volume of space in world coordinates.\n   * @param volume The low and high corners, in world coordinates.\n   * @param options options that control how the view change works\n   */\n  public zoomToVolume(volume: LowAndHighXYZ | LowAndHighXY, options?: ViewChangeOptions) {\n    this.view.lookAtVolume(volume, this.viewRect.aspect, options ? options.marginPercent : undefined);\n    this.finishViewChange(this.getFrustum().clone(), options);\n  }\n\n  /** Shortcut to call view.setupFromFrustum and then [[setupFromView]]\n   * @param inFrustum the new viewing frustum\n   * @returns true if both steps were successful\n   */\n  public setupViewFromFrustum(inFrustum: Frustum): boolean {\n    const validSize = this.view.setupFromFrustum(inFrustum);\n    // note: always call setupFromView, even if setupFromFrustum failed\n    return (ViewStatus.Success === this.setupFromView() && ViewStatus.Success === validSize);\n  }\n\n  /** @internal */\n  public computeViewRange(): Range3d {\n    this.setupFromView(); // can't proceed if viewport isn't valid (not active)\n    return this.view.computeFitRange();\n  }\n\n  /** @internal */\n  public animate() {\n    if (this._animator && this._animator.animate())\n      this._animator = undefined;\n  }\n\n  /** @internal */\n  public removeAnimator() { this.setAnimator(undefined); }\n  private setAnimator(animator: Animator | undefined) {\n    if (this._animator)\n      this._animator.interrupt(); // will be destroyed\n    this._animator = animator;\n  }\n\n  /** @internal */\n  public animateFrustumChange(start: Frustum, end: Frustum, animationTime?: BeDuration) {\n    if (!animationTime || 0.0 >= animationTime.milliseconds)\n      animationTime = ToolSettings.animationTime;\n\n    this.setAnimator(new Animator(animationTime, this, start, end));\n  }\n\n  /** @internal */\n  public applyViewState(val: ViewState, animationTime?: BeDuration) {\n    this.updateChangeFlags(val);\n    const startFrust = this.getFrustum();\n    this._viewFrustum.view = val;\n    this.synchWithView(false);\n    if (animationTime)\n      this.animateFrustumChange(startFrust, this.getFrustum(), animationTime);\n  }\n\n  /** Invoked from applyViewState and changeView to potentially recompute change flags based on differences between current and new ViewState. */\n  private updateChangeFlags(newView: ViewState): void {\n    // Before the first call to changeView, this.view is undefined because we have no frustum. Our API pretends it is never undefined.\n    const oldView = undefined !== this.viewFrustum ? this.view : undefined;\n\n    if (undefined === oldView || oldView === newView)\n      return;\n\n    const flags = this._changeFlags;\n    if (!flags.displayStyle && !oldView.displayStyle.equalState(newView.displayStyle))\n      flags.setDisplayStyle();\n\n    if (!flags.viewedCategories && !oldView.categorySelector.equalState(newView.categorySelector))\n      flags.setViewedCategories();\n\n    if (!flags.neverDrawn) {\n      const oldExclude = oldView.displayStyle.settings.excludedElements;\n      const newExclude = newView.displayStyle.settings.excludedElements;\n      if (oldExclude.size !== newExclude.size) {\n        flags.setNeverDrawn();\n      } else {\n        for (const exclude of oldExclude)\n          if (!newExclude.has(exclude)) {\n            flags.setNeverDrawn();\n            break;\n          }\n      }\n    }\n\n    if (flags.viewedModels)\n      return;\n\n    if (oldView.is2d() && newView.is2d()) {\n      if (oldView.baseModelId !== newView.baseModelId)\n        flags.setViewedModels();\n    } else if (oldView.isSpatialView() && newView.isSpatialView()) {\n      if (!oldView.modelSelector.equalState(newView.modelSelector))\n        flags.setViewedModels();\n    } else {\n      // switched between 2d and 3d view.\n      flags.setViewedModels();\n    }\n  }\n\n  private static roundGrid(num: number, units: number): number {\n    const sign = ((num * units) < 0.0) ? -1.0 : 1.0;\n    num = (num * sign) / units + 0.5;\n    return units * sign * Math.floor(num);\n  }\n\n  private getGridOrientation(origin: Point3d, rMatrix: Matrix3d) {\n    if (this.view.isSpatialView())\n      origin.setFrom(this.iModel!.globalOrigin);\n\n    switch (this.view.getGridOrientation()) {\n      case GridOrientationType.View: {\n        const center = this.view.getCenter();\n        this.toView(center);\n        this.toView(origin);\n        origin.z = center.z;\n        this.fromView(origin);\n        break;\n      }\n\n      case GridOrientationType.WorldXY:\n        break;\n\n      case GridOrientationType.WorldYZ: {\n        Matrix3d.createRows(rMatrix.getRow(1), rMatrix.getRow(2), rMatrix.getRow(0), rMatrix);\n        break;\n      }\n\n      case GridOrientationType.WorldXZ: {\n        Matrix3d.createRows(rMatrix.getRow(0), rMatrix.getRow(2), rMatrix.getRow(1), rMatrix);\n        break;\n      }\n    }\n  }\n\n  private pointToStandardGrid(point: Point3d, rMatrix: Matrix3d, origin: Point3d): void {\n    const planeNormal = rMatrix.getRow(2);\n\n    let eyeVec: Vector3d;\n    if (this.view.is3d() && this.isCameraOn)\n      eyeVec = this.view.camera.eye.vectorTo(point);\n    else\n      eyeVec = this._viewFrustum.rotation.getRow(2).clone();\n\n    eyeVec.normalizeInPlace();\n    linePlaneIntersect(point, point, eyeVec, origin, planeNormal, false);\n\n    // // get origin and point in view coordinate system\n    const pointView = point.clone();\n    const originView = origin.clone();\n    this.toView(pointView);\n    this.toView(originView);\n\n    // subtract off the origin\n    pointView.y -= originView.y;\n    pointView.x -= originView.x;\n\n    // round off the remainder to the grid distances\n    const gridSpacing = this.view.getGridSpacing();\n    pointView.x = Viewport.roundGrid(pointView.x, gridSpacing.x);\n    pointView.y = Viewport.roundGrid(pointView.y, gridSpacing.y);\n\n    // add the origin back in\n    pointView.x += originView.x;\n    pointView.y += originView.y;\n\n    // go back to root coordinate system\n    this.fromView(pointView);\n    point.setFrom(pointView);\n  }\n\n  /** @internal */\n  public pointToGrid(point: Point3d): void {\n    if (GridOrientationType.AuxCoord === this.view.getGridOrientation()) {\n      this.pointToStandardGrid(point, this.getAuxCoordRotation(), this.getAuxCoordOrigin());\n      return;\n    }\n\n    const origin = new Point3d();\n    const rMatrix = Matrix3d.createIdentity();\n    this.getGridOrientation(origin, rMatrix);\n    this.pointToStandardGrid(point, rMatrix, origin);\n  }\n\n  /** Get the width of a pixel (a unit vector in the x direction in view coordinates) at a given point in world coordinates, returning the result in meters (world units).\n   *\n   * This is most useful to determine how large something is in a view. In particular, in a perspective view\n   * the result of this method will be a larger number for points closer to the back of the view Frustum (that is,\n   * one pixel of the view represents more spatial area at the back of the Frustum than the front.)\n   * @param point The point to test, in World coordinates. If undefined, the center of the view in NPC space is used.\n   * @returns The width of a view pixel at the supplied world point, in meters.\n   */\n  public getPixelSizeAtPoint(point?: Point3d): number {\n    if (point === undefined)\n      point = this.npcToWorld(NpcCenter); // if undefined, use center of view\n\n    const worldPts: Point3d[] = [];\n    const viewPts: Point4d[] = [];\n    viewPts[0] = this.worldToView4d(point);\n    viewPts[1] = viewPts[0].clone();\n    viewPts[1].x += viewPts[1].w; // form a vector one pixel wide in x direction.\n    this.view4dToWorldArray(viewPts, worldPts);\n\n    return worldPts[0].distance(worldPts[1]);\n  }\n\n  private get _wantInvertBlackAndWhite(): boolean {\n    const bgColor = this.view.backgroundColor.colors;\n    return ((bgColor.r + bgColor.g + bgColor.b) > (255 * 3) / 2);\n  }\n\n  /** Get a color that will contrast to the current background color of this Viewport. Either Black or White depending on which will have the most contrast. */\n  public getContrastToBackgroundColor(): ColorDef {\n    return this._wantInvertBlackAndWhite ? ColorDef.black : ColorDef.white; // should we use black or white?\n  }\n\n  private processFlash(): boolean {\n    let needsFlashUpdate = false;\n\n    if (this._flashedElem !== this.lastFlashedElem) {\n      this.flashIntensity = 0.0;\n      this.flashUpdateTime = BeTimePoint.now();\n      this.lastFlashedElem = this._flashedElem; // flashing has begun; this is now the previous flash\n      needsFlashUpdate = this._flashedElem === undefined; // notify render thread that flash has been turned off (signified by undefined elem)\n    }\n\n    if (this._flashedElem !== undefined && this.flashIntensity < 1.0) {\n      const flashDuration = BeDuration.fromSeconds(this.flashDuration);\n      const flashElapsed = BeTimePoint.now().milliseconds - this.flashUpdateTime!.milliseconds;\n      this.flashIntensity = Math.min(flashElapsed, flashDuration.milliseconds) / flashDuration.milliseconds; // how intense do we want the flash effect to be from [0..1]?\n      needsFlashUpdate = true;\n    }\n\n    return needsFlashUpdate;\n  }\n\n  /** @internal */\n  public createSceneContext(): SceneContext { return new SceneContext(this); }\n\n  /** Called when the visible contents of the viewport are redrawn.\n   * @note Due to the frequency of this event, avoid performing expensive work inside event listeners.\n   */\n  public readonly onRender = new BeEvent<(vp: Viewport) => void>();\n\n  /** @internal */\n  public renderFrame(): boolean {\n    const changeFlags = this._changeFlags;\n    if (changeFlags.hasChanges)\n      this._changeFlags = new ChangeFlags(ChangeFlag.None);\n\n    const sync = this.sync;\n    const view = this.view;\n    const target = this.target;\n\n    // Start timer for tile loading time\n    const timer = new StopWatch(undefined, true);\n\n    this.animate();\n\n    // Allow ViewState instance to change any state which might affect logic below...\n    view.onRenderFrame(this);\n\n    let isRedrawNeeded = sync.isRedrawPending || this._doContinuousRendering;\n    sync.invalidateRedrawPending();\n\n    if (target.updateViewRect()) {\n      target.onResized();\n      sync.invalidateController();\n    }\n\n    if (this._selectionSetDirty) {\n      target.setHiliteSet(view.iModel.hilited);\n      this._selectionSetDirty = false;\n      isRedrawNeeded = true;\n    }\n\n    let overridesNeeded = changeFlags.areFeatureOverridesDirty;\n\n    if (!sync.isValidAnimationFraction) {\n      target.animationFraction = this.animationFraction;\n      isRedrawNeeded = true;\n      sync.setValidAnimationFraction();\n      const scheduleScript = view.displayStyle.scheduleScript;\n      if (scheduleScript) {\n        const scheduleTime = scheduleScript.duration.fractionToPoint(target.animationFraction);\n        if (scheduleTime !== this._scheduleTime) {\n          this._scheduleTime = scheduleTime;\n          target.animationBranches = scheduleScript.getAnimationBranches(scheduleTime);\n          if (scheduleScript.containsFeatureOverrides)\n            overridesNeeded = true;\n        }\n      }\n    }\n\n    if (overridesNeeded) {\n      const ovr = new FeatureSymbology.Overrides(this);\n      target.overrideFeatureSymbology(ovr);\n      isRedrawNeeded = true;\n    }\n\n    if (!sync.isValidController)\n      this.setupFromView();\n\n    if (!sync.isValidScene) {\n      if (!this._freezeScene) {\n        this.numSelectedTiles = this.numReadyTiles = 0;\n        const context = this.createSceneContext();\n        view.createClassification(context);\n        view.createScene(context);\n        view.createBackgroundMap(context);\n        view.createProviderGraphics(context);\n        view.createSolarShadowMap(context);\n        context.requestMissingTiles();\n        target.changeScene(context.graphics);\n        target.changeBackgroundMap(context.backgroundGraphics);\n        target.changePlanarClassifiers(context.planarClassifiers);\n        target.changeSolarShadowMap(context.solarShadowMap);\n\n        isRedrawNeeded = true;\n      }\n\n      sync.setValidScene();\n    }\n\n    if (!sync.isValidRenderPlan) {\n      target.changeRenderPlan(RenderPlan.createFromViewport(this));\n      sync.setValidRenderPlan();\n      isRedrawNeeded = true;\n    }\n\n    if (!sync.isValidDecorations) {\n      const decorations = new Decorations();\n      this.addDecorations(decorations);\n      target.changeDecorations(decorations);\n      isRedrawNeeded = true;\n    }\n\n    if (this.processFlash()) {\n      target.setFlashed(undefined !== this._flashedElem ? this._flashedElem : Id64.invalid, this.flashIntensity);\n      isRedrawNeeded = true;\n    }\n\n    timer.stop();\n    if (isRedrawNeeded) {\n      target.drawFrame(timer.elapsed.milliseconds);\n      this.onRender.raiseEvent(this);\n    }\n\n    // Dispatch change events after timer has stopped and update has finished.\n    if (changeFlags.hasChanges) {\n      this.onViewportChanged.raiseEvent(this, changeFlags);\n\n      if (changeFlags.displayStyle)\n        this.onDisplayStyleChanged.raiseEvent(this);\n\n      if (changeFlags.viewedModels)\n        this.onViewedModelsChanged.raiseEvent(this, changeFlags);\n\n      if (changeFlags.areFeatureOverridesDirty) {\n        this.onFeatureOverridesChanged.raiseEvent(this);\n\n        if (changeFlags.alwaysDrawn)\n          this.onAlwaysDrawnChanged.raiseEvent(this);\n\n        if (changeFlags.neverDrawn)\n          this.onNeverDrawnChanged.raiseEvent(this);\n\n        if (changeFlags.viewedCategories)\n          this.onViewedCategoriesChanged.raiseEvent(this);\n\n        if (changeFlags.viewedCategoriesPerModel)\n          this.onViewedCategoriesPerModelChanged.raiseEvent(this);\n\n        if (changeFlags.featureOverrideProvider)\n          this.onFeatureOverrideProviderChanged.raiseEvent(this);\n      }\n    }\n\n    return true;\n  }\n\n  /** @internal */\n  public addDecorations(_decorations: Decorations): void { }\n\n  /** Read selected data about each pixel within a rectangular region of this Viewport.\n   * @param rect The area of the viewport's contents to read. The origin specifies the upper-left corner. Must lie entirely within the viewport's dimensions.\n   * @param selector Specifies which aspect(s) of data to read.\n   * @param receiver A function accepting a [[Pixel.Buffer]] object from which the selected data can be retrieved, or receiving undefined if the viewport is not active, the rect is out of bounds, or some other error.\n   * @param excludeNonLocatable If true, geometry with the \"non-locatable\" flag set will not be drawn.\n   * @note The [[Pixel.Buffer]] supplied to the `receiver` function becomes invalid once that function exits. Do not store a reference to it.\n   * @beta\n   */\n  public readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable = false): void {\n    const viewRect = this.viewRect;\n    if (!rect.isContained(viewRect))\n      receiver(undefined);\n    else\n      this.target.readPixels(rect, selector, receiver, excludeNonLocatable);\n  }\n\n  /** Read the current image from this viewport from the rendering system. If a view rectangle outside the actual view is specified, the entire view is captured.\n   * @param rect The area of the view to read. The origin of a viewRect must specify the upper left corner.\n   * @param targetSize The size of the image to be returned. The size can be larger or smaller than the original view.\n   * @param flipVertically If true, the image is flipped along the x-axis.\n   * @returns The contents of the viewport within the specified rectangle as a bitmap image, or undefined if the image could not be read.\n   * @note By default the image is returned upside-down. Pass `true` for `flipVertically` to flip it along the x-axis.\n   */\n  public readImage(rect: ViewRect = new ViewRect(0, 0, -1, -1), targetSize: Point2d = Point2d.createZero(), flipVertically: boolean = false): ImageBuffer | undefined {\n    return this.target.readImage(rect, targetSize, flipVertically);\n  }\n\n  /** Get the point at the specified x and y location in the pixel buffer in npc coordinates\n   * @beta\n   */\n  public getPixelDataNpcPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined {\n    const z = pixels.getPixel(x, y).distanceFraction;\n    if (z <= 0.0)\n      return undefined;\n\n    const vf = this._viewFrustum;\n\n    const result = undefined !== out ? out : new Point3d();\n    const viewRect = this.viewRect;\n    result.x = (x + 0.5 - viewRect.left) / viewRect.width;\n    result.y = 1.0 - (y + 0.5 - viewRect.top) / viewRect.height;\n    if (vf.frustFraction < 1.0)\n      result.z = z * vf.frustFraction / (1.0 + z * (vf.frustFraction - 1.0)); // correct to npc if camera on.\n    else\n      result.z = z;\n\n    return result;\n  }\n\n  /** Get the point at the specified x and y location in the pixel buffer in world coordinates\n   * @beta\n   */\n  public getPixelDataWorldPoint(pixels: Pixel.Buffer, x: number, y: number, out?: Point3d): Point3d | undefined {\n    const npc = this.getPixelDataNpcPoint(pixels, x, y, out);\n    if (undefined !== npc)\n      this.npcToWorld(npc, npc);\n\n    return npc;\n  }\n}\n\n/** An interactive Viewport that exists within an HTMLDivElement. ScreenViewports can receive HTML events.\n * To render the contents of a ScreenViewport, it must be added to the [[ViewManager]] via ViewManager.addViewport().\n * Every frame, the ViewManager will update the Viewport's state and re-render its contents if anything has changed.\n * To halt this loop, use ViewManager.dropViewport() to remove the viewport from the ViewManager.\n *\n * A ScreenViewport internally owns significant WebGL resources which must be explicitly disposed of when the viewport is no longer needed.\n * This is achieved by invoking the viewport's dispose() method. ViewManager.dropViewport() invokes dispose() on the viewport by default.\n *\n * The lifetime of a ScreenViewport typically follows a pattern:\n * ```\n *  1. Application creates the viewport via ScreenViewport.create()\n *  2. The viewport is added to the render loop via ViewManager.addViewport()\n *  3. When the application is finished with the viewport, it removes it from the render loop and disposes of it via ViewManager.dropViewport().\n * ```\n *\n * In some cases it may be useful to temporarily suspend a viewport's render loop. In this case the lifetime of the viewport proceeds as follows:\n * ```\n *  1. Application creates the viewport via ScreenViewport.create()\n *  2. The viewport is added to the render loop via ViewManager.addViewport()\n *  3. At some point the render loop is suspended via ViewManager.dropViewport(viewport, false), indicating the viewport should not be disposed.\n *  4. Optionally, resume rendering by returning to step 2.\n *  5. When the application is finished with the viewport:\n *    5a. If it is currently registered with the ViewManager, it is dropped and disposed of via ViewManager.dropViewport()\n *    5b. Otherwise, it is disposed of by invoking its dispose() method directly.\n * ```\n * @public\n */\nexport class ScreenViewport extends Viewport {\n  private _evController?: EventController;\n  private _viewCmdTargetCenter?: Point3d;\n  /** The number of entries in the view undo/redo buffer. */\n  public maxUndoSteps = 20;\n  private readonly _forwardStack: ViewStateUndo[] = [];\n  private readonly _backStack: ViewStateUndo[] = [];\n  private _currentBaseline?: ViewStateUndo;\n\n  /** The parent HTMLDivElement of the canvas. */\n  public readonly parentDiv: HTMLDivElement;\n  /** The div created to hold all viewport elements. */\n  public readonly vpDiv: HTMLDivElement;\n  /** The canvas to display the view contents. */\n  public readonly canvas: HTMLCanvasElement;\n  /** The HTMLDivElement used for HTML decorations. May be referenced from the DOM by class \"overlay-decorators\". */\n  public readonly decorationDiv: HTMLDivElement;\n  /** The HTMLDivElement used for toolTips. May be referenced from the DOM by class \"overlay-tooltip\". */\n  public readonly toolTipDiv: HTMLDivElement;\n\n  /** Create a new ScreenViewport that shows a View of an iModel into an HTMLDivElement. This method will create a new HTMLCanvasElement as a child of the supplied parentDiv.\n   * It also creates two new child HTMLDivElements: one of class \"overlay-decorators\" for HTML overlay decorators, and one of class\n   * \"overlay-tooltip\" for ToolTips. All the new child HTMLElements are the same size as the parentDiv.\n   * @param parentDiv The HTMLDivElement to contain the ScreenViewport. The element must have non-zero width and height.\n   * @param view The ViewState for the ScreenViewport.\n   * @note After creating a new ScreenViewport, you must call [[ViewManager.addViewport]] for it to become \"live\". You must also ensure you dispose of it properly.\n   * @throws Error if `parentDiv` has zero width or height.\n   */\n  public static create(parentDiv: HTMLDivElement, view: ViewState): ScreenViewport {\n    if (0 === parentDiv.clientWidth || 0 === parentDiv.clientHeight)\n      throw new Error(\"viewport cannot be created from a div with zero width or height\");\n\n    const canvas = document.createElement(\"canvas\");\n    const vp = new this(canvas, parentDiv, IModelApp.renderSystem.createTarget(canvas));\n    vp.changeView(view);\n    return vp;\n  }\n\n  /** Remove all of the children of an HTMLDivElement.\n   * @internal\n   */\n  public static removeAllChildren(el: HTMLDivElement) {\n    while (el.lastChild)\n      el.removeChild(el.lastChild);\n  }\n  /** set Div style to absolute, {0,0,100%,100%}\n   * @internal\n   */\n  public static setToParentSize(div: HTMLElement) {\n    const style = div.style;\n    style.position = \"absolute\";\n    style.top = style.left = \"0\";\n    style.height = style.width = \"100%\";\n  }\n  /**  add a child element to this.vpDiv and set its size and position the same as the parent.  */\n  private addChildDiv(parent: HTMLElement, element: HTMLElement, zIndex: number) {\n    ScreenViewport.setToParentSize(element);\n    // get the (computed) z-index value of the parent, as an integer.\n    const parentZ = parseInt(window.getComputedStyle(this.vpDiv).zIndex || \"0\", 10);\n    element.style.zIndex = (parentZ + zIndex).toString();\n    parent.appendChild(element);\n  }\n\n  /** @internal */\n  public addNewDiv(className: string, overflowHidden: boolean, z: number): HTMLDivElement {\n    const div = document.createElement(\"div\");\n    div.className = className;\n    div.style.pointerEvents = \"none\";\n    div.style.overflow = overflowHidden ? \"hidden\" : \"visible\";\n    this.addChildDiv(this.vpDiv, div, z);\n    return div;\n  }\n\n  /** @internal */\n  constructor(canvas: HTMLCanvasElement, parentDiv: HTMLDivElement, target: RenderTarget) {\n    super(target);\n    this.canvas = canvas;\n    this.parentDiv = parentDiv;\n\n    // first remove all children of the parent Div\n    ScreenViewport.removeAllChildren(parentDiv);\n\n    const div = this.vpDiv = document.createElement(\"div\");\n    div.className = \"imodeljs-vp\";\n    this.addChildDiv(this.parentDiv, div, 0);\n\n    this.addChildDiv(this.vpDiv, canvas, 10);\n    this.target.updateViewRect();\n\n    this.decorationDiv = this.addNewDiv(\"overlay-decorators\", true, 30);\n    this.toolTipDiv = this.addNewDiv(\"overlay-tooltip\", false, 40);\n    this.setCursor();\n  }\n\n  /** Open the toolTip window in this ScreenViewport with the supplied message and location. The tooltip will be a child of [[ScreenViewport.toolTipDiv]].\n   * @param message The message to display\n   * @param location The position of the toolTip, in view coordinates. If undefined, use center of view.\n   * @param options the ToolTip options\n   * @note There is only one ToolTip window, so calling this method more than once will move the toolTip and show the second message.\n   */\n  public openToolTip(message: HTMLElement | string, location?: XAndY, options?: ToolTipOptions) {\n    IModelApp.notifications.openToolTip(this.toolTipDiv, message, location, options);\n  }\n\n  /** Set the event controller for this Viewport. Destroys previous controller, if one was defined. */\n  public setEventController(controller: EventController | undefined) { if (this._evController) { this._evController.destroy(); } this._evController = controller; }\n\n  /** Find a point on geometry visible in this Viewport, within a radius of supplied pick point.\n   * @param pickPoint Point to search about, in world coordinates\n   * @param radius Radius, in pixels, of the circular area to search.\n   * @param allowNonLocatable If true, include geometry with non-locatable flag set.\n   * @param out Optional Point3d to hold the result. If undefined, a new Point3d is returned.\n   * @returns The point, in world coordinates, on the element closest to `pickPoint`, or undefined if no elements within `radius`.\n   */\n  public pickNearestVisibleGeometry(pickPoint: Point3d, radius: number, allowNonLocatable = true, out?: Point3d): Point3d | undefined {\n    const picker = new ElementPicker();\n    const options = new LocateOptions();\n    options.allowNonLocatable = allowNonLocatable;\n    if (0 !== picker.doPick(this, pickPoint, radius, options)) {\n      const result = undefined !== out ? out : new Point3d();\n      result.setFrom(picker.getHit(0)!.getPoint());\n      return result;\n    }\n    if (undefined === this.backgroundMapPlane)\n      return undefined;\n\n    const eyePoint = this.worldToViewMap.transform1.columnZ();\n    const direction = Vector3d.createFrom(eyePoint);\n    const aa = Geometry.conditionalDivideFraction(1, eyePoint.w);\n    if (aa !== undefined) {\n      const xyzEye = direction.scale(aa);\n      direction.setFrom(pickPoint.vectorTo(xyzEye));\n    }\n    direction.scaleToLength(-1.0, direction);\n    const rayToEye = Ray3d.create(pickPoint, direction);\n    const projectedPt = Point3d.createZero();\n    if (undefined === rayToEye.intersectionWithPlane(this.backgroundMapPlane, projectedPt))\n      return undefined;\n\n    const mapResult = undefined !== out ? out : new Point3d();\n    mapResult.setFrom(projectedPt);\n    return mapResult;\n  }\n\n  /** @internal */\n  public pickCanvasDecoration(pt: XAndY) { return this.target.pickOverlayDecoration(pt); }\n\n  /** Get the ClientRect of the canvas for this Viewport. */\n  public getClientRect(): ClientRect { return this.canvas.getBoundingClientRect(); }\n\n  /** The ViewRect for this ScreenViewport. Left and top will be 0, right will be the width, and bottom will be the height. */\n  public get viewRect(): ViewRect { this._viewRange.init(0, 0, this.canvas.clientWidth, this.canvas.clientHeight); return this._viewRange; }\n\n  /** @internal */\n  public addDecorations(decorations: Decorations): void {\n    ScreenViewport.removeAllChildren(this.decorationDiv);\n    const context = new DecorateContext(this, decorations);\n    this.view.decorate(context);\n\n    for (const decorator of IModelApp.viewManager.decorators)\n      decorator.decorate(context);\n\n    this.sync.setValidDecorations();\n  }\n\n  /** Change the cursor for this Viewport */\n  public setCursor(cursor: string = \"default\"): void { this.canvas.style.cursor = cursor; }\n\n  /** @internal */\n  public synchWithView(saveInUndo: boolean): void {\n    super.setupFromView();\n    if (saveInUndo)\n      this.saveViewUndo();\n  }\n\n  /** Change the ViewState of this Viewport\n   * @param view a fully loaded (see discussion at [[ViewState.load]] ) ViewState\n   */\n  public changeView(view: ViewState) {\n    this.clearViewUndo();\n    super.changeView(view);\n    this.saveViewUndo();\n  }\n\n  /** @internal */\n  public get viewCmdTargetCenter(): Point3d | undefined { return this._viewCmdTargetCenter; }\n  /** @internal */\n  public set viewCmdTargetCenter(center: Point3d | undefined) { this._viewCmdTargetCenter = center ? center.clone() : undefined; }\n  /** True if an undoable viewing operation exists on the stack */\n  public get isUndoPossible(): boolean { return 0 < this._backStack.length; }\n\n  /** True if a redoable viewing operation exists on the stack */\n  public get isRedoPossible(): boolean { return 0 < this._forwardStack.length; }\n\n  /** Clear the undo buffers of this Viewport. This resets the undo stack. */\n  public clearViewUndo(): void {\n    this._currentBaseline = undefined;\n    this._forwardStack.length = 0;\n    this._backStack.length = 0;\n  }\n\n  /** Saves the current state of this viewport's [[ViewState]] in the undo stack, such that it can be restored by a call to [[ScreenViewport.doUndo]]. */\n  public saveViewUndo(): void {\n    if (!this.view)\n      return;\n\n    // the first time we're called we need to establish the baseline\n    if (!this._currentBaseline)\n      this._currentBaseline = this.view.saveForUndo();\n\n    if (this._currentBaseline.equalState(this.view))\n      return; // nothing changed, we're done\n\n    const backStack = this._backStack;\n    if (backStack.length >= this.maxUndoSteps) // don't save more than max\n      backStack.shift(); // remove the oldest entry\n\n    /** Sometimes we get requests to save undo entries from rapid viewing operations (e.g. mouse wheel rolls). To avoid lots of\n     * little useless intermediate view undo steps that mean nothing, if we get a call to this within a minimum time (1/2 second by default)\n     * we don't add a new entry to the view undo buffer.\n     */\n    const now = BeTimePoint.now();\n    if (Viewport.undoDelay.isZero || backStack.length < 1 || backStack[backStack.length - 1].undoTime!.plus(Viewport.undoDelay).before(now)) {\n      this._currentBaseline!.undoTime = now; // save time we put this entry in undo buffer\n      this._backStack.push(this._currentBaseline); // save previous state\n      this._forwardStack.length = 0; // not possible to do redo after this\n    }\n\n    this._currentBaseline = this.view.saveForUndo();\n  }\n\n  /** Reverses the most recent change to the Viewport from the undo stack. */\n  public doUndo(animationTime?: BeDuration) {\n    if (0 === this._backStack.length || this._currentBaseline === undefined)\n      return;\n\n    this._forwardStack.push(this._currentBaseline);\n    this._currentBaseline = this._backStack.pop()!;\n    this.view.setFromUndo(this._currentBaseline);\n    this.applyViewState(this.view, animationTime);\n    this.onViewUndoRedo.raiseEvent(this, ViewUndoEvent.Undo);\n  }\n\n  /** Re-applies the most recently un-done change to the Viewport from the redo stack. */\n  public doRedo(animationTime?: BeDuration) {\n    if (0 === this._forwardStack.length || this._currentBaseline === undefined)\n      return;\n\n    this._backStack.push(this._currentBaseline!);\n    this._currentBaseline = this._forwardStack.pop()!;\n    this.view.setFromUndo(this._currentBaseline);\n    this.applyViewState(this.view, animationTime);\n    this.onViewUndoRedo.raiseEvent(this, ViewUndoEvent.Redo);\n  }\n\n  /** Clear the view undo buffer and establish the current ViewState as the new baseline. */\n  public resetUndo() {\n    this.clearViewUndo();\n    this.saveViewUndo();  // Set up new baseline state\n  }\n\n  /** Show the surface normal for geometry under the cursor when snapping. */\n  private static drawLocateHitDetail(context: DecorateContext, aperture: number, hit: HitDetail): void {\n    if (!context.viewport.view.is3d())\n      return; // Not valuable feedback in 2d...\n\n    if (!(hit instanceof SnapDetail) || !hit.normal || hit.isPointAdjusted)\n      return; // AccuSnap will flash edge/segment geometry if not a surface hit or snap location has been adjusted...\n\n    const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n    const color = context.viewport.hilite.color.invert(); // Invert hilite color for good contrast\n    const colorFill = color.clone();\n\n    color.setTransparency(100);\n    colorFill.setTransparency(200);\n    builder.setSymbology(color, colorFill, 1);\n\n    const radius = (2.5 * aperture) * context.viewport.getPixelSizeAtPoint(hit.snapPoint);\n    const rMatrix = Matrix3d.createRigidHeadsUp(hit.normal);\n    const ellipse = Arc3d.createScaledXYColumns(hit.snapPoint, rMatrix, radius, radius, AngleSweep.create360());\n\n    builder.addArc(ellipse, true, true);\n    builder.addArc(ellipse, false, false);\n\n    const length = (0.6 * radius);\n    const normal = Vector3d.create();\n\n    ellipse.vector0.normalize(normal);\n    const pt1 = hit.snapPoint.plusScaled(normal, length);\n    const pt2 = hit.snapPoint.plusScaled(normal, -length);\n    builder.addLineString([pt1, pt2]);\n\n    ellipse.vector90.normalize(normal);\n    const pt3 = hit.snapPoint.plusScaled(normal, length);\n    const pt4 = hit.snapPoint.plusScaled(normal, -length);\n    builder.addLineString([pt3, pt4]);\n\n    context.addDecorationFromBuilder(builder);\n  }\n\n  /** @internal */\n  public drawLocateCursor(context: DecorateContext, pt: Point3d, aperture: number, isLocateCircleOn: boolean, hit?: HitDetail): void {\n    if (hit)\n      ScreenViewport.drawLocateHitDetail(context, aperture, hit);\n\n    if (isLocateCircleOn) {\n      // draw a filled and outlined circle to represent the size of the location aperture in the current view.\n      const radius = Math.floor(aperture * 0.5) + 0.5;\n      const position = this.worldToView(pt); position.x = Math.floor(position.x) + 0.5; position.y = Math.floor(position.y) + 0.5;\n      const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n        ctx.beginPath();\n        ctx.strokeStyle = \"rgba(255,255,255,.4)\";\n        ctx.fillStyle = \"rgba(255,255,255,.2)\";\n        ctx.arc(0, 0, radius, 0, 2 * Math.PI);\n        ctx.fill();\n        ctx.stroke();\n        ctx.beginPath();\n        ctx.strokeStyle = \"rgba(0,0,0,.8)\";\n        ctx.lineWidth = 1;\n        ctx.arc(0, 0, radius + 1, 0, 2 * Math.PI);\n        ctx.stroke();\n      };\n      context.addCanvasDecoration({ position, drawDecoration }, true);\n    }\n  }\n}\n\n/** Forms a 2-way connection between 2 Viewports of the same iModel, such that any change of the parameters in one will be reflected in the other.\n * For example, Navigator uses this class to synchronize two views for revision comparison.\n * @note It is possible to synchronize two Viewports from two different [[IModelConnection]]s of the same iModel.\n * @alpha\n */\nexport class TwoWayViewportSync {\n  private _removals: VoidFunction[] = [];\n  private _isEcho = false;\n  private syncView(source: Viewport, target: Viewport) {\n    if (this._isEcho) return;\n    this._isEcho = true; // so we don't react to the echo of this sync\n    target.applyViewState(source.view.clone(target.iModel));\n    this._isEcho = false;\n  }\n\n  /** Establish the connection between two Viewports. When this method is called, view2 is initialized with the state of view1. */\n  public connect(view1: Viewport, view2: Viewport) {\n    this.disconnect();\n\n    view2.applyViewState(view1.view.clone(view2.iModel)); // use view1 as the starting point\n\n    // listen to the onViewChanged events from both views\n    this._removals.push(view1.onViewChanged.addListener(() => this.syncView(view1, view2)));\n    this._removals.push(view2.onViewChanged.addListener(() => this.syncView(view2, view1)));\n  }\n\n  /** Remove the connection between the two views. */\n  public disconnect() { this._removals.forEach((removal) => removal()); }\n}\n\n/** An off-screen viewport is not rendered to the screen. It is never added to the [[ViewManager]], therefore does not participate in\n * the render loop. It must be initialized with an explicit height and width, and its renderFrame function must be manually invoked.\n * @internal\n */\nexport class OffScreenViewport extends Viewport {\n  public static create(view: ViewState, viewRect?: ViewRect) {\n    const rect = new ViewRect(0, 0, 1, 1);\n    if (undefined !== viewRect)\n      rect.setFrom(viewRect);\n\n    const vp = new this(IModelApp.renderSystem.createOffscreenTarget(rect));\n    vp.changeView(view);\n    vp.sync.setValidDecorations();  // decorations are not used offscreen\n    return vp;\n  }\n\n  public get viewRect(): ViewRect { return this.target.viewRect; }\n\n  public setRect(rect: ViewRect, temporary: boolean = false) {\n    this.target.setViewRect(rect, temporary);\n    this.changeView(this.view);\n  }\n}\n\n/** @internal */\nexport function linePlaneIntersect(outP: Point3d, linePt: Point3d, lineNormal: Vector3d | undefined, planePt: Point3d, planeNormal: Vector3d, perpendicular: boolean): void {\n  let dot = 0;\n  if (lineNormal)\n    dot = lineNormal.dotProduct(planeNormal);\n  else\n    perpendicular = true;\n\n  let temp: Vector3d;\n  if (perpendicular || Math.abs(dot) < .001) {\n    const t = linePt.vectorTo(planePt).dotProduct(planeNormal);\n    temp = planeNormal.scale(t);\n  } else {\n    const t = (planeNormal.dotProduct(planePt) - planeNormal.dotProduct(linePt)) / dot;\n    temp = lineNormal!.scale(t);\n  }\n\n  outP.setFrom(temp.plus(linePt));\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n\nexport * from \"./tools/AccuDrawTool\";\nexport * from \"./tools/EditManipulator\";\nexport * from \"./tools/ElementSetTool\";\nexport * from \"./tools/EventController\";\nexport * from \"./tools/MeasureTool\";\nexport * from \"./tools/SelectTool\";\nexport * from \"./tools/ToolAdmin\";\nexport * from \"./tools/Tool\";\nexport * from \"./tools/ViewTool\";\nexport * from \"./tools/ClipViewTool\";\nexport * from \"./tools/PrimitiveTool\";\nexport * from \"./tools/IdleTool\";\nexport * from \"./AccuDraw\";\nexport * from \"./AccuSnap\";\nexport * from \"./AuxCoordSys\";\nexport * from \"./DevTools\";\nexport * from \"./FrontendRequestContext\";\nexport * from \"./CategorySelectorState\";\nexport * from \"./ContextRealityModelState\";\nexport * from \"./SpatialClassification\";\nexport * from \"./DisplayStyleState\";\nexport * from \"./ElementLocateManager\";\nexport * from \"./EmphasizeElements\";\nexport * from \"./EntityState\";\nexport * from \"./FuzzySearch\";\nexport * from \"./GeoServices\";\nexport * from \"./HitDetail\";\nexport * from \"./IModelConnection\";\nexport * from \"./ImageUtil\";\nexport * from \"./FrontendLoggerCategory\";\nexport * from \"./Marker\";\nexport * from \"./ModelSelectorState\";\nexport * from \"./ModelState\";\nexport * from \"./NotificationManager\";\nexport * from \"./Plugin\";\nexport * from \"./SelectionSet\";\nexport * from \"./Sheet\";\nexport * from \"./Sprites\";\nexport * from \"./StandardView\";\nexport * from \"./SubCategoriesCache\";\nexport * from \"./TentativePoint\";\nexport * from \"./QuantityFormatter\";\nexport * from \"./ViewContext\";\nexport * from \"./ViewManager\";\nexport * from \"./Viewport\";\nexport * from \"./ViewState\";\nexport * from \"./IModelApp\";\nexport * from \"./NoRenderApp\";\nexport * from \"./tile/TileAdmin\";\nexport * from \"./tile/TileTree\";\nexport * from \"./tile/WebMapTileTree\";\nexport * from \"./render/FeatureSymbology\";\nexport * from \"./render/GraphicBuilder\";\nexport * from \"./render/MockRender\";\nexport * from \"./render/System\";\nexport * from \"./render/webgl/Target\";\nexport * from \"./oidc/OidcBrowserClient\";\nexport * from \"./TiledGraphicsProvider\";\nexport * from \"./TerrainProvider\";\nexport * from \"./properties/Description\";\nexport * from \"./properties/EditorParams\";\nexport * from \"./properties/Record\";\nexport * from \"./properties/Value\";\nexport * from \"./properties/ToolSettingsValue\";\nexport * from \"./properties/PrimitiveTypes\";\nexport * from \"./SolarCalculate\";\n\n// Set the version number so it can be found at runtime. BUILD_SEMVER is replaced at build time by the webpack DefinePlugin.\ndeclare var BUILD_SEMVER: string;\nif ((typeof (BUILD_SEMVER) !== \"undefined\") && (typeof window !== \"undefined\") && window) {\n  if (!(window as any).iModelJsVersions)\n    (window as any).iModelJsVersions = new Map<string, string>();\n  (window as any).iModelJsVersions.set(\"imodeljs-frontend\", BUILD_SEMVER);\n}\n\n/** @docs-package-description\n * The ($frontend) package always runs in a web browser. It contains classes for [querying iModels and showing views]($docs/learning/frontend/index.md).\n */\n\n/**\n * @docs-group-description IModelApp\n * Classes for configuring and administering an iModel.js application.\n * See [the learning articles]($docs/learning/frontend/index.md).\n */\n/**\n * @docs-group-description IModelConnection\n * Classes for working with a connection to an [iModel briefcase]($docs/learning/IModels.md)\n */\n/**\n * @docs-group-description ElementState\n * Classes for working with the *state* of Elements in the frontend.\n * See [the learning articles]($docs/learning/frontend/index.md).\n */\n/**\n * @docs-group-description ModelState\n * Classes for working with the *state* of Models in the frontend.\n * See [the learning articles]($docs/learning/frontend/index.md).\n */\n/**\n * @docs-group-description Tools\n * Classes for [working with Tools]($docs/learning/frontend/Tools.md)\n */\n/**\n * @docs-group-description Views\n * Classes for [working with Views]($docs/learning/frontend/Views.md)\n */\n/**\n * @docs-group-description LocatingElements\n * Classes for locating and snapping to elements in views.\n * See [the learning articles]($docs/learning/frontend/index.md).\n */\n/**\n * @docs-group-description AccuDraw\n * AccuDraw provides helpful assistance for creating and modifying elements in a view.\n * See [the learning articles]($docs/learning/frontend/index.md).\n */\n/**\n * @docs-group-description Notifications\n * Notifications provide feedback to the user of something of interest.\n * See [the learning articles]($docs/learning/frontend/index.md).\n */\n/**\n * @docs-group-description Plugins\n * Classes for creating and managing runtime [Plugins]($docs/learning/frontend/Plugins.md)\n */\n/**\n * @docs-group-description Properties\n * Classes for working with property records and descriptions.\n */\n/**\n * @docs-group-description Rendering\n * Classes for rendering the contents of views.\n */\n/**\n * @docs-group-description SelectionSet\n * Classes for working with the set of selected elements.\n * See [the learning articles]($docs/learning/frontend/index.md).\n */\n/**\n * @docs-group-description Tile\n * Classes for selecting and drawing tiles in views.\n */\n/**\n * @docs-group-description WebGL\n * Classes for interfacing to WebGL in browsers.\n */\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module OIDC */\r\n\r\nimport { AuthStatus, BeEvent, BentleyError, ClientRequestContext, Logger, LogLevel, assert } from \"@bentley/bentleyjs-core\";\r\nimport { AccessToken, IOidcFrontendClient, OidcClient, OidcFrontendClientConfiguration, UserInfo } from \"@bentley/imodeljs-clients\";\r\nimport { User, UserManager, UserManagerSettings, Log as OidcClientLog, Logger as IOidcClientLogger } from \"oidc-client\";\r\nimport { FrontendRequestContext } from \"../FrontendRequestContext\";\r\nimport { FrontendLoggerCategory } from \"../FrontendLoggerCategory\";\r\n\r\nconst loggerCategory: string = FrontendLoggerCategory.OidcBrowserClient;\r\n\r\n/** Utility to forward oidc-client logs to the Bentley logger */\r\nclass OidcClientLogger implements IOidcClientLogger {\r\n  private constructor() {\r\n  }\r\n\r\n  public debug(message?: any, ...optionalParams: any[]): void {\r\n    Logger.logTrace(loggerCategory, message, () => optionalParams);\r\n  }\r\n\r\n  public info(message?: any, ...optionalParams: any[]): void {\r\n    Logger.logInfo(loggerCategory, message, () => optionalParams);\r\n  }\r\n\r\n  public warn(message?: any, ...optionalParams: any[]): void {\r\n    Logger.logWarning(loggerCategory, message, () => optionalParams);\r\n  }\r\n\r\n  public error(message?: any, ...optionalParams: any[]): void {\r\n    Logger.logError(loggerCategory, message, () => optionalParams);\r\n  }\r\n\r\n  private static initializeLevel() {\r\n    const logLevel: LogLevel | undefined = Logger.getLevel(loggerCategory);\r\n    switch (logLevel) {\r\n      case LogLevel.Error:\r\n        OidcClientLog.level = OidcClientLog.ERROR;\r\n        break;\r\n      case LogLevel.Warning:\r\n        OidcClientLog.level = OidcClientLog.WARN;\r\n        break;\r\n      case LogLevel.Info:\r\n        OidcClientLog.level = OidcClientLog.INFO;\r\n        break;\r\n      case LogLevel.Trace:\r\n        OidcClientLog.level = OidcClientLog.DEBUG;\r\n        break;\r\n      case LogLevel.None:\r\n        OidcClientLog.level = OidcClientLog.NONE;\r\n        break;\r\n      default:\r\n    }\r\n  }\r\n\r\n  /** Initializes forwarding of OidcClient logs to the Bentley Logger */\r\n  public static initializeLogger() {\r\n    OidcClientLog.logger = new OidcClientLogger();\r\n    this.initializeLevel();\r\n  }\r\n\r\n  /** Resets (or clears) forwarding of OidcClient logs to the Bentley Logger */\r\n  public static reset() {\r\n    OidcClientLog.reset();\r\n  }\r\n}\r\n\r\n/**\r\n * Utility to generate OIDC/OAuth tokens for frontend applications\r\n * @beta\r\n */\r\nexport class OidcBrowserClient extends OidcClient implements IOidcFrontendClient {\r\n  private _userManager?: UserManager;\r\n  private _accessToken?: AccessToken;\r\n  private _redirectPath: string;\r\n\r\n  /** Constructor */\r\n  public constructor(private _configuration: OidcFrontendClientConfiguration) {\r\n    super();\r\n    const redirectUri: URL = new URL(this._configuration.redirectUri);\r\n    this._redirectPath = redirectUri.pathname;\r\n  }\r\n\r\n  /**\r\n   * Used to initialize the client - must be awaited before any other methods are called\r\n   * @throws [[Error]] in some cases of authorization failure\r\n   * - if the login times out without the user providing the necessary input, or\r\n   * - if the user hasn't consented to the scopes.\r\n   */\r\n  public async initialize(requestContext: FrontendRequestContext): Promise<void> {\r\n    /*\r\n     * Any redirection in a SPA causes the entire application to be re-initialized, and subsequently\r\n     * causes this method to be called again. This happens thrice during authorization:\r\n     * - when the application loads up for the first time (signIn hasn't happened yet)\r\n     * - when authorization provider causes browser to redirect to the supplied (and registered) redirectUri\r\n     * - when application causes a redirection after the token was retrieved\r\n     */\r\n\r\n    // Initialize user manager and logging\r\n    await this.createUserManager(requestContext);\r\n    OidcClientLogger.initializeLogger();\r\n\r\n    if (this.getIsRedirecting()) {\r\n      // Handle redirection to extract the accessToken\r\n      await this.handleRedirectCallback();\r\n    } else {\r\n      // Sign-in hasn't happened, or has just happened and we are in the final successful redirection\r\n      await this.nonInteractiveSignIn(requestContext); // load from state, or try silent sign-in\r\n    }\r\n  }\r\n\r\n  private getIsRedirecting(): boolean {\r\n    return (window.location.pathname === this._redirectPath);\r\n  }\r\n\r\n  /**\r\n   * Used to handle the redirection that happens as part of an orchestrated SignIn.\r\n   * If the current pathname is the redirect path, it triggers the redirect call back and completes\r\n   * the SignIn. The returned promise evaluates to true, and the browser is redirected back to the\r\n   * root path.\r\n   * If the current pathname is NOT the redirect path, the returned promise resolves right away with\r\n   * a false value.\r\n   * The application should use this method whenever a redirection happens - since redirection typically causes\r\n   * the re-initialization of a Single Page Application, this method is called already as part of the initialization\r\n   * routine.\r\n   */\r\n  private async handleRedirectCallback(): Promise<boolean> {\r\n    if (!this.getIsRedirecting())\r\n      return false;\r\n\r\n    try {\r\n      let user: User;\r\n      if (window.parent !== window) {\r\n        // This is an i-frame, and we are doing a silent signin.\r\n        await this._userManager!.signinSilentCallback();\r\n      } else {\r\n        user = await this._userManager!.signinRedirectCallback();\r\n        assert(user && !user.expired, \"Expected userManager.signinRedirectCallback to always resolve to authorized user\");\r\n        window.location.replace(user.state.successRedirectUrl);\r\n      }\r\n    } catch (err) {\r\n      Logger.logError(loggerCategory, \"Authentication error - cannot retrieve token after redirection\");\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Attempts a silent sign in with the authorization provider\r\n   * @return Resolves to authenticated user if the silent sign in succeeded\r\n   * @throws [[Error]] If the silent sign in fails\r\n   */\r\n  private async signInSilent(requestContext: ClientRequestContext): Promise<User> {\r\n    requestContext.enter();\r\n    assert(!!this._userManager, \"OidcBrowserClient not initialized\");\r\n\r\n    const user = await this._userManager!.signinSilent();\r\n    assert(user && !user.expired, \"Expected userManager.signinSilent to always resolve to authorized user\");\r\n    return user;\r\n  }\r\n\r\n  /**\r\n   * Gets the user from storage\r\n   * @return User found in storage.\r\n   * - Resolves to null if no user was found.\r\n   * - Does not call any events if the user is loaded from storage\r\n   * - Returned user may have expired - so it's up to the caller to check the expired state\r\n   */\r\n  private async getUser(requestContext: ClientRequestContext): Promise<User> {\r\n    requestContext.enter();\r\n    assert(!!this._userManager, \"OidcBrowserClient not initialized\");\r\n\r\n    return this._userManager!.getUser();\r\n  }\r\n\r\n  /**\r\n   * Attempts a non-interactive signIn\r\n   * - tries to load the user from session or local storage\r\n   * - tries to silently sign-in the user\r\n   */\r\n  private async nonInteractiveSignIn(requestContext: ClientRequestContext): Promise<boolean> {\r\n    // Load user from session/local storage\r\n    const user: User = await this.getUser(requestContext);\r\n    if (user && !user.expired) {\r\n      this._onUserLoaded(user); // Call only because getUser() doesn't call any events\r\n      return true;\r\n    }\r\n\r\n    // Attempt a silent sign-in\r\n    try {\r\n      await this.signInSilent(requestContext); // calls events\r\n    } catch (err) {\r\n      Logger.logInfo(loggerCategory, \"Silent sign-in failed\");\r\n      return false;\r\n    }\r\n\r\n    return true;\r\n  }\r\n\r\n  /**\r\n   * Start the sign-in process\r\n   * - calls the onUserStateChanged() call back after the authorization completes\r\n   * or if there is an error.\r\n   * - redirects application to the redirectUri specified in the configuration and then\r\n   * redirects back to root when sign-in is complete.\r\n   */\r\n  public async signIn(requestContext: ClientRequestContext, successRedirectUrl?: string): Promise<void> {\r\n    requestContext.enter();\r\n    if (!this._userManager)\r\n      throw new BentleyError(AuthStatus.Error, \"OidcBrowserClient not initialized\", Logger.logError, loggerCategory);\r\n\r\n    // Non interactive sign-in\r\n    const status: boolean = await this.nonInteractiveSignIn(requestContext);\r\n    if (status)\r\n      return;\r\n\r\n    // Attempt an interactive signin - returns a promise to redirect\r\n    await this._userManager!.signinRedirect({\r\n      data: {\r\n        successRedirectUrl: successRedirectUrl || window.location.href,\r\n      },\r\n    }); // tslint:disable-line:no-floating-promises\r\n  }\r\n\r\n  /**\r\n   * Start the sign-out process\r\n   * - calls the onUserStateChanged() call back after the authorization completes\r\n   *   or if there is an error.\r\n   * - redirects application to the postSignoutRedirectUri specified in the configuration when the sign out is\r\n   *   complete\r\n   */\r\n  public async signOut(requestContext: ClientRequestContext): Promise<void> {\r\n    requestContext.enter();\r\n    await this._userManager!.signoutRedirect(); // tslint:disable-line:no-floating-promises\r\n  }\r\n\r\n  /** Event called when the user's sign-in state changes - this may be due to calls to signIn(), signOut() or simply because the token expired */\r\n  public readonly onUserStateChanged = new BeEvent<(token: AccessToken | undefined) => void>();\r\n\r\n  /**\r\n   * Returns a promise that resolves to the AccessToken of the currently authorized user.\r\n   * The token is refreshed as necessary.\r\n   * @throws [[BentleyError]] If signIn() was not called, or there was an authorization error.\r\n   */\r\n  public async getAccessToken(requestContext?: ClientRequestContext): Promise<AccessToken> {\r\n    if (this._accessToken)\r\n      return this._accessToken;\r\n    if (requestContext)\r\n      requestContext.enter();\r\n    throw new BentleyError(AuthStatus.Error, \"Not signed in.\", Logger.logError, loggerCategory);\r\n  }\r\n\r\n  /**\r\n   * Set to true if there's a current authorized user or client (in the case of agent applications).\r\n   * Set to true if signed in and the access token has not expired, and false otherwise.\r\n   */\r\n  public get isAuthorized(): boolean {\r\n    return !!this._accessToken;\r\n  }\r\n\r\n  /** Set to true if the user has signed in, but the token has expired and requires a refresh */\r\n  public get hasExpired(): boolean {\r\n    return !!this._accessToken; // Always silently refreshed\r\n  }\r\n\r\n  /** Set to true if signed in - the accessToken may be active or may have expired and require a refresh */\r\n  public get hasSignedIn(): boolean {\r\n    return !!this._accessToken; // Always silently refreshed\r\n  }\r\n\r\n  /** Disposes the resources held by this client */\r\n  public dispose(): void {\r\n    if (!this._userManager)\r\n      return;\r\n    this._userManager.events.removeUserLoaded(this._onUserLoaded);\r\n    this._userManager.events.removeAccessTokenExpiring(this._onAccessTokenExpiring);\r\n    this._userManager.events.removeAccessTokenExpired(this._onAccessTokenExpired);\r\n    this._userManager.events.removeUserUnloaded(this._onUserUnloaded);\r\n    this._userManager.events.removeSilentRenewError(this._onSilentRenewError);\r\n    this._userManager.events.removeUserSignedOut(this._onUserSignedOut);\r\n    OidcClientLogger.reset();\r\n    this._userManager = undefined;\r\n  }\r\n\r\n  private async createUserManager(requestContext: FrontendRequestContext): Promise<UserManager> {\r\n    const settings: UserManagerSettings = await this.getUserManagerSettings(requestContext);\r\n\r\n    this._userManager = new UserManager(settings);\r\n    this._userManager.events.addUserLoaded(this._onUserLoaded);\r\n    this._userManager.events.addUserUnloaded(this._onUserUnloaded);\r\n    this._userManager.events.addAccessTokenExpiring(this._onAccessTokenExpiring);\r\n    this._userManager.events.addAccessTokenExpired(this._onAccessTokenExpired);\r\n    this._userManager.events.addSilentRenewError(this._onSilentRenewError);\r\n    this._userManager.events.addUserSignedOut(this._onUserSignedOut);\r\n\r\n    return this._userManager;\r\n  }\r\n\r\n  private async getUserManagerSettings(requestContext: FrontendRequestContext): Promise<UserManagerSettings> {\r\n    const userManagerSettings: UserManagerSettings = {\r\n      authority: await this.getUrl(requestContext),\r\n      client_id: this._configuration.clientId,\r\n      redirect_uri: this._configuration.redirectUri,\r\n      silent_redirect_uri: this._configuration.redirectUri,\r\n      post_logout_redirect_uri: this._configuration.postSignoutRedirectUri,\r\n      automaticSilentRenew: true,\r\n      response_type: \"id_token token\",\r\n      query_status_response_type: \"id_token token\",\r\n      scope: this._configuration.scope,\r\n    };\r\n    return userManagerSettings;\r\n  }\r\n\r\n  private initAccessToken(user: User | undefined) {\r\n    if (!user) {\r\n      this._accessToken = undefined;\r\n      return;\r\n    }\r\n\r\n    const startsAt: Date = new Date((user.expires_at - user.expires_in!) * 1000);\r\n    const expiresAt: Date = new Date(user.expires_at * 1000);\r\n    const userInfo = UserInfo.fromJson(user.profile);\r\n    this._accessToken = AccessToken.fromJsonWebTokenString(user.access_token, startsAt, expiresAt, userInfo);\r\n  }\r\n\r\n  private _onUserStateChanged = (user: User | undefined) => {\r\n    if (this.getIsRedirecting()) {\r\n      /*\r\n       * no need to raise the event when still redirecting, since\r\n       * the application will be refreshed after the authorization is complete.\r\n       * We as we're about to get a redirect\r\n       */\r\n      return;\r\n    }\r\n\r\n    this.initAccessToken(user);\r\n    try {\r\n      this.onUserStateChanged.raiseEvent(this._accessToken);\r\n    } catch (err) {\r\n      Logger.logError(loggerCategory, \"Error thrown when handing OidcBrowserClient.onUserStateChanged event\", () => ({ message: err.message }));\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Raised when a user session has been established (or re-established).\r\n   * This can happen on startup, after token refresh or token callback.\r\n   */\r\n  private _onUserLoaded = (user: User) => {\r\n    this._onUserStateChanged(user);\r\n  }\r\n\r\n  /**\r\n   * Raised when a user session has been terminated.\r\n   */\r\n  private _onUserUnloaded = () => {\r\n    this._onUserStateChanged(undefined);\r\n  }\r\n\r\n  /**\r\n   * Raised prior to the access token expiring\r\n   */\r\n  private _onAccessTokenExpiring = () => {\r\n  }\r\n\r\n  /**\r\n   * Raised after the access token has expired.\r\n   */\r\n  private _onAccessTokenExpired = () => {\r\n    this._onUserStateChanged(undefined);\r\n  }\r\n\r\n  /**\r\n   * Raised when the automatic silent renew has failed.\r\n   */\r\n  private _onSilentRenewError = () => {\r\n    this._onUserStateChanged(undefined);\r\n  }\r\n\r\n  /**\r\n   * Raised when the user's sign-in status at the OP has changed.\r\n   */\r\n  private _onUserSignedOut = () => {\r\n    this._onUserStateChanged(undefined);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Properties */\nimport { QuantityType } from \"../QuantityFormatter\";\n\n/**\n * Enumeration for Property Editor Param Types\n * @alpha\n */\nexport enum PropertyEditorParamTypes {\n  ButtonGroupData,\n  CheckBoxIcons,\n  Icon,\n  InputEditorSize,\n  JSON,\n  MultilineText,\n  Range,\n  Slider,\n  SuppressUnitLabel,\n  SuppressEditorLabel,\n  ColorData,\n  CustomFormattedNumber,\n}\n\n/**\n * Base interface for Property Editor Params\n * @alpha\n */\nexport interface BasePropertyEditorParams {\n  type: PropertyEditorParamTypes;\n}\n\n/**\n * Parameters used by PropertyEditors that use HTML <input> element.\n * @alpha\n */\nexport interface InputEditorSizeParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.InputEditorSize;\n  /** Optionally define the width in characters. */\n  size?: number;\n  /** Optionally define the maximum number of characters allowed. */\n  maxLength?: number;\n}\n\n/**\n * Parameters used to populate color type editor with a specific set of colors. If not specified the Color\n * Editor will show a default palette of 16 colors.\n * @alpha\n */\nexport interface ColorEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.ColorData;\n  /** array of color values to show in color picker popup. Use [[ColorByName]] enum values. Values should be 32-bit integer in the form 0xBBGGRR. */\n  colorValues: number[];\n  /** number of columns to show in color picker popup. The value of 4 is used if not defined. */\n  numColumns?: number;\n}\n\n/**\n * Information about an icon displayed next to a property editor.\n * @alpha\n */\nexport interface IconDefinition {\n  /** icon class name. */\n  iconClass: string;\n  isEnabledFunction?: () => boolean;\n}\n\n/**\n * Parameters used by EnumButtonGroupEditor to define icons in button group.\n * @alpha\n */\nexport interface ButtonGroupEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.ButtonGroupData;\n  buttons: IconDefinition[];\n}\n\n/**\n * Parameters used to suppress the label for a type editor in the ToolSettings widget.\n * @alpha\n */\nexport interface SuppressLabelEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.SuppressEditorLabel;\n  /** if false then an empty placeholder label is created. This is sometimes necessary to align editor in proper column */\n  suppressLabelPlaceholder?: boolean;\n}\n\n/**\n * Parameters used by PropertyEditors that support JSON.\n * @alpha\n */\nexport interface JsonEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.JSON;\n  json: any;\n}\n\n/**\n * Parameters used by PropertyEditors that support defining a minimum and maximum value.\n * @alpha\n */\nexport interface RangeEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.Range;\n  /** Optionally define the minimum value. */\n  minimum?: number;\n  /** Optionally define the maximum value. */\n  maximum?: number;\n}\n\n/**\n * Parameters used to indicate that a Slider should be presented for the property\n * and to specify the values needed by the slider.\n * @alpha\n */\nexport interface SliderEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.Slider;\n  /** Defines the minimum value. */\n  minimum: number;\n  /** Defines the maximum value. */\n  maximum: number;\n  /** Show buttons at intervals, requires NumButtons to be set. */\n  intervals?: boolean;\n  /** Number of interval buttons to display */\n  numButtons?: number;\n  /** If Vertical is set, the slider will display in a vertical orientation, default is to draw Horizontally. */\n  vertical?: boolean;\n  /** Since slider must work with integer values define factor used to produce a integer (0.1=10, 0.01=100, 0.001=1000). */\n  valueFactor?: number;\n}\n\n/**\n * Parameter that is used to indicate that a multiline text editor should be created.\n * The number of rows specified will determine the height of the editor control.\n * @alpha\n */\nexport interface MultilineTextEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.MultilineText;\n  heightInRows: number;\n}\n\n/**\n * Parameters used to display an icon next to property editor.\n * @alpha\n */\nexport interface IconEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.Icon;\n  definition: IconDefinition;\n}\n\n/**\n * Parameters used with boolean properties to indicate icon overrides.\n * @alpha\n */\nexport interface CheckBoxIconsEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.CheckBoxIcons;\n  onIconDefinition?: IconDefinition;\n  offIconDefinition?: IconDefinition;\n}\n\n/**\n * Parameter used to suppress Unit labels\n * @alpha\n */\nexport interface SuppressUnitLabelEditorParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.SuppressUnitLabel;\n}\n\n/**\n * defines Results of parsing a string input by a user into its desired value type\n * @alpha\n */\nexport interface ParseResults {\n  value?: string | number | boolean | {} | string[] | Date | [] | undefined;\n  parseError?: string;\n}\n\n/**\n * Parameters used with properties that want to control parsing and formatting.\n * @alpha\n */\nexport interface CustomFormattedNumberParams extends BasePropertyEditorParams {\n  type: PropertyEditorParamTypes.CustomFormattedNumber;\n  formatFunction: (numberValue: number, quantityType?: QuantityType | string) => string;\n  parseFunction: (stringValue: string, quantityType?: QuantityType | string) => ParseResults;\n}\n\n/**\n * Type definition for all Property Editor params\n * @alpha\n */\nexport type PropertyEditorParams = ButtonGroupEditorParams | ColorEditorParams | InputEditorSizeParams | SuppressLabelEditorParams | BasePropertyEditorParams | CustomFormattedNumberParams;\n/*  Not yet supported\n  |  JsonEditorParams | RangeEditorParams | SliderEditorParams |\n  | IconEditorParams | CheckBoxIconsEditorParams | SuppressUnitLabelEditorParams\n*/\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Properties */\nimport { PropertyDescription } from \"./Description\";\nimport { PropertyValue } from \"./Value\";\n\n/** Properties for the [[PropertyRecord]] with link info supplied\n * @beta\n */\nexport interface LinkElementsInfo {\n  /** Callback to link click event */\n  onClick: (record: PropertyRecord, text: string) => void;\n  /**\n   * Function that specifies which parts of display value need to be clickable.\n   *\n   * Letters will be picked from __start__ index to __end__ index. __end__ index is not included.\n   * For a string _\"example\"_ and a match ```{ start: 1, end: 3 }```, _\"xa\"_ will be clickable.\n   */\n  matcher?: (displayValue: string) => Array<{ start: number, end: number }>;\n}\n\n/**\n * PropertyRecord contains instance information about a Property, including a\n * value that can be edited using a PropertyEditor and converted using a TypeConverter.\n * @beta\n */\nexport class PropertyRecord {\n  public readonly value: PropertyValue;\n  public readonly property: PropertyDescription;\n  public description?: string;\n  public isReadonly?: boolean;\n  public isDisabled?: boolean;\n  public isMerged?: boolean;\n  public extendedData?: { [key: string]: any };\n\n  /** Properties for link logic */\n  public links?: LinkElementsInfo;\n\n  public constructor(value: PropertyValue, property: PropertyDescription) {\n    this.value = value;\n    this.property = property;\n  }\n\n  /** Creates a copy of this PropertyRecord with a new value */\n  public copyWithNewValue(newValue: PropertyValue): PropertyRecord {\n    return new PropertyRecord(newValue, this.property);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Properties */\r\n\r\n// import { HorizontalAlignment, VerticalAlignment } from \"@bentley/ui-core\";\r\nimport { PropertyDescription } from \"./Description\";\r\nimport { PrimitiveValue, PropertyValue, PropertyValueFormat } from \"./Value\";\r\nimport { PropertyRecord } from \"./Record\";\r\n\r\n/** Primitive ToolSettings Value.\r\n * @beta\r\n */\r\nexport class ToolSettingsValue implements PrimitiveValue {\r\n  public readonly valueFormat = PropertyValueFormat.Primitive;\r\n  public value?: number | string | boolean | Date;\r\n  public displayValue?: string;\r\n\r\n  public constructor(value?: number | string | boolean | Date, displayValue?: string) {\r\n    this.value = value;\r\n    this.displayValue = displayValue;\r\n  }\r\n\r\n  public get isNullValue(): boolean {\r\n    return undefined === this.value;\r\n  }\r\n\r\n  public get hasDisplayValue(): boolean {\r\n    return undefined !== this.displayValue;\r\n  }\r\n\r\n  public update(newValue: ToolSettingsValue): boolean {\r\n    if (newValue.valueFormat !== this.valueFormat)\r\n      throw new Error(\"ToolSettingsValue.update requires both values to be of the same format\");\r\n\r\n    if (this.value === newValue.value && this.displayValue === newValue.displayValue)\r\n      return false;\r\n\r\n    this.value = newValue.value;\r\n    this.displayValue = newValue.displayValue;\r\n    return true;\r\n  }\r\n\r\n  public clone(): ToolSettingsValue {\r\n    return new ToolSettingsValue(this.value, this.displayValue);\r\n  }\r\n}\r\n\r\n/** Interface used to identify the location of the UI control to manipulate a ToolSettings property value.\r\n * @beta\r\n */\r\nexport interface EditorPosition {\r\n  /** Determine the order the row is shown in UI */\r\n  rowPriority: number;\r\n  /** Determines the column position for the type editor */\r\n  columnIndex: number;\r\n  /** Number of columns to occupy. Defaults to 1 */\r\n  columnSpan?: number;\r\n}\r\n\r\n/** Class used to identify a specific ToolSettings property value. This is the minimal amount of info necessary to specify which property a value is associated with. This is used to both\r\n * display property in UI, save and retrieve the state of the property, and to allow the UI to inform the Tool code about property changes.\r\n * @beta\r\n */\r\nexport class ToolSettingsPropertyItem {\r\n  public value: ToolSettingsValue;\r\n  public propertyName: string;\r\n\r\n  public constructor(value: ToolSettingsValue, propertyName: string) {\r\n    this.value = value;\r\n    this.propertyName = propertyName;\r\n  }\r\n}\r\n/** Class used to identify a specific ToolSettings property value that can be enabled/disabled in UI.\r\n * @beta\r\n */\r\nexport class ToolSettingsPropertySyncItem extends ToolSettingsPropertyItem {\r\n  /** used to pass enable state to Ui from Tool so property record can be updated */\r\n  public isDisabled?: boolean;\r\n\r\n  public constructor(value: ToolSettingsValue, propertyName: string, isDisabled?: boolean) {\r\n    super(value, propertyName);\r\n    this.isDisabled = isDisabled;\r\n  }\r\n}\r\n\r\n/** Property Record to specify an editor in Tool Settings zone.\r\n * @beta\r\n */\r\nexport class ToolSettingsPropertyRecord extends PropertyRecord {\r\n  public editorPosition: EditorPosition;\r\n\r\n  public constructor(value: PropertyValue, property: PropertyDescription, editorPosition: EditorPosition, isReadonly = false) {\r\n    super(value, property);\r\n    this.editorPosition = editorPosition;\r\n    this.isReadonly = isReadonly;\r\n  }\r\n\r\n  public static clone(record: ToolSettingsPropertyRecord, newValue?: ToolSettingsValue): ToolSettingsPropertyRecord {\r\n    const value = Object.assign({}, newValue ? newValue : record.value);\r\n    const newRecord = new ToolSettingsPropertyRecord(value, record.property, record.editorPosition, record.isReadonly);\r\n    newRecord.isDisabled = record.isDisabled;\r\n    return newRecord;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Properties */\n\nimport { PropertyRecord } from \"./Record\";\nimport { Primitives } from \"./PrimitiveTypes\";\n\n/**\n * Enumeration for Format of the property value.\n * @beta\n */\nexport enum PropertyValueFormat {\n  Primitive,\n  Array,\n  Struct,\n}\n\n/** Base interface for a property value\n * @beta\n */\nexport interface BasePropertyValue {\n  valueFormat: PropertyValueFormat;\n}\n\n/** Primitive property value\n * @beta\n */\nexport interface PrimitiveValue extends BasePropertyValue {\n  valueFormat: PropertyValueFormat.Primitive;\n  value?: Primitives.Value;\n  displayValue?: string;\n}\n\n/** Struct property value\n * @beta\n */\nexport interface StructValue extends BasePropertyValue {\n  valueFormat: PropertyValueFormat.Struct;\n  members: { [name: string]: PropertyRecord };\n}\n\n/** Array property value\n * @beta\n */\nexport interface ArrayValue extends BasePropertyValue {\n  valueFormat: PropertyValueFormat.Array;\n  items: PropertyRecord[];\n  itemsTypeName: string;\n}\n\n/** Type for all property values\n * @beta\n */\nexport type PropertyValue = PrimitiveValue | StructValue | ArrayValue;\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { LinePixels, ColorDef, RgbColor, Feature, GeometryClass, SubCategoryOverride, BatchType } from \"@bentley/imodeljs-common\";\nimport { Id64, Id64String, Id64Set } from \"@bentley/bentleyjs-core\";\nimport { Viewport } from \"../Viewport\";\nimport { ViewState } from \"../ViewState\";\n\nfunction copyIdSetToUint32Set(dst: Id64.Uint32Set, src?: Set<string>): void {\n  dst.clear();\n  if (undefined !== src) {\n    for (const id of src)\n      dst.addId(id);\n  }\n}\n\n/** Contains types that enable an application to customize how [Feature]($common)s are drawn within a [[Viewport]].\n * @public\n */\nexport namespace FeatureSymbology {\n  /** Properties used to initialize a [[FeatureSymbology.Appearance]]. */\n  export interface AppearanceProps {\n    /** The color of the Appearance */\n    rgb?: RgbColor;\n    /** The line weight of the Appearance */\n    weight?: number;\n    /** The transparency in the range [0.0, 1.0] where 0 indicates fully opaque and 1 indicates fully transparent. */\n    transparency?: number;\n    /** The pixel pattern used to draw lines. */\n    linePixels?: LinePixels;\n    /** If true, ignore the [RenderMaterial]($common) associated with surfaces. */\n    ignoresMaterial?: true | undefined;\n    /** If true, the associated [Feature]($common)s will not be drawn when using [[Viewport.readPixels]]. */\n    nonLocatable?: true | undefined;\n  }\n\n  /** Defines overrides for selected aspects of a [Feature]($common)'s symbology.\n   * Any member defined in the Appearance overrides that aspect of symbology for all [Feature]($common)s to which the Appearance is applied.\n   * @see [[FeatureSymbology.Overrides]]\n   */\n  export class Appearance implements AppearanceProps {\n    /** The rgb color. */\n    public readonly rgb?: RgbColor;\n    /** The line width, in pixels. */\n    public readonly weight?: number;\n    /** The transparency in the range [0.0, 1.0] where 0 indicates fully opaque and 1 indicates fully transparent. */\n    public readonly transparency?: number;\n    /** The pixel pattern used to draw lines. */\n    public readonly linePixels?: LinePixels;\n    /** If true, ignore the [RenderMaterial]($common) associated with surfaces. */\n    public readonly ignoresMaterial?: true | undefined;\n    /** If true, ignore the [Feature]($common) when using [[Viewport.readPixels]]. */\n    public readonly nonLocatable?: true | undefined;\n\n    /** An Appearance which overrides nothing. */\n    public static readonly defaults = new Appearance({});\n\n    public static fromJSON(props?: AppearanceProps) {\n      if (undefined === props || (undefined === props.rgb && undefined === props.weight && undefined === props.transparency && undefined === props.linePixels && !props.ignoresMaterial && !props.nonLocatable))\n        return this.defaults;\n      else\n        return new Appearance(props);\n    }\n\n    /** Create an Appearance that overrides only the RGB color of a [Feature]($common).\n     * @note The transparency component of the ColorDef is ignored.\n     */\n    public static fromRgb(color: ColorDef): Appearance { return this.fromJSON({ rgb: RgbColor.fromColorDef(color) }); }\n\n    /** Create an Appearance that overrides the RGB and transparency of a Feature.\n     * The Appearance's transparency is derived from the transparency component of the ColorDef.\n     */\n    public static fromRgba(color: ColorDef): Appearance {\n      return this.fromJSON({\n        rgb: RgbColor.fromColorDef(color),\n        transparency: color.colors.t / 255,\n      });\n    }\n    /** Create an Appearance that overrides only the transparency */\n    public static fromTransparency(transparencyValue: number) { return this.fromJSON({ transparency: transparencyValue }); }\n\n    /** Create an Appearance with overrides corresponding to those defined by the supplied SubCategoryOverride. */\n    public static fromSubCategoryOverride(ovr: SubCategoryOverride): Appearance {\n      const rgb = undefined !== ovr.color ? RgbColor.fromColorDef(ovr.color) : undefined;\n      const transparency = undefined !== ovr.transparency ? ovr.transparency : undefined;\n      const weight = undefined !== ovr.weight ? ovr.weight : undefined;\n      const ignoresMaterial = undefined !== ovr.material && Id64.isValid(ovr.material) ? true : undefined;\n      return this.fromJSON({ rgb, transparency, weight, ignoresMaterial });\n    }\n\n    public get overridesRgb(): boolean { return undefined !== this.rgb; }\n    public get overridesTransparency(): boolean { return undefined !== this.transparency; }\n    public get overridesLinePixels(): boolean { return undefined !== this.linePixels; }\n    public get overridesWeight(): boolean { return undefined !== this.weight; }\n    public get overridesSymbology(): boolean { return this.overridesRgb || this.overridesTransparency || this.overridesWeight || this.overridesLinePixels || !!this.ignoresMaterial; }\n    public get isFullyTransparent(): boolean { return undefined !== this.transparency && this.transparency >= 1.0; }\n\n    public equals(other: Appearance): boolean {\n      return this.rgbIsEqual(other.rgb) && this.weight === other.weight && this.transparency === other.transparency && this.linePixels === other.linePixels && this.ignoresMaterial === other.ignoresMaterial;\n    }\n\n    public toJSON(): AppearanceProps {\n      return {\n        rgb: this.rgb,\n        weight: this.weight,\n        transparency: this.transparency,\n        linePixels: this.linePixels,\n        ignoresMaterial: this.ignoresMaterial ? true : undefined,\n        nonLocatable: this.nonLocatable ? true : undefined,\n      };\n    }\n\n    /** Produce an Appearance from the supplied Appearance in which any aspect not defined by the base Appearance is overridden by this Appearance. */\n    public extendAppearance(base: Appearance): Appearance {\n      if (!this.overridesSymbology)\n        return base;\n\n      const props = base.toJSON();\n      if (undefined === props.rgb) props.rgb = this.rgb;\n      if (undefined === props.transparency) props.transparency = this.transparency;\n      if (undefined === props.linePixels) props.linePixels = this.linePixels;\n      if (undefined === props.weight) props.weight = this.weight;\n      if (undefined === props.ignoresMaterial && this.ignoresMaterial) props.ignoresMaterial = true;\n      if (undefined === props.nonLocatable && this.nonLocatable) props.nonLocatable = true;\n\n      return Appearance.fromJSON(props);\n    }\n\n    private constructor(props: AppearanceProps) {\n      this.rgb = props.rgb;\n      this.weight = props.weight;\n      this.transparency = props.transparency;\n      this.linePixels = props.linePixels;\n      this.ignoresMaterial = props.ignoresMaterial;\n      this.nonLocatable = props.nonLocatable;\n\n      if (undefined !== this.weight)\n        this.weight = Math.max(1, Math.min(this.weight, 32));\n\n      if (undefined !== this.transparency) {\n        this.transparency = Math.max(0, Math.min(this.transparency, 1));\n\n        // Fix up rounding errors...\n        const smallDelta = 0.0001;\n        if (1.0 - this.transparency < smallDelta)\n          this.transparency = 1.0;\n        else if (this.transparency < smallDelta)\n          this.transparency = 0.0;\n      }\n    }\n\n    private rgbIsEqual(rgb?: RgbColor): boolean { return undefined === this.rgb ? undefined === rgb ? true : false : undefined === rgb ? false : this.rgb.equals(rgb); }\n  }\n\n  /** Allows a [[Viewport]] to customize the appearance of individual [Feature]($common)s within it.\n   *\n   * The Viewport computes its base Overrides based on the following:\n   *  - The set of categories enabled for display in its [[CategorySelectorState]]. Every [[SubCategory]] belonging to an enabled [[Category]] is added to the set of visible subcategories - all other subcategories are assumed to be invisible.\n   *  - For the set of visible subcategories, any [[SubCategoryOverride]]s defined by the view's [[DisplayStyleState]] are applied. This may render some subcategories invisible, and change the symbology of others.\n   *  - The visibility of each [GeometryClass]($common) is set based on the view's [[ViewFlags]].\n   *  - The line weight is overridden to 1 pixel for all Features if line weight has been disabled by the view's [[ViewFlags]].\n   *  - The sets of elements which are always drawn and never drawn are initialized from the [[Viewport]]'s sets.\n   * An application can further customize the symbology of any Features by registering a [[FeatureOverrideProvider]] with a [[Viewport]]. That provider's addFeatureOverrides function will be invoked\n   * whenever the Overrides need to be regenerated.\n   *\n   * To override the symbology of *most* Features within a view, specify a [[defaultOverrides]] to be applied to any Feature not explicitly overridden.\n   * If default overrides are defined and some Features should draw normally without being affected by the default overrides, override that Feature with\n   * an Appearance which defines no overrides.\n   *\n   * It is possible to override multiple aspects of a Feature. For example, you might specify that all elements belonging to subcategory \"A\" should be drawn in red, and\n   * that the element with Id \"0x123\" should be drawn with 0.25 transparency. In this case, when drawing a Feature with subcategory \"A\" and element Id \"0x123\", the two overrides will\n   * be merged, causing the Feature's geometry to draw 25% transparent red. On the other hand, if subcategory \"A\" is specified to draw in red and element \"0x123\" to draw in green,\n   * the color specified by the element override will take precedence over that specified for the subcategory, resulting in a green Feature.\n   *\n   * @see [[Viewport.alwaysDrawn]]\n   * @see [[Viewport.neverDrawn]]\n   */\n  export class Overrides {\n    /** Ids of elements which should never be drawn. This takes precedence over [[_alwaysDrawn]]. @internal */\n    protected readonly _neverDrawn = new Id64.Uint32Set();\n    /** Ids of elements which should always be drawn. [[_neverDrawn]] takes precedence over this set. @internal */\n    protected readonly _alwaysDrawn = new Id64.Uint32Set();\n    /** If true, no elements *except* those defined in the \"always drawn\" set will be drawn.\n     * @see [[setAlwaysDrawn]]\n     */\n    public isAlwaysDrawnExclusive = false;\n\n    /** Overrides applied to any feature not explicitly overridden. @internal */\n    protected _defaultOverrides = Appearance.defaults;\n    /** Whether construction geometry should be drawn. @internal */\n    protected _constructions = false;\n    /** Whether dimensions should be drawn. @internal */\n    protected _dimensions = false;\n    /** Whether area patterns should be drawn. @internal */\n    protected _patterns = false;\n    /** Whether line weights should be applied. If false, all lines are rendered 1-pixel wide. @internal */\n    protected _lineWeights = true;\n\n    /** Overrides applied to all elements belonging to each model. @internal */\n    protected readonly _modelOverrides = new Id64.Uint32Map<Appearance>();\n    /** Overrides applied to specific elements. @internal */\n    protected readonly _elementOverrides = new Id64.Uint32Map<Appearance>();\n    /** Overrides applied to geometry belonging to each subcategory. @internal */\n    protected readonly _subCategoryOverrides = new Id64.Uint32Map<Appearance>();\n    /** The set of displayed subcategories. Geometry belonging to subcategories not included in this set will not be drawn. @internal */\n    protected readonly _visibleSubCategories = new Id64.Uint32Set();\n\n    /** Per-model, a set of subcategories whose visibility should be inverted for elements within that model.\n     * Populated by Viewport.\n     * @internal\n     */\n    protected readonly _modelSubCategoryOverrides = new Id64.Uint32Map<Id64.Uint32Set>();\n\n    /** Ids of animation nodes which should never be drawn.\n     * @internal\n     */\n    public readonly neverDrawnAnimationNodes = new Set<number>();\n    /** Mapping of animation node Ids to overrides applied to the corresponding animation nodes.\n     * @internal\n     */\n    public readonly animationNodeOverrides = new Map<number, Appearance>();\n\n    /** Overrides applied to features for which no other overrides are defined */\n    public get defaultOverrides(): Appearance { return this._defaultOverrides; }\n    /** Whether or not line weights are applied. If false, all lines are drawn with a weight of 1. */\n    public get lineWeights(): boolean { return this._lineWeights; }\n\n    /** @internal */\n    protected isNeverDrawn(elemIdLo: number, elemIdHi: number, animationNodeId: number): boolean {\n      if (this._neverDrawn.has(elemIdLo, elemIdHi))\n        return true;\n      else\n        return 0 !== animationNodeId && this.neverDrawnAnimationNodes.has(animationNodeId);\n    }\n    /** @internal */\n    protected isAlwaysDrawn(idLo: number, idHi: number): boolean { return this._alwaysDrawn.has(idLo, idHi); }\n    /** Returns true if the [[SubCategory]] specified by Id is in the set of visible subcategories. @internal */\n    public isSubCategoryVisible(idLo: number, idHi: number): boolean { return this._visibleSubCategories.has(idLo, idHi); }\n    /** @internal */\n    public isSubCategoryVisibleInModel(subcatLo: number, subcatHi: number, modelLo: number, modelHi: number): boolean {\n      let vis = this.isSubCategoryVisible(subcatLo, subcatHi);\n      const modelOvr = this._modelSubCategoryOverrides.get(modelLo, modelHi);\n      if (undefined !== modelOvr && modelOvr.has(subcatLo, subcatHi))\n        vis = !vis;\n\n      return vis;\n    }\n\n    /** @internal */\n    protected getModelOverrides(idLo: number, idHi: number): Appearance | undefined { return this._modelOverrides.get(idLo, idHi); }\n    /** @internal */\n    protected getElementOverrides(idLo: number, idHi: number, animationNodeId: number): Appearance | undefined {\n      const app = this._elementOverrides.get(idLo, idHi);\n      if (app !== undefined || 0 === animationNodeId)\n        return app;\n\n      return this.animationNodeOverrides.get(animationNodeId);\n    }\n    /** @internal */\n    protected getSubCategoryOverrides(idLo: number, idHi: number): Appearance | undefined { return this._subCategoryOverrides.get(idLo, idHi); }\n\n    /** Add a [[SubCategory]] to the set of visible subcategories. */\n    public setVisibleSubCategory(id: Id64String): void { this._visibleSubCategories.addId(id); }\n    /** Specify the Id of an element which should never be drawn in this view. */\n    public setNeverDrawn(id: Id64String): void { this._neverDrawn.addId(id); }\n    /** Specify the Id of an element which should always be drawn in this view. */\n    public setAlwaysDrawn(id: Id64String): void { this._alwaysDrawn.addId(id); }\n    /** Specify the Id of a animation node which should never be drawn in this view. */\n    public setAnimationNodeNeverDrawn(id: number): void { this.neverDrawnAnimationNodes.add(id); }\n    /** Specify the Ids of elements which should never be drawn in this view. */\n    public setNeverDrawnSet(ids: Id64Set) { copyIdSetToUint32Set(this._neverDrawn, ids); }\n    /** Specify the Ids of elements which should always be drawn in this view. */\n    public setAlwaysDrawnSet(ids: Id64Set, exclusive: boolean) { copyIdSetToUint32Set(this._alwaysDrawn, ids); this.isAlwaysDrawnExclusive = exclusive; }\n\n    /** Returns the feature's Appearance overrides, or undefined if the feature is not visible. */\n    public getFeatureAppearance(feature: Feature, modelId: Id64String, type: BatchType = BatchType.Primary): Appearance | undefined {\n      return this.getAppearance(\n        Id64.getLowerUint32(feature.elementId), Id64.getUpperUint32(feature.elementId),\n        Id64.getLowerUint32(feature.subCategoryId), Id64.getUpperUint32(feature.subCategoryId),\n        feature.geometryClass,\n        Id64.getLowerUint32(modelId), Id64.getUpperUint32(modelId),\n        type, 0);\n    }\n\n    private static readonly _weight1Appearance = Appearance.fromJSON({ weight: 1 });\n\n    /** Returns a feature's Appearance overrides, or undefined if the feature is not visible.\n     * Takes Id64s as pairs of unsigned 32-bit integers, because that is how they are stored by the PackedFeatureTable associated with each batch of graphics.\n     * This API is much uglier but also much more efficient.\n     * @internal\n     */\n    public getAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, geomClass: GeometryClass, modelLo: number, modelHi: number, type: BatchType, animationNodeId: number): Appearance | undefined {\n      if (BatchType.VolumeClassifier === type)\n        return this.getClassifierAppearance(elemLo, elemHi, subcatLo, subcatHi, modelLo, modelHi);\n\n      let app = !this._lineWeights ? Overrides._weight1Appearance : Appearance.defaults;\n      const modelApp = this.getModelOverrides(modelLo, modelHi);\n      if (undefined !== modelApp)\n        app = modelApp.extendAppearance(app);\n\n      // Is the element visible?\n      let elemApp, alwaysDrawn = false;\n\n      if (Id64.isValidUint32Pair(elemLo, elemHi)) {\n        if (this.isNeverDrawn(elemLo, elemHi, animationNodeId))\n          return undefined;\n\n        alwaysDrawn = this.isAlwaysDrawn(elemLo, elemHi);\n        if (!alwaysDrawn && this.isAlwaysDrawnExclusive)\n          return undefined;\n\n        // Element overrides take precedence\n        elemApp = this.getElementOverrides(elemLo, elemHi, animationNodeId);\n        if (undefined !== elemApp)\n          app = undefined !== modelApp ? elemApp.extendAppearance(app) : elemApp;\n      }\n\n      if (Id64.isValidUint32Pair(subcatLo, subcatHi)) {\n        if (!alwaysDrawn && !this.isSubCategoryVisibleInModel(subcatLo, subcatHi, modelLo, modelHi))\n          return undefined;\n\n        const subCat = this.getSubCategoryOverrides(subcatLo, subcatHi);\n        if (undefined !== subCat)\n          app = subCat.extendAppearance(app);\n      }\n\n      if (undefined === elemApp && undefined === modelApp)\n        app = this._defaultOverrides.extendAppearance(app);\n\n      let visible = alwaysDrawn || this.isClassVisible(geomClass);\n      if (visible && app.isFullyTransparent)\n        visible = false; // don't bother rendering something with full transparency...\n\n      return visible ? app : undefined;\n    }\n\n    /** Classifiers behave totally differently...in particular they are never invisible unless fully-transparent.\n     * @internal\n     */\n    protected getClassifierAppearance(elemLo: number, elemHi: number, subcatLo: number, subcatHi: number, modelLo: number, modelHi: number): Appearance | undefined {\n      let app = Appearance.defaults;\n      const modelApp = this.getModelOverrides(modelLo, modelHi);\n      if (undefined !== modelApp)\n        app = modelApp.extendAppearance(app);\n\n      const elemApp = this.getElementOverrides(elemLo, elemHi, 0);\n      if (undefined !== elemApp)\n        app = undefined !== modelApp ? elemApp.extendAppearance(app) : elemApp;\n\n      if (Id64.isValidUint32Pair(subcatLo, subcatHi)) {\n        const subCat = this.getSubCategoryOverrides(subcatLo, subcatHi);\n        if (undefined !== subCat)\n          app = subCat.extendAppearance(app);\n      }\n\n      if (undefined === elemApp && undefined === modelApp)\n        app = this._defaultOverrides.extendAppearance(app);\n\n      if (app.isFullyTransparent)\n        return undefined;\n      else\n        return app;\n    }\n\n    /** @internal */\n    public isClassVisible(geomClass: GeometryClass): boolean {\n      switch (geomClass) {\n        case GeometryClass.Construction: return this._constructions;\n        case GeometryClass.Dimension: return this._dimensions;\n        case GeometryClass.Pattern: return this._patterns;\n        default: return true;\n      }\n    }\n\n    /** Specify overrides for all elements within the specified model.\n     * @param id The Id of the model.\n     * @param app The symbology overrides.\n     * @param replaceExisting Specifies whether to replace a pre-existing override for the same model.\n     * @note These overrides take priority over all other overrides.\n     * @note If [[defaultOverrides]] are defined, they will not apply to any element within this model, even if the supplied Appearance overrides nothing.\n     */\n    public overrideModel(id: Id64String, app: Appearance, replaceExisting: boolean = true): void {\n      const idLo = Id64.getLowerUint32(id);\n      const idHi = Id64.getUpperUint32(id);\n      if (replaceExisting || undefined === this.getModelOverrides(idLo, idHi))\n        this._modelOverrides.set(idLo, idHi, app);\n    }\n\n    /** Specify overrides for all geometry belonging to the specified [[SubCategory]].\n     * @param id The Id of the subcategory.\n     * @param app The symbology overrides.\n     * @param replaceExisting Specifies whether to replace a pre-existing override for the same subcategory.\n     * @note These overrides have lower priority than element and model overrides.\n     * @note If [[defaultOverrides]] are defined, they will not apply to any geometry within this subcategory, even if the supplied Appearance overrides nothing.\n     */\n    public overrideSubCategory(id: Id64String, app: Appearance, replaceExisting: boolean = true): void {\n      // NB: We used to do nothing if this.isSubCategoryVisible() => false but now models can turn invisible subcategories visible in their own context.\n      const idLo = Id64.getLowerUint32(id);\n      const idHi = Id64.getUpperUint32(id);\n\n      // NB: Appearance may specify no overridden symbology - this means \"don't apply the default overrides to this subcategory\"\n      if (replaceExisting || undefined === this.getSubCategoryOverrides(idLo, idHi))\n        this._subCategoryOverrides.set(idLo, idHi, app);\n    }\n\n    /** Specify overrides for all geometry originating from the specified element.\n     * @param id The Id of the element.\n     * @param app The symbology overrides.\n     * @param replaceExisting Specifies whether to replace a pre-existing override for the same element.\n     * @note These overrides take precedence over subcategory overrides, but not over model overrides.\n     * @note If [[defaultOverrides]] are defined, they will not apply to this element, even if the supplied Appearance overrides nothing.\n     */\n    public overrideElement(id: Id64String, app: Appearance, replaceExisting: boolean = true): void {\n      const idLo = Id64.getLowerUint32(id);\n      const idHi = Id64.getUpperUint32(id);\n      if (this.isNeverDrawn(idLo, idHi, 0))\n        return;\n\n      // NB: Appearance may specify no overridden symbology - this means \"don't apply the default overrides to this element\"\n      if (replaceExisting || undefined === this.getElementOverrides(idLo, idHi, 0))\n        this._elementOverrides.set(idLo, idHi, app);\n    }\n    /** Specify overrides for all geometry originating from the specified animation node.\n     * @param id The Id of the animation node.\n     * @param app The symbology overrides.\n     * @note These overides do not take precedence over element overrides.\n     */\n    public overrideAnimationNode(id: number, app: Appearance): void { this.animationNodeOverrides.set(id, app); }\n\n    /** Defines a default Appearance to be applied to any [Feature]($common) *not* explicitly overridden.\n     * @param appearance The symbology overides.\n     * @param replaceExisting Specifies whether to replace the current default overrides if they are already defined.\n     */\n    public setDefaultOverrides(appearance: Appearance, replaceExisting: boolean = true): void {\n      if (replaceExisting || !appearance.overridesSymbology)\n        this._defaultOverrides = appearance;\n    }\n\n    /** Initialize these Overrides based on a specific view.\n     * @internal\n     */\n    public initFromView(view: ViewState): void {\n      this._initFromView(view);\n      this._initSubCategoryOverrides(view);\n    }\n\n    /** Initialize these Overrides based on a specific viewport.\n     * @internal\n     */\n    public initFromViewport(viewport: Viewport): void {\n      const view = viewport.view;\n      this._initFromView(view);\n\n      if (undefined !== viewport.neverDrawn)\n        this.setNeverDrawnSet(viewport.neverDrawn);\n\n      if (undefined !== viewport.alwaysDrawn)\n        this.setAlwaysDrawnSet(viewport.alwaysDrawn, viewport.isAlwaysDrawnExclusive);\n\n      if (undefined !== view.scheduleScript)\n        view.scheduleScript.getSymbologyOverrides(this, viewport.scheduleTime);\n\n      if (undefined !== viewport.featureOverrideProvider)\n        viewport.featureOverrideProvider.addFeatureOverrides(this, viewport);\n\n      viewport.addModelSubCategoryVisibilityOverrides(this, this._modelSubCategoryOverrides);\n\n      // This will include any per-model subcategory visibility overrides added above.\n      this._initSubCategoryOverrides(view);\n    }\n\n    private _initFromView(view: ViewState): void {\n      const { viewFlags } = view;\n      const { constructions, dimensions, patterns } = viewFlags;\n\n      this.neverDrawnAnimationNodes.clear();\n      this.animationNodeOverrides.clear();\n\n      const excludedElements = view.displayStyle.settings.excludedElements;\n      excludedElements.forEach((element: Id64String) => {\n        this.setNeverDrawn(element);\n      });\n\n      this._constructions = constructions;\n      this._dimensions = dimensions;\n      this._patterns = patterns;\n      this._lineWeights = viewFlags.weights;\n\n      for (const categoryId of view.categorySelector.categories) {\n        const subCategoryIds = view.iModel.subcategories.getSubCategories(categoryId);\n        if (undefined === subCategoryIds)\n          continue;\n\n        for (const subCategoryId of subCategoryIds) {\n          if (view.isSubCategoryVisible(subCategoryId)) {\n            const idLo = Id64.getLowerUint32(subCategoryId);\n            const idHi = Id64.getUpperUint32(subCategoryId);\n            this._visibleSubCategories.add(idLo, idHi);\n          }\n        }\n      }\n    }\n\n    private _initSubCategoryOverrides(view: ViewState): void {\n      const addOverride = (idLo: number, idHi: number) => {\n        const subCategoryId = Id64.fromUint32Pair(idLo, idHi);\n        const ovr = view.getSubCategoryOverride(subCategoryId);\n        if (undefined !== ovr) {\n          const app = Appearance.fromSubCategoryOverride(ovr);\n          if (app.overridesSymbology)\n            this._subCategoryOverrides.set(idLo, idHi, app);\n        }\n      };\n\n      // Add overrides for all subcategories visible in the view\n      this._visibleSubCategories.forEach((idLo: number, idHi: number) => {\n        addOverride(idLo, idHi);\n      });\n\n      // Add overrides for all subcategories overridden to be visible in specific models\n      this._modelSubCategoryOverrides.forEach((_modelIdLo: number, _modelIdHi: number, subcats: Id64.Uint32Set) => {\n        subcats.forEach((idLo: number, idHi: number) => {\n          if (!this.isSubCategoryVisible(idLo, idHi)) {\n            // Overridden to be visible in one or more models - will need the appearance overrides\n            addOverride(idLo, idHi);\n          }\n        });\n      });\n    }\n\n    /** Construct a new Overrides. The result is an empty set of overrides if no view or viewport is supplied.\n     * @param view If supplied, the overrides will be initialized based on the current state of the view or viewport.\n     */\n    public constructor(view?: ViewState | Viewport) {\n      if (undefined !== view) {\n        if (view instanceof Viewport)\n          this.initFromViewport(view);\n        else\n          this.initFromView(view);\n      }\n    }\n\n    /** Returns true if geometry belonging to the specified subcategory will be drawn. */\n    public isSubCategoryIdVisible(id: Id64String): boolean { return this.isSubCategoryVisible(Id64.getLowerUint32(id), Id64.getUpperUint32(id)); }\n    /** Returns the overrides applied to geometry belonging to the specified model, if any such are defined. */\n    public getModelOverridesById(id: Id64String): Appearance | undefined { return this.getModelOverrides(Id64.getLowerUint32(id), Id64.getUpperUint32(id)); }\n    /** Returns the overrides applied to geometry belonging to the specified element, if any such are defined. */\n    public getElementOverridesById(id: Id64String): Appearance | undefined { return this.getElementOverrides(Id64.getLowerUint32(id), Id64.getUpperUint32(id), 0); }\n    /** Returns the overrides applied to geometry belonging to the specified subcategory, if any such are defined. */\n    public getSubCategoryOverridesById(id: Id64String): Appearance | undefined { return this.getSubCategoryOverrides(Id64.getLowerUint32(id), Id64.getUpperUint32(id)); }\n\n    /** Returns true if the specified Feature will be drawn. */\n    public isFeatureVisible(feature: Feature): boolean {\n      const { elementId, subCategoryId, geometryClass } = feature;\n      const isValidElemId = !Id64.isInvalid(elementId);\n      const elemIdParts = isValidElemId ? Id64.getUint32Pair(elementId) : undefined;\n\n      if (undefined !== elemIdParts && this.isNeverDrawn(elemIdParts.lower, elemIdParts.upper, 0))\n        return false;\n\n      const alwaysDrawn = undefined !== elemIdParts && this.isAlwaysDrawn(elemIdParts.lower, elemIdParts.upper);\n      if (alwaysDrawn || this.isAlwaysDrawnExclusive)\n        return alwaysDrawn;\n\n      // NB: This ignores per-model subcategory visibility overrides, because caller did not specify a model.\n      if (!this.isSubCategoryIdVisible(subCategoryId))\n        return false;\n\n      return this.isClassVisible(geometryClass);\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { IModelConnection } from \"../IModelConnection\";\nimport { Id64String } from \"@bentley/bentleyjs-core\";\nimport {\n  Transform,\n  Point3d,\n  Point2d,\n  Range3d,\n  Arc3d,\n  Polyface,\n  Path,\n  Loop,\n} from \"@bentley/geometry-core\";\nimport {\n  ColorDef,\n  Frustum,\n  GraphicParams,\n  LinePixels,\n  Npc,\n} from \"@bentley/imodeljs-common\";\nimport { Viewport } from \"../Viewport\";\nimport { RenderGraphic } from \"./System\";\n\n/**\n * Describes the type of a [[GraphicBuilder]], which defines the coordinate system in which the builder's geometry is defined and\n * controls the behavior of the [[RenderGraphic]] produced by the builder.\n * @note For those types for which depth-testing is disabled, the order in which the individual geometric primitives are drawn determines which geometry draws on top of other geometry.\n *  - Within a [[GraphicList]], each [[RenderGraphic]] is rendered in the order in which it appears in the list; and\n *  - Within a single [[RenderGraphic]], each geometric primitive is rendered in the ordered in which it was added to the GraphicBuilder.\n * @public\n */\nexport enum GraphicType {\n  /**\n   * Renders behind all other graphics. For example, the border of a [[SheetViewState]] is of this type.\n   * Coordinates: [[CoordSystem.View]].\n   * [[RenderMode]]: [[RenderMode.SmoothShade]].\n   * Lighting: none.\n   * Depth-testing: disabled.\n   * @see [[Decorations.viewBackground]]\n   */\n  ViewBackground,\n  /** Used for the scene itself, dynamics, and 'normal' decorations. */\n  /**\n   * Renders as if it were part of the scene. All of the [[ViewFlags]] applied to the view's normal geometry also applies to these types of decorations.\n   * Coordinates: [[CoordSystem.World]].\n   * Lighting and [[RenderMode]]: from view.\n   * Depth-testing: enabled.\n   * @see [[Decorations.normal]].\n   */\n  Scene,\n  /** Renders within the scene. Coordinates: world. RenderMode: smooth. Lighting: default. Z-testing: enabled */\n  /** Renders within the scene, but ignores the view's [[ViewFlags]].\n   * Coordinates: [[CoordSystem.World]].\n   * Lighting: default.\n   * [[RenderMode]]: [[RenderMode.SmoothShade]].\n   * Depth-testing: enabled.\n   * @see [[Decorations.world]].\n   */\n  WorldDecoration,\n  /**\n   * Renders as an overlay on top of the scene. These decorations differ from [[GraphicType.WorldDecoration]] only in that depth-testing is disabled.\n   * For example, the ACS triad and [[WindowAreaTool]] decorations are of this type.\n   * Coordinates: [[CoordSystem.World]].\n   * [[RenderMode]]: [[RenderMode.SmoothShade]]\n   * Lighting: default.\n   * Depth-testing: disabled.\n   * Renders atop the scene. Coordinates: world. RenderMode: smooth. Lighting: none. Z-testing: disabled\n   * @note Overlay decorations typically employ some degree of transparency to ensure that they do not fully obscure the scene.\n   * @see [[Decorations.worldOverlay]]\n   */\n  WorldOverlay,\n  /**\n   * Renders as an overlay on top of the scene. These decorations differ from [[GraphicType.WorldOverlay]] only in that their geometry is defined in view coordinates rather than world.\n   * Coordinates: [[CoordSystem.View]].\n   * [[RenderMode]]: [[RenderMode.SmoothShade]]\n   * Lighting: default.\n   * Depth-testing: disabled.\n   * @note For more flexibility in defining view overlay decorations, consider using a [[CanvasDecorationList]].\n   * @see [[Decorations.viewOverlay]]\n   */\n  ViewOverlay,\n}\n\n/** Provides methods for constructing a [[RenderGraphic]] from geometric primitives.\n * GraphicBuilder is primarily used for creating [[Decorations]] to be displayed inside a [[Viewport]].\n *\n * The typical process for constructing a [[RenderGraphic]] proceeds as follows:\n *  1. Use [[RenderContext.createGraphicBuilder]] to obtain a builder.\n *  2. Set up the symbology using [[GraphicBuilder.activateGraphicParams]].\n *  3. Add one or more geometric primitives using methods like [[GraphicBuilder.addShape]] and [[GraphicBuilder.addLineString]], possibly setting new symbology in between.\n *  4. Use [[GraphicBuilder.finish]] to produce the finished [[RenderGraphic]].\n *\n * @note Most of the methods which add geometry to the builder take ownership of their inputs rather than cloning them.\n * So, for example, if you pass an array of points to addLineString(), you should not subsequently modify that array.\n *\n * @see [[Decorator]].\n * @see [[RenderContext.createGraphicBuilder]].\n * @see [[RenderSystem.createGraphicBuilder]].\n * @see [[DecorateContext]].\n * @see [[DynamicsContext]].\n * @public\n */\nexport abstract class GraphicBuilder {\n  private readonly _placement: Transform;\n  /** The type of this builder. */\n  public readonly type: GraphicType;\n  /** The viewport in which the resultant [[RenderGraphic]] will be drawn. */\n  public readonly viewport: Viewport;\n  /* Some [[Decorator]]s produce \"pickable\" decorations with which the user can interact using tools like [[SelectionTool]].\n   * To enable this behavior, the [[GraphicBuilder]] must be constructed with a unique identifier.\n   * @see [[IModelConnection.transientIds]].\n   */\n  public pickId?: string;\n\n  /** The local coordinate system transform applied to this builder's geometry. */\n  public get placement(): Transform { return this._placement; }\n  public set placement(tf: Transform) { this._placement.setFrom(tf); }\n\n  /** @internal */\n  public get isViewCoordinates(): boolean { return this.type === GraphicType.ViewBackground || this.type === GraphicType.ViewOverlay; }\n  /** @internal */\n  public get isWorldCoordinates(): boolean { return !this.isViewCoordinates; }\n  /** @internal */\n  public get isSceneGraphic(): boolean { return this.type === GraphicType.Scene; }\n  /** @internal */\n  public get isViewBackground(): boolean { return this.type === GraphicType.ViewBackground; }\n  /** @internal */\n  public get isOverlay(): boolean { return this.type === GraphicType.ViewOverlay || this.type === GraphicType.WorldOverlay; }\n  /** @internal */\n  public get iModel(): IModelConnection { return this.viewport.iModel; }\n\n  /** @internal */\n  protected constructor(placement: Transform = Transform.identity, type: GraphicType, viewport: Viewport, pickId?: Id64String) {\n    this._placement = placement;\n    this.type = type;\n    this.viewport = viewport;\n    if (undefined !== pickId)\n      this.pickId = pickId.toString();\n  }\n\n  /**\n   * Processes the accumulated symbology and geometry to produce a renderable graphic.\n   * This function can only be called once; after the [[RenderGraphic]] has been extracted the [[GraphicBuilder]] should no longer be used.\n   */\n  public abstract finish(): RenderGraphic;\n\n  /** Sets the current active symbology for this builder. Any new geometry subsequently added to the builder will be drawn using the specified symbology.\n   * @param graphicParams The symbology to apply to subsequent geometry.\n   * @see [[GraphicBuilder.setSymbology]] for a convenient way to set common symbology options.\n   */\n  public abstract activateGraphicParams(graphicParams: GraphicParams): void;\n\n  /**\n   * Appends a 3d line string to the builder.\n   * @param points Array of vertices in the line string.\n   */\n  public abstract addLineString(points: Point3d[]): void;\n\n  /**\n   * Appends a 2d line string to the builder.\n   * @param points Array of vertices in the line string.\n   * @param zDepth Z value in local coordinates to use for each point.\n   */\n  public abstract addLineString2d(points: Point2d[], zDepth: number): void;\n\n  /**\n   * Appends a 3d point string to the builder. The points are drawn disconnected, with a diameter in pixels defined by the builder's active [[GraphicParams.rasterWidth]].\n   * @param points Array of vertices in the point string.\n   */\n  public abstract addPointString(points: Point3d[]): void;\n\n  /**\n   * Appends a 2d point string to the builder. The points are drawn disconnected, with a diameter in pixels defined by the builder's active [[GraphicParams.rasterWidth]].\n   * @param points Array of vertices in the point string.\n   * @param zDepth Z value in local coordinates to use for each point.\n   */\n  public abstract addPointString2d(points: Point2d[], zDepth: number): void;\n\n  /**\n   * Appends a closed 3d planar region to the builder.\n   * @param points Array of vertices of the shape.\n   */\n  public abstract addShape(points: Point3d[]): void;\n\n  /**\n   * Appends a closed 2d region to the builder.\n   * @param points Array of vertices of the shape.\n   * @param zDepth Z value in local coordinates to use for each point.\n   */\n  public abstract addShape2d(points: Point2d[], zDepth: number): void;\n\n  /**\n   * Appends a 3d open arc or closed ellipse to the builder.\n   * @param arc Description of the arc or ellipse.\n   * @param isEllipse If true, and if the arc defines a full sweep, then draw as a closed ellipse instead of an arc.\n   * @param filled If true, and isEllipse is also true, then draw ellipse filled.\n   */\n  public abstract addArc(arc: Arc3d, isEllipse: boolean, filled: boolean): void;\n\n  /**\n   * Appends a 2d open arc or closed ellipse to the builder.\n   * @param arc Description of the arc or ellipse.\n   * @param isEllipse If true, and if the arc defines a full sweep, then draw as a closed ellipse instead of an arc.\n   * @param filled If true, and isEllipse is also true, then draw ellipse filled.\n   * @param zDepth Z value in local coordinates to use for each point in the arc or ellipse.\n   */\n  public abstract addArc2d(ellipse: Arc3d, isEllipse: boolean, filled: boolean, zDepth: number): void;\n\n  /** Append a 3d open path to the builder. */\n  public abstract addPath(path: Path): void;\n\n  /** Append a 3d planar region to the builder. */\n  public abstract addLoop(loop: Loop): void;\n\n  /** Append a mesh to the builder.\n   * @param meshData Describes the mesh\n   * @param filled If the mesh describes a planar region, indicates whether its interior area should be drawn with fill in [[RenderMode.Wireframe]].\n   */\n  public abstract addPolyface(meshData: Polyface, filled: boolean): void;\n\n  /** Add Range3d edges. Useful for debugging.\n   * @public\n   */\n  public addRangeBox(range: Range3d) {\n    const frustum = Frustum.fromRange(range);\n    const p = frustum.points;\n\n    this.addLineString([\n      p[Npc.LeftBottomFront],\n      p[Npc.LeftTopFront],\n      p[Npc.RightTopFront],\n      p[Npc.RightBottomFront],\n      p[Npc.RightBottomRear],\n      p[Npc.RightTopRear],\n      p[Npc.LeftTopRear],\n      p[Npc.LeftBottomRear],\n      p[Npc.LeftBottomFront].clone(),\n      p[Npc.RightBottomFront].clone(),\n    ]);\n\n    this.addLineString([p[Npc.LeftTopFront].clone(), p[Npc.LeftTopRear].clone()]);\n    this.addLineString([p[Npc.RightTopFront].clone(), p[Npc.RightTopRear].clone()]);\n    this.addLineString([p[Npc.LeftBottomRear].clone(), p[Npc.RightBottomRear].clone()]);\n  }\n\n  /** Sets the current active symbology for this builder. Any new geometry subsequently added will be drawn using the specified symbology.\n   * @param lineColor The color in which to draw lines.\n   * @param fillColor The color in which to draw filled regions.\n   * @param lineWidth The width in pixels to draw lines. The renderer will clamp this value to an integer in the range [1, 32].\n   * @param linePixels The pixel pattern in which to draw lines.\n   * @see [[GraphicBuilder.activateGraphicParams]] for additional symbology options.\n   */\n  public setSymbology(lineColor: ColorDef, fillColor: ColorDef, lineWidth: number, linePixels = LinePixels.Solid) {\n    this.activateGraphicParams(GraphicParams.fromSymbology(lineColor, fillColor, lineWidth, linePixels));\n  }\n\n  /** Set blanking fill symbology for decoration.\n   * @internal\n   */\n  public setBlankingFill(fillColor: ColorDef) { this.activateGraphicParams(GraphicParams.fromBlankingFill(fillColor)); }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n\r\nimport { Viewport, ViewRect } from \"../Viewport\";\r\nimport {\r\n  Decorations,\r\n  GraphicBranch,\r\n  GraphicList,\r\n  PackedFeatureTable,\r\n  Pixel,\r\n  RenderClipVolume,\r\n  RenderGraphic,\r\n  RenderMemory,\r\n  RenderPlan,\r\n  RenderSystem,\r\n  RenderTarget,\r\n} from \"./System\";\r\nimport { GraphicType } from \"./GraphicBuilder\";\r\nimport { IModelApp, IModelAppOptions } from \"../IModelApp\";\r\nimport { IModelConnection } from \"../IModelConnection\";\r\nimport { PrimitiveBuilder } from \"./primitives/geometry/GeometryListBuilder\";\r\nimport { MeshParams, PolylineParams, PointStringParams } from \"./primitives/VertexTable\";\r\nimport { PointCloudArgs } from \"./primitives/PointCloudPrimitive\";\r\nimport { ElementAlignedBox3d } from \"@bentley/imodeljs-common\";\r\nimport { Transform } from \"@bentley/geometry-core\";\r\nimport { Id64String, dispose } from \"@bentley/bentleyjs-core\";\r\n\r\n/** Contains extensible mock implementations of the various components of a RenderSystem, intended for use in tests.\r\n * Use these for tests instead of the default RenderSystem wherever possible because:\r\n *  (1) Electron has a bug on Windows in which it fails to obtain a WebGLRenderingContext when running inside a VM (e.g., during CI job); and\r\n *  (2) To decouple the logic which uses aspects of the RenderSystem from the full implementation.\r\n * Any and all of these types can be extended for the purposes of specific tests.\r\n * To use this:\r\n *  (1) If overriding anything in the implementation supplied herein, pass a SystemFactory function to MockRender.App.systemFactory.\r\n *  (2) Call MockRender.App.startup() instead of IModelApp.startup() before tests begin.\r\n *  (3) Likewise call MockRender.App.shutdown() when finished. This resets the SystemFactory to its default.\r\n * @internal\r\n */\r\nexport namespace MockRender {\r\n  /** @internal */\r\n  export abstract class Target extends RenderTarget {\r\n    protected constructor(private readonly _system: System) { super(); }\r\n\r\n    public get renderSystem(): RenderSystem { return this._system; }\r\n    public get cameraFrustumNearScaleLimit() { return 0; }\r\n    public get wantInvertBlackBackground() { return false; }\r\n    public get animationFraction() { return 0; }\r\n    public set animationFraction(_fraction: number) { }\r\n    public changeScene(_scene: GraphicList) { }\r\n    public changeBackgroundMap(_backgroundMap: GraphicList) { }\r\n    public changeDynamics(_dynamics?: GraphicList) { }\r\n    public changeDecorations(_decs: Decorations) { }\r\n    public changeRenderPlan(_plan: RenderPlan) { }\r\n    public drawFrame(_sceneTime?: number) { }\r\n    public updateViewRect() { return false; }\r\n    public readPixels(_rect: ViewRect, _selector: Pixel.Selector, receiver: Pixel.Receiver, _excludeNonLocatable: boolean) { receiver(undefined); }\r\n  }\r\n\r\n  /** @internal */\r\n  export class OnScreenTarget extends Target {\r\n    public constructor(system: System, private readonly _canvas: HTMLCanvasElement) { super(system); }\r\n\r\n    public get viewRect() { return new ViewRect(0, 0, this._canvas.clientWidth, this._canvas.clientHeight); }\r\n    public setViewRect(_rect: ViewRect, _temp: boolean) { }\r\n  }\r\n\r\n  /** @internal */\r\n  export class OffScreenTarget extends Target {\r\n    public constructor(system: System, private readonly _viewRect: ViewRect) { super(system); }\r\n\r\n    public get viewRect() { return this._viewRect; }\r\n    public setViewRect(rect: ViewRect, _temp: boolean) { this._viewRect.setFrom(rect); }\r\n  }\r\n\r\n  /** @internal */\r\n  export class Builder extends PrimitiveBuilder {\r\n    public constructor(system: System, placement: Transform = Transform.identity, type: GraphicType, viewport: Viewport, pickId?: Id64String) {\r\n      super(system, type, viewport, placement, pickId);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  export class Graphic extends RenderGraphic {\r\n    public constructor() { super(); }\r\n\r\n    public dispose() { }\r\n    public collectStatistics(_stats: RenderMemory.Statistics): void { }\r\n  }\r\n\r\n  /** @internal */\r\n  export class List extends Graphic {\r\n    public constructor(public readonly graphics: RenderGraphic[]) { super(); }\r\n\r\n    public dispose() {\r\n      for (const graphic of this.graphics)\r\n        dispose(graphic);\r\n\r\n      this.graphics.length = 0;\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  export class Branch extends Graphic {\r\n    public constructor(public readonly branch: GraphicBranch, public readonly transform: Transform, public readonly clips?: RenderClipVolume) { super(); }\r\n\r\n    public dispose() { this.branch.dispose(); }\r\n  }\r\n\r\n  /** @internal */\r\n  export class Batch extends Graphic {\r\n    public constructor(public readonly graphic: RenderGraphic, public readonly featureTable: PackedFeatureTable, public readonly range: ElementAlignedBox3d) { super(); }\r\n\r\n    public dispose() {\r\n      dispose(this.graphic);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  export class System extends RenderSystem {\r\n    public get isValid() { return true; }\r\n    public dispose(): void { }\r\n    public get maxTextureSize() { return 4096; }\r\n\r\n    public constructor() { super(); }\r\n\r\n    public createTarget(canvas: HTMLCanvasElement) { return new OnScreenTarget(this, canvas); }\r\n    public createOffscreenTarget(rect: ViewRect): RenderTarget { return new OffScreenTarget(this, rect); }\r\n\r\n    public createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String) { return new Builder(this, placement, type, viewport, pickableId); }\r\n    public createGraphicList(primitives: RenderGraphic[]) { return new List(primitives); }\r\n    public createGraphicBranch(branch: GraphicBranch, transform: Transform, clips?: RenderClipVolume) { return new Branch(branch, transform, clips); }\r\n    public createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d) { return new Batch(graphic, features, range); }\r\n\r\n    public createMesh(_params: MeshParams) { return new Graphic(); }\r\n    public createPolyline(_params: PolylineParams) { return new Graphic(); }\r\n    public createPointString(_params: PointStringParams) { return new Graphic(); }\r\n    public createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection) { return new Graphic(); }\r\n  }\r\n\r\n  /** @internal */\r\n  export type SystemFactory = () => RenderSystem;\r\n\r\n  /** An implementation of IModelApp which uses a MockRender.System by default.\r\n   * @internal\r\n   */\r\n  export class App {\r\n    public static systemFactory: SystemFactory = () => App.createDefaultRenderSystem();\r\n\r\n    public static startup(opts?: IModelAppOptions) {\r\n      opts = opts ? opts : {};\r\n      opts.renderSys = this.systemFactory();\r\n      IModelApp.startup(opts);\r\n    }\r\n    public static shutdown(): void {\r\n      this.systemFactory = () => App.createDefaultRenderSystem();\r\n      IModelApp.shutdown();\r\n    }\r\n\r\n    protected static createDefaultRenderSystem() { return new System(); }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { assert, base64StringToUint8Array, dispose, disposeArray, Id64, Id64String, IDisposable } from \"@bentley/bentleyjs-core\";\nimport { ClipVector, IndexedPolyface, Plane3dByOriginAndUnitNormal, Point2d, Point3d, Range3d, Transform, XAndY, Vector3d } from \"@bentley/geometry-core\";\nimport {\n  AntiAliasPref, BatchType, ColorDef, ElementAlignedBox3d, Feature, FeatureTable, Frustum, Gradient,\n  HiddenLine, Hilite, ImageBuffer, ImageSource, ImageSourceFormat, isValidImageSourceFormat, QParams3d, SolarShadows,\n  QPoint3dList, RenderMaterial, RenderTexture, SceneLights, ViewFlag, ViewFlags, AnalysisStyle, GeometryClass, AmbientOcclusion, SpatialClassificationProps,\n} from \"@bentley/imodeljs-common\";\nimport { SkyBox } from \"../DisplayStyleState\";\nimport { imageElementFromImageSource } from \"../ImageUtil\";\nimport { IModelApp } from \"../IModelApp\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { HiliteSet } from \"../SelectionSet\";\nimport { BeButtonEvent, BeWheelEvent } from \"../tools/Tool\";\nimport { ViewFrustum, Viewport, ViewRect } from \"../Viewport\";\nimport { FeatureSymbology } from \"./FeatureSymbology\";\nimport { GraphicBuilder, GraphicType } from \"./GraphicBuilder\";\nimport { MeshArgs, PolylineArgs } from \"./primitives/mesh/MeshPrimitives\";\nimport { PointCloudArgs } from \"./primitives/PointCloudPrimitive\";\nimport { MeshParams, PointStringParams, PolylineParams } from \"./primitives/VertexTable\";\nimport { TileTreeModelState } from \"../ModelState\";\nimport { TileTree } from \"../tile/TileTree\";\nimport { SceneContext } from \"../ViewContext\";\nimport { ModelSelectorState } from \"../ModelSelectorState\";\nimport { CategorySelectorState } from \"../CategorySelectorState\";\n\n// tslint:disable:no-const-enum\n\n/** Contains metadata about memory consumed by the render system or aspect thereof.\n * @internal\n */\nexport namespace RenderMemory {\n  /** Describes memory consumed by a particular type of resource.\n   * @internal\n   */\n  export class Consumers {\n    public totalBytes = 0; // total number of bytes consumed by all consumers\n    public maxBytes = 0; // largest number of bytes consumed by a single consumer\n    public count = 0; // total number of consumers of this type\n\n    public addConsumer(numBytes: number): void {\n      this.totalBytes += numBytes;\n      this.maxBytes = Math.max(this.maxBytes, numBytes);\n      ++this.count;\n    }\n\n    public clear(): void {\n      this.totalBytes = this.maxBytes = this.count = 0;\n    }\n  }\n\n  /** @internal */\n  export const enum BufferType {\n    Surfaces = 0,\n    VisibleEdges,\n    SilhouetteEdges,\n    PolylineEdges,\n    Polylines,\n    PointStrings,\n    PointClouds,\n    Instances,\n\n    COUNT,\n  }\n\n  /** Describes memory consumed by GPU-allocated buffers.\n   * @internal\n   */\n  export class Buffers extends Consumers {\n    public readonly consumers: Consumers[];\n\n    public constructor() {\n      super();\n      this.consumers = [];\n      for (let i = 0; i < BufferType.COUNT; i++)\n        this.consumers[i] = new Consumers();\n    }\n\n    public get surfaces() { return this.consumers[BufferType.Surfaces]; }\n    public get visibleEdges() { return this.consumers[BufferType.VisibleEdges]; }\n    public get silhouetteEdges() { return this.consumers[BufferType.SilhouetteEdges]; }\n    public get polylineEdges() { return this.consumers[BufferType.PolylineEdges]; }\n    public get polylines() { return this.consumers[BufferType.Polylines]; }\n    public get pointStrings() { return this.consumers[BufferType.PointStrings]; }\n    public get pointClouds() { return this.consumers[BufferType.PointClouds]; }\n    public get instances() { return this.consumers[BufferType.Instances]; }\n\n    public clear(): void {\n      for (const consumer of this.consumers)\n        consumer.clear();\n\n      super.clear();\n    }\n\n    public addBuffer(type: BufferType, numBytes: number): void {\n      this.addConsumer(numBytes);\n      this.consumers[type].addConsumer(numBytes);\n    }\n  }\n\n  /** @internal */\n  export const enum ConsumerType {\n    Textures = 0,\n    VertexTables,\n    FeatureTables,\n    FeatureOverrides,\n    ClipVolumes,\n    PlanarClassifiers,\n    ShadowMaps,\n    COUNT,\n  }\n\n  /** @internal */\n  export class Statistics {\n    private _totalBytes = 0;\n    public readonly consumers: Consumers[];\n    public readonly buffers = new Buffers();\n\n    public constructor() {\n      this.consumers = [];\n      for (let i = 0; i < ConsumerType.COUNT; i++)\n        this.consumers[i] = new Consumers();\n    }\n\n    public get totalBytes(): number { return this._totalBytes; }\n    public get textures() { return this.consumers[ConsumerType.Textures]; }\n    public get vertexTables() { return this.consumers[ConsumerType.VertexTables]; }\n    public get featureTables() { return this.consumers[ConsumerType.FeatureTables]; }\n    public get featureOverrides() { return this.consumers[ConsumerType.FeatureOverrides]; }\n    public get clipVolumes() { return this.consumers[ConsumerType.ClipVolumes]; }\n    public get planarClassifiers() { return this.consumers[ConsumerType.PlanarClassifiers]; }\n    public get shadowMaps() { return this.consumers[ConsumerType.ShadowMaps]; }\n\n    public addBuffer(type: BufferType, numBytes: number): void {\n      this._totalBytes += numBytes;\n      this.buffers.addBuffer(type, numBytes);\n    }\n\n    public addConsumer(type: ConsumerType, numBytes: number): void {\n      this._totalBytes += numBytes;\n      this.consumers[type].addConsumer(numBytes);\n    }\n\n    public clear(): void {\n      this._totalBytes = 0;\n      this.buffers.clear();\n      for (const consumer of this.consumers)\n        consumer.clear();\n    }\n\n    public addTexture(numBytes: number) { this.addConsumer(ConsumerType.Textures, numBytes); }\n    public addVertexTable(numBytes: number) { this.addConsumer(ConsumerType.VertexTables, numBytes); }\n    public addFeatureTable(numBytes: number) { this.addConsumer(ConsumerType.FeatureTables, numBytes); }\n    public addFeatureOverrides(numBytes: number) { this.addConsumer(ConsumerType.FeatureOverrides, numBytes); }\n    public addClipVolume(numBytes: number) { this.addConsumer(ConsumerType.ClipVolumes, numBytes); }\n    public addPlanarClassifier(numBytes: number) { this.addConsumer(ConsumerType.PlanarClassifiers, numBytes); }\n    public addShadowMap(numBytes: number) { this.addConsumer(ConsumerType.ShadowMaps, numBytes); }\n\n    public addSurface(numBytes: number) { this.addBuffer(BufferType.Surfaces, numBytes); }\n    public addVisibleEdges(numBytes: number) { this.addBuffer(BufferType.VisibleEdges, numBytes); }\n    public addSilhouetteEdges(numBytes: number) { this.addBuffer(BufferType.SilhouetteEdges, numBytes); }\n    public addPolylineEdges(numBytes: number) { this.addBuffer(BufferType.PolylineEdges, numBytes); }\n    public addPolyline(numBytes: number) { this.addBuffer(BufferType.Polylines, numBytes); }\n    public addPointString(numBytes: number) { this.addBuffer(BufferType.PointStrings, numBytes); }\n    public addPointCloud(numBytes: number) { this.addBuffer(BufferType.PointClouds, numBytes); }\n    public addInstances(numBytes: number) { this.addBuffer(BufferType.Instances, numBytes); }\n  }\n\n  /** @internal */\n  export interface Consumer {\n    collectStatistics(stats: Statistics): void;\n  }\n}\n\n/** A RenderPlan holds a Frustum and the render settings for displaying a RenderScene into a RenderTarget.\n * @internal\n */\nexport class RenderPlan {\n  public readonly is3d: boolean;\n  public readonly viewFlags: ViewFlags;\n  public readonly viewFrustum: ViewFrustum;\n  public readonly expandedFrustum: ViewFrustum | undefined;\n  public readonly bgColor: ColorDef;\n  public readonly monoColor: ColorDef;\n  public readonly hiliteSettings: Hilite.Settings;\n  public readonly aaLines: AntiAliasPref;\n  public readonly aaText: AntiAliasPref;\n  public readonly activeVolume?: ClipVector;\n  public readonly hline?: HiddenLine.Settings;\n  public readonly lights?: SceneLights;\n  public readonly analysisStyle?: AnalysisStyle;\n  public readonly ao?: AmbientOcclusion.Settings;\n  public readonly isFadeOutActive: boolean;\n  public analysisTexture?: RenderTexture;\n  public classificationTextures?: Map<Id64String, RenderTexture>;\n  private _curFrustum: ViewFrustum;\n\n  public get frustum(): Frustum { return this._curFrustum.getFrustum(); }\n  public get fraction(): number { return this._curFrustum.frustFraction; }\n\n  public selectExpandedFrustum() { if (undefined !== this.expandedFrustum) this._curFrustum = this.expandedFrustum; }\n  public selectViewFrustum() { this._curFrustum = this.viewFrustum; }\n\n  private constructor(is3d: boolean, viewFlags: ViewFlags, bgColor: ColorDef, monoColor: ColorDef, hiliteSettings: Hilite.Settings, aaLines: AntiAliasPref, aaText: AntiAliasPref, viewFrustum: ViewFrustum, isFadeOutActive: boolean, expandedFrustum: ViewFrustum | undefined, activeVolume?: ClipVector, hline?: HiddenLine.Settings, lights?: SceneLights, analysisStyle?: AnalysisStyle, ao?: AmbientOcclusion.Settings) {\n    this.is3d = is3d;\n    this.viewFlags = viewFlags;\n    this.bgColor = bgColor;\n    this.monoColor = monoColor;\n    this.hiliteSettings = hiliteSettings;\n    this.aaLines = aaLines;\n    this.aaText = aaText;\n    this.activeVolume = activeVolume;\n    this.hline = hline;\n    this.lights = lights;\n    this._curFrustum = this.viewFrustum = viewFrustum;\n    this.expandedFrustum = expandedFrustum;\n    this.analysisStyle = analysisStyle;\n    this.ao = ao;\n    this.isFadeOutActive = isFadeOutActive;\n  }\n\n  public static createFromViewport(vp: Viewport): RenderPlan {\n    const view = vp.view;\n    const style = view.displayStyle;\n\n    const hline = style.is3d() ? style.settings.hiddenLineSettings : undefined;\n    const ao = style.is3d() ? style.settings.ambientOcclusionSettings : undefined;\n    const lights = undefined; // view.is3d() ? view.getLights() : undefined\n    const clipVec = view.getViewClip();\n    const expandedFrustum = (undefined === vp.backgroundMapPlane) ? undefined : ViewFrustum.createFromViewportAndPlane(vp, vp.backgroundMapPlane as Plane3dByOriginAndUnitNormal);\n    const rp = new RenderPlan(view.is3d(), style.viewFlags, view.backgroundColor, style.monochromeColor, vp.hilite, vp.wantAntiAliasLines, vp.wantAntiAliasText, vp.viewFrustum, vp.isFadeOutActive, expandedFrustum!, clipVec, hline, lights, style.analysisStyle, ao);\n    if (rp.analysisStyle !== undefined && rp.analysisStyle.scalarThematicSettings !== undefined)\n      rp.analysisTexture = vp.target.renderSystem.getGradientTexture(Gradient.Symb.createThematic(rp.analysisStyle.scalarThematicSettings), vp.iModel);\n\n    return rp;\n  }\n}\n\n/** Abstract representation of an object which can be rendered by a [[RenderSystem]].\n * Two broad classes of graphics exist:\n *  - \"Scene\" graphics generated on the back-end to represent the contents of the models displayed in a [[Viewport]]; and\n *  - [[Decorations]] created on the front-end to be rendered along with the scene.\n * The latter are produced using a [[GraphicBuilder]].\n * @public\n */\nexport abstract class RenderGraphic implements IDisposable /* , RenderMemory.Consumer */ {\n  public abstract dispose(): void;\n\n  /** @internal */\n  public abstract collectStatistics(stats: RenderMemory.Statistics): void;\n}\n\n/** Describes the type of a RenderClipVolume.\n * @beta\n */\nexport const enum ClippingType {\n  /** No clip volume. */\n  None,\n  /** A 2d mask which excludes geometry obscured by the mask. */\n  Mask,\n  /** A 3d set of convex clipping planes which excludes geometry outside of the planes. */\n  Planes,\n}\n\n/** An opaque representation of a clip volume applied to geometry within a [[Viewport]].\n * A RenderClipVolume is created from a [[ClipVector]] and takes ownership of that ClipVector, expecting that it will not be modified while the RenderClipVolume still references it.\n * @see [System.createClipVolume]\n * @beta\n */\nexport abstract class RenderClipVolume implements IDisposable /* , RenderMemory.Consumer */ {\n  /** The ClipVector from which this volume was created. It must not be modified. */\n  public readonly clipVector: ClipVector;\n\n  protected constructor(clipVector: ClipVector) {\n    this.clipVector = clipVector;\n  }\n\n  /** Returns the type of this clipping volume. */\n  public abstract get type(): ClippingType;\n\n  /** Disposes of any WebGL resources owned by this volume. Must be invoked when finished with the clip volume object to prevent memory leaks. */\n  public abstract dispose(): void;\n\n  /** @internal */\n  public abstract collectStatistics(stats: RenderMemory.Statistics): void;\n}\n/** An opaque representation of a shadow map.\n * @internal\n */\nexport abstract class RenderSolarShadowMap implements IDisposable {\n  public abstract dispose(): void;\n\n  /** @internal */\n  public abstract collectStatistics(stats: RenderMemory.Statistics): void;\n\n  /** @internal */\n  public abstract collectGraphics(sceneContext: SceneContext): void;\n}\n\n/** An opaque representation of a planar classifier applied to geometry within a [[Viewport]].\n * @beta\n */\nexport abstract class RenderPlanarClassifier implements IDisposable {\n  public abstract dispose(): void;\n}\n\n/** Describes the type of a RenderClassifierModel\n * @beta\n */\nexport const enum ClassifierType {\n  Volume,\n  Planar,\n}\n\n/** @beta */\nexport type PlanarClassifierMap = Map<Id64String, RenderPlanarClassifier>;\n\n/** Models that may be used as classifiers.  Detecting their type requires a range query.\n * @beta\n */\nexport class RenderClassifierModel {\n  constructor(public readonly type: ClassifierType) { }\n}\n\n/** An array of [[RenderGraphic]]s.\n * @public\n */\nexport type GraphicList = RenderGraphic[];\n\n/** A [Decoration]($docs/learning/frontend/ViewDecorations#canvas-decorations) that is drawn onto the\n * [2d canvas](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D) on top of a ScreenViewport.\n * CanvasDecorations may be pickable by implementing [[pick]].\n * @public\n */\nexport interface CanvasDecoration {\n  /**\n   * Required method to draw this decoration into the supplied [CanvasRenderingContext2D](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D). This method is called every time a frame is rendered.\n   * @param ctx The CanvasRenderingContext2D for the [[ScreenViewport]] being rendered.\n   * @note Before this this function is called, the state of the CanvasRenderingContext2D is [saved](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/save),\n   * and it is [restored](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/restore) when this method returns. Therefore,\n   * it is *not* necessary for implementers to save/restore themselves.\n   */\n  drawDecoration(ctx: CanvasRenderingContext2D): void;\n  /**\n   * Optional view coordinates position of this overlay decoration. If present, [ctx.translate](https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/translate) is called\n   * with this point before [[drawDecoration]] is called.\n   */\n  position?: XAndY;\n  /** Optional method to provide feedback when mouse events occur on this decoration.\n   * @param pt The position of the mouse in the ScreenViewport\n   * @return true if the mouse is inside this decoration.\n   * @note If this method is not present, no mouse events are directed to this decoration.\n   */\n  pick?(pt: XAndY): boolean;\n  /** Optional method to be called whenever this decorator is picked and the mouse first enters this decoration. */\n  onMouseEnter?(ev: BeButtonEvent): void;\n  /** Optional method to be called whenever when the mouse leaves this decoration. */\n  onMouseLeave?(): void;\n  /** Optional method to be called whenever when the mouse moves inside this decoration. */\n  onMouseMove?(ev: BeButtonEvent): void;\n  /**\n   * Optional method to be called whenever this decorator is picked and a mouse button is pressed or released inside this decoration.\n   * @return true if the event was handled by this decoration and should *not* be forwarded to the active tool.\n   * @note This method is called for both mouse up and down events. If it returns `true` for a down event, it should also return `true` for the\n   * corresponding up event.\n   */\n  onMouseButton?(ev: BeButtonEvent): boolean;\n  /**\n   * Optional method to be called when the mouse wheel is rolled with the pointer over this decoration.\n   * @return true to indicate that the event has been handled and should not be propagated to default handler\n   */\n  onWheel?(ev: BeWheelEvent): boolean;\n  /** Cursor to use when mouse is inside this decoration. Default is \"pointer\". */\n  decorationCursor?: string;\n}\n\n/** An array of [[CanvasDecoration]]s.\n * @public\n */\nexport type CanvasDecorationList = CanvasDecoration[];\n\n/** A set of [[RenderGraphic]]s and [[CanvasDecoration]]s produced by [[Tool]]s and [[Decorator]]s, used to decorate the contents of a [[Viewport]].\n * @public\n */\nexport class Decorations implements IDisposable {\n  private _skyBox?: RenderGraphic;\n  private _viewBackground?: RenderGraphic; // drawn first, view units, with no zbuffer, smooth shading, default lighting. e.g., a skybox\n  private _normal?: GraphicList;       // drawn with zbuffer, with scene lighting\n  private _world?: GraphicList;        // drawn with zbuffer, with default lighting, smooth shading\n  private _worldOverlay?: GraphicList; // drawn in overlay mode, world units\n  private _viewOverlay?: GraphicList;  // drawn in overlay mode, view units\n\n  public canvasDecorations?: CanvasDecorationList;\n\n  /** A view decoration created from a [[SkyBox]] rendered behind all other geometry to provide environmental context. */\n  public get skyBox(): RenderGraphic | undefined { return this._skyBox; }\n  public set skyBox(skyBox: RenderGraphic | undefined) { dispose(this._skyBox); this._skyBox = skyBox; }\n  /** A view decoration drawn as the background of the view. @see [[GraphicType.ViewBackground]]. */\n  public get viewBackground(): RenderGraphic | undefined { return this._viewBackground; }\n  public set viewBackground(viewBackground: RenderGraphic | undefined) { dispose(this._viewBackground); this._viewBackground = viewBackground; }\n  /** Decorations drawn as if they were part of the scene. @see [[GraphicType.Scene]]. */\n  public get normal(): GraphicList | undefined { return this._normal; }\n  public set normal(normal: GraphicList | undefined) { disposeArray(this._normal); this._normal = normal; }\n  /** Decorations drawn as if they were part of the world, but ignoring the view's [[ViewFlags]]. @see [[GraphicType.WorldDecoration]]. */\n  public get world(): GraphicList | undefined { return this._world; }\n  public set world(world: GraphicList | undefined) { disposeArray(this._world); this._world = world; }\n  /** Overlay decorations drawn in world coordinates. @see [[GraphicType.WorldOverlay]]. */\n  public get worldOverlay(): GraphicList | undefined { return this._worldOverlay; }\n  public set worldOverlay(worldOverlay: GraphicList | undefined) { disposeArray(this._worldOverlay); this._worldOverlay = worldOverlay; }\n  /** Overlay decorations drawn in view coordinates. @see [[GraphicType.ViewOverlay]]. */\n  public get viewOverlay(): GraphicList | undefined { return this._viewOverlay; }\n  public set viewOverlay(viewOverlay: GraphicList | undefined) { disposeArray(this._viewOverlay); this._viewOverlay = viewOverlay; }\n\n  public dispose() {\n    this.skyBox = undefined;\n    this.viewBackground = undefined;\n    this.world = undefined;\n    this.worldOverlay = undefined;\n    this.viewOverlay = undefined;\n    this.normal = undefined;\n  }\n}\n\n/**\n * A node in a scene graph. The branch itself is not renderable. Instead it contains a list of RenderGraphics,\n * and a transform, symbology overrides, and clip volume which are to be applied when rendering them.\n * Branches can be nested to build an arbitrarily-complex scene graph.\n * @see [[RenderSystem.createBranch]]\n * @public\n */\nexport class GraphicBranch implements IDisposable /* , RenderMemory.Consumer */ {\n  /** The child nodes of this branch */\n  public readonly entries: RenderGraphic[] = [];\n  /** If true, when the branch is disposed of, the RenderGraphics in its entries array will also be disposed */\n  public readonly ownsEntries: boolean;\n  private _viewFlagOverrides = new ViewFlag.Overrides();\n  /** Optional symbology overrides to be applied to all graphics in this branch */\n  public symbologyOverrides?: FeatureSymbology.Overrides;\n  /** Optional animation branch Id.\n   * @internal\n   */\n  public animationId?: string;\n\n  /** Constructor\n   * @param ownsEntries If true, when this branch is [[dispose]]d, all of the [[RenderGraphic]]s it contains will also be disposed.\n   */\n  public constructor(ownsEntries: boolean = false) { this.ownsEntries = ownsEntries; }\n\n  /** Add a graphic to this branch. */\n  public add(graphic: RenderGraphic): void { this.entries.push(graphic); }\n  /** @internal */\n  public getViewFlags(flags: ViewFlags, out?: ViewFlags): ViewFlags { return this._viewFlagOverrides.apply(flags.clone(out)); }\n  /** @internal */\n  public setViewFlags(flags: ViewFlags): void { this._viewFlagOverrides.overrideAll(flags); }\n  /** @internal */\n  public setViewFlagOverrides(ovr: ViewFlag.Overrides): void { this._viewFlagOverrides.copyFrom(ovr); }\n\n  public dispose() { this.clear(); }\n  public get isEmpty(): boolean { return 0 === this.entries.length; }\n\n  /** Empties the list of [[RenderGraphic]]s contained in this branch, and if the [[GraphicBranch.ownsEntries]] flag is set, also disposes of them. */\n  public clear(): void {\n    if (this.ownsEntries)\n      disposeArray(this.entries);\n    else\n      this.entries.length = 0;\n  }\n\n  /** @internal */\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    for (const entry of this.entries)\n      entry.collectStatistics(stats);\n  }\n}\n\n/** Describes aspects of a pixel as read from a [[Viewport]].\n * @see [[Viewport.readPixels]]\n * @beta\n */\nexport namespace Pixel {\n  /** Describes a single pixel within a [[Pixel.Buffer]]. */\n  export class Data {\n    public readonly feature?: Feature;\n    public readonly distanceFraction: number;\n    public readonly type: GeometryType;\n    public readonly planarity: Planarity;\n    /** @internal */\n    public readonly featureTable?: PackedFeatureTable;\n\n    /** @internal */\n    public constructor(feature?: Feature, distanceFraction = -1.0, type = GeometryType.Unknown, planarity = Planarity.Unknown, featureTable?: PackedFeatureTable) {\n      this.feature = feature;\n      this.distanceFraction = distanceFraction;\n      this.type = type;\n      this.planarity = planarity;\n      this.featureTable = featureTable;\n    }\n\n    public get elementId(): Id64String | undefined { return undefined !== this.feature ? this.feature.elementId : undefined; }\n    public get subCategoryId(): Id64String | undefined { return undefined !== this.feature ? this.feature.subCategoryId : undefined; }\n    public get geometryClass(): GeometryClass | undefined { return undefined !== this.feature ? this.feature.geometryClass : undefined; }\n  }\n\n  /** Describes the foremost type of geometry which produced the [[Pixel.Data]]. */\n  export const enum GeometryType {\n    /** [[Pixel.Selector.GeometryAndDistance]] was not specified, or the type could not be determined. */\n    Unknown, // Geometry was not selected, or type could not be determined\n    /** No geometry was rendered to this pixel. */\n    None,\n    /** A surface produced this pixel. */\n    Surface,\n    /** A point primitive or polyline produced this pixel. */\n    Linear,\n    /** This pixel was produced by an edge of a surface. */\n    Edge,\n    /** This pixel was produced by a silhouette edge of a curved surface. */\n    Silhouette,\n  }\n\n  /** Describes the planarity of the foremost geometry which produced the pixel. */\n  export const enum Planarity {\n    /** [[Pixel.Selector.GeometryAndDistance]] was not specified, or the planarity could not be determined. */\n    Unknown,\n    /** No geometry was rendered to this pixel. */\n    None,\n    /** Planar geometry produced this pixel. */\n    Planar,\n    /** Non-planar geometry produced this pixel. */\n    NonPlanar,\n  }\n\n  /**\n   * Bit-mask by which callers of [[Viewport.readPixels]] specify which aspects are of interest.\n   * Aspects not specified will be omitted from the returned data.\n   */\n  export const enum Selector {\n    None = 0,\n    /** Select the [[Feature]] which produced each pixel, as well as the [[PackedFeatureTable]] from which the feature originated. */\n    Feature = 1 << 0,\n    /** Select the type and planarity of geometry which produced each pixel as well as the fraction of its distance between the near and far planes. */\n    GeometryAndDistance = 1 << 2,\n    /** Select all aspects of each pixel. */\n    All = GeometryAndDistance | Feature,\n  }\n\n  /** A rectangular array of pixels as read from a [[Viewport]]'s frame buffer. Each pixel is represented as a [[Pixel.Data]] object.\n   * @see [[Viewport.readPixels]].\n   */\n  export interface Buffer {\n    /** Retrieve the data associated with the pixel at (x,y) in view coordinates. */\n    getPixel(x: number, y: number): Data;\n  }\n\n  /** A function which receives the results of a call to [[Viewport.readPixels]].\n   * @note The contents of the buffer become invalid once the Receiver function returns. Do not store a reference to it.\n   */\n  export type Receiver = (pixels: Buffer | undefined) => void;\n}\n\n/** @internal */\nexport interface PackedFeature {\n  elementId: Id64.Uint32Pair;\n  subCategoryId: Id64.Uint32Pair;\n  geometryClass: GeometryClass;\n  animationNodeId: number;\n}\n\n/**\n * An immutable, packed representation of a [[FeatureTable]]. The features are packed into a single array of 32-bit integer values,\n * wherein each feature occupies 3 32-bit integers.\n * @internal\n */\nexport class PackedFeatureTable {\n  private readonly _data: Uint32Array;\n  public readonly modelId: Id64String;\n  public readonly maxFeatures: number;\n  public readonly numFeatures: number;\n  public readonly anyDefined: boolean;\n  public readonly type: BatchType;\n  private readonly _animationNodeIds?: Uint8Array | Uint16Array | Uint32Array;\n\n  public get byteLength(): number { return this._data.byteLength; }\n\n  /** Construct a PackedFeatureTable from the packed binary data.\n   * This is used internally when deserializing Tiles in iMdl format.\n   * @internal\n   */\n  public constructor(data: Uint32Array, modelId: Id64String, numFeatures: number, maxFeatures: number, type: BatchType, animationNodeIds?: Uint8Array | Uint16Array | Uint32Array) {\n    this._data = data;\n    this.modelId = modelId;\n    this.maxFeatures = maxFeatures;\n    this.numFeatures = numFeatures;\n    this.type = type;\n    this._animationNodeIds = animationNodeIds;\n\n    switch (this.numFeatures) {\n      case 0:\n        this.anyDefined = false;\n        break;\n      case 1:\n        this.anyDefined = this.getFeature(0).isDefined;\n        break;\n      default:\n        this.anyDefined = true;\n        break;\n    }\n\n    assert(this._data.length >= this._subCategoriesOffset);\n    assert(this.maxFeatures >= this.numFeatures);\n    assert(undefined === this._animationNodeIds || this._animationNodeIds.length === this.numFeatures);\n  }\n\n  /** Create a packed feature table from a [[FeatureTable]]. */\n  public static pack(featureTable: FeatureTable): PackedFeatureTable {\n    // We must determine how many subcategories we have ahead of time to compute the size of the Uint32Array, as\n    // the array cannot be resized after it is created.\n    // We are not too worried about this as FeatureTables created on the front-end will contain few if any features; those obtained from the\n    // back-end arrive within tiles already in the packed format.\n    const subcategories = new Map<string, number>();\n    for (const iv of featureTable.getArray()) {\n      const found = subcategories.get(iv.value.subCategoryId.toString());\n      if (undefined === found)\n        subcategories.set(iv.value.subCategoryId, subcategories.size);\n    }\n\n    // We need 3 32-bit integers per feature, plus 2 32-bit integers per subcategory.\n    const subCategoriesOffset = 3 * featureTable.length;\n    const nUint32s = subCategoriesOffset + 2 * subcategories.size;\n    const uint32s = new Uint32Array(nUint32s);\n\n    for (const iv of featureTable.getArray()) {\n      const feature = iv.value;\n      const index = iv.index * 3;\n\n      let subCategoryIndex = subcategories.get(feature.subCategoryId)!;\n      assert(undefined !== subCategoryIndex); // we inserted it above...\n      subCategoryIndex |= (feature.geometryClass << 24);\n\n      uint32s[index + 0] = Id64.getLowerUint32(feature.elementId);\n      uint32s[index + 1] = Id64.getUpperUint32(feature.elementId);\n      uint32s[index + 2] = subCategoryIndex;\n    }\n\n    subcategories.forEach((index: number, id: string, _map) => {\n      const index32 = subCategoriesOffset + 2 * index;\n      uint32s[index32 + 0] = Id64.getLowerUint32(id);\n      uint32s[index32 + 1] = Id64.getUpperUint32(id);\n    });\n\n    return new PackedFeatureTable(uint32s, featureTable.modelId, featureTable.length, featureTable.maxFeatures, featureTable.type);\n  }\n\n  /** Retrieve the Feature associated with the specified index. */\n  public getFeature(featureIndex: number): Feature {\n    const packed = this.getPackedFeature(featureIndex);\n    const elemId = Id64.fromUint32Pair(packed.elementId.lower, packed.elementId.upper);\n    const subcatId = Id64.fromUint32Pair(packed.subCategoryId.lower, packed.subCategoryId.upper);\n    return new Feature(elemId, subcatId, packed.geometryClass);\n  }\n\n  /** Returns the Feature associated with the specified index, or undefined if the index is out of range. */\n  public findFeature(featureIndex: number): Feature | undefined {\n    return featureIndex < this.numFeatures ? this.getFeature(featureIndex) : undefined;\n  }\n\n  /** @internal */\n  public getElementIdPair(featureIndex: number): Id64.Uint32Pair {\n    assert(featureIndex < this.numFeatures);\n    const offset = 3 * featureIndex;\n    return {\n      lower: this._data[offset],\n      upper: this._data[offset + 1],\n    };\n  }\n\n  /** @internal */\n  public getSubCategoryIdPair(featureIndex: number): Id64.Uint32Pair {\n    const index = 3 * featureIndex;\n    let subCatIndex = this._data[index + 2];\n    subCatIndex = (subCatIndex & 0x00ffffff) >>> 0;\n    subCatIndex = subCatIndex * 2 + this._subCategoriesOffset;\n    return { lower: this._data[subCatIndex], upper: this._data[subCatIndex + 1] };\n  }\n\n  /** @internal */\n  public getAnimationNodeId(featureIndex: number): number {\n    return undefined !== this._animationNodeIds ? this._animationNodeIds[featureIndex] : 0;\n  }\n\n  /** @internal */\n  public getPackedFeature(featureIndex: number): PackedFeature {\n    assert(featureIndex < this.numFeatures);\n\n    const index32 = 3 * featureIndex;\n    const elementId = { lower: this._data[index32], upper: this._data[index32 + 1] };\n\n    const subCatIndexAndClass = this._data[index32 + 2];\n    const geometryClass = (subCatIndexAndClass >>> 24) & 0xff;\n\n    let subCatIndex = (subCatIndexAndClass & 0x00ffffff) >>> 0;\n    subCatIndex = subCatIndex * 2 + this._subCategoriesOffset;\n    const subCategoryId = { lower: this._data[subCatIndex], upper: this._data[subCatIndex + 1] };\n\n    const animationNodeId = this.getAnimationNodeId(featureIndex);\n    return { elementId, subCategoryId, geometryClass, animationNodeId };\n  }\n\n  /** Returns the element ID of the Feature associated with the specified index, or undefined if the index is out of range. */\n  public findElementId(featureIndex: number): Id64String | undefined {\n    if (featureIndex >= this.numFeatures)\n      return undefined;\n    else\n      return this.readId(3 * featureIndex);\n  }\n\n  /** Return true if this table contains exactly 1 feature. */\n  public get isUniform(): boolean { return 1 === this.numFeatures; }\n\n  /** If this table contains exactly 1 feature, return it. */\n  public get uniform(): Feature | undefined { return this.isUniform ? this.getFeature(0) : undefined; }\n\n  public get isVolumeClassifier(): boolean { return BatchType.VolumeClassifier === this.type; }\n  public get isPlanarClassifier(): boolean { return BatchType.VolumeClassifier === this.type; }\n  public get isClassifier(): boolean { return this.isVolumeClassifier || this.isPlanarClassifier; }\n\n  /** Unpack the features into a [[FeatureTable]]. */\n  public unpack(): FeatureTable {\n    const table = new FeatureTable(this.maxFeatures, this.modelId);\n    for (let i = 0; i < this.numFeatures; i++) {\n      const feature = this.getFeature(i);\n      table.insertWithIndex(feature, i);\n    }\n\n    return table;\n  }\n\n  private get _subCategoriesOffset(): number { return this.numFeatures * 3; }\n\n  private readId(offset32: number): Id64String {\n    return Id64.fromUint32Pair(this._data[offset32], this._data[offset32 + 1]);\n  }\n}\n\n/** A RenderTarget connects a [[Viewport]] to a WebGLRenderingContext to enable the viewport's contents to be displayed on the screen.\n * Application code rarely interacts directly with a RenderTarget - instead, it interacts with a Viewport which forwards requests to the implementation\n * of the RenderTarget.\n * @internal\n */\nexport abstract class RenderTarget implements IDisposable {\n  public pickOverlayDecoration(_pt: XAndY): CanvasDecoration | undefined { return undefined; }\n\n  public static get frustumDepth2d(): number { return 1.0; } // one meter\n  public static get maxDisplayPriority(): number { return (1 << 23) - 32; }\n  public static get minDisplayPriority(): number { return -this.maxDisplayPriority; }\n\n  /** Returns a transform mapping an object's display priority to a depth from 0 to frustumDepth2d. */\n  public static depthFromDisplayPriority(priority: number): number {\n    return (priority - this.minDisplayPriority) / (this.maxDisplayPriority - this.minDisplayPriority) * this.frustumDepth2d;\n  }\n\n  public abstract get renderSystem(): RenderSystem;\n  public abstract get cameraFrustumNearScaleLimit(): number;\n  public abstract get viewRect(): ViewRect;\n  public abstract get wantInvertBlackBackground(): boolean;\n\n  public abstract get animationFraction(): number;\n  public abstract set animationFraction(fraction: number);\n\n  public get animationBranches(): AnimationBranchStates | undefined { return undefined; }\n  public set animationBranches(_transforms: AnimationBranchStates | undefined) { }\n  public get solarShadowMap(): RenderSolarShadowMap | undefined { return undefined; }\n\n  public createGraphicBuilder(type: GraphicType, viewport: Viewport, placement: Transform = Transform.identity, pickableId?: Id64String) { return this.renderSystem.createGraphicBuilder(placement, type, viewport, pickableId); }\n\n  public dispose(): void { }\n  public reset(): void { }\n  public abstract changeScene(scene: GraphicList): void;\n  public abstract changeBackgroundMap(_scene: GraphicList): void;\n  public changePlanarClassifiers(_classifiers?: PlanarClassifierMap): void { }\n  public changeSolarShadowMap(_solarShadowMap?: RenderSolarShadowMap): void { }\n  public abstract changeDynamics(dynamics?: GraphicList): void;\n  public abstract changeDecorations(decorations: Decorations): void;\n  public abstract changeRenderPlan(plan: RenderPlan): void;\n  public abstract drawFrame(sceneMilSecElapsed?: number): void;\n  public overrideFeatureSymbology(_ovr: FeatureSymbology.Overrides): void { }\n  public setHiliteSet(_hilited: HiliteSet): void { }\n  public setFlashed(_elementId: Id64String, _intensity: number): void { }\n  public abstract setViewRect(_rect: ViewRect, _temporary: boolean): void;\n  public onResized(): void { }\n  public abstract updateViewRect(): boolean; // force a RenderTarget viewRect to resize if necessary since last draw\n  public abstract readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void;\n  public readImage(_rect: ViewRect, _targetSize: Point2d, _flipVertically: boolean): ImageBuffer | undefined { return undefined; }\n}\n\n/** Describes a texture loaded from an HTMLImageElement\n * @internal\n */\nexport interface TextureImage {\n  /** The HTMLImageElement containing the texture's image data */\n  image: HTMLImageElement | undefined;\n  /** The format of the texture's image data */\n  format: ImageSourceFormat | undefined;\n}\n\n/** @internal */\nexport const enum RenderDiagnostics {\n  /** No diagnostics enabled. */\n  None = 0,\n  /** Debugging output to browser console enabled. */\n  DebugOutput = 1 << 1,\n  /** Potentially expensive checks of WebGL state enabled. */\n  WebGL = 1 << 2,\n  /** All diagnostics enabled. */\n  All = DebugOutput | WebGL,\n}\n\n/** Parameters for creating a [[RenderGraphic]] representing a collection of instances of shared geometry.\n * Each instance is drawn using the same graphics, but with its own transform and (optionally) [[Feature]] Id.\n * @internal\n */\nexport interface InstancedGraphicParams {\n  /** The number of instances.\n   * Must be greater than zero.\n   * Must be equal to (transforms.length / 12)\n   * If featureIds is defined, must be equal to (featureIds.length / 3)\n   * If symbologyOverrides is defined, must be equal to (symbologyOverrides.length / 8)\n   */\n  readonly count: number;\n\n  /** An array of instance-to-model transforms.\n   * Each transform consists of 3 rows of 4 columns where the 4th column holds the translation.\n   * The translations are relative to the `transformCenter` property.\n   */\n  readonly transforms: Float32Array;\n\n  /** A point roughly in the center of the range of all of the instances, to which each instance's translation is relative.\n   * This is used to reduce precision errors when transforming the instances in shader code.\n   */\n  readonly transformCenter: Point3d;\n\n  /** If defined, an array of little-endian 24-bit unsigned integers containing the feature ID of each instance. */\n  readonly featureIds?: Uint8Array;\n\n  /**\n   * If defined, as array of bytes (8 per instance) encoding the symbology overrides for each instance. The encoding matches that used by FeatureOverrides, though only the RGB, alpha, line weight, and line code are used.\n   * @internal\n   */\n  readonly symbologyOverrides?: Uint8Array;\n}\n\n/** A RenderSystem provides access to resources used by the internal WebGL-based rendering system.\n * An application rarely interacts directly with the RenderSystem; instead it interacts with types like [[Viewport]] which\n * coordinate with the RenderSystem on the application's behalf.\n * @see [[IModelApp.renderSystem]].\n * @public\n */\nexport abstract class RenderSystem implements IDisposable {\n  /** Options used to initialize the RenderSystem. These are primarily used for feature-gating.\n   * This object is frozen and cannot be modified after the RenderSystem is created.\n   * @internal\n   */\n  public readonly options: RenderSystem.Options;\n\n  /** Initialize the RenderSystem with the specified options.\n   * @note The RenderSystem takes ownership of the supplied Options and freezes it.\n   * @internal\n   */\n  protected constructor(options?: RenderSystem.Options) {\n    this.options = undefined !== options ? options : {};\n    Object.freeze(this.options);\n    if (undefined !== this.options.disabledExtensions)\n      Object.freeze(this.options.disabledExtensions);\n  }\n\n  /** @internal */\n  public abstract get isValid(): boolean;\n\n  /** @internal */\n  public abstract dispose(): void;\n\n  /** @internal */\n  public get maxTextureSize(): number { return 0; }\n\n  /** @internal */\n  public get supportsInstancing(): boolean { return true; }\n\n  /** @internal */\n  public abstract createTarget(canvas: HTMLCanvasElement): RenderTarget;\n  /** @internal */\n  public abstract createOffscreenTarget(rect: ViewRect): RenderTarget;\n\n  /** Find a previously-created [RenderMaterial]($common) by its ID.\n   * @param _key The unique ID of the material within the context of the IModelConnection. Typically an element ID.\n   * @param _imodel The IModelConnection with which the material is associated.\n   * @returns A previously-created material matching the specified ID, or undefined if no such material exists.\n   */\n  public findMaterial(_key: string, _imodel: IModelConnection): RenderMaterial | undefined { return undefined; }\n\n  /** Create a [RenderMaterial]($common) from parameters\n   * If the parameters include a non-empty key, and no previously-created material already exists with that key, the newly-created material will be cached on the IModelConnection such\n   * that it can later be retrieved by the same key using [[RenderSystem.findMaterial]].\n   * @param _params A description of the material's properties.\n   * @param _imodel The IModelConnection associated with the material.\n   * @returns the newly-created material, or undefined if the material could not be created or if a material with the same key as that specified in the params already exists.\n   */\n  public createMaterial(_params: RenderMaterial.Params, _imodel: IModelConnection): RenderMaterial | undefined { return undefined; }\n\n  /** Creates a [[GraphicBuilder]] for creating a [[RenderGraphic]].\n   * @param placement The local-to-world transform in which the builder's geometry is to be defined.\n   * @param type The type of builder to create.\n   * @param viewport The viewport in which the resultant [[RenderGraphic]] will be rendered.\n   * @param pickableId If the decoration is to be pickable, a unique identifier to associate with the resultant [[RenderGraphic]].\n   * @returns A builder for creating a [[RenderGraphic]] of the specified type appropriate for rendering within the specified viewport.\n   * @see [[IModelConnection.transientIds]] for obtaining an ID for a pickable decoration.\n   * @see [[RenderContext.createGraphicBuilder]].\n   * @see [[Decorator]]\n   */\n  public abstract createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): GraphicBuilder;\n\n  /** @internal */\n  public createTriMesh(args: MeshArgs, instances?: InstancedGraphicParams): RenderGraphic | undefined {\n    const params = MeshParams.create(args);\n    return this.createMesh(params, instances);\n  }\n\n  /** @internal */\n  public createIndexedPolylines(args: PolylineArgs, instances?: InstancedGraphicParams): RenderGraphic | undefined {\n    if (args.flags.isDisjoint) {\n      const pointStringParams = PointStringParams.create(args);\n      return undefined !== pointStringParams ? this.createPointString(pointStringParams, instances) : undefined;\n    } else {\n      const polylineParams = PolylineParams.create(args);\n      return undefined !== polylineParams ? this.createPolyline(polylineParams, instances) : undefined;\n    }\n  }\n\n  /** @internal */\n  public createMesh(_params: MeshParams, _instances?: InstancedGraphicParams): RenderGraphic | undefined { return undefined; }\n  /** @internal */\n  public createPolyline(_params: PolylineParams, _instances?: InstancedGraphicParams): RenderGraphic | undefined { return undefined; }\n  /** @internal */\n  public createPointString(_params: PointStringParams, _instances?: InstancedGraphicParams): RenderGraphic | undefined { return undefined; }\n  /** @internal */\n  public createPointCloud(_args: PointCloudArgs, _imodel: IModelConnection): RenderGraphic | undefined { return undefined; }\n  /** @internal */\n  public createSheetTilePolyfaces(_corners: Point3d[], _clip?: ClipVector): IndexedPolyface[] { return []; }\n  /** @internal */\n  public createSheetTile(_tile: RenderTexture, _polyfaces: IndexedPolyface[], _tileColor: ColorDef): GraphicList { return []; }\n  /** @internal */\n  public createClipVolume(_clipVector: ClipVector): RenderClipVolume | undefined { return undefined; }\n  /** @internal */\n  public getSpatialClassificationModel(_classifierModelId: Id64String, _iModel: IModelConnection): RenderClassifierModel | undefined { return undefined; }\n  /** @internal */\n  public addSpatialClassificationModel(_modelId: Id64String, _classificationModel: RenderClassifierModel, _iModel: IModelConnection) { }\n  /** @internal */\n  public createPlanarClassifier(_properties: SpatialClassificationProps.Properties, _tileTree: TileTree, _classifiedModel: TileTreeModelState, _sceneContext: SceneContext): RenderPlanarClassifier | undefined { return undefined; }\n  /** @internal */\n  public getSolarShadowMap(_frustum: Frustum, _direction: Vector3d, _settings: SolarShadows.Settings, _models: ModelSelectorState, _categories: CategorySelectorState, _imodel: IModelConnection): RenderSolarShadowMap | undefined { return undefined; }\n  /** @internal */\n  public createTile(tileTexture: RenderTexture, corners: Point3d[]): RenderGraphic | undefined {\n    const rasterTile = new MeshArgs();\n\n    // corners\n    // [0] [1]\n    // [2] [3]\n    // Quantize the points according to their range\n    rasterTile.points = new QPoint3dList(QParams3d.fromRange(Range3d.create(...corners)));\n    for (let i = 0; i < 4; ++i)\n      rasterTile.points.add(corners[i]);\n\n    // Now remove the translation from the quantized points and put it into a transform instead.\n    // This prevents graphical artifacts when quantization origin is large relative to quantization scale.\n    // ###TODO: Would be better not to create a branch for every tile.\n    const qorigin = rasterTile.points.params.origin;\n    const transform = Transform.createTranslationXYZ(qorigin.x, qorigin.y, qorigin.z);\n    qorigin.setZero();\n\n    rasterTile.vertIndices = [0, 1, 2, 2, 1, 3];\n    rasterTile.textureUv = [\n      new Point2d(0.0, 0.0),\n      new Point2d(1.0, 0.0),\n      new Point2d(0.0, 1.0),\n      new Point2d(1.0, 1.0),\n    ];\n\n    rasterTile.texture = tileTexture;\n    rasterTile.isPlanar = true;\n\n    const trimesh = this.createTriMesh(rasterTile);\n    if (undefined === trimesh)\n      return undefined;\n\n    const branch = new GraphicBranch(true);\n    branch.add(trimesh);\n    return this.createBranch(branch, transform);\n  }\n\n  /** Create a Graphic for a [[SkyBox]] which encompasses the entire scene, rotating with the camera. */\n  public createSkyBox(_params: SkyBox.CreateParams): RenderGraphic | undefined { return undefined; }\n\n  /** Create a RenderGraphic consisting of a list of Graphics to be drawn together. */\n  public abstract createGraphicList(primitives: RenderGraphic[]): RenderGraphic;\n\n  /** Create a RenderGraphic consisting of a list of Graphics, with optional transform and symbology overrides applied to the list */\n  public createBranch(branch: GraphicBranch, transform: Transform): RenderGraphic {\n    return this.createGraphicBranch(branch, transform);\n  }\n\n  /** @internal */\n  public abstract createGraphicBranch(branch: GraphicBranch, transform: Transform, clips?: RenderClipVolume, planarClassifier?: RenderPlanarClassifier): RenderGraphic;\n\n  /** Create a RenderGraphic consisting of batched [[Feature]]s.\n   * @internal\n   */\n  public abstract createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d): RenderGraphic;\n\n  /** Find a previously-created [[RenderTexture]] by its ID.\n   * @param _key The unique ID of the texture within the context of the IModelConnection. Typically an element ID.\n   * @param _imodel The IModelConnection with which the texture is associated.\n   * @returns A previously-created texture matching the specified ID, or undefined if no such texture exists.\n   */\n  public findTexture(_key: string, _imodel: IModelConnection): RenderTexture | undefined { return undefined; }\n\n  /** Find or create a [[RenderTexture]] from a persistent texture element.\n   * @param id The ID of the texture element.\n   * @param iModel The IModel containing the texture element.\n   * @returns A Promise resolving to the created RenderTexture or to undefined if the texture could not be created.\n   * @note If the texture is successfully created, it will be cached on the IModelConnection such that it can later be retrieved by its ID using [[RenderSystem.findTexture]].\n   * @see [[RenderSystem.loadTextureImage]].\n   * @internal\n   */\n  public async loadTexture(id: Id64String, iModel: IModelConnection): Promise<RenderTexture | undefined> {\n    let texture = this.findTexture(id.toString(), iModel);\n    if (undefined === texture) {\n      const image = await this.loadTextureImage(id, iModel);\n      if (undefined !== image) {\n        // This will return a pre-existing RenderTexture if somebody else loaded it while we were awaiting the image.\n        texture = this.createTextureFromImage(image.image!, ImageSourceFormat.Png === image.format!, iModel, new RenderTexture.Params(id.toString()));\n      }\n    }\n\n    return texture;\n  }\n\n  /**\n   * Load a texture image given the ID of a texture element.\n   * @param id The ID of the texture element.\n   * @param iModel The IModel containing the texture element.\n   * @returns A Promise resolving to a TextureImage created from the texture element's data, or to undefined if the TextureImage could not be created.\n   * @see [[RenderSystem.loadTexture]]\n   * @internal\n   */\n  public async loadTextureImage(id: Id64String, iModel: IModelConnection): Promise<TextureImage | undefined> {\n    const elemProps = await iModel.elements.getProps(id);\n    if (1 !== elemProps.length)\n      return undefined;\n\n    const textureProps = elemProps[0];\n    if (undefined === textureProps.data || \"string\" !== typeof (textureProps.data) || undefined === textureProps.format || \"number\" !== typeof (textureProps.format))\n      return undefined;\n\n    const format = textureProps.format as ImageSourceFormat;\n    if (!isValidImageSourceFormat(format))\n      return undefined;\n\n    const imageSource = new ImageSource(base64StringToUint8Array(textureProps.data as string), format);\n    const imagePromise = imageElementFromImageSource(imageSource);\n    return imagePromise.then((image: HTMLImageElement) => ({ image, format }));\n  }\n\n  /** Obtain a texture created from a gradient.\n   * @param _symb The description of the gradient.\n   * @param _imodel The IModelConnection with which the texture is associated.\n   * @returns A texture created from the gradient image, or undefined if the texture could not be created.\n   * @note If a texture matching the specified gradient already exists, it will be returned.\n   * Otherwise, the newly-created texture will be cached on the IModelConnection such that a subsequent call to getGradientTexture with an equivalent gradient will\n   * return the previously-created texture.\n   * @beta\n   */\n  public getGradientTexture(_symb: Gradient.Symb, _imodel: IModelConnection): RenderTexture | undefined { return undefined; }\n\n  /** Create a new texture from an [[ImageBuffer]]. */\n  public createTextureFromImageBuffer(_image: ImageBuffer, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined { return undefined; }\n\n  /** Create a new texture from an HTML image. Typically the image was extracted from a binary representation of a jpeg or png via [[imageElementFromImageSource]] */\n  public createTextureFromImage(_image: HTMLImageElement, _hasAlpha: boolean, _imodel: IModelConnection | undefined, _params: RenderTexture.Params): RenderTexture | undefined { return undefined; }\n\n  /** Create a new texture from an [[ImageSource]]. */\n  public async createTextureFromImageSource(source: ImageSource, imodel: IModelConnection | undefined, params: RenderTexture.Params): Promise<RenderTexture | undefined> {\n    return imageElementFromImageSource(source).then((image) => IModelApp.hasRenderSystem ? this.createTextureFromImage(image, ImageSourceFormat.Png === source.format, imodel, params) : undefined);\n  }\n\n  /** Create a new texture from a cube of HTML images.\n   * @internal\n   */\n  public createTextureFromCubeImages(_posX: HTMLImageElement, _negX: HTMLImageElement, _posY: HTMLImageElement, _negY: HTMLImageElement, _posZ: HTMLImageElement, _negZ: HTMLImageElement, _imodel: IModelConnection, _params: RenderTexture.Params): RenderTexture | undefined { return undefined; }\n\n  /** @internal */\n  public onInitialized(): void { }\n\n  /** @internal */\n  public enableDiagnostics(_enable: RenderDiagnostics): void { }\n}\n\n/** @internal */\nexport type WebGLExtensionName = \"WEBGL_draw_buffers\" | \"OES_element_index_uint\" | \"OES_texture_float\" | \"OES_texture_half_float\" |\n  \"WEBGL_depth_texture\" | \"EXT_color_buffer_float\" | \"EXT_shader_texture_lod\" | \"ANGLE_instanced_arrays\";\n\n/** A RenderSystem provides access to resources used by the internal WebGL-based rendering system.\n * An application rarely interacts directly with the RenderSystem; instead it interacts with types like [[Viewport]] which\n * coordinate with the RenderSystem on the application's behalf.\n * @see [[IModelApp.renderSystem]].\n * @public\n */\nexport namespace RenderSystem {\n  /** Options passed to [[IModelApp.supplyRenderSystem]] to configure the [[RenderSystem]] on startup.\n   * @beta\n   */\n  export interface Options {\n    /** WebGL extensions to be explicitly disabled, regardless of whether or not the WebGL implementation supports them.\n     * This is chiefly useful for testing code which only executes in the absence of particular extensions.\n     * @internal\n     */\n    disabledExtensions?: WebGLExtensionName[];\n    /** Specifies whether to use optimized surface shaders when edge display is not important. If set to true, then in 3d views the optimized shaders will be used if:\n     *  - Render mode is wireframe; or\n     *  - Render mode is smooth shade and visible edges are turned off.\n     * @internal\n     */\n    enableOptimizedSurfaceShaders?: boolean;\n    /** If true, when a clip volume is applied to the view, geometry will be tested against the clip volume on the CPU and not drawn if it is entirely clipped, improving performance.\n     * @internal\n     */\n    cullAgainstActiveVolume?: boolean;\n    /** If true, preserve the shader source code as internal strings, useful for debugging purposes.\n     * @internal\n     */\n    preserveShaderSourceCode?: boolean;\n    /** If true display solar shadows.\n     *      * @internal\n     */\n    displaySolarShadows?: boolean;\n\n  }\n}\n\n/** Clip/Transform for a branch that are varied over time.\n * @internal\n */\nexport class AnimationBranchState {\n  public readonly omit?: boolean;\n  public readonly transform?: Transform;\n  public readonly clip?: RenderClipVolume;\n  constructor(transform?: Transform, clip?: RenderClipVolume, omit?: boolean) { this.transform = transform; this.clip = clip; this.omit = omit; }\n}\n\n/** Mapping from node/branch IDs to animation branch state\n * @internal\n */\nexport type AnimationBranchStates = Map<string, AnimationBranchState>;\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Rendering */\r\n\r\n/** @internal */\r\nexport interface AuxChannelProps {\r\n  readonly name: string;\r\n  readonly inputs: number[];\r\n  readonly indices: number[];\r\n}\r\n\r\n/** @internal */\r\nexport interface QuantizedAuxChannelProps extends AuxChannelProps {\r\n  readonly qOrigin: number[];\r\n  readonly qScale: number[];\r\n}\r\n\r\n/** @internal */\r\nexport class AuxChannel implements AuxChannelProps {\r\n  public readonly name: string;\r\n  public readonly inputs: number[];\r\n  public readonly indices: number[];\r\n\r\n  public constructor(props: AuxChannelProps) {\r\n    this.name = props.name;\r\n    this.inputs = props.inputs;\r\n    this.indices = props.indices;\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class AuxDisplacementChannel extends AuxChannel {\r\n  public readonly qOrigin: Float32Array;\r\n  public readonly qScale: Float32Array;\r\n\r\n  public constructor(props: QuantizedAuxChannelProps) {\r\n    super(props);\r\n    this.qOrigin = Float32Array.from(props.qOrigin);\r\n    this.qScale = Float32Array.from(props.qScale);\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class AuxParamChannel extends AuxChannel {\r\n  public readonly qOrigin: number;\r\n  public readonly qScale: number;\r\n\r\n  public constructor(props: QuantizedAuxChannelProps) {\r\n    super(props);\r\n    this.qOrigin = props.qOrigin[0];\r\n    this.qScale = props.qScale[0];\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport interface AuxChannelTableProps {\r\n  /** Rectangular array of per-vertex data, of size width * height * numBytesPerVertex bytes. */\r\n  readonly data: Uint8Array;\r\n  /** The number of 4-byte RGBA columns in each row of the array. */\r\n  readonly width: number;\r\n  /** The number of rows in the array. */\r\n  readonly height: number;\r\n  /** The number of vertices in the array. Must be no more than (width * height) / numBytesPerVertex. */\r\n  readonly count: number;\r\n  /** The number of bytes allocated for each vertex. Must be a multiple of two. */\r\n  readonly numBytesPerVertex: number;\r\n  /** Displacements used for animations. */\r\n  readonly displacements?: QuantizedAuxChannelProps[];\r\n  /** Normals used for animations. */\r\n  readonly normals?: AuxChannelProps[];\r\n  /** Scalar params used for animations. */\r\n  readonly params?: QuantizedAuxChannelProps[];\r\n}\r\n\r\n/**\r\n * Represents one or more channels of auxiliary per-vertex data which can be used to animate and resymbolize a mesh in various ways.\r\n * Each channel holds a fixed number of bytes for each vertex (typically 2 bytes for normals and params, 6 bytes for displacements).\r\n * The channels are interleaved in a rectangular array such that the data for each vertex is stored contiguously; that is, if a displacement and\r\n * a normal channel exist, then the first vertex's displacement is followed by the first vertex's normal, which is followed by the second\r\n * vertex's displacement and normal; and so on.\r\n * @internal\r\n */\r\nexport class AuxChannelTable {\r\n  /** Rectangular array of per-vertex data, of size width * height * numBytesPerVertex bytes. */\r\n  public readonly data: Uint8Array;\r\n  /** The number of 4-byte RGBA columns in each row of the array. */\r\n  public readonly width: number;\r\n  /** The number of rows in the array. */\r\n  public readonly height: number;\r\n  /** The number of vertices in the array. Must be no more than (width * height) / numBytesPerVertex. */\r\n  public readonly numVertices: number;\r\n  /** The number of bytes allocated for each vertex. Must be a multiple of two. */\r\n  public readonly numBytesPerVertex: number;\r\n  /** Displacements used for animations. */\r\n  public readonly displacements?: AuxDisplacementChannel[];\r\n  /** Normals used for animations. */\r\n  public readonly normals?: AuxChannel[];\r\n  /** Scalar params used for animations. */\r\n  public readonly params?: AuxParamChannel[];\r\n\r\n  private constructor(props: AuxChannelTableProps, displacements?: AuxDisplacementChannel[], normals?: AuxChannel[], params?: AuxParamChannel[]) {\r\n    this.data = props.data;\r\n    this.width = props.width;\r\n    this.height = props.height;\r\n    this.numVertices = props.count;\r\n    this.numBytesPerVertex = props.numBytesPerVertex;\r\n    this.displacements = displacements;\r\n    this.normals = normals;\r\n    this.params = params;\r\n  }\r\n\r\n  public static fromJSON(props: AuxChannelTableProps): AuxChannelTable | undefined {\r\n    let displacements: AuxDisplacementChannel[] | undefined;\r\n    let normals: AuxChannel[] | undefined;\r\n    let params: AuxParamChannel[] | undefined;\r\n\r\n    if (undefined !== props.displacements && 0 < props.displacements.length) {\r\n      displacements = [];\r\n      for (const displacement of props.displacements)\r\n        displacements.push(new AuxDisplacementChannel(displacement));\r\n    }\r\n\r\n    if (undefined !== props.normals && 0 < props.normals.length) {\r\n      normals = [];\r\n      for (const normal of props.normals)\r\n        normals.push(new AuxChannel(normal));\r\n    }\r\n\r\n    if (undefined !== props.params && 0 < props.params.length) {\r\n      params = [];\r\n      for (const param of props.params)\r\n        params.push(new AuxParamChannel(param));\r\n    }\r\n\r\n    return undefined !== displacements || undefined !== normals || undefined !== params ? new AuxChannelTable(props, displacements, normals, params) : undefined;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { assert, IndexMap, compareNumbers } from \"@bentley/bentleyjs-core\";\nimport { ColorDef, ColorIndex } from \"@bentley/imodeljs-common\";\n\n/** @internal */\nexport class ColorMap extends IndexMap<number> {\n  private _hasTransparency: boolean = false;\n\n  public constructor() { super(compareNumbers, 0xffff); }\n\n  public hasColor(color: number): boolean { return -1 !== this.indexOf(color); }\n\n  public insert(color: number): number {\n    // The table should never contain a mix of opaque and translucent colors.\n    if (this.isEmpty)\n      this._hasTransparency = ColorMap.isTranslucent(color);\n    else\n      assert(ColorMap.isTranslucent(color) === this.hasTransparency);\n\n    return super.insert(color);\n  }\n\n  public get hasTransparency(): boolean { return this._hasTransparency; }\n  public get isUniform(): boolean { return 1 === this.length; }\n\n  public toColorIndex(index: ColorIndex, indices: number[]): void {\n    index.reset();\n    if (0 === this.length) {\n      assert(false, \"empty color map\");\n      return;\n    } else if (1 === this.length) {\n      index.initUniform(this._array[0].value);\n    } else {\n      const colors = new Uint32Array(this.length);\n      for (const entry of this._array)\n        colors[entry.index] = entry.value;\n\n      index.initNonUniform(colors, indices, this.hasTransparency);\n    }\n  }\n\n  private static _scratchColorDef = new ColorDef();\n  private static isTranslucent(color: number) {\n    this._scratchColorDef.tbgr = color;\n    return 255 !== this._scratchColorDef.getAlpha();\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { GraphicParams, ColorDef, LinePixels, FillFlags, Gradient, RenderMaterial, TextureMapping, RenderTexture } from \"@bentley/imodeljs-common\";\nimport { compareNumbers, compareBooleans, compareStringsOrUndefined, comparePossiblyUndefined, assert } from \"@bentley/bentleyjs-core\";\n\nfunction compareMaterials(lhs?: RenderMaterial, rhs?: RenderMaterial): number {\n  return comparePossiblyUndefined((lhMat: RenderMaterial, rhMat: RenderMaterial) => lhMat === rhMat ? 0 : compareStringsOrUndefined(lhMat.key, rhMat.key), lhs, rhs);\n}\nfunction compareTextureMappings(lhs?: TextureMapping, rhs?: TextureMapping): number {\n  return comparePossiblyUndefined((lhTex: TextureMapping, rhTex: TextureMapping) => lhTex === rhTex ? 0 : compareStringsOrUndefined(lhTex.texture.key, rhTex.texture.key), lhs, rhs);\n}\n\n/** This class is used to determine if things can be batched together for display.\n * @internal\n */\nexport class DisplayParams {\n  public static readonly minTransparency: number = 15;  // Threshold below which we consider a color fully opaque\n  public readonly type: DisplayParams.Type = DisplayParams.Type.Mesh;\n  public readonly material?: RenderMaterial; // meshes only\n  public readonly gradient?: Gradient.Symb;\n  private readonly _textureMapping?: TextureMapping; // only if material is undefined - e.g. glyphs, gradients\n  public readonly lineColor: ColorDef; // all types of geometry (edge color for meshes)\n  public readonly fillColor: ColorDef; // meshes only\n  public readonly width: number; // linear and mesh (edges)\n  public readonly linePixels: LinePixels; // linear and mesh (edges)\n  public readonly fillFlags: FillFlags; // meshes only\n  public readonly ignoreLighting: boolean; // always true for text and linear geometry; true for meshes only if normals not desired\n\n  public constructor(type: DisplayParams.Type, lineColor: ColorDef, fillColor: ColorDef, width: number = 0, linePixels: LinePixels = LinePixels.Solid,\n    fillFlags: FillFlags = FillFlags.None, material?: RenderMaterial, gradient?: Gradient.Symb, ignoreLighting: boolean = false, textureMapping?: TextureMapping) {\n    this.type = type;\n    this.material = material;\n    this.gradient = gradient;\n    this.lineColor = DisplayParams.adjustTransparencyInPlace(lineColor);\n    this.fillColor = DisplayParams.adjustTransparencyInPlace(fillColor);\n    this.width = width;\n    this.linePixels = linePixels;\n    this.fillFlags = fillFlags;\n    this.ignoreLighting = ignoreLighting;\n    this._textureMapping = textureMapping;\n\n    assert(undefined === material || undefined === textureMapping);\n  }\n\n  /** Creates a DisplayParams object for a particular type (mesh, linear, text) based on the specified GraphicParams. */\n  public static createForType(type: DisplayParams.Type, gf: GraphicParams, resolveGradient?: (grad: Gradient.Symb) => RenderTexture | undefined): DisplayParams {\n    const lineColor = DisplayParams.adjustTransparencyInPlace(gf.lineColor.clone());\n    switch (type) {\n      case DisplayParams.Type.Mesh: {\n        let gradientMapping: TextureMapping | undefined;\n        if (undefined !== gf.gradient && undefined !== resolveGradient) {\n          const gradientTexture = resolveGradient(gf.gradient);\n          if (undefined !== gradientTexture)\n            gradientMapping = new TextureMapping(gradientTexture, new TextureMapping.Params());\n        }\n        return new DisplayParams(type, lineColor, DisplayParams.adjustTransparencyInPlace(gf.fillColor.clone()), gf.rasterWidth, gf.linePixels, gf.fillFlags, gf.material, gf.gradient, false, gradientMapping);\n      }\n      case DisplayParams.Type.Linear:\n        return new DisplayParams(type, lineColor, lineColor, gf.rasterWidth, gf.linePixels);\n      default: // DisplayParams.Type.Text\n        return new DisplayParams(type, lineColor, lineColor, 0, LinePixels.Solid, FillFlags.Always, undefined, undefined, true);\n    }\n  }\n\n  /** Creates a DisplayParams object that describes mesh geometry based on the specified GraphicParams. */\n  public static createForMesh(gf: GraphicParams, resolveGradient?: (grad: Gradient.Symb) => RenderTexture | undefined): DisplayParams {\n    return DisplayParams.createForType(DisplayParams.Type.Mesh, gf, resolveGradient);\n  }\n\n  /** Creates a DisplayParams object that describes linear geometry based on the specified GraphicParams. */\n  public static createForLinear(gf: GraphicParams): DisplayParams {\n    return DisplayParams.createForType(DisplayParams.Type.Linear, gf);\n  }\n\n  /** Creates a DisplayParams object that describes text geometry based on the specified GraphicParams. */\n  public static createForText(gf: GraphicParams): DisplayParams {\n    return DisplayParams.createForType(DisplayParams.Type.Text, gf);\n  }\n\n  public get regionEdgeType(): DisplayParams.RegionEdgeType {\n    if (this.hasBlankingFill)\n      return DisplayParams.RegionEdgeType.None;\n\n    if (this.gradient !== undefined && undefined !== this.gradient.flags) {\n      // Even if the gradient is not outlined, produce an outline to be displayed as the region's edges when fill ViewFlag is off.\n      const gradFlags: Gradient.Flags = this.gradient.flags;\n      if (0 !== (gradFlags & Gradient.Flags.Outline) || FillFlags.None === (this.fillFlags & FillFlags.Always))\n        return DisplayParams.RegionEdgeType.Outline;\n      return DisplayParams.RegionEdgeType.None;\n    }\n    return (!this.fillColor.equals(this.lineColor)) ? DisplayParams.RegionEdgeType.Outline : DisplayParams.RegionEdgeType.Default;\n  }\n\n  public get wantRegionOutline(): boolean {\n    return DisplayParams.RegionEdgeType.Outline === this.regionEdgeType;\n  }\n\n  public get hasBlankingFill(): boolean { return FillFlags.Blanking === (this.fillFlags & FillFlags.Blanking); }\n  public get hasFillTransparency(): boolean { return 255 !== this.fillColor.getAlpha(); }\n  public get hasLineTransparency(): boolean { return 255 !== this.lineColor.getAlpha(); }\n  public get textureMapping(): TextureMapping | undefined { return undefined !== this.material ? this.material.textureMapping : this._textureMapping; }\n  public get isTextured(): boolean { return undefined !== this.textureMapping; }\n\n  /** Determines if the properties of this DisplayParams object are equal to those of another DisplayParams object.  */\n  public equals(rhs: DisplayParams, purpose: DisplayParams.ComparePurpose = DisplayParams.ComparePurpose.Strict): boolean {\n    if (DisplayParams.ComparePurpose.Merge === purpose)\n      return 0 === this.compareForMerge(rhs);\n    else if (rhs === this)\n      return true;\n\n    if (this.type !== rhs.type) return false;\n    if (this.ignoreLighting !== rhs.ignoreLighting) return false;\n    if (this.width !== rhs.width) return false;\n    if (this.linePixels !== rhs.linePixels) return false;\n    if (this.fillFlags !== rhs.fillFlags) return false;\n    if (this.wantRegionOutline !== rhs.wantRegionOutline) return false;\n    if (this.material !== rhs.material) return false;\n    if (this.textureMapping !== rhs.textureMapping) return false;\n\n    if (!this.fillColor.equals(rhs.fillColor)) return false;\n    if (!this.lineColor.equals(rhs.lineColor)) return false;\n    return true;\n  }\n\n  public compareForMerge(rhs: DisplayParams): number {\n    if (rhs === this)\n      return 0;\n\n    let diff = compareNumbers(this.type, rhs.type);\n    if (0 === diff) {\n      diff = compareBooleans(this.ignoreLighting, rhs.ignoreLighting);\n      if (0 === diff) {\n        diff = compareNumbers(this.width, rhs.width);\n        if (0 === diff) {\n          diff = compareNumbers(this.linePixels, rhs.linePixels);\n          if (0 === diff) {\n            diff = compareNumbers(this.fillFlags, rhs.fillFlags);\n            if (0 === diff) {\n              diff = compareBooleans(this.wantRegionOutline, rhs.wantRegionOutline);\n              if (0 === diff) {\n                diff = compareBooleans(this.hasFillTransparency, rhs.hasFillTransparency);\n                if (0 === diff) {\n                  diff = compareBooleans(this.hasLineTransparency, rhs.hasLineTransparency);\n                  if (0 === diff) {\n                    diff = compareMaterials(this.material, rhs.material);\n                    if (0 === diff && undefined === this.material && this.isTextured) {\n                      diff = compareTextureMappings(this.textureMapping, rhs.textureMapping);\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n\n    return diff;\n  }\n\n  /**\n   * Given a ColorDef object, check its transparency and if it falls below the minimum, mark the color as fully opaque.\n   * @return The original reference to the color provided, which has possibly been modified.\n   */\n  public static adjustTransparencyInPlace(color: ColorDef): ColorDef {\n    if (color.colors.t < DisplayParams.minTransparency)\n      color.setTransparency(0);\n    return color;\n  }\n}\n\n/** @internal */\nexport namespace DisplayParams {\n  export enum Type {\n    Mesh,\n    Linear,\n    Text,\n  }\n\n  export enum RegionEdgeType {\n    None,\n    Default,\n    Outline,\n  }\n\n  export enum ComparePurpose {\n    Merge,  // considers colors equivalent if both have or both lack transparency\n    Strict, // compares all members\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { QParams3d, FeatureIndex } from \"@bentley/imodeljs-common\";\nimport { Mesh } from \"./mesh/MeshPrimitives\";\n\n/** @internal */\nexport class PointCloudArgs {\n  public points: Uint16Array;\n  public pointParams: QParams3d;\n  public colors: Uint8Array;\n  public features: FeatureIndex = new FeatureIndex();\n\n  public constructor(points: Uint16Array, pointParams: QParams3d, colors: Uint8Array, features: Mesh.Features) {\n    this.points = points;\n    this.colors = colors;\n    this.pointParams = pointParams;\n    features.toFeatureIndex(this.features);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Rendering */\r\n\r\nimport { IndexedPolyface, Transform } from \"@bentley/geometry-core\";\r\nimport { DisplayParams } from \"./DisplayParams\";\r\n\r\n/** @internal */\r\nexport class PolyfacePrimitive {\r\n  public readonly displayParams: DisplayParams;\r\n  private _polyface: IndexedPolyface;\r\n  public readonly displayEdges: boolean;\r\n  public readonly isPlanar: boolean;\r\n\r\n  public get indexedPolyface() { return this._polyface; }\r\n\r\n  public static create(params: DisplayParams, pf: IndexedPolyface, displayEdges: boolean = true, isPlanar: boolean = false) {\r\n    return new PolyfacePrimitive(params, pf, displayEdges, isPlanar);\r\n  }\r\n\r\n  private constructor(params: DisplayParams, pf: IndexedPolyface, displayEdges: boolean, isPlanar: boolean) {\r\n    this.displayParams = params;\r\n    this._polyface = pf;\r\n    this.displayEdges = displayEdges;\r\n    this.isPlanar = isPlanar;\r\n  }\r\n\r\n  public clone(): PolyfacePrimitive { return new PolyfacePrimitive(this.displayParams, this._polyface.clone(), this.displayEdges, this.isPlanar); }\r\n  public transform(trans: Transform): boolean { return this._polyface.tryTransformInPlace(trans); }\r\n}\r\n\r\n/** @internal */\r\nexport class PolyfacePrimitiveList extends Array<PolyfacePrimitive> { constructor(...args: PolyfacePrimitive[]) { super(...args); } }\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { assert, SortedArray } from \"@bentley/bentleyjs-core\";\nimport { GraphicBuilder } from \"../GraphicBuilder\";\n\n/** @internal */\nexport namespace ToleranceRatio {\n  export const vertex = 0.1;\n  export const facetArea = 0.1;\n}\n\n// tslint:disable:no-const-enum\n\n/** Specifies under what circumstances a GeometryAccumulator should generate normals.\n * @internal\n */\nexport const enum NormalMode {\n  Never,              // Never generate normals\n  Always,             // Always generate normals\n  CurvedSurfacesOnly, // Generate normals only for curved surfaces\n}\n\n/** @internal */\nexport const enum SurfacesOnly { Yes = 1, No = 0 }  // Yes indicates polylines will not be generated, only meshes.\n\n/** @internal */\nexport const enum PreserveOrder { Yes = 1, No = 0 } // Yes indicates primitives will not be merged, and the order in which they were added to the GraphicBuilder will be preserved.\n\n/** @internal */\nexport const enum GenerateEdges { Yes = 1, No = 0 } // Yes indicates edges will be generated for surfaces\n\n/** @internal */\nexport class GeometryOptions {\n  public readonly normals: NormalMode;\n  public readonly surfaces: SurfacesOnly;\n  public readonly preserveOrder: PreserveOrder;\n  public readonly edges: GenerateEdges;\n  constructor(normals: NormalMode = NormalMode.Always, surfaces: SurfacesOnly = SurfacesOnly.No, preserveOrder: PreserveOrder = PreserveOrder.No, edges: GenerateEdges = GenerateEdges.Yes) {\n    this.normals = normals; this.surfaces = surfaces; this.preserveOrder = preserveOrder; this.edges = edges;\n  }\n\n  public get wantSurfacesOnly(): boolean { return this.surfaces === SurfacesOnly.Yes; }\n  public get wantPreserveOrder(): boolean { return this.preserveOrder === PreserveOrder.Yes; }\n  public get wantEdges(): boolean { return this.edges === GenerateEdges.Yes; }\n\n  public static createForGraphicBuilder(params: GraphicBuilder, normals: NormalMode = NormalMode.Always, surfaces: SurfacesOnly = SurfacesOnly.No): GeometryOptions {\n    return new GeometryOptions(normals, surfaces, (params.isOverlay || params.isViewBackground) ? PreserveOrder.Yes : PreserveOrder.No, params.isSceneGraphic ? GenerateEdges.Yes : GenerateEdges.No);\n  }\n}\n\n/** @internal */\nexport class Triangle {\n  public readonly indices = new Uint32Array(3);\n  public readonly visible = [true, true, true];\n  public singleSided: boolean;\n\n  public constructor(singleSided: boolean = true) { this.singleSided = singleSided; }\n\n  public setIndices(a: number, b: number, c: number) {\n    this.indices[0] = a;\n    this.indices[1] = b;\n    this.indices[2] = c;\n  }\n\n  public setEdgeVisibility(a: boolean, b: boolean, c: boolean) {\n    this.visible[0] = a;\n    this.visible[1] = b;\n    this.visible[2] = c;\n  }\n\n  public isEdgeVisible(index: number) {\n    assert(index < 3 && index >= 0);\n    return this.visible[index];\n  }\n\n  public get isDegenerate() { return this.indices[0] === this.indices[1] || this.indices[0] === this.indices[2] || this.indices[1] === this.indices[2]; }\n}\n\n/** @internal */\nexport class TriangleList {\n  private readonly _flags: number[] = [];\n  public readonly indices: number[] = [];\n\n  public get length(): number { return this._flags.length; }\n  public get isEmpty(): boolean { return 0 === this.length; }\n\n  public addTriangle(triangle: Triangle): void {\n    let flags = triangle.singleSided ? 1 : 0;\n    for (let i = 0; i < 3; i++) {\n      if (triangle.isEdgeVisible(i))\n        flags |= (0x0002 << i);\n\n      this.indices.push(triangle.indices[i]);\n    }\n\n    this._flags.push(flags);\n  }\n\n  public getTriangle(index: number, out?: Triangle): Triangle {\n    const triangle = undefined !== out ? out : new Triangle();\n\n    if (index > this.length) {\n      assert(false);\n      return new Triangle();\n    }\n\n    const flags = this._flags[index];\n    triangle.singleSided = 0 !== (flags & 0x0001);\n\n    const baseIndex = index * 3;\n    for (let i = 0; i < 3; i++) {\n      triangle.indices[i] = this.indices[baseIndex + i];\n      triangle.visible[i] = 0 !== (flags & 0x0002 << i);\n    }\n\n    return triangle;\n  }\n}\n\n/** @internal */\nexport class TriangleKey {\n  private readonly _sortedIndices = new Uint32Array(3);\n\n  public constructor(triangle: Triangle) {\n    const index = triangle.indices;\n    const sorted = this._sortedIndices;\n\n    if (index[0] < index[1]) {\n      if (index[0] < index[2]) {\n        sorted[0] = index[0];\n        if (index[1] < index[2]) {\n          sorted[1] = index[1];\n          sorted[2] = index[2];\n        } else {\n          sorted[1] = index[2];\n          sorted[2] = index[1];\n        }\n      } else {\n        sorted[0] = index[2];\n        sorted[1] = index[0];\n        sorted[2] = index[1];\n      }\n    } else {\n      if (index[1] < index[2]) {\n        sorted[0] = index[1];\n        if (index[0] < index[2]) {\n          sorted[1] = index[0];\n          sorted[2] = index[2];\n        } else {\n          sorted[1] = index[2];\n          sorted[2] = index[0];\n        }\n      } else {\n        sorted[0] = index[2];\n        sorted[1] = index[1];\n        sorted[2] = index[0];\n      }\n    }\n\n    assert(sorted[0] < sorted[1]);\n    assert(sorted[1] < sorted[2]);\n  }\n\n  public compare(rhs: TriangleKey): number {\n    let diff = 0;\n    for (let i = 0; i < 3; i++) {\n      diff = this._sortedIndices[i] - rhs._sortedIndices[i];\n      if (0 !== diff)\n        break;\n    }\n\n    return diff;\n  }\n}\n\n/** @internal */\nexport class TriangleSet extends SortedArray<TriangleKey> {\n  public constructor() {\n    super((lhs: TriangleKey, rhs: TriangleKey) => lhs.compare(rhs));\n  }\n  public insertKey(triangle: Triangle, onInsert: (triangleKey: TriangleKey) => any): number {\n    return this.insert(new TriangleKey(triangle), onInsert);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { Point3d, Transform } from \"@bentley/geometry-core\";\nimport { DisplayParams } from \"./DisplayParams\";\n\n/** @internal */\nexport class StrokesPrimitivePointList {\n  public points: Point3d[];\n  constructor(points: Point3d[] = []) { this.points = [...points]; }\n}\n\n/** @internal */\nexport class StrokesPrimitivePointLists extends Array<StrokesPrimitivePointList> { constructor(...args: StrokesPrimitivePointList[]) { super(...args); } }\n\n/** @internal */\nexport class StrokesPrimitive {\n  public readonly displayParams: DisplayParams;\n  public readonly isDisjoint: boolean;\n  public readonly isPlanar: boolean;\n  public strokes: StrokesPrimitivePointLists;\n\n  public static create(params: DisplayParams, isDisjoint: boolean, isPlanar: boolean) {\n    return new StrokesPrimitive(params, isDisjoint, isPlanar);\n  }\n\n  private constructor(params: DisplayParams, isDisjoint: boolean, isPlanar: boolean) {\n    this.displayParams = params;\n    this.strokes = new StrokesPrimitivePointLists();\n    this.isDisjoint = isDisjoint;\n    this.isPlanar = isPlanar;\n  }\n\n  public transform(trans: Transform) {\n    for (const strk of this.strokes) {\n      trans.multiplyPoint3dArrayInPlace(strk.points);\n    }\n  }\n}\n\n/** @internal */\nexport class StrokesPrimitiveList extends Array<StrokesPrimitive> { constructor(...args: StrokesPrimitive[]) { super(...args); } }\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { IndexMap, assert, compareWithTolerance } from \"@bentley/bentleyjs-core\";\nimport { Point2d } from \"@bentley/geometry-core\";\nimport { QPoint3d, OctEncodedNormal } from \"@bentley/imodeljs-common\";\n\n/** @internal */\nexport interface VertexKeyProps {\n  position: QPoint3d;\n  fillColor: number;\n  normal?: OctEncodedNormal;\n  uvParam?: Point2d;\n}\n\n/** @internal */\nexport class VertexKey {\n  public readonly position: QPoint3d;\n  public readonly octEncodedNormal: number = 0;\n  public readonly uvParam?: Point2d;\n  public readonly fillColor: number;\n  public readonly normalValid: boolean = false;\n\n  public constructor(position: QPoint3d, fillColor: number, normal?: OctEncodedNormal, uvParam?: Point2d) {\n    this.position = position.clone();\n    this.fillColor = fillColor;\n\n    if (undefined !== normal) {\n      this.normalValid = true;\n      this.octEncodedNormal = normal.value;\n    }\n\n    if (undefined !== uvParam)\n      this.uvParam = uvParam.clone();\n  }\n\n  public static create(props: VertexKeyProps): VertexKey { return new VertexKey(props.position, props.fillColor, props.normal, props.uvParam); }\n\n  public equals(rhs: VertexKey): boolean {\n    assert(this.normalValid === rhs.normalValid);\n\n    if (!this.position.equals(rhs.position) || this.octEncodedNormal !== rhs.octEncodedNormal || this.fillColor !== rhs.fillColor)\n      return false;\n\n    if (undefined === this.uvParam) {\n      assert(undefined === rhs.uvParam);\n      return true;\n    } else {\n      assert(undefined !== rhs.uvParam);\n      return this.uvParam.isAlmostEqual(rhs.uvParam!, 0.1);\n    }\n  }\n\n  public compare(rhs: VertexKey): number {\n    if (this === rhs)\n      return 0;\n\n    let diff = this.position.compare(rhs.position);\n    if (0 === diff) {\n      diff = this.octEncodedNormal - rhs.octEncodedNormal;\n      if (0 === diff) {\n        diff = this.fillColor - rhs.fillColor;\n        if (0 === diff && undefined !== this.uvParam) {\n          assert(undefined !== rhs.uvParam);\n          diff = compareWithTolerance(this.uvParam.x, rhs.uvParam!.x);\n          if (0 === diff) {\n            diff = compareWithTolerance(this.uvParam.x, rhs.uvParam!.y);\n          }\n        }\n      }\n    }\n\n    return diff;\n  }\n}\n\n/** @internal */\nexport class VertexMap extends IndexMap<VertexKey> {\n  public constructor() { super((lhs, rhs) => lhs.compare(rhs)); }\n\n  public insertKey(props: VertexKeyProps, onInsert?: (vk: VertexKey) => any): number {\n    return this.insert(VertexKey.create(props), onInsert);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { Range2d, Point2d, Point3d, Vector3d } from \"@bentley/geometry-core\";\nimport {\n  ColorDef,\n  ColorIndex,\n  FeatureIndex,\n  QPoint2d,\n  QPoint3dList,\n  QParams2d,\n  QParams3d,\n  FeatureIndexType,\n  FillFlags,\n  RenderTexture,\n  RenderMaterial,\n  LinePixels,\n  OctEncodedNormalPair,\n  PolylineData,\n  PolylineTypeFlags,\n  MeshEdge,\n} from \"@bentley/imodeljs-common\";\nimport { AuxChannelTable } from \"./AuxChannelTable\";\nimport { PolylineArgs, MeshArgs } from \"./mesh/MeshPrimitives\";\nimport { IModelApp } from \"../../IModelApp\";\n\n// tslint:disable:no-const-enum\n\n/**\n * Holds an array of indices into a VertexTable. Each index is a 24-bit unsigned integer.\n * The order of the indices specifies the order in which vertices are drawn.\n * @internal\n */\nexport class VertexIndices {\n  public readonly data: Uint8Array;\n\n  /**\n   * Directly construct from an array of bytes in which each index occupies 3 contiguous bytes.\n   * The length of the array must be a multiple of 3. This object takes ownership of the array.\n   */\n  public constructor(data: Uint8Array) {\n    this.data = data;\n    assert(0 === this.data.length % 3);\n  }\n\n  /** Get the number of 24-bit indices. */\n  public get length(): number { return this.data.length / 3; }\n\n  /** Convert an array of 24-bit unsigned integer values into a VertexIndices object. */\n  public static fromArray(indices: number[]): VertexIndices {\n    const bytes = new Uint8Array(indices.length * 3);\n    for (let i = 0; i < indices.length; i++)\n      this.encodeIndex(indices[i], bytes, i * 3);\n\n    return new VertexIndices(bytes);\n  }\n\n  public static encodeIndex(index: number, bytes: Uint8Array, byteIndex: number): void {\n    assert(byteIndex + 2 < bytes.length);\n    bytes[byteIndex + 0] = index & 0x000000ff;\n    bytes[byteIndex + 1] = (index & 0x0000ff00) >> 8;\n    bytes[byteIndex + 2] = (index & 0x00ff0000) >> 16;\n  }\n}\n\ninterface Dimensions {\n  width: number;\n  height: number;\n}\n\nfunction computeDimensions(nEntries: number, nRgbaPerEntry: number, nExtraRgba: number): Dimensions {\n  const maxSize = IModelApp.renderSystem.maxTextureSize;\n  const nRgba = nEntries * nRgbaPerEntry + nExtraRgba;\n\n  if (nRgba < maxSize)\n    return { width: nRgba, height: 1 };\n\n  // Make roughly square to reduce unused space in last row\n  let width = Math.ceil(Math.sqrt(nRgba));\n\n  // Ensure a given entry's RGBA values all fit on the same row.\n  const remainder = width % nRgbaPerEntry;\n  if (0 !== remainder) {\n    width += nRgbaPerEntry - remainder;\n  }\n\n  // Compute height\n  const height = Math.ceil(nRgba / width);\n\n  assert(height <= maxSize);\n  assert(width <= maxSize);\n  assert(width * height >= nRgba);\n  assert(Math.floor(height) === height);\n  assert(Math.floor(width) === width);\n\n  // Row padding should never be necessary...\n  assert(0 === width % nRgbaPerEntry);\n\n  return { width, height };\n}\n\nconst scratchColorDef = new ColorDef();\n\n/** Describes a VertexTable.\n * @internal\n */\nexport interface VertexTableProps {\n  /** The rectangular array of vertex data, of size width*height*numRgbaPerVertex bytes. */\n  readonly data: Uint8Array;\n  /** Quantization parameters for the vertex positions encoded into the array. */\n  readonly qparams: QParams3d;\n  /** The number of 4-byte 'RGBA' values in each row of the array. Must be divisible by numRgbaPerVertex. */\n  readonly width: number;\n  /** The number of rows in the array. */\n  readonly height: number;\n  /** Whether or not the vertex colors contain translucent colors. */\n  readonly hasTranslucency: boolean;\n  /** If no color table exists, the color to use for all vertices. */\n  readonly uniformColor?: ColorDef;\n  /** Describes the number of features (none, one, or multiple) contained. */\n  readonly featureIndexType: FeatureIndexType;\n  /** If featureIndexType is 'Uniform', the feature ID associated with all vertices. */\n  readonly uniformFeatureID?: number;\n  /** The number of vertices in the table. Must be less than (width*height)/numRgbaPerVertex. */\n  readonly numVertices: number;\n  /** The number of 4-byte 'RGBA' values associated with each vertex. */\n  readonly numRgbaPerVertex: number;\n  /** If vertex data include texture UV coordinates, the quantization params for those coordinates. */\n  readonly uvParams?: QParams2d;\n}\n\n/**\n * Represents vertex data (position, color, normal, UV params, etc) in a rectangular array.\n * Each vertex is described by one or more contiguous 4-byte ('RGBA') values.\n * This allows vertex data to be uploaded to the GPU as a texture and vertex data to be sampled\n * from that texture using a single vertex ID representing an index into the array.\n * Vertex color is identified by a 16-bit index into a color table appended to the vertex data.\n * @internal\n */\nexport class VertexTable implements VertexTableProps {\n  /** The rectangular array of vertex data, of size width*height*numRgbaPerVertex bytes. */\n  public readonly data: Uint8Array;\n  /** Quantization parameters for the vertex positions encoded into the array. */\n  public readonly qparams: QParams3d;\n  /** The number of 4-byte 'RGBA' values in each row of the array. Must be divisible by numRgbaPerVertex. */\n  public readonly width: number;\n  /** The number of rows in the array. */\n  public readonly height: number;\n  /** Whether or not the vertex colors contain translucent colors. */\n  public readonly hasTranslucency: boolean;\n  /** If no color table exists, the color to use for all vertices. */\n  public readonly uniformColor?: ColorDef;\n  /** Describes the number of features (none, one, or multiple) contained. */\n  public readonly featureIndexType: FeatureIndexType;\n  /** If featureIndexType is 'Uniform', the feature ID associated with all vertices. */\n  public readonly uniformFeatureID?: number;\n  /** The number of vertices in the table. Must be less than (width*height)/numRgbaPerVertex. */\n  public readonly numVertices: number;\n  /** The number of 4-byte 'RGBA' values associated with each vertex. */\n  public readonly numRgbaPerVertex: number;\n  /** If vertex data include texture UV coordinates, the quantization params for those coordinates. */\n  public readonly uvParams?: QParams2d;\n\n  /** Construct a VertexTable. The VertexTable takes ownership of all input data - it must not be later modified by the caller. */\n  public constructor(props: VertexTableProps) {\n    this.data = props.data;\n    this.qparams = props.qparams;\n    this.width = props.width;\n    this.height = props.height;\n    this.hasTranslucency = true === props.hasTranslucency;\n    this.uniformColor = props.uniformColor;\n    this.featureIndexType = props.featureIndexType;\n    this.uniformFeatureID = props.uniformFeatureID;\n    this.numVertices = props.numVertices;\n    this.numRgbaPerVertex = props.numRgbaPerVertex;\n    this.uvParams = props.uvParams;\n  }\n\n  public static buildFrom(builder: VertexTableBuilder, colorIndex: ColorIndex, featureIndex: FeatureIndex): VertexTable {\n    const { numVertices, numRgbaPerVertex } = builder;\n    const numColors = colorIndex.isUniform ? 0 : colorIndex.numColors;\n    const dimensions = computeDimensions(numVertices, numRgbaPerVertex, numColors);\n    assert(0 === dimensions.width % numRgbaPerVertex || (0 < numColors && 1 === dimensions.height));\n\n    const data = new Uint8Array(dimensions.width * dimensions.height * 4);\n\n    builder.data = data;\n    for (let i = 0; i < numVertices; i++)\n      builder.appendVertex(i);\n\n    builder.appendColorTable(colorIndex);\n\n    builder.data = undefined;\n\n    return new VertexTable({\n      data,\n      qparams: builder.qparams,\n      width: dimensions.width,\n      height: dimensions.height,\n      hasTranslucency: colorIndex.hasAlpha,\n      uniformColor: colorIndex.uniform,\n      numVertices,\n      numRgbaPerVertex,\n      uvParams: builder.uvParams,\n      featureIndexType: featureIndex.type,\n      uniformFeatureID: featureIndex.type === FeatureIndexType.Uniform ? featureIndex.featureID : undefined,\n    });\n  }\n\n  public static createForPolylines(args: PolylineArgs): VertexTable | undefined {\n    const polylines = args.polylines;\n    if (0 < polylines.length)\n      return this.buildFrom(new SimpleBuilder(args), args.colors, args.features);\n    else\n      return undefined;\n  }\n}\n\n/** Describes point string geometry to be submitted to the rendering system.\n * @internal\n */\nexport class PointStringParams {\n  public readonly vertices: VertexTable;\n  public readonly indices: VertexIndices;\n  public readonly weight: number;\n\n  public constructor(vertices: VertexTable, indices: VertexIndices, weight: number) {\n    this.vertices = vertices;\n    this.indices = indices;\n    this.weight = weight;\n  }\n\n  public static create(args: PolylineArgs): PointStringParams | undefined {\n    if (!args.flags.isDisjoint)\n      return undefined;\n\n    const vertices = VertexTable.createForPolylines(args);\n    if (undefined === vertices)\n      return undefined;\n\n    const polylines = args.polylines;\n    let vertIndices = polylines[0].vertIndices;\n    if (1 < polylines.length) {\n      // We used to assert this wouldn't happen - apparently it does...\n      vertIndices = [];\n      for (const polyline of polylines)\n        for (const vertIndex of polyline.vertIndices)\n          vertIndices.push(vertIndex);\n    }\n\n    const vertexIndices = VertexIndices.fromArray(vertIndices);\n    assert(vertexIndices.length === vertIndices.length);\n\n    return new PointStringParams(vertices, vertexIndices, args.width);\n  }\n}\n\n/** Parameter associated with each vertex index of a tesselated polyline. */\nconst enum PolylineParam {\n  kNone = 0,\n  kSquare = 1 * 3,\n  kMiter = 2 * 3,\n  kMiterInsideOnly = 3 * 3,\n  kJointBase = 4 * 3,\n  kNegatePerp = 8 * 3,\n  kNegateAlong = 16 * 3,\n  kNoneAdjustWeight = 32 * 3,\n}\n\n/**\n * Represents a tesselated polyline.\n * Given a polyline as a line string, each segment of the line string is triangulated into a quad.\n * Based on the angle between two segments, additional joint triangles may be inserted in between to enable smoothly-rounded corners.\n * @internal\n */\nexport interface TesselatedPolyline {\n  /** 24-bit index of each vertex. */\n  readonly indices: VertexIndices;\n  /** 24-bit index of the previous vertex in the polyline. */\n  readonly prevIndices: VertexIndices;\n  /** 24-bit index of the next vertex in the polyline, plus 8-bit parameter describing the semantics of this vertex. */\n  readonly nextIndicesAndParams: Uint8Array;\n}\n\nclass PolylineVertex {\n  public isSegmentStart: boolean = false;\n  public isPolylineStartOrEnd: boolean = false;\n  public vertexIndex: number = 0;\n  public prevIndex: number = 0;\n  public nextIndex: number = 0;\n\n  public constructor() { }\n\n  public init(isSegmentStart: boolean, isPolylineStartOrEnd: boolean, vertexIndex: number, prevIndex: number, nextIndex: number) {\n    this.isSegmentStart = isSegmentStart;\n    this.isPolylineStartOrEnd = isPolylineStartOrEnd;\n    this.vertexIndex = vertexIndex;\n    this.prevIndex = prevIndex;\n    this.nextIndex = nextIndex;\n  }\n\n  public computeParam(negatePerp: boolean, adjacentToJoint: boolean = false, joint: boolean = false, noDisplacement: boolean = false): number {\n    if (joint)\n      return PolylineParam.kJointBase;\n\n    let param: PolylineParam = PolylineParam.kNone;\n    if (noDisplacement)\n      param = PolylineParam.kNoneAdjustWeight; // prevent getting tossed before width adjustment\n    else if (adjacentToJoint)\n      param = PolylineParam.kMiterInsideOnly;\n    else\n      param = this.isPolylineStartOrEnd ? PolylineParam.kSquare : PolylineParam.kMiter;\n\n    let adjust = 0;\n    if (negatePerp)\n      adjust = PolylineParam.kNegatePerp;\n    if (!this.isSegmentStart)\n      adjust += PolylineParam.kNegateAlong;\n\n    return param + adjust;\n  }\n}\n\nclass PolylineTesselator {\n  private _polylines: PolylineData[];\n  private _points: QPoint3dList;\n  private _doJoints: boolean;\n  private _numIndices = 0;\n  private _vertIndex: number[] = [];\n  private _prevIndex: number[] = [];\n  private _nextIndex: number[] = [];\n  private _nextParam: number[] = [];\n  private _position: Point3d[] = [];\n\n  private constructor(polylines: PolylineData[], points: QPoint3dList, doJointTriangles: boolean) {\n    this._polylines = polylines;\n    this._points = points;\n    this._doJoints = doJointTriangles;\n  }\n\n  public static fromPolyline(args: PolylineArgs): PolylineTesselator {\n    return new PolylineTesselator(args.polylines, args.points, wantJointTriangles(args.width, args.flags.is2d));\n  }\n\n  public static fromMesh(args: MeshArgs): PolylineTesselator | undefined {\n    if (undefined !== args.edges.polylines.lines && undefined !== args.points)\n      return new PolylineTesselator(args.edges.polylines.lines, args.points, wantJointTriangles(args.edges.width, args.is2d));\n\n    return undefined;\n  }\n\n  public tesselate(): TesselatedPolyline {\n    for (const p of this._points.list)\n      this._position.push(p.unquantize(this._points.params));\n\n    this._tesselate();\n\n    const vertIndex = VertexIndices.fromArray(this._vertIndex);\n    const prevIndex = VertexIndices.fromArray(this._prevIndex);\n\n    const nextIndexAndParam = new Uint8Array(this._numIndices * 4);\n    for (let i = 0; i < this._numIndices; i++) {\n      const index = this._nextIndex[i];\n      const j = i * 4;\n      VertexIndices.encodeIndex(index, nextIndexAndParam, j);\n      nextIndexAndParam[j + 3] = this._nextParam[i] & 0x000000ff;\n    }\n\n    return {\n      indices: vertIndex,\n      prevIndices: prevIndex,\n      nextIndicesAndParams: nextIndexAndParam,\n    };\n  }\n\n  private _tesselate() {\n    const v0 = new PolylineVertex(), v1 = new PolylineVertex();\n    const maxJointDot = -0.7;\n\n    for (const line of this._polylines) {\n      if (line.numIndices < 2)\n        continue;\n\n      const last = line.numIndices - 1;\n      const isClosed: boolean = line.vertIndices[0] === line.vertIndices[last];\n\n      for (let i = 0; i < last; ++i) {\n        const idx0 = line.vertIndices[i];\n        const idx1 = line.vertIndices[i + 1];\n        const isStart: boolean = (0 === i);\n        const isEnd: boolean = (last - 1 === i);\n        const prevIdx0 = isStart ? (isClosed ? line.vertIndices[last - 1] : idx0) : line.vertIndices[i - 1];\n        const nextIdx1 = isEnd ? (isClosed ? line.vertIndices[1] : idx1) : line.vertIndices[i + 2];\n\n        v0.init(true, isStart && !isClosed, idx0, prevIdx0, idx1);\n        v1.init(false, isEnd && !isClosed, idx1, nextIdx1, idx0);\n\n        const jointAt0: boolean = this._doJoints && (isClosed || !isStart) && this._dotProduct(v0) > maxJointDot;\n        const jointAt1: boolean = this._doJoints && (isClosed || !isEnd) && this._dotProduct(v1) > maxJointDot;\n\n        if (jointAt0 || jointAt1) {\n          this._addVertex(v0, v0.computeParam(true, jointAt0, false, false));\n          this._addVertex(v1, v1.computeParam(false, jointAt1, false, false));\n          this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));\n          this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));\n          this._addVertex(v1, v1.computeParam(false, jointAt1, false, false));\n          this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));\n          this._addVertex(v0, v0.computeParam(false, jointAt0, false, true));\n          this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));\n          this._addVertex(v0, v0.computeParam(false, jointAt0, false, false));\n          this._addVertex(v0, v0.computeParam(false, jointAt0, false, false));\n          this._addVertex(v1, v1.computeParam(false, jointAt1, false, true));\n          this._addVertex(v1, v1.computeParam(true, jointAt1, false, false));\n        } else {\n          this._addVertex(v0, v0.computeParam(true));\n          this._addVertex(v1, v1.computeParam(false));\n          this._addVertex(v0, v0.computeParam(false));\n          this._addVertex(v0, v0.computeParam(false));\n          this._addVertex(v1, v1.computeParam(false));\n          this._addVertex(v1, v1.computeParam(true));\n        }\n      }\n    }\n  }\n\n  private _dotProduct(v: PolylineVertex): number {\n    const pos: Point3d = this._position[v.vertexIndex];\n    const prevDir: Vector3d = Vector3d.createStartEnd(this._position[v.prevIndex], pos);\n    const nextDir: Vector3d = Vector3d.createStartEnd(this._position[v.nextIndex], pos);\n    return prevDir.dotProduct(nextDir);\n  }\n\n  private _addVertex(vertex: PolylineVertex, param: number): void {\n    this._vertIndex[this._numIndices] = vertex.vertexIndex;\n    this._prevIndex[this._numIndices] = vertex.prevIndex;\n    this._nextIndex[this._numIndices] = vertex.nextIndex;\n    this._nextParam[this._numIndices] = param;\n    this._numIndices++;\n  }\n}\n\n/** @internal */\nexport const enum SurfaceType {\n  Unlit,\n  Lit,\n  Textured,\n  TexturedLit,\n  VolumeClassifier,\n}\n\n/** @internal */\nexport function isValidSurfaceType(value: number): boolean {\n  switch (value) {\n    case SurfaceType.Unlit:\n    case SurfaceType.Lit:\n    case SurfaceType.Textured:\n    case SurfaceType.TexturedLit:\n    case SurfaceType.VolumeClassifier:\n      return true;\n    default:\n      return false;\n  }\n}\n\n/** @internal */\nexport interface SurfaceParams {\n  readonly type: SurfaceType;\n  readonly indices: VertexIndices;\n  readonly fillFlags: FillFlags;\n  readonly hasBakedLighting: boolean;\n  readonly texture?: RenderTexture;\n  readonly material?: RenderMaterial;\n}\n\n/**\n * Describes a set of line segments representing edges of a mesh.\n * Each segment is expanded into a quad defined by two triangles.\n * The positions are adjusted in the shader to account for the edge width.\n * @internal\n */\nexport interface SegmentEdgeParams {\n  /** The 24-bit indices of the tesselated line segment */\n  readonly indices: VertexIndices;\n  /**\n   * For each 24-bit index, 4 bytes:\n   * the 24-bit index of the vertex at the other end of the segment, followed by\n   * an 8-bit 'quad index' in [0..3] indicating which point in the expanded quad the vertex represents.\n   */\n  readonly endPointAndQuadIndices: Uint8Array;\n}\n\nfunction convertPolylinesAndEdges(polylines?: PolylineData[], edges?: MeshEdge[]): SegmentEdgeParams | undefined {\n  let numIndices = undefined !== edges ? edges.length : 0;\n  if (undefined !== polylines)\n    for (const pd of polylines)\n      numIndices += (pd.vertIndices.length - 1);\n\n  if (0 === numIndices)\n    return undefined;\n\n  numIndices *= 6;\n  const indexBytes = new Uint8Array(numIndices * 3);\n  const endPointAndQuadIndexBytes = new Uint8Array(numIndices * 4);\n\n  let ndx: number = 0;\n  let ndx2: number = 0;\n\n  const addPoint = (p0: number, p1: number, quadIndex: number) => {\n    VertexIndices.encodeIndex(p0, indexBytes, ndx);\n    ndx += 3;\n    VertexIndices.encodeIndex(p1, endPointAndQuadIndexBytes, ndx2);\n    endPointAndQuadIndexBytes[ndx2 + 3] = quadIndex;\n    ndx2 += 4;\n  };\n\n  if (undefined !== polylines) {\n    for (const pd of polylines) {\n      const num = pd.vertIndices.length - 1;\n      for (let i = 0; i < num; ++i) {\n        let p0 = pd.vertIndices[i];\n        let p1 = pd.vertIndices[i + 1];\n        if (p1 < p0) { // swap so that lower index is first.\n          p0 = p1;\n          p1 = pd.vertIndices[i];\n        }\n        addPoint(p0, p1, 0);\n        addPoint(p1, p0, 2);\n        addPoint(p0, p1, 1);\n        addPoint(p0, p1, 1);\n        addPoint(p1, p0, 2);\n        addPoint(p1, p0, 3);\n      }\n    }\n  }\n\n  if (undefined !== edges) {\n    for (const meshEdge of edges) {\n      const p0 = meshEdge.indices[0];\n      const p1 = meshEdge.indices[1];\n      addPoint(p0, p1, 0);\n      addPoint(p1, p0, 2);\n      addPoint(p0, p1, 1);\n      addPoint(p0, p1, 1);\n      addPoint(p1, p0, 2);\n      addPoint(p1, p0, 3);\n    }\n  }\n\n  return {\n    indices: new VertexIndices(indexBytes),\n    endPointAndQuadIndices: endPointAndQuadIndexBytes,\n  };\n}\n\n/**\n * A set of line segments representing edges of curved portions of a mesh.\n * Each vertex is augmented with a pair of oct-encoded normals used in the shader\n * to determine whether or not the edge should be displayed.\n * @internal\n */\nexport interface SilhouetteParams extends SegmentEdgeParams {\n  /** Per index, 2 16-bit oct-encoded normals */\n  readonly normalPairs: Uint8Array;\n}\n\nfunction convertSilhouettes(edges: MeshEdge[], normalPairs: OctEncodedNormalPair[]): SilhouetteParams | undefined {\n  const base = convertPolylinesAndEdges(undefined, edges);\n  if (undefined === base)\n    return undefined;\n\n  const normalPairBytes = new Uint8Array(normalPairs.length * 6 * 4);\n  const normalPair16 = new Uint16Array(normalPairBytes.buffer);\n\n  let ndx = 0;\n  for (const pair of normalPairs) {\n    for (let i = 0; i < 6; i++) {\n      normalPair16[ndx++] = pair.first.value;\n      normalPair16[ndx++] = pair.second.value;\n    }\n  }\n\n  return {\n    indices: base.indices,\n    endPointAndQuadIndices: base.endPointAndQuadIndices,\n    normalPairs: normalPairBytes,\n  };\n}\n\n/** Describes the edges of a mesh. */\nexport interface EdgeParams {\n  /** The edge width in pixels. */\n  readonly weight: number;\n  /** The line pattern in which edges are drawn. */\n  readonly linePixels: LinePixels;\n  /** Simple single-segment edges, always displayed when edge display is enabled. */\n  readonly segments?: SegmentEdgeParams;\n  /** Single-segment edges of curved surfaces, displayed based on edge normal relative to eye. */\n  readonly silhouettes?: SilhouetteParams;\n  /** Polyline edges, always displayed when edge display is enabled. */\n  readonly polylines?: TesselatedPolyline;\n}\n\nfunction wantJointTriangles(weight: number, is2d: boolean): boolean {\n  // Joints are incredibly expensive. In 3d, only generate them if the line is sufficiently wide for them to be noticeable.\n  const jointWidthThreshold = 5;\n  return is2d || weight > jointWidthThreshold;\n}\n\nfunction convertEdges(meshArgs: MeshArgs): EdgeParams | undefined {\n  const args = meshArgs.edges;\n  if (undefined === args)\n    return undefined;\n\n  let polylines: TesselatedPolyline | undefined;\n  let segments: SegmentEdgeParams | undefined;\n  if (wantJointTriangles(args.width, meshArgs.is2d)) {\n    segments = convertPolylinesAndEdges(args.polylines.lines, args.edges.edges);\n  } else {\n    segments = convertPolylinesAndEdges(undefined, args.edges.edges);\n    const tesselator = PolylineTesselator.fromMesh(meshArgs);\n    if (undefined !== tesselator)\n      polylines = tesselator.tesselate();\n  }\n\n  // ###TODO: why the heck are the edges and normals of SilhouetteEdgeArgs potentially undefined???\n  const silhouettes = undefined !== args.silhouettes.edges && undefined !== args.silhouettes.normals ? convertSilhouettes(args.silhouettes.edges, args.silhouettes.normals) : undefined;\n  if (undefined === segments && undefined === silhouettes && undefined === polylines)\n    return undefined;\n\n  return {\n    weight: args.width,\n    linePixels: args.linePixels,\n    segments,\n    silhouettes,\n    polylines,\n  };\n}\n\n/**\n * Describes mesh geometry to be submitted to the rendering system.\n * A mesh consists of a surface and its edges, which may include any combination of silhouettes, polylines, and single segments.\n * The surface and edges all refer to the same vertex table.\n */\nexport class MeshParams {\n  public readonly vertices: VertexTable;\n  public readonly surface: SurfaceParams;\n  public readonly edges?: EdgeParams;\n  public readonly isPlanar: boolean;\n  public readonly auxChannels?: AuxChannelTable;\n\n  /** Directly construct a MeshParams. The MeshParams takes ownership of all input data. */\n  public constructor(vertices: VertexTable, surface: SurfaceParams, edges?: EdgeParams, isPlanar?: boolean, auxChannels?: AuxChannelTable) {\n    this.vertices = vertices;\n    this.surface = surface;\n    this.edges = edges;\n    this.isPlanar = !!isPlanar;\n    this.auxChannels = auxChannels;\n  }\n\n  /** Construct from a MeshArgs. */\n  public static create(args: MeshArgs): MeshParams {\n    const builder = MeshBuilder.create(args);\n    const vertices = VertexTable.buildFrom(builder, args.colors, args.features);\n\n    const surfaceIndices = VertexIndices.fromArray(args.vertIndices!);\n    const surface: SurfaceParams = {\n      type: builder.type,\n      indices: surfaceIndices,\n      fillFlags: args.fillFlags,\n      hasBakedLighting: args.hasBakedLighting,\n      texture: args.texture,\n      material: args.material,\n    };\n\n    const edges = convertEdges(args);\n    return new MeshParams(vertices, surface, edges, args.isPlanar);\n  }\n}\n\n/**\n * Describes a set of tesselated polylines.\n * Each segment of each polyline is triangulated into a quad. Additional triangles may be inserted\n * between segments to enable rounded corners.\n */\nexport class PolylineParams {\n  public readonly vertices: VertexTable;\n  public readonly polyline: TesselatedPolyline;\n  public readonly isPlanar: boolean;\n  public readonly type: PolylineTypeFlags;\n  public readonly weight: number;\n  public readonly linePixels: LinePixels;\n\n  /** Directly construct a PolylineParams. The PolylineParams takes ownership of all input data. */\n  public constructor(vertices: VertexTable, polyline: TesselatedPolyline, weight: number, linePixels: LinePixels, isPlanar: boolean, type: PolylineTypeFlags = PolylineTypeFlags.Normal) {\n    this.vertices = vertices;\n    this.polyline = polyline;\n    this.isPlanar = isPlanar;\n    this.weight = weight;\n    this.linePixels = linePixels;\n    this.type = type;\n  }\n\n  /** Construct from an PolylineArgs. */\n  public static create(args: PolylineArgs): PolylineParams | undefined {\n    assert(!args.flags.isDisjoint);\n    const vertices = VertexTable.createForPolylines(args);\n    if (undefined === vertices)\n      return undefined;\n\n    const tesselator = PolylineTesselator.fromPolyline(args);\n    if (undefined === tesselator)\n      return undefined;\n\n    return new PolylineParams(vertices, tesselator.tesselate(), args.width, args.linePixels, args.flags.isPlanar, args.flags.type);\n  }\n}\n\n/** Builds a VertexTable from some data type supplying the vertex data. */\nexport abstract class VertexTableBuilder {\n  public data?: Uint8Array;\n  private _curIndex: number = 0;\n\n  public abstract get numVertices(): number;\n  public abstract get numRgbaPerVertex(): number;\n  public abstract get qparams(): QParams3d;\n  public get uvParams(): QParams2d | undefined { return undefined; }\n  public abstract appendVertex(vertIndex: number): void;\n\n  public appendColorTable(colorIndex: ColorIndex) {\n    if (undefined !== colorIndex.nonUniform) {\n      for (const color of colorIndex.nonUniform.colors) {\n        this.appendColor(color);\n      }\n    }\n  }\n\n  protected advance(nBytes: number) {\n    this._curIndex += nBytes;\n    assert(this._curIndex <= this.data!.length);\n  }\n\n  protected append8(val: number) {\n    assert(0 <= val);\n    assert(val <= 0xff);\n    assert(val === Math.floor(val));\n\n    this.data![this._curIndex] = val;\n    this.advance(1);\n  }\n  protected append16(val: number) {\n    this.append8(val & 0x00ff);\n    this.append8(val >>> 8);\n  }\n  protected append32(val: number) {\n    this.append16(val & 0x0000ffff);\n    this.append16(val >>> 16);\n  }\n\n  private appendColor(tbgr: number) {\n    const colorDef = scratchColorDef;\n    colorDef.tbgr = tbgr;\n    const colors = colorDef.colors;\n\n    // invert transparency => alpha\n    colors.t = 255 - colors.t;\n\n    // premultiply alpha...\n    switch (colors.t) {\n      case 0:\n        colors.r = colors.g = colors.b = 0;\n        break;\n      case 255:\n        break;\n      default: {\n        const f = colors.t / 255.0;\n        colors.r = Math.floor(colors.r * f + 0.5);\n        colors.g = Math.floor(colors.g * f + 0.5);\n        colors.b = Math.floor(colors.b * f + 0.5);\n        break;\n      }\n    }\n\n    // Store 32-bit value in little-endian order (red first)\n    this.append8(colors.r);\n    this.append8(colors.g);\n    this.append8(colors.b);\n    this.append8(colors.t);\n  }\n}\n\ntype SimpleVertexData = PolylineArgs | MeshArgs;\n\n/**\n * Supplies vertex data from a PolylineArgs or MeshArgs. Each vertex consists of 12 bytes:\n *  pos.x           00\n *  pos.y           02\n *  pos.z           04\n *  colorIndex      06\n *  featureIndex    08\n */\nclass SimpleBuilder<T extends SimpleVertexData> extends VertexTableBuilder {\n  public args: T;\n\n  public constructor(args: T) {\n    super();\n    this.args = args;\n    assert(undefined !== this.args.points);\n  }\n\n  public get numVertices() { return this.args.points!.length; }\n  public get numRgbaPerVertex() { return 3; }\n  public get qparams() { return this.args.points!.params; }\n\n  public appendVertex(vertIndex: number): void {\n    this.appendPosition(vertIndex);\n    this.appendColorIndex(vertIndex);\n    this.appendFeatureIndex(vertIndex);\n  }\n\n  protected appendPosition(vertIndex: number) {\n    const points = this.args.points!;\n    this.append16(points.list[vertIndex].x);\n    this.append16(points.list[vertIndex].y);\n    this.append16(points.list[vertIndex].z);\n  }\n\n  protected appendColorIndex(vertIndex: number) {\n    if (undefined !== this.args.colors.nonUniform) {\n      this.append16(this.args.colors.nonUniform.indices[vertIndex]);\n    } else {\n      this.advance(2);\n    }\n  }\n\n  protected appendFeatureIndex(vertIndex: number) {\n    if (undefined !== this.args.features.featureIDs) {\n      this.append32(this.args.features.featureIDs[vertIndex]);\n    } else {\n      this.advance(4);\n    }\n  }\n}\n\n/** Supplies vertex data from a MeshArgs. */\nclass MeshBuilder extends SimpleBuilder<MeshArgs> {\n  public readonly type: SurfaceType;\n\n  protected constructor(args: MeshArgs, type: SurfaceType) {\n    super(args);\n    this.type = type;\n  }\n\n  public static create(args: MeshArgs): MeshBuilder {\n    if (args.isVolumeClassifier)\n      return new MeshBuilder(args, SurfaceType.VolumeClassifier);\n\n    const isLit = undefined !== args.normals && 0 < args.normals.length;\n    const isTextured = undefined !== args.texture;\n\n    let uvParams: QParams2d | undefined;\n\n    if (isTextured) {\n      const uvRange = Range2d.createNull();\n      const fpts = args.textureUv;\n      const pt2d = new Point2d();\n      if (undefined !== fpts && fpts.length > 0)\n        for (let i = 0; i < args.points!.length; i++)\n          uvRange.extendPoint(Point2d.create(fpts[i].x, fpts[i].y, pt2d));\n\n      uvParams = QParams2d.fromRange(uvRange);\n    }\n\n    if (isLit)\n      return isTextured ? new TexturedLitMeshBuilder(args, uvParams!) : new LitMeshBuilder(args);\n    else\n      return isTextured ? new TexturedMeshBuilder(args, uvParams!) : new MeshBuilder(args, SurfaceType.Unlit);\n  }\n}\n\n/** Supplies vertex data from a MeshArgs where each vertex consists of 16 bytes.\n * In addition to the SimpleBuilder data, the final 4 bytes hold the quantized UV params\n * The color index is left uninitialized as it is unused.\n */\nclass TexturedMeshBuilder extends MeshBuilder {\n  private _qparams: QParams2d;\n  private _qpoint = new QPoint2d();\n\n  public constructor(args: MeshArgs, qparams: QParams2d, type: SurfaceType = SurfaceType.Textured) {\n    super(args, type);\n    this._qparams = qparams;\n    assert(undefined !== args.textureUv);\n  }\n\n  public get numRgbaPerVertex() { return 4; }\n  public get uvParams() { return this._qparams; }\n\n  public appendVertex(vertIndex: number) {\n    this.appendPosition(vertIndex);\n    this.appendNormal(vertIndex);\n    this.appendFeatureIndex(vertIndex);\n    this.appendUVParams(vertIndex);\n  }\n\n  protected appendNormal(_vertIndex: number): void { this.advance(2); } // no normal for unlit meshes\n\n  protected appendUVParams(vertIndex: number) {\n    this._qpoint.init(this.args.textureUv![vertIndex], this._qparams);\n    this.append16(this._qpoint.x);\n    this.append16(this._qpoint.y);\n  }\n}\n\n/** As with TexturedMeshBuilder, but the color index is replaced with the oct-encoded normal value. */\nclass TexturedLitMeshBuilder extends TexturedMeshBuilder {\n  public constructor(args: MeshArgs, qparams: QParams2d) {\n    super(args, qparams, SurfaceType.TexturedLit);\n    assert(undefined !== args.normals);\n  }\n\n  protected appendNormal(vertIndex: number) { this.append16(this.args.normals![vertIndex].value); }\n}\n\n/** 16 bytes. The last 2 bytes are unused; the 2 immediately preceding it hold the oct-encoded normal value. */\nclass LitMeshBuilder extends MeshBuilder {\n  public constructor(args: MeshArgs) {\n    super(args, SurfaceType.Lit);\n    assert(undefined !== args.normals);\n  }\n\n  public get numRgbaPerVertex() { return 4; }\n\n  public appendVertex(vertIndex: number) {\n    super.appendVertex(vertIndex);\n    this.append16(this.args.normals![vertIndex].value);\n    this.advance(2); // 2 unused bytes\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { Transform, Range3d, Loop, Path, IndexedPolyface, Point3d } from \"@bentley/geometry-core\";\nimport { IModelConnection } from \"../../../IModelConnection\";\nimport { GeometryOptions } from \"../Primitives\";\nimport { RenderSystem, RenderGraphic, GraphicBranch } from \"../../System\";\nimport { DisplayParams } from \"../DisplayParams\";\nimport { MeshGraphicArgs, MeshList } from \"../mesh/MeshPrimitives\";\nimport { MeshBuilderMap } from \"../mesh/MeshBuilderMap\";\nimport { Geometry, PrimitiveGeometryType } from \"./GeometryPrimitives\";\nimport { GeometryList } from \"./GeometryList\";\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { FeatureTable } from \"@bentley/imodeljs-common\";\n\n/** @internal */\nexport class GeometryAccumulator {\n  private _transform: Transform;\n  private _surfacesOnly: boolean;\n\n  public readonly tileRange: Range3d;\n  public readonly geometries: GeometryList = new GeometryList();\n  public readonly checkGlyphBoxes: boolean = false; // #TODO: obviously update when checkGlyphBoxes needs to be mutable\n  public readonly iModel: IModelConnection;\n  public readonly system: RenderSystem;\n\n  public get surfacesOnly(): boolean { return this._surfacesOnly; }\n  public get transform(): Transform { return this._transform; }\n  public get isEmpty(): boolean { return this.geometries.isEmpty; }\n  public get haveTransform(): boolean { return !this._transform.isIdentity; }\n\n  public constructor(iModel: IModelConnection, system: RenderSystem, surfacesOnly: boolean = false, transform: Transform = Transform.createIdentity(), tileRange: Range3d = Range3d.createNull()) {\n    this._surfacesOnly = surfacesOnly;\n    this._transform = transform;\n    this.iModel = iModel;\n    this.system = system;\n    this.tileRange = tileRange;\n  }\n\n  private getPrimitiveRange(pGeom: PrimitiveGeometryType): Range3d | undefined {\n    const pRange: Range3d = new Range3d();\n    pGeom.range(undefined, pRange);\n    if (pRange.isNull)\n      return undefined;\n    return pRange;\n  }\n\n  private calculateTransform(transform: Transform, range: Range3d): void {\n    if (this.haveTransform) this._transform.multiplyTransformTransform(transform, transform);\n    transform.multiplyRange(range, range);\n  }\n\n  public addLoop(loop: Loop, displayParams: DisplayParams, transform: Transform, disjoint: boolean): boolean {\n    const range: Range3d | undefined = this.getPrimitiveRange(loop);\n    if (!range)\n      return false;\n\n    this.calculateTransform(transform, range);\n    return this.addGeometry(Geometry.createFromLoop(loop, transform, range, displayParams, disjoint));\n  }\n\n  public addLineString(pts: Point3d[], displayParams: DisplayParams, transform: Transform): boolean {\n    // Do this.getPrimitiveRange() manually, so there is no need to create a PointString3d object just to find the range\n    const range = Range3d.createNull();\n    range.extendArray(pts, undefined);\n    if (range.isNull)\n      return false;\n\n    this.calculateTransform(transform, range);\n    return this.addGeometry(Geometry.createFromLineString(pts, transform, range, displayParams));\n  }\n\n  public addPointString(pts: Point3d[], displayParams: DisplayParams, transform: Transform): boolean {\n    // Do this.getPrimitiveRange() manually, so there is no need to create a PointString3d object just to find the range\n    const range = Range3d.createNull();\n    range.extendArray(pts, undefined);\n    if (range.isNull)\n      return false;\n\n    this.calculateTransform(transform, range);\n    return this.addGeometry(Geometry.createFromPointString(pts, transform, range, displayParams));\n  }\n\n  public addPath(path: Path, displayParams: DisplayParams, transform: Transform, disjoint: boolean): boolean {\n    const range: Range3d | undefined = this.getPrimitiveRange(path);\n    if (!range)\n      return false;\n\n    this.calculateTransform(transform, range);\n    return this.addGeometry(Geometry.createFromPath(path, transform, range, displayParams, disjoint));\n  }\n\n  public addPolyface(ipf: IndexedPolyface, displayParams: DisplayParams, transform: Transform): boolean {\n    const range: Range3d | undefined = this.getPrimitiveRange(ipf);\n    if (undefined === range)\n      return false;\n\n    this.calculateTransform(transform, range);\n    return this.addGeometry(Geometry.createFromPolyface(ipf, transform, range, displayParams));\n  }\n\n  public addGeometry(geom: Geometry): boolean { this.geometries.push(geom); return true; }\n\n  public clear(): void { this.geometries.clear(); }\n\n  public reset(transform: Transform = Transform.createIdentity(), surfacesOnly: boolean = false) {\n    this.clear();\n    this._transform = transform;\n    this._surfacesOnly = surfacesOnly;\n  }\n\n  /**\n   * Generates a MeshBuilderMap\n   * native: GeometryAccumulator::ToMeshBuilderMap(GeometryOptionsCR options, double tolerance, FeatureTableP featureTable, ViewContextR context) const\n   * note  : removed featureTable, ViewContext\n   * @param tolerance should derive from Viewport.getPixelSizeAtPoint\n   */\n  public toMeshBuilderMap(options: GeometryOptions, tolerance: number, pickableId?: string): MeshBuilderMap {\n    const { geometries } = this; // declare internal dependencies\n    const { wantSurfacesOnly, wantPreserveOrder } = options;\n\n    const range = geometries.computeRange();\n    const is2d = !range.isNull && range.isAlmostZeroZ;\n\n    return MeshBuilderMap.createFromGeometries(geometries, tolerance, range, is2d, wantSurfacesOnly, wantPreserveOrder, pickableId);\n  }\n\n  public toMeshes(options: GeometryOptions, tolerance: number, pickableId?: string): MeshList {\n    if (this.geometries.isEmpty)\n      return new MeshList();\n\n    const builderMap = this.toMeshBuilderMap(options, tolerance, pickableId);\n    return builderMap.toMeshes();\n  }\n\n  /**\n   * Populate a list of Graphic objects from the accumulated Geometry objects.\n   * removed ViewContext\n   */\n  public saveToGraphicList(graphics: RenderGraphic[], options: GeometryOptions, tolerance: number, pickableId?: string): FeatureTable | undefined {\n    const meshes = this.toMeshes(options, tolerance, pickableId);\n    if (0 === meshes.length)\n      return undefined;\n\n    const args = new MeshGraphicArgs();\n\n    // All of the meshes are quantized to the same range.\n    // If that range is small relative to the distance from the origin, quantization errors can produce display artifacts.\n    // Remove the translation from the quantization parameters and apply it in the transform instead.\n    const branch = new GraphicBranch(true);\n    const qorigin = new Point3d();\n\n    for (const mesh of meshes) {\n      const verts = mesh.points;\n      if (branch.isEmpty) {\n        qorigin.setFrom(verts.params.origin);\n      } else {\n        assert(verts.params.origin.isAlmostEqual(qorigin));\n      }\n\n      verts.params.origin.setZero();\n\n      const graphic = mesh.getGraphics(args, this.system);\n      if (undefined !== graphic)\n        branch.add(graphic);\n    }\n\n    if (!branch.isEmpty) {\n      const transform = Transform.createTranslationXYZ(qorigin.x, qorigin.y, qorigin.z);\n      graphics.push(this.system.createBranch(branch, transform));\n    }\n\n    return meshes.features;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { QParams3d } from \"@bentley/imodeljs-common\";\nimport { Range3d } from \"@bentley/geometry-core\";\nimport { Geometry } from \"./GeometryPrimitives\";\n\n/** @internal */\nexport class GeometryList {\n  private _list: Geometry[] = [];\n\n  public get first(): Geometry | undefined { return this._list[0]; }\n  public get isEmpty(): boolean { return this._list.length === 0; }\n  public get length(): number { return this._list.length; }\n  public push(geom: Geometry): number {\n    return this._list.push(geom);\n  }\n  public append(src: GeometryList): GeometryList {\n    this._list.push(...src._list);\n    return this;\n  }\n  public clear(): void { this._list.length = 0; }\n  public computeRange(): Range3d {\n    const range: Range3d = Range3d.createNull();\n    const extendRange = (geom: Geometry) => range.extendRange(geom.tileRange);\n    this._list.forEach(extendRange);\n    return range;\n  }\n  public computeQuantizationParams(): QParams3d { return QParams3d.fromRange(this.computeRange()); }\n\n  public [Symbol.iterator]() {\n    let key = 0;\n    return { next: (): IteratorResult<Geometry> => { const result = key < this._list.length ? { value: this._list[key], done: false } : { value: this._list[key - 1], done: true }; key++; return result; } };\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { Transform, Arc3d, LineSegment3d, CurvePrimitive, Loop, Path, Point2d, Point3d, Polyface, IndexedPolyface, LineString3d, Range3d } from \"@bentley/geometry-core\";\nimport { GraphicParams, RenderTexture, Gradient, FeatureTable } from \"@bentley/imodeljs-common\";\nimport { GraphicBuilder, GraphicType } from \"../../GraphicBuilder\";\nimport { Viewport } from \"../../../Viewport\";\nimport { GeometryOptions } from \"../Primitives\";\nimport { RenderSystem, RenderGraphic, PackedFeatureTable } from \"../../System\";\nimport { DisplayParams } from \"../DisplayParams\";\nimport { GeometryAccumulator } from \"./GeometryAccumulator\";\nimport { Geometry } from \"./GeometryPrimitives\";\nimport { Id64String } from \"@bentley/bentleyjs-core\";\n\nfunction copy2dTo3d(pts2d: Point2d[], depth: number): Point3d[] {\n  const pts3d: Point3d[] = [];\n  for (const point of pts2d)\n    pts3d.push(Point3d.create(point.x, point.y, depth));\n  return pts3d;\n}\n\n/** @internal */\nexport abstract class GeometryListBuilder extends GraphicBuilder {\n  public accum: GeometryAccumulator;\n  public graphicParams: GraphicParams = new GraphicParams();\n\n  public abstract finishGraphic(accum: GeometryAccumulator): RenderGraphic; // Invoked by Finish() to obtain the finished RenderGraphic.\n\n  public constructor(system: RenderSystem, type: GraphicType, viewport: Viewport, placement: Transform = Transform.identity, pickableId?: Id64String, accumulatorTf: Transform = Transform.identity) {\n    super(placement, type, viewport, pickableId);\n    this.accum = new GeometryAccumulator(this.iModel, system, undefined, accumulatorTf);\n  }\n\n  public finish(): RenderGraphic {\n    const graphic = this.finishGraphic(this.accum);\n    this.accum.clear();\n    return graphic;\n  }\n\n  public activateGraphicParams(graphicParams: GraphicParams): void {\n    this.graphicParams = graphicParams;\n  }\n\n  public addArc2d(ellipse: Arc3d, isEllipse: boolean, filled: boolean, zDepth: number): void {\n    if (0.0 === zDepth) {\n      this.addArc(ellipse, isEllipse, filled);\n    } else {\n      const ell: Arc3d = ellipse;\n      ell.center.z = zDepth;\n      this.addArc(ell, isEllipse, filled);\n    }\n  }\n\n  public addArc(ellipse: Arc3d, isEllipse: boolean, filled: boolean): void {\n    let curve;\n    let isLoop = false;\n    if (isEllipse || filled) {\n      curve = Loop.create(ellipse);\n      isLoop = true;\n    } else {\n      curve = Path.create(ellipse);\n    }\n\n    if (filled && !isEllipse && !ellipse.sweep.isFullCircle) {\n      const gapSegment: CurvePrimitive = LineSegment3d.create(ellipse.startPoint(), ellipse.endPoint());\n      (gapSegment as any).markerBits = 0x00010000; // Set the CURVE_PRIMITIVE_BIT_GapCurve marker bit\n      curve.children.push(gapSegment);\n    }\n    const displayParams = curve.isAnyRegionType ? this.getMeshDisplayParams() : this.getLinearDisplayParams();\n    if (isLoop)\n      this.accum.addLoop(curve, displayParams, this.placement, false);\n    else\n      this.accum.addPath(curve, displayParams, this.placement, false);\n  }\n\n  /** take ownership of input points and add as a line string to this builder */\n  public addLineString(points: Point3d[]): void {\n    if (2 === points.length && points[0].isAlmostEqual(points[1]))\n      this.accum.addPointString(points, this.getLinearDisplayParams(), this.placement);\n    else\n      this.accum.addLineString(points, this.getLinearDisplayParams(), this.placement);\n  }\n\n  public addLineString2d(points: Point2d[], zDepth: number): void {\n    const pts3d = copy2dTo3d(points, zDepth);\n    this.addLineString(pts3d);\n  }\n\n  /** take ownership of input points and add as a point string to this builder */\n  public addPointString(points: Point3d[]): void {\n    this.accum.addPointString(points, this.getLinearDisplayParams(), this.placement);\n  }\n\n  public addPointString2d(points: Point2d[], zDepth: number): void {\n    const pts3d = copy2dTo3d(points, zDepth);\n    this.addPointString(pts3d);\n  }\n\n  public addShape(points: Point3d[]): void {\n    const loop = Loop.create(LineString3d.create(points));\n    this.accum.addLoop(loop, this.getMeshDisplayParams(), this.placement, false);\n  }\n\n  public addShape2d(points: Point2d[], zDepth: number): void {\n    const pts3d = copy2dTo3d(points, zDepth);\n    this.addShape(pts3d);\n  }\n\n  public addPath(path: Path): void {\n    this.accum.addPath(path, this.getLinearDisplayParams(), this.placement, false);\n  }\n\n  public addLoop(loop: Loop): void {\n    this.accum.addLoop(loop, this.getMeshDisplayParams(), this.placement, false);\n  }\n\n  public addPolyface(meshData: Polyface): void {\n    this.accum.addPolyface(meshData as IndexedPolyface, this.getMeshDisplayParams(), this.placement);\n  }\n\n  public abstract reset(): void;\n\n  public getGraphicParams(): GraphicParams { return this.graphicParams; }\n\n  public getDisplayParams(type: DisplayParams.Type): DisplayParams { return DisplayParams.createForType(type, this.graphicParams); }\n  public getMeshDisplayParams(): DisplayParams { return DisplayParams.createForMesh(this.graphicParams, (grad) => this.resolveGradient(grad)); }\n  public getLinearDisplayParams(): DisplayParams { return DisplayParams.createForLinear(this.graphicParams); }\n  public get textDisplayParams(): DisplayParams { return DisplayParams.createForText(this.graphicParams); }\n\n  public get system(): RenderSystem { return this.accum.system; }\n\n  public add(geom: Geometry): void { this.accum.addGeometry(geom); }\n\n  public reInitialize(localToWorld: Transform, accumTf: Transform = Transform.createIdentity()) {\n    this.accum.reset(accumTf);\n    this.activateGraphicParams(this.graphicParams);\n    this.placement = localToWorld;\n    this.reset();\n  }\n\n  private resolveGradient(gradient: Gradient.Symb): RenderTexture | undefined {\n    return this.system.getGradientTexture(gradient, this.iModel);\n  }\n}\n\n/** @internal */\nexport class PrimitiveBuilder extends GeometryListBuilder {\n  public primitives: RenderGraphic[] = [];\n\n  public finishGraphic(accum: GeometryAccumulator): RenderGraphic {\n    let featureTable: FeatureTable | undefined;\n    if (!accum.isEmpty) {\n      // Overlay decorations don't test Z. Tools like to layer multiple primitives on top of one another; they rely on the primitives rendering\n      // in that same order to produce correct results (e.g., a thin line rendered atop a thick line of another color).\n      // No point generating edges for graphics that are always rendered in smooth shade mode.\n      const options = GeometryOptions.createForGraphicBuilder(this);\n      const tolerance = this.computeTolerance(accum);\n      featureTable = accum.saveToGraphicList(this.primitives, options, tolerance, this.pickId);\n    }\n\n    let graphic = (this.primitives.length !== 1) ? this.accum.system.createGraphicList(this.primitives) : this.primitives.pop() as RenderGraphic;\n    if (undefined !== featureTable) {\n      const range = new Range3d(); // ###TODO compute range...\n      graphic = this.accum.system.createBatch(graphic, PackedFeatureTable.pack(featureTable), range);\n    }\n\n    return graphic;\n  }\n\n  public computeTolerance(accum: GeometryAccumulator): number {\n    const toleranceMult = 0.25;\n    if (this.isViewCoordinates) return toleranceMult;\n    if (!this.viewport) return 20;\n    const range = accum.geometries!.computeRange(); // NB: Already multiplied by transform...\n    // NB: Geometry::CreateFacetOptions() will apply any scale factors from transform...no need to do it here.\n    const pt = range.low.interpolate(0.5, range.high);\n    return this.viewport!.getPixelSizeAtPoint(pt) * toleranceMult;\n  }\n\n  public reset(): void { this.primitives = []; }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport {\n  Transform,\n  Range3d,\n  Loop,\n  Path,\n  CurveChain,\n  Point3d,\n  StrokeOptions,\n  IndexedPolyface,\n  PolyfaceBuilder,\n  SweepContour,\n} from \"@bentley/geometry-core\";\nimport { DisplayParams } from \"../DisplayParams\";\nimport { StrokesPrimitive, StrokesPrimitiveList, StrokesPrimitivePointList, StrokesPrimitivePointLists } from \"../Strokes\";\nimport { PolyfacePrimitive, PolyfacePrimitiveList } from \"../Polyface\";\n\n/** @internal */\nexport type PrimitiveGeometryType = Loop | Path | IndexedPolyface;\n\n/** @internal */\nexport abstract class Geometry {\n  public readonly transform: Transform;\n  public readonly tileRange: Range3d;\n  public readonly displayParams: DisplayParams;\n\n  public constructor(transform: Transform, tileRange: Range3d, displayParams: DisplayParams) {\n    this.transform = transform;\n    this.tileRange = tileRange;\n    this.displayParams = displayParams;\n  }\n\n  public static createFromPointString(pts: Point3d[], tf: Transform, tileRange: Range3d, params: DisplayParams): Geometry {\n    return new PrimitivePointStringGeometry(pts, tf, tileRange, params);\n  }\n\n  public static createFromLineString(pts: Point3d[], tf: Transform, tileRange: Range3d, params: DisplayParams): Geometry {\n    return new PrimitiveLineStringGeometry(pts, tf, tileRange, params);\n  }\n\n  public static createFromLoop(loop: Loop, tf: Transform, tileRange: Range3d, params: DisplayParams, disjoint: boolean): Geometry {\n    return new PrimitiveLoopGeometry(loop, tf, tileRange, params, disjoint);\n  }\n\n  public static createFromPath(path: Path, tf: Transform, tileRange: Range3d, params: DisplayParams, disjoint: boolean): Geometry {\n    return new PrimitivePathGeometry(path, tf, tileRange, params, disjoint);\n  }\n\n  public static createFromPolyface(ipf: IndexedPolyface, tf: Transform, tileRange: Range3d, params: DisplayParams): Geometry {\n    return new PrimitivePolyfaceGeometry(ipf, tf, tileRange, params);\n  }\n\n  protected abstract _getPolyfaces(facetOptions: StrokeOptions): PolyfacePrimitiveList | undefined;\n  protected abstract _getStrokes(facetOptions: StrokeOptions): StrokesPrimitiveList | undefined;\n\n  public getPolyfaces(tolerance: number): PolyfacePrimitiveList | undefined {\n    const facetOptions = StrokeOptions.createForFacets();\n    facetOptions.chordTol = tolerance;\n    if (this.displayParams.isTextured)\n      facetOptions.needParams = true;\n\n    // if (!this.displayParams.ignoreLighting) // ###TODO And not 2D...\n    //   facetOptions.needNormals = true;\n\n    return this._getPolyfaces(facetOptions);\n  }\n\n  public getStrokes(tolerance: number): StrokesPrimitiveList | undefined {\n    const strokeOptions = StrokeOptions.createForCurves();\n    strokeOptions.chordTol = tolerance;\n    return this._getStrokes(strokeOptions);\n  }\n\n  public get hasTexture() { return this.displayParams.isTextured; }\n  public doDecimate() { return false; }\n  public doVertexCluster() { return true; }\n  public part() { return undefined; }\n}\n\n/** @internal */\nexport class PrimitivePathGeometry extends Geometry {\n  public readonly path: Path;\n  public readonly isDisjoint: boolean;\n\n  public constructor(path: Path, tf: Transform, range: Range3d, params: DisplayParams, isDisjoint: boolean) {\n    super(tf, range, params);\n    this.path = path;\n    this.isDisjoint = isDisjoint;\n  }\n\n  protected _getPolyfaces(_facetOptions: StrokeOptions): PolyfacePrimitiveList | undefined { return undefined; }\n\n  protected _getStrokes(facetOptions: StrokeOptions): StrokesPrimitiveList | undefined {\n    return PrimitivePathGeometry.getStrokesForLoopOrPath(this.path, facetOptions, this.displayParams, this.isDisjoint, this.transform);\n  }\n\n  public static getStrokesForLoopOrPath(loopOrPath: Loop | Path, facetOptions: StrokeOptions, params: DisplayParams, isDisjoint: boolean, transform: Transform): StrokesPrimitiveList | undefined {\n    const strksList = new StrokesPrimitiveList();\n\n    if (!loopOrPath.isAnyRegionType || params.wantRegionOutline) {\n      const strksPts: StrokesPrimitivePointLists = new StrokesPrimitivePointLists();\n      PrimitivePathGeometry.collectCurveStrokes(strksPts, loopOrPath, facetOptions, transform);\n\n      if (strksPts.length > 0) {\n        const isPlanar = loopOrPath.isAnyRegionType;\n        assert(isPlanar === params.wantRegionOutline);\n        const strksPrim: StrokesPrimitive = StrokesPrimitive.create(params, isDisjoint, isPlanar);\n        strksPrim.strokes = strksPts;\n        strksList.push(strksPrim);\n      }\n    }\n\n    return strksList;\n  }\n\n  private static collectCurveStrokes(strksPts: StrokesPrimitivePointLists, loopOrPath: CurveChain, facetOptions: StrokeOptions, trans: Transform) {\n    const strokes = loopOrPath.getPackedStrokes(facetOptions);\n    if (undefined !== strokes) {\n      const pts = strokes.getPoint3dArray();\n      trans.multiplyPoint3dArrayInPlace(pts);\n      strksPts.push(new StrokesPrimitivePointList(pts));\n    }\n  }\n}\n\n/** @internal */\nexport class PrimitivePointStringGeometry extends Geometry {\n  public readonly pts: Point3d[];\n\n  public constructor(pts: Point3d[], tf: Transform, range: Range3d, params: DisplayParams) {\n    super(tf, range, params);\n    this.pts = pts;\n  }\n\n  protected _getPolyfaces(_facetOptions: StrokeOptions): PolyfacePrimitiveList | undefined {\n    return undefined;\n  }\n\n  protected _getStrokes(_facetOptions: StrokeOptions): StrokesPrimitiveList | undefined {\n    const strksList = new StrokesPrimitiveList();\n    const strksPts = new StrokesPrimitivePointLists(new StrokesPrimitivePointList(this.pts));\n\n    const strksPrim: StrokesPrimitive = StrokesPrimitive.create(this.displayParams, true, false);\n    strksPrim.strokes = strksPts;\n    strksPrim.transform(this.transform);\n    strksList.push(strksPrim);\n\n    return strksList;\n  }\n}\n\n/** @internal */\nexport class PrimitiveLineStringGeometry extends Geometry {\n  public readonly pts: Point3d[];\n\n  public constructor(pts: Point3d[], tf: Transform, range: Range3d, params: DisplayParams) {\n    super(tf, range, params);\n    this.pts = pts;\n  }\n\n  protected _getPolyfaces(_facetOptions: StrokeOptions): PolyfacePrimitiveList | undefined {\n    return undefined;\n  }\n\n  protected _getStrokes(_facetOptions: StrokeOptions): StrokesPrimitiveList | undefined {\n    const strksList = new StrokesPrimitiveList();\n    const strksPts = new StrokesPrimitivePointLists(new StrokesPrimitivePointList(this.pts));\n\n    const strksPrim: StrokesPrimitive = StrokesPrimitive.create(this.displayParams, false, false);\n    strksPrim.strokes = strksPts;\n    strksPrim.transform(this.transform);\n    strksList.push(strksPrim);\n\n    return strksList;\n  }\n}\n\n/** @internal */\nexport class PrimitiveLoopGeometry extends Geometry {\n  public readonly loop: Loop;\n  public readonly isDisjoint: boolean;\n\n  public constructor(loop: Loop, tf: Transform, range: Range3d, params: DisplayParams, isDisjoint: boolean) {\n    super(tf, range, params);\n    this.loop = loop;\n    this.isDisjoint = isDisjoint;\n  }\n\n  protected _getPolyfaces(facetOptions: StrokeOptions): PolyfacePrimitiveList | undefined {\n    if (!this.loop.isAnyRegionType) {\n      return undefined;\n    }\n\n    // The following is good for single loop things according to Earlin.\n    const contour = SweepContour.createForLinearSweep(this.loop);\n    if (contour !== undefined) {\n      const pfBuilder: PolyfaceBuilder = PolyfaceBuilder.create(facetOptions);\n      contour.emitFacets(pfBuilder, false, this.transform); // build facets and emit them to the builder\n      const polyface = pfBuilder.claimPolyface();\n      const wantEdges = DisplayParams.RegionEdgeType.Default === this.displayParams.regionEdgeType;\n      const isPlanar = true;\n      return new PolyfacePrimitiveList(PolyfacePrimitive.create(this.displayParams, polyface, wantEdges, isPlanar));\n    } // ###TODO: this approach might not work with holes\n\n    return undefined;\n  }\n\n  protected _getStrokes(facetOptions: StrokeOptions): StrokesPrimitiveList | undefined {\n    return PrimitivePathGeometry.getStrokesForLoopOrPath(this.loop, facetOptions, this.displayParams, this.isDisjoint, this.transform);\n  }\n}\n\n/** @internal */\nexport class PrimitivePolyfaceGeometry extends Geometry {\n  public readonly polyface: IndexedPolyface;\n\n  public constructor(polyface: IndexedPolyface, tf: Transform, range: Range3d, params: DisplayParams) {\n    super(tf, range, params);\n    this.polyface = polyface;\n  }\n\n  protected _getPolyfaces(_facetOptions: StrokeOptions): PolyfacePrimitiveList | undefined {\n    if (!this.hasTexture) { // clear parameters\n      if (this.polyface.data.param) {\n          this.polyface.data.param.clear();\n      }\n      if (this.polyface.data.paramIndex) {\n        this.polyface.data.paramIndex = [];\n      }\n    }\n\n    assert(this.transform.isIdentity);\n    return new PolyfacePrimitiveList(PolyfacePrimitive.create(this.displayParams, this.polyface));\n  }\n\n  protected _getStrokes(_facetOptions: StrokeOptions): StrokesPrimitiveList | undefined { return undefined; }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport {\n  Point3d,\n  Range3d,\n  Polyface,\n  PolyfaceVisitor,\n  Angle,\n  IndexedPolyface,\n  Point2d,\n} from \"@bentley/geometry-core\";\nimport { VertexMap, VertexKey, VertexKeyProps } from \"../VertexKey\";\nimport {\n  QPoint3d,\n  QPoint3dList,\n  MeshPolyline,\n  MeshEdges,\n  OctEncodedNormal,\n  TextureMapping,\n} from \"@bentley/imodeljs-common\";\nimport { DisplayParams } from \"../DisplayParams\";\nimport { Triangle, TriangleKey, TriangleSet } from \"../Primitives\";\nimport { Mesh } from \"./MeshPrimitives\";\nimport { StrokesPrimitivePointLists } from \"../Strokes\";\n\n/** @internal */\nexport class MeshBuilder {\n  private _vertexMap?: VertexMap;\n  private _triangleSet?: TriangleSet;\n  private _currentPolyface?: MeshBuilderPolyface;\n  public readonly mesh: Mesh;\n  public readonly tolerance: number;\n  public readonly areaTolerance: number;\n  public readonly tileRange: Range3d;\n  public get currentPolyface(): MeshBuilderPolyface | undefined { return this._currentPolyface; }\n  public set displayParams(params: DisplayParams) { this.mesh.displayParams = params; }\n\n  /** create reference for vertexMap on demand */\n  public get vertexMap(): VertexMap {\n    if (undefined === this._vertexMap) this._vertexMap = new VertexMap();\n    return this._vertexMap;\n  }\n\n  /** create reference for triangleSet on demand */\n  public get triangleSet(): TriangleSet {\n    if (undefined === this._triangleSet) this._triangleSet = new TriangleSet();\n    return this._triangleSet;\n  }\n\n  private constructor(mesh: Mesh, tolerance: number, areaTolerance: number, tileRange: Range3d) {\n    this.mesh = mesh;\n    this.tolerance = tolerance;\n    this.areaTolerance = areaTolerance;\n    this.tileRange = tileRange;\n  }\n\n  /** create a new MeshBuilder */\n  public static create(props: MeshBuilder.Props): MeshBuilder {\n    const mesh = Mesh.create(props);\n    const { tolerance, areaTolerance, range } = props;\n    return new MeshBuilder(mesh, tolerance, areaTolerance, range);\n  }\n\n  /**\n   * iterate through each point list of the strokes primitive and either load the point string or polyline into builder\n   * @param strokes lists of stroke primitive point lists to iterate\n   * @param isDisjoint if true add point string, else add polyline\n   * @param fillColor\n   */\n  public addStrokePointLists(strokes: StrokesPrimitivePointLists, isDisjoint: boolean, fillColor: number): void {\n    for (const strokePoints of strokes) {\n      if (isDisjoint)\n        this.addPointString(strokePoints.points, fillColor);\n      else\n        this.addPolyline(strokePoints.points, fillColor);\n    }\n  }\n\n  /**\n   * add data from polyface into mesh builder\n   * @param polyface the indexed polyface to iterate the facets of to load each facet's triangles' vertices\n   * @param props the properties required for this operation\n   */\n  public addFromPolyface(polyface: IndexedPolyface, props: MeshBuilder.PolyfaceOptions): void {\n    const visitor = polyface.createVisitor();\n\n    while (visitor.moveToNextFacet()) {\n      this.addFromPolyfaceVisitor(visitor, props);\n    }\n\n    this.endPolyface();\n  }\n\n  /**\n   * @param visitor the PolyfaceVisitor containing the face data to be added\n   * @param props the properties required for this operation:\n   */\n  public addFromPolyfaceVisitor(visitor: PolyfaceVisitor, options: MeshBuilder.PolyfaceOptions): void {\n    const { pointCount, normalCount, paramCount, requireNormals } = visitor;\n    const { includeParams, mappedTexture } = options;\n\n    const isDegenerate = requireNormals && normalCount < pointCount; // TFS#790263: Degenerate triangle - no normals.\n\n    // a triangle must have at least 3 points\n    if (pointCount < 3 || isDegenerate)\n      return;\n\n    const haveParam = includeParams && paramCount > 0;\n    const triangleCount = pointCount - 2;\n\n    assert(!includeParams || paramCount > 0);\n    assert(!haveParam || undefined !== mappedTexture);\n\n    const polyfaceVisitorOptions = { ...options, triangleCount, haveParam };\n    // The face represented by this visitor should be convex (we request that in facet options) - so we do a simple fan triangulation.\n    for (let triangleIndex = 0; triangleIndex < triangleCount; triangleIndex++) {\n      const triangle = this.createTriangle(triangleIndex, visitor, polyfaceVisitorOptions);\n      if (undefined !== triangle)\n        this.addTriangle(triangle);\n    }\n  }\n\n  public createTriangleVertices(triangleIndex: number, visitor: PolyfaceVisitor, options: MeshBuilder.PolyfaceVisitorOptions): VertexKeyProps[] | undefined {\n    const { point, requireNormals } = visitor;\n    const { fillColor, haveParam } = options;\n    const qPointParams = this.mesh.points.params;\n\n    // If we do not have UVParams stored on the IndexedPolyface, compute them now\n    let params: Point2d[] | undefined;\n    if (haveParam && options.mappedTexture) {\n      assert(this.mesh.points.length === 0 || this.mesh.uvParams.length !== 0);\n      const mappedTexture = options.mappedTexture;\n      const transformToImodel = mappedTexture.params.textureMatrix.transform;\n      if (transformToImodel)\n        params = mappedTexture.computeUVParams(visitor, transformToImodel);\n      assert(params !== undefined);\n    }\n\n    const vertices = [];\n    for (let i = 0; i < 3; ++i) {\n      const vertexIndex = 0 === i ? 0 : triangleIndex + i;\n      const position = QPoint3d.create(point.getPoint3dAtUncheckedPointIndex(vertexIndex), qPointParams);\n      const normal = requireNormals ? OctEncodedNormal.fromVector(visitor.getNormal(vertexIndex)!) : undefined;\n      const uvParam: Point2d | undefined = params ? params[vertexIndex] : undefined;\n      vertices[i] = { position, fillColor, normal, uvParam };\n    }\n\n    // Previously we would add all 3 vertices to our map, then detect degenerate triangles in AddTriangle().\n    // This led to unused vertex data, and caused mismatch in # of vertices when recreating the MeshBuilder from the data in the tile cache.\n    // Detect beforehand instead.\n    if (vertices[0].position.equals(vertices[1].position) || vertices[0].position.equals(vertices[2].position) || vertices[1].position.equals(vertices[2].position))\n      return undefined;\n\n    return vertices;\n  }\n\n  public createTriangle(triangleIndex: number, visitor: PolyfaceVisitor, options: MeshBuilder.PolyfaceVisitorOptions): Triangle | undefined {\n    // generate vertex key properties for each of the three sides of the triangle\n    const vertices = this.createTriangleVertices(triangleIndex, visitor, options);\n\n    // avoid creating degenerate triangles\n    if (undefined === vertices)\n      return undefined;\n\n    const { edgeVisible } = visitor;\n\n    const triangle = new Triangle();\n\n    triangle.setEdgeVisibility(\n      0 === triangleIndex ? edgeVisible[0] : false,\n      edgeVisible[triangleIndex + 1],\n      triangleIndex === options.triangleCount - 1 ? edgeVisible[triangleIndex + 2] : false,\n    );\n\n    // set each triangle index to the index associated with the vertex key location in the vertex map\n    vertices.forEach((vertexProps: VertexKeyProps, i: number) => {\n      const vertexKeyIndex = this.addVertex(vertexProps);\n\n      triangle.indices[i] = vertexKeyIndex;\n\n      // if the current polyface exists, map the vertex key index to the visitor's client point index\n      if (this.currentPolyface !== undefined)\n        this.currentPolyface.vertexIndexMap.set(vertexKeyIndex, visitor.clientPointIndex(i));\n    });\n\n    return triangle;\n  }\n\n  /** removed Feature for now */\n  public addPolyline(pts: QPoint3dList | Point3d[], fillColor: number): void {\n    const { mesh } = this;\n\n    const poly = new MeshPolyline();\n    const points = pts instanceof QPoint3dList ? pts : QPoint3dList.createFrom(pts, mesh.points.params);\n\n    for (const position of points)\n      poly.addIndex(this.addVertex({ position, fillColor }));\n\n    mesh.addPolyline(poly);\n  }\n\n  /** removed Feature for now */\n  public addPointString(pts: Point3d[], fillColor: number): void {\n    const { mesh } = this;\n    const poly = new MeshPolyline();\n    const points = QPoint3dList.createFrom(pts, mesh.points.params);\n\n    for (const position of points)\n      poly.addIndex(this.addVertex({ position, fillColor }));\n\n    mesh.addPolyline(poly);\n  }\n\n  public beginPolyface(polyface: Polyface, options: MeshEdgeCreationOptions): void {\n    // ###TODO generateNoEdges no edges case\n    // maybe this --> (options.generateNoEdges && 0 === polyface.data.edgeVisible.length)\n    const triangles = this.mesh.triangles;\n    this._currentPolyface = new MeshBuilderPolyface(polyface, options, triangles === undefined ? 0 : triangles.length);\n  }\n\n  public endPolyface(): void {\n    const { currentPolyface, mesh } = this;\n    if (undefined === currentPolyface)\n      return;\n\n    if (mesh.edges === undefined)\n      mesh.edges = new MeshEdges();\n\n    // ###TODO\n    // MeshEdgesBuilder(m_tileRange, *m_mesh, *m_currentPolyface).BuildEdges(*m_mesh->m_edges, m_currentPolyface.get());\n  }\n\n  public addVertex(vertex: VertexKeyProps, addToMeshOnInsert = true): number {\n    // if vertex key isn't duplicate, then also insert properties into mesh\n    const onInsert = (vk: VertexKey) => this.mesh.addVertex(vk);\n    return this.vertexMap.insertKey(vertex, addToMeshOnInsert ? onInsert : undefined);\n  }\n\n  public addTriangle(triangle: Triangle): void {\n    // Prefer to avoid adding vertices originating from degenerate triangles before we get here...\n    assert(!triangle.isDegenerate);\n\n    const onInsert = (_vk: TriangleKey) => this.mesh.addTriangle(triangle);\n    this.triangleSet.insertKey(triangle, onInsert);\n  }\n}\n\n/** @internal */\nexport namespace MeshBuilder {\n  export interface Props extends Mesh.Props {\n    tolerance: number;\n    areaTolerance: number;\n  }\n  export interface PolyfaceOptions {\n    includeParams: boolean;\n    fillColor: number;\n    mappedTexture?: TextureMapping;\n  }\n  export interface PolyfaceVisitorOptions extends PolyfaceOptions {\n    triangleCount: number;\n    haveParam: boolean;\n  }\n}\n\n/** @internal */\nexport class MeshEdgeCreationOptions {\n  public readonly type: MeshEdgeCreationOptions.Type;\n  public readonly minCreaseAngle = 20.0 * Angle.radiansPerDegree;\n  public get generateAllEdges(): boolean { return this.type === MeshEdgeCreationOptions.Type.AllEdges; }\n  public get generateNoEdges(): boolean { return this.type === MeshEdgeCreationOptions.Type.NoEdges; }\n  public get generateSheetEdges(): boolean { return 0 !== (this.type & MeshEdgeCreationOptions.Type.SheetEdges); }\n  public get generateCreaseEdges(): boolean { return 0 !== (this.type & MeshEdgeCreationOptions.Type.CreaseEdges); }\n  /** Create edge chains for polyfaces that do not already have them. */\n  public get createEdgeChains(): boolean { return 0 !== (this.type & MeshEdgeCreationOptions.Type.CreateChains); }\n  constructor(type = MeshEdgeCreationOptions.Type.NoEdges) { this.type = type; }\n}\n\n/** @internal */\nexport namespace MeshEdgeCreationOptions {\n  export const enum Type {  // tslint:disable-line:no-const-enum\n    NoEdges = 0x0000,\n    SheetEdges = 0x0001 << 0,\n    CreaseEdges = 0x0001 << 1,\n    SmoothEdges = 0x0001 << 2,\n    CreateChains = 0x0001 << 3,\n    DefaultEdges = CreaseEdges | SheetEdges,\n    AllEdges = CreaseEdges | SheetEdges | SmoothEdges,\n  }\n}\n\n/** @internal */\nexport class MeshBuilderPolyface {\n  public readonly polyface: Polyface;\n  public readonly edgeOptions: MeshEdgeCreationOptions;\n  public readonly vertexIndexMap: Map<number, number> = new Map<number, number>();\n  public readonly baseTriangleIndex: number;\n  constructor(polyface: Polyface, edgeOptions: MeshEdgeCreationOptions, baseTriangleIndex: number) {\n    this.polyface = polyface;\n    this.edgeOptions = edgeOptions;\n    this.baseTriangleIndex = baseTriangleIndex;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { compareNumbers, compareBooleans, Dictionary } from \"@bentley/bentleyjs-core\";\nimport { Range3d } from \"@bentley/geometry-core\";\nimport { PolyfacePrimitive } from \"../Polyface\";\nimport { DisplayParams } from \"../DisplayParams\";\nimport { ToleranceRatio } from \"../Primitives\";\nimport { MeshBuilder } from \"./MeshBuilder\";\nimport { Mesh, MeshList } from \"./MeshPrimitives\";\nimport { Geometry } from \"../geometry/GeometryPrimitives\";\nimport { GeometryList } from \"../geometry/GeometryList\";\nimport { StrokesPrimitive } from \"../Strokes\";\nimport { Feature, FeatureTable } from \"@bentley/imodeljs-common\";\n\n/** @internal */\nexport class MeshBuilderMap extends Dictionary<MeshBuilderMap.Key, MeshBuilder> {\n  public readonly range: Range3d;\n  public readonly vertexTolerance: number;\n  public readonly facetAreaTolerance: number;\n  public readonly tolerance: number;\n  public readonly is2d: boolean;\n  public readonly features?: Mesh.Features;\n\n  /** if true the order of keys created to store meshBuilders maintain order */\n  private readonly _preserveKeyOrder: boolean;\n  private _keyOrder = 0;\n\n  constructor(tolerance: number, range: Range3d, is2d: boolean, preserveKeyOrder: boolean = false, id?: string) {\n    super((lhs: MeshBuilderMap.Key, rhs: MeshBuilderMap.Key) => lhs.compare(rhs));\n    this.tolerance = tolerance;\n    this.vertexTolerance = tolerance * ToleranceRatio.vertex;\n    this.facetAreaTolerance = tolerance * ToleranceRatio.facetArea;\n    this.range = range;\n    this.is2d = is2d;\n    this._preserveKeyOrder = preserveKeyOrder;\n    if (undefined !== id) {\n      const table = new FeatureTable(1);\n      this.features = new Mesh.Features(table);\n      this.features.add(new Feature(id), 0);\n    }\n  }\n\n  public static createFromGeometries(geometries: GeometryList, tolerance: number, range: Range3d, is2d: boolean, wantSurfacesOnly: boolean, wantPreserveOrder: boolean, id?: string): MeshBuilderMap {\n    const map = new MeshBuilderMap(tolerance, range, is2d, wantPreserveOrder, id);\n\n    for (const geom of geometries)\n      map.loadGeometry(geom, wantSurfacesOnly);\n\n    return map;\n  }\n\n  public toMeshes(): MeshList {\n    const meshes = new MeshList(undefined !== this.features ? this.features.table : undefined);\n    for (const builder of this._values)\n      meshes.push(builder.mesh);\n\n    return meshes;\n  }\n\n  /**\n   * extract polyfaces and strokes from geometry into MeshBuilder stored in builderMap\n   * @param geom Geometry instance to extract polyfaces and strokes from\n   * @param wantSurfacesOnly if true prevent strokes from being loaded into builders\n   */\n  public loadGeometry(geom: Geometry, wantSurfacesOnly: boolean): void {\n    this.loadPolyfacePrimitiveList(geom);\n\n    if (!wantSurfacesOnly)\n      this.loadStrokePrimitiveList(geom);\n  }\n\n  /**\n   * extract polyface primitives from geometry in meshBuilder stored in builderMap\n   * @param geom Geometry instance to extract polyfaces from\n   */\n  public loadPolyfacePrimitiveList(geom: Geometry): void {\n    const polyfaces = geom.getPolyfaces(this.tolerance);\n\n    if (polyfaces !== undefined)\n      for (const polyface of polyfaces)\n        this.loadIndexedPolyface(polyface);\n  }\n\n  /**\n   * extract indexed polyfaces into meshBuilder stored in builderMap\n   * @param polyface PolyfacePrimitive to extract indexed polyfaces from\n   */\n  public loadIndexedPolyface(polyface: PolyfacePrimitive): void {\n    const { indexedPolyface, displayParams, isPlanar } = polyface;\n    const { pointCount, normalCount } = indexedPolyface;\n    const { fillColor, isTextured } = displayParams;\n    const textureMapping = displayParams.textureMapping;\n\n    if (pointCount === 0)\n      return;\n\n    const builder = this.getBuilder(displayParams, Mesh.PrimitiveType.Mesh, normalCount > 0, isPlanar);\n    builder.addFromPolyface(indexedPolyface, { includeParams: isTextured, fillColor: fillColor.tbgr, mappedTexture: textureMapping });\n  }\n\n  /**\n   * extract stroke primitives from geometry in meshBuilder stored in builderMap\n   * @param geom Geometry instance to extract strokes from\n   */\n  public loadStrokePrimitiveList(geom: Geometry): void {\n    const strokes = geom.getStrokes(this.tolerance);\n\n    if (undefined !== strokes)\n      for (const stroke of strokes)\n        this.loadStrokesPrimitive(stroke);\n  }\n\n  /**\n   * extract strokes primitive into meshBuilder stored in builderMap\n   * @param strokePrimitive StrokesPrimitive instance to extractfrom\n   */\n  public loadStrokesPrimitive(strokePrimitive: StrokesPrimitive): void {\n    const { displayParams, isDisjoint, isPlanar, strokes } = strokePrimitive;\n\n    const type = isDisjoint ? Mesh.PrimitiveType.Point : Mesh.PrimitiveType.Polyline;\n    const builder = this.getBuilder(displayParams, type, false, isPlanar);\n    builder.addStrokePointLists(strokes, isDisjoint, displayParams.fillColor.tbgr);\n  }\n\n  public getBuilder(displayParams: DisplayParams, type: Mesh.PrimitiveType, hasNormals: boolean, isPlanar: boolean): MeshBuilder {\n    const { facetAreaTolerance, tolerance, is2d, range } = this;\n    const key = this.getKey(displayParams, type, hasNormals, isPlanar);\n\n    return this.getBuilderFromKey(key, { displayParams, type, range, is2d, isPlanar, tolerance, areaTolerance: facetAreaTolerance, features: this.features });\n  }\n\n  public getKey(displayParams: DisplayParams, type: Mesh.PrimitiveType, hasNormals: boolean, isPlanar: boolean): MeshBuilderMap.Key {\n    const key = new MeshBuilderMap.Key(displayParams, type, hasNormals, isPlanar);\n\n    if (this._preserveKeyOrder)\n      key.order = ++this._keyOrder;\n\n    return key;\n  }\n\n  /**\n   * gets builder associated with key if defined, otherwise creates a new builder and sets that with key\n   * @param key MeshBuilderMap.Key to associate with builder\n   * @param props MeshBuilder.Props required to create builder if it does not already exist\n   * @returns builder reference, changes will update instance stored in builderMap\n   */\n  public getBuilderFromKey(key: MeshBuilderMap.Key, props: MeshBuilder.Props): MeshBuilder {\n    let builder = this.get(key);\n    if (undefined === builder) {\n      builder = MeshBuilder.create(props);\n      this.set(key, builder);\n    }\n    return builder;\n  }\n}\n\n/** @internal */\nexport namespace MeshBuilderMap {\n  export class Key {\n    public order: number = 0;\n    public readonly params: DisplayParams;\n    public readonly type: Mesh.PrimitiveType;\n    public readonly hasNormals: boolean;\n    public readonly isPlanar: boolean;\n\n    constructor(params: DisplayParams, type: Mesh.PrimitiveType, hasNormals: boolean, isPlanar: boolean) {\n      this.params = params;\n      this.type = type;\n      this.hasNormals = hasNormals;\n      this.isPlanar = isPlanar;\n    }\n\n    public static createFromMesh(mesh: Mesh): Key {\n      return new Key(mesh.displayParams, mesh.type, mesh.normals.length !== 0, mesh.isPlanar);\n    }\n\n    public compare(rhs: Key): number {\n      let diff = compareNumbers(this.order, rhs.order);\n      if (0 === diff) {\n        diff = compareNumbers(this.type, rhs.type);\n        if (0 === diff) {\n          diff = compareBooleans(this.isPlanar, rhs.isPlanar);\n          if (0 === diff) {\n            diff = compareBooleans(this.hasNormals, rhs.hasNormals);\n            if (0 === diff) {\n              diff = this.params.compareForMerge(rhs.params);\n            }\n          }\n        }\n      }\n\n      return diff;\n    }\n\n    public equals(rhs: Key): boolean { return 0 === this.compare(rhs); }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { Range3d, Point2d } from \"@bentley/geometry-core\";\nimport {\n  QPoint3dList,\n  MeshPolyline,\n  MeshEdges,\n  QParams3d,\n  Feature,\n  FeatureTable,\n  FeatureIndex,\n  FeatureIndexType,\n  OctEncodedNormal,\n  MeshPolylineList,\n  PolylineFlags,\n  LinePixels,\n  ColorIndex,\n  PolylineData,\n  SilhouetteEdgeArgs,\n  RenderTexture,\n  RenderMaterial,\n  EdgeArgs,\n  PolylineEdgeArgs,\n  FillFlags,\n  // QPoint3d,\n} from \"@bentley/imodeljs-common\";\nimport { DisplayParams } from \"../DisplayParams\";\nimport { ColorMap } from \"../ColorMap\";\nimport { InstancedGraphicParams, RenderGraphic, RenderSystem } from \"../../System\";\nimport { Triangle, TriangleList } from \"../Primitives\";\nimport { VertexKeyProps } from \"../VertexKey\";\n\n/* Information needed to draw a set of indexed polylines using a shared vertex buffer.\n * @internal\n */\nexport class PolylineArgs {\n  public colors = new ColorIndex();\n  public features = new FeatureIndex();\n  public width = 0;\n  public linePixels = LinePixels.Solid;\n  public flags: PolylineFlags;\n  public points: QPoint3dList;\n  public polylines: PolylineData[];\n  public pointParams: QParams3d;\n\n  public constructor(points: QPoint3dList = new QPoint3dList(QParams3d.fromRange(Range3d.createNull())),\n    polylines: PolylineData[] = [], pointParams?: QParams3d, is2d = false, isPlanar = false) {\n    this.points = points;\n    this.polylines = polylines;\n    if (undefined === pointParams) {\n      this.pointParams = QParams3d.fromRange(Range3d.createNull());\n    } else {\n      this.pointParams = pointParams;\n    }\n    this.flags = new PolylineFlags(is2d, isPlanar);\n  }\n\n  public get isValid(): boolean { return this.polylines.length !== 0; }\n  public reset(): void {\n    this.flags.initDefaults();\n    this.points = new QPoint3dList(QParams3d.fromRange(Range3d.createNull()));\n    this.polylines = [];\n    this.colors.reset();\n    this.features.reset();\n  }\n  public init(mesh: Mesh) {\n    this.reset();\n    if (undefined === mesh.polylines)\n      return;\n\n    this.width = mesh.displayParams.width;\n    this.linePixels = mesh.displayParams.linePixels;\n    this.flags.is2d = mesh.is2d;\n    this.flags.isPlanar = mesh.isPlanar;\n    this.flags.isDisjoint = Mesh.PrimitiveType.Point === mesh.type;\n    if (DisplayParams.RegionEdgeType.Outline === mesh.displayParams.regionEdgeType) {\n      // This polyline is behaving as the edges of a region surface.\n      if (undefined === mesh.displayParams.gradient || mesh.displayParams.gradient.isOutlined)\n        this.flags.setIsNormalEdge();\n      else\n        this.flags.setIsOutlineEdge(); // edges only displayed if fill undisplayed...\n    }\n\n    mesh.polylines.forEach((polyline) => {\n      const indexedPolyline = new PolylineData();\n      if (indexedPolyline.init(polyline)) { this.polylines.push(indexedPolyline); }\n    });\n    if (!this.isValid) { return false; }\n    this.finishInit(mesh);\n    return true;\n  }\n  public finishInit(mesh: Mesh) {\n    this.pointParams = mesh.points.params;\n    this.points = mesh.points;\n    mesh.colorMap.toColorIndex(this.colors, mesh.colors);\n    mesh.toFeatureIndex(this.features);\n  }\n}\n\n/** The vertices of the edges are shared with those of the surface\n * @internal\n */\nexport class MeshArgsEdges {\n  public edges = new EdgeArgs();\n  public silhouettes = new SilhouetteEdgeArgs();\n  public polylines = new PolylineEdgeArgs();\n  public width = 0;\n  public linePixels = LinePixels.Solid;\n\n  public clear(): void {\n    this.edges.clear();\n    this.silhouettes.clear();\n    this.polylines.clear();\n    this.width = 0;\n    this.linePixels = LinePixels.Solid;\n  }\n  public get isValid(): boolean { return this.edges.isValid || this.silhouettes.isValid || this.polylines.isValid; }\n}\n\n/* A carrier of information needed to describe a triangle mesh and its edges.\n * @internal\n */\nexport class MeshArgs {\n  public edges = new MeshArgsEdges();\n  public vertIndices?: number[];\n  public points?: QPoint3dList;\n  public normals?: OctEncodedNormal[];\n  public textureUv?: Point2d[];\n  public texture?: RenderTexture;\n  public colors = new ColorIndex();\n  public features = new FeatureIndex();\n  public material?: RenderMaterial;\n  public fillFlags = FillFlags.None;\n  public isPlanar = false;\n  public is2d = false;\n  public hasBakedLighting = false;\n  public isVolumeClassifier = false;\n\n  public clear() {\n    this.edges.clear();\n    this.vertIndices = undefined;\n    this.points = undefined;\n    this.normals = undefined;\n    this.textureUv = undefined;\n    this.texture = undefined;\n    this.colors.reset();\n    this.features.reset();\n    this.material = undefined;\n    this.fillFlags = FillFlags.None;\n    this.isPlanar = this.is2d = this.hasBakedLighting = this.isVolumeClassifier = false;\n  }\n  public init(mesh: Mesh): boolean {\n    this.clear();\n    if (undefined === mesh.triangles || mesh.triangles.isEmpty)\n      return false;\n\n    assert(0 < mesh.points.length);\n\n    this.vertIndices = mesh.triangles.indices;\n    this.points = mesh.points;\n\n    if (!mesh.displayParams.ignoreLighting && 0 < mesh.normals.length)\n      this.normals = mesh.normals;\n\n    if (0 < mesh.uvParams.length)\n      this.textureUv = mesh.uvParams;\n\n    mesh.colorMap.toColorIndex(this.colors, mesh.colors);\n    mesh.toFeatureIndex(this.features);\n\n    this.material = mesh.displayParams.material;\n    if (undefined !== mesh.displayParams.textureMapping)\n      this.texture = mesh.displayParams.textureMapping.texture;\n\n    this.fillFlags = mesh.displayParams.fillFlags;\n    this.isPlanar = mesh.isPlanar;\n    this.is2d = mesh.is2d;\n    this.hasBakedLighting = (true === mesh.hasBakedLighting);\n    this.isVolumeClassifier = (true === mesh.isVolumeClassifier);\n\n    this.edges.width = mesh.displayParams.width;\n    this.edges.linePixels = mesh.displayParams.linePixels;\n\n    const meshEdges = mesh.edges;\n    if (undefined === meshEdges)\n      return true;\n\n    this.edges.edges.init(mesh.edges);\n    this.edges.silhouettes.init(mesh.edges);\n\n    const polylines: PolylineData[] = [];\n    meshEdges.polylines.forEach((meshPolyline: MeshPolyline) => {\n      const polyline = new PolylineData();\n      if (polyline.init(meshPolyline)) { polylines.push(polyline); }\n    });\n\n    this.edges.polylines.init(polylines);\n\n    return true;\n  }\n}\n\n/** @internal */\nexport class MeshGraphicArgs {\n  public polylineArgs = new PolylineArgs();\n  public meshArgs: MeshArgs = new MeshArgs();\n}\n\n/** @internal */\nexport class Mesh {\n  private readonly _data: TriangleList | MeshPolylineList;\n  public readonly points: QPoint3dList;\n  public readonly normals: OctEncodedNormal[] = [];\n  public readonly uvParams: Point2d[] = [];\n  public readonly colorMap: ColorMap = new ColorMap(); // used to be called ColorTable\n  public colors: number[] = [];\n  public edges?: MeshEdges;\n  public readonly features?: Mesh.Features;\n  public readonly type: Mesh.PrimitiveType;\n  public readonly is2d: boolean;\n  public readonly isPlanar: boolean;\n  public readonly hasBakedLighting: boolean;\n  public readonly isVolumeClassifier: boolean;\n  public displayParams: DisplayParams;\n\n  private constructor(props: Mesh.Props) {\n    const { displayParams, features, type, range, is2d, isPlanar } = props;\n    this._data = Mesh.PrimitiveType.Mesh === type ? new TriangleList() : new MeshPolylineList();\n    this.displayParams = displayParams;\n    this.features = features;\n    this.type = type;\n    this.is2d = is2d;\n    this.isPlanar = isPlanar;\n    this.hasBakedLighting = (true === props.hasBakedLighting);\n    this.isVolumeClassifier = (true === props.isVolumeClassifier);\n    this.points = new QPoint3dList(QParams3d.fromRange(range));\n  }\n\n  public static create(props: Mesh.Props): Mesh { return new Mesh(props); }\n\n  public get triangles(): TriangleList | undefined { return Mesh.PrimitiveType.Mesh === this.type ? this._data as TriangleList : undefined; }\n  public get polylines(): MeshPolylineList | undefined { return Mesh.PrimitiveType.Mesh !== this.type ? this._data as MeshPolylineList : undefined; }\n\n  public toFeatureIndex(index: FeatureIndex): void {\n    if (undefined !== this.features)\n      this.features.toFeatureIndex(index);\n  }\n\n  public getGraphics(args: MeshGraphicArgs, system: RenderSystem, instances?: InstancedGraphicParams): RenderGraphic | undefined {\n    if (undefined !== this.triangles && this.triangles.length !== 0) {\n      if (args.meshArgs.init(this))\n        return system.createTriMesh(args.meshArgs, instances);\n    } else if (undefined !== this.polylines && this.polylines.length !== 0 && args.polylineArgs.init(this)) {\n      return system.createIndexedPolylines(args.polylineArgs, instances);\n    }\n\n    return undefined;\n  }\n\n  public addPolyline(poly: MeshPolyline): void {\n    const { type, polylines } = this;\n\n    assert(Mesh.PrimitiveType.Polyline === type || Mesh.PrimitiveType.Point === type);\n    assert(undefined !== polylines);\n\n    if (Mesh.PrimitiveType.Polyline === type && poly.indices.length < 2)\n      return;\n\n    if (undefined !== polylines)\n      polylines.push(poly);\n  }\n\n  public addTriangle(triangle: Triangle): void {\n    const { triangles, type } = this;\n\n    assert(Mesh.PrimitiveType.Mesh === type);\n    assert(undefined !== triangles);\n\n    if (undefined !== triangles)\n      triangles.addTriangle(triangle);\n  }\n\n  public addVertex(props: VertexKeyProps): number {\n    const { position, normal, uvParam, fillColor } = props;\n\n    this.points.push(position);\n\n    if (undefined !== normal)\n      this.normals.push(normal);\n\n    if (undefined !== uvParam)\n      this.uvParams.push(uvParam);\n\n    // Don't allocate color indices until we have non-uniform colors\n    if (0 === this.colorMap.length) {\n      this.colorMap.insert(fillColor);\n      assert(this.colorMap.isUniform);\n      assert(0 === this.colorMap.indexOf(fillColor));\n    } else if (!this.colorMap.isUniform || !this.colorMap.hasColor(fillColor)) {\n      // Back-fill uniform value (index=0) for existing vertices if previously uniform\n      if (0 === this.colors.length)\n        this.colors.length = this.points.length - 1;\n\n      this.colors.push(this.colorMap.insert(fillColor));\n      assert(!this.colorMap.isUniform);\n    }\n\n    return this.points.length - 1;\n  }\n}\n\n/** @internal */\nexport namespace Mesh {\n  export const enum PrimitiveType { // tslint:disable-line:no-const-enum\n    Mesh,\n    Polyline,\n    Point,\n  }\n\n  export class Features {\n    public readonly table: FeatureTable;\n    public indices: number[] = [];\n    public uniform = 0;\n    public initialized = false;\n\n    public constructor(table: FeatureTable) { this.table = table; }\n\n    public add(feat: Feature, numVerts: number): void {\n      const index = this.table.insert(feat);\n      if (!this.initialized) {\n        // First feature - uniform.\n        this.uniform = index;\n        this.initialized = true;\n      } else if (0 < this.indices.length) {\n        // Already non-uniform\n        this.indices.push(index);\n      } else {\n        // Second feature - back-fill uniform for existing verts\n        while (this.indices.length < numVerts - 1)\n          this.indices.push(this.uniform);\n\n        this.indices.push(index);\n      }\n    }\n\n    public setIndices(indices: number[]) {\n      this.indices.length = 0;\n      this.uniform = 0;\n      this.initialized = 0 < indices.length;\n\n      assert(0 < indices.length);\n      if (1 === indices.length)\n        this.uniform = indices[0];\n      else if (1 < indices.length)\n        this.indices = indices;\n    }\n\n    public toFeatureIndex(index: FeatureIndex): void {\n      if (!this.initialized) {\n        index.type = FeatureIndexType.Empty;\n      } else if (this.indices.length === 0) {\n        index.type = FeatureIndexType.Uniform;\n        index.featureID = this.uniform;\n      } else {\n        index.type = FeatureIndexType.NonUniform;\n        index.featureIDs = new Uint32Array(this.indices);\n      }\n    }\n  }\n\n  export interface Props {\n    displayParams: DisplayParams;\n    features?: Mesh.Features;\n    type: Mesh.PrimitiveType;\n    range: Range3d;\n    is2d: boolean;\n    isPlanar: boolean;\n    hasBakedLighting?: boolean;\n    isVolumeClassifier?: boolean;\n  }\n}\n\n/** @internal */\nexport class MeshList extends Array<Mesh> {\n  public readonly features?: FeatureTable;\n  constructor(features?: FeatureTable) {\n    super();\n    this.features = features;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { Transform } from \"@bentley/geometry-core\";\nimport { ViewFlags, RenderMode, Feature } from \"@bentley/imodeljs-common\";\nimport { Id64, Id64String, assert, lowerBound } from \"@bentley/bentleyjs-core\";\nimport { FeatureSymbology } from \"../FeatureSymbology\";\nimport { Branch, Batch } from \"./Graphic\";\nimport { ClipPlanesVolume, ClipMaskVolume } from \"./ClipVolume\";\nimport { PlanarClassifier } from \"./PlanarClassifier\";\n\n/**\n * Represents a branch node in the scene graph, with associated view flags and transform to be applied to\n * all sub-nodes of the branch.\n * @internal\n */\nexport class BranchState {\n  public readonly transform: Transform;\n  private readonly _viewFlags: ViewFlags;\n  public symbologyOverrides: FeatureSymbology.Overrides;\n  public readonly clipVolume?: ClipPlanesVolume | ClipMaskVolume;\n  public readonly planarClassifier?: PlanarClassifier;\n\n  public static fromBranch(prev: BranchState, branch: Branch) {\n    const vf = branch.branch.getViewFlags(prev.viewFlags);\n    const transform = prev.transform.multiplyTransformTransform(branch.localToWorldTransform);\n    const ovrs = undefined !== branch.branch.symbologyOverrides ? branch.branch.symbologyOverrides : prev.symbologyOverrides;\n    return new BranchState(vf, transform, ovrs, branch.clips, branch.planarClassifier);\n  }\n\n  public static create(ovrs: FeatureSymbology.Overrides, flags?: ViewFlags, transform?: Transform, clip?: ClipMaskVolume | ClipPlanesVolume, planarClassifier?: PlanarClassifier) {\n    return new BranchState(ViewFlags.createFrom(flags), undefined !== transform ? transform.clone() : Transform.createIdentity(), ovrs, clip, planarClassifier);\n  }\n\n  public static createForDecorations(): BranchState {\n    const vf = new ViewFlags();\n    vf.renderMode = RenderMode.SmoothShade;\n    vf.sourceLights = false;\n    vf.cameraLights = false;\n    vf.solarLight = false;\n    return new BranchState(vf, Transform.createIdentity(), new FeatureSymbology.Overrides());\n  }\n\n  public get viewFlags() { return this._viewFlags; }\n  public set viewFlags(vf: ViewFlags) { vf.clone(this._viewFlags); }\n  public get showClipVolume(): boolean { return this.viewFlags.clipVolume; }\n\n  private constructor(flags: ViewFlags, transform: Transform, ovrs: FeatureSymbology.Overrides, clip?: ClipPlanesVolume | ClipMaskVolume, planarClassifier?: PlanarClassifier) {\n    this._viewFlags = flags;\n    this.transform = transform;\n    this.symbologyOverrides = ovrs;\n    this.clipVolume = clip;\n    this.planarClassifier = planarClassifier;\n  }\n}\n\n/**\n * Represents the current state of the scene graph. As the scene graph is traversed,\n * branch states are pushed and popped. Pushing a branch state replaces the current view flags\n * and multiplies the current transform with the branch's transform. Popping it inverts this\n * operation. The state at the top of the stack applies to the rendering of all primitives.\n * The stack does not store the scene graph itself.\n * @internal\n */\nexport class BranchStack {\n  private readonly _stack: BranchState[] = [];\n\n  public constructor(flags?: ViewFlags, transform?: Transform) { this.pushState(BranchState.create(new FeatureSymbology.Overrides(), flags, transform)); }\n\n  public get top(): BranchState {\n    assert(!this.empty);\n    return this._stack[this._stack.length - 1];\n  }\n\n  public get bottom(): BranchState {\n    assert(!this.empty);\n    return this._stack[0];\n  }\n\n  public get length() { return this._stack.length; }\n  public get empty() { return 0 === this.length; }\n\n  public pushBranch(branch: Branch): void {\n    assert(this.length > 0);\n    this.pushState(BranchState.fromBranch(this.top, branch));\n  }\n  public pushState(state: BranchState) {\n    this._stack.push(state);\n  }\n\n  public pop(): void {\n    assert(!this.empty);\n    if (!this.empty) {\n      this._stack.pop();\n    }\n  }\n\n  public setViewFlags(vf: ViewFlags) { assert(1 === this.length); this.top.viewFlags = vf; }\n  public setSymbologyOverrides(ovrs: FeatureSymbology.Overrides) {\n    assert(1 === this.length);\n    this.top.symbologyOverrides = ovrs;\n  }\n}\n\n/**\n * Assigns a transient, unique 32-bit integer ID to each Batch in a RenderCommands.\n * A batch ID of 0 means \"no batch\".\n * The first batch gets batch ID of 1.\n * The next batch gets the previous batch's ID plus the number of features in the previous batch's feature table\n * (or 1, if empty feature table).\n * The IDs are set temporarily as members on the Batch objects and reset to 0 immediately after rendering.\n * The currentBatch member identifies the batch containing primitives currently being drawn.\n * The combination of the current batch's ID (passed as uniform to shader) and the index of a given Feature within\n * its batch's FeatureTable (stored in vertex table) produce a unique ID for every feature rendered during a frame.\n * During rendering, the feature IDs are written to the \"feature ID\" color attachment.\n * The batch IDs remain valid during a call to Target.readPixels() so that they can be used to extract\n * Features from the Batch's FeatureTables.\n * @internal\n */\nexport class BatchState {\n  private _batches: Batch[] = []; // NB: this list is ordered - but *not* indexed - by batch ID.\n  private _curBatch?: Batch;\n\n  public get currentBatch(): Batch | undefined { return this._curBatch; }\n  public get currentBatchId(): number { return undefined !== this._curBatch ? this._curBatch.batchId : 0; }\n  public get isEmpty(): boolean { return 0 === this._batches.length; }\n\n  public push(batch: Batch, allowAdd: boolean): void {\n    assert(undefined === this.currentBatch, \"batches cannot nest\");\n    this.getBatchId(batch, allowAdd);\n    this._curBatch = batch;\n  }\n\n  public pop(): void {\n    assert(undefined !== this.currentBatch);\n    this._curBatch = undefined;\n  }\n\n  public reset(): void {\n    assert(undefined === this.currentBatch);\n    for (const batch of this._batches)\n      batch.batchId = 0;\n\n    this._batches.length = 0;\n    this._curBatch = undefined;\n  }\n\n  public getElementId(featureId: number): Id64String {\n    const batch = this.find(featureId);\n    if (undefined === batch)\n      return Id64.invalid;\n\n    const featureIndex = featureId - batch.batchId;\n    assert(featureIndex >= 0);\n\n    const parts = batch.featureTable.getElementIdPair(featureIndex);\n    return Id64.fromUint32Pair(parts.lower, parts.upper);\n  }\n\n  public getFeature(featureId: number): Feature | undefined {\n    const batch = this.find(featureId);\n    if (undefined === batch)\n      return undefined;\n\n    const featureIndex = featureId - batch.batchId;\n    assert(featureIndex >= 0);\n\n    return batch.featureTable.findFeature(featureIndex);\n  }\n\n  public get numFeatureIds() { return this.nextBatchId; }\n  public get numBatches() { return this._batches.length; }\n  public findBatchId(featureId: number) {\n    const batch = this.find(featureId);\n    return undefined !== batch ? batch.batchId : 0;\n  }\n\n  public get nextBatchId(): number {\n    if (this.isEmpty)\n      return 1;\n\n    const prev = this._batches[this._batches.length - 1];\n    assert(0 !== prev.batchId);\n\n    let prevNumFeatures = prev.featureTable.numFeatures;\n    if (0 === prevNumFeatures)\n      prevNumFeatures = 1;\n\n    return prev.batchId + prevNumFeatures;\n  }\n\n  private getBatchId(batch: Batch, allowAdd: boolean): number {\n    if (allowAdd && 0 === batch.batchId) {\n      batch.batchId = this.nextBatchId;\n      this._batches.push(batch);\n    }\n\n    return batch.batchId;\n  }\n\n  private indexOf(featureId: number): number {\n    if (featureId <= 0)\n      return -1;\n\n    const found = lowerBound(featureId, this._batches, (lhs: number, rhs: Batch) => {\n      // Determine if the requested feature ID is within the range of this batch.\n      if (lhs < rhs.batchId)\n        return -1;\n\n      const numFeatures = rhs.featureTable.numFeatures;\n      const nextBatchId = rhs.batchId + (numFeatures > 0 ? numFeatures : 1);\n      return lhs < nextBatchId ? 0 : 1;\n    });\n\n    return found.index < this._batches.length ? found.index : -1;\n  }\n\n  public find(featureId: number): Batch | undefined {\n    const index = this.indexOf(featureId);\n    return -1 !== index ? this._batches[index] : undefined;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { QPoint3dList, QParams3d, RenderTexture, ViewFlags, RenderMode } from \"@bentley/imodeljs-common\";\nimport { TesselatedPolyline } from \"../primitives/VertexTable\";\nimport { assert, IDisposable, dispose } from \"@bentley/bentleyjs-core\";\nimport { Point3d, Range3d, Vector2d } from \"@bentley/geometry-core\";\nimport { AttributeHandle, BufferHandle, QBufferHandle3d } from \"./Handle\";\nimport { Target } from \"./Target\";\nimport { ShaderProgramParams } from \"./DrawCommand\";\nimport { TechniqueId, computeCompositeTechniqueId } from \"./TechniqueId\";\nimport { RenderPass, RenderOrder, CompositeFlags } from \"./RenderFlags\";\nimport { LineCode } from \"./EdgeOverrides\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\nimport { RenderMemory } from \"../System\";\nimport { ColorInfo } from \"./ColorInfo\";\nimport { FeaturesInfo } from \"./FeaturesInfo\";\nimport { VertexLUT } from \"./VertexLUT\";\nimport { TextureHandle } from \"./Texture\";\nimport { Material } from \"./Material\";\nimport { SkyBox } from \"../../DisplayStyleState\";\nimport { InstancedGeometry } from \"./InstancedGeometry\";\nimport { SurfaceGeometry, MeshGeometry, EdgeGeometry, SilhouetteEdgeGeometry } from \"./Mesh\";\n\n/** Represents a geometric primitive ready to be submitted to the GPU for rendering.\n * @internal\n */\nexport abstract class CachedGeometry implements IDisposable, RenderMemory.Consumer {\n  protected _range?: Range3d;\n  /**\n   * Functions for obtaining a subclass of CachedGeometry.\n   * IMPORTANT: Do NOT use code like `const surface = cachedGeom as SurfaceGeometry`.\n   * Instanced geometry holds a reference to the shared geometry rendered for each instance - such casts will fail,\n   * while the casting `functions` will forward to the shared geometry.\n   */\n  public get asLUT(): LUTGeometry | undefined { return undefined; }\n  public get asSurface(): SurfaceGeometry | undefined { return undefined; }\n  public get asMesh(): MeshGeometry | undefined { return undefined; }\n  public get asEdge(): EdgeGeometry | undefined { return undefined; }\n  public get asSilhouette(): SilhouetteEdgeGeometry | undefined { return undefined; }\n  public get asInstanced(): InstancedGeometry | undefined { return undefined; }\n  public get isInstanced() { return undefined !== this.asInstanced; }\n\n  // Returns true if white portions of this geometry should render as black on white background\n  protected abstract _wantWoWReversal(_target: Target): boolean;\n  // Returns the edge/line weight used to render this geometry\n  protected _getLineWeight(_params: ShaderProgramParams): number { return 0; }\n  // Returns the edge/line pattern used to render this geometry\n  protected _getLineCode(_params: ShaderProgramParams): number { return LineCode.solid; }\n\n  // Returns the Id of the Technique used to render this geometry\n  public abstract getTechniqueId(target: Target): TechniqueId;\n  // Returns the pass in which to render this geometry. RenderPass.None indicates it should not be rendered.\n  public abstract getRenderPass(target: Target): RenderPass;\n  // Returns the 'order' of this geometry, which determines how z-fighting is resolved.\n  public abstract get renderOrder(): RenderOrder;\n  // Returns true if this is a lit surface\n  public get isLitSurface(): boolean { return false; }\n  // Returns true if this is an unlit surface with baked-in lighting (e.g. 3mx, scalable mesh reality models)\n  public get hasBakedLighting(): boolean { return false; }\n  // Returns true if this primititive constains auxilliary animation data.\n  public get hasAnimation(): boolean { return false; }\n\n  /** Returns the origin of this geometry's quantization parameters. */\n  public abstract get qOrigin(): Float32Array;\n  /** Returns the scale of this geometry's quantization parameters. */\n  public abstract get qScale(): Float32Array;\n  /** Binds this geometry's vertex data to the vertex attribute. */\n  public abstract bindVertexArray(handle: AttributeHandle): void;\n  // Draws this geometry\n  public abstract draw(): void;\n\n  public abstract dispose(): void;\n\n  // Intended to be overridden by specific subclasses\n  public get material(): Material | undefined { return undefined; }\n  public get polylineBuffers(): PolylineBuffers | undefined { return undefined; }\n  public set uniformFeatureIndices(_value: number) { }\n  public get featuresInfo(): FeaturesInfo | undefined { return undefined; }\n\n  public get isEdge(): boolean {\n    switch (this.renderOrder) {\n      case RenderOrder.Edge:\n      case RenderOrder.Silhouette:\n      case RenderOrder.PlanarEdge:\n      case RenderOrder.PlanarSilhouette:\n        return true;\n      default:\n        return false;\n    }\n  }\n  public wantWoWReversal(params: ShaderProgramParams): boolean {\n    return !params.isOverlayPass && this._wantWoWReversal(params.target);\n  }\n  public getLineCode(params: ShaderProgramParams): number {\n    return params.target.currentViewFlags.styles ? this._getLineCode(params) : LineCode.solid;\n  }\n  public getLineWeight(params: ShaderProgramParams): number {\n    if (!params.target.currentViewFlags.weights) {\n      return 1.0;\n    }\n\n    const minWeight = 1;\n    let weight = this._getLineWeight(params);\n    weight = Math.max(weight, minWeight);\n    weight = Math.min(weight, 31.0);\n    return weight;\n  }\n\n  // Returns true if flashing this geometry should mix its color with the hilite color. If not, the geometry color will be brightened instead.\n  public wantMixHiliteColorForFlash(vf: ViewFlags, target: Target): boolean {\n    // By default only surfaces rendered with lighting get brightened. Overridden for reality meshes since they have lighting baked-in.\n    if (this.hasBakedLighting || RenderPass.Classification === this.getRenderPass(target))\n      return true;\n    else if (!this.isLitSurface)\n      return false;\n    else if (RenderMode.SmoothShade !== vf.renderMode)\n      return false;\n    else\n      return vf.sourceLights || vf.cameraLights || vf.solarLight;\n  }\n\n  public abstract collectStatistics(stats: RenderMemory.Statistics): void;\n\n  public computeRange(output?: Range3d): Range3d {\n    if (undefined === this._range) {\n      const lowX = this.qOrigin[0];\n      const lowY = this.qOrigin[1];\n      const lowZ = this.qOrigin[2];\n\n      const hiX = 0xffff * this.qScale[0] + lowX;\n      const hiY = 0xffff * this.qScale[1] + lowY;\n      const hiZ = 0xffff * this.qScale[2] + lowZ;\n\n      this._range = Range3d.createXYZXYZ(lowX, lowY, lowZ, hiX, hiY, hiZ);\n    }\n\n    return this._range.clone(output);\n  }\n}\n\n/** Geometry which is drawn using indices into a look-up texture of vertex data, via gl.drawArrays()\n * @internal\n */\nexport abstract class LUTGeometry extends CachedGeometry {\n  // The texture containing the vertex data.\n  public abstract get lut(): VertexLUT;\n  public get asLUT() { return this; }\n\n  protected abstract _draw(_numInstances: number): void;\n  public draw(): void { this._draw(0); }\n  public drawInstanced(numInstances: number): void { this._draw(numInstances); }\n\n  // Override this if your color varies based on the target\n  public getColor(_target: Target): ColorInfo { return this.lut.colorInfo; }\n\n  public get qOrigin(): Float32Array { return this.lut.qOrigin; }\n  public get qScale(): Float32Array { return this.lut.qScale; }\n  public get hasAnimation() { return this.lut.hasAnimation; }\n\n  protected constructor() { super(); }\n}\n\n/** Parameters used to construct an IndexedGeometry\n * @internal\n */\nexport class IndexedGeometryParams implements IDisposable {\n  public readonly positions: QBufferHandle3d;\n  public readonly indices: BufferHandle;\n  public readonly numIndices: number;\n\n  protected constructor(positions: QBufferHandle3d, indices: BufferHandle, numIndices: number) {\n    this.positions = positions;\n    this.indices = indices;\n    this.numIndices = numIndices;\n  }\n\n  public static create(positions: Uint16Array, qparams: QParams3d, indices: Uint32Array) {\n    const posBuf = QBufferHandle3d.create(qparams, positions);\n    const indBuf = BufferHandle.createBuffer(GL.Buffer.Target.ElementArrayBuffer, indices);\n    if (undefined === posBuf || undefined === indBuf)\n      return undefined;\n\n    return new IndexedGeometryParams(posBuf, indBuf, indices.length);\n  }\n  public static createFromList(positions: QPoint3dList, indices: Uint32Array) {\n    return IndexedGeometryParams.create(positions.toTypedArray(), positions.params, indices);\n  }\n\n  public dispose() {\n    dispose(this.positions);\n    dispose(this.indices);\n  }\n}\n\n/** A geometric primitive which is rendered using gl.drawElements() with one or more vertex buffers indexed by an index buffer.\n * @internal\n */\nexport abstract class IndexedGeometry extends CachedGeometry {\n  protected readonly _params: IndexedGeometryParams;\n  protected _wantWoWReversal(_target: Target): boolean { return false; }\n  protected constructor(params: IndexedGeometryParams) {\n    super();\n    this._params = params;\n  }\n\n  public dispose() {\n    dispose(this._params);\n  }\n\n  public bindVertexArray(attr: AttributeHandle): void {\n    attr.enableArray(this._params.positions, 3, GL.DataType.UnsignedShort, false, 0, 0);\n  }\n  public draw(): void {\n    this._params.indices.bind(GL.Buffer.Target.ElementArrayBuffer);\n    System.instance.context.drawElements(GL.PrimitiveType.Triangles, this._params.numIndices, GL.DataType.UnsignedInt, 0);\n  }\n\n  public get qOrigin() { return this._params.positions.origin; }\n  public get qScale() { return this._params.positions.scale; }\n}\n\n/** A geometric primitive representative of a set of clipping planes to clip a volume of space.\n * @internal\n */\nexport class ClipMaskGeometry extends IndexedGeometry {\n  public constructor(indices: Uint32Array, vertices: QPoint3dList) {\n    super(IndexedGeometryParams.createFromList(vertices, indices)!);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    stats.addClipVolume(this._params.positions.bytesUsed + this._params.indices.bytesUsed);\n  }\n\n  public getTechniqueId(_target: Target): TechniqueId { return TechniqueId.ClipMask; }\n  public getRenderPass(_target: Target): RenderPass { return RenderPass.None; }\n  public get renderOrder(): RenderOrder { return RenderOrder.Surface; }\n}\n\n/** a cube of quads in normalized device coordinates for skybox rendering techniques\n * @internal\n */\nclass SkyBoxQuads {\n  public readonly vertices: Uint16Array;\n  public readonly vertexParams: QParams3d;\n\n  public constructor() {\n    const skyBoxSz = 1.0;\n\n    const qVerts = new QPoint3dList(QParams3d.fromNormalizedRange());\n\n    // NB: After applying the rotation matrix in the shader, Back becomes (Bottom), etc.\n    // See the notes in the parens below.\n\n    // ###TODO: Make this indexed.  Currently not indexed because of previous six-sided texture system.\n\n    // Back (Bottom after rotation)\n    qVerts.add(new Point3d(-skyBoxSz, skyBoxSz, skyBoxSz));   // back upper left - 0\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, skyBoxSz));    // back upper right - 1\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));  // back lower left - 2\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, skyBoxSz));    // back upper right - 1\n    qVerts.add(new Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));   // back lower right - 3\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));  // back lower left - 2\n\n    // Front (Top after rotation)\n    qVerts.add(new Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));  // front upper left - 4\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));   // front upper right - 5\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));   // front upper right - 5\n    qVerts.add(new Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz));  // front lower right - 7\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6\n\n    // Top (Front after rotation)\n    qVerts.add(new Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));  // front upper left - 4\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));   // front upper right - 5\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, skyBoxSz));    // back upper right - 1\n    qVerts.add(new Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));  // front upper left - 4\n    qVerts.add(new Point3d(-skyBoxSz, skyBoxSz, skyBoxSz));   // back upper left - 0\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, skyBoxSz));    // back upper right - 1\n\n    // Bottom (Back after rotation)\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));  // back lower left - 2\n    qVerts.add(new Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));   // back lower right - 3\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6\n    qVerts.add(new Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));   // back lower right - 3\n    qVerts.add(new Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz));  // front lower right - 7\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6\n\n    // Left (Right after rotation)\n    qVerts.add(new Point3d(-skyBoxSz, skyBoxSz, skyBoxSz));   // back upper left - 0\n    qVerts.add(new Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));  // front upper left - 4\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));  // back lower left - 2\n    qVerts.add(new Point3d(-skyBoxSz, skyBoxSz, -skyBoxSz));  // front upper left - 4\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, -skyBoxSz)); // front lower left - 6\n    qVerts.add(new Point3d(-skyBoxSz, -skyBoxSz, skyBoxSz));  // back lower left - 2\n\n    // Right (Left after rotation)\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, skyBoxSz));    // back upper right - 1\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));   // front upper right - 5\n    qVerts.add(new Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));   // back lower right - 3\n    qVerts.add(new Point3d(skyBoxSz, skyBoxSz, -skyBoxSz));   // front upper right - 5\n    qVerts.add(new Point3d(skyBoxSz, -skyBoxSz, -skyBoxSz));  // front lower right - 7\n    qVerts.add(new Point3d(skyBoxSz, -skyBoxSz, skyBoxSz));   // back lower right - 3\n\n    this.vertices = qVerts.toTypedArray();\n    this.vertexParams = qVerts.params;\n  }\n\n  public createParams() {\n    return SkyBoxGeometryParams.create(this.vertices, this.vertexParams);\n  }\n}\n\n/** Parameters used to construct an SkyBox\n * @internal\n */\nexport class SkyBoxGeometryParams implements IDisposable {\n  public readonly positions: QBufferHandle3d;\n\n  protected constructor(positions: QBufferHandle3d) {\n    this.positions = positions;\n  }\n\n  public static create(positions: Uint16Array, qparams: QParams3d) {\n    const posBuf = QBufferHandle3d.create(qparams, positions);\n    if (undefined === posBuf)\n      return undefined;\n\n    return new SkyBoxGeometryParams(posBuf);\n  }\n\n  public dispose() {\n    dispose(this.positions);\n  }\n}\n\n/** @internal */\nnamespace SkyBoxQuads {\n  let _skyBoxQuads: SkyBoxQuads | undefined;\n\n  export function getInstance(): SkyBoxQuads {\n    if (undefined === _skyBoxQuads)\n      _skyBoxQuads = new SkyBoxQuads();\n\n    return _skyBoxQuads;\n  }\n}\n\n/** Geometry used for view-space rendering techniques.\n * @internal\n */\nexport class SkyBoxQuadsGeometry extends CachedGeometry {\n  protected _techniqueId: TechniqueId;\n  public readonly cube: RenderTexture;\n  protected readonly _params: SkyBoxGeometryParams;\n\n  protected constructor(ndxGeomParams: SkyBoxGeometryParams, texture: RenderTexture) {\n    super();\n    this.cube = texture;\n    this._techniqueId = TechniqueId.SkyBox;\n    this._params = ndxGeomParams;\n  }\n\n  public static create(texture: RenderTexture): SkyBoxQuadsGeometry | undefined {\n    const sbxGeomParams = SkyBoxQuads.getInstance().createParams();\n    return undefined !== sbxGeomParams ? new SkyBoxQuadsGeometry(sbxGeomParams, texture) : undefined;\n  }\n\n  public collectStatistics(_stats: RenderMemory.Statistics): void {\n    // Not interested in tracking this.\n  }\n\n  public getTechniqueId(_target: Target) { return this._techniqueId; }\n  public getRenderPass(_target: Target) { return RenderPass.SkyBox; }\n  public get renderOrder() { return RenderOrder.Surface; }\n\n  public bindVertexArray(attr: AttributeHandle): void {\n    attr.enableArray(this._params.positions, 3, GL.DataType.UnsignedShort, false, 0, 0);\n  }\n\n  public draw(): void {\n    System.instance.context.drawArrays(GL.PrimitiveType.Triangles, 0, 36);\n  }\n\n  public get qOrigin() { return this._params.positions.origin; }\n  public get qScale() { return this._params.positions.scale; }\n\n  public dispose() {\n    dispose(this._params);\n  }\n\n  protected _wantWoWReversal(_target: Target): boolean { return false; }\n}\n\n/** A quad with its corners mapped to the dimensions as the viewport, used for special rendering techniques.\n * @internal\n */\nclass ViewportQuad {\n  public readonly vertices: Uint16Array;\n  public readonly vertexParams: QParams3d;\n  public readonly indices = new Uint32Array(6);\n\n  public constructor() {\n    const pt = new Point3d(-1, -1, 0);\n    const vertices = new QPoint3dList(QParams3d.fromNormalizedRange());\n    vertices.add(pt);\n    pt.x = 1;\n    vertices.add(pt);\n    pt.y = 1;\n    vertices.add(pt);\n    pt.x = -1;\n    vertices.add(pt);\n\n    this.vertices = vertices.toTypedArray();\n    this.vertexParams = vertices.params;\n\n    this.indices[0] = 0;\n    this.indices[1] = 1;\n    this.indices[2] = 2;\n    this.indices[3] = 0;\n    this.indices[4] = 2;\n    this.indices[5] = 3;\n  }\n\n  public createParams() {\n    return IndexedGeometryParams.create(this.vertices, this.vertexParams, this.indices);\n  }\n}\n\n/** @internal */\nnamespace ViewportQuad {\n  let _viewportQuad: ViewportQuad | undefined;\n\n  export function getInstance(): ViewportQuad {\n    if (undefined === _viewportQuad)\n      _viewportQuad = new ViewportQuad();\n\n    return _viewportQuad;\n  }\n}\n\n/** Geometry used for view-space rendering techniques.\n * @internal\n */\nexport class ViewportQuadGeometry extends IndexedGeometry {\n  protected _techniqueId: TechniqueId;\n\n  protected constructor(params: IndexedGeometryParams, techniqueId: TechniqueId) {\n    super(params);\n    this._techniqueId = techniqueId;\n  }\n  public static create(techniqueId: TechniqueId) {\n    const params = ViewportQuad.getInstance().createParams();\n    return undefined !== params ? new ViewportQuadGeometry(params, techniqueId) : undefined;\n  }\n\n  public getTechniqueId(_target: Target) { return this._techniqueId; }\n  public getRenderPass(_target: Target) { return RenderPass.OpaqueGeneral; }\n  public get renderOrder() { return RenderOrder.Surface; }\n\n  public collectStatistics(_stats: RenderMemory.Statistics): void {\n    // NB: These don't really count...\n  }\n}\n\n/** Geometry used for view-space rendering techniques which involve sampling one or more textures.\n * @internal\n */\nexport class TexturedViewportQuadGeometry extends ViewportQuadGeometry {\n  protected readonly _textures: WebGLTexture[];\n\n  protected constructor(params: IndexedGeometryParams, techniqueId: TechniqueId, textures: WebGLTexture[]) {\n    super(params, techniqueId);\n    this._textures = textures;\n\n    // TypeScript compiler will happily accept TextureHandle (or any other type) in place of WebGLTexture.\n    // There is no such 'type' as WebGLTexture at run-time.\n    assert(this._textures.every((tx) => !(tx instanceof TextureHandle)));\n  }\n}\n\n/** Geometry used for rendering default gradient-style or single texture spherical skybox.\n * @internal\n */\nexport class SkySphereViewportQuadGeometry extends ViewportQuadGeometry {\n  public worldPos: Float32Array; // LeftBottom, RightBottom, RightTop, LeftTop worl pos of frustum at mid depth.\n  public readonly typeAndExponents: Float32Array; // [0] -1.0 for 2-color gradient, 1.0 for 4-color gradient, 0.0 for texture; [1] sky exponent (4-color only) [2] ground exponent (4-color only)\n  public readonly zOffset: number;\n  public readonly rotation: number;\n  public readonly zenithColor: Float32Array;\n  public readonly skyColor: Float32Array;\n  public readonly groundColor: Float32Array;\n  public readonly nadirColor: Float32Array;\n  public readonly skyTexture?: RenderTexture;\n  protected readonly _worldPosBuff: BufferHandle;\n\n  protected constructor(params: IndexedGeometryParams, skybox: SkyBox.CreateParams, techniqueId: TechniqueId) {\n    super(params, techniqueId);\n\n    this.worldPos = new Float32Array(4 * 3);\n    this._worldPosBuff = new BufferHandle();\n    this.typeAndExponents = new Float32Array(3);\n    this.zenithColor = new Float32Array(3);\n    this.skyColor = new Float32Array(3);\n    this.groundColor = new Float32Array(3);\n    this.nadirColor = new Float32Array(3);\n    this.zOffset = skybox.zOffset;\n\n    const sphere = skybox.sphere;\n    this.rotation = undefined !== sphere ? sphere.rotation : 0.0;\n\n    if (undefined !== sphere) {\n      this.skyTexture = sphere.texture;\n      this.typeAndExponents[0] = 0.0;\n      this.typeAndExponents[1] = 1.0;\n      this.typeAndExponents[2] = 1.0;\n      this.zenithColor[0] = 0.0;\n      this.zenithColor[1] = 0.0;\n      this.zenithColor[2] = 0.0;\n      this.nadirColor[0] = 0.0;\n      this.nadirColor[1] = 0.0;\n      this.nadirColor[2] = 0.0;\n      this.skyColor[0] = 0.0;\n      this.skyColor[1] = 0.0;\n      this.skyColor[2] = 0.0;\n      this.groundColor[0] = 0.0;\n      this.groundColor[1] = 0.0;\n      this.groundColor[2] = 0.0;\n    } else {\n      const gradient = skybox.gradient!;\n\n      this.zenithColor[0] = gradient.zenithColor.colors.r / 255.0;\n      this.zenithColor[1] = gradient.zenithColor.colors.g / 255.0;\n      this.zenithColor[2] = gradient.zenithColor.colors.b / 255.0;\n      this.nadirColor[0] = gradient.nadirColor.colors.r / 255.0;\n      this.nadirColor[1] = gradient.nadirColor.colors.g / 255.0;\n      this.nadirColor[2] = gradient.nadirColor.colors.b / 255.0;\n\n      if (gradient.twoColor) {\n        this.typeAndExponents[0] = -1.0;\n        this.typeAndExponents[1] = 4.0;\n        this.typeAndExponents[2] = 4.0;\n        this.skyColor[0] = 0.0;\n        this.skyColor[1] = 0.0;\n        this.skyColor[2] = 0.0;\n        this.groundColor[0] = 0.0;\n        this.groundColor[1] = 0.0;\n        this.groundColor[2] = 0.0;\n      } else {\n        this.typeAndExponents[0] = 1.0;\n        this.typeAndExponents[1] = gradient.skyExponent;\n        this.typeAndExponents[2] = gradient.groundExponent;\n        this.skyColor[0] = gradient.skyColor.colors.r / 255.0;\n        this.skyColor[1] = gradient.skyColor.colors.g / 255.0;\n        this.skyColor[2] = gradient.skyColor.colors.b / 255.0;\n        this.groundColor[0] = gradient.groundColor.colors.r / 255.0;\n        this.groundColor[1] = gradient.groundColor.colors.g / 255.0;\n        this.groundColor[2] = gradient.groundColor.colors.b / 255.0;\n      }\n    }\n  }\n\n  public static createGeometry(skybox: SkyBox.CreateParams) {\n    const params = ViewportQuad.getInstance().createParams();\n    if (undefined === params)\n      return undefined;\n\n    const technique = undefined !== skybox.sphere ? TechniqueId.SkySphereTexture : TechniqueId.SkySphereGradient;\n    return new SkySphereViewportQuadGeometry(params, skybox, technique);\n  }\n\n  public get worldPosBuff() { return this._worldPosBuff; }\n\n  public bind() {\n    this._worldPosBuff.bindData(GL.Buffer.Target.ArrayBuffer, this.worldPos, GL.Buffer.Usage.StreamDraw);\n  }\n\n  public dispose() {\n    dispose(this._worldPosBuff);\n  }\n}\n\n/** Geometry used when rendering ambient occlusion information to an output texture\n * @internal\n */\nexport class AmbientOcclusionGeometry extends TexturedViewportQuadGeometry {\n  public static createGeometry(depthAndOrder: WebGLTexture) {\n    const params = ViewportQuad.getInstance().createParams();\n    if (undefined === params) {\n      return undefined;\n    }\n\n    // Will derive positions and normals from depthAndOrder.\n    return new AmbientOcclusionGeometry(params, [depthAndOrder]);\n  }\n\n  public get depthAndOrder() { return this._textures[0]; }\n  public get noise() { return System.instance.noiseTexture!.getHandle()!; }\n\n  private constructor(params: IndexedGeometryParams, textures: WebGLTexture[]) {\n    super(params, TechniqueId.AmbientOcclusion, textures);\n  }\n}\n\n/** @internal */\nexport class BlurGeometry extends TexturedViewportQuadGeometry {\n  public readonly blurDir: Vector2d;\n\n  public static createGeometry(texToBlur: WebGLTexture, depthAndOrder: WebGLTexture, blurDir: Vector2d) {\n    const params = ViewportQuad.getInstance().createParams();\n    if (undefined === params) {\n      return undefined;\n    }\n    return new BlurGeometry(params, [texToBlur, depthAndOrder], blurDir);\n  }\n\n  public get textureToBlur() { return this._textures[0]; }\n  public get depthAndOrder() { return this._textures[1]; }\n\n  private constructor(params: IndexedGeometryParams, textures: WebGLTexture[], blurDir: Vector2d) {\n    super(params, TechniqueId.Blur, textures);\n    this.blurDir = blurDir;\n  }\n}\n\n/** Geometry used during the 'composite' pass to apply transparency and/or hilite effects.\n * @internal\n */\nexport class CompositeGeometry extends TexturedViewportQuadGeometry {\n  public static createGeometry(opaque: WebGLTexture, accum: WebGLTexture, reveal: WebGLTexture, hilite: WebGLTexture) {\n    const params = ViewportQuad.getInstance().createParams();\n    if (undefined === params)\n      return undefined;\n\n    const textures = [opaque, accum, reveal, hilite];\n    return new CompositeGeometry(params, textures);\n  }\n\n  public get opaque() { return this._textures[0]; }\n  public get accum() { return this._textures[1]; }\n  public get reveal() { return this._textures[2]; }\n  public get hilite() { return this._textures[3]; }\n  public get occlusion(): WebGLTexture | undefined {\n    return this._textures.length > 4 ? this._textures[4] : undefined;\n  }\n  public set occlusion(occlusion: WebGLTexture | undefined) {\n    assert((undefined === occlusion) === (undefined !== this.occlusion));\n    if (undefined !== occlusion)\n      this._textures[4] = occlusion;\n    else\n      this._textures.length = 4;\n  }\n\n  // Invoked each frame to determine the appropriate Technique to use.\n  public update(flags: CompositeFlags): void { this._techniqueId = this.determineTechnique(flags); }\n\n  private determineTechnique(flags: CompositeFlags): TechniqueId {\n    return computeCompositeTechniqueId(flags);\n  }\n\n  private constructor(params: IndexedGeometryParams, textures: WebGLTexture[]) {\n    super(params, TechniqueId.CompositeHilite, textures);\n    assert(4 <= this._textures.length);\n  }\n}\n\n/** Geometry used to ping-pong the pick buffer data in between opaque passes.\n * @internal\n */\nexport class CopyPickBufferGeometry extends TexturedViewportQuadGeometry {\n  public static createGeometry(featureId: WebGLTexture, depthAndOrder: WebGLTexture) {\n    const params = ViewportQuad.getInstance().createParams();\n    if (undefined !== params) {\n      return new CopyPickBufferGeometry(params, [featureId, depthAndOrder]);\n    } else {\n      return undefined;\n    }\n  }\n\n  public get featureId() { return this._textures[0]; }\n  public get depthAndOrder() { return this._textures[1]; }\n\n  private constructor(params: IndexedGeometryParams, textures: WebGLTexture[]) {\n    super(params, TechniqueId.CopyPickBuffers, textures);\n  }\n}\nexport class CombineTexturesGeometry extends TexturedViewportQuadGeometry {\n  public static createGeometry(texture0: WebGLTexture, texture1: WebGLTexture) {\n    const params = ViewportQuad.getInstance().createParams();\n    if (undefined !== params) {\n      return new CombineTexturesGeometry(params, [texture0, texture1]);\n    } else {\n      return undefined;\n    }\n  }\n\n  public get texture0() { return this._textures[0]; }\n  public get texture1() { return this._textures[1]; }\n\n  private constructor(params: IndexedGeometryParams, textures: WebGLTexture[]) {\n    super(params, TechniqueId.CombineTextures, textures);\n  }\n}\n\n/** @internal */\nexport class SingleTexturedViewportQuadGeometry extends TexturedViewportQuadGeometry {\n  public static createGeometry(texture: WebGLTexture, techId: TechniqueId) {\n    const params = ViewportQuad.getInstance().createParams();\n    if (undefined === params) {\n      return undefined;\n    }\n\n    return new SingleTexturedViewportQuadGeometry(params, texture, techId);\n  }\n\n  public get texture(): WebGLTexture { return this._textures[0]; }\n  public set texture(texture: WebGLTexture) { this._textures[0] = texture; }\n\n  protected constructor(params: IndexedGeometryParams, texture: WebGLTexture, techId: TechniqueId) {\n    super(params, techId, [texture]);\n  }\n}\n\n/** @internal */\nexport class PolylineBuffers implements IDisposable {\n  public indices: BufferHandle;\n  public prevIndices: BufferHandle;\n  public nextIndicesAndParams: BufferHandle;\n  private constructor(indices: BufferHandle, prevIndices: BufferHandle, nextIndicesAndParams: BufferHandle) {\n    this.indices = indices;\n    this.prevIndices = prevIndices;\n    this.nextIndicesAndParams = nextIndicesAndParams;\n  }\n\n  public static create(polyline: TesselatedPolyline): PolylineBuffers | undefined {\n    const indices = BufferHandle.createArrayBuffer(polyline.indices.data);\n    const prev = BufferHandle.createArrayBuffer(polyline.prevIndices.data);\n    const next = BufferHandle.createArrayBuffer(polyline.nextIndicesAndParams);\n\n    return undefined !== indices && undefined !== prev && undefined !== next ? new PolylineBuffers(indices, prev, next) : undefined;\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics, type: RenderMemory.BufferType): void {\n    stats.addBuffer(type, this.indices.bytesUsed + this.prevIndices.bytesUsed + this.nextIndicesAndParams.bytesUsed);\n  }\n\n  public dispose() {\n    dispose(this.indices);\n    dispose(this.prevIndices);\n    dispose(this.nextIndicesAndParams);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { dispose, assert } from \"@bentley/bentleyjs-core\";\nimport { ClipVector, Point3d, ClipUtilities, Triangulator, PolyfaceBuilder, IndexedPolyfaceVisitor, UnionOfConvexClipPlaneSets, Vector3d, StrokeOptions, Transform } from \"@bentley/geometry-core\";\nimport { QPoint3dList, Frustum, QParams3d } from \"@bentley/imodeljs-common\";\nimport { ShaderProgramExecutor } from \"./ShaderProgram\";\nimport { Target } from \"./Target\";\nimport { RenderMemory, RenderClipVolume, ClippingType } from \"../System\";\nimport { ClipMaskGeometry } from \"./CachedGeometry\";\nimport { ViewRect } from \"../../Viewport\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { TextureHandle, Texture2DData, Texture2DHandle } from \"./Texture\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\nimport { RenderState } from \"./RenderState\";\nimport { DrawParams } from \"./DrawCommand\";\n\n/** @internal */\ninterface ClipPlaneSets {\n  readonly planes: UnionOfConvexClipPlaneSets;\n  readonly numPlanes: number;\n  readonly numSets: number;\n}\n\n/** @internal */\ninterface ClipPlaneTexture {\n  readonly handle: Texture2DHandle;\n  readonly data: Texture2DData;\n}\n\n/** Maintains a texture representing clipping planes. Updated when view matrix changes.\n * @internal\n */\nabstract class ClippingPlanes {\n  /** Most recently-applied view matrix. */\n  private readonly _transform = Transform.createZero();\n  private readonly _texture: ClipPlaneTexture;\n  private readonly _planes: ClipPlaneSets;\n  /** Used for writing to texture data. */\n  private readonly _view: DataView;\n  /** Position at which to write next texture data. */\n  private _curPos: number = 0;\n\n  public static create(planes: ClipPlaneSets): ClippingPlanes | undefined {\n    return System.instance.capabilities.supportsTextureFloat ? FloatPlanes.create(planes) : PackedPlanes.create(planes);\n  }\n\n  public dispose(): void {\n    dispose(this._texture.handle);\n  }\n\n  public get bytesUsed(): number { return this._texture.handle.bytesUsed; }\n\n  public getTexture(transform: Transform): Texture2DHandle {\n    if (transform.isAlmostEqual(this._transform))\n      return this._texture.handle;\n\n    this.reset();\n    transform.clone(this._transform);\n\n    // Avoid allocations inside loop...\n    const pInwardNormal = new Vector3d();\n    const dir = new Vector3d();\n    const pos = new Point3d();\n    const v0 = new Vector3d();\n\n    let numSetsProcessed = 0;\n    for (const set of this._planes.planes.convexSets) {\n      if (set.planes.length === 0)\n        continue;\n\n      for (const plane of set.planes) {\n        plane.inwardNormalRef.clone(pInwardNormal);\n        let pDistance = plane.distance;\n\n        // Transform direction of clip plane\n        const norm = pInwardNormal;\n        transform.matrix.multiplyVector(norm, dir);\n        dir.normalizeInPlace();\n\n        // Transform distance of clip plane\n        transform.multiplyPoint3d(norm.scale(pDistance, v0), pos);\n        v0.setFromPoint3d(pos);\n\n        pInwardNormal.set(dir.x, dir.y, dir.z);\n        pDistance = -v0.dotProduct(dir);\n\n        // The plane has been transformed into view space\n        this.appendPlane(pInwardNormal, pDistance);\n      }\n\n      if (++numSetsProcessed < this._planes.numSets)\n        this.appendZeroPlane();\n    }\n\n    this._texture.handle.replaceTextureData(this._texture.data);\n    return this._texture.handle;\n  }\n\n  /** Exposed for testing purposes. */\n  public getTextureData(transform: Transform): Texture2DData {\n    this.getTexture(transform);\n    return this._texture.data;\n  }\n\n  protected constructor(planes: ClipPlaneSets, texture: ClipPlaneTexture) {\n    this._texture = texture;\n    this._planes = planes;\n    this._view = new DataView(texture.data.buffer);\n  }\n\n  protected abstract append(value: number): void;\n\n  protected appendFloat(value: number): void { this._view.setFloat32(this._curPos, value, true); this.advance(4); }\n  protected appendUint8(value: number): void { this._view.setUint8(this._curPos, value); this.advance(1); }\n\n  private advance(numBytes: number): void { this._curPos += numBytes; }\n  private reset(): void { this._curPos = 0; }\n\n  private appendValues(a: number, b: number, c: number, d: number) {\n    this.append(a);\n    this.append(b);\n    this.append(c);\n    this.append(d);\n  }\n\n  private appendPlane(normal: Vector3d, distance: number): void { this.appendValues(normal.x, normal.y, normal.z, distance); }\n  private appendZeroPlane(): void { this.appendValues(0, 0, 0, 0); }\n}\n\n/** Stores clip planes in floating-point texture.\n * @internal\n */\nclass FloatPlanes extends ClippingPlanes {\n  public static create(planes: ClipPlaneSets): ClippingPlanes | undefined {\n    const totalNumPlanes = planes.numPlanes + planes.numSets - 1;\n    const data = new Float32Array(totalNumPlanes * 4);\n    const handle = Texture2DHandle.createForData(1, totalNumPlanes, data, false, GL.Texture.WrapMode.ClampToEdge, GL.Texture.Format.Rgba);\n    return undefined !== handle ? new FloatPlanes(planes, { handle, data }) : undefined;\n  }\n\n  protected append(value: number) { this.appendFloat(value); }\n\n  private constructor(planes: ClipPlaneSets, texture: ClipPlaneTexture) { super(planes, texture); }\n}\n\n/** Stores clip planes packed into RGBA texture.\n * @internal\n */\nclass PackedPlanes extends ClippingPlanes {\n  public static create(planes: ClipPlaneSets): ClippingPlanes | undefined {\n    const totalNumPlanes = planes.numPlanes + planes.numSets - 1;\n    const data = new Uint8Array(totalNumPlanes * 4 * 4);\n    const handle = Texture2DHandle.createForData(4, totalNumPlanes, data, false, GL.Texture.WrapMode.ClampToEdge, GL.Texture.Format.Rgba);\n    return undefined !== handle ? new PackedPlanes(planes, { handle, data }) : undefined;\n  }\n\n  protected append(value: number) {\n    const sign = value < 0 ? 1 : 0;\n    value = Math.abs(value);\n    const exponent = Math.floor(Math.log10(value)) + 1;\n    value = value / Math.pow(10, exponent);\n\n    const bias = 38;\n    let temp = value * 256;\n    const b0 = Math.floor(temp);\n    temp = (temp - b0) * 256;\n    const b1 = Math.floor(temp);\n    temp = (temp - b1) * 256;\n    const b2 = Math.floor(temp);\n    const b3 = (exponent + bias) * 2 + sign;\n\n    this.appendUint8(b0);\n    this.appendUint8(b1);\n    this.appendUint8(b2);\n    this.appendUint8(b3);\n  }\n\n  private constructor(planes: ClipPlaneSets, texture: ClipPlaneTexture) { super(planes, texture); }\n}\n\n/** A 3D clip volume defined as a texture derived from a set of planes.\n * @internal\n */\nexport class ClipPlanesVolume extends RenderClipVolume implements RenderMemory.Consumer {\n  private _planes?: ClippingPlanes; // not read-only because dispose()...\n\n  private constructor(clip: ClipVector, planes?: ClippingPlanes) {\n    super(clip);\n    this._planes = planes;\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    if (undefined !== this._planes)\n      stats.addClipVolume(this._planes.bytesUsed);\n  }\n\n  public get type(): ClippingType { return ClippingType.Planes; }\n\n  /** Create a new ClipPlanesVolume from a ClipVector.\n   * * The result is undefined if\n   *   * (a) there is more than one clipper\n   *   * (b) the clipper does not have clipPlaneSet (for instance, a pure mask clipper has mask planes but not primary clip planes)\n   */\n  public static create(clipVec: ClipVector): ClipPlanesVolume | undefined {\n    if (1 !== clipVec.clips.length)\n      return undefined;\n\n    const clipPrim = clipVec.clips[0];\n    const clipPlaneSet = clipPrim.fetchClipPlanesRef();\n    return undefined !== clipPlaneSet ? ClipPlanesVolume.createFromClipPlaneSet(clipPlaneSet, clipVec) : undefined;\n  }\n\n  private static createFromClipPlaneSet(clipPlaneSet: UnionOfConvexClipPlaneSets, clip: ClipVector) {\n    let numPlanes = 0;\n    let numSets = 0;\n    for (const set of clipPlaneSet.convexSets) {\n      const setLength = set.planes.length;\n      if (setLength !== 0) {\n        numSets++;\n        numPlanes += setLength;\n      }\n    }\n    if (numPlanes === 0)\n      return undefined;\n\n    const planes = ClippingPlanes.create({ planes: clipPlaneSet, numPlanes, numSets });\n    return new ClipPlanesVolume(clip, planes);\n  }\n\n  public dispose() {\n    this._planes = dispose(this._planes);\n  }\n\n  /** Push this ClipPlanesVolume clipping onto a target. */\n  public pushToTarget(target: Target) {\n    if (undefined !== this._planes) {\n      const texture = this._planes.getTexture(target.viewMatrix);\n      target.clips.set(texture.height, texture);\n    }\n  }\n\n  /** Push this ClipPlanesVolume clipping onto the target of a shader program executor. */\n  public pushToShaderExecutor(shader: ShaderProgramExecutor) {\n    this.pushToTarget(shader.target);\n  }\n\n  /** Pop this ClipPlanesVolume clipping from a target. */\n  public pop(target: Target) {\n    target.clips.clear();\n  }\n\n  /** Exposed for testing purposes. */\n  public getTextureData(transform = Transform.identity): Float32Array | Uint8Array | undefined {\n    return undefined !== this._planes ? this._planes.getTextureData(transform) : undefined;\n  }\n}\n\n/** A 2D clip volume defined as a texture derived from a masked set of planes.\n * @internal\n */\nexport class ClipMaskVolume extends RenderClipVolume implements RenderMemory.Consumer {\n  public readonly geometry: ClipMaskGeometry;\n  public readonly frustum: Frustum;\n  public readonly rect: ViewRect;\n  private _texture?: TextureHandle;\n  private _fbo?: FrameBuffer;\n\n  private constructor(geometry: ClipMaskGeometry, clip: ClipVector) {\n    super(clip);\n    this.geometry = geometry;\n    this.frustum = new Frustum();\n    this.rect = new ViewRect(0, 0, 0, 0);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    this.geometry.collectStatistics(stats);\n    if (undefined !== this._texture)\n      stats.addClipVolume(this._texture.bytesUsed);\n  }\n\n  public get type(): ClippingType { return ClippingType.Mask; }\n\n  /** Create a new ClipMaskVolume from a clip vector. */\n  public static create(clipVec: ClipVector): ClipMaskVolume | undefined {\n    const range = clipVec.boundingRange;\n    if (range.isNull)\n      return undefined;\n\n    const pts: Point3d[] = [\n      Point3d.create(range.low.x, range.low.y, 0),\n      Point3d.create(range.high.x, range.low.y, 0),\n      Point3d.create(range.high.x, range.high.y, 0),\n      Point3d.create(range.low.x, range.high.y, 0),\n    ];\n\n    // Clip the polygon into smaller polygons inside the clipping region\n    const clippedPolygonInsides = ClipUtilities.clipPolygonToClipShape(pts, clipVec.clips[0]);  // ### TODO: Currently assume that there is only one shape...\n    const indices: number[] = [];\n    const vertices = QPoint3dList.createFrom([], QParams3d.fromRange(range));\n\n    const strokeOptions = new StrokeOptions();\n    strokeOptions.shouldTriangulate = true;\n    const polyfaceBuilder = PolyfaceBuilder.create(strokeOptions);\n    for (const clippedPolygon of clippedPolygonInsides) {\n      if (clippedPolygon.length < 3) {\n        continue;\n      } else if (clippedPolygon.length === 3) {\n        polyfaceBuilder.addTriangleFacet(clippedPolygon);\n\n      } else if (clippedPolygon.length === 4) {\n        polyfaceBuilder.addQuadFacet(clippedPolygon);\n\n      } else if (clippedPolygon.length > 4) {\n        // Clipped polygon must be triangulated before appending\n        const triangulatedPolygonGraph = Triangulator.createTriangulatedGraphFromSingleLoop(clippedPolygon);\n        Triangulator.flipTriangles(triangulatedPolygonGraph);\n        polyfaceBuilder.addGraph(triangulatedPolygonGraph, false);\n      }\n    }\n    const polyface = polyfaceBuilder.claimPolyface();\n    const nPoints = polyface.pointCount;\n    const pPoints = polyface.data.point;\n    assert(nPoints !== 0);\n\n    for (let i = 0; i < nPoints; i++)\n      vertices.add(pPoints.getPoint3dAtUncheckedPointIndex(i));\n\n    const visitor = IndexedPolyfaceVisitor.create(polyface, 0);\n    while (visitor.moveToNextFacet())\n      for (let i = 0; i < 3; i++)\n        indices.push(visitor.clientPointIndex(i));\n\n    assert(indices.length > 0);\n    if (indices.length === 0 || vertices.length === 0)\n      return undefined;\n\n    return new ClipMaskVolume(new ClipMaskGeometry(new Uint32Array(indices), vertices), clipVec);\n  }\n\n  public get texture(): TextureHandle | undefined { return this._texture; }\n  public get fbo(): FrameBuffer | undefined { return this._fbo; }\n\n  public dispose() {\n    this._texture = dispose(this._texture);\n    this._fbo = dispose(this._fbo);\n  }\n\n  /** Push this ClipMaskVolume clipping onto a target. */\n  public pushToTarget(_target: Target) { assert(false); }\n\n  /** Push this ClipMaskVolume clipping onto the target of a program executor. */\n  public pushToShaderExecutor(shader: ShaderProgramExecutor) {\n    const texture = this.getTexture(shader);\n    if (texture !== undefined)\n      shader.target.clipMask = texture;\n  }\n\n  /** Pop this ClipMaskVolume clipping from a target. */\n  public pop(target: Target) {\n    if (target.is2d && this._texture !== undefined)\n      target.clipMask = undefined;\n  }\n\n  /** Update the clip mask using the shader executor's target and return the resulting texture. */\n  public getTexture(exec: ShaderProgramExecutor): TextureHandle | undefined {\n    const target = exec.target;\n    if (!target.is2d)\n      return undefined;\n\n    const frust = target.planFrustum;\n    const rect = target.viewRect;\n    const frustumChanged = !this.frustum.equals(frust);\n    const textureChanged = this._texture === undefined || this.rect.width !== rect.width || this.rect.height !== rect.height;\n\n    if (textureChanged) {\n      this.dispose();\n      this._texture = TextureHandle.createForAttachment(rect.width, rect.height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n      if (this._texture !== undefined)\n        this._fbo = FrameBuffer.create([this._texture]);\n    }\n\n    this.rect.init(rect.left, rect.top, rect.right, rect.bottom);\n    if (textureChanged || frustumChanged) {\n      this.frustum.setFrom(frust);\n      this.render(exec);\n    }\n\n    return this._texture;\n  }\n\n  private static _drawParams?: DrawParams;\n\n  public render(exec: ShaderProgramExecutor) {\n    if (this._fbo === undefined)\n      return;\n\n    const state = new RenderState();\n    state.flags.depthMask = false;\n    state.flags.blend = false;\n    state.flags.depthTest = false;\n\n    // Render clip geometry as a mask\n    System.instance.frameBufferStack.execute(this._fbo, true, () => {\n      const prevState = System.instance.currentRenderState.clone();\n      const target = exec.target;\n      System.instance.applyRenderState(state);\n\n      const context = System.instance.context;\n      context.clearColor(0, 0, 0, 0);\n      context.clear(context.COLOR_BUFFER_BIT);\n\n      if (undefined === ClipMaskVolume._drawParams)\n        ClipMaskVolume._drawParams = new DrawParams();\n\n      const params = ClipMaskVolume._drawParams!;\n      params.init(exec.params, this.geometry, target.currentTransform);\n      exec.drawInterrupt(params);\n\n      // Restore previous render state\n      System.instance.applyRenderState(prevState);\n    });\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ColorIndex, ColorDef } from \"@bentley/imodeljs-common\";\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { FloatPreMulRgba } from \"./FloatRGBA\";\nimport { VertexTable } from \"../primitives/VertexTable\";\n\n/* Describes a primitive's basic color properties\n * @internal\n */\nexport class ColorInfo {\n  private readonly _uniform?: FloatPreMulRgba;\n  public readonly hasTranslucency: boolean;\n\n  private constructor(hasTranslucency: boolean, uniform?: FloatPreMulRgba) {\n    this.hasTranslucency = hasTranslucency;\n    this._uniform = uniform;\n  }\n\n  public static createUniform(color: FloatPreMulRgba) { return new ColorInfo(color.hasTranslucency, color); }\n  public static createNonUniform(hasTranslucency: boolean) { return hasTranslucency ? this._nonUniformTranslucent : this._nonUniformOpaque; }\n  public static createFromColorDef(color: ColorDef) { return this.createUniform(FloatPreMulRgba.fromColorDef(color)); }\n\n  public static createFromColorIndex(colorIndex: ColorIndex) {\n    return undefined !== colorIndex.uniform ? this.createFromColorDef(colorIndex.uniform) : this.createNonUniform(colorIndex.hasAlpha);\n  }\n\n  public static createFromVertexTable(vt: VertexTable) {\n    return undefined !== vt.uniformColor ? this.createFromColorDef(vt.uniformColor) : this.createNonUniform(vt.hasTranslucency);\n  }\n\n  public get isUniform() { return undefined !== this._uniform; }\n  public get isNonUniform() { return !this.isUniform; }\n  public get uniform(): FloatPreMulRgba { assert(this.isUniform); return this._uniform!; }\n\n  private static _nonUniformTranslucent = new ColorInfo(true);\n  private static _nonUniformOpaque = new ColorInfo(false);\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module WebGL */\r\n\r\nimport { GL } from \"./GL\";\r\nimport { System } from \"./System\";\r\n\r\n/** Provides facilities for conditionally executing diagnostic/debug code. By default, all facilities are disabled - they must be explicitly enabled.\r\n * @internal\r\n */\r\nexport class Debug {\r\n  /** Whether [[Debug.print]] will actually produce output. */\r\n  public static printEnabled = false;\r\n  /** Whether [[Debug.evaluate]] will actually evaluate an expression. */\r\n  public static evaluateEnabled = false;\r\n\r\n  /** If [[Debug.printEnabled]] is true, outputs a message using `console.log`.\r\n   * @param message A function which returns a string. If [[Debug.printEnabled]] is false, the function is never evaluated.\r\n   */\r\n  public static print(message: () => string): void {\r\n    if (this.printEnabled)\r\n      console.log(message()); // tslint:disable-line:no-console\r\n  }\r\n\r\n  /** If [[Debug.evaluate]] is true, executes the supplied function and returns its result; otherwise returns the supplied default value.\r\n   * @param evaluate The function to execute\r\n   * @param defaultValue The value to return if [[Debug.evaluate]] is false\r\n   * @returns The return value of `evaluate` if [[Debug.evaluate]] is true; otherwise, the `defaultValue`.\r\n   */\r\n  public static evaluate<T>(evaluate: () => T, defaultValue: T): T {\r\n    return this.evaluateEnabled ? evaluate() : defaultValue;\r\n  }\r\n\r\n  /** If [[Debug.evaluateEnabled]] is true, returns whether the currently-bound framebuffer is complete. */\r\n  public static get isValidFrameBuffer(): boolean { return GL.FrameBuffer.Status.Complete === this.checkFrameBufferStatus(); }\r\n\r\n  /** If [[Debug.evaluateEnabled]] is true, returns the status of the currently-bound framebuffer. */\r\n  public static checkFrameBufferStatus(): GL.FrameBuffer.Status {\r\n    return this.evaluate(() => System.instance.context.checkFramebufferStatus(GL.FrameBuffer.TARGET), GL.FrameBuffer.Status.Complete);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { Matrix4 } from \"./Matrix\";\nimport { CachedGeometry } from \"./CachedGeometry\";\nimport { Transform, Range3d } from \"@bentley/geometry-core\";\nimport { Id64, Id64String, assert } from \"@bentley/bentleyjs-core\";\nimport { FeatureIndexType, RenderMode, ViewFlags, Frustum, FrustumPlanes } from \"@bentley/imodeljs-common\";\nimport { System } from \"./System\";\nimport { Batch, Branch, Graphic, GraphicsArray } from \"./Graphic\";\nimport { Primitive } from \"./Primitive\";\nimport { ShaderProgramExecutor } from \"./ShaderProgram\";\nimport { RenderPass, RenderOrder, CompositeFlags } from \"./RenderFlags\";\nimport { Target } from \"./Target\";\nimport { BranchStack, BatchState } from \"./BranchState\";\nimport { GraphicList, Decorations, RenderGraphic, AnimationBranchState, ClippingType } from \"../System\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { SurfaceType } from \"../primitives/VertexTable\";\nimport { MeshGraphic } from \"./Mesh\";\nimport { ClipPlanesVolume } from \"./ClipVolume\";\n\n// tslint:disable:no-const-enum\n\n/** @internal */\nexport class ShaderProgramParams {\n  private _target?: Target;\n  private _renderPass: RenderPass = RenderPass.None;\n  private readonly _projectionMatrix: Matrix4 = new Matrix4();\n  private readonly _viewMatrix = new Matrix4();\n\n  public get target(): Target { assert(undefined !== this._target); return this._target!; }\n  public get renderPass() { return this._renderPass; }\n  public get projectionMatrix() { return this._projectionMatrix; }\n  public get viewMatrix() { return this._viewMatrix; }\n\n  public get isViewCoords() { return RenderPass.ViewOverlay === this.renderPass || RenderPass.Background === this.renderPass; }\n  public get isOverlayPass() { return RenderPass.WorldOverlay === this.renderPass || RenderPass.ViewOverlay === this.renderPass; }\n  public get context() { return System.instance.context; }\n\n  public init(target: Target, pass: RenderPass = RenderPass.OpaqueGeneral) {\n    this._renderPass = pass;\n    this._target = target;\n    if (this.isViewCoords) {\n      const rect = target.viewRect;\n      Matrix4.fromOrtho(0.0, rect.width, rect.height, 0.0, -1.0, 1.0, this._projectionMatrix);\n    } else {\n      Matrix4.fromMatrix4d(target.projectionMatrix, this._projectionMatrix);\n    }\n\n    Matrix4.fromTransform(this.target.viewMatrix, this._viewMatrix);\n  }\n}\n\nconst _scratchTransform = Transform.createIdentity();\n\n/** @internal */\nexport class DrawParams {\n  private _programParams?: ShaderProgramParams;\n  private _geometry?: CachedGeometry;\n  private readonly _modelViewMatrix = new Matrix4();\n  private readonly _modelMatrix = new Matrix4();\n\n  public get geometry(): CachedGeometry { assert(undefined !== this._geometry); return this._geometry!; }\n  public get programParams(): ShaderProgramParams { assert(undefined !== this._programParams); return this._programParams!; }\n  public get modelViewMatrix() { return this._modelViewMatrix; }\n\n  // Used strictly by planar classification shaders - otherwise not necessarily initialized!\n  public get modelMatrix() { return this._modelMatrix; }\n\n  public get target() { return this.programParams.target; }\n  public get renderPass() { return this.programParams.renderPass; }\n  public get projectionMatrix() { return this.programParams.projectionMatrix; }\n  public get viewMatrix() { return this.programParams.viewMatrix; }\n  public get isViewCoords() { return this.programParams.isViewCoords; }\n  public get isOverlayPass() { return this.programParams.isOverlayPass; }\n  public get context() { return this.programParams.context; }\n\n  public init(programParams: ShaderProgramParams, geometry: CachedGeometry, modelMatrix: Transform = Transform.identity, pass?: RenderPass) {\n    this._programParams = programParams;\n    if (undefined === pass)\n      pass = programParams.renderPass;\n    else\n      assert(pass === this.programParams.renderPass);\n\n    this._geometry = geometry;\n    if (this.isViewCoords) {\n      // Zero out Z for silly clipping tools...\n      const tf = modelMatrix.clone(_scratchTransform);\n      tf.matrix.coffs[2] = tf.matrix.coffs[5] = tf.matrix.coffs[8] = 0.0;\n      Matrix4.fromTransform(tf, this._modelViewMatrix);\n    } else {\n      let modelViewMatrix = this.target.viewMatrix.clone(_scratchTransform);\n\n      // For instanced geometry, the \"model view\" matrix is really a transform from center of instanced geometry range to view.\n      // Shader will compute final model-view matrix based on this and the per-instance transform.\n      const instancedGeom = geometry.asInstanced;\n      if (undefined !== instancedGeom) {\n        modelViewMatrix = modelViewMatrix.multiplyTransformTransform(instancedGeom.getRtcTransform(modelMatrix), modelViewMatrix);\n      } else {\n        Matrix4.fromTransform(modelMatrix, this._modelMatrix);\n        modelViewMatrix = modelViewMatrix.multiplyTransformTransform(modelMatrix, modelViewMatrix);\n      }\n\n      Matrix4.fromTransform(modelViewMatrix, this._modelViewMatrix);\n    }\n  }\n}\n\n/** Defines operation associated with pushing or popping a branch\n * @internal\n */\nexport const enum PushOrPop {\n  Push,\n  Pop,\n}\n\n/**\n * Represents a command to be executed within a RenderPass. The most common command is\n * to draw a primitive; others involve state changes such as pushing/popping transforms\n * and symbology overrides, which require that commands be executed in order.\n * @internal\n */\nexport const enum OmitStatus {\n  Neutral = 0,\n  Begin = 1,\n  End = -1,\n}\n\n/** @internal */\nexport abstract class DrawCommand {\n  public preExecute(_exec: ShaderProgramExecutor): void { }\n  public abstract execute(_exec: ShaderProgramExecutor): void;\n  public postExecute(_exec: ShaderProgramExecutor): void { }\n\n  public get primitive(): Primitive | undefined { return undefined; }\n  public get branch(): Branch | undefined { return undefined; }\n  public get pushOrPop(): PushOrPop | undefined { return undefined; }\n\n  public get isPrimitiveCommand(): boolean { return undefined !== this.primitive; }\n  public get featureIndexType(): FeatureIndexType { return undefined !== this.primitive ? this.primitive.featureIndexType : FeatureIndexType.Empty; }\n  public get hasFeatureOverrides(): boolean { return FeatureIndexType.Empty !== this.featureIndexType; }\n  public get renderOrder(): RenderOrder { return undefined !== this.primitive ? this.primitive.renderOrder : RenderOrder.BlankingRegion; }\n  public get hasAnimation(): boolean { return undefined !== this.primitive ? this.primitive.hasAnimation : false; }\n  public get isInstanced(): boolean { return undefined !== this.primitive ? this.primitive.isInstanced : false; }\n  public getRenderPass(target: Target): RenderPass { return undefined !== this.primitive ? this.primitive.getRenderPass(target) : RenderPass.None; }\n  public getTechniqueId(target: Target): TechniqueId { return undefined !== this.primitive ? this.primitive.getTechniqueId(target) : TechniqueId.Invalid; }\n  public getOmitStatus(_target: Target) { return OmitStatus.Neutral; }\n\n  public isPushCommand(branch?: Branch) {\n    return PushOrPop.Push === this.pushOrPop && (undefined === branch || this.branch === branch);\n  }\n  public isPopCommand(branch?: Branch) {\n    return PushOrPop.Pop === this.pushOrPop && (undefined === branch || this.branch === branch);\n  }\n\n  public static createForBranch(branch: Branch, pushOrPop: PushOrPop): DrawCommand { return new BranchCommand(branch, pushOrPop); }\n  public static createForPrimitive(primitive: Primitive, batch?: Batch): DrawCommand {\n    return undefined !== batch ? new BatchPrimitiveCommand(primitive, batch) : new PrimitiveCommand(primitive);\n  }\n}\n\nclass BranchCommand extends DrawCommand {\n  private readonly _branch: Branch;\n  private readonly _pushOrPop: PushOrPop;\n\n  public get branch(): Branch { return this._branch; }\n  public get pushOrPop(): PushOrPop { return this._pushOrPop; }\n\n  public constructor(branch: Branch, pushOrPop: PushOrPop) {\n    super();\n    this._branch = branch;\n    this._pushOrPop = pushOrPop;\n  }\n  private getAnimationBranch(target: Target): AnimationBranchState | undefined {\n    return (this._branch.branch.animationId && target.animationBranches) ? target.animationBranches.get(this._branch.branch.animationId) : undefined;\n  }\n\n  public getOmitStatus(target: Target): OmitStatus {\n    const animationBranch = this.getAnimationBranch(target);\n    return (animationBranch && animationBranch.omit) ? (this._pushOrPop === PushOrPop.Push ? OmitStatus.Begin : OmitStatus.End) : OmitStatus.Neutral;\n  }\n\n  public preExecute(_exec: ShaderProgramExecutor): void {\n    const animationBranch = this.getAnimationBranch(_exec.target);\n    if (animationBranch) {\n      if (animationBranch.transform) {\n        let branchTransform = animationBranch.transform;\n        const prevLocalToWorld = _exec.target.currentTransform;\n        const prevWorldToLocal = prevLocalToWorld.inverse();\n        if (prevLocalToWorld && prevWorldToLocal)\n          branchTransform = prevWorldToLocal.multiplyTransformTransform(branchTransform.multiplyTransformTransform(prevLocalToWorld));\n        this._branch.localToWorldTransform = branchTransform;\n      }\n      if (animationBranch.clip !== undefined && animationBranch.clip.type === ClippingType.Planes)\n        this._branch.clips = animationBranch.clip as ClipPlanesVolume;\n    }\n  }\n\n  public execute(exec: ShaderProgramExecutor): void {\n    if (PushOrPop.Push === this._pushOrPop) {\n      exec.pushBranch(this._branch);\n    } else {\n      exec.popBranch();\n    }\n  }\n}\n\n/** Draw a primitive with no symbology overrides */\nclass PrimitiveCommand extends DrawCommand {\n  private readonly _primitive: Primitive;\n\n  public constructor(primitive: Primitive) {\n    super();\n    this._primitive = primitive;\n  }\n\n  public get primitive(): Primitive { return this._primitive; }\n\n  public execute(exec: ShaderProgramExecutor): void {\n    if (!System.instance.options.cullAgainstActiveVolume || !exec.target.isGeometryOutsideActiveVolume(this._primitive.cachedGeometry))\n      this._primitive.draw(exec);\n  }\n}\n\n/** Draw a batch primitive, possibly with symbology overridden per-feature\n * @internal\n */\nexport class BatchPrimitiveCommand extends PrimitiveCommand {\n  private readonly _batch: Batch;\n\n  public constructor(primitive: Primitive, batch: Batch) {\n    super(primitive);\n    this._batch = batch;\n  }\n\n  public preExecute(exec: ShaderProgramExecutor): void {\n    exec.target.pushBatch(this._batch);\n  }\n  public postExecute(exec: ShaderProgramExecutor): void {\n    exec.target.popBatch();\n  }\n\n  public computeIsFlashed(flashedId: Id64String): boolean {\n    // ###TODO Can this be done in a less-ugly way? It's trying to determine if the batch's graphic is a classification primitive.\n    const sp = this.primitive.cachedGeometry.asSurface;\n    if (undefined !== sp && undefined !== sp.mesh.features && sp.mesh.features.isUniform) {\n      const fi = sp.mesh.features.uniform!;\n      const featureElementId = this._batch.featureTable.findElementId(fi);\n      if (undefined !== featureElementId)\n        return featureElementId.toString() === flashedId.toString();\n    }\n\n    return Id64.isInvalid(flashedId);\n  }\n}\n\n/** For a single RenderPass, an ordered list of commands to be executed during that pass.\n * @internal\n */\nexport type DrawCommands = DrawCommand[];\n\n/** A list of DrawCommands to be rendered, ordered by render pass.\n * @internal\n */\nexport class RenderCommands {\n  private _frustumPlanes?: FrustumPlanes;\n  private readonly _scratchFrustum = new Frustum();\n  private readonly _scratchRange = new Range3d();\n  private readonly _commands: DrawCommands[];\n  private readonly _stack: BranchStack; // refers to the Target's BranchStack\n  private readonly _batchState: BatchState; // refers to the Target's BatchState\n  private _forcedRenderPass: RenderPass = RenderPass.None;\n  private _opaqueOverrides: boolean = false;\n  private _translucentOverrides: boolean = false;\n  private _addTranslucentAsOpaque: boolean = false; // true when rendering for _ReadPixels to force translucent items to be drawn in opaque pass.\n  public readonly target: Target;\n\n  public get isEmpty(): boolean {\n    for (const commands of this._commands)\n      if (0 < commands.length)\n        return false;\n\n    return true;\n  }\n\n  public get currentViewFlags(): ViewFlags { return this._stack.top.viewFlags; }\n  public get compositeFlags(): CompositeFlags {\n    let flags = CompositeFlags.None;\n    if (this.hasCommands(RenderPass.Translucent))\n      flags |= CompositeFlags.Translucent;\n\n    if (this.hasCommands(RenderPass.Hilite) || this.hasCommands(RenderPass.HiliteClassification) || this.hasCommands(RenderPass.HilitePlanarClassification))\n      flags |= CompositeFlags.Hilite;\n\n    if (this.target.wantAmbientOcclusion)\n      flags |= CompositeFlags.AmbientOcclusion;\n\n    return flags;\n  }\n\n  private get _curBatch(): Batch | undefined { return this._batchState.currentBatch; }\n\n  public hasCommands(pass: RenderPass): boolean { return 0 !== this.getCommands(pass).length; }\n  public isOpaquePass(pass: RenderPass): boolean { return pass >= RenderPass.OpaqueLinear && pass <= RenderPass.OpaqueGeneral; }\n\n  constructor(target: Target, stack: BranchStack, batchState: BatchState) {\n    this.target = target;\n    this._stack = stack;\n    this._batchState = batchState;\n    this._commands = Array<DrawCommands>(RenderPass.COUNT);\n    for (let i = 0; i < RenderPass.COUNT; ++i)\n      this._commands[i] = [];\n  }\n\n  public addGraphics(scene: GraphicList, forcedPass: RenderPass = RenderPass.None): void {\n    this._forcedRenderPass = forcedPass;\n    scene.forEach((entry: RenderGraphic) => (entry as Graphic).addCommands(this));\n    this._forcedRenderPass = RenderPass.None;\n  }\n\n  /** Add backgroundMap graphics to their own render pass. */\n  public addBackgroundMapGraphics(backgroundMapGraphics: GraphicList): void {\n    this._forcedRenderPass = RenderPass.BackgroundMap;\n    backgroundMapGraphics.forEach((entry: RenderGraphic) => (entry as Graphic).addCommands(this));\n    this._forcedRenderPass = RenderPass.None;\n  }\n\n  public addDecorations(dec: GraphicList, forcedPass: RenderPass = RenderPass.None): void {\n    this._forcedRenderPass = forcedPass;\n    for (const entry of dec) {\n      (entry as Graphic).addCommands(this);\n    }\n\n    this._forcedRenderPass = RenderPass.None;\n  }\n\n  public addWorldDecorations(decs: GraphicList): void {\n    const world = this.target.getWorldDecorations(decs);\n    this.pushAndPopBranch(world, () => {\n      for (const entry of world.branch.entries) {\n        (entry as Graphic).addCommands(this);\n      }\n    });\n  }\n\n  private addPickableDecorations(decs: Decorations): void {\n    if (undefined !== decs.normal) {\n      for (const normal of decs.normal) {\n        const gf = normal as Graphic;\n        if (gf.isPickable)\n          gf.addCommands(this);\n      }\n    }\n\n    if (undefined !== decs.world) {\n      const world = this.target.getWorldDecorations(decs.world);\n      this.pushAndPopBranch(world, () => {\n        for (const gf of world.branch.entries) {\n          if ((gf as Graphic).isPickable)\n            (gf as Graphic).addCommands(this);\n        }\n      });\n    }\n  }\n\n  public addBackground(gf?: Graphic): void {\n    if (undefined === gf)\n      return;\n\n    assert(RenderPass.None === this._forcedRenderPass);\n\n    this._forcedRenderPass = RenderPass.Background;\n    this._stack.pushState(this.target.decorationState);\n    (gf as Graphic).addCommands(this);\n    this._stack.pop();\n    this._forcedRenderPass = RenderPass.None;\n  }\n\n  public addSkyBox(gf?: Graphic): void {\n    if (undefined === gf)\n      return;\n\n    assert(RenderPass.None === this._forcedRenderPass);\n\n    this._forcedRenderPass = RenderPass.SkyBox;\n    this._stack.pushState(this.target.decorationState);\n    (gf as Graphic).addCommands(this);\n    this._stack.pop();\n    this._forcedRenderPass = RenderPass.None;\n  }\n\n  public addDrawCommand(command: DrawCommand, pass?: RenderPass): void {\n    if (undefined === pass)\n      pass = this.getRenderPass(command);\n\n    if (RenderPass.None === pass) // Edges will return none if they don't want to draw at all (edges not turned on).\n      return;\n\n    if (RenderPass.None !== this._forcedRenderPass) {\n      // Add the command to the forced render pass (background).\n      this.getCommands(this._forcedRenderPass).push(command);\n      return;\n    }\n\n    let ovrType = FeatureIndexType.Empty;\n    if (this._opaqueOverrides || this._translucentOverrides)\n      ovrType = command.featureIndexType;\n\n    const haveFeatureOverrides = FeatureIndexType.Empty !== ovrType;\n\n    if (RenderPass.Translucent === pass && this._addTranslucentAsOpaque) {\n      switch (command.renderOrder) {\n        case RenderOrder.PlanarSurface:\n          pass = RenderPass.OpaquePlanar;\n          break;\n        case RenderOrder.Surface:\n          pass = RenderPass.OpaqueGeneral;\n          break;\n        default:\n          pass = RenderPass.OpaqueLinear;\n          break;\n      }\n    }\n\n    switch (pass) {\n      // If this command ordinarily renders translucent, but some features have been overridden to be opaque, must draw in both passes\n      case RenderPass.Translucent:\n        if (this._opaqueOverrides && haveFeatureOverrides) {\n          let opaquePass: RenderPass;\n          switch (command.renderOrder) {\n            case RenderOrder.PlanarSurface:\n              opaquePass = RenderPass.OpaquePlanar;\n              break;\n            case RenderOrder.Surface:\n              opaquePass = RenderPass.OpaqueGeneral;\n              break;\n            default:\n              opaquePass = RenderPass.OpaqueLinear;\n              break;\n          }\n          this.getCommands(opaquePass).push(command);\n        }\n        break;\n      // If this command ordinarily renders opaque, but some features have been overridden to be translucent,\n      // must draw in both passes unless we are overriding translucent geometry to draw in the opaque pass for _ReadPixels.\n      case RenderPass.OpaqueLinear:\n      case RenderPass.OpaquePlanar:\n        // Want these items to draw in general opaque pass so they are not in pick data.\n        if (FeatureIndexType.Empty === command.featureIndexType)\n          pass = RenderPass.OpaqueGeneral;\n      /* falls through */\n      case RenderPass.OpaqueGeneral:\n        if (this._translucentOverrides && haveFeatureOverrides && !this._addTranslucentAsOpaque)\n          this.getCommands(RenderPass.Translucent).push(command);\n        break;\n    }\n\n    this.getCommands(pass).push(command);\n  }\n\n  public getRenderPass(command: DrawCommand): RenderPass { return command.getRenderPass(this.target); }\n\n  public getCommands(pass: RenderPass): DrawCommands {\n    let idx = pass as number;\n    assert(idx < this._commands.length);\n    if (idx >= this._commands.length)\n      idx -= 1;\n\n    return this._commands[idx];\n  }\n\n  public addHiliteBranch(branch: Branch, batch: Batch, pass: RenderPass): void {\n    this.pushAndPopBranchForPass(pass, branch, () => {\n      branch.branch.entries.forEach((entry: RenderGraphic) => (entry as Graphic).addHiliteCommands(this, batch, pass));\n    });\n  }\n\n  private pushAndPopBranchForPass(pass: RenderPass, branch: Branch, func: () => void): void {\n    assert(RenderPass.None !== pass);\n\n    this._stack.pushBranch(branch);\n    if (branch.planarClassifier) branch.planarClassifier.pushBatchState(this._batchState);\n    const cmds = this.getCommands(pass);\n    cmds.push(DrawCommand.createForBranch(branch, PushOrPop.Push));\n\n    func();\n\n    this._stack.pop();\n    if (cmds[cmds.length - 1].isPushCommand(branch))\n      cmds.pop();\n    else\n      cmds.push(DrawCommand.createForBranch(branch, PushOrPop.Pop));\n  }\n\n  public pushAndPopBranch(branch: Branch, func: () => void): void {\n    this._stack.pushBranch(branch);\n    if (branch.planarClassifier) branch.planarClassifier.pushBatchState(this._batchState);\n\n    let cmds: DrawCommands;\n    const emptyRenderPass = RenderPass.None === this._forcedRenderPass,\n      start = emptyRenderPass ? 0 : this._forcedRenderPass as number,\n      end = emptyRenderPass ? this._commands.length : start + 1;\n\n    for (let i = start; i < end; ++i) {\n      cmds = this._commands[i];\n      cmds.push(DrawCommand.createForBranch(branch, PushOrPop.Push));\n    }\n\n    // Add the commands from within the branch\n    func();\n\n    const popCmd = DrawCommand.createForBranch(branch, PushOrPop.Pop);\n    for (let i = start; i < end; ++i) {\n      cmds = this._commands[i];\n      assert(0 < cmds.length);\n      if (0 < cmds.length && cmds[cmds.length - 1].isPushCommand(branch))\n        cmds.pop();\n      else\n        cmds.push(popCmd);\n    }\n\n    this._stack.pop();\n  }\n\n  public clear(): void {\n    assert(this._batchState.isEmpty);\n    this._clearCommands();\n  }\n  private _clearCommands(): void {\n    this._commands.forEach((cmds: DrawCommands) => { cmds.splice(0); });\n  }\n\n  public initForPickOverlays(overlays: GraphicList): void {\n    this._clearCommands();\n\n    this._addTranslucentAsOpaque = true;\n    this._stack.pushState(this.target.decorationState);\n\n    for (const overlay of overlays) {\n      const gf = overlay as Graphic;\n      if (gf.isPickable)\n        gf.addCommands(this);\n    }\n\n    this._stack.pop();\n    this._addTranslucentAsOpaque = false;\n  }\n\n  public init(scene: GraphicList, backgroundMap: GraphicList, dec?: Decorations, dynamics?: GraphicList, initForReadPixels: boolean = false): void {\n    this.clear();\n\n    if (initForReadPixels) {\n      this._addTranslucentAsOpaque = true;      // Set flag to force translucent geometry to be put into the opaque pass.\n\n      // Add the scene graphics.\n      this.addGraphics(scene);\n\n      // Also add any pickable decorations.\n      if (undefined !== dec)\n        this.addPickableDecorations(dec);\n\n      this._addTranslucentAsOpaque = false;\n      this.setupClassificationByVolume();\n      return;\n    }\n\n    this.addGraphics(scene);\n    this.addBackgroundMapGraphics(backgroundMap);\n\n    if (undefined !== dynamics && 0 < dynamics.length) {\n      this.addDecorations(dynamics);\n    }\n\n    if (undefined !== dec) {\n      this.addBackground(dec.viewBackground as Graphic);\n\n      this.addSkyBox(dec.skyBox as Graphic);\n\n      if (undefined !== dec.normal && 0 < dec.normal.length) {\n        this.addGraphics(dec.normal);\n      }\n\n      if (undefined !== dec.world && 0 < dec.world.length) {\n        this.addWorldDecorations(dec.world);\n      }\n\n      this._stack.pushState(this.target.decorationState);\n      if (undefined !== dec.viewOverlay && 0 < dec.viewOverlay.length) {\n        this.addDecorations(dec.viewOverlay, RenderPass.ViewOverlay);\n      }\n\n      if (undefined !== dec.worldOverlay && 0 < dec.worldOverlay.length) {\n        this.addDecorations(dec.worldOverlay, RenderPass.WorldOverlay);\n      }\n\n      this._stack.pop();\n    }\n    this.setupClassificationByVolume();\n  }\n\n  public addPrimitive(prim: Primitive): void {\n    // ###TODO Would be nice if we could detect outside active volume here, but active volume only applies to specific render passes\n    // if (this.target.isGeometryOutsideActiveVolume(prim.cachedGeometry))\n    //   return;\n\n    if (undefined !== this._frustumPlanes) { // See if we can cull this primitive.\n      if (RenderPass.Classification === prim.getRenderPass(this.target)) {\n        const geom = prim.cachedGeometry;\n        geom.computeRange(this._scratchRange);\n        let frustum = Frustum.fromRange(this._scratchRange, this._scratchFrustum);\n        frustum = frustum.transformBy(this.target.currentTransform, frustum);\n        if (FrustumPlanes.Containment.Outside === this._frustumPlanes.computeFrustumContainment(frustum)) {\n          return;\n        }\n      }\n    }\n\n    const command = DrawCommand.createForPrimitive(prim, this._curBatch);\n    this.addDrawCommand(command);\n\n    if (RenderPass.None === this._forcedRenderPass && prim.isEdge) {\n      const vf: ViewFlags = this.target.currentViewFlags;\n      if (vf.renderMode !== RenderMode.Wireframe && vf.hiddenEdges)\n        this.addDrawCommand(command, RenderPass.HiddenEdge);\n    }\n  }\n\n  public addBranch(branch: Branch): void {\n    this.pushAndPopBranch(branch, () => {\n      branch.branch.entries.forEach((entry: RenderGraphic) => (entry as Graphic).addCommands(this));\n    });\n  }\n\n  public computeBatchHiliteRenderPass(batch: Batch): RenderPass {\n    let pass = RenderPass.Hilite;\n    if (batch.graphic instanceof MeshGraphic) {\n      const mg = batch.graphic as MeshGraphic;\n      if (SurfaceType.VolumeClassifier === mg.surfaceType)\n        pass = RenderPass.HiliteClassification;\n    } else if (batch.graphic instanceof GraphicsArray) {\n      const ga = batch.graphic as GraphicsArray;\n      if (ga.graphics[0] instanceof MeshGraphic) {\n        const mg = ga.graphics[0] as MeshGraphic;\n        if (SurfaceType.VolumeClassifier === mg.surfaceType)\n          pass = RenderPass.HiliteClassification;\n      }\n    }\n    return pass;\n  }\n\n  public addBatch(batch: Batch): void {\n    // Batches (aka element tiles) should only draw during ordinary (translucent or opaque) passes.\n    // They may draw during both, or neither.\n    // NB: This is no longer true - pickable overlay decorations are defined as Batches. Problem?\n    // assert(RenderPass.None === this._forcedRenderPass);\n    assert(!this._opaqueOverrides && !this._translucentOverrides);\n    assert(undefined === this._curBatch);\n\n    // If all features are overridden to be invisible, draw no graphics in this batch\n    const overrides = batch.getOverrides(this.target);\n    if (overrides.allHidden)\n      return;\n\n    if (!batch.range.isNull) {\n      // ###TODO Would be nice if we could detect outside active volume here, but active volume only applies to specific render passes\n      // if (this.target.isRangeOutsideActiveVolume(batch.range))\n      //   return;\n\n      if (undefined !== this._frustumPlanes) {\n        let frustum = Frustum.fromRange(batch.range, this._scratchFrustum);\n        frustum = frustum.transformBy(this.target.currentTransform, frustum);\n        if (FrustumPlanes.Containment.Outside === this._frustumPlanes.computeFrustumContainment(frustum)) {\n          return;\n        }\n      }\n    }\n\n    this._batchState.push(batch, true);\n    if (this.currentViewFlags.transparency) {\n      this._opaqueOverrides = overrides.anyOpaque;\n      this._translucentOverrides = overrides.anyTranslucent;\n    }\n\n    (batch.graphic as Graphic).addCommands(this);\n\n    this._batchState.pop();\n\n    // If the batch contains hilited features, need to render them in the hilite pass\n    const anyHilited = overrides.anyHilited;\n    const planarClassifierHilited = this._stack.top.planarClassifier && this._stack.top.planarClassifier.anyHilited;\n    if (anyHilited || planarClassifierHilited)\n      (batch.graphic as Graphic).addHiliteCommands(this, batch, planarClassifierHilited ? RenderPass.HilitePlanarClassification : this.computeBatchHiliteRenderPass(batch));\n\n    this._opaqueOverrides = this._translucentOverrides = false;\n  }\n\n  // Define a culling frustum. Commands associated with Graphics whose ranges do not intersect the frustum will be skipped.\n  public setCheckRange(frustum: Frustum) { this._frustumPlanes = new FrustumPlanes(frustum); }\n  // Clear the culling frustum.\n  public clearCheckRange(): void { this._frustumPlanes = undefined; }\n\n  private setupClassificationByVolume(): void {\n    // To make is easier to process the classifiers individually, set up a secondary command list for them where they\n    // are each separated by their own push & pop and can more easily be accessed by index.\n    const groupedCmds = this._commands[RenderPass.Classification];\n    const byIndexCmds = this._commands[RenderPass.ClassificationByIndex];\n    const numCmds = groupedCmds.length;\n    let curCmdIndex = 0;\n    while (curCmdIndex < numCmds) {\n      // Find the next set of clasifiers (should be between a push & pop branch).\n      const pushCmd = groupedCmds[curCmdIndex++];\n      if (!pushCmd.isPushCommand())\n        continue;\n      let primCmdIndex = curCmdIndex++;\n      if (!groupedCmds[primCmdIndex].isPrimitiveCommand) continue;\n      while (groupedCmds[curCmdIndex].isPrimitiveCommand)++curCmdIndex;\n      const popCmdIndex = curCmdIndex++;\n      const popCmd = groupedCmds[popCmdIndex];\n      if (!popCmd.isPopCommand()) continue;\n      // Loop through the primitive commands between the push and pop, copying them to the byIndex command list.\n      while (primCmdIndex < popCmdIndex) {\n        byIndexCmds.push(pushCmd);\n        byIndexCmds.push(groupedCmds[primCmdIndex++]);\n        byIndexCmds.push(popCmd);\n      }\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { LinePixels, HiddenLine } from \"@bentley/imodeljs-common\";\nimport { FloatPreMulRgba } from \"./FloatRGBA\";\nimport { OvrFlags } from \"./RenderFlags\";\n\n/** Describes one of the pre-defined line patterns. See Render.LinePixels.\n * @internal\n */\nexport namespace LineCode {\n  export function valueFromLinePixels(pixels: LinePixels): number {\n    switch (pixels) {\n      case LinePixels.Code0: return 0;\n      case LinePixels.Code1: return 1;\n      case LinePixels.Code2: return 2;\n      case LinePixels.Code3: return 3;\n      case LinePixels.Code4: return 4;\n      case LinePixels.Code5: return 5;\n      case LinePixels.Code6: return 6;\n      case LinePixels.Code7: return 7;\n      case LinePixels.HiddenLine: return 8;\n      case LinePixels.Invisible: return 9;\n      default: return 0;\n    }\n  }\n\n  export const solid = 0;\n  export const count = 16; // only 10 line codes, but pad to 16 to make height a power of two.\n  export const size = 32;\n\n  // NB: Non-power-of-two textures in WebGL only support clamp-to-edge.\n  // Make this a power of two so we can use repeat.\n  export const lineCodeData: number[] = [\n    0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,\n    0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n    0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0xff, 0xff,\n    0xff, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00];\n}\n\n/** @internal */\nexport class EdgeOverrides {\n  private _color?: FloatPreMulRgba;\n  private _lineCode?: number;\n  private _weight?: number;\n  private _forceOpaque: boolean = false;\n\n  public get color() { return this._color; }\n  public get lineCode() { return this._lineCode; }\n  public get weight() { return this._weight; }\n  public get forceOpaque() { return this._forceOpaque; }\n\n  public get overridesColor() { return undefined !== this.color; }\n  public get overridesLineCode() { return undefined !== this.lineCode; }\n  public get overridesWeight() { return undefined !== this.weight; }\n  public get overridesAlpha() { return this.forceOpaque; }\n  public get anyOverridden() { return this.overridesColor || this.overridesLineCode || this.overridesWeight || this.overridesAlpha; }\n\n  public constructor(style?: HiddenLine.Style, forceOpaque: boolean = false) {\n    this.init(forceOpaque, style);\n  }\n\n  public computeOvrFlags(): OvrFlags {\n    let flags = OvrFlags.None;\n\n    if (this.overridesColor) flags |= OvrFlags.Rgba;\n    if (this.overridesWeight) flags |= OvrFlags.Weight;\n    if (this.overridesLineCode) flags |= OvrFlags.LineCode;\n    if (this.overridesAlpha) flags |= OvrFlags.Alpha;\n\n    return flags;\n  }\n\n  public init(forceOpaque: boolean, style?: HiddenLine.Style): void {\n    this._forceOpaque = forceOpaque;\n    if (undefined === style) {\n      this._color = undefined;\n      this._weight = undefined;\n      this._lineCode = undefined;\n    } else {\n      this._color = undefined !== style.color ? FloatPreMulRgba.fromColorDef(style.color) : undefined;\n      this._weight = style.width;\n      this._lineCode = undefined !== style.pattern ? LineCode.valueFromLinePixels(style.pattern) : undefined;\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { FeatureIndexType } from \"@bentley/imodeljs-common\";\nimport { System } from \"./System\";\nimport { assert } from \"@bentley/bentleyjs-core\";\n\n// tslint:disable:no-const-enum\n\n/** Describes the dimensionality of a texture used as a look-up table.\n * @internal\n */\nexport const enum LUTDimension {\n  Uniform, //  uniform lookup table\n  NonUniform, // 1- or 2-dimensional lookup table\n}\n\n/** @internal */\nexport interface WidthAndHeight {\n  readonly width: number;\n  readonly height: number;\n}\n\n/** @internal */\nexport class LUTParams implements WidthAndHeight {\n  public readonly width: number;\n  public readonly height: number;\n\n  public constructor(width: number, height: number) { this.width = width; this.height = height; }\n}\n\n/** Describes the dimensions of a texture used as a look-up table\n * @internal\n */\nexport class LUTDimensions implements WidthAndHeight {\n  public readonly width: number;\n  public readonly height: number;\n\n  public constructor(nEntries: number, nRgbaPerEntry: number, nExtraRgba: number = 0, nTables: number = 1) {\n    const dims = LUTDimensions.computeWidthAndHeight(nEntries, nRgbaPerEntry, nExtraRgba, nTables);\n    this.width = dims.width;\n    this.height = dims.height;\n  }\n\n  public static computeWidthAndHeight(nEntries: number, nRgbaPerEntry: number, nExtraRgba: number = 0, nTables: number = 1): WidthAndHeight {\n    const maxSize = System.instance.capabilities.maxTextureSize;\n    const nRgba = nEntries * nRgbaPerEntry * nTables + nExtraRgba;\n\n    if (nRgba < maxSize)\n      return { width: nRgba, height: 1 };\n\n    // Make roughly square to reduce unused space in last row\n    let width = Math.ceil(Math.sqrt(nRgba));\n\n    // Ensure a given entry's RGBA values all fit on the same row.\n    const remainder = width % nRgbaPerEntry;\n    if (0 !== remainder) {\n      width += nRgbaPerEntry - remainder;\n    }\n\n    // Compute height\n    const height = Math.ceil(nRgba / width);\n\n    assert(height <= maxSize);\n    assert(width <= maxSize);\n    assert(width * height >= nRgba);\n    assert(Math.floor(height) === height);\n    assert(Math.floor(width) === width);\n\n    // Row padding should never be necessary...\n    assert(0 === width % nRgbaPerEntry);\n\n    return { width, height };\n  }\n}\n\n/** @internal */\nexport const enum FeatureDimension {\n  Empty,\n  SingleUniform,\n  SingleNonUniform,\n  Multiple,\n  COUNT,\n}\n\n/** @internal */\nexport function getFeatureName(dim: FeatureDimension): string {\n  switch (dim) {\n    case FeatureDimension.Empty: return \"Empty\";\n    case FeatureDimension.SingleUniform: return \"Single/Uniform\";\n    case FeatureDimension.SingleNonUniform: return \"Single/Non-uniform\";\n    case FeatureDimension.Multiple: return \"Multiple\";\n    default: assert(false); return \"Invalid\";\n  }\n}\n\n/** @internal */\nexport function computeFeatureDimension(dim: LUTDimension, type: FeatureIndexType) {\n  switch (type) {\n    case FeatureIndexType.Empty:\n      return FeatureDimension.Empty;\n    case FeatureIndexType.NonUniform:\n      assert(LUTDimension.Uniform !== dim);\n      return FeatureDimension.Multiple;\n    default:\n      return LUTDimension.Uniform === dim ? FeatureDimension.SingleUniform : FeatureDimension.SingleNonUniform;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport {\n  FeatureIndexType,\n  FeatureIndex,\n} from \"@bentley/imodeljs-common\";\nimport { VertexTable } from \"../primitives/VertexTable\";\nimport { assert } from \"@bentley/bentleyjs-core\";\n\n/** @internal */\nexport class FeaturesInfo {\n  public readonly uniform?: number;\n\n  public static create(featureIndex: FeatureIndex): FeaturesInfo | undefined {\n    switch (featureIndex.type) {\n      case FeatureIndexType.Empty: return undefined;\n      case FeatureIndexType.Uniform: return new FeaturesInfo(featureIndex.featureID);\n      default: return FeaturesInfo._nonUniform;\n    }\n  }\n\n  public static createUniform(id: number): FeaturesInfo { return new FeaturesInfo(id); }\n\n  public static createFromVertexTable(vt: VertexTable): FeaturesInfo | undefined {\n    switch (vt.featureIndexType) {\n      case FeatureIndexType.Empty: return undefined;\n      case FeatureIndexType.NonUniform: return FeaturesInfo._nonUniform;\n      default:\n        assert(undefined !== vt.uniformFeatureID);\n        return new FeaturesInfo(vt.uniformFeatureID!);\n    }\n  }\n\n  public static createFromFeatureIds(ids?: Uint8Array): FeaturesInfo | undefined {\n    if (undefined === ids || 0 === ids.length)\n      return undefined;\n\n    assert(0 === ids.length % 3);\n    const nFeatures = ids.length / 3;\n    for (let i = 1; i < nFeatures; i++) {\n      const index = i * 3;\n      if (ids[index + 0] !== ids[0] || ids[index + 1] !== ids[1] || ids[index + 2] !== ids[2])\n        return FeaturesInfo._nonUniform;\n    }\n\n    const uniform = ids[0] | (ids[1] << 8) | (ids[2] << 16);\n    return FeaturesInfo.createUniform(uniform);\n  }\n\n  public get type(): FeatureIndexType { return undefined !== this.uniform ? FeatureIndexType.Uniform : FeatureIndexType.NonUniform; }\n  public get isUniform() { return FeatureIndexType.Uniform === this.type; }\n  public get isNonUniform() { return !this.isUniform; }\n\n  private constructor(uniform?: number) { this.uniform = uniform; }\n\n  private static _nonUniform = new FeaturesInfo(undefined);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { ColorDef } from \"@bentley/imodeljs-common\";\nimport { UniformHandle } from \"./Handle\";\n\nfunction assertComponent(c: number) { assert(1.0 >= c && 0.0 <= c); }\nfunction assertRgb(rgb: FloatRgb) {\n  assertComponent(rgb.red);\n  assertComponent(rgb.green);\n  assertComponent(rgb.blue);\n}\nfunction assertRgba(rgba: Rgba) {\n  assertComponent(rgba.red);\n  assertComponent(rgba.green);\n  assertComponent(rgba.blue);\n  assertComponent(rgba.alpha);\n}\n\n/**\n * An RGB color with components in the range [0, 1].\n * @internal\n */\nexport class FloatRgb {\n  private readonly _value = new Float32Array(3);\n  private _colorDefValue?: number;\n\n  /** Set from red, green, and blue components, or colorDefValue. */\n  protected setValues(red: number, green: number, blue: number, colorDefValue?: number) {\n    this._value[0] = red;\n    this._value[1] = green;\n    this._value[2] = blue;\n    this._colorDefValue = colorDefValue;\n    assertRgb(this);\n  }\n\n  protected constructor() { }\n\n  public setFromColorDef(def: ColorDef) {\n    if (this._colorDefValue === def.tbgr)\n      return;\n\n    const c = def.colors;\n    this.setValues(c.r / 255.0, c.g / 255.0, c.b / 255.0, def.tbgr);\n  }\n\n  /** Create a FloatRgb using a ColorDef. */\n  public static fromColorDef(def: ColorDef) {\n    const rgb = new FloatRgb();\n    rgb.setFromColorDef(def);\n    return rgb;\n  }\n\n  public get red() { return this._value[0]; }\n  public get green() { return this._value[1]; }\n  public get blue() { return this._value[2]; }\n  public get colorDefValue() { return this._colorDefValue; }\n\n  public bind(uniform: UniformHandle): void { uniform.setUniform3fv(this._value); }\n}\n\n/** @internal */\nexport class Rgba {\n  private readonly _value = new Float32Array(4);\n  protected _colorDefValue?: number;\n\n  protected setValues(r: number, g: number, b: number, a: number, colorDefValue?: number) {\n    this._value[0] = r;\n    this._value[1] = g;\n    this._value[2] = b;\n    this._value[3] = a;\n    this._colorDefValue = colorDefValue;\n    assertRgba(this);\n  }\n\n  protected constructor() { }\n\n  public get red() { return this._value[0]; }\n  public get green() { return this._value[1]; }\n  public get blue() { return this._value[2]; }\n  public get alpha() { return this._value[3]; }\n  public get colorDefValue() { return this._colorDefValue; }\n\n  public get hasTranslucency(): boolean { return 1.0 !== this.alpha; }\n\n  public equals(rhs: Rgba): boolean {\n    return this.colorDefValue === rhs.colorDefValue || (this.red === rhs.red && this.green === rhs.green && this.blue === rhs.blue && this.alpha === rhs.alpha);\n  }\n\n  public get isWhite(): boolean {\n    return this.red === 1.0 && this.green === 1.0 && this.blue === 1.0;\n  }\n\n  public bind(uniform: UniformHandle): void { uniform.setUniform4fv(this._value); }\n}\n\n/** @internal */\nexport class FloatRgba extends Rgba {\n  public setFromColorDef(def: ColorDef, transparency?: number) {\n    const c = def.colors;\n    if (undefined !== transparency) {\n      c.t = transparency;\n      def = ColorDef.from(c.r, c.g, c.b, c.t);\n    }\n\n    if (this._colorDefValue === def.tbgr)\n      return;\n\n    this.setValues(c.r / 255.0, c.g / 255.0, c.b / 255.0, (255.0 - c.t) / 255.0, def.tbgr);\n  }\n\n  public setFromFloatRgba(rgba: FloatRgba) {\n    this.setValues(rgba.red, rgba.green, rgba.blue, rgba.alpha, rgba.colorDefValue);\n  }\n\n  /** Create a FloatRgba using a ColorDef. */\n  public static fromColorDef(def: ColorDef, transparency?: number) {\n    const rgba = new FloatRgba();\n    rgba.setFromColorDef(def, transparency);\n    return rgba;\n  }\n}\n\n/**\n * An RGBA color with components in the range [0, 1], wherein the red, green, and blue components are pre-multiplied by the alpha component.\n * @internal\n */\nexport class FloatPreMulRgba extends Rgba {\n  /** Set a FloatPreMulRgba using a ColorDef (premultiplied by alpha).\n   * @param def A ColorDef used to create a new FloatPreMulRgba.\n   */\n  public setFromColorDef(def: ColorDef) {\n    if (this._colorDefValue === def.tbgr)\n      return;\n\n    const c = def.colors;\n    const a = (255.0 - c.t) / 255.0;\n    this.setValues(c.r * a / 255.0, c.g * a / 255.0, c.b * a / 255.0, a, def.tbgr);\n  }\n\n  /** Create a FloatPreMulRgba using a ColorDef. */\n  public static fromColorDef(def: ColorDef) {\n    const rgba = new FloatPreMulRgba();\n    rgba.setFromColorDef(def);\n    return rgba;\n  }\n}\n\n/**\n * A mutable implementation of a FloatRgb for internal use where changing of values is desirable without requiring allocating a new instance.\n * @internal\n */\nexport class MutableFloatRgb extends FloatRgb {\n  public setRgbValues(red: number, green: number, blue: number) {\n    this.setValues(red, green, blue);\n  }\n  public static fromColorDef(def: ColorDef) {\n    const rgb = new MutableFloatRgb();\n    rgb.setFromColorDef(def);\n    return rgb;\n  }\n}\n\n/**\n * A mutable implementation of a FloatRgba for internal use where changing of values is desirable without requiring allocating a new instance.\n * @internal\n */\nexport class MutableFloatRgba extends FloatRgba {\n  public setRgbaValues(red: number, green: number, blue: number, alpha: number) {\n    this.setValues(red, green, blue, alpha);\n  }\n  public static fromColorDef(def: ColorDef) {\n    const rgb = new MutableFloatRgba();\n    rgb.setFromColorDef(def);\n    return rgb;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { IDisposable, assert } from \"@bentley/bentleyjs-core\";\nimport { TextureHandle } from \"./Texture\";\nimport { RenderBuffer } from \"./RenderBuffer\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\n\n/** @internal */\nexport type DepthBuffer = RenderBuffer | TextureHandle;\n// tslint:disable:no-const-enum\n\n/** @internal */\nexport const enum FrameBufferBindState {\n  Unbound,\n  Bound,\n  BoundWithAttachments,\n  Suspended,\n}\n\n/** @internal */\nexport class FrameBuffer implements IDisposable {\n  private _fbo?: WebGLFramebuffer;\n  private _bindState: FrameBufferBindState = FrameBufferBindState.Unbound;\n  private readonly _colorTextures: TextureHandle[] = [];\n  private readonly _colorAttachments: GLenum[] = [];\n  public readonly depthBuffer?: DepthBuffer;\n\n  public get isDisposed(): boolean { return this._fbo === undefined; }\n\n  public get isBound(): boolean { return FrameBufferBindState.Bound === this._bindState || FrameBufferBindState.BoundWithAttachments === this._bindState; }\n  public get isSuspended(): boolean { return FrameBufferBindState.Suspended === this._bindState; }\n  public getColor(ndx: number): TextureHandle {\n    assert(ndx < this._colorTextures.length);\n    return this._colorTextures[ndx];\n  }\n\n  private constructor(fbo: WebGLFramebuffer, colorTextures: TextureHandle[], depthBuffer?: DepthBuffer) {\n    this._fbo = fbo;\n    const gl: WebGLRenderingContext = System.instance.context;\n\n    this.bind(false);\n\n    let i: number = 0;\n    for (const colTex of colorTextures) {\n      const attachmentEnum: GLenum = gl.COLOR_ATTACHMENT0 + i;\n      this._colorAttachments.push(attachmentEnum);\n      this._colorTextures.push(colTex);\n      const texHandle = colTex.getHandle();\n      if (undefined !== texHandle)\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, attachmentEnum, gl.TEXTURE_2D, texHandle, 0);\n      i++;\n    }\n\n    if (depthBuffer !== undefined) {\n      this.depthBuffer = depthBuffer;\n      const dbHandle = depthBuffer.getHandle();\n      if (undefined !== dbHandle) {\n        if (depthBuffer instanceof RenderBuffer) {\n          gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, dbHandle);\n        } else {\n          // Looks like we only get a 24 bit depth buffer anyway, so use a 24-8 with a stencil.\n          // gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, dbHandle, 0);\n          gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.TEXTURE_2D, dbHandle, 0);\n        }\n      }\n    }\n\n    this.unbind();\n  }\n\n  public static create(colorTextures: TextureHandle[], depthBuffer?: DepthBuffer): FrameBuffer | undefined {\n    const fbo: WebGLFramebuffer | null = System.instance.context.createFramebuffer();\n    if (null === fbo) {\n      return undefined;\n    }\n    return new FrameBuffer(fbo, colorTextures, depthBuffer);\n  }\n\n  public dispose(): void {\n    // NB: The FrameBuffer does not *own* the textures and depth buffer.\n    if (!this.isDisposed) {\n      System.instance.context.deleteFramebuffer(this._fbo!);\n      this._fbo = undefined;\n    }\n  }\n\n  public bind(bindAttachments: boolean = false): boolean {\n    assert(undefined !== this._fbo);\n    assert(!this.isBound);\n\n    if (undefined === this._fbo)\n      return false;\n\n    const gl: WebGLRenderingContext = System.instance.context;\n\n    gl.bindFramebuffer(GL.FrameBuffer.TARGET, this._fbo);\n\n    if (bindAttachments) {\n      System.instance.setDrawBuffers(this._colorAttachments);\n      this._bindState = FrameBufferBindState.BoundWithAttachments;\n    } else {\n      this._bindState = FrameBufferBindState.Bound;\n    }\n    return true;\n  }\n\n  public unbind() {\n    assert(this.isBound);\n    System.instance.context.bindFramebuffer(GL.FrameBuffer.TARGET, null);\n    this._bindState = FrameBufferBindState.Unbound;\n  }\n\n  public suspend() { assert(this.isBound); this._bindState = FrameBufferBindState.Suspended; }\n\n  // Chiefly for debugging currently - assumes RGBA, unsigned byte, want all pixels.\n  public get debugPixels(): Uint8Array | undefined {\n    if (!this.isBound || 0 === this._colorTextures.length)\n      return undefined;\n\n    const tex = this._colorTextures[0];\n    if (GL.Texture.Format.Rgba !== tex.format || GL.Texture.DataType.UnsignedByte !== tex.dataType)\n      return undefined;\n\n    const buffer = new Uint8Array(tex.width * tex.height * 4);\n    for (let i = 0; i < buffer.length; i += 4) {\n      buffer[i] = 0xba;\n      buffer[i + 1] = 0xad;\n      buffer[i + 2] = 0xf0;\n      buffer[i + 3] = 0x0d;\n    }\n\n    System.instance.context.readPixels(0, 0, tex.width, tex.height, tex.format, tex.dataType, buffer);\n    return buffer;\n  }\n}\n\ninterface Binding {\n  fbo: FrameBuffer;\n  withAttachments: boolean;\n}\n\n/** @internal */\nexport class FrameBufferStack {\n  // FrameBuffers within this array are not owned, as this is only a storage device holding references\n  private readonly _stack: Binding[] = [];\n\n  private get _top() { return !this.isEmpty ? this._stack[this._stack.length - 1] : undefined; }\n\n  public push(fbo: FrameBuffer, withAttachments: boolean): void {\n    if (undefined !== this._top) {\n      this._top.fbo.suspend();\n    }\n\n    assert(!fbo.isBound);\n    fbo.bind(withAttachments);\n    assert(fbo.isBound);\n\n    this._stack.push({ fbo, withAttachments });\n  }\n\n  public pop(): void {\n    assert(!this.isEmpty);\n    if (undefined === this._top) {\n      return;\n    }\n\n    const fbo = this._top.fbo;\n    this._stack.pop();\n\n    assert(fbo.isBound);\n    fbo.unbind();\n    assert(!fbo.isBound);\n\n    if (this.isEmpty) {\n      System.instance.context.bindFramebuffer(GL.FrameBuffer.TARGET, null);\n    } else {\n      const top = this._top;\n      assert(top.fbo.isSuspended);\n      top.fbo.bind(top.withAttachments);\n      assert(top.fbo.isBound);\n    }\n  }\n\n  public get currentColorBuffer(): TextureHandle | undefined {\n    assert(!this.isEmpty);\n    return undefined !== this._top ? this._top.fbo.getColor(0) : undefined;\n  }\n\n  public get isEmpty(): boolean { return 0 === this._stack.length; }\n\n  public execute(fbo: FrameBuffer, withAttachments: boolean, func: () => void) {\n    this.push(fbo, withAttachments);\n    func();\n    this.pop();\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nif (typeof (WebGLRenderingContext) === \"undefined\") {\n  (global as any).WebGLRenderingContext = new Proxy({}, { get: () => 0 });\n}\n\n/** @internal */\nexport namespace GL {\n  export enum BlendEquation {\n    Add = WebGLRenderingContext.FUNC_ADD,\n    Subtract = WebGLRenderingContext.FUNC_SUBTRACT,\n    ReverseSubtract = WebGLRenderingContext.FUNC_REVERSE_SUBTRACT,\n    Default = Add,\n  }\n\n  export enum BlendFactor {\n    Zero = WebGLRenderingContext.ZERO,\n    One = WebGLRenderingContext.ONE,\n    SrcColor = WebGLRenderingContext.SRC_COLOR,\n    OneMinusSrcColor = WebGLRenderingContext.ONE_MINUS_SRC_COLOR,\n    DstColor = WebGLRenderingContext.DST_COLOR,\n    OneMinusDstColor = WebGLRenderingContext.ONE_MINUS_DST_COLOR,\n    SrcAlpha = WebGLRenderingContext.SRC_ALPHA,\n    OneMinusSrcAlpha = WebGLRenderingContext.ONE_MINUS_SRC_ALPHA,\n    DstAlpha = WebGLRenderingContext.DST_ALPHA,\n    OneMinusDstAlpha = WebGLRenderingContext.ONE_MINUS_DST_ALPHA,\n    ConstColor = WebGLRenderingContext.CONSTANT_COLOR,\n    OneMinusConstColor = WebGLRenderingContext.ONE_MINUS_CONSTANT_COLOR,\n    ConstAlpha = WebGLRenderingContext.CONSTANT_ALPHA,\n    OneMinusConstAlpha = WebGLRenderingContext.ONE_MINUS_CONSTANT_ALPHA,\n    AlphaSaturate = WebGLRenderingContext.SRC_ALPHA_SATURATE,\n    DefaultSrc = One,\n    DefaultDst = Zero,\n  }\n\n  export namespace Buffer {\n    export enum Target {\n      ArrayBuffer = WebGLRenderingContext.ARRAY_BUFFER,\n      ElementArrayBuffer = WebGLRenderingContext.ELEMENT_ARRAY_BUFFER,\n    }\n\n    export enum Binding {\n      ArrayBuffer = WebGLRenderingContext.ARRAY_BUFFER_BINDING,\n      ElementArrayBuffer = WebGLRenderingContext.ELEMENT_ARRAY_BUFFER_BINDING,\n    }\n\n    export enum Parameter {\n      Size = WebGLRenderingContext.BUFFER_SIZE,\n      Usage = WebGLRenderingContext.BUFFER_USAGE,\n    }\n\n    export enum Usage {\n      DynamicDraw = WebGLRenderingContext.DYNAMIC_DRAW,\n      StaticDraw = WebGLRenderingContext.STATIC_DRAW,\n      StreamDraw = WebGLRenderingContext.STREAM_DRAW,\n    }\n  }\n\n  export enum StencilOperation {\n    Keep = WebGLRenderingContext.KEEP,\n    Zero = WebGLRenderingContext.ZERO,\n    Replace = WebGLRenderingContext.REPLACE,\n    Incr = WebGLRenderingContext.INCR,\n    IncrWrap = WebGLRenderingContext.INCR_WRAP,\n    Decr = WebGLRenderingContext.DECR,\n    DecrWrap = WebGLRenderingContext.DECR_WRAP,\n    Invert = WebGLRenderingContext.INVERT,\n    Default = Keep,\n  }\n\n  export enum StencilFunction {\n    Never = WebGLRenderingContext.NEVER,\n    Less = WebGLRenderingContext.LESS,\n    LEqual = WebGLRenderingContext.LEQUAL,\n    Greater = WebGLRenderingContext.GREATER,\n    GEqual = WebGLRenderingContext.GEQUAL,\n    Equal = WebGLRenderingContext.EQUAL,\n    NotEqual = WebGLRenderingContext.NOTEQUAL,\n    Always = WebGLRenderingContext.ALWAYS,\n    Default = Always,\n  }\n\n  export enum CullFace {\n    Front = WebGLRenderingContext.FRONT,\n    Back = WebGLRenderingContext.BACK,\n    FrontAndBack = WebGLRenderingContext.FRONT_AND_BACK,\n    Default = Back,\n  }\n\n  export enum DataType {\n    Byte = WebGLRenderingContext.BYTE,\n    Short = WebGLRenderingContext.SHORT,\n    UnsignedByte = WebGLRenderingContext.UNSIGNED_BYTE,\n    UnsignedShort = WebGLRenderingContext.UNSIGNED_SHORT,\n    UnsignedInt = WebGLRenderingContext.UNSIGNED_INT,\n    Float = WebGLRenderingContext.FLOAT,\n    // WebGL 2 has more data types\n    // HalfFloat = WebGLRenderingContext.HALF_FLOAT,\n  }\n\n  export enum FrontFace {\n    CounterClockwise = WebGLRenderingContext.CCW,\n    Clockwise = WebGLRenderingContext.CW,\n    Default = CounterClockwise,\n  }\n\n  export enum DepthFunc {\n    Never = WebGLRenderingContext.NEVER,\n    Less = WebGLRenderingContext.LESS,\n    Equal = WebGLRenderingContext.EQUAL,\n    LessOrEqual = WebGLRenderingContext.LEQUAL,\n    Greater = WebGLRenderingContext.GREATER,\n    NotEqual = WebGLRenderingContext.NOTEQUAL,\n    GreaterOrEqual = WebGLRenderingContext.GEQUAL,\n    Always = WebGLRenderingContext.ALWAYS,\n    Default = LessOrEqual,\n  }\n\n  export enum Capability {\n    Blend = WebGLRenderingContext.BLEND,\n    BlendColor = WebGLRenderingContext.BLEND_COLOR,\n    BlendEquationAlpha = WebGLRenderingContext.BLEND_EQUATION_ALPHA,\n    BlendEquationRGB = WebGLRenderingContext.BLEND_EQUATION_RGB,\n    BlendSrcAlpha = WebGLRenderingContext.BLEND_SRC_ALPHA,\n    BlendSrcRgb = WebGLRenderingContext.BLEND_SRC_RGB,\n    BlendDstAlpha = WebGLRenderingContext.BLEND_DST_ALPHA,\n    BlendDstRgb = WebGLRenderingContext.BLEND_DST_RGB,\n    CullFace = WebGLRenderingContext.CULL_FACE,\n    CullFaceMode = WebGLRenderingContext.CULL_FACE_MODE,\n    DepthFunc = WebGLRenderingContext.DEPTH_FUNC,\n    DepthTest = WebGLRenderingContext.DEPTH_TEST,\n    DepthWriteMask = WebGLRenderingContext.DEPTH_WRITEMASK,\n    FrontFace = WebGLRenderingContext.FRONT_FACE,\n    StencilFrontFunc = WebGLRenderingContext.STENCIL_FUNC,\n    StencilFrontRef = WebGLRenderingContext.STENCIL_REF,\n    StencilFrontValueMask = WebGLRenderingContext.STENCIL_VALUE_MASK,\n    StencilFrontWriteMask = WebGLRenderingContext.STENCIL_WRITEMASK,\n    StencilFrontOpFail = WebGLRenderingContext.STENCIL_FAIL,\n    StencilFrontOpZFail = WebGLRenderingContext.STENCIL_PASS_DEPTH_FAIL,\n    StencilFrontOpZPass = WebGLRenderingContext.STENCIL_PASS_DEPTH_PASS,\n    StencilBackFunc = WebGLRenderingContext.STENCIL_BACK_FUNC,\n    StencilBackRef = WebGLRenderingContext.STENCIL_BACK_REF,\n    StencilBackValueMask = WebGLRenderingContext.STENCIL_BACK_VALUE_MASK,\n    StencilBackWriteMask = WebGLRenderingContext.STENCIL_BACK_WRITEMASK,\n    StencilBackOpFail = WebGLRenderingContext.STENCIL_BACK_FAIL,\n    StencilBackOpZFail = WebGLRenderingContext.STENCIL_BACK_PASS_DEPTH_FAIL,\n    StencilBackOpZPass = WebGLRenderingContext.STENCIL_BACK_PASS_DEPTH_PASS,\n    StencilTest = WebGLRenderingContext.STENCIL_TEST,\n    StencilWriteMask = WebGLRenderingContext.STENCIL_WRITEMASK,\n  }\n\n  export namespace Texture {\n    export enum Target {\n      TwoDee = WebGLRenderingContext.TEXTURE_2D, // regular 2D texture\n      CubeMap = WebGLRenderingContext.TEXTURE_CUBE_MAP, // six-sided cubemap texture\n      CubeMapPositiveX = WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_X, // right side\n      CubeMapNegativeX = WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_X, // left side\n      CubeMapPositiveY = WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Y, // top side\n      CubeMapNegativeY = WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Y, // bottom side\n      CubeMapPositiveZ = WebGLRenderingContext.TEXTURE_CUBE_MAP_POSITIVE_Z, // back side\n      CubeMapNegativeZ = WebGLRenderingContext.TEXTURE_CUBE_MAP_NEGATIVE_Z, // front side\n    }\n    export enum Format {\n      Rgb = WebGLRenderingContext.RGB,\n      Rgba = WebGLRenderingContext.RGBA,\n      DepthStencil = WebGLRenderingContext.DEPTH_STENCIL,\n      Luminance = WebGLRenderingContext.LUMINANCE,\n      DepthComponent = WebGLRenderingContext.DEPTH_COMPONENT,\n    }\n\n    // This name is unambiguous as it is qualified by the namespace...https://github.com/palantir/tslint/issues/3789\n    export enum DataType { // tslint:disable-line:no-shadowed-variable\n      Float = WebGLRenderingContext.FLOAT,\n      UnsignedByte = WebGLRenderingContext.UNSIGNED_BYTE,\n      //    UnsignedInt24_8 = WebGLRenderingContext.UNSIGNED_INT_24_8,\n      UnsignedInt = WebGLRenderingContext.UNSIGNED_INT,\n    }\n\n    export enum WrapMode {\n      Repeat = WebGLRenderingContext.REPEAT,\n      MirroredRepeat = WebGLRenderingContext.MIRRORED_REPEAT,\n      ClampToEdge = WebGLRenderingContext.CLAMP_TO_EDGE,\n    }\n  }\n\n  export enum ShaderType {\n    Fragment = WebGLRenderingContext.FRAGMENT_SHADER,\n    Vertex = WebGLRenderingContext.VERTEX_SHADER,\n  }\n\n  export enum ShaderParameter {\n    CompileStatus = WebGLRenderingContext.COMPILE_STATUS,\n  }\n\n  export enum ProgramParameter {\n    LinkStatus = WebGLRenderingContext.LINK_STATUS,\n  }\n\n  export enum PrimitiveType {\n    Points = WebGLRenderingContext.POINTS,\n    Lines = WebGLRenderingContext.LINES,\n    Triangles = WebGLRenderingContext.TRIANGLES,\n  }\n\n  export namespace RenderBuffer {\n    export const TARGET = WebGLRenderingContext.RENDERBUFFER;\n\n    export enum Format {\n      DepthComponent16 = WebGLRenderingContext.DEPTH_COMPONENT16,\n      // Currently this is the only supported format\n    }\n  }\n\n  export namespace FrameBuffer {\n    export const TARGET = WebGLRenderingContext.FRAMEBUFFER;\n    export enum Status {\n      Complete = WebGLRenderingContext.FRAMEBUFFER_COMPLETE,\n      IncompleteAttachment = WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_ATTACHMENT,\n      IncompleteMissingAttachment = WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT,\n      IncompleteDimensions = WebGLRenderingContext.FRAMEBUFFER_INCOMPLETE_DIMENSIONS,\n      Unsupported = WebGLRenderingContext.FRAMEBUFFER_UNSUPPORTED,\n    }\n  }\n\n  export enum BufferBit {\n    Color = WebGLRenderingContext.COLOR_BUFFER_BIT,\n    Depth = WebGLRenderingContext.DEPTH_BUFFER_BIT,\n    Stencil = WebGLRenderingContext.STENCIL_BUFFER_BIT,\n  }\n\n  export const POLYGON_OFFSET_FILL = WebGLRenderingContext.POLYGON_OFFSET_FILL;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { Id64, BeTimePoint, IDisposable, dispose, assert } from \"@bentley/bentleyjs-core\";\nimport { ViewFlags, ElementAlignedBox3d } from \"@bentley/imodeljs-common\";\nimport { Transform } from \"@bentley/geometry-core\";\nimport { Primitive } from \"./Primitive\";\nimport { RenderGraphic, GraphicBranch, GraphicList, PackedFeature, PackedFeatureTable, RenderMemory } from \"../System\";\nimport { RenderCommands } from \"./DrawCommand\";\nimport { FeatureSymbology } from \"../FeatureSymbology\";\nimport { TextureHandle, Texture2DHandle, Texture2DDataUpdater } from \"./Texture\";\nimport { LUTDimensions, LUTParams } from \"./FeatureDimensions\";\nimport { Hilites, Target } from \"./Target\";\nimport { OvrFlags, RenderPass } from \"./RenderFlags\";\nimport { LineCode } from \"./EdgeOverrides\";\nimport { GL } from \"./GL\";\nimport { ClipPlanesVolume, ClipMaskVolume } from \"./ClipVolume\";\nimport { PlanarClassifier } from \"./PlanarClassifier\";\n\nfunction isFeatureHilited(feature: PackedFeature, hilites: Hilites): boolean {\n  if (hilites.isEmpty)\n    return false;\n\n  return hilites.elements.has(feature.elementId.lower, feature.elementId.upper) ||\n    hilites.subcategories.has(feature.subCategoryId.lower, feature.subCategoryId.upper);\n}\n\n/** @internal */\nexport class FeatureOverrides implements IDisposable {\n  public lut?: TextureHandle;\n  public readonly target: Target;\n  private _lastOverridesUpdated: BeTimePoint = BeTimePoint.now();\n  private _lastFlashUpdated: BeTimePoint = BeTimePoint.now();\n  private _lastHiliteUpdated: BeTimePoint = BeTimePoint.now();\n  public lutParams: LUTParams = new LUTParams(1, 1);\n  public anyOverridden: boolean = true;\n  public allHidden: boolean = true;\n  public anyTranslucent: boolean = true;\n  public anyOpaque: boolean = true;\n  public anyHilited: boolean = true;\n\n  public get byteLength(): number { return undefined !== this.lut ? this.lut.bytesUsed : 0; }\n  public get isUniform() { return 2 === this.lutParams.width && 1 === this.lutParams.height; }\n  public get isUniformFlashed() {\n    if (!this.isUniform || undefined === this.lut)\n      return false;\n\n    const lut = this.lut as Texture2DHandle;\n    const flags = lut.dataBytes![0];\n    return 0 !== (flags & OvrFlags.Flashed);\n  }\n\n  private _initialize(map: PackedFeatureTable, ovrs: FeatureSymbology.Overrides, hilite: Hilites, flashed?: Id64.Uint32Pair): TextureHandle | undefined {\n    const nFeatures = map.numFeatures;\n    const dims: LUTDimensions = LUTDimensions.computeWidthAndHeight(nFeatures, 2);\n    const width = dims.width;\n    const height = dims.height;\n    assert(width * height >= nFeatures);\n\n    this.lutParams = new LUTParams(width, height);\n\n    const data = new Uint8Array(width * height * 4);\n    const creator = new Texture2DDataUpdater(data);\n    this.buildLookupTable(creator, map, ovrs, flashed, hilite);\n\n    return TextureHandle.createForData(width, height, data, true, GL.Texture.WrapMode.ClampToEdge);\n  }\n\n  private _update(map: PackedFeatureTable, lut: TextureHandle, flashed?: Id64.Uint32Pair, hilites?: Hilites, ovrs?: FeatureSymbology.Overrides) {\n    const updater = new Texture2DDataUpdater(lut.dataBytes!);\n\n    if (undefined === ovrs) {\n      this.updateFlashedAndHilited(updater, map, flashed, hilites);\n    } else {\n      assert(undefined !== hilites);\n      this.buildLookupTable(updater, map, ovrs, flashed, hilites!);\n    }\n\n    (lut as Texture2DHandle).update(updater);\n  }\n\n  private buildLookupTable(data: Texture2DDataUpdater, map: PackedFeatureTable, ovr: FeatureSymbology.Overrides, flashedIdParts: Id64.Uint32Pair | undefined, hilites: Hilites) {\n    const modelIdParts = Id64.getUint32Pair(map.modelId);\n    const isModelHilited = hilites.models.has(modelIdParts.lower, modelIdParts.upper);\n\n    this.anyOpaque = this.anyTranslucent = this.anyHilited = false;\n\n    let nHidden = 0;\n    let nOverridden = 0;\n\n    // NB: We currently use 2 RGBA values per feature as follows:\n    //  [0]\n    //      R = override flags (see FeatureOverrides::Flags)\n    //      G = line weight\n    //      B = line code\n    //      A = 1 if no-locatable\n    //  [1]\n    //      RGB = rgb\n    //      A = alpha\n    for (let i = 0; i < map.numFeatures; i++) {\n      const feature = map.getPackedFeature(i);\n      const dataIndex = i * 4 * 2;\n\n      const app = ovr.getAppearance(\n        feature.elementId.lower, feature.elementId.upper,\n        feature.subCategoryId.lower, feature.subCategoryId.upper,\n        feature.geometryClass,\n        modelIdParts.lower, modelIdParts.upper, map.type, feature.animationNodeId);\n\n      if (undefined === app || app.isFullyTransparent) {\n        // The feature is not visible. We don't care about any of the other overrides, because we're not going to render it.\n        data.setOvrFlagsAtIndex(dataIndex, OvrFlags.Visibility);\n        nHidden++;\n        nOverridden++;\n        continue;\n      }\n\n      let flags = OvrFlags.None;\n      if (isModelHilited || isFeatureHilited(feature, hilites)) {\n        flags |= OvrFlags.Hilited;\n        this.anyHilited = true;\n      }\n\n      if (app.overridesRgb && app.rgb) {\n        flags |= OvrFlags.Rgb;\n        const rgb = app.rgb;\n        data.setByteAtIndex(dataIndex + 4, rgb.r);\n        data.setByteAtIndex(dataIndex + 5, rgb.g);\n        data.setByteAtIndex(dataIndex + 6, rgb.b);\n      }\n\n      if (undefined !== app.transparency) {\n        // transparency in range [0, 1]...convert to byte and invert so 0=transparent...\n        flags |= OvrFlags.Alpha;\n        let alpha = 1.0 - app.transparency;\n        alpha = Math.floor(0xff * alpha + 0.5);\n        data.setByteAtIndex(dataIndex + 7, alpha);\n        if (0xff === alpha)\n          this.anyOpaque = true;\n        else\n          this.anyTranslucent = true;\n      }\n\n      if (app.overridesWeight && app.weight) {\n        flags |= OvrFlags.Weight;\n        let weight = app.weight;\n        weight = Math.min(31, weight);\n        weight = Math.max(1, weight);\n        data.setByteAtIndex(dataIndex + 1, weight);\n      }\n\n      if (app.overridesLinePixels && app.linePixels) {\n        flags |= OvrFlags.LineCode;\n        const lineCode = LineCode.valueFromLinePixels(app.linePixels);\n        data.setByteAtIndex(dataIndex + 2, lineCode);\n      }\n\n      if (app.ignoresMaterial)\n        flags |= OvrFlags.IgnoreMaterial;\n\n      if (undefined !== flashedIdParts && feature.elementId.lower === flashedIdParts.lower && feature.elementId.upper === flashedIdParts.upper)\n        flags |= OvrFlags.Flashed;\n\n      data.setByteAtIndex(dataIndex + 3, app.nonLocatable ? 1 : 0);\n\n      data.setOvrFlagsAtIndex(dataIndex, flags);\n      if (OvrFlags.None !== flags || app.nonLocatable)\n        nOverridden++;\n    }\n\n    this.allHidden = (nHidden === map.numFeatures);\n    this.anyOverridden = (nOverridden > 0);\n  }\n\n  // NB: If hilites is undefined, it means that the hilited set has not changed.\n  private updateFlashedAndHilited(data: Texture2DDataUpdater, map: PackedFeatureTable, flashed?: Id64.Uint32Pair, hilites?: Hilites) {\n    this.anyOverridden = this.anyHilited = false;\n\n    let isModelHilited = false;\n    let needElemId = undefined !== flashed;\n    let needSubCatId = false;\n    if (undefined !== hilites) {\n      const modelId = Id64.getUint32Pair(map.modelId);\n      isModelHilited = hilites.models.has(modelId.lower, modelId.upper);\n      needSubCatId = !isModelHilited && !hilites.subcategories.isEmpty;\n      needElemId = needElemId || (!isModelHilited && !hilites.elements.isEmpty);\n    }\n\n    for (let i = 0; i < map.numFeatures; i++) {\n      const dataIndex = i * 4 * 2;\n      const oldFlags = data.getFlagsAtIndex(dataIndex);\n      if (OvrFlags.None !== (oldFlags & OvrFlags.Visibility)) {\n        // Do the same thing as when applying feature overrides - if it's invisible, none of the other flags matter\n        // (and if we don't check this we can end up rendering silhouettes around invisible elements in selection set)\n        this.anyOverridden = true;\n        continue;\n      }\n\n      let isFlashed = false;\n      let isHilited = undefined !== hilites ? isModelHilited : (0 !== (oldFlags & OvrFlags.Hilited));\n\n      if (needElemId) {\n        const elemId = map.getElementIdPair(i);\n        if (undefined !== flashed)\n          isFlashed = elemId.lower === flashed.lower && elemId.upper === flashed.upper;\n\n        if (!isHilited && undefined !== hilites)\n          isHilited = hilites.elements.has(elemId.lower, elemId.upper);\n      }\n\n      if (needSubCatId && !isHilited) {\n        const subcat = map.getSubCategoryIdPair(i);\n        isHilited = hilites!.subcategories.has(subcat.lower, subcat.upper);\n      }\n\n      let newFlags = isFlashed ? (oldFlags | OvrFlags.Flashed) : (oldFlags & ~OvrFlags.Flashed);\n      newFlags = isHilited ? (newFlags | OvrFlags.Hilited) : (newFlags & ~OvrFlags.Hilited);\n\n      data.setOvrFlagsAtIndex(dataIndex, newFlags);\n      if (OvrFlags.None !== newFlags) {\n        this.anyOverridden = true;\n        this.anyHilited = this.anyHilited || isHilited;\n      }\n    }\n  }\n\n  private constructor(target: Target) {\n    this.target = target;\n  }\n\n  public static createFromTarget(target: Target) {\n    return new FeatureOverrides(target);\n  }\n\n  public dispose() {\n    dispose(this.lut);\n    this.lut = undefined;\n  }\n\n  public initFromMap(map: PackedFeatureTable) {\n    const nFeatures = map.numFeatures;\n    assert(0 < nFeatures);\n\n    this.lut = undefined;\n\n    const ovrs: FeatureSymbology.Overrides = this.target.currentFeatureSymbologyOverrides;\n    const hilite = this.target.hilites;\n    this.lut = this._initialize(map, ovrs, hilite, this.target.flashed);\n    this._lastOverridesUpdated = this._lastFlashUpdated = this._lastHiliteUpdated = BeTimePoint.now();\n  }\n\n  public update(features: PackedFeatureTable) {\n    const styleLastUpdated = this.target.overridesUpdateTime;\n    const flashLastUpdated = this.target.flashedUpdateTime;\n    const ovrsUpdated = this._lastOverridesUpdated.before(styleLastUpdated);\n    const hiliteLastUpdated = this.target.hiliteUpdateTime;\n    const hiliteUpdated = this._lastHiliteUpdated.before(hiliteLastUpdated);\n\n    const ovrs = ovrsUpdated ? this.target.currentFeatureSymbologyOverrides : undefined;\n    const hilite = this.target.hilites;\n    if (ovrsUpdated || hiliteUpdated || this._lastFlashUpdated.before(flashLastUpdated)) {\n      this._update(features, this.lut!, this.target.flashed, undefined !== ovrs || hiliteUpdated ? hilite : undefined, ovrs);\n\n      this._lastOverridesUpdated = styleLastUpdated;\n      this._lastFlashUpdated = flashLastUpdated;\n      this._lastHiliteUpdated = hiliteLastUpdated;\n    }\n  }\n}\n\n/** @internal */\nexport abstract class Graphic extends RenderGraphic {\n  public abstract addCommands(_commands: RenderCommands): void;\n  public get isPickable(): boolean { return false; }\n  public addHiliteCommands(_commands: RenderCommands, _batch: Batch, _pass: RenderPass): void { assert(false); }\n  public toPrimitive(): Primitive | undefined { return undefined; }\n}\n\n/** @internal */\nexport class Batch extends Graphic {\n  public readonly graphic: RenderGraphic;\n  public readonly featureTable: PackedFeatureTable;\n  public readonly range: ElementAlignedBox3d;\n  public batchId: number = 0; // Transient ID assigned while rendering a frame, reset afterward.\n  private _overrides: FeatureOverrides[] = [];\n\n  public constructor(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d) {\n    super();\n    this.graphic = graphic;\n    this.featureTable = features;\n    this.range = range;\n  }\n\n  // Note: This does not remove FeatureOverrides from the array, but rather disposes of the WebGL resources they contain\n  public dispose() {\n    dispose(this.graphic);\n    for (const over of this._overrides) {\n      over.target.onBatchDisposed(this);\n      dispose(over);\n    }\n    this._overrides.length = 0;\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    this.graphic.collectStatistics(stats);\n    stats.addFeatureTable(this.featureTable.byteLength);\n    for (const ovrs of this._overrides)\n      stats.addFeatureOverrides(ovrs.byteLength);\n  }\n\n  public addCommands(commands: RenderCommands): void { commands.addBatch(this); }\n  public get isPickable(): boolean { return true; }\n\n  public getOverrides(target: Target): FeatureOverrides {\n    let ret: FeatureOverrides | undefined;\n\n    for (const ovr of this._overrides) {\n      if (ovr.target === target) {\n        ret = ovr;\n        break;\n      }\n    }\n\n    if (undefined === ret) {\n      ret = FeatureOverrides.createFromTarget(target);\n      this._overrides.push(ret);\n      target.addBatch(this);\n      ret.initFromMap(this.featureTable);\n    }\n\n    ret.update(this.featureTable);\n    return ret;\n  }\n\n  public onTargetDisposed(target: Target) {\n    let index = 0;\n    let foundIndex = -1;\n\n    for (const ovr of this._overrides) {\n      if (ovr.target === target) {\n        foundIndex = index;\n        break;\n      }\n      index++;\n    }\n\n    if (foundIndex > -1) {\n      dispose(this._overrides[foundIndex]);\n      this._overrides.splice(foundIndex, 1);\n    }\n  }\n}\n\n/** @internal */\nexport class Branch extends Graphic {\n  public readonly branch: GraphicBranch;\n  public localToWorldTransform: Transform;\n  public clips?: ClipPlanesVolume | ClipMaskVolume;\n  public planarClassifier?: PlanarClassifier;\n  public readonly animationId?: number;\n\n  public constructor(branch: GraphicBranch, localToWorld: Transform = Transform.createIdentity(), clips?: ClipMaskVolume | ClipPlanesVolume, viewFlags?: ViewFlags, planarClassifier?: PlanarClassifier) {\n    super();\n    this.branch = branch;\n    this.localToWorldTransform = localToWorld;\n    this.clips = clips;\n    this.planarClassifier = planarClassifier;\n    if (undefined !== viewFlags)\n      branch.setViewFlags(viewFlags);\n  }\n\n  public dispose() { this.branch.dispose(); }\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    this.branch.collectStatistics(stats);\n    if (undefined !== this.clips)\n      this.clips.collectStatistics(stats);\n  }\n\n  public addCommands(commands: RenderCommands): void { commands.addBranch(this); }\n  public addHiliteCommands(commands: RenderCommands, batch: Batch, pass: RenderPass): void { commands.addHiliteBranch(this, batch, pass); }\n}\n\n/** @internal */\nexport class WorldDecorations extends Branch {\n  public constructor(viewFlags: ViewFlags) {\n    super(new GraphicBranch(), Transform.identity, undefined, viewFlags);\n\n    // World decorations ignore all the symbology overrides for the \"scene\" geometry...\n    this.branch.symbologyOverrides = new FeatureSymbology.Overrides();\n  }\n\n  public init(decs: GraphicList): void {\n    this.branch.clear();\n    for (const dec of decs) {\n      this.branch.add(dec);\n    }\n  }\n}\n/** @internal */\nexport class GraphicsArray extends Graphic {\n  // Note: We assume the graphics array we get contains undisposed graphics to start\n  constructor(public graphics: RenderGraphic[]) { super(); }\n\n  public dispose() {\n    for (const graphic of this.graphics)\n      dispose(graphic);\n    this.graphics.length = 0;\n  }\n\n  public addCommands(commands: RenderCommands): void {\n    for (const graphic of this.graphics) {\n      (graphic as Graphic).addCommands(commands);\n    }\n  }\n\n  public addHiliteCommands(commands: RenderCommands, batch: Batch, pass: RenderPass): void {\n    for (const graphic of this.graphics) {\n      (graphic as Graphic).addHiliteCommands(commands, batch, pass);\n    }\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    for (const graphic of this.graphics)\n      graphic.collectStatistics(stats);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert, IDisposable } from \"@bentley/bentleyjs-core\";\nimport { GL } from \"./GL\";\nimport { QParams3d, QParams2d } from \"@bentley/imodeljs-common\";\nimport { Matrix3, Matrix4 } from \"./Matrix\";\nimport { System } from \"./System\";\nimport { Point3d } from \"@bentley/geometry-core\";\n\n/** @internal */\nexport type BufferData = number | Int8Array | Int16Array | Int32Array | Uint8Array | Uint16Array | Uint32Array | Uint8ClampedArray | Float32Array | Float64Array | DataView | ArrayBuffer;\n\n/**\n * A handle to a WebGLBuffer, such as a vertex or index buffer.\n * The WebGLBuffer is allocated by the constructor and should be freed by a call to dispose().\n * @internal\n */\nexport class BufferHandle implements IDisposable {\n  private _glBuffer?: WebGLBuffer;\n  private _bytesUsed = 0;\n\n  /** Allocates the WebGLBuffer using the supplied context. Free the WebGLBuffer using dispose() */\n  public constructor() {\n    const glBuffer = System.instance.context.createBuffer();\n\n    // gl.createBuffer() returns WebGLBuffer | null...\n    if (null !== glBuffer) {\n      this._glBuffer = glBuffer;\n    } else {\n      this._glBuffer = undefined;\n    }\n\n    assert(!this.isDisposed);\n  }\n\n  public get isDisposed(): boolean { return this._glBuffer === undefined; }\n  public get bytesUsed(): number { return this._bytesUsed; }\n\n  /** Frees the WebGL buffer */\n  public dispose(): void {\n    if (!this.isDisposed) {\n      System.instance.context.deleteBuffer(this._glBuffer!);\n      this._glBuffer = undefined;\n    }\n  }\n\n  /** Binds this buffer to the specified target */\n  public bind(target: GL.Buffer.Target): void {\n    if (undefined !== this._glBuffer) {\n      System.instance.context.bindBuffer(target, this._glBuffer);\n    }\n  }\n\n  /** Sets the specified target to be bound to no buffer */\n  public static unbind(target: GL.Buffer.Target): void { System.instance.context.bindBuffer(target, null); }\n\n  /** Binds this buffer to the specified target and sets the buffer's data store. */\n  public bindData(target: GL.Buffer.Target, data: BufferSource, usage: GL.Buffer.Usage = GL.Buffer.Usage.StaticDraw): void {\n    this.bind(target);\n    System.instance.context.bufferData(target, data, usage);\n    BufferHandle.unbind(target);\n    this._bytesUsed = data.byteLength;\n  }\n\n  /** Creates a BufferHandle and binds its data */\n  public static createBuffer(target: GL.Buffer.Target, data: BufferSource, usage: GL.Buffer.Usage = GL.Buffer.Usage.StaticDraw): BufferHandle | undefined {\n    const handle = new BufferHandle();\n    if (handle.isDisposed) {\n      return undefined;\n    }\n\n    handle!.bindData(target, data, usage);\n    return handle;\n  }\n  /** Creates a BufferHandle and binds its data */\n  public static createArrayBuffer(data: BufferSource, usage: GL.Buffer.Usage = GL.Buffer.Usage.StaticDraw) {\n    return BufferHandle.createBuffer(GL.Buffer.Target.ArrayBuffer, data, usage);\n  }\n\n  public isBound(binding: GL.Buffer.Binding) { return System.instance.context.getParameter(binding) === this._glBuffer; }\n}\n\nfunction setScale(index: number, value: number, array: Float32Array) {\n  array[index] = 0.0 !== value ? 1.0 / value : value;\n}\n\n/**\n * Converts 2d quantization parameters to a format appropriate for submittal to the GPU.\n * params[0] = origin.x\n * params[1] = origin.y\n * params[2] = scale.x\n * params[3] = scale.y\n * @internal\n */\nexport function qparams2dToArray(params: QParams2d): Float32Array {\n  const arr = new Float32Array(4);\n\n  arr[0] = params.origin.x;\n  arr[1] = params.origin.y;\n  setScale(2, params.scale.x, arr);\n  setScale(3, params.scale.y, arr);\n\n  return arr;\n}\n\n/** @internal */\nexport function qorigin3dToArray(qorigin: Point3d): Float32Array {\n  const origin = new Float32Array(3);\n  origin[0] = qorigin.x;\n  origin[1] = qorigin.y;\n  origin[2] = qorigin.z;\n  return origin;\n}\n\n/** @internal */\nexport function qscale3dToArray(qscale: Point3d): Float32Array {\n  const scale = new Float32Array(3);\n  setScale(0, qscale.x, scale);\n  setScale(1, qscale.y, scale);\n  setScale(2, qscale.z, scale);\n  return scale;\n}\n\n/** Converts 3d quantization params to a pair of Float32Arrays\n * @internal\n */\nexport function qparams3dToArray(params: QParams3d): { origin: Float32Array, scale: Float32Array } {\n  const origin = qorigin3dToArray(params.origin);\n  const scale = qscale3dToArray(params.scale);\n  return { origin, scale };\n}\n\n/** A handle to a WebGLBuffer intended to hold quantized 2d points\n * @internal\n */\nexport class QBufferHandle2d extends BufferHandle {\n  public readonly params: Float32Array;\n\n  public constructor(params: QParams2d) {\n    super();\n    this.params = qparams2dToArray(params);\n  }\n\n  public static create(params: QParams2d, data: Uint16Array): QBufferHandle2d | undefined {\n    const handle = new QBufferHandle2d(params);\n    if (handle.isDisposed) {\n      return undefined;\n    }\n\n    handle.bindData(GL.Buffer.Target.ArrayBuffer, data);\n    return handle;\n  }\n}\n\n/* A handle to a WebGLBuffer intended to hold quantized 3d points\n * @internal\n */\nexport class QBufferHandle3d extends BufferHandle {\n  /** The quantization origin in x, y, and z */\n  public readonly origin: Float32Array;\n  /** The quantization scale in x, y, and z */\n  public readonly scale: Float32Array;\n\n  public constructor(params: QParams3d) {\n    super();\n    this.origin = qorigin3dToArray(params.origin);\n    this.scale = qscale3dToArray(params.scale);\n  }\n\n  public static create(params: QParams3d, data: Uint16Array): QBufferHandle3d | undefined {\n    const handle = new QBufferHandle3d(params);\n    if (handle.isDisposed) {\n      return undefined;\n    }\n\n    handle.bindData(GL.Buffer.Target.ArrayBuffer, data);\n    return handle;\n  }\n}\n\n/** A handle to the location of an attribute within a shader program\n * @internal\n */\nexport class AttributeHandle {\n  private readonly _glId: number;\n\n  private constructor(glId: number) { this._glId = glId; }\n\n  public static create(program: WebGLProgram, name: string, required: boolean = false): AttributeHandle | undefined {\n    const glId = System.instance.context.getAttribLocation(program, name);\n    if (-1 === glId) {\n      assert(!required, \"getAttribLocation failed for \" + name);\n      return undefined;\n    }\n\n    return new AttributeHandle(glId);\n  }\n\n  public setVertexAttribPointer(size: number, type: number, normalized: boolean, stride: number, offset: number) {\n    System.instance.context.vertexAttribPointer(this._glId, size, type, normalized, stride, offset);\n  }\n\n  public enableVertexAttribArray(instanced = false): void { System.instance.enableVertexAttribArray(this._glId, instanced); }\n\n  public enableArray(buffer: BufferHandle, size: number, type: GL.DataType, normalized: boolean, stride: number, offset: number, instanced = false): void {\n    buffer.bind(GL.Buffer.Target.ArrayBuffer);\n    this.setVertexAttribPointer(size, type, normalized, stride, offset);\n    this.enableVertexAttribArray(instanced);\n    BufferHandle.unbind(GL.Buffer.Target.ArrayBuffer);\n  }\n}\n\nconst enum DataType {\n  Undefined,\n  Mat3,\n  Mat4,\n  Float,\n  FloatArray,\n  Vec2,\n  Vec3,\n  Vec4,\n  Int,\n}\n\n/** A handle to the location of a uniform within a shader program\n * @internal\n */\nexport class UniformHandle {\n  private readonly _location: WebGLUniformLocation;\n  private _type: DataType = DataType.Undefined;\n  private readonly _data: number[] = [];\n\n  private constructor(location: WebGLUniformLocation) { this._location = location; }\n\n  public static create(program: WebGLProgram, name: string, required: boolean = true): UniformHandle | undefined {\n    const location = System.instance.context.getUniformLocation(program, name);\n    if (null === location) {\n      assert(!required, \"getUniformLocation failed for \" + name);\n      return undefined;\n    }\n\n    return new UniformHandle(location);\n  }\n\n  private updateData(type: DataType, data: Float32Array | number[]): boolean {\n    assert(DataType.Undefined !== type && DataType.Int !== type && DataType.Float !== type);\n\n    let updated = this._type !== type;\n    if (updated) {\n      this._type = type;\n      if (this._data.length !== data.length)\n        this._data.length = data.length;\n    }\n\n    for (let i = 0; i < data.length; i++) {\n      const datum = data[i];\n      updated = updated || this._data[i] !== datum;\n      this._data[i] = datum;\n    }\n\n    return updated;\n  }\n\n  private updateDatum(type: DataType, datum: number): boolean {\n    assert(DataType.Int === type || DataType.Float === type);\n\n    // NB: Yes, calling data.length without actually changing the length shows up as a significant performance bottleneck...\n    if (this._data.length !== 1)\n      this._data.length = 1;\n\n    const updated = this._type !== type || this._data[0] !== datum;\n    this._type = type;\n    this._data[0] = datum;\n\n    return updated;\n  }\n\n  public setMatrix3(mat: Matrix3) {\n    if (this.updateData(DataType.Mat3, mat.data))\n      System.instance.context.uniformMatrix3fv(this._location, false, mat.data);\n  }\n\n  public setMatrix4(mat: Matrix4) {\n    if (this.updateData(DataType.Mat4, mat.data))\n      System.instance.context.uniformMatrix4fv(this._location, false, mat.data);\n  }\n\n  public setUniform1fv(data: Float32Array | number[]) {\n    if (this.updateData(DataType.FloatArray, data))\n      System.instance.context.uniform1fv(this._location, data);\n  }\n\n  public setUniform2fv(data: Float32Array | number[]) {\n    if (this.updateData(DataType.Vec2, data))\n      System.instance.context.uniform2fv(this._location, data);\n  }\n\n  public setUniform3fv(data: Float32Array | number[]) {\n    if (this.updateData(DataType.Vec3, data))\n      System.instance.context.uniform3fv(this._location, data);\n  }\n\n  public setUniform4fv(data: Float32Array | number[]) {\n    if (this.updateData(DataType.Vec4, data))\n      System.instance.context.uniform4fv(this._location, data);\n  }\n\n  public setUniform1i(data: number) {\n    if (this.updateDatum(DataType.Int, data))\n      System.instance.context.uniform1i(this._location, data);\n  }\n\n  public setUniform1f(data: number) {\n    if (this.updateDatum(DataType.Float, data))\n      System.instance.context.uniform1f(this._location, data);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module WebGL */\r\n\r\nimport { assert, dispose, IDisposable } from \"@bentley/bentleyjs-core\";\r\nimport { Range3d, Point3d, Transform } from \"@bentley/geometry-core\";\r\nimport { InstancedGraphicParams, RenderMemory } from \"../System\";\r\nimport { CachedGeometry, LUTGeometry } from \"./CachedGeometry\";\r\nimport { Target } from \"./Target\";\r\nimport { ShaderProgramParams } from \"./DrawCommand\";\r\nimport { AttributeHandle, BufferHandle } from \"./Handle\";\r\nimport { FeaturesInfo } from \"./FeaturesInfo\";\r\n\r\n/** @internal */\r\nexport class InstanceBuffers implements IDisposable {\r\n  public readonly numInstances: number;\r\n  public readonly transforms: BufferHandle;\r\n  public readonly featureIds?: BufferHandle;\r\n  public readonly featuresInfo?: FeaturesInfo;\r\n  public readonly symbology?: BufferHandle;\r\n  public readonly shared: boolean;\r\n  // The center of the range of the instances' translations.\r\n  private readonly _rtcCenter: Point3d;\r\n  // A transform from _rtcCenter including model matrix\r\n  private readonly _rtcTransform: Transform;\r\n  // The model matrix from which _rtcTransform was previously computed. If it changes, _rtcTransform must be recomputed.\r\n  private readonly _modelMatrix = Transform.createIdentity();\r\n  // Holds the instance transforms for computing range. Set to undefined after range computed (immediately after construction)\r\n  private _transforms?: Float32Array;\r\n  // Holds the range computed from the above transforms\r\n  private _range?: Range3d;\r\n\r\n  private constructor(shared: boolean, count: number, transforms: BufferHandle, rtcCenter: Point3d, transformsData: Float32Array, symbology?: BufferHandle, featureIds?: BufferHandle, featuresInfo?: FeaturesInfo) {\r\n    this.shared = shared;\r\n    this.numInstances = count;\r\n    this.transforms = transforms;\r\n    this.featureIds = featureIds;\r\n    this.featuresInfo = featuresInfo;\r\n    this.symbology = symbology;\r\n    this._rtcCenter = rtcCenter;\r\n    this._rtcTransform = Transform.createTranslation(this._rtcCenter);\r\n    this._transforms = transformsData;\r\n  }\r\n\r\n  public static create(params: InstancedGraphicParams, shared: boolean): InstanceBuffers | undefined {\r\n    const { count, featureIds, symbologyOverrides, transforms } = params;\r\n\r\n    assert(count > 0 && Math.floor(count) === count);\r\n    assert(count === transforms.length / 12);\r\n    assert(undefined === featureIds || count === featureIds.length / 3);\r\n    assert(undefined === symbologyOverrides || count * 8 === symbologyOverrides.length);\r\n\r\n    let idBuf: BufferHandle | undefined;\r\n    if (undefined !== featureIds && undefined === (idBuf = BufferHandle.createArrayBuffer(featureIds)))\r\n      return undefined;\r\n\r\n    const featuresInfo = FeaturesInfo.createFromFeatureIds(featureIds);\r\n\r\n    let symBuf: BufferHandle | undefined;\r\n    if (undefined !== symbologyOverrides && undefined === (symBuf = BufferHandle.createArrayBuffer(symbologyOverrides)))\r\n      return undefined;\r\n\r\n    const tfBuf = BufferHandle.createArrayBuffer(transforms);\r\n    return undefined !== tfBuf ? new InstanceBuffers(shared, count, tfBuf, params.transformCenter, transforms, symBuf, idBuf, featuresInfo) : undefined;\r\n  }\r\n\r\n  public getRtcTransform(modelMatrix: Transform): Transform {\r\n    if (!this._modelMatrix.isAlmostEqual(modelMatrix)) {\r\n      modelMatrix.clone(this._modelMatrix);\r\n      const rtcTransform = Transform.createTranslation(this._rtcCenter);\r\n      modelMatrix.multiplyTransformTransform(rtcTransform, this._rtcTransform);\r\n    }\r\n\r\n    return this._rtcTransform;\r\n  }\r\n\r\n  public dispose() {\r\n    dispose(this.transforms);\r\n    dispose(this.featureIds);\r\n    dispose(this.symbology);\r\n  }\r\n\r\n  public get rtcCenter(): Point3d { return this._rtcCenter; }\r\n\r\n  public collectStatistics(stats: RenderMemory.Statistics): void {\r\n    const featureBytes = undefined !== this.featureIds ? this.featureIds.bytesUsed : 0;\r\n    const symBytes = undefined !== this.symbology ? this.symbology.bytesUsed : 0;\r\n\r\n    const bytesUsed = this.transforms.bytesUsed + symBytes + featureBytes;\r\n    stats.addInstances(bytesUsed);\r\n  }\r\n\r\n  public computeRange(reprRange: Range3d, out?: Range3d): Range3d {\r\n    if (undefined !== this._range)\r\n      return this._range.clone(out);\r\n\r\n    this._range = new Range3d();\r\n    const tfs = this._transforms;\r\n    if (undefined === tfs) {\r\n      assert(false);\r\n      return this._range.clone(out);\r\n    }\r\n\r\n    this._transforms = undefined;\r\n\r\n    const numFloatsPerTransform = 3 * 4;\r\n    assert(0 === tfs.length % (3 * 4));\r\n\r\n    const tf = Transform.createIdentity();\r\n    const r = new Range3d();\r\n    for (let i = 0; i < tfs.length; i += numFloatsPerTransform) {\r\n      tf.setFromJSON({\r\n        origin: [ tfs[i + 3], tfs[i + 7], tfs[i + 11] ],\r\n        matrix: [\r\n          [ tfs[i + 0], tfs[i + 1], tfs[i + 2] ],\r\n          [ tfs[i + 4], tfs[i + 5], tfs[i + 6] ],\r\n          [ tfs[i + 8], tfs[i + 9], tfs[i + 10] ],\r\n        ],\r\n      });\r\n\r\n      reprRange.clone(r);\r\n      tf.multiplyRange(r, r);\r\n      this._range.extendRange(r);\r\n    }\r\n\r\n    const rtcTransform = Transform.createTranslation(this._rtcCenter);\r\n    rtcTransform.multiplyRange(this._range, this._range);\r\n\r\n    return this._range.clone(out);\r\n  }\r\n}\r\n\r\n/** @internal */\r\nexport class InstancedGeometry extends CachedGeometry {\r\n  private readonly _buffers: InstanceBuffers;\r\n  private readonly _repr: LUTGeometry;\r\n  private readonly _ownsRepr: boolean;\r\n\r\n  public get numInstances() { return this._buffers.numInstances; }\r\n  public get transforms() { return this._buffers.transforms; }\r\n  public get featureIds() { return this._buffers.featureIds; }\r\n  public get symbology() { return this._buffers.symbology; }\r\n  public getRtcTransform(modelMatrix: Transform) { return this._buffers.getRtcTransform(modelMatrix); }\r\n\r\n  public get asInstanced() { return this; }\r\n  public get asLUT() { return this._repr.asLUT; }\r\n  public get asMesh() { return this._repr.asMesh; }\r\n  public get asSurface() { return this._repr.asSurface; }\r\n  public get asEdge() { return this._repr.asEdge; }\r\n  public get asSilhouette() { return this._repr.asSilhouette; }\r\n\r\n  public get renderOrder() { return this._repr.renderOrder; }\r\n  public get isLitSurface() { return this._repr.isLitSurface; }\r\n  public get hasBakedLighting() { return this._repr.hasBakedLighting; }\r\n  public get hasAnimation() { return this._repr.hasAnimation; }\r\n  public get qOrigin() { return this._repr.qOrigin; }\r\n  public get qScale() { return this._repr.qScale; }\r\n  public get material() { return this._repr.material; }\r\n  public get polylineBuffers() { return this._repr.polylineBuffers; }\r\n  public set uniformFeatureIndices(_value: number) { assert(false); } // This is used for decoration graphics. No such thing as instanced decorations.\r\n  public get isEdge() { return this._repr.isEdge; }\r\n  public get featuresInfo() { return this._buffers.featuresInfo; }\r\n\r\n  public getTechniqueId(target: Target) { return this._repr.getTechniqueId(target); }\r\n  public getRenderPass(target: Target) { return this._repr.getRenderPass(target); }\r\n  public wantWoWReversal(params: ShaderProgramParams) { return this._repr.wantWoWReversal(params); }\r\n  public getLineCode(params: ShaderProgramParams) { return this._repr.getLineCode(params); }\r\n  public getLineWeight(params: ShaderProgramParams) { return this._repr.getLineWeight(params); }\r\n\r\n  public get rtcCenter(): Point3d { return this._buffers.rtcCenter; }\r\n\r\n  public constructor(repr: LUTGeometry, ownsRepr: boolean, buffers: InstanceBuffers) {\r\n    super();\r\n    this._repr = repr;\r\n    this._ownsRepr = ownsRepr;\r\n    this._buffers = buffers;\r\n  }\r\n\r\n  public dispose() {\r\n    dispose(this._buffers);\r\n    if (this._ownsRepr)\r\n      this._repr.dispose();\r\n  }\r\n\r\n  public bindVertexArray(handle: AttributeHandle) {\r\n    this._repr.bindVertexArray(handle);\r\n  }\r\n\r\n  protected _wantWoWReversal(_target: Target) {\r\n    assert(false, \"Should never be called\");\r\n    return false;\r\n  }\r\n\r\n  public draw() {\r\n    this._repr.drawInstanced(this.numInstances);\r\n  }\r\n\r\n  public computeRange(output?: Range3d): Range3d {\r\n    if (undefined === this._range) {\r\n      this._range = new Range3d();\r\n      const reprRange = this._repr.computeRange();\r\n      this._buffers.computeRange(reprRange, this._range);\r\n    }\r\n\r\n    return this._range.clone(output);\r\n  }\r\n\r\n  public collectStatistics(stats: RenderMemory.Statistics) {\r\n    this._repr.collectStatistics(stats);\r\n    if (!this._buffers.shared)\r\n      this._buffers.collectStatistics(stats);\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ColorDef, RenderMaterial } from \"@bentley/imodeljs-common\";\n\n/** @internal */\nexport class Material extends RenderMaterial {\n  public static readonly default: Material = new Material(RenderMaterial.Params.defaults);\n\n  public readonly diffuseUniform = new Float32Array(4); // [red, green, blue, overridden]\n  public readonly reflectColor?: ColorDef;\n  public readonly alphaUniform = new Float32Array(2); // [alpha, overridden]\n  public readonly specular = new Float32Array(4); // [red, green, blue, exponent]\n  public readonly weights = new Float32Array(3);  // [diffuse weight, specular weight, reflect]\n\n  public get textureWeight(): number { return undefined !== this.textureMapping ? this.textureMapping.params.weight : 1.0; }\n  public get overridesRgb(): boolean { return 1.0 === this.diffuseUniform[3]; }\n  public get overridesAlpha(): boolean { return 1.0 === this.alphaUniform[1]; }\n  public get hasTranslucency(): boolean { return this.overridesAlpha && this.alphaUniform[0] < 1.0; }\n\n  public constructor(materialParams: RenderMaterial.Params) {\n    super(materialParams);\n\n    this.diffuseUniform[3] = undefined !== materialParams.diffuseColor ? 1.0 : 0.0;\n    if (undefined !== materialParams.diffuseColor) {\n      const diffRgb = materialParams.diffuseColor.colors;\n      this.diffuseUniform[0] = diffRgb.r / 255;\n      this.diffuseUniform[1] = diffRgb.g / 255;\n      this.diffuseUniform[2] = diffRgb.b / 255;\n    } else {\n      this.diffuseUniform[0] = this.diffuseUniform[1] = this.diffuseUniform[2] = 1.0;\n    }\n\n    this.specular[3] = materialParams.specularExponent;\n    if (materialParams.specularColor) {\n      const specRgb = materialParams.specularColor.colors;\n      this.specular[0] = specRgb.r / 255;\n      this.specular[1] = specRgb.g / 255;\n      this.specular[2] = specRgb.b / 255;\n    } else {\n      this.specular[0] = this.specular[1] = this.specular[2] = 1.0;\n    }\n\n    if (materialParams.reflectColor)\n      this.reflectColor = materialParams.reflectColor.clone();\n\n    this.weights[0] = materialParams.diffuse;\n    this.weights[1] = materialParams.specular;\n    this.weights[2] = materialParams.reflect;\n\n    if (0.0 !== materialParams.transparency) {\n      this.alphaUniform[0] = 1.0 - materialParams.transparency;\n      this.alphaUniform[1] = 1.0;\n    } else {\n      this.alphaUniform[0] = 1.0;\n      this.alphaUniform[1] = 0.0;\n    }\n  }\n}\n\nObject.freeze(Material.default);\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { Vector3d, Point3d, Matrix3d, Transform, Matrix4d } from \"@bentley/geometry-core\";\nimport { assert } from \"@bentley/bentleyjs-core\";\n\n/** @internal */\nexport class Matrix3 {\n  public readonly data: Float32Array = new Float32Array(3 * 3);\n\n  public constructor() { }\n\n  public initIdentity(): void {\n    this.setValues(1, 0, 0, 0, 1, 0, 0, 0, 1);\n  }\n  public static fromIdentity(out?: Matrix3): Matrix3 {\n    const mat = undefined !== out ? out : new Matrix3();\n    mat.initIdentity();\n    return mat;\n  }\n\n  public copyFrom(src: Matrix3): void {\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] = src.data[i];\n    }\n  }\n  public clone(out?: Matrix3): Matrix3 {\n    const mat = undefined !== out ? out : new Matrix3();\n    mat.copyFrom(this);\n    return mat;\n  }\n\n  public setValues(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number) {\n    this.m00 = m00; this.m01 = m01; this.m02 = m02;\n    this.m10 = m10; this.m11 = m11; this.m12 = m12;\n    this.m20 = m20; this.m21 = m21; this.m22 = m22;\n  }\n  public static fromValues(m00: number, m01: number, m02: number, m10: number, m11: number, m12: number, m20: number, m21: number, m22: number, out?: Matrix3) {\n    const mat = undefined !== out ? out : new Matrix3();\n    mat.setValues(m00, m01, m02, m10, m11, m12, m20, m21, m22);\n    return mat;\n  }\n\n  public initFromMatrix3d(rot: Matrix3d): void {\n    this.setValues(\n      rot.at(0, 0), rot.at(0, 1), rot.at(0, 2),\n      rot.at(1, 0), rot.at(1, 1), rot.at(1, 2),\n      rot.at(2, 0), rot.at(2, 1), rot.at(2, 2));\n  }\n  public static fromMatrix3d(rot: Matrix3d, out?: Matrix3): Matrix3 {\n    const mat = undefined !== out ? out : new Matrix3();\n    mat.initFromMatrix3d(rot);\n    return mat;\n  }\n  public toMatrix3d(): Matrix3d {\n    const data = this.data;\n    return Matrix3d.createRowValues(data[0], data[3], data[6], data[1], data[4], data[7], data[2], data[5], data[8]);\n  }\n\n  public swap(firstIndex: number, secondIndex: number) {\n    assert(firstIndex < this.data.length);\n    assert(secondIndex < this.data.length);\n    assert(secondIndex !== firstIndex);\n    const tmp = this.data[firstIndex];\n    this.data[firstIndex] = this.data[secondIndex];\n    this.data[secondIndex] = tmp;\n  }\n\n  public transpose(): void {\n    this.swap(1, 3);\n    this.swap(5, 7);\n    this.swap(2, 6);\n  }\n  public static fromTranspose(src: Matrix3, out?: Matrix3) {\n    const mat = src.clone(out);\n    mat.transpose();\n    return mat;\n  }\n\n  public get(index: number) { assert(index < this.data.length); return this.data[index]; }\n  public set(index: number, value: number) { assert(index < this.data.length); this.data[index] = value; }\n\n  public at(row: number, col: number) { return this.get(col * 3 + row); }\n  public setAt(row: number, col: number, value: number) { this.set(col * 3 + row, value); }\n\n  public get m00() { return this.at(0, 0); }\n  public set m00(value: number) { this.setAt(0, 0, value); }\n  public get m01() { return this.at(0, 1); }\n  public set m01(value: number) { this.setAt(0, 1, value); }\n  public get m02() { return this.at(0, 2); }\n  public set m02(value: number) { this.setAt(0, 2, value); }\n  public get m10() { return this.at(1, 0); }\n  public set m10(value: number) { this.setAt(1, 0, value); }\n  public get m11() { return this.at(1, 1); }\n  public set m11(value: number) { this.setAt(1, 1, value); }\n  public get m12() { return this.at(1, 2); }\n  public set m12(value: number) { this.setAt(1, 2, value); }\n  public get m20() { return this.at(2, 0); }\n  public set m20(value: number) { this.setAt(2, 0, value); }\n  public get m21() { return this.at(2, 1); }\n  public set m21(value: number) { this.setAt(2, 1, value); }\n  public get m22() { return this.at(2, 2); }\n  public set m22(value: number) { this.setAt(2, 2, value); }\n}\n\n/** @internal */\nexport class Matrix4 {\n  public readonly data: Float32Array = new Float32Array(4 * 4);\n\n  public constructor() { }\n\n  public copyFrom(src: Matrix4): void {\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] = src.data[i];\n    }\n  }\n  public clone(out?: Matrix4): Matrix4 {\n    const mat = undefined !== out ? out : new Matrix4();\n    mat.copyFrom(this);\n    return mat;\n  }\n\n  public initIdentity(): void {\n    this.setValues(\n      1, 0, 0, 0,\n      0, 1, 0, 0,\n      0, 0, 1, 0,\n      0, 0, 0, 1);\n  }\n  public static fromIdentity(out?: Matrix4): Matrix4 {\n    const mat = undefined !== out ? out : new Matrix4();\n    mat.initIdentity();\n    return mat;\n  }\n\n  public setValues(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number) {\n    this.m00 = m00; this.m01 = m01; this.m02 = m02; this.m03 = m03;\n    this.m10 = m10; this.m11 = m11; this.m12 = m12; this.m13 = m13;\n    this.m20 = m20; this.m21 = m21; this.m22 = m22; this.m23 = m23;\n    this.m30 = m30; this.m31 = m31; this.m32 = m32; this.m33 = m33;\n  }\n  public static fromValues(m00: number, m01: number, m02: number, m03: number, m10: number, m11: number, m12: number, m13: number, m20: number, m21: number, m22: number, m23: number, m30: number, m31: number, m32: number, m33: number, out?: Matrix4): Matrix4 {\n    const mat = undefined !== out ? out : new Matrix4();\n    mat.setValues(m00, m01, m02, m03, m10, m11, m12, m13, m20, m21, m22, m23, m30, m31, m32, m33);\n    return mat;\n  }\n\n  public getRotation(out?: Matrix3): Matrix3 {\n    const rot = undefined !== out ? out : new Matrix3();\n    rot.setValues(this.m00, this.m01, this.m02, this.m10, this.m11, this.m12, this.m20, this.m21, this.m22);\n    return rot;\n  }\n\n  public initFromTransform(transform: Transform): void {\n    const mat = transform.matrix;\n    const org = transform.origin;\n    this.setValues(\n      mat.at(0, 0), mat.at(0, 1), mat.at(0, 2), org.x,\n      mat.at(1, 0), mat.at(1, 1), mat.at(1, 2), org.y,\n      mat.at(2, 0), mat.at(2, 1), mat.at(2, 2), org.z,\n      0, 0, 0, 1);\n  }\n  public static fromTransform(transform: Transform, out?: Matrix4): Matrix4 {\n    const mat = undefined !== out ? out : new Matrix4();\n    mat.initFromTransform(transform);\n    return mat;\n  }\n  public toTransform(): Transform {\n    const data = this.data;\n    assert(0.0 === data[3] && 0.0 === data[7] && 0.0 === data[11] && 1.0 === data[15]);\n    const origin = new Point3d(data[12], data[13], data[14]);\n    const rotMat = Matrix3d.createIdentity();\n    for (let i = 0; i < 3; i++)\n      for (let j = 0; j < 3; j++)\n        rotMat.setAt(i, j, data[i + j * 4]);\n\n    return Transform.createRefs(origin, rotMat);\n  }\n\n  public initFromMatrix4d(mat: Matrix4d): void {\n    this.setValues(\n      mat.atIJ(0, 0), mat.atIJ(0, 1), mat.atIJ(0, 2), mat.atIJ(0, 3),\n      mat.atIJ(1, 0), mat.atIJ(1, 1), mat.atIJ(1, 2), mat.atIJ(1, 3),\n      mat.atIJ(2, 0), mat.atIJ(2, 1), mat.atIJ(2, 2), mat.atIJ(2, 3),\n      mat.atIJ(3, 0), mat.atIJ(3, 1), mat.atIJ(3, 2), mat.atIJ(3, 3));\n  }\n  public static fromMatrix4d(mat: Matrix4d, out?: Matrix4): Matrix4 {\n    const result = undefined !== out ? out : new Matrix4();\n    result.initFromMatrix4d(mat);\n    return result;\n  }\n  public toMatrix4d(): Matrix4d {\n    const data = this.data;\n    return Matrix4d.createRowValues(data[0], data[4], data[8], data[12], data[1], data[5], data[9], data[13], data[2], data[6], data[10], data[14], data[3], data[7], data[11], data[15]);\n  }\n\n  public lookAt(eye: Point3d, center: Point3d, up: Vector3d): boolean {\n    const f = normalizedDifference(center, eye);\n    if (undefined === f) {\n      return false;\n    }\n\n    const s = fromNormalizedCrossProduct(f, up);\n    if (undefined === s) {\n      return false;\n    }\n\n    const u = Vector3d.createCrossProduct(s.x, s.y, s.z, f.x, f.y, f.z);\n    this.setValues(\n      s.x, s.y, s.z, -s.dotProduct(eye),\n      u.x, u.y, u.z, -u.dotProduct(eye),\n      -f.x, -f.y, -f.z, f.dotProduct(eye),\n      0, 0, 0, 1);\n    return true;\n  }\n  public static fromLookAt(eye: Point3d, center: Point3d, up: Vector3d, out?: Matrix4): Matrix4 | undefined {\n    const mat = undefined !== out ? out : new Matrix4();\n    return mat.lookAt(eye, center, up) ? mat : undefined;\n  }\n\n  // left, right, bottom, top, near, far\n  public frustum(l: number, r: number, b: number, t: number, n: number, f: number): void {\n    this.setValues((2 * n) / (r - l), 0, (r + l) / (r - l), 0, 0, (2 * n) / (t - b),\n      (t + b) / (t - b), 0, 0, 0, -(f + n) / (f - n),\n      -(2 * f * n) / (f - n), 0, 0, -1, 0);\n  }\n  public static fromFrustum(l: number, r: number, b: number, t: number, n: number, f: number, out?: Matrix4): Matrix4 {\n    const mat = undefined !== out ? out : new Matrix4();\n    mat.frustum(l, r, b, t, n, f);\n    return mat;\n  }\n\n  public perspective(fovY: number, aspectRatio: number, nearZ: number, farZ: number): void {\n    const frustumHeight = Math.tan(fovY / 360 * Math.PI) * nearZ;\n    const frustumWidth = frustumHeight * aspectRatio;\n    this.frustum(-frustumWidth, frustumWidth, -frustumHeight, frustumHeight, nearZ, farZ);\n  }\n  public static fromPerspective(fovY: number, aspectRatio: number, nearZ: number, farZ: number, out?: Matrix4): Matrix4 {\n    const mat = undefined !== out ? out : new Matrix4();\n    mat.perspective(fovY, aspectRatio, nearZ, farZ);\n    return mat;\n  }\n\n  public ortho(l: number, r: number, b: number, t: number, n: number, f: number): void {\n    this.setValues(\n      2 / (r - l), 0, 0, -(r + l) / (r - l),\n      0, 2 / (t - b), 0, -(t + b) / (t - b),\n      0, 0, -2 / (f - n), -(f + n) / (f - n),\n      0, 0, 0, 1);\n  }\n  public static fromOrtho(l: number, r: number, b: number, t: number, n: number, f: number, out?: Matrix4): Matrix4 {\n    const mat = undefined !== out ? out : new Matrix4();\n    mat.ortho(l, r, b, t, n, f);\n    return mat;\n  }\n\n  public invert(): boolean {\n    const d = this.data;\n    const d0 = d[0];\n    const d1 = d[1];\n    const d2 = d[2];\n    const d3 = d[3];\n\n    this.setValues(\n      d[5] * d[10] * d[15] - d[5] * d[11] * d[14] - d[9] * d[6] * d[15] + d[9] * d[7] * d[14] + d[13] * d[6] * d[11] - d[13] * d[7] * d[10],\n      -d[4] * d[10] * d[15] + d[4] * d[11] * d[14] + d[8] * d[6] * d[15] - d[8] * d[7] * d[14] - d[12] * d[6] * d[11] + d[12] * d[7] * d[10],\n      d[4] * d[9] * d[15] - d[4] * d[11] * d[13] - d[8] * d[5] * d[15] + d[8] * d[7] * d[13] + d[12] * d[5] * d[11] - d[12] * d[7] * d[9],\n      -d[4] * d[9] * d[14] + d[4] * d[10] * d[13] + d[8] * d[5] * d[14] - d[8] * d[6] * d[13] - d[12] * d[5] * d[10] + d[12] * d[6] * d[9],\n      -d[1] * d[10] * d[15] + d[1] * d[11] * d[14] + d[9] * d[2] * d[15] - d[9] * d[3] * d[14] - d[13] * d[2] * d[11] + d[13] * d[3] * d[10],\n      d[0] * d[10] * d[15] - d[0] * d[11] * d[14] - d[8] * d[2] * d[15] + d[8] * d[3] * d[14] + d[12] * d[2] * d[11] - d[12] * d[3] * d[10],\n      -d[0] * d[9] * d[15] + d[0] * d[11] * d[13] + d[8] * d[1] * d[15] - d[8] * d[3] * d[13] - d[12] * d[1] * d[11] + d[12] * d[3] * d[9],\n      d[0] * d[9] * d[14] - d[0] * d[10] * d[13] - d[8] * d[1] * d[14] + d[8] * d[2] * d[13] + d[12] * d[1] * d[10] - d[12] * d[2] * d[9],\n      d[1] * d[6] * d[15] - d[1] * d[7] * d[14] - d[5] * d[2] * d[15] + d[5] * d[3] * d[14] + d[13] * d[2] * d[7] - d[13] * d[3] * d[6],\n      -d[0] * d[6] * d[15] + d[0] * d[7] * d[14] + d[4] * d[2] * d[15] - d[4] * d[3] * d[14] - d[12] * d[2] * d[7] + d[12] * d[3] * d[6],\n      d[0] * d[5] * d[15] - d[0] * d[7] * d[13] - d[4] * d[1] * d[15] + d[4] * d[3] * d[13] + d[12] * d[1] * d[7] - d[12] * d[3] * d[5],\n      -d[0] * d[5] * d[14] + d[0] * d[6] * d[13] + d[4] * d[1] * d[14] - d[4] * d[2] * d[13] - d[12] * d[1] * d[6] + d[12] * d[2] * d[5],\n      -d[1] * d[6] * d[11] + d[1] * d[7] * d[10] + d[5] * d[2] * d[11] - d[5] * d[3] * d[10] - d[9] * d[2] * d[7] + d[9] * d[3] * d[6],\n      d[0] * d[6] * d[11] - d[0] * d[7] * d[10] - d[4] * d[2] * d[11] + d[4] * d[3] * d[10] + d[8] * d[2] * d[7] - d[8] * d[3] * d[6],\n      -d[0] * d[5] * d[11] + d[0] * d[7] * d[9] + d[4] * d[1] * d[11] - d[4] * d[3] * d[9] - d[8] * d[1] * d[7] + d[8] * d[3] * d[5],\n      d[0] * d[5] * d[10] - d[0] * d[6] * d[9] - d[4] * d[1] * d[10] + d[4] * d[2] * d[9] + d[8] * d[1] * d[6] - d[8] * d[2] * d[5]);\n\n    const determinant = d0 * d[0] + d1 * d[4] + d2 * d[8] + d3 * d[12];\n    if (0 === determinant) {\n      this.initIdentity();\n      return false;\n    }\n\n    this.multiplyByScalar(1 / determinant);\n    return true;\n  }\n  public static fromInverse(src: Matrix4, out?: Matrix4): Matrix4 | undefined {\n    const mat = src.clone(out);\n    return mat.invert() ? mat : undefined;\n  }\n\n  public swap(firstIndex: number, secondIndex: number) {\n    assert(firstIndex < this.data.length);\n    assert(secondIndex < this.data.length);\n    assert(secondIndex !== firstIndex);\n    const tmp = this.data[firstIndex];\n    this.data[firstIndex] = this.data[secondIndex];\n    this.data[secondIndex] = tmp;\n  }\n\n  public transpose(): void {\n    this.swap(1, 4);\n    this.swap(2, 8);\n    this.swap(3, 12);\n    this.swap(6, 9);\n    this.swap(7, 13);\n    this.swap(11, 14);\n  }\n  public static fromTranspose(src: Matrix4, out?: Matrix4): Matrix4 {\n    const mat = src.clone(out);\n    mat.transpose();\n    return mat;\n  }\n\n  public multiplyBy(other: Matrix4): void {\n    const a = this.data;\n    const b = other.data;\n    this.setValues(\n      a[0] * b[0] + a[4] * b[1] + a[8] * b[2] + a[12] * b[3],\n      a[0] * b[4] + a[4] * b[5] + a[8] * b[6] + a[12] * b[7],\n      a[0] * b[8] + a[4] * b[9] + a[8] * b[10] + a[12] * b[11],\n      a[0] * b[12] + a[4] * b[13] + a[8] * b[14] + a[12] * b[15],\n      a[1] * b[0] + a[5] * b[1] + a[9] * b[2] + a[13] * b[3],\n      a[1] * b[4] + a[5] * b[5] + a[9] * b[6] + a[13] * b[7],\n      a[1] * b[8] + a[5] * b[9] + a[9] * b[10] + a[13] * b[11],\n      a[1] * b[12] + a[5] * b[13] + a[9] * b[14] + a[13] * b[15],\n      a[2] * b[0] + a[6] * b[1] + a[10] * b[2] + a[14] * b[3],\n      a[2] * b[4] + a[6] * b[5] + a[10] * b[6] + a[14] * b[7],\n      a[2] * b[8] + a[6] * b[9] + a[10] * b[10] + a[14] * b[11],\n      a[2] * b[12] + a[6] * b[13] + a[10] * b[14] + a[14] * b[15],\n      a[3] * b[0] + a[7] * b[1] + a[11] * b[2] + a[15] * b[3],\n      a[3] * b[4] + a[7] * b[5] + a[11] * b[6] + a[15] * b[7],\n      a[3] * b[8] + a[7] * b[9] + a[11] * b[10] + a[15] * b[11],\n      a[3] * b[12] + a[7] * b[13] + a[11] * b[14] + a[15] * b[15]);\n  }\n  public static fromProduct(a: Matrix4, b: Matrix4, out?: Matrix4): Matrix4 {\n    const mat = a.clone(out);\n    mat.multiplyBy(b);\n    return mat;\n  }\n\n  public multiplyByScalar(scalar: number): void {\n    for (let i = 0; i < this.data.length; i++) {\n      this.data[i] *= scalar;\n    }\n  }\n\n  public get(index: number) { assert(index < this.data.length); return this.data[index]; }\n  public set(index: number, value: number) { assert(index < this.data.length); this.data[index] = value; }\n\n  public at(row: number, col: number) { return this.get(col * 4 + row); }\n  public setAt(row: number, col: number, value: number) { this.set(col * 4 + row, value); }\n\n  public get m00() { return this.at(0, 0); }\n  public set m00(value: number) { this.setAt(0, 0, value); }\n  public get m01() { return this.at(0, 1); }\n  public set m01(value: number) { this.setAt(0, 1, value); }\n  public get m02() { return this.at(0, 2); }\n  public set m02(value: number) { this.setAt(0, 2, value); }\n  public get m03() { return this.at(0, 3); }\n  public set m03(value: number) { this.setAt(0, 3, value); }\n  public get m10() { return this.at(1, 0); }\n  public set m10(value: number) { this.setAt(1, 0, value); }\n  public get m11() { return this.at(1, 1); }\n  public set m11(value: number) { this.setAt(1, 1, value); }\n  public get m12() { return this.at(1, 2); }\n  public set m12(value: number) { this.setAt(1, 2, value); }\n  public get m13() { return this.at(1, 3); }\n  public set m13(value: number) { this.setAt(1, 3, value); }\n  public get m20() { return this.at(2, 0); }\n  public set m20(value: number) { this.setAt(2, 0, value); }\n  public get m21() { return this.at(2, 1); }\n  public set m21(value: number) { this.setAt(2, 1, value); }\n  public get m22() { return this.at(2, 2); }\n  public set m22(value: number) { this.setAt(2, 2, value); }\n  public get m23() { return this.at(2, 3); }\n  public set m23(value: number) { this.setAt(2, 3, value); }\n\n  public get m30() { return this.at(3, 0); }\n  public set m30(value: number) { this.setAt(3, 0, value); }\n  public get m31() { return this.at(3, 1); }\n  public set m31(value: number) { this.setAt(3, 1, value); }\n  public get m32() { return this.at(3, 2); }\n  public set m32(value: number) { this.setAt(3, 2, value); }\n  public get m33() { return this.at(3, 3); }\n  public set m33(value: number) { this.setAt(3, 3, value); }\n}\n\n// missing Vector3d functions\n\n/** @internal */\nexport function fromNormalizedCrossProduct(vec0: Vector3d, vec1: Vector3d): Vector3d | undefined {\n  return vec0.unitCrossProduct(vec1);\n}\n\n/** @internal */\nexport function normalizedDifference(target: Point3d, origin: Point3d): Vector3d | undefined {\n  return Vector3d.createStartEnd(origin, target).normalize();\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { IDisposable, dispose } from \"@bentley/bentleyjs-core\";\nimport { SurfaceFlags, RenderPass, RenderOrder } from \"./RenderFlags\";\nimport { LUTGeometry, PolylineBuffers, CachedGeometry } from \"./CachedGeometry\";\nimport { VertexIndices, SurfaceType, MeshParams, SegmentEdgeParams, SilhouetteParams, TesselatedPolyline } from \"../primitives/VertexTable\";\nimport { LineCode } from \"./EdgeOverrides\";\nimport { ColorInfo } from \"./ColorInfo\";\nimport { Graphic, Batch } from \"./Graphic\";\nimport { FeaturesInfo } from \"./FeaturesInfo\";\nimport { VertexLUT } from \"./VertexLUT\";\nimport { Primitive } from \"./Primitive\";\nimport { FloatPreMulRgba } from \"./FloatRGBA\";\nimport { ShaderProgramParams, RenderCommands } from \"./DrawCommand\";\nimport { Target } from \"./Target\";\nimport { Material } from \"./Material\";\nimport { Texture } from \"./Texture\";\nimport { FillFlags, RenderMode, LinePixels, ViewFlags } from \"@bentley/imodeljs-common\";\nimport { System } from \"./System\";\nimport { BufferHandle, AttributeHandle } from \"./Handle\";\nimport { GL } from \"./GL\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { InstancedGraphicParams, RenderMemory } from \"../System\";\nimport { InstanceBuffers } from \"./InstancedGeometry\";\n\n/** @internal */\nexport class MeshData implements IDisposable {\n  public readonly edgeWidth: number;\n  public features?: FeaturesInfo;\n  public readonly texture?: Texture;\n  public readonly material?: Material;\n  public readonly type: SurfaceType;\n  public readonly fillFlags: FillFlags;\n  public readonly edgeLineCode: number; // Must call LineCode.valueFromLinePixels(val: LinePixels) and set the output to edgeLineCode\n  public readonly isPlanar: boolean;\n  public readonly hasBakedLighting: boolean;\n  public readonly lut: VertexLUT;\n\n  private constructor(lut: VertexLUT, params: MeshParams) {\n    this.lut = lut;\n    this.features = FeaturesInfo.createFromVertexTable(params.vertices);\n    this.texture = params.surface.texture as Texture;\n    this.material = params.surface.material as Material;\n    this.type = params.surface.type;\n    this.fillFlags = params.surface.fillFlags;\n    this.isPlanar = params.isPlanar;\n    this.hasBakedLighting = params.surface.hasBakedLighting;\n    const edges = params.edges;\n    this.edgeWidth = undefined !== edges ? edges.weight : 1;\n    this.edgeLineCode = LineCode.valueFromLinePixels(undefined !== edges ? edges.linePixels : LinePixels.Solid);\n  }\n\n  public static create(params: MeshParams): MeshData | undefined {\n    const lut = VertexLUT.createFromVertexTable(params.vertices, params.auxChannels);\n    return undefined !== lut ? new MeshData(lut, params) : undefined;\n  }\n\n  public dispose() {\n    dispose(this.lut);\n    if (undefined !== this.texture && undefined === this.texture.key && !this.texture.isOwned)\n      this.texture.dispose();\n  }\n}\n\n/** @internal */\nexport class MeshGraphic extends Graphic {\n  public readonly meshData: MeshData;\n  private readonly _primitives: Primitive[] = [];\n  private readonly _instances?: InstanceBuffers;\n\n  public static create(params: MeshParams, instances?: InstancedGraphicParams): MeshGraphic | undefined {\n    const buffers = undefined !== instances ? InstanceBuffers.create(instances, true) : undefined;\n    if (undefined === buffers && undefined !== instances)\n      return undefined;\n\n    const data = MeshData.create(params);\n    return undefined !== data ? new MeshGraphic(data, params, buffers) : undefined;\n  }\n\n  private addPrimitive(createGeom: () => CachedGeometry | undefined, instances?: InstanceBuffers) {\n    const primitive = Primitive.createShared(createGeom, instances);\n    if (undefined !== primitive)\n      this._primitives.push(primitive);\n  }\n\n  private constructor(data: MeshData, params: MeshParams, instances?: InstanceBuffers) {\n    super();\n    this.meshData = data;\n    this._instances = instances;\n\n    this.addPrimitive(() => SurfaceGeometry.create(this.meshData, params.surface.indices), instances);\n\n    // Classifiers are surfaces only...no edges.\n    if (this.surfaceType === SurfaceType.VolumeClassifier || undefined === params.edges)\n      return;\n\n    const edges = params.edges;\n    if (undefined !== edges.silhouettes)\n      this.addPrimitive(() => SilhouetteEdgeGeometry.createSilhouettes(this.meshData, edges.silhouettes!), instances);\n\n    if (undefined !== edges.segments)\n      this.addPrimitive(() => EdgeGeometry.create(this.meshData, edges.segments!), instances);\n\n    if (undefined !== edges.polylines)\n      this.addPrimitive(() => PolylineEdgeGeometry.create(this.meshData, edges.polylines!), instances);\n  }\n\n  public dispose() {\n    dispose(this.meshData);\n    for (const primitive of this._primitives)\n      dispose(primitive);\n\n    this._primitives.length = 0;\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    stats.addVertexTable(this.meshData.lut.bytesUsed);\n    this._primitives.forEach((prim) => prim.collectStatistics(stats));\n\n    // Only count the shared instance buffers once...\n    if (undefined !== this._instances)\n      this._instances.collectStatistics(stats);\n  }\n\n  public addCommands(cmds: RenderCommands): void { this._primitives.forEach((prim) => prim.addCommands(cmds)); }\n  public addHiliteCommands(cmds: RenderCommands, batch: Batch, pass: RenderPass): void { this._primitives.forEach((prim) => prim.addHiliteCommands(cmds, batch, pass)); }\n\n  public setUniformFeatureIndices(id: number): void {\n    this.meshData.features = FeaturesInfo.createUniform(id);\n  }\n  public get surfaceType(): SurfaceType { return this.meshData.type; }\n}\n\n/** Defines one aspect of the geometry of a mesh (surface or edges)\n * @internal\n */\nexport abstract class MeshGeometry extends LUTGeometry {\n  public readonly mesh: MeshData;\n  protected readonly _numIndices: number;\n\n  public get asMesh() { return this; }\n  protected _getLineWeight(params: ShaderProgramParams): number { return this.computeEdgeWeight(params); }\n\n  // Convenience accessors...\n  public get edgeWidth() { return this.mesh.edgeWidth; }\n  public get edgeLineCode() { return this.mesh.edgeLineCode; }\n  public get featuresInfo(): FeaturesInfo | undefined { return this.mesh.features; }\n  public get surfaceType() { return this.mesh.type; }\n  public get fillFlags() { return this.mesh.fillFlags; }\n  public get isPlanar() { return this.mesh.isPlanar; }\n  public get colorInfo(): ColorInfo { return this.mesh.lut.colorInfo; }\n  public get uniformColor(): FloatPreMulRgba | undefined { return this.colorInfo.isUniform ? this.colorInfo.uniform : undefined; }\n  public get texture() { return this.mesh.texture; }\n  public get hasBakedLighting() { return this.mesh.hasBakedLighting; }\n  public get lut() { return this.mesh.lut; }\n  public get hasScalarAnimation() { return this.mesh.lut.hasScalarAnimation; }\n\n  protected constructor(mesh: MeshData, numIndices: number) {\n    super();\n    this._numIndices = numIndices;\n    this.mesh = mesh;\n  }\n\n  protected computeEdgeWeight(params: ShaderProgramParams): number { return params.target.getEdgeWeight(params, this.edgeWidth); }\n  protected computeEdgeLineCode(params: ShaderProgramParams): number { return params.target.getEdgeLineCode(params, this.edgeLineCode); }\n  protected computeEdgeColor(target: Target): ColorInfo { return target.isEdgeColorOverridden ? target.edgeColor : this.colorInfo; }\n  protected computeEdgePass(target: Target): RenderPass {\n    const vf = target.currentViewFlags;\n    if (RenderMode.SmoothShade === vf.renderMode && !vf.visibleEdges) {\n      return RenderPass.None;\n    }\n\n    // Only want translucent edges in wireframe mode.\n    const isTranslucent = RenderMode.Wireframe === vf.renderMode && vf.transparency && this.colorInfo.hasTranslucency;\n    return isTranslucent ? RenderPass.Translucent : RenderPass.OpaqueLinear;\n  }\n}\n\n/** @internal */\nexport class EdgeGeometry extends MeshGeometry {\n  protected readonly _indices: BufferHandle;\n  protected readonly _endPointAndQuadIndices: BufferHandle;\n\n  public get asSurface() { return undefined; }\n  public get asEdge() { return this; }\n  public get asSilhouette(): SilhouetteEdgeGeometry | undefined { return undefined; }\n\n  public static create(mesh: MeshData, edges: SegmentEdgeParams): EdgeGeometry | undefined {\n    const indexBuffer = BufferHandle.createArrayBuffer(edges.indices.data);\n    const endPointBuffer = BufferHandle.createArrayBuffer(edges.endPointAndQuadIndices);\n    return undefined !== indexBuffer && undefined !== endPointBuffer ? new EdgeGeometry(indexBuffer, endPointBuffer, edges.indices.length, mesh) : undefined;\n  }\n\n  public dispose() {\n    dispose(this._indices);\n    dispose(this._endPointAndQuadIndices);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    stats.addVisibleEdges(this._indices.bytesUsed + this._endPointAndQuadIndices.bytesUsed);\n  }\n\n  public bindVertexArray(attr: AttributeHandle): void {\n    attr.enableArray(this._indices, 3, GL.DataType.UnsignedByte, false, 0, 0);\n  }\n\n  protected _draw(numInstances: number): void {\n    this._indices.bind(GL.Buffer.Target.ArrayBuffer);\n    System.instance.drawArrays(GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);\n  }\n\n  protected _wantWoWReversal(_target: Target): boolean { return true; }\n  protected _getLineCode(params: ShaderProgramParams): number { return this.computeEdgeLineCode(params); }\n  public getTechniqueId(_target: Target): TechniqueId { return TechniqueId.Edge; }\n  public getRenderPass(target: Target): RenderPass { return this.computeEdgePass(target); }\n  public get renderOrder(): RenderOrder { return this.isPlanar ? RenderOrder.PlanarEdge : RenderOrder.Edge; }\n  public getColor(target: Target): ColorInfo { return this.computeEdgeColor(target); }\n  public get endPointAndQuadIndices(): BufferHandle { return this._endPointAndQuadIndices; }\n\n  protected constructor(indices: BufferHandle, endPointAndQuadsIndices: BufferHandle, numIndices: number, mesh: MeshData) {\n    super(mesh, numIndices);\n    this._indices = indices;\n    this._endPointAndQuadIndices = endPointAndQuadsIndices;\n  }\n}\n\n/** @internal */\nexport class SilhouetteEdgeGeometry extends EdgeGeometry {\n  private readonly _normalPairs: BufferHandle;\n\n  public get asSilhouette() { return this; }\n\n  public static createSilhouettes(mesh: MeshData, params: SilhouetteParams): SilhouetteEdgeGeometry | undefined {\n    const indexBuffer = BufferHandle.createArrayBuffer(params.indices.data);\n    const endPointBuffer = BufferHandle.createArrayBuffer(params.endPointAndQuadIndices);\n    const normalsBuffer = BufferHandle.createArrayBuffer(params.normalPairs);\n    return undefined !== indexBuffer && undefined !== endPointBuffer && undefined !== normalsBuffer ? new SilhouetteEdgeGeometry(indexBuffer, endPointBuffer, normalsBuffer, params.indices.length, mesh) : undefined;\n  }\n\n  public dispose() {\n    dispose(this._normalPairs);\n    super.dispose();\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    stats.addSilhouetteEdges(this._indices.bytesUsed + this._endPointAndQuadIndices.bytesUsed + this._normalPairs.bytesUsed);\n  }\n\n  public getTechniqueId(_target: Target): TechniqueId { return TechniqueId.SilhouetteEdge; }\n  public get renderOrder(): RenderOrder { return this.isPlanar ? RenderOrder.PlanarSilhouette : RenderOrder.Silhouette; }\n  public get normalPairs(): BufferHandle { return this._normalPairs; }\n\n  private constructor(indices: BufferHandle, endPointAndQuadsIndices: BufferHandle, normalPairs: BufferHandle, numIndices: number, mesh: MeshData) {\n    super(indices, endPointAndQuadsIndices, numIndices, mesh);\n    this._normalPairs = normalPairs;\n  }\n}\n\n/** @internal */\nexport class PolylineEdgeGeometry extends MeshGeometry {\n  private _buffers: PolylineBuffers;\n\n  public static create(mesh: MeshData, polyline: TesselatedPolyline): PolylineEdgeGeometry | undefined {\n    const buffers = PolylineBuffers.create(polyline);\n    return undefined !== buffers ? new PolylineEdgeGeometry(polyline.indices.length, buffers, mesh) : undefined;\n  }\n\n  public dispose() {\n    dispose(this._buffers);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    this._buffers.collectStatistics(stats, RenderMemory.BufferType.PolylineEdges);\n  }\n\n  protected _wantWoWReversal(_target: Target): boolean { return true; }\n  protected _getLineWeight(params: ShaderProgramParams): number { return this.computeEdgeWeight(params); }\n  protected _getLineCode(params: ShaderProgramParams): number { return this.computeEdgeLineCode(params); }\n  public getTechniqueId(_target: Target): TechniqueId { return TechniqueId.Polyline; }\n  public getRenderPass(target: Target): RenderPass { return this.computeEdgePass(target); }\n  public get renderOrder(): RenderOrder { return this.isPlanar ? RenderOrder.PlanarEdge : RenderOrder.Edge; }\n  public get polylineBuffers(): PolylineBuffers { return this._buffers; }\n\n  public bindVertexArray(attr: AttributeHandle): void {\n    attr.enableArray(this._buffers.indices, 3, GL.DataType.UnsignedByte, false, 0, 0);\n  }\n\n  protected _draw(numInstances: number): void {\n    const gl = System.instance;\n    this._buffers.indices.bind(GL.Buffer.Target.ArrayBuffer);\n    gl.drawArrays(GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);\n  }\n\n  private constructor(numIndices: number, buffers: PolylineBuffers, mesh: MeshData) {\n    super(mesh, numIndices);\n    this._buffers = buffers;\n  }\n}\n\nfunction wantMaterials(vf: ViewFlags) { return vf.materials && RenderMode.SmoothShade === vf.renderMode; }\nfunction wantLighting(vf: ViewFlags) {\n  return RenderMode.SmoothShade === vf.renderMode && (vf.sourceLights || vf.cameraLights || vf.solarLight);\n}\n\n/** @internal */\nexport class SurfaceGeometry extends MeshGeometry {\n  private readonly _indices: BufferHandle;\n\n  public static create(mesh: MeshData, indices: VertexIndices): SurfaceGeometry | undefined {\n    const indexBuffer = BufferHandle.createArrayBuffer(indices.data);\n    return undefined !== indexBuffer ? new SurfaceGeometry(indexBuffer, indices.length, mesh) : undefined;\n  }\n\n  public dispose() {\n    dispose(this._indices);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    stats.addSurface(this._indices.bytesUsed);\n  }\n\n  public get isLit() { return SurfaceType.Lit === this.surfaceType || SurfaceType.TexturedLit === this.surfaceType; }\n  public get isTextured() { return SurfaceType.Textured === this.surfaceType || SurfaceType.TexturedLit === this.surfaceType; }\n  public get isGlyph() { return undefined !== this.texture && this.texture.isGlyph; }\n  public get isTileSection() { return undefined !== this.texture && this.texture.isTileSection; }\n  public get isClassifier() { return SurfaceType.VolumeClassifier === this.surfaceType; }\n\n  public get asSurface() { return this; }\n  public get asEdge() { return undefined; }\n  public get asSilhouette() { return undefined; }\n\n  public bindVertexArray(attr: AttributeHandle): void {\n    attr.enableArray(this._indices, 3, GL.DataType.UnsignedByte, false, 0, 0);\n  }\n\n  protected _draw(numInstances: number): void {\n    const system = System.instance;\n    const gl = system.context;\n    const offset = RenderOrder.BlankingRegion === this.renderOrder;\n    if (offset) {\n      gl.enable(GL.POLYGON_OFFSET_FILL);\n      gl.polygonOffset(1.0, 1.0);\n    }\n\n    this._indices.bind(GL.Buffer.Target.ArrayBuffer);\n    system.drawArrays(GL.PrimitiveType.Triangles, 0, this._numIndices, numInstances);\n\n    if (offset) {\n      gl.disable(GL.POLYGON_OFFSET_FILL);\n    }\n  }\n\n  public getTechniqueId(_target: Target) { return TechniqueId.Surface; }\n  public get isLitSurface() { return this.isLit; }\n  public get hasBakedLighting() { return this.mesh.hasBakedLighting; }\n  public get renderOrder(): RenderOrder {\n    if (FillFlags.Behind === (this.fillFlags & FillFlags.Behind))\n      return RenderOrder.BlankingRegion;\n    else\n      return this.isPlanar ? RenderOrder.PlanarSurface : RenderOrder.Surface;\n  }\n\n  public getColor(target: Target) {\n    if (FillFlags.Background === (this.fillFlags & FillFlags.Background))\n      return ColorInfo.createUniform(target.bgColor);\n    else\n      return this.colorInfo;\n  }\n\n  public getRenderPass(target: Target): RenderPass {\n    if (this.isClassifier)\n      return RenderPass.Classification;\n\n    const mat = this.isLit ? this.mesh.material : undefined;\n    const opaquePass = this.isPlanar ? RenderPass.OpaquePlanar : RenderPass.OpaqueGeneral;\n    const fillFlags = this.fillFlags;\n\n    if (this.isGlyph && target.isReadPixelsInProgress)\n      return opaquePass;\n\n    const vf = target.currentViewFlags;\n    if (RenderMode.Wireframe === vf.renderMode) {\n      const showFill = FillFlags.Always === (fillFlags & FillFlags.Always) || (vf.fill && FillFlags.ByView === (fillFlags & FillFlags.ByView));\n      if (!showFill) {\n        return RenderPass.None;\n      }\n    }\n    if (!this.isGlyph) {\n      if (!vf.transparency || RenderMode.SolidFill === vf.renderMode || RenderMode.HiddenLine === vf.renderMode) {\n        return opaquePass;\n      }\n    }\n    if (undefined !== this.texture && this.wantTextures(target, true)) {\n      if (this.texture.hasTranslucency)\n        return RenderPass.Translucent;\n\n      // material may have texture weight < 1 - if so must account for material or element alpha below\n      if (undefined === mat || (mat.textureMapping !== undefined && mat.textureMapping.params.weight >= 1))\n        return opaquePass;\n    }\n\n    const hasAlpha = (undefined !== mat && wantMaterials(vf) && mat.hasTranslucency) || this.getColor(target).hasTranslucency;\n    return hasAlpha ? RenderPass.Translucent : opaquePass;\n  }\n\n  protected _wantWoWReversal(target: Target): boolean {\n    const fillFlags = this.fillFlags;\n    if (FillFlags.None !== (fillFlags & FillFlags.Background))\n      return false; // fill color explicitly from background\n\n    if (FillFlags.None !== (fillFlags & FillFlags.Always))\n      return true; // fill displayed even in wireframe\n\n    const vf = target.currentViewFlags;\n    if (RenderMode.Wireframe === vf.renderMode || vf.visibleEdges)\n      return false; // never invert surfaces when edges are displayed\n\n    if (this.isLit && wantLighting(vf))\n      return false;\n\n    // Don't invert white pixels of textures...\n    return !this.wantTextures(target, this.isTextured);\n  }\n  public get material(): Material | undefined { return this.mesh.material; }\n\n  public computeSurfaceFlags(params: ShaderProgramParams): SurfaceFlags {\n    const target = params.target;\n    const vf = target.currentViewFlags;\n\n    let flags = wantMaterials(vf) ? SurfaceFlags.None : SurfaceFlags.IgnoreMaterial;\n    if (this.isLit) {\n      flags |= SurfaceFlags.HasNormals;\n      if (wantLighting(vf)) {\n        flags |= SurfaceFlags.ApplyLighting;\n      }\n\n      // Textured meshes store normal in place of color index.\n      // Untextured lit meshes store normal where textured meshes would store UV coords.\n      // Tell shader where to find normal.\n      if (!this.isTextured) {\n        flags |= SurfaceFlags.HasColorAndNormal;\n      }\n    }\n\n    if (this.wantTextures(target, this.isTextured)) {\n      flags |= SurfaceFlags.HasTexture;\n    }\n\n    switch (params.renderPass) {\n      // NB: We need this for opaque pass due to SolidFill (must compute transparency, discard below threshold, render opaque at or above threshold)\n      case RenderPass.OpaqueLinear:\n      case RenderPass.OpaquePlanar:\n      case RenderPass.OpaqueGeneral:\n      case RenderPass.Translucent: {\n        const mode = vf.renderMode;\n        if (!this.isGlyph && (RenderMode.HiddenLine === mode || RenderMode.SolidFill === mode)) {\n          flags |= SurfaceFlags.TransparencyThreshold;\n          if (RenderMode.HiddenLine === mode && FillFlags.Always !== (this.fillFlags & FillFlags.Always)) {\n            // fill flags test for text - doesn't render with bg fill in hidden line mode.\n            flags |= SurfaceFlags.BackgroundFill;\n          }\n          break;\n        }\n      }\n    }\n\n    return flags;\n  }\n\n  private constructor(indices: BufferHandle, numIndices: number, mesh: MeshData) {\n    super(mesh, numIndices);\n    this._indices = indices;\n  }\n\n  private wantTextures(target: Target, surfaceTextureExists: boolean): boolean {\n    if (this.hasScalarAnimation && undefined !== target.analysisTexture)\n      return true;\n\n    if (!surfaceTextureExists)\n      return false;\n\n    if (this.isGlyph) {\n      return true;\n    }\n    const fill = this.fillFlags;\n    const flags = target.currentViewFlags;\n\n    // ###TODO need to distinguish between gradient fill and actual textures...\n    switch (flags.renderMode) {\n      case RenderMode.SmoothShade: return flags.textures;\n      case RenderMode.Wireframe: return FillFlags.Always === (fill & FillFlags.Always) || (flags.fill && FillFlags.ByView === (fill & FillFlags.ByView));\n      default: return FillFlags.Always === (fill & FillFlags.Always);\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\nimport { GL } from \"./GL\";\nimport { dispose, BeTimePoint, assert } from \"@bentley/bentleyjs-core\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { RenderClipVolume, RenderMemory, RenderGraphic, RenderPlanarClassifier } from \"../System\";\nimport { Texture, TextureHandle } from \"./Texture\";\nimport { Target } from \"./Target\";\nimport { ShaderProgramExecutor } from \"./ShaderProgram\";\nimport { Matrix4 } from \"./Matrix\";\nimport { SceneContext } from \"../../ViewContext\";\nimport { TileTreeModelState } from \"../../ModelState\";\nimport { TileTree, Tile } from \"../../tile/TileTree\";\nimport { Frustum, Npc, FrustumPlanes, RenderTexture, RenderMode, ColorDef, SpatialClassificationProps } from \"@bentley/imodeljs-common\";\nimport { ViewportQuadGeometry, CombineTexturesGeometry } from \"./CachedGeometry\";\nimport { Plane3dByOriginAndUnitNormal, Point3d, Vector3d, Range3d, Transform, Matrix3d, Matrix4d, Ray3d } from \"@bentley/geometry-core\";\nimport { System } from \"./System\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { getDrawParams } from \"./SceneCompositor\";\nimport { BatchState, BranchStack } from \"./BranchState\";\nimport { Batch, Branch } from \"./Graphic\";\nimport { RenderState } from \"./RenderState\";\nimport { RenderCommands } from \"./DrawCommand\";\nimport { RenderPass } from \"./RenderFlags\";\nimport { FloatRgba } from \"./FloatRGBA\";\nimport { ViewState3d } from \"../../ViewState\";\n\nclass PlanarClassifierDrawArgs extends Tile.DrawArgs {\n  constructor(private _classifierPlanes: FrustumPlanes, private _classifier: PlanarClassifier, context: SceneContext, location: Transform, root: TileTree, now: BeTimePoint, purgeOlderThan: BeTimePoint, clip?: RenderClipVolume) {\n    super(context, location, root, now, purgeOlderThan, clip);\n  }\n  public get frustumPlanes(): FrustumPlanes { return this._classifierPlanes; }\n  public drawGraphics(): void {\n    if (!this.graphics.isEmpty) {\n      this._classifier.addGraphic(this.context.createBranch(this.graphics, this.location));\n    }\n  }\n\n  public static create(context: SceneContext, classifier: PlanarClassifier, tileTree: TileTree, planes: FrustumPlanes) {\n    const now = BeTimePoint.now();\n    const purgeOlderThan = now.minus(tileTree.expirationTime);\n    return new PlanarClassifierDrawArgs(planes, classifier, context, tileTree.location.clone(), tileTree, now, purgeOlderThan, tileTree.clipVolume);\n  }\n}\n\n/** @internal */\nexport class PlanarClassifier extends RenderPlanarClassifier implements RenderMemory.Consumer {\n  private _colorTexture?: Texture;\n  private _featureTexture?: Texture;\n  private _hiliteTexture?: Texture;\n  private _combinedTexture?: Texture;\n  private _fbo?: FrameBuffer;\n  private _featureFbo?: FrameBuffer;    // For multi-pass case only.\n  private _hiliteFbo?: FrameBuffer;\n  private _combinedFbo?: FrameBuffer;\n  private _projectionMatrix = new Matrix4();\n  private _graphics: RenderGraphic[] = [];\n  private _frustum?: Frustum;\n  private _width = 0;\n  private _height = 0;\n  private _baseBatchId = 0;\n  private _anyHilited = false;\n  private _plane = Plane3dByOriginAndUnitNormal.create(new Point3d(0, 0, 0), new Vector3d(0, 0, 1))!;    // TBD -- Support other planes - default to X-Y for now.\n  private _postProjectionMatrix = Matrix4d.createRowValues(/* Row 1 */ 0, 1, 0, 0, /* Row 1 */ 0, 0, -1, 0, /* Row 3 */ 1, 0, 0, 0, /* Row 4 */ 0, 0, 0, 1);\n  private _postProjectionMatrixNpc = Matrix4d.createRowValues(/* Row 1 */ 0, 1, 0, 0, /* Row 1 */ 0, 0, 1, 0, /* Row 3 */ 1, 0, 0, 0, /* Row 4 */ 0, 0, 0, 1);\n  private static _scratchFrustum = new Frustum();\n\n  private constructor(private _classifierProperties: SpatialClassificationProps.Properties) { super(); }\n  public get hiliteTexture(): Texture | undefined { return this._hiliteTexture; }\n  public get combinedTexture(): Texture | undefined { return this._combinedTexture; }\n  public get projectionMatrix(): Matrix4 { return this._projectionMatrix; }\n  public get properties(): SpatialClassificationProps.Properties { return this._classifierProperties; }\n  public get baseBatchId(): number { return this._baseBatchId; }\n  public get anyHilited(): boolean { return this._anyHilited; }\n  public get insideDisplay(): SpatialClassificationProps.Display { return this._classifierProperties.flags.inside; }\n  public get outsideDisplay(): SpatialClassificationProps.Display { return this._classifierProperties.flags.outside; }\n  public addGraphic(graphic: RenderGraphic) { this._graphics.push(graphic); }\n\n  public static create(properties: SpatialClassificationProps.Properties, tileTree: TileTree, classifiedModel: TileTreeModelState, sceneContext: SceneContext): PlanarClassifier {\n    const classifier = new PlanarClassifier(properties);\n    classifier.collectGraphics(sceneContext, classifiedModel, tileTree);\n    return classifier;\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    if (undefined !== this._colorTexture)\n      stats.addPlanarClassifier(this._colorTexture.bytesUsed);\n    if (undefined !== this._featureTexture)\n      stats.addPlanarClassifier(this._featureTexture.bytesUsed);\n    if (undefined !== this._hiliteTexture)\n      stats.addPlanarClassifier(this._hiliteTexture.bytesUsed);\n  }\n  public dispose() {\n    this._colorTexture = dispose(this._colorTexture);\n    this._featureTexture = dispose(this._featureTexture);\n    this._hiliteTexture = dispose(this._hiliteTexture);\n    this._fbo = dispose(this._fbo);\n    this._hiliteFbo = dispose(this._hiliteFbo);\n  }\n\n  public push(exec: ShaderProgramExecutor) {\n    if (undefined !== this._colorTexture)\n      exec.target.planarClassifiers.push(this);\n  }\n  public pop(target: Target) {\n    if (undefined !== this._colorTexture)\n      target.planarClassifiers.pop();\n  }\n  private pushBatches(batchState: BatchState, graphics: RenderGraphic[]) {\n    graphics.forEach((graphic) => {\n      if (graphic instanceof Batch) {\n        batchState.push(graphic as Batch, true);\n        batchState.pop();\n      } else if (graphic instanceof Branch) {\n        const branch = graphic as Branch;\n        this.pushBatches(batchState, branch.branch.entries);\n      }\n    });\n  }\n\n  public pushBatchState(batchState: BatchState) {\n    this._baseBatchId = batchState.nextBatchId - 1;\n    if (undefined !== this._graphics)\n      this.pushBatches(batchState, this._graphics);\n  }\n\n  public collectGraphics(context: SceneContext, classifiedModel: TileTreeModelState, tileTree: TileTree) {\n    const classifierZ = this._plane.getNormalRef();\n    if (undefined === context.viewFrustum)\n      return;\n\n    const viewState = context.viewFrustum!.view as ViewState3d;\n    if (undefined === viewState)\n      return;\n    const viewX = context.viewFrustum.rotation.rowX();\n    const viewZ = context.viewFrustum.rotation.rowZ();\n    const minCrossMagnitude = 1.0E-4;\n\n    if (viewZ === undefined)\n      return;       // View without depth?....\n\n    let classifierX = viewZ.crossProduct(classifierZ);\n    let classifierY;\n    if (classifierX.magnitude() < minCrossMagnitude) {\n      classifierY = viewX.crossProduct(classifierZ);\n      classifierX = classifierY.crossProduct(classifierZ).normalize()!;\n    } else {\n      classifierX.normalizeInPlace();\n      classifierY = classifierZ.crossProduct(classifierX).normalize()!;\n    }\n\n    const frustumX = classifierZ, frustumY = classifierX, frustumZ = classifierY;\n    const classifierMatrix = Matrix3d.createRows(frustumX, frustumY, frustumZ);\n    const classifierTransform = Transform.createRefs(Point3d.createZero(), classifierMatrix);\n\n    let npcRange = Range3d.createXYZXYZ(0, 0, 0, 1, 1, 1);\n    const viewFrustum = context.viewFrustum.getFrustum();\n    const viewMap = viewFrustum.toMap4d()!;\n    const viewPlanes = new FrustumPlanes(viewFrustum);\n    if (classifiedModel && classifiedModel.tileTree) {\n      const tileRange = Range3d.createNull();\n      classifiedModel.tileTree.accumlateTransformedRange(tileRange, viewMap.transform0, viewPlanes);\n      if (undefined === tileRange)\n        return;\n      npcRange = npcRange.intersect(tileRange);\n    }\n    PlanarClassifier._scratchFrustum.initFromRange(npcRange);\n    viewMap.transform1.multiplyPoint3dArrayQuietNormalize(PlanarClassifier._scratchFrustum.points);\n    const range = Range3d.createTransformedArray(classifierTransform, PlanarClassifier._scratchFrustum.points);\n    range.low.x = Math.min(range.low.x, -.0001);    // Always include classification plane.\n    range.high.x = Math.max(range.high.x, .0001);\n\n    this._frustum = Frustum.fromRange(range);\n    if (viewState.isCameraOn) {\n      const projectionRay = Ray3d.create(viewState.getEyePoint(), viewZ.crossProduct(classifierX).normalize()!);\n      const projectionDistance = projectionRay.intersectionWithPlane(this._plane);\n      if (undefined !== projectionDistance) {\n        const eyePoint = classifierTransform.multiplyPoint3d(projectionRay.fractionToPoint(projectionDistance));\n        const near = Math.max(.01, eyePoint.z - range.high.z);\n        const far = eyePoint.z - range.low.z;\n        const minFraction = 1.0 / 50.0;\n        const fraction = Math.max(minFraction, near / far);\n        for (let i = Npc.LeftBottomFront; i <= Npc.RightTopFront; i++) {\n          const frustumPoint = this._frustum.points[i];\n          frustumPoint.x = frustumPoint.x * fraction;\n          frustumPoint.y = eyePoint.y + (frustumPoint.y - eyePoint.y) * fraction;\n        }\n      }\n    }\n    classifierMatrix.transposeInPlace();\n    classifierMatrix.multiplyVectorArrayInPlace(this._frustum.points);\n    const frustumMap = this._frustum.toMap4d();\n    if (undefined === frustumMap) {\n      assert(false);\n      return;\n    }\n    this._projectionMatrix.initFromMatrix4d(this._postProjectionMatrixNpc.multiplyMatrixMatrix(frustumMap.transform0));\n\n    const drawArgs = PlanarClassifierDrawArgs.create(context, this, tileTree, new FrustumPlanes(this._frustum));\n    tileTree.draw(drawArgs);\n  }\n  public draw(target: Target) {\n    if (undefined === this._frustum) {\n      assert(false);\n      return;\n    }\n\n    if (this._graphics === undefined)\n      return;\n\n    const requiredHeight = 2 * Math.max(target.viewRect.width, target.viewRect.height);\n    const requiredWidth = requiredHeight;\n\n    if (requiredWidth !== this._width || requiredHeight !== this._height)\n      this.dispose();\n\n    this._width = requiredWidth;\n    this._height = requiredHeight;\n    const useMRT = System.instance.capabilities.supportsDrawBuffers;\n\n    if (undefined === this._fbo) {\n      const colorTextureHandle = TextureHandle.createForAttachment(this._width, this._height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n      const featureTextureHandle = TextureHandle.createForAttachment(this._width, this._height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n      const combinedTextureHandle = TextureHandle.createForAttachment(this._width, 2 * this._height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n      if (undefined === colorTextureHandle ||\n        undefined === featureTextureHandle ||\n        undefined === combinedTextureHandle) {\n        assert(false, \"Failed to create planar classifier texture\");\n        return;\n      }\n      this._colorTexture = new Texture(new RenderTexture.Params(undefined, RenderTexture.Type.TileSection, true), colorTextureHandle);\n      this._featureTexture = new Texture(new RenderTexture.Params(undefined, RenderTexture.Type.TileSection, true), featureTextureHandle);\n      this._combinedTexture = new Texture(new RenderTexture.Params(undefined, RenderTexture.Type.TileSection, true), combinedTextureHandle);\n      if (useMRT)\n        this._fbo = FrameBuffer.create([colorTextureHandle, featureTextureHandle]);\n      else {\n        this._fbo = FrameBuffer.create([colorTextureHandle]);\n        this._featureFbo = FrameBuffer.create([featureTextureHandle]);\n      }\n      this._combinedFbo = FrameBuffer.create([combinedTextureHandle]);\n    }\n    if (undefined === this._fbo || (!useMRT && undefined === this._featureFbo)) {\n      assert(false, \"unable to create frame buffer objects\");\n      return;\n    }\n\n    const prevState = System.instance.currentRenderState.clone();\n    System.instance.context.viewport(0, 0, this._width, this._height);\n\n    const state = new RenderState();\n    state.flags.depthMask = false;\n    state.flags.blend = false;\n    state.flags.depthTest = false;\n\n    const viewFlags = target.currentViewFlags.clone();\n    viewFlags.renderMode = RenderMode.SmoothShade;\n    viewFlags.transparency = false;\n    viewFlags.textures = false;\n    viewFlags.sourceLights = false;\n    viewFlags.cameraLights = false;\n    viewFlags.solarLight = false;\n    viewFlags.shadows = false;\n    viewFlags.noGeometryMap = true;\n    viewFlags.monochrome = false;\n    viewFlags.materials = false;\n    viewFlags.ambientOcclusion = false;\n    viewFlags.visibleEdges = viewFlags.hiddenEdges = false;\n\n    const batchState = new BatchState();\n    System.instance.applyRenderState(state);\n    const prevPlan = target.plan;\n    const prevBgColor = FloatRgba.fromColorDef(ColorDef.white);\n    prevBgColor.setFromFloatRgba(target.bgColor);\n\n    target.bgColor.setFromColorDef(ColorDef.from(0, 0, 0, 255)); // Avoid white on white reversal.\n    target.changeFrustum(this._frustum, this._frustum.getFraction(), true);\n    target.projectionMatrix.setFrom(this._postProjectionMatrix.multiplyMatrixMatrix(target.projectionMatrix));\n    target.branchStack.setViewFlags(viewFlags);\n\n    const renderCommands = new RenderCommands(target, new BranchStack(), batchState);\n    renderCommands.addGraphics(this._graphics);\n\n    const system = System.instance;\n    const gl = system.context;\n    if (undefined !== this._featureFbo) {\n      system.frameBufferStack.execute(this._fbo, true, () => {\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(GL.BufferBit.Color);\n        target.compositor.currentRenderTargetIndex = 0;\n        target.techniques.execute(target, renderCommands.getCommands(RenderPass.OpaquePlanar), RenderPass.PlanarClassification);    // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.\n      });\n      system.frameBufferStack.execute(this._featureFbo!, true, () => {\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(GL.BufferBit.Color);\n        target.compositor.currentRenderTargetIndex = 1;\n        target.techniques.execute(target, renderCommands.getCommands(RenderPass.OpaquePlanar), RenderPass.PlanarClassification);    // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.\n      });\n    } else {\n      system.frameBufferStack.execute(this._fbo, true, () => {\n        const clearPickAndColor = ViewportQuadGeometry.create(TechniqueId.ClearPickAndColor);\n        target.techniques.draw(getDrawParams(target, clearPickAndColor!));\n        target.techniques.execute(target, renderCommands.getCommands(RenderPass.OpaquePlanar), RenderPass.PlanarClassification);    // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.\n      });\n    }\n    // Create combined texture with color followed by featureIds.\n    system.frameBufferStack.execute(this._combinedFbo!, true, () => {\n      gl.clearColor(0, 0, 0, 0);\n      const combineTextures = CombineTexturesGeometry.createGeometry(this._colorTexture!.texture.getHandle()!, this._featureTexture!.texture.getHandle()!);\n      target.techniques.draw(getDrawParams(target, combineTextures!));\n    });\n\n    const hiliteCommands = renderCommands.getCommands(RenderPass.Hilite);\n    if (false !== (this._anyHilited = 0 !== hiliteCommands.length)) {\n      if (undefined === this._hiliteFbo) {\n        const hiliteTextureHandle = TextureHandle.createForAttachment(this._width, this._height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n        this._hiliteTexture = new Texture(new RenderTexture.Params(undefined, RenderTexture.Type.TileSection, true), hiliteTextureHandle!);\n        if (undefined === hiliteTextureHandle || undefined === (this._hiliteFbo = FrameBuffer.create([hiliteTextureHandle!]))) {\n          assert(false, \"Failed to create planar classifier hilite texture\");\n          return;\n        }\n      }\n\n      system.frameBufferStack.execute(this._hiliteFbo, true, () => {\n        gl.clearColor(0, 0, 0, 0);\n        gl.clear(GL.BufferBit.Color);\n        target.techniques.execute(target, hiliteCommands, RenderPass.Hilite);\n      });\n    }\n    // Create combined texture with color followed by featureIds.  We do this to conserve texture units - could use color and feature textures directly otherwise.\n    System.instance.context.viewport(0, 0, this._width, 2 * this._height);\n    system.frameBufferStack.execute(this._combinedFbo!, true, () => {\n      gl.clearColor(0, 0, 0, 0);\n      const combineTextures = CombineTexturesGeometry.createGeometry(this._colorTexture!.texture.getHandle()!, this._featureTexture!.texture.getHandle()!);\n      target.techniques.draw(getDrawParams(target, combineTextures!));\n    });\n\n    batchState.reset();   // Reset the batch Ids...\n    target.bgColor.setFromFloatRgba(prevBgColor);\n    if (prevPlan)\n      target.changeRenderPlan(prevPlan);\n\n    system.applyRenderState(prevState);\n    gl.viewport(0, 0, target.viewRect.width, target.viewRect.height); // Restore viewport\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\nimport { PointCloudArgs } from \"../primitives/PointCloudPrimitive\";\nimport { FeaturesInfo } from \"./FeaturesInfo\";\nimport { CachedGeometry } from \"./CachedGeometry\";\nimport { AttributeHandle, QBufferHandle3d, BufferHandle } from \"./Handle\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { RenderPass, RenderOrder } from \"./RenderFlags\";\nimport { Target } from \"./Target\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\nimport { dispose } from \"@bentley/bentleyjs-core\";\nimport { RenderMemory } from \"../System\";\n\n/** @internal */\nexport class PointCloudGeometry extends CachedGeometry {\n  private _vertices: QBufferHandle3d;\n  private _vertexCount: number;\n  private _colorHandle: BufferHandle | undefined = undefined;\n  public features: FeaturesInfo | undefined;\n\n  public dispose() { dispose(this._vertices); }\n\n  constructor(pointCloud: PointCloudArgs) {\n    super();\n    this._vertices = QBufferHandle3d.create(pointCloud.pointParams, pointCloud.points) as QBufferHandle3d;\n    this._vertexCount = pointCloud.points.length / 3;\n    this.features = FeaturesInfo.create(pointCloud.features);\n    if (undefined !== pointCloud.colors)\n      this._colorHandle = BufferHandle.createArrayBuffer(pointCloud.colors);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    const bytesUsed = this._vertices.bytesUsed + (undefined !== this._colorHandle ? this._colorHandle.bytesUsed : 0);\n    stats.addPointCloud(bytesUsed);\n  }\n\n  protected _wantWoWReversal(_target: Target): boolean { return false; }\n\n  public getTechniqueId(_target: Target): TechniqueId { return TechniqueId.PointCloud; }\n  public getRenderPass(_target: Target): RenderPass { return RenderPass.OpaqueGeneral; }\n  public get renderOrder(): RenderOrder { return RenderOrder.Surface; }\n  public get qOrigin(): Float32Array { return this._vertices.origin; }\n  public get qScale(): Float32Array { return this._vertices.scale; }\n  public get colors(): BufferHandle | undefined { return this._colorHandle; }\n  public get featuresInfo(): FeaturesInfo | undefined { return this.features; }\n  public get hasBakedLighting() { return true; }\n\n  public bindVertexArray(attr: AttributeHandle): void { attr.enableArray(this._vertices, 3, GL.DataType.UnsignedShort, false, 0, 0); }\n  public draw(): void {\n    const gl = System.instance.context;\n    gl.drawArrays(GL.PrimitiveType.Points, 0, this._vertexCount);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { dispose } from \"@bentley/bentleyjs-core\";\nimport { QParams3d } from \"@bentley/imodeljs-common\";\nimport { Target } from \"./Target\";\nimport { LUTGeometry } from \"./CachedGeometry\";\nimport { RenderPass, RenderOrder } from \"./RenderFlags\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { PointStringParams } from \"../primitives/VertexTable\";\nimport { VertexLUT } from \"./VertexLUT\";\nimport { FeaturesInfo } from \"./FeaturesInfo\";\nimport { AttributeHandle, BufferHandle } from \"./Handle\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\nimport { ShaderProgramParams } from \"./DrawCommand\";\nimport { RenderMemory } from \"../System\";\n\n/** @internal */\nexport class PointStringGeometry extends LUTGeometry {\n  public readonly vertexParams: QParams3d;\n  public readonly features: FeaturesInfo | undefined;\n  public readonly weight: number;\n  public readonly lut: VertexLUT;\n  public readonly indices: BufferHandle;\n  public readonly numIndices: number;\n\n  private constructor(indices: BufferHandle, numIndices: number, lut: VertexLUT, qparams: QParams3d, weight: number, features?: FeaturesInfo) {\n    super();\n    this.numIndices = numIndices;\n    this.indices = indices;\n    this.lut = lut;\n    this.vertexParams = qparams;\n    this.weight = weight;\n    this.features = features;\n  }\n\n  protected _wantWoWReversal(_target: Target): boolean { return true; }\n\n  public getTechniqueId(_target: Target): TechniqueId { return TechniqueId.PointString; }\n  public getRenderPass(_target: Target): RenderPass { return RenderPass.OpaqueLinear; }\n  public get featuresInfo(): FeaturesInfo | undefined { return this.features; }\n  public get renderOrder(): RenderOrder { return RenderOrder.PlanarLinear; }\n  public bindVertexArray(attr: AttributeHandle): void {\n    attr.enableArray(this.indices, 3, GL.DataType.UnsignedByte, false, 0, 0);\n  }\n\n  protected _getLineWeight(_params: ShaderProgramParams): number { return this.weight; }\n\n  protected _draw(numInstances: number): void {\n    const gl = System.instance;\n    this.indices.bind(GL.Buffer.Target.ArrayBuffer);\n    gl.drawArrays(GL.PrimitiveType.Points, 0, this.numIndices, numInstances);\n  }\n\n  public static create(params: PointStringParams): PointStringGeometry | undefined {\n    const indices = BufferHandle.createArrayBuffer(params.indices.data);\n    if (undefined === indices)\n      return undefined;\n\n    const lut = VertexLUT.createFromVertexTable(params.vertices);\n    if (undefined === lut)\n      return undefined;\n\n    return new PointStringGeometry(indices, params.indices.length, lut, params.vertices.qparams, params.weight, FeaturesInfo.createFromVertexTable(params.vertices));\n  }\n\n  public dispose() {\n    dispose(this.lut);\n    dispose(this.indices);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    stats.addVertexTable(this.lut.bytesUsed);\n    stats.addPointString(this.indices.bytesUsed);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { QParams3d, RenderMode, PolylineTypeFlags } from \"@bentley/imodeljs-common\";\nimport { PolylineParams } from \"../primitives/VertexTable\";\nimport { Target } from \"./Target\";\nimport { LUTGeometry, PolylineBuffers } from \"./CachedGeometry\";\nimport { RenderPass, RenderOrder } from \"./RenderFlags\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { AttributeHandle } from \"./Handle\";\nimport { FeaturesInfo } from \"./FeaturesInfo\";\nimport { LineCode } from \"./EdgeOverrides\";\nimport { VertexLUT } from \"./VertexLUT\";\nimport { ColorInfo } from \"./ColorInfo\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\nimport { ShaderProgramParams } from \"./DrawCommand\";\nimport { dispose } from \"@bentley/bentleyjs-core\";\nimport { RenderMemory } from \"../System\";\n\n/** @internal */\nexport class PolylineGeometry extends LUTGeometry {\n  public vertexParams: QParams3d;\n  public features?: FeaturesInfo;\n  public lineWeight: number;\n  public lineCode: number;\n  public type: PolylineTypeFlags;\n  private _isPlanar: boolean;\n  public lut: VertexLUT;\n  public numIndices: number;\n  private _buffers: PolylineBuffers;\n\n  private constructor(lut: VertexLUT, buffers: PolylineBuffers, params: PolylineParams) {\n    super();\n    this.vertexParams = params.vertices.qparams;\n    this.features = FeaturesInfo.createFromVertexTable(params.vertices);\n    this.lineWeight = params.weight;\n    this.lineCode = LineCode.valueFromLinePixels(params.linePixels);\n    this.type = params.type;\n    this._isPlanar = params.isPlanar;\n    this.lut = lut;\n    this.numIndices = params.polyline.indices.length;\n    this._buffers = buffers;\n  }\n\n  public dispose() {\n    dispose(this.lut);\n    dispose(this._buffers);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    this._buffers.collectStatistics(stats, RenderMemory.BufferType.Polylines);\n    stats.addVertexTable(this.lut.bytesUsed);\n  }\n\n  public get isAnyEdge(): boolean { return PolylineTypeFlags.Normal !== this.type; }\n  public get isNormalEdge(): boolean { return PolylineTypeFlags.Edge === this.type; }\n  public get isOutlineEdge(): boolean { return PolylineTypeFlags.Outline === this.type; }\n\n  public get renderOrder(): RenderOrder {\n    if (this.isAnyEdge)\n      return this.isPlanar ? RenderOrder.PlanarEdge : RenderOrder.Edge;\n    else\n      return this.isPlanar ? RenderOrder.PlanarLinear : RenderOrder.Linear;\n  }\n\n  protected _wantWoWReversal(_target: Target): boolean { return true; }\n\n  public get polylineBuffers(): PolylineBuffers | undefined { return this._buffers; }\n\n  private _computeEdgePass(target: Target, colorInfo: ColorInfo): RenderPass {\n    const vf = target.currentViewFlags;\n    if (RenderMode.SmoothShade === vf.renderMode && !vf.visibleEdges)\n      return RenderPass.None;\n\n    // Only want to return Translucent for edges if rendering in Wireframe mode ###TODO: what about overrides?\n    const isTranslucent: boolean = RenderMode.Wireframe === vf.renderMode && vf.transparency && colorInfo.hasTranslucency;\n    return isTranslucent ? RenderPass.Translucent : RenderPass.OpaqueLinear;\n  }\n\n  public getRenderPass(target: Target): RenderPass {\n    const vf = target.currentViewFlags;\n    if (this.isEdge) {\n      let pass = this._computeEdgePass(target, this.lut.colorInfo);\n      // Only display the outline in wireframe if Fill is off...\n      if (RenderPass.None !== pass && this.isOutlineEdge && RenderMode.Wireframe === vf.renderMode && vf.fill)\n        pass = RenderPass.None;\n      return pass;\n    }\n    const isTranslucent: boolean = vf.transparency && this.lut.colorInfo.hasTranslucency;\n    return isTranslucent ? RenderPass.Translucent : RenderPass.OpaqueLinear;\n  }\n\n  public getTechniqueId(_target: Target): TechniqueId { return TechniqueId.Polyline; }\n  public get isPlanar(): boolean { return this._isPlanar; }\n  public get isEdge(): boolean { return this.isAnyEdge; }\n  public get qOrigin(): Float32Array { return this.lut.qOrigin; }\n  public get qScale(): Float32Array { return this.lut.qScale; }\n  public get numRgbaPerVertex(): number { return this.lut.numRgbaPerVertex; }\n  public get featuresInfo(): FeaturesInfo | undefined { return this.features; }\n\n  protected _getLineWeight(params: ShaderProgramParams): number {\n    return this.isEdge ? params.target.getEdgeWeight(params, this.lineWeight) : this.lineWeight;\n  }\n  protected _getLineCode(params: ShaderProgramParams): number {\n    return this.isEdge ? params.target.getEdgeLineCode(params, this.lineCode) : this.lineCode;\n  }\n  public getColor(target: Target): ColorInfo { return this.isEdge && target.isEdgeColorOverridden ? target.edgeColor : this.lut.colorInfo; }\n\n  public bindVertexArray(attr: AttributeHandle): void {\n    attr.enableArray(this._buffers!.indices, 3, GL.DataType.UnsignedByte, false, 0, 0);\n  }\n\n  protected _draw(numInstances: number): void {\n    const gl = System.instance;\n    this._buffers!.indices.bind(GL.Buffer.Target.ArrayBuffer);\n    gl.drawArrays(GL.PrimitiveType.Triangles, 0, this.numIndices, numInstances);\n  }\n\n  public static create(params: PolylineParams): PolylineGeometry | undefined {\n    const lut = VertexLUT.createFromVertexTable(params.vertices);\n    if (undefined === lut)\n      return undefined;\n\n    const buffers = PolylineBuffers.create(params.polyline);\n    if (undefined === buffers)\n      return undefined;\n\n    return new PolylineGeometry(lut, buffers, params);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { FeatureIndexType } from \"@bentley/imodeljs-common\";\nimport { Target, PrimitiveVisibility } from \"./Target\";\nimport { Graphic, Batch } from \"./Graphic\";\nimport { CachedGeometry, LUTGeometry } from \"./CachedGeometry\";\nimport { RenderPass, RenderOrder } from \"./RenderFlags\";\nimport { ShaderProgramExecutor } from \"./ShaderProgram\";\nimport { DrawParams, RenderCommands, DrawCommand } from \"./DrawCommand\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { assert, dispose } from \"@bentley/bentleyjs-core\";\nimport { System } from \"./System\";\nimport { InstancedGraphicParams, RenderMemory } from \"../System\";\nimport { InstancedGeometry, InstanceBuffers } from \"./InstancedGeometry\";\n\n/** @internal */\nexport class Primitive extends Graphic {\n  public cachedGeometry: CachedGeometry;\n  public isPixelMode: boolean = false;\n\n  protected constructor(cachedGeom: CachedGeometry) { super(); this.cachedGeometry = cachedGeom; }\n\n  public static create(createGeom: () => CachedGeometry | undefined, instances?: InstancedGraphicParams): Primitive | undefined {\n    const instanceBuffers = undefined !== instances ? InstanceBuffers.create(instances, false) : undefined;\n    if (undefined === instanceBuffers && undefined !== instances)\n      return undefined;\n\n    return this.createShared(createGeom, instanceBuffers);\n  }\n\n  public static createShared(createGeom: () => CachedGeometry | undefined, instances?: InstanceBuffers): Primitive | undefined {\n    let geom = createGeom();\n    if (undefined === geom)\n      return undefined;\n\n    if (undefined !== instances) {\n      assert(geom instanceof LUTGeometry, \"Invalid geometry type for instancing\");\n      geom = new InstancedGeometry(geom as LUTGeometry, true, instances);\n\n      // Ensure range computed immediately so we can discard the Float32Array holding the instance transforms...\n      geom.computeRange();\n    }\n\n    return undefined !== geom ? new this(geom) : undefined;\n  }\n\n  public dispose() {\n    dispose(this.cachedGeometry);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    this.cachedGeometry.collectStatistics(stats);\n  }\n\n  public getRenderPass(target: Target) {\n    if (this.isPixelMode)\n      return RenderPass.ViewOverlay;\n\n    switch (target.primitiveVisibility) {\n      case PrimitiveVisibility.Uninstanced:\n        if (this.cachedGeometry.isInstanced)\n          return RenderPass.None;\n        break;\n      case PrimitiveVisibility.Instanced:\n        if (!this.cachedGeometry.isInstanced)\n          return RenderPass.None;\n        break;\n    }\n\n    return this.cachedGeometry.getRenderPass(target);\n  }\n\n  public get featureIndexType(): FeatureIndexType {\n    const feature = this.cachedGeometry.featuresInfo;\n    return undefined !== feature ? feature.type : FeatureIndexType.Empty;\n  }\n\n  public get usesMaterialColor(): boolean {\n    const materialData = this.cachedGeometry.material;\n    return undefined !== materialData && (materialData.overridesRgb || materialData.overridesAlpha);\n  }\n\n  public addCommands(commands: RenderCommands): void { commands.addPrimitive(this); }\n\n  public addHiliteCommands(commands: RenderCommands, batch: Batch, pass: RenderPass): void {\n    // Edges do not contribute to hilite pass.\n    // Note that IsEdge() does not imply geom->ToEdge() => true...polylines can be edges too...\n    if (!this.isEdge) {\n      commands.getCommands(pass).push(DrawCommand.createForPrimitive(this, batch));\n    }\n  }\n\n  public setUniformFeatureIndices(featId: number): void { this.cachedGeometry.uniformFeatureIndices = featId; }\n  public get hasAnimation(): boolean { return this.cachedGeometry.hasAnimation; }\n  public get isInstanced(): boolean { return this.cachedGeometry.isInstanced; }\n  public get isLit(): boolean { return this.cachedGeometry.isLitSurface; }\n  public get isEdge(): boolean { return this.cachedGeometry.isEdge; }\n  public get renderOrder(): RenderOrder { return this.cachedGeometry.renderOrder; }\n\n  public toPrimitive(): Primitive { return this; }\n\n  private static _drawParams?: DrawParams;\n\n  public draw(shader: ShaderProgramExecutor): void {\n    // ###TODO: local to world should be pushed before we're invoked...we shouldn't need to pass (or copy) it\n    if (undefined === Primitive._drawParams)\n      Primitive._drawParams = new DrawParams();\n\n    const drawParams = Primitive._drawParams!;\n    drawParams.init(shader.params, this.cachedGeometry, shader.target.currentTransform, shader.renderPass);\n    shader.draw(drawParams);\n  }\n\n  public getTechniqueId(target: Target): TechniqueId { return this.cachedGeometry.getTechniqueId(target); }\n}\n\n/** @internal */\nexport class SkyCubePrimitive extends Primitive {\n  public constructor(cachedGeom: CachedGeometry) { super(cachedGeom); }\n\n  public draw(shader: ShaderProgramExecutor): void {\n    // Alter viewport to maintain square aspect ratio of skybox images even as viewRect resizes\n    const vh = shader.target.viewRect.height;\n    const vw = shader.target.viewRect.width;\n    if (vw > vh)\n      System.instance.context.viewport(0, -(vw - vh) / 2, vw, vw);\n    else\n      System.instance.context.viewport(-(vh - vw) / 2, 0, vh, vh);\n\n    super.draw(shader); // Draw the skybox cubemap\n\n    System.instance.context.viewport(0, 0, vw, vh); // Restore viewport\n  }\n}\n\n/** @internal */\nexport class SkySpherePrimitive extends Primitive {\n  public constructor(cachedGeom: CachedGeometry) { super(cachedGeom); }\n\n  public draw(shader: ShaderProgramExecutor): void {\n    super.draw(shader); // Draw the skybox sphere\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert, IDisposable } from \"@bentley/bentleyjs-core\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\n\n/** @internal */\nexport class RenderBuffer implements IDisposable {\n  private _glBuffer?: WebGLRenderbuffer;\n\n  public getHandle() { return this._glBuffer; }\n\n  public static create(width: number, height: number, format = GL.RenderBuffer.Format.DepthComponent16) {\n    const gl: WebGLRenderingContext = System.instance.context;\n\n    const glBuffer = gl.createRenderbuffer();\n    if (null === glBuffer) {\n      return undefined;\n    }\n\n    assert(0 < width && 0 < height);\n    RenderBuffer.bindBuffer(glBuffer);\n    gl.renderbufferStorage(GL.RenderBuffer.TARGET, format, width, height);\n    RenderBuffer.unbind();\n\n    return new RenderBuffer(glBuffer);\n  }\n\n  public get isDisposed(): boolean { return this._glBuffer === undefined || this._glBuffer === null; }\n\n  public dispose(): void {\n    if (!this.isDisposed) {\n      System.instance.context.deleteRenderbuffer(this._glBuffer!);\n      this._glBuffer = undefined;\n    }\n  }\n\n  public bind() {\n    assert(undefined !== this._glBuffer);\n    if (undefined !== this._glBuffer) {\n      RenderBuffer.bindBuffer(this._glBuffer);\n    }\n  }\n\n  private constructor(glBuffer: WebGLRenderbuffer) { this._glBuffer = glBuffer; }\n\n  private static bindBuffer(glBuffer: WebGLRenderbuffer | null) { System.instance.context.bindRenderbuffer(GL.RenderBuffer.TARGET, glBuffer); }\n  private static unbind() { this.bindBuffer(null); }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n// tslint:disable:no-const-enum\n\n/** Ordered list of render passes which produce a rendered frame.\n * @internal\n */\nexport const enum RenderPass {\n  None = 0xff,\n  Background = 0,\n  OpaqueLinear,       // Linear geometry that is opaque and needs to be written to the pick data buffers\n  OpaquePlanar,       // Planar surface geometry that is opaque and needs to be written to the pick data buffers\n  OpaqueGeneral,      // All other opaque geometry (including point clouds and reality meshes) which are not written to the pick data buffers\n  Classification,     // Stencil volumes for normal processing of reality data classification.\n  Translucent,\n  HiddenEdge,\n  Hilite,\n  WorldOverlay,\n  ViewOverlay,\n  SkyBox,\n  BackgroundMap,\n  HiliteClassification,  // Secondary hilite pass for stencil volumes to process hilited classifiers for reality data\n  ClassificationByIndex, // Stencil volumes for processing classification one classifier at a time (used for generating pick data Ids and flashing a single classifier).\n  HilitePlanarClassification,\n  PlanarClassification,\n  COUNT,\n}\n\n/** Describes the type of geometry rendered by a ShaderProgram.\n * @internal\n */\nexport const enum GeometryType {\n  IndexedTriangles,\n  IndexedPoints,\n  ArrayedPoints,\n}\n\n/** Reserved texture units for specific sampler variables, to avoid conflicts between shader components which each have their own textures.\n * @internal\n */\nexport enum TextureUnit {\n  // For shaders which know exactly which textures will be used\n  Zero = WebGLRenderingContext.TEXTURE0,\n  One = WebGLRenderingContext.TEXTURE1,\n  Two = WebGLRenderingContext.TEXTURE2,\n  Three = WebGLRenderingContext.TEXTURE3,\n  Four = WebGLRenderingContext.TEXTURE4,\n  Five = WebGLRenderingContext.TEXTURE5,\n  Six = WebGLRenderingContext.TEXTURE6,\n  Seven = WebGLRenderingContext.TEXTURE7, // Last one available for GLES2\n\n  ClipVolume = Zero,\n  FeatureSymbology = One,\n  SurfaceTexture = Two,\n  LineCode = Two,\n\n  PickFeatureId = Three,\n  PickDepthAndOrder = Four,\n\n  VertexLUT = Five,\n  AuxChannelLUT = Six,\n  PlanarClassification = Six,               // classification or aux channel - not both.\n  PlanarClassificationHilite = Six,         // hilite or color, not both.\n  ShadowMap = Seven,                        // shadows or classification - not both.\n}\n\n/**\n * Defines the order in which primitives are rendered within a GLESList. This is chiefly\n * used to sort primitives which originate from the same element. e.g., the blanking fill\n * associated with a text field must always render behind the text; the edges of a surface\n * must render in front of the surface; etc.\n * An exception to the 'same element' rule is provided for planar surfaces and edges thereof\n * sketched onto non-planar surfaces. When the depth test is ambiguous the planar geometry\n * is always on top of the non-planar surface. This addresses z-fighting when shapes are\n * sketched onto surfaces, e.g. as part of push-pull modeling workflows.\n * @internal\n */\nexport const enum RenderOrder {\n  None = 0,\n  BlankingRegion = 1,\n  Surface = 2,\n  Linear = 3,\n  Edge = 4,\n  Silhouette = 5,\n\n  PlanarBit = 8,\n\n  PlanarSurface = Surface | PlanarBit,\n  PlanarLinear = Linear | PlanarBit,\n  PlanarEdge = Edge | PlanarBit,\n  PlanarSilhouette = Silhouette | PlanarBit,\n}\n\n/** @internal */\nexport function isPlanar(order: RenderOrder): boolean { return order >= RenderOrder.PlanarBit; }\n\n/** @internal */\nexport function isSurface(order: RenderOrder): boolean { return order <= RenderOrder.Surface || order === RenderOrder.PlanarSurface; }\n\n/** Flags indicating operations to be performed by the post-process composite step.\n * @internal\n */\nexport const enum CompositeFlags {\n  None = 0,\n  Translucent = 1 << 0,\n  Hilite = 1 << 1,\n  AmbientOcclusion = 1 << 2,\n}\n\n/** Describes attributes of a MeshGeometry object. Used to conditionally execute portion of shader programs.\n * @internal\n */\nexport const enum SurfaceFlags {\n  None = 0,\n  HasTexture = 1 << 0,\n  ApplyLighting = 1 << 1,\n  HasNormals = 1 << 2,\n\n  // NB: In u_surfaceFlags provided to shader, indicates material color/specular/alpha should be ignored. Has no effect on texture.\n  // If a given feature has the 'ignore material' override set, v_surfaceFlags will be modified to turn on IgnoreMaterial and turn off HasTexture.\n  IgnoreMaterial = 1 << 3,\n\n  // In HiddenLine and SolidFill modes, a transparency threshold is supplied; surfaces that are more transparent than the threshold are not rendered.\n  TransparencyThreshold = 1 << 4,\n\n  // For HiddenLine mode\n  BackgroundFill = 1 << 5,\n\n  // For textured meshes, the color index in the vertex LUT is unused - we place the normal there instead.\n  // For untextured lit meshes, the normal is placed after the feature ID.\n  HasColorAndNormal = 1 << 6,\n}\n\n/** @internal */\nexport const enum OvrFlags {\n  None = 0,\n  Visibility = 1 << 0,\n  Rgb = 1 << 1,\n  Alpha = 1 << 2,\n  Weight = 1 << 3,\n  Flashed = 1 << 4,\n  Hilited = 1 << 5,\n  LineCode = 1 << 6,\n  IgnoreMaterial = 1 << 7, // ignore material color, specular properties, and texture\n\n  Rgba = Rgb | Alpha,\n}\n\n/** @internal */\nexport const enum IsTranslucent { No, Yes, Maybe }\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\n\n/** @internal */\nexport class RenderStateFlags {\n  public cull: boolean = false;\n  public depthTest: boolean = false;\n  public blend: boolean = false;\n  public stencilTest: boolean = false;\n  public depthMask: boolean = true;\n  public colorWrite: boolean = true;\n\n  public constructor(src?: RenderStateFlags) {\n    if (src) {\n      this.copyFrom(src);\n    }\n  }\n\n  public copyFrom(src: RenderStateFlags): void {\n    this.cull = src.cull;\n    this.depthTest = src.depthTest;\n    this.blend = src.blend;\n    this.stencilTest = src.stencilTest;\n    this.depthMask = src.depthMask;\n    this.colorWrite = src.colorWrite;\n  }\n\n  public clone(result?: RenderStateFlags): RenderStateFlags {\n    if (!result) {\n      return new RenderStateFlags(this);\n    } else {\n      result.copyFrom(this);\n      return result;\n    }\n  }\n\n  public equals(rhs: RenderStateFlags): boolean {\n    return this.cull === rhs.cull\n      && this.depthTest === rhs.depthTest\n      && this.blend === rhs.blend\n      && this.stencilTest === rhs.stencilTest\n      && this.depthMask === rhs.depthMask\n      && this.colorWrite === rhs.colorWrite;\n  }\n\n  public apply(previousFlags: RenderStateFlags): void {\n    RenderStateFlags.enableOrDisable(this.cull, GL.Capability.CullFace, previousFlags.cull);\n    RenderStateFlags.enableOrDisable(this.depthTest, GL.Capability.DepthTest, previousFlags.depthTest);\n    RenderStateFlags.enableOrDisable(this.blend, GL.Capability.Blend, previousFlags.blend);\n    RenderStateFlags.enableOrDisable(this.stencilTest, GL.Capability.StencilTest, previousFlags.stencilTest);\n\n    if (previousFlags.depthMask !== this.depthMask) {\n      System.instance.context.depthMask(this.depthMask);\n    }\n\n    if (previousFlags.colorWrite !== this.colorWrite) {\n      System.instance.context.colorMask(this.colorWrite, this.colorWrite, this.colorWrite, this.colorWrite);\n    }\n  }\n\n  public static enableOrDisable(currentFlag: boolean, value: number, previousFlag: boolean) {\n    if (currentFlag !== previousFlag) {\n      const gl: WebGLRenderingContext = System.instance.context;\n      if (currentFlag) {\n        gl.enable(value);\n      } else {\n        gl.disable(value);\n      }\n    }\n  }\n}\n\n/** @internal */\nexport class RenderStateBlend {\n  public color: [number, number, number, number] = [0.0, 0.0, 0.0, 0.0];\n  public equationRgb: GL.BlendEquation = GL.BlendEquation.Default;\n  public equationAlpha: GL.BlendEquation = GL.BlendEquation.Default;\n  public functionSourceRgb: GL.BlendFactor = GL.BlendFactor.DefaultSrc;\n  public functionSourceAlpha: GL.BlendFactor = GL.BlendFactor.DefaultSrc;\n  public functionDestRgb: GL.BlendFactor = GL.BlendFactor.DefaultDst;\n  public functionDestAlpha: GL.BlendFactor = GL.BlendFactor.DefaultDst;\n\n  public constructor(src?: RenderStateBlend) {\n    if (src) {\n      this.copyFrom(src);\n    }\n  }\n\n  public apply(previousBlend?: RenderStateBlend): void {\n    const gl: WebGLRenderingContext = System.instance.context;\n\n    if (previousBlend === undefined || !this.equalColors(previousBlend)) {\n      gl.blendColor(this.color[0], this.color[1], this.color[2], this.color[3]);\n    }\n    if (previousBlend === undefined || previousBlend.equationRgb !== this.equationRgb || previousBlend.equationAlpha !== this.equationAlpha) {\n      gl.blendEquationSeparate(this.equationRgb, this.equationAlpha);\n    }\n    if (previousBlend === undefined || previousBlend.functionSourceRgb !== this.functionSourceRgb || previousBlend.functionSourceAlpha !== this.functionSourceAlpha\n      || previousBlend.functionDestRgb !== this.functionDestRgb || previousBlend.functionDestAlpha !== this.functionDestAlpha) {\n      gl.blendFuncSeparate(this.functionSourceRgb, this.functionDestRgb, this.functionSourceAlpha, this.functionDestAlpha);\n    }\n  }\n\n  public copyFrom(src: RenderStateBlend): void {\n    this.setColor(src.color);\n    this.equationRgb = src.equationRgb;\n    this.equationAlpha = src.equationAlpha;\n    this.functionSourceRgb = src.functionSourceRgb;\n    this.functionSourceAlpha = src.functionSourceAlpha;\n    this.functionDestRgb = src.functionDestRgb;\n    this.functionDestAlpha = src.functionDestAlpha;\n  }\n\n  public clone(result?: RenderStateBlend): RenderStateBlend {\n    if (!result) {\n      return new RenderStateBlend(this);\n    } else {\n      result.copyFrom(this);\n      return result;\n    }\n  }\n\n  public equals(rhs: RenderStateBlend): boolean {\n    return this.equalColors(rhs)\n      && this.equationRgb === rhs.equationRgb\n      && this.equationAlpha === rhs.equationAlpha\n      && this.functionSourceRgb === rhs.functionSourceRgb\n      && this.functionSourceAlpha === rhs.functionSourceAlpha\n      && this.functionDestRgb === rhs.functionDestRgb\n      && this.functionDestAlpha === rhs.functionDestAlpha;\n  }\n\n  public equalColors(rhs: RenderStateBlend): boolean {\n    return this.color[0] === rhs.color[0] &&\n      this.color[1] === rhs.color[1] &&\n      this.color[2] === rhs.color[2] &&\n      this.color[3] === rhs.color[3];\n  }\n\n  public setColor(color: [number, number, number, number]) {\n    this.color[0] = color[0];\n    this.color[1] = color[1];\n    this.color[2] = color[2];\n    this.color[3] = color[3];\n  }\n\n  public setBlendFunc(src: GL.BlendFactor, dst: GL.BlendFactor): void {\n    this.setBlendFuncSeparate(src, src, dst, dst);\n  }\n\n  public setBlendFuncSeparate(srcRgb: GL.BlendFactor, srcAlpha: GL.BlendFactor, dstRgb: GL.BlendFactor, dstAlpha: GL.BlendFactor): void {\n    this.functionSourceRgb = srcRgb;\n    this.functionSourceAlpha = srcAlpha;\n    this.functionDestRgb = dstRgb;\n    this.functionDestAlpha = dstAlpha;\n  }\n}\n\n/** @internal */\nexport class RenderStateStencilOperation {\n  public fail: GL.StencilOperation = GL.StencilOperation.Default;\n  public zFail: GL.StencilOperation = GL.StencilOperation.Default;\n  public zPass: GL.StencilOperation = GL.StencilOperation.Default;\n\n  public constructor(src?: RenderStateStencilOperation) {\n    if (src) {\n      this.copyFrom(src);\n    }\n  }\n\n  public copyFrom(src: RenderStateStencilOperation): void {\n    this.fail = src.fail;\n    this.zFail = src.zFail;\n    this.zPass = src.zPass;\n  }\n\n  public clone(result?: RenderStateStencilOperation): RenderStateStencilOperation {\n    if (!result) {\n      return new RenderStateStencilOperation(this);\n    } else {\n      result.copyFrom(this);\n      return result;\n    }\n  }\n\n  public equals(rhs: RenderStateStencilOperation): boolean {\n    return this.fail === rhs.fail\n      && this.zFail === rhs.zFail\n      && this.zPass === rhs.zPass;\n  }\n}\n\n/** @internal */\nexport class RenderStateStencilFunction {\n  public function: GL.StencilFunction = GL.StencilFunction.Default;\n  public ref: number = 0;\n  public mask: number = 0xFFFFFFFF;\n\n  public constructor(src?: RenderStateStencilFunction) {\n    if (src) {\n      this.copyFrom(src);\n    }\n  }\n\n  public copyFrom(src: RenderStateStencilFunction): void {\n    this.function = src.function;\n    this.ref = src.ref;\n    this.mask = src.mask;\n  }\n\n  public clone(result?: RenderStateStencilFunction): RenderStateStencilFunction {\n    if (!result) {\n      return new RenderStateStencilFunction(this);\n    } else {\n      result.copyFrom(this);\n      return result;\n    }\n  }\n\n  public equals(rhs: RenderStateStencilFunction): boolean {\n    return this.function === rhs.function\n      && this.ref === rhs.ref\n      && this.mask === rhs.mask;\n  }\n}\n\n/** @internal */\nexport class RenderStateStencil {\n  public frontFunction: RenderStateStencilFunction = new RenderStateStencilFunction();\n  public backFunction: RenderStateStencilFunction = new RenderStateStencilFunction();\n  public frontOperation: RenderStateStencilOperation = new RenderStateStencilOperation();\n  public backOperation: RenderStateStencilOperation = new RenderStateStencilOperation();\n\n  public constructor(src?: RenderStateStencil) {\n    if (src) {\n      this.copyFrom(src);\n    }\n  }\n\n  public apply(previousStencil?: RenderStateStencil): void {\n    const gl = System.instance.context;\n    if (previousStencil === undefined || !previousStencil.frontFunction.equals(this.frontFunction)) {\n      gl.stencilFuncSeparate(GL.CullFace.Front, this.frontFunction.function, this.frontFunction.ref, this.frontFunction.mask);\n    }\n    if (previousStencil === undefined || !previousStencil.backFunction.equals(this.backFunction)) {\n      gl.stencilFuncSeparate(GL.CullFace.Back, this.backFunction.function, this.backFunction.ref, this.backFunction.mask);\n    }\n    if (previousStencil === undefined || !previousStencil.frontOperation.equals(this.frontOperation)) {\n      gl.stencilOpSeparate(GL.CullFace.Front, this.frontOperation.fail, this.frontOperation.zFail, this.frontOperation.zPass);\n    }\n    if (previousStencil === undefined || !previousStencil.backOperation.equals(this.backOperation)) {\n      gl.stencilOpSeparate(GL.CullFace.Back, this.backOperation.fail, this.backOperation.zFail, this.backOperation.zPass);\n    }\n  }\n\n  public copyFrom(src: RenderStateStencil): void {\n    this.frontFunction.copyFrom(src.frontFunction);\n    this.backFunction.copyFrom(src.backFunction);\n    this.frontOperation.copyFrom(src.frontOperation);\n    this.backOperation.copyFrom(src.backOperation);\n  }\n\n  public clone(result?: RenderStateStencil): RenderStateStencil {\n    if (!result) {\n      return new RenderStateStencil(this);\n    } else {\n      result.copyFrom(this);\n      return result;\n    }\n  }\n\n  public equals(rhs: RenderStateStencil): boolean {\n    return this.frontFunction.equals(rhs.frontFunction)\n      && this.backFunction.equals(rhs.backFunction)\n      && this.frontOperation.equals(rhs.frontOperation)\n      && this.backOperation.equals(rhs.backOperation);\n  }\n}\n\n/** Encapsulates the state of an OpenGL context.\n * to modify the context for a rendering operation, do *not* directly call\n * functions like glDepthMask(), glBlendFunc(), etc - otherwise such calls may adversely\n * affect subsequent rendering operations.\n * Instead, set up a RenderState as desired and invoke System.instance.applyRenderState()\n * The context tracks the most-recently applied RenderState, allowing it to minimize\n * the number of GL state changes actually invoked, improving performance.\n * @internal\n */\nexport class RenderState {\n  public flags: RenderStateFlags = new RenderStateFlags();\n  public blend: RenderStateBlend = new RenderStateBlend();\n  public stencil: RenderStateStencil = new RenderStateStencil();\n  public frontFace: GL.FrontFace = GL.FrontFace.Default;\n  public cullFace: GL.CullFace = GL.CullFace.Default;\n  public depthFunc: GL.DepthFunc = GL.DepthFunc.Default;\n  public stencilMask: number = 0xFFFFFFFF;\n\n  public constructor(src?: RenderState) {\n    if (src) {\n      this.copyFrom(src);\n    }\n  }\n\n  public static defaults = new RenderState();\n\n  public copyFrom(src: RenderState): void {\n    this.flags.copyFrom(src.flags);\n    this.blend.copyFrom(src.blend);\n    this.stencil.copyFrom(src.stencil);\n    this.frontFace = src.frontFace;\n    this.cullFace = src.cullFace;\n    this.depthFunc = src.depthFunc;\n    this.stencilMask = src.stencilMask;\n  }\n\n  public clone(result?: RenderState): RenderState {\n    if (!result) {\n      return new RenderState(this);\n    } else {\n      result.copyFrom(this);\n      return result;\n    }\n  }\n\n  public set clockwiseFrontFace(clockwise: boolean) {\n    this.frontFace = clockwise ? GL.FrontFace.Clockwise : GL.FrontFace.CounterClockwise;\n  }\n\n  public equals(rhs: RenderState): boolean {\n    return this.flags.equals(rhs.flags)\n      && this.blend.equals(rhs.blend)\n      && this.stencil.equals(rhs.stencil)\n      && this.frontFace === rhs.frontFace\n      && this.cullFace === rhs.cullFace\n      && this.depthFunc === rhs.depthFunc\n      && this.stencilMask === rhs.stencilMask;\n  }\n\n  public apply(prevState: RenderState): void {\n    this.flags.apply(prevState.flags);\n\n    if (this.flags.blend) {\n      if (prevState.flags.blend)\n        this.blend.apply(prevState.blend);\n      else\n        this.blend.apply();\n    }\n\n    if (this.flags.cull) {\n      if (!prevState.flags.cull || prevState.cullFace !== this.cullFace) {\n        System.instance.context.cullFace(this.cullFace);\n      }\n    }\n\n    if (this.flags.depthTest) {\n      if (!prevState.flags.depthTest || prevState.depthFunc !== this.depthFunc) {\n        System.instance.context.depthFunc(this.depthFunc);\n      }\n    }\n\n    if (this.flags.stencilTest) {\n      if (prevState.flags.stencilTest)\n        this.stencil.apply(prevState.stencil);\n      else\n        this.stencil.apply();\n    }\n\n    if (this.frontFace !== prevState.frontFace) {\n      System.instance.context.frontFace(this.frontFace);\n    }\n\n    if (this.stencilMask !== prevState.stencilMask) {\n      System.instance.context.stencilMask(this.stencilMask);\n    }\n  }\n}\n\nObject.freeze(RenderState.defaults);\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { FrameBuffer, DepthBuffer } from \"./FrameBuffer\";\nimport { TextureHandle } from \"./Texture\";\nimport { Target } from \"./Target\";\nimport { ViewportQuadGeometry, CompositeGeometry, CopyPickBufferGeometry, SingleTexturedViewportQuadGeometry, CachedGeometry, AmbientOcclusionGeometry, BlurGeometry } from \"./CachedGeometry\";\nimport { Vector2d, Vector3d } from \"@bentley/geometry-core\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { System, RenderType, DepthType } from \"./System\";\nimport { PackedFeatureTable, Pixel, GraphicList } from \"../System\";\nimport { ViewRect } from \"../../Viewport\";\nimport { assert, Id64, IDisposable, dispose } from \"@bentley/bentleyjs-core\";\nimport { GL } from \"./GL\";\nimport { RenderCommands, ShaderProgramParams, DrawParams, DrawCommands, BatchPrimitiveCommand } from \"./DrawCommand\";\nimport { RenderState } from \"./RenderState\";\nimport { CompositeFlags, RenderPass, RenderOrder } from \"./RenderFlags\";\nimport { BatchState } from \"./BranchState\";\nimport { Feature } from \"@bentley/imodeljs-common\";\nimport { Debug } from \"./Diagnostics\";\n\nlet progParams: ShaderProgramParams | undefined;\nlet drawParams: DrawParams | undefined;\n\n/** @internal */\nexport function getDrawParams(target: Target, geometry: CachedGeometry): DrawParams {\n  if (undefined === progParams) {\n    progParams = new ShaderProgramParams();\n    drawParams = new DrawParams();\n  }\n\n  progParams.init(target);\n  drawParams!.init(progParams, geometry);\n  return drawParams!;\n}\n\n// Maintains the textures used by a SceneCompositor. The textures are reallocated when the dimensions of the viewport change.\nclass Textures implements IDisposable {\n  public accumulation?: TextureHandle;\n  public revealage?: TextureHandle;\n  public color?: TextureHandle;\n  public featureId?: TextureHandle;\n  public depthAndOrder?: TextureHandle;\n  public hilite?: TextureHandle;\n  public occlusion?: TextureHandle;\n  public occlusionBlur?: TextureHandle;\n\n  public dispose() {\n    this.accumulation = dispose(this.accumulation);\n    this.revealage = dispose(this.revealage);\n    this.color = dispose(this.color);\n    this.featureId = dispose(this.featureId);\n    this.depthAndOrder = dispose(this.depthAndOrder);\n    this.hilite = dispose(this.hilite);\n    this.occlusion = dispose(this.occlusion);\n    this.occlusionBlur = dispose(this.occlusionBlur);\n  }\n\n  public init(width: number, height: number): boolean {\n    assert(undefined === this.accumulation);\n\n    let pixelDataType: GL.Texture.DataType = GL.Texture.DataType.UnsignedByte;\n    switch (System.instance.capabilities.maxRenderType) {\n      case RenderType.TextureFloat: {\n        pixelDataType = GL.Texture.DataType.Float;\n        break;\n      }\n      case RenderType.TextureHalfFloat: {\n        const ext = System.instance.capabilities.queryExtensionObject<OES_texture_half_float>(\"OES_texture_half_float\");\n        if (undefined !== ext) {\n          pixelDataType = ext.HALF_FLOAT_OES;\n          break;\n        }\n      }\n      /* falls through */\n      case RenderType.TextureUnsignedByte: {\n        break;\n      }\n    }\n\n    // NB: Both of these must be of the same type, because they are borrowed by pingpong and bound to the same frame buffer.\n    this.accumulation = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, pixelDataType);\n    this.revealage = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, pixelDataType);\n\n    // Hilite texture is a simple on-off, but the smallest texture format WebGL allows us to use as output is RGBA with a byte per component.\n    this.hilite = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n\n    this.color = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n\n    this.featureId = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n    this.depthAndOrder = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n\n    return undefined !== this.accumulation\n      && undefined !== this.revealage\n      && undefined !== this.color\n      && undefined !== this.featureId\n      && undefined !== this.depthAndOrder\n      && undefined !== this.hilite;\n  }\n\n  public enableOcclusion(width: number, height: number): boolean {\n    assert(undefined === this.occlusion && undefined === this.occlusionBlur);\n    this.occlusion = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n    this.occlusionBlur = TextureHandle.createForAttachment(width, height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n    return undefined !== this.occlusion && undefined !== this.occlusionBlur;\n  }\n\n  public disableOcclusion(): void {\n    assert(undefined !== this.occlusion && undefined !== this.occlusionBlur);\n    this.occlusion = dispose(this.occlusion);\n    this.occlusionBlur = dispose(this.occlusionBlur);\n  }\n}\n\n// Maintains the framebuffers used by a SceneCompositor. The color attachments are supplied by a Textures object.\nclass FrameBuffers implements IDisposable {\n  public opaqueColor?: FrameBuffer;\n  public opaqueAndCompositeColor?: FrameBuffer;\n  public depthAndOrder?: FrameBuffer;\n  public hilite?: FrameBuffer;\n  public hiliteUsingStencil?: FrameBuffer;\n  public stencilSet?: FrameBuffer;\n  public occlusion?: FrameBuffer;\n  public occlusionBlur?: FrameBuffer;\n\n  public init(textures: Textures, depth: DepthBuffer): boolean {\n    const boundColor = System.instance.frameBufferStack.currentColorBuffer;\n    if (undefined === boundColor)\n      return false;\n\n    this.opaqueColor = FrameBuffer.create([boundColor], depth);\n    this.opaqueAndCompositeColor = FrameBuffer.create([textures.color!], depth);\n    this.depthAndOrder = FrameBuffer.create([textures.depthAndOrder!], depth);\n    this.hilite = FrameBuffer.create([textures.hilite!]);\n    this.hiliteUsingStencil = FrameBuffer.create([textures.hilite!], depth);\n\n    if (DepthType.TextureUnsignedInt24Stencil8 === System.instance.capabilities.maxDepthType)\n      this.stencilSet = FrameBuffer.create([], depth);\n\n    return undefined !== this.opaqueColor\n      && undefined !== this.opaqueAndCompositeColor\n      && undefined !== this.depthAndOrder\n      && undefined !== this.hilite\n      && undefined !== this.hiliteUsingStencil;\n  }\n\n  public toggleOcclusion(textures: Textures): void {\n    if (undefined !== textures.occlusion) {\n      assert(undefined !== textures.occlusionBlur);\n      this.occlusion = FrameBuffer.create([textures.occlusion]);\n      this.occlusionBlur = FrameBuffer.create([textures.occlusionBlur!]);\n    } else {\n      assert(undefined === textures.occlusionBlur);\n      this.occlusion = dispose(this.occlusion);\n      this.occlusionBlur = dispose(this.occlusionBlur);\n    }\n  }\n\n  public dispose() {\n    this.opaqueColor = dispose(this.opaqueColor);\n    this.opaqueAndCompositeColor = dispose(this.opaqueAndCompositeColor);\n    this.depthAndOrder = dispose(this.depthAndOrder);\n    this.hilite = dispose(this.hilite);\n    this.hiliteUsingStencil = dispose(this.hiliteUsingStencil);\n    this.stencilSet = dispose(this.stencilSet);\n    this.occlusion = dispose(this.occlusion);\n    this.occlusionBlur = dispose(this.occlusionBlur);\n  }\n}\n\n// Maintains the geometry used to execute screenspace operations for a SceneCompositor.\nclass Geometry implements IDisposable {\n  public composite?: CompositeGeometry;\n  public stencilCopy?: ViewportQuadGeometry;\n  public occlusion?: AmbientOcclusionGeometry;\n  public occlusionXBlur?: BlurGeometry;\n  public occlusionYBlur?: BlurGeometry;\n\n  public init(textures: Textures): boolean {\n    assert(undefined === this.composite);\n    this.composite = CompositeGeometry.createGeometry(\n      textures.color!.getHandle()!,\n      textures.accumulation!.getHandle()!,\n      textures.revealage!.getHandle()!, textures.hilite!.getHandle()!);\n\n    this.stencilCopy = ViewportQuadGeometry.create(TechniqueId.CopyStencil);\n\n    return undefined !== this.composite;\n  }\n\n  public toggleOcclusion(textures: Textures): void {\n    if (undefined !== textures.occlusion) {\n      assert(undefined !== textures.occlusionBlur);\n      this.composite!.occlusion = textures.occlusion.getHandle();\n      this.occlusion = AmbientOcclusionGeometry.createGeometry(textures.depthAndOrder!.getHandle()!);\n      this.occlusionXBlur = BlurGeometry.createGeometry(textures.occlusion!.getHandle()!, textures.depthAndOrder!.getHandle()!, new Vector2d(1.0, 0.0));\n      this.occlusionYBlur = BlurGeometry.createGeometry(textures.occlusionBlur!.getHandle()!, textures.depthAndOrder!.getHandle()!, new Vector2d(0.0, 1.0));\n    } else {\n      assert(undefined === textures.occlusionBlur);\n      this.composite!.occlusion = undefined;\n      this.occlusion = dispose(this.occlusion);\n      this.occlusionXBlur = dispose(this.occlusionXBlur);\n      this.occlusionYBlur = dispose(this.occlusionYBlur);\n    }\n  }\n\n  public dispose() {\n    this.composite = dispose(this.composite);\n    this.stencilCopy = dispose(this.stencilCopy);\n    this.occlusion = dispose(this.occlusion);\n    this.occlusionXBlur = dispose(this.occlusionXBlur);\n    this.occlusionYBlur = dispose(this.occlusionYBlur);\n  }\n}\n\n// Represents a view of data read from a region of the frame buffer.\nclass PixelBuffer implements Pixel.Buffer {\n  private readonly _rect: ViewRect;\n  private readonly _selector: Pixel.Selector;\n  private readonly _featureId?: Uint32Array;\n  private readonly _depthAndOrder?: Uint32Array;\n  private readonly _batchState: BatchState;\n\n  private get _numPixels(): number { return this._rect.width * this._rect.height; }\n\n  private getPixelIndex(x: number, y: number): number {\n    if (x < this._rect.left || y < this._rect.top)\n      return this._numPixels;\n\n    x -= this._rect.left;\n    y -= this._rect.top;\n    if (x >= this._rect.width || y >= this._rect.height)\n      return this._numPixels;\n\n    // NB: View coords have origin at top-left; GL at bottom-left. So our rows are upside-down.\n    y = this._rect.height - 1 - y;\n    return y * this._rect.width + x;\n  }\n\n  private getPixel32(data: Uint32Array, pixelIndex: number): number | undefined {\n    return pixelIndex < data.length ? data[pixelIndex] : undefined;\n  }\n\n  private getFeature(pixelIndex: number): Feature | undefined {\n    const featureId = this.getFeatureId(pixelIndex);\n    return undefined !== featureId ? this._batchState.getFeature(featureId) : undefined;\n  }\n\n  private getFeatureId(pixelIndex: number): number | undefined {\n    return undefined !== this._featureId ? this.getPixel32(this._featureId, pixelIndex) : undefined;\n  }\n\n  private getFeatureTable(pixelIndex: number): PackedFeatureTable | undefined {\n    const featureId = this.getFeatureId(pixelIndex);\n    if (undefined !== featureId) {\n      const batch = this._batchState.find(featureId);\n      if (undefined !== batch)\n        return batch.featureTable;\n    }\n\n    return undefined;\n  }\n\n  private readonly _scratchUint32Array = new Uint32Array(1);\n  private readonly _scratchUint8Array = new Uint8Array(this._scratchUint32Array.buffer);\n  private readonly _scratchVector3d = new Vector3d();\n  private readonly _mult = new Vector3d(1.0, 1.0 / 255.0, 1.0 / 65025.0);\n  private decodeDepthRgba(depthAndOrder: number): number {\n    this._scratchUint32Array[0] = depthAndOrder;\n    const bytes = this._scratchUint8Array;\n    const fpt = Vector3d.create(bytes[1] / 255.0, bytes[2] / 255.0, bytes[3] / 255.0, this._scratchVector3d);\n    let depth = fpt.dotProduct(this._mult);\n\n    assert(0.0 <= depth);\n    assert(1.01 >= depth); // rounding error...\n\n    depth = Math.min(1.0, depth);\n    depth = Math.max(0.0, depth);\n\n    return depth;\n  }\n\n  private decodeRenderOrderRgba(depthAndOrder: number): RenderOrder {\n    this._scratchUint32Array[0] = depthAndOrder;\n    const encByte = this._scratchUint8Array[0];\n    const enc = encByte / 255.0;\n    const dec = Math.floor(16.0 * enc + 0.5);\n    return dec;\n  }\n\n  private readonly _invalidPixelData = new Pixel.Data();\n  public getPixel(x: number, y: number): Pixel.Data {\n    const px = this._invalidPixelData;\n    const index = this.getPixelIndex(x, y);\n    if (index >= this._numPixels)\n      return px;\n\n    // Initialize to the defaults...\n    let distanceFraction = px.distanceFraction;\n    let geometryType = px.type;\n    let planarity = px.planarity;\n\n    const haveFeatureIds = Pixel.Selector.None !== (this._selector & Pixel.Selector.Feature);\n    const feature = haveFeatureIds ? this.getFeature(index) : undefined;\n    const featureTable = haveFeatureIds ? this.getFeatureTable(index) : undefined;\n    if (Pixel.Selector.None !== (this._selector & Pixel.Selector.GeometryAndDistance) && undefined !== this._depthAndOrder) {\n      const depthAndOrder = this.getPixel32(this._depthAndOrder, index);\n      if (undefined !== depthAndOrder) {\n        distanceFraction = this.decodeDepthRgba(depthAndOrder);\n\n        const orderWithPlanarBit = this.decodeRenderOrderRgba(depthAndOrder);\n        const order = orderWithPlanarBit & ~RenderOrder.PlanarBit;\n        planarity = (orderWithPlanarBit === order) ? Pixel.Planarity.NonPlanar : Pixel.Planarity.Planar;\n        switch (order) {\n          case RenderOrder.None:\n            geometryType = Pixel.GeometryType.None;\n            planarity = Pixel.Planarity.None;\n            break;\n          case RenderOrder.BlankingRegion:\n          case RenderOrder.Surface:\n            geometryType = Pixel.GeometryType.Surface;\n            break;\n          case RenderOrder.Linear:\n            geometryType = Pixel.GeometryType.Linear;\n            break;\n          case RenderOrder.Edge:\n            geometryType = Pixel.GeometryType.Edge;\n            break;\n          case RenderOrder.Silhouette:\n            geometryType = Pixel.GeometryType.Silhouette;\n            break;\n          default:\n            // ###TODO: may run into issues with point clouds - they are not written correctly in C++.\n            assert(false, \"Invalid render order\");\n            geometryType = Pixel.GeometryType.None;\n            planarity = Pixel.Planarity.None;\n            break;\n        }\n      }\n    }\n\n    return new Pixel.Data(feature, distanceFraction, geometryType, planarity, featureTable);\n  }\n\n  private constructor(rect: ViewRect, selector: Pixel.Selector, compositor: SceneCompositor) {\n    this._rect = rect.clone();\n    this._selector = selector;\n    this._batchState = compositor.target.batchState;\n\n    if (Pixel.Selector.None !== (selector & Pixel.Selector.GeometryAndDistance)) {\n      const depthAndOrderBytes = compositor.readDepthAndOrder(rect);\n      if (undefined !== depthAndOrderBytes)\n        this._depthAndOrder = new Uint32Array(depthAndOrderBytes.buffer);\n      else\n        this._selector &= ~Pixel.Selector.GeometryAndDistance;\n    }\n\n    if (Pixel.Selector.None !== (selector & Pixel.Selector.Feature)) {\n      const features = compositor.readFeatureIds(rect);\n      if (undefined !== features)\n        this._featureId = new Uint32Array(features.buffer);\n      else\n        this._selector &= ~Pixel.Selector.Feature;\n    }\n  }\n\n  public get isEmpty(): boolean { return Pixel.Selector.None === this._selector; }\n\n  public static create(rect: ViewRect, selector: Pixel.Selector, compositor: SceneCompositor): Pixel.Buffer | undefined {\n    const pdb = new PixelBuffer(rect, selector, compositor);\n    return pdb.isEmpty ? undefined : pdb;\n  }\n}\n\n/** Orchestrates rendering of the scene on behalf of a Target.\n * This base class exists only so we don't have to export all the types of the shared Compositor members like Textures, FrameBuffers, etc.\n * @internal\n */\nexport abstract class SceneCompositor implements IDisposable {\n  public readonly target: Target;\n\n  public abstract get currentRenderTargetIndex(): number;\n  public abstract set currentRenderTargetIndex(_index: number);\n  public abstract dispose(): void;\n  public abstract draw(_commands: RenderCommands): void;\n  public abstract drawForReadPixels(_commands: RenderCommands, overlays?: GraphicList): void;\n  public abstract readPixels(rect: ViewRect, selector: Pixel.Selector): Pixel.Buffer | undefined;\n  public abstract readDepthAndOrder(rect: ViewRect): Uint8Array | undefined;\n  public abstract readFeatureIds(rect: ViewRect): Uint8Array | undefined;\n\n  public abstract get featureIds(): TextureHandle;\n  public abstract get depthAndOrder(): TextureHandle;\n\n  protected constructor(target: Target) { this.target = target; }\n\n  public static create(target: Target): SceneCompositor {\n    return System.instance.capabilities.supportsDrawBuffers ? new MRTCompositor(target) : new MPCompositor(target);\n  }\n}\n\n// The actual base class. Specializations are provided based on whether or not multiple render targets are supported.\nabstract class Compositor extends SceneCompositor {\n  protected _width: number = -1;\n  protected _height: number = -1;\n  protected _includeOcclusion: boolean = false;\n  protected _textures = new Textures();\n  protected _depth?: DepthBuffer;\n  protected _frameBuffers: FrameBuffers;\n  protected _geom: Geometry;\n  protected _readPickDataFromPingPong: boolean = true;\n  protected _opaqueRenderState = new RenderState();\n  protected _translucentRenderState = new RenderState();\n  protected _noDepthMaskRenderState = new RenderState();\n  protected _stencilSetRenderState = new RenderState();\n  protected _classifyColorRenderState = new RenderState();\n  protected _classifyPickDataRenderState = new RenderState();\n  protected _debugStencilRenderState = new RenderState();\n  protected _debugStencil: number = 0; // 0 to draw stencil volumes normally, 1 to draw as opaque, 2 to draw blended\n\n  public abstract get currentRenderTargetIndex(): number;\n  public abstract set currentRenderTargetIndex(_index: number);\n\n  protected abstract clearOpaque(_needComposite: boolean): void;\n  protected abstract renderOpaque(_commands: RenderCommands, _compositeFlags: CompositeFlags, _renderForReadPixels: boolean): void;\n  protected abstract renderIndexedClassifierForReadPixels(_commands: DrawCommands, index: number, state: RenderState, _needComposite: boolean): void;\n  protected abstract clearTranslucent(): void;\n  protected abstract renderTranslucent(_commands: RenderCommands): void;\n  protected abstract getBackgroundFbo(_needComposite: boolean): FrameBuffer;\n  protected abstract pingPong(): void;\n\n  /** This function generates a texture that contains ambient occlusion information to be applied later. */\n  protected renderAmbientOcclusion() {\n    const system = System.instance;\n\n    // Render unblurred ambient occlusion based on depth buffer\n    let fbo = this._frameBuffers.occlusion!;\n    system.frameBufferStack.execute(fbo, true, () => {\n      System.instance.applyRenderState(RenderState.defaults);\n      const params = getDrawParams(this.target, this._geom.occlusion!);\n      this.target.techniques.draw(params);\n    });\n    this.target.recordPerformanceMetric(\"Compute AO\");\n\n    // Render the X-blurred ambient occlusion based on unblurred ambient occlusion\n    fbo = this._frameBuffers.occlusionBlur!;\n    system.frameBufferStack.execute(fbo, true, () => {\n      System.instance.applyRenderState(RenderState.defaults);\n      const params = getDrawParams(this.target, this._geom.occlusionXBlur!);\n      this.target.techniques.draw(params);\n    });\n    this.target.recordPerformanceMetric(\"Blur AO X\");\n\n    // Render the Y-blurred ambient occlusion based on X-blurred ambient occlusion (render into original occlusion framebuffer)\n    fbo = this._frameBuffers.occlusion!;\n    system.frameBufferStack.execute(fbo, true, () => {\n      System.instance.applyRenderState(RenderState.defaults);\n      const params = getDrawParams(this.target, this._geom.occlusionYBlur!);\n      this.target.techniques.draw(params);\n    });\n    this.target.recordPerformanceMetric(\"Blur AO Y\");\n  }\n\n  protected constructor(target: Target, fbos: FrameBuffers, geometry: Geometry) {\n    super(target);\n\n    this._frameBuffers = fbos;\n    this._geom = geometry;\n\n    this._opaqueRenderState.flags.depthTest = true;\n\n    this._translucentRenderState.flags.depthMask = false;\n    this._translucentRenderState.flags.blend = this._translucentRenderState.flags.depthTest = true;\n    this._translucentRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.One, GL.BlendFactor.Zero, GL.BlendFactor.One, GL.BlendFactor.OneMinusSrcAlpha);\n\n    this._noDepthMaskRenderState.flags.depthMask = false;\n\n    this._stencilSetRenderState.flags.depthTest = true;\n    this._stencilSetRenderState.flags.depthMask = false;\n    this._stencilSetRenderState.flags.colorWrite = false;\n    this._stencilSetRenderState.flags.stencilTest = true;\n    this._stencilSetRenderState.depthFunc = GL.DepthFunc.LessOrEqual;\n    this._stencilSetRenderState.stencil.frontFunction.function = GL.StencilFunction.Always;\n    this._stencilSetRenderState.stencil.frontOperation.zFail = GL.StencilOperation.IncrWrap;\n    this._stencilSetRenderState.stencil.backFunction.function = GL.StencilFunction.Always;\n    this._stencilSetRenderState.stencil.backOperation.zFail = GL.StencilOperation.DecrWrap;\n\n    this._classifyPickDataRenderState.flags.depthTest = false;\n    this._classifyPickDataRenderState.flags.depthMask = false;\n    this._classifyPickDataRenderState.flags.colorWrite = true;\n    this._classifyPickDataRenderState.flags.stencilTest = true;\n    this._classifyPickDataRenderState.flags.cull = true;\n    this._classifyPickDataRenderState.cullFace = GL.CullFace.Front;\n    this._classifyPickDataRenderState.stencil.backFunction.function = GL.StencilFunction.NotEqual;\n    this._classifyPickDataRenderState.stencil.backOperation.zPass = GL.StencilOperation.Zero; // this will clear the stencil\n    // Let all of the operations remain at Keep so that the stencil will remain in tact for the subsequent blend draw to the color buffer.\n\n    this._classifyColorRenderState.flags.depthTest = false;\n    this._classifyColorRenderState.flags.depthMask = false;\n    this._classifyColorRenderState.flags.colorWrite = true;\n    this._classifyColorRenderState.flags.stencilTest = true;\n    this._classifyColorRenderState.stencil.frontFunction.function = GL.StencilFunction.NotEqual;\n    this._classifyColorRenderState.stencil.frontOperation.fail = GL.StencilOperation.Zero;\n    this._classifyColorRenderState.stencil.frontOperation.zFail = GL.StencilOperation.Zero;\n    this._classifyColorRenderState.stencil.frontOperation.zPass = GL.StencilOperation.Zero; // this will clear the stencil\n    this._classifyColorRenderState.stencil.backFunction.function = GL.StencilFunction.NotEqual;\n    this._classifyColorRenderState.stencil.backOperation.fail = GL.StencilOperation.Zero;\n    this._classifyColorRenderState.stencil.backOperation.zFail = GL.StencilOperation.Zero;\n    this._classifyColorRenderState.stencil.backOperation.zPass = GL.StencilOperation.Zero; // this will clear the stencil\n    this._classifyColorRenderState.flags.blend = true; // blend func will be set before using\n\n    if (this._debugStencil > 0) {\n      this._debugStencilRenderState.flags.depthTest = true;\n      this._debugStencilRenderState.flags.blend = true;\n      this._debugStencilRenderState.blend.setBlendFunc(GL.BlendFactor.OneMinusConstColor, GL.BlendFactor.ConstColor);\n      this._debugStencilRenderState.blend.color = [0.67, 0.67, 0.67, 1.0];\n    }\n  }\n\n  public update(): boolean {\n    const rect = this.target.viewRect;\n    const width = rect.width;\n    const height = rect.height;\n    const includeOcclusion = this.target.wantAmbientOcclusion;\n\n    // If not yet initialized, or dimensions changed, initialize.\n    if (undefined === this._textures.accumulation || width !== this._width || height !== this._height) {\n      this._width = width;\n      this._height = height;\n\n      // init() first calls dispose(), which releases all of our fbos, textures, etc, and resets the _includeOcclusion flag.\n      if (!this.init()) {\n        assert(false, \"Failed to initialize scene compositor\");\n        return false;\n      }\n    }\n\n    // Allocate or free ambient occlusion-related resources if necessary\n    if (includeOcclusion !== this._includeOcclusion) {\n      this._includeOcclusion = includeOcclusion;\n      if (includeOcclusion) {\n        if (!this._textures.enableOcclusion(width, height)) {\n          assert(false, \"Failed to initialize occlusion textures\");\n          return false;\n        }\n      } else {\n        this._textures.disableOcclusion();\n      }\n\n      this._frameBuffers.toggleOcclusion(this._textures);\n      this._geom.toggleOcclusion(this._textures);\n    }\n\n    return true;\n  }\n\n  public draw(commands: RenderCommands) {\n    if (!this.update()) {\n      assert(false);\n      return;\n    }\n\n    const compositeFlags = commands.compositeFlags;\n    const needComposite = CompositeFlags.None !== compositeFlags;\n\n    // Clear output targets\n    this.clearOpaque(needComposite);\n\n    // Render the background\n    this.renderBackground(commands, needComposite);\n    this.target.recordPerformanceMetric(\"Render Background\");\n\n    // Render the sky box\n    this.renderSkyBox(commands, needComposite);\n    this.target.recordPerformanceMetric(\"Render SkyBox\");\n\n    // Render the background map graphics\n    this.renderBackgroundMap(commands, needComposite);\n    this.target.recordPerformanceMetric(\"Render BackgroundMap (background map)\");\n\n    // Enable clipping\n    this.target.pushActiveVolume();\n    this.target.recordPerformanceMetric(\"Enable Clipping\");\n\n    // Render opaque geometry\n    this.renderOpaque(commands, compositeFlags, false);\n    this.target.recordPerformanceMetric(\"Render Opaque\");\n\n    // Render stencil volumes\n    this.renderClassification(commands, needComposite, false);\n    this.target.recordPerformanceMetric(\"Render Stencils\");\n\n    if (needComposite) {\n      this._geom.composite!.update(compositeFlags);\n      this.clearTranslucent();\n      this.renderTranslucent(commands);\n      this.target.recordPerformanceMetric(\"Render Translucent\");\n      this.renderHilite(commands);\n      this.target.recordPerformanceMetric(\"Render Hilite\");\n      this.composite();\n      this.target.recordPerformanceMetric(\"Composite\");\n    }\n    this.target.popActiveVolume();\n  }\n\n  public get fullHeight(): number { return this.target.viewRect.height; }\n\n  public drawForReadPixels(commands: RenderCommands, overlays?: GraphicList) {\n    if (!this.update()) {\n      assert(false);\n      return;\n    }\n\n    this.clearOpaque(false);\n    this.target.recordPerformanceMetric(\"Render Background\");\n\n    // On entry the RenderCommands has been initialized for all scene graphics and pickable decorations with the exception of world overlays.\n    // It's possible we have no pickable scene graphics or decorations, but do have pickable world overlays.\n    const haveRenderCommands = !commands.isEmpty;\n    if (haveRenderCommands) {\n      this.target.pushActiveVolume();\n      this.target.recordPerformanceMetric(\"Enable Clipping\");\n      this.renderOpaque(commands, CompositeFlags.None, true);\n      this.target.recordPerformanceMetric(\"Render Opaque\");\n      this.renderClassification(commands, false, true);\n      this.target.recordPerformanceMetric(\"Render Stencils\");\n      this.target.popActiveVolume();\n    }\n\n    if (undefined === overlays || 0 === overlays.length)\n      return;\n\n    // Now populate the opaque passes with any pickable world overlays\n    commands.initForPickOverlays(overlays);\n    if (commands.isEmpty)\n      return;\n\n    // Clear the depth buffer so that overlay decorations win the depth test.\n    // (If *only* overlays exist, then clearOpaque() above already took care of this).\n    if (haveRenderCommands) {\n      const system = System.instance;\n      system.frameBufferStack.execute(this._frameBuffers.opaqueColor!, true, () => {\n        system.applyRenderState(RenderState.defaults);\n        system.context.clearDepth(1.0);\n        system.context.clear(GL.BufferBit.Depth);\n      });\n    }\n\n    // Render overlays as opaque into the pick buffers\n    this.renderOpaque(commands, CompositeFlags.None, true);\n    this.target.recordPerformanceMetric(\"Overlay Draws\");\n  }\n\n  public readPixels(rect: ViewRect, selector: Pixel.Selector): Pixel.Buffer | undefined {\n    return PixelBuffer.create(rect, selector, this);\n  }\n\n  public readDepthAndOrder(rect: ViewRect): Uint8Array | undefined { return this.readFrameBuffer(rect, this._frameBuffers.depthAndOrder); }\n\n  public readFeatureIds(rect: ViewRect): Uint8Array | undefined {\n    const tex = this._textures.featureId;\n    if (undefined === tex)\n      return undefined;\n\n    const fbo = FrameBuffer.create([tex]);\n    const result = this.readFrameBuffer(rect, fbo);\n\n    dispose(fbo);\n\n    return result;\n  }\n\n  private readFrameBuffer(rect: ViewRect, fbo?: FrameBuffer): Uint8Array | undefined {\n    if (undefined === fbo || !Debug.isValidFrameBuffer)\n      return undefined;\n\n    // NB: ViewRect origin at top-left; GL origin at bottom-left\n    const bottom = this.fullHeight - rect.bottom;\n    const gl = System.instance.context;\n    const bytes = new Uint8Array(rect.width * rect.height * 4);\n    let result: Uint8Array | undefined = bytes;\n    System.instance.frameBufferStack.execute(fbo, true, () => {\n      try {\n        gl.readPixels(rect.left, bottom, rect.width, rect.height, gl.RGBA, gl.UNSIGNED_BYTE, bytes);\n      } catch (e) {\n        result = undefined;\n      }\n    });\n\n    return result;\n  }\n\n  public dispose() {\n    this._depth = dispose(this._depth);\n    this._includeOcclusion = false;\n    dispose(this._textures);\n    dispose(this._frameBuffers);\n    dispose(this._geom);\n  }\n\n  private init(): boolean {\n    this.dispose();\n    this._depth = System.instance.createDepthBuffer(this._width, this._height);\n    if (this._depth !== undefined) {\n      return this._textures.init(this._width, this._height)\n        && this._frameBuffers.init(this._textures, this._depth)\n        && this._geom.init(this._textures);\n    }\n    return false;\n  }\n\n  private renderBackgroundMap(commands: RenderCommands, needComposite: boolean) {\n    const cmds = commands.getCommands(RenderPass.BackgroundMap);\n    if (0 === cmds.length) {\n      return;\n    }\n\n    this.target.plan!.selectExpandedFrustum();\n    this.target.changeFrustum(this.target.plan!.frustum, this.target.plan!.fraction, this.target.plan!.is3d);\n\n    const fbStack = System.instance.frameBufferStack;\n    const fbo = this.getBackgroundFbo(needComposite);\n    fbStack.execute(fbo, true, () => {\n      System.instance.applyRenderState(this.getRenderState(RenderPass.BackgroundMap));\n      this.target.techniques.execute(this.target, cmds, RenderPass.BackgroundMap);\n    });\n\n    this.target.plan!.selectViewFrustum();\n    this.target.changeFrustum(this.target.plan!.frustum, this.target.plan!.fraction, this.target.plan!.is3d);\n  }\n\n  private renderSkyBox(commands: RenderCommands, needComposite: boolean) {\n    const cmds = commands.getCommands(RenderPass.SkyBox);\n    if (0 === cmds.length) {\n      return;\n    }\n\n    const fbStack = System.instance.frameBufferStack;\n    const fbo = this.getBackgroundFbo(needComposite);\n    fbStack.execute(fbo, true, () => {\n      this.target.pushState(this.target.decorationState);\n      System.instance.applyRenderState(this.getRenderState(RenderPass.SkyBox));\n      this.target.techniques.execute(this.target, cmds, RenderPass.SkyBox);\n      this.target.popBranch();\n    });\n  }\n\n  private renderBackground(commands: RenderCommands, needComposite: boolean) {\n    const cmds = commands.getCommands(RenderPass.Background);\n    if (0 === cmds.length) {\n      return;\n    }\n\n    const fbStack = System.instance.frameBufferStack;\n    const fbo = this.getBackgroundFbo(needComposite);\n    fbStack.execute(fbo, true, () => {\n      this.target.pushState(this.target.decorationState);\n      System.instance.applyRenderState(this.getRenderState(RenderPass.Background));\n      this.target.techniques.execute(this.target, cmds, RenderPass.Background);\n      this.target.popBranch();\n    });\n  }\n\n  private findFlashedClassifier(cmdsByIndex: DrawCommands): number {\n    if (!Id64.isValid(this.target.flashedId))\n      return -1; // nothing flashed\n\n    for (let i = 1; i < cmdsByIndex.length; i += 3) {\n      const command = cmdsByIndex[i];\n      if (command.isPrimitiveCommand) {\n        if (command instanceof BatchPrimitiveCommand) {\n          const batch = command as BatchPrimitiveCommand;\n          if (batch.computeIsFlashed(this.target.flashedId)) {\n            return (i - 1) / 3;\n          }\n        }\n      }\n    }\n\n    return -1; // couldn't find it\n  }\n\n  private renderIndexedClassifier(cmdsByIndex: DrawCommands, index: number, needComposite: boolean) {\n    // Set the stencil for the given classifier stencil volume.\n    System.instance.frameBufferStack.execute(this._frameBuffers.stencilSet!, false, () => {\n      this.target.pushState(this.target.decorationState);\n      System.instance.applyRenderState(this._stencilSetRenderState);\n      this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, RenderPass.Classification, index);\n      this.target.popBranch();\n    });\n\n    // Process the stencil for the pick data.\n    this.renderIndexedClassifierForReadPixels(cmdsByIndex, index, this._classifyPickDataRenderState, needComposite);\n  }\n\n  private renderClassification(commands: RenderCommands, needComposite: boolean, renderForReadPixels: boolean) {\n    const cmds = commands.getCommands(RenderPass.Classification);\n    const cmdsByIndex = commands.getCommands(RenderPass.ClassificationByIndex);\n    if (0 === cmds.length || 0 === cmdsByIndex.length)\n      return;\n\n    if (this._debugStencil > 0) {\n      System.instance.frameBufferStack.execute(this.getBackgroundFbo(needComposite), true, () => {\n        if (1 === this._debugStencil) {\n          System.instance.applyRenderState(this.getRenderState(RenderPass.OpaqueGeneral));\n          this.target.techniques.execute(this.target, cmds, RenderPass.OpaqueGeneral);\n        } else {\n          this.target.pushState(this.target.decorationState);\n          System.instance.applyRenderState(this._debugStencilRenderState);\n          this.target.techniques.execute(this.target, cmds, RenderPass.Classification);\n          this.target.popBranch();\n        }\n      });\n\n      return;\n    }\n\n    const fbStack = System.instance.frameBufferStack;\n    const fboSet = this._frameBuffers.stencilSet;\n    const fboCopy = this.getBackgroundFbo(needComposite);\n    if (undefined === fboSet || undefined === fboCopy)\n      return;\n\n    // Clear the stencil.\n    fbStack.execute(fboSet!, false, () => {\n      System.instance.context.clearStencil(0);\n      System.instance.context.clear(GL.BufferBit.Stencil);\n    });\n\n    if (renderForReadPixels) {\n      // We need to render the classifier stencil volumes one at a time, so first count them then render them in a loop.\n      const numClassifiers = cmdsByIndex.length / 3;\n      for (let i = 0; i < numClassifiers; ++i)\n        this.renderIndexedClassifier(cmdsByIndex, i, needComposite);\n\n      return;\n    }\n\n    const flashedClassifier = this.findFlashedClassifier(cmdsByIndex);\n\n    // Process the selected classifiers.\n    const cmdsH = commands.getCommands(RenderPass.HiliteClassification);\n    if (cmds.length > 0) {\n      // Set the stencil for the given classifier stencil volume.\n      fbStack.execute(fboSet, false, () => {\n        this.target.pushState(this.target.decorationState);\n        System.instance.applyRenderState(this._stencilSetRenderState);\n        this.target.techniques.execute(this.target, cmdsH, RenderPass.Hilite);\n        this.target.popBranch();\n      });\n\n      // Process the stencil volumes, blending into the current color buffer.\n      fbStack.execute(fboCopy!, true, () => {\n        this.target.pushState(this.target.decorationState);\n        this._classifyColorRenderState.blend.color = [1.0, 1.0, 1.0, 0.2];\n        this._classifyColorRenderState.blend.setBlendFunc(GL.BlendFactor.ConstAlpha, GL.BlendFactor.OneMinusConstAlpha); // Mix with select/hilite color\n        System.instance.applyRenderState(this._classifyColorRenderState);\n        const params = getDrawParams(this.target, this._geom.stencilCopy!);\n        this.target.techniques.draw(params);\n        this.target.popBranch();\n      });\n    }\n\n    // Process the flashed classifier if there is one.\n    if (flashedClassifier !== -1) {\n      // Set the stencil for this one classifier.\n      fbStack.execute(this._frameBuffers.stencilSet!, false, () => {\n        this.target.pushState(this.target.decorationState);\n        System.instance.applyRenderState(this._stencilSetRenderState);\n        this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, RenderPass.Classification, flashedClassifier);\n        this.target.popBranch();\n      });\n\n      // Process the stencil.\n      fbStack.execute(fboCopy!, true, () => {\n        this.target.pushState(this.target.decorationState);\n        this._classifyColorRenderState.blend.color = [1.0, 1.0, 1.0, this.target.flashIntensity * 0.5];\n        this._classifyColorRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.ConstAlpha, GL.BlendFactor.ConstAlpha, GL.BlendFactor.One, GL.BlendFactor.OneMinusConstAlpha); // want to just add flash color\n        System.instance.applyRenderState(this._classifyColorRenderState);\n        this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, RenderPass.OpaquePlanar, flashedClassifier);\n        this.target.popBranch();\n      });\n    }\n\n    // Process the area outside the classifiers.\n    // ###TODO: Need a way to only do this to reality mesh and point cloud data\n    // Set the stencil using the stencil command list.\n    fbStack.execute(fboSet!, false, () => {\n      this.target.pushState(this.target.decorationState);\n      System.instance.applyRenderState(this._stencilSetRenderState);\n      this.target.techniques.execute(this.target, cmds, RenderPass.Classification);\n      this.target.popBranch();\n    });\n\n    // Process the stencil volumes, blending into the current color buffer.\n    fbStack.execute(fboCopy!, true, () => {\n      this.target.pushState(this.target.decorationState);\n      this._classifyColorRenderState.stencil.frontFunction.function = GL.StencilFunction.Equal;\n      this._classifyColorRenderState.stencil.backFunction.function = GL.StencilFunction.Equal;\n      this._classifyColorRenderState.blend.color = [1.0, 1.0, 1.0, 0.4];\n      this._classifyColorRenderState.blend.setBlendFuncSeparate(GL.BlendFactor.Zero, GL.BlendFactor.Zero, GL.BlendFactor.ConstAlpha, GL.BlendFactor.One); // want to just darken dest. color\n      System.instance.applyRenderState(this._classifyColorRenderState);\n      this._classifyColorRenderState.stencil.frontFunction.function = GL.StencilFunction.NotEqual;\n      this._classifyColorRenderState.stencil.backFunction.function = GL.StencilFunction.NotEqual;\n      const params = getDrawParams(this.target, this._geom.stencilCopy!);\n      this.target.techniques.draw(params);\n      this.target.popBranch();\n    });\n  }\n\n  private renderHilite(commands: RenderCommands) {\n    const system = System.instance;\n    system.frameBufferStack.execute(this._frameBuffers.hilite!, true, () => {\n      // Clear the hilite buffer.\n      system.context.clearColor(0, 0, 0, 0);\n      system.context.clear(GL.BufferBit.Color);\n      // Draw the normal hilite geometry.\n      this.drawPass(commands, RenderPass.Hilite);\n    });\n\n    // Process planar classifiers\n    const planarClassifierCmds = commands.getCommands(RenderPass.HilitePlanarClassification);\n    if (0 !== planarClassifierCmds.length) {\n      system.frameBufferStack.execute(this._frameBuffers.hiliteUsingStencil!, true, () => {\n        system.applyRenderState(this._opaqueRenderState);\n        system.context.clearDepth(1.0);\n        system.context.clear(GL.BufferBit.Depth);\n        system.context.clearColor(0, 0, 0, 0);\n        system.context.clear(GL.BufferBit.Color);\n        this.target.techniques.execute(this.target, planarClassifierCmds, RenderPass.HilitePlanarClassification);\n      });\n    }\n\n    // Process the hilite stencil volumes.\n    const cmds = commands.getCommands(RenderPass.HiliteClassification);\n    if (0 === cmds.length) {\n      return;\n    }\n    // Set the stencil for the given classifier stencil volume.\n    system.frameBufferStack.execute(this._frameBuffers.stencilSet!, false, () => {\n      this.target.pushState(this.target.decorationState);\n      system.applyRenderState(this._stencilSetRenderState);\n      this.target.techniques.execute(this.target, cmds, RenderPass.Hilite);\n      this.target.popBranch();\n    });\n\n    // Process the stencil for the hilite data.\n    system.frameBufferStack.execute(this._frameBuffers.hiliteUsingStencil!, true, () => {\n      system.applyRenderState(this._classifyPickDataRenderState);\n      this.target.techniques.execute(this.target, cmds, RenderPass.Hilite);\n    });\n  }\n\n  private composite() {\n    System.instance.applyRenderState(RenderState.defaults);\n    const params = getDrawParams(this.target, this._geom.composite!);\n    this.target.techniques.draw(params);\n  }\n\n  protected getRenderState(pass: RenderPass): RenderState {\n    switch (pass) {\n      case RenderPass.OpaqueLinear:\n      case RenderPass.OpaquePlanar:\n      case RenderPass.OpaqueGeneral:\n      case RenderPass.HilitePlanarClassification:\n        return this._opaqueRenderState;\n      case RenderPass.Translucent:\n        return this._translucentRenderState;\n      default:\n        return this._noDepthMaskRenderState;\n    }\n  }\n\n  protected drawPass(commands: RenderCommands, pass: RenderPass, pingPong: boolean = false) {\n    const cmds = commands.getCommands(pass);\n    if (0 === cmds.length) {\n      return;\n    } else if (pingPong) {\n      this.pingPong();\n    }\n\n    System.instance.applyRenderState(this.getRenderState(pass));\n    this.target.techniques.execute(this.target, cmds, pass);\n  }\n}\n\nclass MRTFrameBuffers extends FrameBuffers {\n  public opaqueAll?: FrameBuffer;\n  public opaqueAndCompositeAll?: FrameBuffer;\n  public pingPong?: FrameBuffer;\n  public translucent?: FrameBuffer;\n  public clearTranslucent?: FrameBuffer;\n  public idOnly?: FrameBuffer;\n  public idOnlyAndComposite?: FrameBuffer;\n\n  public init(textures: Textures, depth: DepthBuffer): boolean {\n    if (!super.init(textures, depth))\n      return false;\n\n    assert(undefined === this.opaqueAll);\n\n    const boundColor = System.instance.frameBufferStack.currentColorBuffer;\n    if (undefined === boundColor)\n      return false;\n\n    const colorAndPick = [boundColor, textures.featureId!, textures.depthAndOrder!];\n    this.opaqueAll = FrameBuffer.create(colorAndPick, depth);\n\n    colorAndPick[0] = textures.color!;\n    this.opaqueAndCompositeAll = FrameBuffer.create(colorAndPick, depth);\n\n    const colors = [textures.accumulation!, textures.revealage!];\n    this.translucent = FrameBuffer.create(colors, depth);\n    this.clearTranslucent = FrameBuffer.create(colors);\n\n    // We borrow the SceneCompositor's accum and revealage textures for the surface pass.\n    // First we render edges, writing to our textures.\n    // Then we copy our textures to borrowed textures.\n    // Finally we render surfaces, writing to our textures and reading from borrowed textures.\n    const pingPong = [textures.accumulation!, textures.revealage!];\n    this.pingPong = FrameBuffer.create(pingPong);\n\n    const ids = [boundColor, textures.featureId!];\n    this.idOnly = FrameBuffer.create(ids, depth);\n    colorAndPick[0] = textures.color!;\n    this.idOnlyAndComposite = FrameBuffer.create(ids, depth);\n\n    return undefined !== this.opaqueAll\n      && undefined !== this.opaqueAndCompositeAll\n      && undefined !== this.pingPong\n      && undefined !== this.translucent\n      && undefined !== this.clearTranslucent\n      && undefined !== this.idOnly\n      && undefined !== this.idOnlyAndComposite;\n  }\n\n  public dispose(): void {\n    super.dispose();\n\n    this.opaqueAll = dispose(this.opaqueAll);\n    this.opaqueAndCompositeAll = dispose(this.opaqueAndCompositeAll);\n    this.pingPong = dispose(this.pingPong);\n    this.translucent = dispose(this.translucent);\n    this.clearTranslucent = dispose(this.clearTranslucent);\n    this.idOnly = dispose(this.idOnly);\n    this.idOnlyAndComposite = dispose(this.idOnlyAndComposite);\n  }\n}\n\nclass MRTGeometry extends Geometry {\n  public copyPickBuffers?: CopyPickBufferGeometry;\n  public clearTranslucent?: ViewportQuadGeometry;\n  public clearPickAndColor?: ViewportQuadGeometry;\n\n  public init(textures: Textures): boolean {\n    if (!super.init(textures))\n      return false;\n\n    assert(undefined === this.copyPickBuffers);\n\n    this.copyPickBuffers = CopyPickBufferGeometry.createGeometry(textures.featureId!.getHandle()!, textures.depthAndOrder!.getHandle()!);\n    this.clearTranslucent = ViewportQuadGeometry.create(TechniqueId.OITClearTranslucent);\n    this.clearPickAndColor = ViewportQuadGeometry.create(TechniqueId.ClearPickAndColor);\n\n    return undefined !== this.copyPickBuffers && undefined !== this.clearTranslucent && undefined !== this.clearPickAndColor;\n  }\n\n  public dispose() {\n    super.dispose();\n\n    this.copyPickBuffers = dispose(this.copyPickBuffers);\n    this.clearTranslucent = dispose(this.clearTranslucent);\n    this.clearPickAndColor = dispose(this.clearPickAndColor);\n  }\n}\n\n// SceneCompositor used when multiple render targets are supported (WEBGL_draw_buffers exists and supports at least 4 color attachments).\nclass MRTCompositor extends Compositor {\n  public constructor(target: Target) {\n    super(target, new MRTFrameBuffers(), new MRTGeometry());\n  }\n\n  public get currentRenderTargetIndex(): number {\n    assert(false, \"MRT is supported\");\n    return 0;\n  }\n  public set currentRenderTargetIndex(_index: number) {\n    assert(false, \"MRT is supported\");\n  }\n\n  public get featureIds(): TextureHandle { return this.getSamplerTexture(this._readPickDataFromPingPong ? 0 : 1); }\n  public get depthAndOrder(): TextureHandle { return this.getSamplerTexture(this._readPickDataFromPingPong ? 1 : 2); }\n\n  private get _fbos(): MRTFrameBuffers { return this._frameBuffers as MRTFrameBuffers; }\n  private get _geometry(): MRTGeometry { return this._geom as MRTGeometry; }\n\n  protected clearOpaque(needComposite: boolean): void {\n    const fbo = needComposite ? this._fbos.opaqueAndCompositeAll! : this._fbos.opaqueAll!;\n    const system = System.instance;\n    system.frameBufferStack.execute(fbo, true, () => {\n      // Clear pick data buffers to 0's and color buffer to background color\n      // (0,0,0,0) in elementID0 and ElementID1 buffers indicates invalid element id\n      // (0,0,0,0) in DepthAndOrder buffer indicates render order 0 and encoded depth of 0 (= far plane)\n      system.applyRenderState(this._noDepthMaskRenderState);\n      const params = getDrawParams(this.target, this._geometry.clearPickAndColor!);\n      this.target.techniques.draw(params);\n\n      // Clear depth buffer\n      system.applyRenderState(RenderState.defaults); // depthMask == true.\n      system.context.clearDepth(1.0);\n      system.context.clear(GL.BufferBit.Depth);\n    });\n  }\n\n  protected renderOpaque(commands: RenderCommands, compositeFlags: CompositeFlags, renderForReadPixels: boolean) {\n    // Output the first 2 passes to color and pick data buffers. (All 3 in the case of rendering for readPixels()).\n    this._readPickDataFromPingPong = true;\n\n    const needComposite = CompositeFlags.None !== compositeFlags;\n    const needAO = CompositeFlags.None !== (compositeFlags & CompositeFlags.AmbientOcclusion);\n\n    let fbStack = System.instance.frameBufferStack;\n    fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeAll! : this._fbos.opaqueAll!, true, () => {\n      this.drawPass(commands, RenderPass.OpaqueLinear);\n      this.drawPass(commands, RenderPass.OpaquePlanar, true);\n      if (needAO || renderForReadPixels) {\n        this.drawPass(commands, RenderPass.OpaqueGeneral, true);\n        if (needAO)\n          this.renderAmbientOcclusion();\n      }\n    });\n\n    this._readPickDataFromPingPong = false;\n\n    // The general pass (and following) will not bother to write to pick buffers and so can read from the actual pick buffers.\n    if (!renderForReadPixels && !needAO) {\n      fbStack = System.instance.frameBufferStack;\n      fbStack.execute(needComposite ? this._fbos.opaqueAndCompositeColor! : this._fbos.opaqueColor!, true, () => {\n        this.drawPass(commands, RenderPass.OpaqueGeneral, false);\n        this.drawPass(commands, RenderPass.HiddenEdge, false);\n      });\n    }\n  }\n\n  protected renderIndexedClassifierForReadPixels(cmdsByIndex: DrawCommands, index: number, state: RenderState, needComposite: boolean) {\n    this._readPickDataFromPingPong = true;\n    const fbStack = System.instance.frameBufferStack;\n    fbStack.execute(needComposite ? this._fbos.idOnlyAndComposite! : this._fbos.idOnly!, true, () => {\n      System.instance.applyRenderState(state);\n      this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, RenderPass.OpaqueGeneral, index);\n    });\n    this._readPickDataFromPingPong = false;\n  }\n\n  protected clearTranslucent() {\n    System.instance.applyRenderState(this._noDepthMaskRenderState);\n    System.instance.frameBufferStack.execute(this._fbos.clearTranslucent!, true, () => {\n      const params = getDrawParams(this.target, this._geometry.clearTranslucent!);\n      this.target.techniques.draw(params);\n    });\n  }\n\n  protected renderTranslucent(commands: RenderCommands) {\n    System.instance.frameBufferStack.execute(this._fbos.translucent!, true, () => {\n      this.drawPass(commands, RenderPass.Translucent);\n    });\n  }\n\n  protected pingPong() {\n    System.instance.applyRenderState(this._noDepthMaskRenderState);\n    System.instance.frameBufferStack.execute(this._fbos.pingPong!, true, () => {\n      const params = getDrawParams(this.target, this._geometry.copyPickBuffers!);\n      this.target.techniques.draw(params);\n    });\n  }\n\n  protected getBackgroundFbo(needComposite: boolean): FrameBuffer { return needComposite ? this._fbos.opaqueAndCompositeColor! : this._fbos.opaqueColor!; }\n\n  private get _samplerFbo(): FrameBuffer { return this._readPickDataFromPingPong ? this._fbos.pingPong! : this._fbos.opaqueAll!; }\n  private getSamplerTexture(index: number) { return this._samplerFbo.getColor(index); }\n}\n\nclass MPFrameBuffers extends FrameBuffers {\n  public accumulation?: FrameBuffer;\n  public revealage?: FrameBuffer;\n  public featureId?: FrameBuffer;\n  public featureIdWithDepth?: FrameBuffer;\n\n  public init(textures: Textures, depth: DepthBuffer): boolean {\n    if (!super.init(textures, depth))\n      return false;\n\n    assert(undefined === this.accumulation);\n\n    this.accumulation = FrameBuffer.create([textures.accumulation!], depth);\n    this.revealage = FrameBuffer.create([textures.revealage!], depth);\n    this.featureId = FrameBuffer.create([textures.featureId!], depth);\n    this.featureIdWithDepth = FrameBuffer.create([textures.featureId!], depth);\n\n    return undefined !== this.accumulation && undefined !== this.revealage && undefined !== this.featureId && undefined !== this.featureIdWithDepth;\n  }\n\n  public dispose(): void {\n    super.dispose();\n\n    this.accumulation = dispose(this.accumulation);\n    this.revealage = dispose(this.revealage);\n    this.featureId = dispose(this.featureId);\n    this.featureIdWithDepth = dispose(this.featureIdWithDepth);\n  }\n}\n\nclass MPGeometry extends Geometry {\n  public copyColor?: SingleTexturedViewportQuadGeometry;\n\n  public init(textures: Textures): boolean {\n    if (!super.init(textures))\n      return false;\n\n    assert(undefined === this.copyColor);\n    this.copyColor = SingleTexturedViewportQuadGeometry.createGeometry(textures.featureId!.getHandle()!, TechniqueId.CopyColor);\n    return undefined !== this.copyColor;\n  }\n\n  public dispose(): void {\n    super.dispose();\n    this.copyColor = dispose(this.copyColor);\n  }\n}\n\n// Compositor used when multiple render targets are not supported (WEBGL_draw_buffers not available or fewer than 4 color attachments supported).\n// This falls back to multi-pass rendering in place of MRT rendering, which has obvious performance implications.\n// The chief use case is iOS.\nclass MPCompositor extends Compositor {\n  private _currentRenderTargetIndex: number = 0;\n  private _drawMultiPassDepth: boolean = true;\n  private readonly _opaqueRenderStateNoZWt = new RenderState();\n\n  public constructor(target: Target) {\n    super(target, new MPFrameBuffers(), new MPGeometry());\n\n    this._opaqueRenderStateNoZWt.flags.depthTest = true;\n    this._opaqueRenderStateNoZWt.flags.depthMask = false;\n  }\n\n  protected getRenderState(pass: RenderPass): RenderState {\n    switch (pass) {\n      case RenderPass.OpaqueLinear:\n      case RenderPass.OpaquePlanar:\n      case RenderPass.OpaqueGeneral:\n        return this._drawMultiPassDepth ? this._opaqueRenderState : this._opaqueRenderStateNoZWt;\n    }\n\n    return super.getRenderState(pass);\n  }\n\n  private get _fbos(): MPFrameBuffers { return this._frameBuffers as MPFrameBuffers; }\n  private get _geometry(): MPGeometry { return this._geom as MPGeometry; }\n\n  public get currentRenderTargetIndex(): number { return this._currentRenderTargetIndex; }\n  public set currentRenderTargetIndex(index: number) { this._currentRenderTargetIndex = index; }\n  public get featureIds(): TextureHandle { return this._readPickDataFromPingPong ? this._textures.accumulation! : this._textures.featureId!; }\n  public get depthAndOrder(): TextureHandle { return this._readPickDataFromPingPong ? this._textures.revealage! : this._textures.depthAndOrder!; }\n\n  protected getBackgroundFbo(needComposite: boolean): FrameBuffer { return needComposite ? this._fbos.opaqueAndCompositeColor! : this._fbos.opaqueColor!; }\n\n  protected clearOpaque(needComposite: boolean): void {\n    const bg = this.target.bgColor;\n    this.clearFbo(needComposite ? this._fbos.opaqueAndCompositeColor! : this._fbos.opaqueColor!, bg.red, bg.green, bg.blue, bg.alpha, true);\n    this.clearFbo(this._fbos.depthAndOrder!, 0, 0, 0, 0, false);\n    this.clearFbo(this._fbos.featureId!, 0, 0, 0, 0, false);\n  }\n\n  protected renderOpaque(commands: RenderCommands, compositeFlags: CompositeFlags, renderForReadPixels: boolean): void {\n    // Output the first 2 passes to color and pick data buffers. (All 3 in the case of rendering for readPixels()).\n    this._readPickDataFromPingPong = true;\n    const needComposite = CompositeFlags.None !== compositeFlags;\n    const needAO = CompositeFlags.None !== (compositeFlags & CompositeFlags.AmbientOcclusion);\n    const colorFbo = needComposite ? this._fbos.opaqueAndCompositeColor! : this._fbos.opaqueColor!;\n    this.drawOpaquePass(colorFbo, commands, RenderPass.OpaqueLinear, false);\n    this.drawOpaquePass(colorFbo, commands, RenderPass.OpaquePlanar, true);\n    if (renderForReadPixels || needAO) {\n      this.drawOpaquePass(colorFbo, commands, RenderPass.OpaqueGeneral, true);\n      if (needAO)\n        this.renderAmbientOcclusion();\n    }\n\n    this._readPickDataFromPingPong = false;\n\n    // The general pass (and following) will not bother to write to pick buffers and so can read from the actual pick buffers.\n    if (!renderForReadPixels && !needAO) {\n      System.instance.frameBufferStack.execute(colorFbo, true, () => {\n        this._drawMultiPassDepth = true;  // for OpaqueGeneral\n        this.drawPass(commands, RenderPass.OpaqueGeneral, false);\n        this.drawPass(commands, RenderPass.HiddenEdge, false);\n      });\n    }\n  }\n\n  protected renderIndexedClassifierForReadPixels(cmdsByIndex: DrawCommands, index: number, state: RenderState, _needComposite: boolean) {\n    // Note that we only need to render to the Id textures here, no color, since the color buffer is not used in readPixels.\n    this._readPickDataFromPingPong = true;\n    const stack = System.instance.frameBufferStack;\n    this._currentRenderTargetIndex = 1;\n    stack.execute(this._fbos.featureIdWithDepth!, true, () => {\n      state.stencil.backOperation.zPass = GL.StencilOperation.Zero;\n      System.instance.applyRenderState(state);\n      this.target.techniques.executeForIndexedClassifier(this.target, cmdsByIndex, RenderPass.OpaqueGeneral, index);\n    });\n    this._currentRenderTargetIndex = 0;\n    this._readPickDataFromPingPong = false;\n  }\n\n  // ###TODO: For readPixels(), could skip rendering color...also could skip rendering depth and/or element ID depending upon selector...\n  private drawOpaquePass(colorFbo: FrameBuffer, commands: RenderCommands, pass: RenderPass, pingPong: boolean): void {\n    const stack = System.instance.frameBufferStack;\n    this._drawMultiPassDepth = true;\n    if (!this.target.isReadPixelsInProgress) {\n      stack.execute(colorFbo, true, () => this.drawPass(commands, pass, pingPong));\n      this._drawMultiPassDepth = false;\n    }\n    this._currentRenderTargetIndex++;\n    if (!this.target.isReadPixelsInProgress || Pixel.Selector.None !== (this.target.readPixelsSelector & Pixel.Selector.Feature)) {\n      stack.execute(this._fbos.featureId!, true, () => this.drawPass(commands, pass, pingPong && this._drawMultiPassDepth));\n      this._drawMultiPassDepth = false;\n    }\n    this._currentRenderTargetIndex++;\n    if (!this.target.isReadPixelsInProgress || Pixel.Selector.None !== (this.target.readPixelsSelector & Pixel.Selector.GeometryAndDistance)) {\n      stack.execute(this._fbos.depthAndOrder!, true, () => this.drawPass(commands, pass, pingPong && this._drawMultiPassDepth));\n    }\n    this._currentRenderTargetIndex = 0;\n  }\n\n  protected clearTranslucent() {\n    this.clearFbo(this._fbos.accumulation!, 0, 0, 0, 1, false);\n    this.clearFbo(this._fbos.revealage!, 1, 0, 0, 1, false);\n  }\n\n  protected renderTranslucent(commands: RenderCommands) {\n    System.instance.frameBufferStack.execute(this._fbos.accumulation!, true, () => {\n      this.drawPass(commands, RenderPass.Translucent);\n    });\n\n    this._currentRenderTargetIndex = 1;\n    System.instance.frameBufferStack.execute(this._fbos.revealage!, true, () => {\n      this.drawPass(commands, RenderPass.Translucent);\n    });\n\n    this._currentRenderTargetIndex = 0;\n  }\n\n  protected pingPong() {\n    System.instance.applyRenderState(this._noDepthMaskRenderState);\n\n    this.copyFbo(this._textures.featureId!, this._fbos.accumulation!);\n    this.copyFbo(this._textures.depthAndOrder!, this._fbos.revealage!);\n  }\n\n  private copyFbo(src: TextureHandle, dst: FrameBuffer): void {\n    const geom = this._geometry.copyColor!;\n    geom.texture = src.getHandle()!;\n    System.instance.frameBufferStack.execute(dst, true, () => {\n      const params = getDrawParams(this.target, geom);\n      this.target.techniques.draw(params);\n    });\n  }\n\n  private clearFbo(fbo: FrameBuffer, red: number, green: number, blue: number, alpha: number, andDepth: boolean): void {\n    const system = System.instance;\n    const gl = system.context;\n    system.frameBufferStack.execute(fbo, true, () => {\n      system.applyRenderState(andDepth ? RenderState.defaults : this._noDepthMaskRenderState);\n      gl.clearColor(red, green, blue, alpha);\n      let bit = GL.BufferBit.Color;\n      if (andDepth) {\n        gl.clearDepth(1.0);\n        bit |= GL.BufferBit.Depth;\n      }\n\n      gl.clear(bit);\n    });\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { ClippingType } from \"../System\";\nimport { ShaderProgram } from \"./ShaderProgram\";\nimport { System } from \"./System\";\nimport { ClipDef } from \"./TechniqueFlags\";\nimport { GLSLVertex, addPosition } from \"./glsl/Vertex\";\nimport { addInstancedModelMatrixRTC } from \"./glsl/Instancing\";\nimport { addClipping } from \"./glsl/Clipping\";\n\n// tslint:disable:no-const-enum\n\n/** Describes the data type of a shader program variable.\n * @internal\n */\nexport const enum VariableType {\n  Boolean, // bool\n  Int, // int\n  Float, // float\n  Vec2, // vec2\n  Vec3, // vec3\n  Vec4, // vec4\n  Mat3, // mat3\n  Mat4, // mat4\n  Sampler2D, // sampler2D\n  SamplerCube, // samplerCube\n\n  COUNT,\n}\n\n/** Describes the qualifier associated with a shader program variable.\n * @internal\n */\nexport const enum VariableScope {\n  Global, // no qualifier\n  Varying, // varying\n  Uniform, // uniform\n  Attribute, // attribute\n\n  COUNT,\n}\n\n/** Describes the declared or undeclared precision of a shader program variable.\n * @internal\n */\nexport const enum VariablePrecision {\n  Default, // undeclared precision - variable uses the explicit or implicit precision default for its type\n  Low, // lowp\n  Medium, // mediump\n  High, // highp\n\n  COUNT,\n}\n\n/** @internal */\nnamespace Convert {\n  export function typeToString(type: VariableType): string {\n    switch (type) {\n      case VariableType.Boolean: return \"bool\";\n      case VariableType.Int: return \"int\";\n      case VariableType.Float: return \"float\";\n      case VariableType.Vec2: return \"vec2\";\n      case VariableType.Vec3: return \"vec3\";\n      case VariableType.Vec4: return \"vec4\";\n      case VariableType.Mat3: return \"mat3\";\n      case VariableType.Mat4: return \"mat4\";\n      case VariableType.Sampler2D: return \"sampler2D\";\n      case VariableType.SamplerCube: return \"samplerCube\";\n      default: assert(false); return \"undefined\";\n    }\n  }\n\n  export function scopeToString(scope: VariableScope): string {\n    switch (scope) {\n      case VariableScope.Global: return \"\";\n      case VariableScope.Varying: return \"varying\";\n      case VariableScope.Uniform: return \"uniform\";\n      case VariableScope.Attribute: return \"attribute\";\n      default: assert(false); return \"undefined\";\n    }\n  }\n\n  export function precisionToString(precision: VariablePrecision): string {\n    switch (precision) {\n      case VariablePrecision.Default: return \"\";\n      case VariablePrecision.Low: return \"lowp\";\n      case VariablePrecision.Medium: return \"mediump\";\n      case VariablePrecision.High: return \"highp\";\n      default: assert(false); return \"undefined\";\n    }\n  }\n}\n\n/**\n * Function invoked by ShaderVariable::AddBinding() to bind the variable to the compiled program.\n * The implementation should call ShaderProgram::AddShaderUniform or ShaderProgram::AddGraphicUniform/Attribute to register a function\n * which can be used to bind the value of the variable when program is used.\n * @internal\n */\nexport type AddVariableBinding = (prog: ShaderProgram) => void;\n\n/** Represents a variable within a fragment or vertex shader.\n * @internal\n */\nexport class ShaderVariable {\n  private readonly _addBinding?: AddVariableBinding;\n  public readonly name: string;\n  public readonly value?: string; // for global variables only\n  public readonly type: VariableType;\n  public readonly scope: VariableScope;\n  public readonly precision: VariablePrecision;\n  public readonly isConst: boolean = false; // for global variables only\n\n  private constructor(name: string, type: VariableType, scope: VariableScope, precision: VariablePrecision, isConst: boolean, addBinding?: AddVariableBinding, value?: string) {\n    this._addBinding = addBinding;\n    this.name = name;\n    this.value = value;\n    this.type = type;\n    this.scope = scope;\n    this.precision = precision;\n    this.isConst = isConst;\n  }\n\n  public static create(name: string, type: VariableType, scope: VariableScope, addBinding?: AddVariableBinding, precision: VariablePrecision = VariablePrecision.Default): ShaderVariable {\n    return new ShaderVariable(name, type, scope, precision, false, addBinding, undefined);\n  }\n\n  public static createGlobal(name: string, type: VariableType, value?: string, isConst: boolean = false) {\n    return new ShaderVariable(name, type, VariableScope.Global, VariablePrecision.Default, isConst, undefined, value);\n  }\n\n  public get hasBinding(): boolean { return undefined !== this._addBinding; }\n  public addBinding(prog: ShaderProgram) {\n    if (undefined !== this._addBinding)\n      this._addBinding(prog);\n  }\n\n  public get typeName(): string { return Convert.typeToString(this.type); }\n  public get scopeName(): string { return Convert.scopeToString(this.scope); }\n  public get precisionName(): string { return Convert.precisionToString(this.precision); }\n\n  /** Constructs the single-line declaration of this variable */\n  public buildDeclaration(): string {\n    const parts = new Array<string>();\n    if (this.isConst)\n      parts.push(\"const\");\n\n    const scopeName = this.scopeName;\n    if (0 < scopeName.length)\n      parts.push(scopeName);\n\n    const precisionName = this.precisionName;\n    if (0 < precisionName.length)\n      parts.push(precisionName);\n\n    parts.push(this.typeName);\n    parts.push(this.name);\n\n    if (undefined !== this.value && 0 < this.value.length) {\n      parts.push(\"=\");\n      parts.push(this.value);\n    }\n\n    return parts.join(\" \") + \";\";\n  }\n}\n\n/**\n * Represents the set of variables defined and used within a fragment or vertex shader.\n * If the same variable is used in both the fragment and vertex shader (e.g., a varying variable), it should be defined in both ShaderBuilders' ShaderVariables object.\n * @internal\n */\nexport class ShaderVariables {\n  public readonly list: ShaderVariable[] = new Array<ShaderVariable>();\n\n  /** Find an existing variable with the specified name */\n  public find(name: string): ShaderVariable | undefined { return this.list.find((v: ShaderVariable) => v.name === name); }\n\n  /** Add a new variable, if a variable with the same name does not already exist. */\n  public addVariable(v: ShaderVariable): void {\n    const found = this.find(v.name);\n    if (undefined !== found) {\n      assert(found.type === v.type);\n      // assume same binding etc...\n    } else {\n      this.list.push(v);\n    }\n  }\n\n  public addUniform(name: string, type: VariableType, binding: AddVariableBinding, precision: VariablePrecision = VariablePrecision.Default) {\n    this.addVariable(ShaderVariable.create(name, type, VariableScope.Uniform, binding, precision));\n  }\n\n  public addAttribute(name: string, type: VariableType, binding: AddVariableBinding) {\n    this.addVariable(ShaderVariable.create(name, type, VariableScope.Attribute, binding));\n  }\n\n  public addVarying(name: string, type: VariableType) {\n    this.addVariable(ShaderVariable.create(name, type, VariableScope.Varying));\n  }\n\n  public addGlobal(name: string, type: VariableType, value?: string, isConst: boolean = false) {\n    this.addVariable(ShaderVariable.createGlobal(name, type, value, isConst));\n  }\n\n  public addConstant(name: string, type: VariableType, value: string) {\n    this.addGlobal(name, type, value, true);\n  }\n\n  /** Constructs the lines of glsl code declaring all of the variables. */\n  public buildDeclarations(): string {\n    let decls = \"\";\n    for (const v of this.list) {\n      decls += v.buildDeclaration() + \"\\n\";\n    }\n\n    return decls;\n  }\n\n  /**\n   * For every uniform and attribute variable not contained in the optional 'predefined' list, invokes the associated binding function\n   * to add the corresponding Uniform or Attribute object to the ShaderProgram.\n   */\n  public addBindings(prog: ShaderProgram, predefined?: ShaderVariables): void {\n    for (const v of this.list) {\n      // Some variables exist in both frag and vert shaders - only add them to the program once.\n      if (v.hasBinding && (undefined === predefined || undefined === predefined.find(v.name))) {\n        v.addBinding(prog);\n      }\n    }\n  }\n\n  public get length(): number { return this.list.length; }\n\n  // Return true if GL_MAX_VARYING_VECTORS has been exceeded for the minimum guaranteed value of 8.\n  public exceedsMaxVaryingVectors(): boolean {\n    // Varyings go into a matrix of 4 columns and GL_MAX_VARYING_VECTORS rows of floats.\n    // The packing rules are defined by the standard. Specifically each row can contain one of:\n    //  vec4\n    //  vec3 (+ float)\n    //  vec2 (+ vec2)\n    //  vec2 (+ float (+ float))\n    //  float (+ float (+ float (+ float)))\n    const registers = [0, 0, 0, 0, 0, 0, 0, 0];\n    for (const variable of this.list) {\n      if (VariableScope.Varying !== variable.scope)\n        continue;\n\n      let variableSize = 0;\n      switch (variable.type) {\n        case VariableType.Int:\n        case VariableType.Float:\n          variableSize = 1;\n          break;\n        case VariableType.Vec2:\n          variableSize = 2;\n          break;\n        case VariableType.Vec3:\n          variableSize = 3;\n          break;\n        case VariableType.Vec4:\n          variableSize = 4;\n          break;\n        default:\n          assert(false, \"Invalid varying variable type\");\n          continue;\n      }\n\n      // Find the first available slot into which to insert this variable\n      let slotAvailable = false;\n      for (let i = 0; i < 8; i++) {\n        const newSize = registers[i] + variableSize;\n        if (newSize <= 4) {\n          registers[i] = newSize;\n          slotAvailable = true;\n          break;\n        }\n      }\n\n      if (!slotAvailable)\n        return true;\n    }\n\n    return false;\n  }\n}\n\n/** Convenience API for assembling glsl source code.\n * @internal\n */\nexport class SourceBuilder {\n  public source: string = \"\";\n\n  /* Append the specified string to the glsl source */\n  public add(what: string): void { this.source += what; }\n\n  /* Append a new-line to the glsl source */\n  public newline(): void { this.add(\"\\n\"); }\n\n  /* Append the specified string to the glsl source, followed by a new-line */\n  public addline(what: string): void { this.add(what); this.newline(); }\n\n  /**\n   * Construct a function definition given the function signature and body. For example:\n   * buildFunctionDefintion(\"float average(float a, float b)\", \"\\n  return (a + b) / 2.0;\\n\");\n   * will produce:\n   *  \"float average(float a, float b) {\n   *     return (a + b) / 2.0;\n   *   }\"\n   * For an inline function:\n   * buildFunctionDefintion(\"float average(float a, float b)\", \"return (a + b) / 2.0;\");\n   * will produce:\n   *  \"float average(float a, float b) { return (a + b) / 2.0; }\"\n   */\n  public static buildFunctionDefinition(declaration: string, implementation: string): string {\n    // If implementation does not start with a newline then assume it is an inline function & add spaces between braces.\n    if (\"\\n\" === implementation.charAt(0))\n      return declaration + \" {\" + implementation + \"}\\n\\n\";\n    else\n      return declaration + \" { \" + implementation + \" }\\n\\n\";\n  }\n\n  /** Constructs a function definition as described by buildFunctionDefinition() and appends it to the glsl source. */\n  public addFunction(declaration: string, implementation: string): void { this.add(SourceBuilder.buildFunctionDefinition(declaration, implementation)); }\n\n  /** Constructs the definition of the main() function using the supplied function body and appends it to the glsl source. */\n  public addMain(implementation: string): void { this.addFunction(\"void main()\", implementation); }\n}\n\n/** @internal */\nexport const enum ShaderBuilderFlags {\n  // No special flags. Vertex data comes from attributes, geometry is not instanced.\n  None = 0,\n  // Vertex data comes from a texture.\n  VertexTable = 1 << 0,\n  // Geometry is instanced.\n  Instanced = 1 << 1,\n  InstancedVertexTable = VertexTable | Instanced,\n}\n\n/*\n * Represents a fragment or vertex shader under construction. The shader consists of a set of defined variables,\n * plus a set of code snippets which can be concatenated together to form the shader source.\n * @internal\n */\nexport class ShaderBuilder extends ShaderVariables {\n  public readonly components = new Array<string | undefined>();\n  public readonly functions: string[] = new Array<string>();\n  public readonly extensions: string[] = new Array<string>();\n  public headerComment: string = \"\";\n  protected readonly _flags: ShaderBuilderFlags;\n\n  public get usesVertexTable() { return ShaderBuilderFlags.None !== (this._flags & ShaderBuilderFlags.VertexTable); }\n  public get usesInstancedGeometry() { return ShaderBuilderFlags.None !== (this._flags & ShaderBuilderFlags.Instanced); }\n\n  protected constructor(maxComponents: number, flags: ShaderBuilderFlags) {\n    super();\n    this.components.length = maxComponents;\n    this._flags = flags;\n  }\n\n  protected addComponent(index: number, component: string): void {\n    assert(index < this.components.length);\n\n    // assume if caller is replacing an existing component, they know what they're doing...\n    this.components[index] = component;\n  }\n  protected removeComponent(index: number) {\n    assert(index < this.components.length);\n    this.components[index] = undefined;\n  }\n\n  protected getComponent(index: number): string | undefined {\n    assert(index < this.components.length);\n    return this.components[index];\n  }\n\n  public addFunction(declarationOrFull: string, implementation?: string): void {\n    let def = declarationOrFull;\n    if (undefined !== implementation) {\n      def = SourceBuilder.buildFunctionDefinition(\"\\n\" + declarationOrFull, implementation);\n    }\n\n    if (undefined === this.findFunction(def)) {\n      this.functions.push(def);\n    }\n  }\n\n  public replaceFunction(existing: string, replacement: string): boolean {\n    const index = this.functions.indexOf(existing);\n    if (-1 !== index) {\n      this.functions[index] = replacement;\n    }\n\n    assert(-1 !== index);\n    return -1 !== index;\n  }\n\n  public findFunction(func: string): string | undefined {\n    return this.functions.find((f: string | undefined) => f === func);\n  }\n\n  public addExtension(extName: string): void {\n    if (-1 === this.extensions.indexOf(extName)) {\n      this.extensions.push(extName);\n    }\n  }\n\n  protected buildPreludeCommon(isFrag: boolean = false, isLit: boolean = false, maxClippingPlanes: number = 0): SourceBuilder {\n    const src = new SourceBuilder();\n\n    src.addline(\"#version 100\");\n    src.addline(\"#define TEXTURE texture2D\");\n    src.addline(\"#define TEXTURE_CUBE textureCube\");\n\n    if (maxClippingPlanes > 0)\n      src.addline(\"#define MAX_CLIPPING_PLANES \" + maxClippingPlanes);\n\n    // Header comment\n    src.newline();\n    if (\"\" !== this.headerComment) {\n      src.addline(this.headerComment);\n      src.newline();\n    }\n\n    // Extensions\n    let needMultiDrawBuffers = false;\n    for (const ext of this.extensions) {\n      if (ext === \"GL_EXT_draw_buffers\") {\n        assert(System.instance.capabilities.supportsDrawBuffers, \"GL_EXT_draw_buffers unsupported\");\n        needMultiDrawBuffers = true;\n      }\n\n      src.addline(\"#extension \" + ext + \" : enable\");\n    }\n\n    // Default precisions\n    src.addline(\"precision highp float;\");\n    src.addline(\"precision highp int;\");\n    src.newline();\n\n    // Variable declarations\n    src.add(this.buildDeclarations());\n\n    if (!isFrag) {\n      src.addline(\"#define MAT_NORM g_nmx\");\n      if (!this.usesInstancedGeometry) {\n        src.addline(\"#define MAT_MV u_mv\");\n        src.addline(\"#define MAT_MVP u_mvp\");\n        src.addline(\"#define MAT_MODEL u_modelMatrix\");\n      } else {\n        src.addline(\"#define MAT_MV g_mv\");\n        src.addline(\"#define MAT_MVP g_mvp\");\n        src.addline(\"#define MAT_MODEL g_instancedModelMatrix\");\n      }\n    } else {\n      src.addline(\"#define FragColor gl_FragColor\");\n      if (needMultiDrawBuffers) {\n        src.addline(\"#define FragColor0 gl_FragData[0]\");\n        src.addline(\"#define FragColor1 gl_FragData[1]\");\n        src.addline(\"#define FragColor2 gl_FragData[2]\");\n        src.addline(\"#define FragColor3 gl_FragData[3]\");\n      }\n\n      if (isLit) {\n        // ###TODO: Source Lighting\n      }\n    }\n\n    // Functions\n    for (const func of this.functions) {\n      src.add(func);\n    }\n    if (0 !== this.functions.length)\n      src.newline();\n\n    return src;\n  }\n}\n\n/** Describes the optional and required components which can be assembled into complete\n * @internal\n */\nexport const enum VertexShaderComponent {\n  // (Optional) Adjust the result of unquantizeVertexPosition().\n  // vec4 adjustRawPosition(vec4 rawPosition)\n  AdjustRawPosition,\n  // (Optional) Return true to discard this vertex before evaluating feature overrides etc, given the model-space position.\n  // bool checkForEarlyDiscard(vec4 rawPos)\n  CheckForEarlyDiscard,\n  // (Optional) Compute feature overrides like visibility, rgb, transparency, line weight.\n  ComputeFeatureOverrides,\n  // (Optional) Return true if this vertex should be \"discarded\" (is not visible)\n  // bool checkForDiscard()\n  // If this returns true, gl_Position will be set to 0; presumably related vertices will also do so, resulting in a degenerate triangle.\n  // If this returns true, no further processing will be performed.\n  CheckForDiscard,\n  // (Required) Return this vertex's position in clip space.\n  // vec4 computePosition(vec4 rawPos)\n  ComputePosition,\n  // (Optional) After all output (varying) values have been computed, return true if this vertex should be discarded.\n  // bool checkForLateDiscard()\n  CheckForLateDiscard,\n\n  COUNT,\n}\n\n/** Assembles the source code for a vertex shader from a set of modular components.\n * @internal\n */\nexport class VertexShaderBuilder extends ShaderBuilder {\n  private _computedVarying: string[] = new Array<string>();\n  private _initializers: string[] = new Array<string>();\n\n  public get computedVarying(): string[] { return this._computedVarying; }\n  public get initializers(): string[] { return this._initializers; }\n\n  private buildPrelude(): SourceBuilder { return this.buildPreludeCommon(); }\n\n  public constructor(flags: ShaderBuilderFlags) {\n    super(VertexShaderComponent.COUNT, flags);\n    if (this.usesInstancedGeometry)\n      addInstancedModelMatrixRTC(this);\n\n    addPosition(this, this.usesVertexTable);\n  }\n\n  public get(id: VertexShaderComponent): string | undefined { return this.getComponent(id); }\n  public set(id: VertexShaderComponent, component: string) { this.addComponent(id, component); }\n  public unset(id: VertexShaderComponent) { this.removeComponent(id); }\n\n  public addInitializer(initializer: string): void { this._initializers.push(initializer); }\n  public addComputedVarying(name: string, type: VariableType, computation: string): void {\n    this.addVarying(name, type);\n    this._computedVarying.push(computation);\n  }\n\n  public buildSource(): string {\n    const prelude = this.buildPrelude();\n    const main = new SourceBuilder();\n    main.newline();\n\n    const computePosition = this.get(VertexShaderComponent.ComputePosition);\n    assert(undefined !== computePosition);\n    if (undefined !== computePosition) {\n      prelude.addFunction(\"vec4 computePosition(vec4 rawPos)\", computePosition);\n    }\n\n    // Initialization logic that should occur at start of main() - primarily global variables whose values\n    // are too complex to compute inline or which depend on uniforms and/or other globals.\n    for (const init of this._initializers) {\n      main.addline(\"  {\" + init + \"  }\\n\");\n    }\n\n    main.addline(\"  vec4 rawPosition = unquantizeVertexPosition(a_pos, u_qOrigin, u_qScale);\");\n    const adjustRawPosition = this.get(VertexShaderComponent.AdjustRawPosition);\n    if (undefined !== adjustRawPosition) {\n      prelude.addFunction(\"vec4 adjustRawPosition(vec4 rawPos)\", adjustRawPosition);\n      main.addline(\"  rawPosition = adjustRawPosition(rawPosition);\");\n    }\n\n    const checkForEarlyDiscard = this.get(VertexShaderComponent.CheckForEarlyDiscard);\n    if (undefined !== checkForEarlyDiscard) {\n      prelude.addFunction(\"bool checkForEarlyDiscard(vec4 rawPos)\", checkForEarlyDiscard);\n      main.add(GLSLVertex.earlyDiscard);\n    }\n\n    const computeFeatureOverrides = this.get(VertexShaderComponent.ComputeFeatureOverrides);\n    if (undefined !== computeFeatureOverrides) {\n      prelude.addFunction(\"void computeFeatureOverrides()\", computeFeatureOverrides);\n      main.addline(\"  computeFeatureOverrides();\");\n    }\n\n    const checkForDiscard = this.get(VertexShaderComponent.CheckForDiscard);\n    if (undefined !== checkForDiscard) {\n      prelude.addFunction(\"bool checkForDiscard()\", checkForDiscard);\n      main.add(GLSLVertex.discard);\n    }\n\n    main.addline(\"  gl_Position = computePosition(rawPosition);\");\n\n    for (const comp of this._computedVarying) {\n      main.addline(\"  \" + comp);\n    }\n\n    const checkForLateDiscard = this.get(VertexShaderComponent.CheckForLateDiscard);\n    if (undefined !== checkForLateDiscard) {\n      prelude.addFunction(\"bool checkForLateDiscard()\", checkForLateDiscard);\n      main.addline(GLSLVertex.lateDiscard);\n    }\n\n    prelude.addMain(main.source);\n    return prelude.source;\n  }\n}\n\n/** Describes the optional and required components which can be assembled into complete\n * @internal\n */\nexport const enum FragmentShaderComponent {\n  // (Optional) Return true to immediately discard this fragment.\n  // bool checkForEarlyDiscard()\n  CheckForEarlyDiscard,\n  // (Required) Compute this fragment's base color\n  // vec4 computeBaseColor()\n  ComputeBaseColor,\n  // (Optional) Apply material overrides to base color\n  // vec4 applyMaterialOverrides(vec4 baseColor)\n  ApplyMaterialOverrides,\n  // (Optional) Apply feature overrides to base color\n  // vec4 applyFeatureColor(vec4 baseColor)\n  ApplyFeatureColor,\n  // (Optional) Adjust base color after material and/or feature overrides have been applied.\n  // vec4 finalizeBaseColor(vec4 baseColor)\n  FinalizeBaseColor,\n  // (Optional) Return true if this fragment should be discarded\n  // Do not invoke discard directly in your shader components - instead, return true from this function to generate a discard statement.\n  // bool checkForDiscard(vec4 baseColor)\n  CheckForDiscard,\n  // (Optional) Return true if the alpha value is not suitable for the current render pass\n  // bool discardByAlpha(float alpha)\n  DiscardByAlpha,\n  // (Optional) Apply lighting to base color\n  // vec4 applyLighting(vec4 baseColor)\n  ApplyLighting,\n  // (Optional) Apply monochrome overrides to base color\n  // vec4 applyMonochrome(vec4 baseColor)\n  ApplyMonochrome,\n  // (Optional) Apply white-on-white reversal to base color\n  ReverseWhiteOnWhite,\n  // (Optional) Discard if outside any clipping planes\n  // void applyClipping()\n  ApplyClipping,\n  // (Optional) Apply flash hilite to lit base color\n  // vec4 applyFlash(vec4 baseColor)\n  ApplyFlash,\n  // (Optional) Apply planar classifier.\n  // vec4 applyPlanarClassification(vec4)\n  ApplyPlanarClassifier,\n  // (Optional) Apply solar shadow map.\n  // vec4 applySolarShadowMap(vec4)\n  ApplySolarShadowMap,\n  // (Optional) Apply a debug color\n  // vec4 applyDebugColor(vec4 baseColor)\n  ApplyDebugColor,\n  // (Required) Assign the final color to gl_FragColor or gl_FragData\n  // void assignFragData(vec4 baseColor)\n  AssignFragData,\n  // (Optional) Override current featureId\n  // vec4 overrideFeatureId(vec4 currentId)\n  OverrideFeatureId,\n  COUNT,\n}\n\n/** Assembles the source code for a fragment shader from a set of modular components.\n * @internal\n */\nexport class FragmentShaderBuilder extends ShaderBuilder {\n  public maxClippingPlanes: number = 0;\n\n  public constructor(flags: ShaderBuilderFlags) {\n    super(FragmentShaderComponent.COUNT, flags);\n  }\n\n  public get(id: FragmentShaderComponent): string | undefined { return this.getComponent(id); }\n  public set(id: FragmentShaderComponent, component: string) { this.addComponent(id, component); }\n  public unset(id: FragmentShaderComponent) { this.removeComponent(id); }\n\n  public addDrawBuffersExtension(): void {\n    assert(System.instance.capabilities.supportsDrawBuffers, \"WEBGL_draw_buffers unsupported\");\n    this.addExtension(\"GL_EXT_draw_buffers\");\n  }\n\n  public buildSource(): string {\n    const applyLighting = this.get(FragmentShaderComponent.ApplyLighting);\n    const prelude = this.buildPrelude(undefined !== applyLighting);\n\n    const computeBaseColor = this.get(FragmentShaderComponent.ComputeBaseColor);\n    assert(undefined !== computeBaseColor);\n    if (undefined !== computeBaseColor) {\n      prelude.addFunction(\"vec4 computeBaseColor()\", computeBaseColor);\n    }\n\n    const main = new SourceBuilder();\n    main.newline();\n    const checkForEarlyDiscard = this.get(FragmentShaderComponent.CheckForEarlyDiscard);\n    if (undefined !== checkForEarlyDiscard) {\n      prelude.addFunction(\"bool checkForEarlyDiscard()\", checkForEarlyDiscard);\n      main.addline(\"  if (checkForEarlyDiscard()) { discard; return; }\");\n    }\n\n    const applyClipping = this.get(FragmentShaderComponent.ApplyClipping);\n    if (undefined !== applyClipping) {\n      prelude.addFunction(\"void applyClipping()\", applyClipping);\n      main.addline(\"  applyClipping();\");\n    }\n\n    main.addline(\"  vec4 baseColor = computeBaseColor();\");\n\n    const applyMaterialOverrides = this.get(FragmentShaderComponent.ApplyMaterialOverrides);\n    if (undefined !== applyMaterialOverrides) {\n      prelude.addFunction(\"vec4 applyMaterialOverrides(vec4 baseColor)\", applyMaterialOverrides);\n      main.addline(\"  baseColor = applyMaterialOverrides(baseColor);\");\n    }\n\n    const applyPlanarClassifier = this.get(FragmentShaderComponent.ApplyPlanarClassifier);\n    if (undefined !== applyPlanarClassifier) {\n      prelude.addFunction(\"vec4 applyPlanarClassifications(vec4 baseColor)\", applyPlanarClassifier);\n      main.addline(\"  baseColor = applyPlanarClassifications(baseColor);\");\n    }\n    const applySolarShadowMap = this.get(FragmentShaderComponent.ApplySolarShadowMap);\n    if (undefined !== applySolarShadowMap) {\n      prelude.addFunction(\"vec4 applySolarShadowMap(vec4 baseColor)\", applySolarShadowMap);\n      main.addline(\"  baseColor = applySolarShadowMap(baseColor);\");\n    }\n    const applyFeatureColor = this.get(FragmentShaderComponent.ApplyFeatureColor);\n    if (undefined !== applyFeatureColor) {\n      prelude.addFunction(\"vec4 applyFeatureColor(vec4 baseColor)\", applyFeatureColor);\n      main.addline(\"  baseColor = applyFeatureColor(baseColor);\");\n    }\n\n    const finalize = this.get(FragmentShaderComponent.FinalizeBaseColor);\n    if (undefined !== finalize) {\n      prelude.addFunction(\"vec4 finalizeBaseColor(vec4 baseColor)\", finalize);\n      main.addline(\"  baseColor = finalizeBaseColor(baseColor);\");\n    }\n\n    const checkForDiscard = this.get(FragmentShaderComponent.CheckForDiscard);\n    if (undefined !== checkForDiscard) {\n      prelude.addFunction(\"bool checkForDiscard(vec4 baseColor)\", checkForDiscard);\n      main.addline(\"  if (checkForDiscard(baseColor)) { discard; return; }\");\n    }\n\n    const discardByAlpha = this.get(FragmentShaderComponent.DiscardByAlpha);\n    if (undefined !== discardByAlpha) {\n      prelude.addFunction(\"bool discardByAlpha(float alpha)\", discardByAlpha);\n      main.addline(\"  if (discardByAlpha(baseColor.a)) { discard; return; }\");\n    }\n\n    if (undefined !== applyLighting) {\n      prelude.addFunction(\"vec4 applyLighting(vec4 baseColor)\", applyLighting);\n      main.addline(\"  baseColor = applyLighting(baseColor);\");\n    }\n\n    const applyMonochrome = this.get(FragmentShaderComponent.ApplyMonochrome);\n    if (undefined !== applyMonochrome) {\n      prelude.addFunction(\"vec4 applyMonochrome(vec4 baseColor)\", applyMonochrome);\n      main.addline(\"  baseColor = applyMonochrome(baseColor);\");\n    }\n\n    const reverseWoW = this.get(FragmentShaderComponent.ReverseWhiteOnWhite);\n    if (undefined !== reverseWoW) {\n      prelude.addFunction(\"vec4 reverseWhiteOnWhite(vec4 baseColor)\", reverseWoW);\n      main.addline(\"  baseColor = reverseWhiteOnWhite(baseColor);\");\n    }\n\n    const applyFlash = this.get(FragmentShaderComponent.ApplyFlash);\n    if (undefined !== applyFlash) {\n      prelude.addFunction(\"vec4 applyFlash(vec4 baseColor)\", applyFlash);\n      main.addline(\"  baseColor = applyFlash(baseColor);\");\n    }\n\n    const applyDebug = this.get(FragmentShaderComponent.ApplyDebugColor);\n    if (undefined !== applyDebug) {\n      prelude.addFunction(\"vec4 applyDebugColor(vec4 baseColor)\", applyDebug);\n      main.addline(\"  baseColor = applyDebugColor(baseColor);\");\n    }\n\n    const assignFragData = this.get(FragmentShaderComponent.AssignFragData);\n    assert(undefined !== assignFragData);\n    if (undefined !== assignFragData) {\n      prelude.addFunction(\"void assignFragData(vec4 baseColor)\", assignFragData);\n      main.addline(\"  assignFragData(baseColor);\");\n    }\n\n    prelude.addMain(main.source);\n    return prelude.source;\n  }\n\n  private buildPrelude(isLit: boolean): SourceBuilder {\n    assert(this.maxClippingPlanes === 0 || this.get(FragmentShaderComponent.ApplyClipping) !== undefined);\n    return this.buildPreludeCommon(true, isLit, this.maxClippingPlanes);\n  }\n}\n\n/** A collection of shader programs with clipping that vary based on the max number of clipping planes each supports.\n * @internal\n */\nexport class ClippingShaders {\n  public builder: ProgramBuilder;\n  public shaders: ShaderProgram[] = [];\n  public maskShader?: ShaderProgram;\n\n  public constructor(prog: ProgramBuilder, context: WebGLRenderingContext) {\n    this.builder = prog.clone();\n    addClipping(this.builder, ClipDef.forPlanes(6));\n\n    const maskBuilder = prog.clone();\n    addClipping(maskBuilder, ClipDef.forMask());\n    this.maskShader = maskBuilder.buildProgram(context);\n    assert(this.maskShader !== undefined);\n  }\n\n  public compileShaders(): boolean {\n    return undefined === this.maskShader || this.maskShader.compile();\n  }\n\n  private static roundUpToNearestMultipleOf(value: number, factor: number): number {\n    const maxPlanes = Math.ceil(value / factor) * factor;\n    assert(maxPlanes >= value);\n    return maxPlanes;\n  }\n\n  private static roundNumPlanes(minPlanes: number): number {\n    // We want to avoid making the shader do too much extra work, but we also want to avoid creating separate clipping shaders for\n    // every unique # of planes\n    if (minPlanes <= 2)\n      return minPlanes;   // 1 or 2 planes fairly common (ex - section cut)\n    else if (minPlanes <= 6)\n      return 6;           // cuboid volume\n    else if (minPlanes <= 120)\n      return this.roundUpToNearestMultipleOf(minPlanes, 20);\n    else\n      return this.roundUpToNearestMultipleOf(minPlanes, 50);\n  }\n\n  public getProgram(clipDef: ClipDef): ShaderProgram | undefined {\n    if (clipDef.type === ClippingType.Mask) {\n      return this.maskShader;\n    } else if (clipDef.type === ClippingType.Planes) {\n      assert(clipDef.numberOfPlanes > 0);\n      const numClips = ClippingShaders.roundNumPlanes(clipDef.numberOfPlanes);\n      for (const shader of this.shaders)\n        if (shader.maxClippingPlanes === numClips)\n          return shader;\n\n      this.builder.frag.maxClippingPlanes = numClips;\n      const newProgram = this.builder.buildProgram(System.instance.context);\n      this.shaders.push(newProgram);\n      return newProgram;\n    } else {\n      assert(false);\n      return undefined;\n    }\n  }\n}\n\n/** @internal */\nexport const enum ShaderType {\n  Fragment = 1 << 0,\n  Vertex = 1 << 1,\n  Both = Fragment | Vertex,\n}\n\n/**\n * Assembles vertex and fragment shaders from a set of modular components to produce a compiled ShaderProgram.\n * Be very careful with components which use samplers to ensure that no conflicts exist with texture units used by other components (see TextureUnit enum).\n * @internal\n */\nexport class ProgramBuilder {\n  public readonly vert: VertexShaderBuilder;\n  public readonly frag: FragmentShaderBuilder;\n  private readonly _flags: ShaderBuilderFlags;\n\n  public constructor(flags = ShaderBuilderFlags.None) {\n    this.vert = new VertexShaderBuilder(flags);\n    this.frag = new FragmentShaderBuilder(flags);\n    this._flags = flags; // only needed for clone - though could loook up from vert or frag shader.\n  }\n\n  private addVariable(v: ShaderVariable, which: ShaderType) {\n    if (which & ShaderType.Fragment) {\n      this.frag.addVariable(v);\n    }\n\n    if (which & ShaderType.Vertex) {\n      this.vert.addVariable(v);\n    }\n  }\n\n  public addUniform(name: string, type: VariableType, binding: AddVariableBinding, which: ShaderType = ShaderType.Both) {\n    this.addVariable(ShaderVariable.create(name, type, VariableScope.Uniform, binding), which);\n  }\n  public addAttribute(name: string, type: VariableType, binding: AddVariableBinding, which: ShaderType = ShaderType.Both) {\n    this.addVariable(ShaderVariable.create(name, type, VariableScope.Attribute, binding), which);\n  }\n  public addVarying(name: string, type: VariableType) {\n    this.addVariable(ShaderVariable.create(name, type, VariableScope.Varying), ShaderType.Both);\n  }\n  public addGlobal(name: string, type: VariableType, which: ShaderType = ShaderType.Both, value?: string, isConst: boolean = false) {\n    this.addVariable(ShaderVariable.createGlobal(name, type, value, isConst), which);\n  }\n\n  public addInlineComputedVarying(name: string, type: VariableType, inlineComputation: string) {\n    this.frag.addVarying(name, type);\n    this.vert.addComputedVarying(name, type, inlineComputation);\n  }\n  public addFunctionComputedVarying(name: string, type: VariableType, funcName: string, funcBody: string) {\n    let funcDecl = \"\\n\" + Convert.typeToString(type) + \" \" + funcName + \"()\";\n    funcDecl = SourceBuilder.buildFunctionDefinition(funcDecl, funcBody);\n\n    const funcCall = funcName + \"()\";\n    this.addFunctionComputedVaryingWithArgs(name, type, funcCall, funcDecl);\n  }\n  public addFunctionComputedVaryingWithArgs(name: string, type: VariableType, funcCall: string, funcDef: string) {\n    this.vert.addFunction(funcDef);\n    const computation = name + \" = \" + funcCall + \";\";\n    this.addInlineComputedVarying(name, type, computation);\n  }\n\n  /** Assembles the vertex and fragment shader code and returns a ready-to-compile shader program */\n  public buildProgram(gl: WebGLRenderingContext): ShaderProgram {\n    if (this.vert.exceedsMaxVaryingVectors())\n      assert(false, \"GL_MAX_VARYING_VECTORS exceeded\");\n\n    const prog = new ShaderProgram(gl, this.vert.buildSource(), this.frag.buildSource(), this.vert.headerComment, this.frag.maxClippingPlanes);\n    this.vert.addBindings(prog);\n    this.frag.addBindings(prog, this.vert);\n    return prog;\n  }\n\n  public setDebugDescription(description: string): void {\n    this.vert.headerComment = (\"//!V! \" + description);\n    this.frag.headerComment = (\"//!F! \" + description);\n  }\n\n  /** Returns a deep copy of this program builder. */\n  public clone(): ProgramBuilder {\n    const clone = new ProgramBuilder(this._flags);\n\n    // Copy from vertex builder\n    clone.vert.headerComment = this.vert.headerComment;\n    for (let i = 0; i < this.vert.computedVarying.length; i++)\n      clone.vert.computedVarying[i] = this.vert.computedVarying[i];\n    for (let i = 0; i < this.vert.initializers.length; i++)\n      clone.vert.initializers[i] = this.vert.initializers[i];\n    for (let i = 0; i < this.vert.components.length; i++)\n      clone.vert.components[i] = this.vert.components[i];\n    for (let i = 0; i < this.vert.functions.length; i++)\n      clone.vert.functions[i] = this.vert.functions[i];\n    for (let i = 0; i < this.vert.extensions.length; i++)\n      clone.vert.extensions[i] = this.vert.extensions[i];\n    for (let i = 0; i < this.vert.list.length; i++)\n      clone.vert.list[i] = this.vert.list[i];\n\n    // Copy from fragment builder\n    clone.frag.headerComment = this.frag.headerComment;\n    clone.frag.maxClippingPlanes = this.frag.maxClippingPlanes;\n    for (let i = 0; i < this.frag.components.length; i++)\n      clone.frag.components[i] = this.frag.components[i];\n    for (let i = 0; i < this.frag.functions.length; i++)\n      clone.frag.functions[i] = this.frag.functions[i];\n    for (let i = 0; i < this.frag.extensions.length; i++)\n      clone.frag.extensions[i] = this.frag.extensions[i];\n    for (let i = 0; i < this.frag.list.length; i++)\n      clone.frag.list[i] = this.frag.list[i];\n\n    return clone;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert, IDisposable } from \"@bentley/bentleyjs-core\";\nimport { UniformHandle, AttributeHandle } from \"./Handle\";\nimport { ShaderProgramParams, DrawParams } from \"./DrawCommand\";\nimport { GL } from \"./GL\";\nimport { Target } from \"./Target\";\nimport { RenderPass } from \"./RenderFlags\";\nimport { TechniqueFlags } from \"./TechniqueFlags\";\nimport { System } from \"./System\";\nimport { Branch, Batch } from \"./Graphic\";\n\n// tslint:disable:no-const-enum\n\n/** Flags which control some conditional branches in shader code\n * @internal\n */\nexport const enum ShaderFlags {\n  None = 0,\n  Monochrome = 1 << 0,\n  NonUniformColor = 1 << 1,\n  OITFlatAlphaWeight = 1 << 2,\n  OITScaleOutput = 1 << 3,\n  IgnoreNonLocatable = 1 << 4,\n}\n\n/** Describes the location of a uniform variable within a shader program.\n * @internal\n */\nexport class Uniform {\n  private readonly _name: string;\n  protected _handle?: UniformHandle;\n\n  protected constructor(name: string) { this._name = name; }\n\n  public compile(prog: ShaderProgram): boolean {\n    assert(!this.isValid);\n    if (undefined !== prog.glProgram) {\n      this._handle = UniformHandle.create(prog.glProgram, this._name, true);\n    }\n\n    return this.isValid;\n  }\n\n  public get isValid(): boolean { return undefined !== this._handle; }\n}\n\n/**\n * A function associated with a ProgramUniform which is invoked each time the shader program becomes active.\n * The function is responsible for setting the value of the uniform.\n * @internal\n */\nexport type BindProgramUniform = (uniform: UniformHandle, params: ShaderProgramParams) => void;\n\n/**\n * Describes the location of a uniform variable within a shader program, the value of which does not change while the program is active.\n * The supplied binding function will be invoked once each time the shader becomes active to set the value of the uniform.\n * @internal\n */\nexport class ProgramUniform extends Uniform {\n  private readonly _bind: BindProgramUniform;\n\n  public constructor(name: string, bind: BindProgramUniform) {\n    super(name);\n    this._bind = bind;\n  }\n\n  public bind(params: ShaderProgramParams): void {\n    if (undefined !== this._handle) {\n      this._bind(this._handle, params);\n    }\n  }\n}\n\n/**\n * A function associated with a GraphicUniform which is invoked each time a new graphic primitive is rendered using the associated shader.\n * The function is responsible for setting the value of the uniform.\n * @internal\n */\nexport type BindGraphicUniform = (uniform: UniformHandle, params: DrawParams) => void;\n\n/**\n * Describes the location of a uniform variable within a shader program, the value of which is dependent upon the graphic primitive\n * currently being rendered by the program. The supplied binding function will be invoked once for each graphic primitive submitted\n * to the program to set the value of the uniform.\n * @internal\n */\nexport class GraphicUniform extends Uniform {\n  private readonly _bind: BindGraphicUniform;\n\n  public constructor(name: string, bind: BindGraphicUniform) {\n    super(name);\n    this._bind = bind;\n  }\n\n  public bind(params: DrawParams): void {\n    if (undefined !== this._handle) {\n      this._bind(this._handle, params);\n    }\n  }\n}\n\n/** A function associated with an Attribute which is invoked to bind the attribute data.\n * @internal\n */\nexport type BindAttribute = (attr: AttributeHandle, params: DrawParams) => void;\n\n/** Describes the location of an attribute within a shader program along with a function for binding the attribute's data\n * @internal\n */\nexport class Attribute {\n  private readonly _name: string;\n  private readonly _bind: BindAttribute;\n  private _handle?: AttributeHandle;\n\n  public constructor(name: string, bind: BindAttribute) {\n    this._name = name;\n    this._bind = bind;\n  }\n\n  public compile(prog: ShaderProgram): boolean {\n    assert(!this.isValid);\n    if (undefined !== prog.glProgram) {\n      this._handle = AttributeHandle.create(prog.glProgram, this._name, true);\n    }\n\n    return this.isValid;\n  }\n\n  public get isValid(): boolean { return undefined !== this._handle; }\n  public bind(params: DrawParams): void {\n    if (undefined !== this._handle) {\n      this._bind(this._handle, params);\n    }\n  }\n}\n\n/** Describes the compilation status of a shader program. Programs may be compiled during idle time, or upon first use.\n * @internal\n */\nexport const enum CompileStatus {\n  Success,    // The program was successfully compiled.\n  Failure,    // The program failed to compile.\n  Uncompiled, // No attempt has yet been made to compile the program.\n}\n\n/** @internal */\nexport class ShaderProgram implements IDisposable {\n  private _description: string; // for debugging purposes...\n  public vertSource: string;\n  public fragSource: string;\n  public readonly maxClippingPlanes: number;\n  private _glProgram?: WebGLProgram;\n  private _inUse: boolean = false;\n  private _status: CompileStatus = CompileStatus.Uncompiled;\n  private readonly _programUniforms = new Array<ProgramUniform>();\n  private readonly _graphicUniforms = new Array<GraphicUniform>();\n  private readonly _attributes = new Array<Attribute>();\n  private readonly _preserveShaderSourceCode: boolean;\n\n  public constructor(gl: WebGLRenderingContext, vertSource: string, fragSource: string, description: string, maxClippingPlanes: number) {\n    this._description = description;\n    this.vertSource = vertSource;\n    this.fragSource = fragSource;\n    this.maxClippingPlanes = maxClippingPlanes;\n\n    const glProgram = gl.createProgram();\n    this._glProgram = (null === glProgram) ? undefined : glProgram;\n\n    this._preserveShaderSourceCode = true === System.instance.options.preserveShaderSourceCode;\n\n    // Silencing 'unused variable' warnings temporarily...\n    assert(undefined !== this._description);\n  }\n\n  public get isDisposed(): boolean { return this._glProgram === undefined; }\n\n  public dispose(): void {\n    if (!this.isDisposed) {\n      assert(!this._inUse);\n      System.instance.context.deleteProgram(this._glProgram!);\n      this._glProgram = undefined;\n      this._status = CompileStatus.Uncompiled;\n    }\n  }\n\n  public get glProgram(): WebGLProgram | undefined { return this._glProgram; }\n  public get isUncompiled() { return CompileStatus.Uncompiled === this._status; }\n\n  private compileShader(type: GL.ShaderType): WebGLShader | undefined {\n    const gl: WebGLRenderingContext = System.instance.context;\n\n    const shader = gl.createShader(type);\n    if (null === shader) {\n      return undefined;\n    }\n\n    const src = GL.ShaderType.Vertex === type ? this.vertSource : this.fragSource;\n    gl.shaderSource(shader, src);\n    gl.compileShader(shader);\n    const succeeded = gl.getShaderParameter(shader, GL.ShaderParameter.CompileStatus) as boolean;\n    const compileLog = succeeded ? \"\" : (GL.ShaderType.Vertex === type ? \"Vertex\" : \"Fragment\") + \" compilation errors: \" + gl.getShaderInfoLog(shader) + \"\\n\" + src;\n\n    if (this._preserveShaderSourceCode !== true) { // do not preserve shader source code\n      if (GL.ShaderType.Vertex === type)\n        this.vertSource = \"\";\n      else\n        this.fragSource = \"\";\n    }\n\n    assert(succeeded, compileLog);\n    return succeeded ? shader : undefined;\n  }\n  private linkProgram(vert: WebGLShader, frag: WebGLShader): boolean {\n    assert(undefined !== this.glProgram);\n    if (undefined === this._glProgram || null === this._glProgram) { // because WebGL APIs used Thing|null, not Thing|undefined...\n      return false;\n    }\n\n    const gl: WebGLRenderingContext = System.instance.context;\n    gl.attachShader(this._glProgram, vert);\n    gl.attachShader(this._glProgram, frag);\n    gl.linkProgram(this._glProgram);\n\n    const linkLog = gl.getProgramInfoLog(this._glProgram);\n    gl.validateProgram(this._glProgram);\n    const validateLog = gl.getProgramInfoLog(this._glProgram);\n\n    const succeeded = gl.getProgramParameter(this._glProgram, GL.ProgramParameter.LinkStatus) as boolean;\n    if (!succeeded)\n      assert(succeeded, \"Link errors: \" + linkLog + \" Validate errors: \" + validateLog);\n\n    return succeeded;\n  }\n  public compile(): boolean {\n    switch (this._status) {\n      case CompileStatus.Failure: return false;\n      case CompileStatus.Success: return true;\n      default: {\n        if (this.isDisposed) {\n          this._status = CompileStatus.Failure;\n          return false;\n        }\n        break;\n      }\n    }\n\n    const vert = this.compileShader(GL.ShaderType.Vertex);\n    const frag = this.compileShader(GL.ShaderType.Fragment);\n    if (undefined !== vert && undefined !== frag) {\n      if (this.linkProgram(vert, frag) && this.compileUniforms(this._programUniforms) && this.compileUniforms(this._graphicUniforms) && this.compileAttributes()) {\n        this._status = CompileStatus.Success;\n        return true;\n      }\n    }\n\n    this._status = CompileStatus.Failure;\n    return false;\n  }\n\n  public use(params: ShaderProgramParams): boolean {\n    if (!this.compile()) {\n      return false;\n    }\n\n    assert(undefined !== this._glProgram);\n    if (null === this._glProgram || undefined === this._glProgram) {\n      return false;\n    }\n\n    assert(!this._inUse);\n    this._inUse = true;\n    params.context.useProgram(this._glProgram);\n\n    for (const uniform of this._programUniforms) {\n      uniform.bind(params);\n    }\n\n    return true;\n  }\n  public endUse() {\n    assert(this._inUse);\n    this._inUse = false;\n    System.instance.context.useProgram(null);\n  }\n\n  public draw(params: DrawParams): void {\n    assert(this._inUse);\n    for (const uniform of this._graphicUniforms) {\n      uniform.bind(params);\n    }\n\n    for (const attribute of this._attributes)\n      attribute.bind(params);\n\n    System.instance.updateVertexAttribArrays();\n\n    params.geometry.draw();\n  }\n\n  public addProgramUniform(name: string, binding: BindProgramUniform) {\n    assert(this.isUncompiled);\n    this._programUniforms.push(new ProgramUniform(name, binding));\n  }\n  public addGraphicUniform(name: string, binding: BindGraphicUniform) {\n    assert(this.isUncompiled);\n    this._graphicUniforms.push(new GraphicUniform(name, binding));\n  }\n  public addAttribute(name: string, binding: BindAttribute) {\n    assert(this.isUncompiled);\n    this._attributes.push(new Attribute(name, binding));\n  }\n\n  private compileUniforms<T extends Uniform>(uniforms: T[]): boolean {\n    for (const uniform of uniforms) {\n      if (!uniform.compile(this))\n        return false;\n    }\n\n    return true;\n  }\n\n  private compileAttributes(): boolean {\n    for (const attribute of this._attributes) {\n      if (!attribute.compile(this))\n        return false;\n    }\n\n    return true;\n  }\n}\n\n/** Context in which ShaderPrograms are executed. Avoids switching shaders unnecessarily.\n * Ensures shader programs are compiled before use and un-bound when scope is disposed.\n * This class must *only* be used inside a using() function!\n * @internal\n */\nexport class ShaderProgramExecutor {\n  private _program?: ShaderProgram;\n  private static _params?: ShaderProgramParams;\n\n  public constructor(target: Target, pass: RenderPass, program?: ShaderProgram) {\n    this.params.init(target, pass);\n    this.changeProgram(program);\n  }\n\n  /** Clears the current program to be executed. This does not free WebGL resources, since those are owned by Techniques. */\n  public dispose() { this.changeProgram(undefined); }\n\n  public setProgram(program: ShaderProgram): boolean { return this.changeProgram(program); }\n  public get isValid() { return undefined !== this._program; }\n  public get target() { return this.params.target; }\n  public get renderPass() { return this.params.renderPass; }\n  public get params() {\n    if (undefined === ShaderProgramExecutor._params)\n      ShaderProgramExecutor._params = new ShaderProgramParams();\n\n    return ShaderProgramExecutor._params;\n  }\n\n  public draw(params: DrawParams) {\n    assert(this.isValid);\n    if (undefined !== this._program) {\n      this._program.draw(params);\n    }\n  }\n  public drawInterrupt(params: DrawParams) {\n    assert(params.target === this.params.target);\n\n    const tech = params.target.techniques.getTechnique(params.geometry.getTechniqueId(params.target));\n    const program = tech.getShader(TechniqueFlags.defaults);\n    if (this.setProgram(program)) {\n      this.draw(params);\n    }\n  }\n\n  public pushBranch(branch: Branch): void { this.target.pushBranch(this, branch); }\n  public popBranch(): void { this.target.popBranch(); }\n  public pushBatch(batch: Batch): void { this.target.pushBatch(batch); }\n  public popBatch(): void { this.target.popBatch(); }\n\n  private changeProgram(program?: ShaderProgram): boolean {\n    if (this._program === program) {\n      return true;\n    } else if (undefined !== this._program) {\n      this._program.endUse();\n    }\n\n    this._program = program;\n    if (undefined !== program && !program.use(this.params)) {\n      this._program = undefined;\n      return false;\n    }\n\n    return true;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module WebGL */\r\nimport { GL } from \"./GL\";\r\nimport { dispose, assert, BeTimePoint } from \"@bentley/bentleyjs-core\";\r\nimport { RenderMemory, RenderSolarShadowMap, RenderGraphic, RenderClipVolume } from \"../System\";\r\nimport { Vector3d, Point3d, Matrix3d, Matrix4d, Transform, Range3d } from \"@bentley/geometry-core\";\r\nimport { ModelSelectorState } from \"../../ModelSelectorState\";\r\nimport { CategorySelectorState } from \"../../CategorySelectorState\";\r\nimport { Matrix4 } from \"./Matrix\";\r\nimport { Target } from \"./Target\";\r\nimport { Texture, TextureHandle } from \"./Texture\";\r\nimport { FrameBuffer } from \"./FrameBuffer\";\r\nimport { SceneContext } from \"../../ViewContext\";\r\nimport { TileTree, Tile } from \"../../tile/TileTree\";\r\nimport { IModelConnection } from \"../../IModelConnection\";\r\nimport { Frustum, FrustumPlanes, RenderTexture, RenderMode, SolarShadows } from \"@bentley/imodeljs-common\";\r\nimport { System } from \"./System\";\r\nimport { RenderState } from \"./RenderState\";\r\nimport { BatchState, BranchStack } from \"./BranchState\";\r\nimport { RenderCommands } from \"./DrawCommand\";\r\nimport { RenderPass } from \"./RenderFlags\";\r\n\r\nclass SolarShadowMapDrawArgs extends Tile.DrawArgs {\r\n  constructor(private _mapFrustumPlanes: FrustumPlanes, private _shadowMap: SolarShadowMap, context: SceneContext, location: Transform, root: TileTree, now: BeTimePoint, purgeOlderThan: BeTimePoint, clip?: RenderClipVolume) {\r\n    super(context, location, root, now, purgeOlderThan, clip);\r\n  }\r\n  public get frustumPlanes(): FrustumPlanes { return this._mapFrustumPlanes; }\r\n  public drawGraphics(): void {\r\n    if (!this.graphics.isEmpty) {\r\n      this._shadowMap.addGraphic(this.context.createBranch(this.graphics, this.location));\r\n    }\r\n  }\r\n\r\n  public static create(context: SceneContext, shadowMap: SolarShadowMap, tileTree: TileTree, planes: FrustumPlanes) {\r\n    const now = BeTimePoint.now();\r\n    const purgeOlderThan = now.minus(tileTree.expirationTime);\r\n    return new SolarShadowMapDrawArgs(planes, shadowMap, context, tileTree.location.clone(), tileTree, now, purgeOlderThan, tileTree.clipVolume);\r\n  }\r\n}\r\n\r\nconst enum Status { BelowHorizon, OutOfSynch, WaitingForTiles, GraphicsReady, TextureReady }\r\nexport class SolarShadowMap extends RenderSolarShadowMap implements RenderMemory.Consumer {\r\n\r\n  private _doFitToFrustum = true;\r\n  private _depthTexture?: Texture;\r\n  private _fbo?: FrameBuffer;\r\n  private _direction?: Vector3d;\r\n  private _models?: ModelSelectorState;\r\n  private _categories?: CategorySelectorState;\r\n  private _projectionMatrix = new Matrix4();\r\n  private _graphics: RenderGraphic[] = [];\r\n  private _shadowFrustum = new Frustum();\r\n  private _viewFrustum = new Frustum();\r\n  private _status = Status.OutOfSynch;\r\n  private _settings = new SolarShadows.Settings();\r\n  public get isReady() { return this._status === Status.TextureReady; }\r\n  public get projectionMatrix(): Matrix4 { return this._projectionMatrix; }\r\n  public get depthTexture(): Texture | undefined { return this._depthTexture; }\r\n  public get settings(): SolarShadows.Settings { return this._settings; }\r\n  public get direction(): Vector3d | undefined { return this._direction; }\r\n  public addGraphic(graphic: RenderGraphic) { this._graphics.push(graphic); }\r\n  private static _scratchRange = Range3d.createNull();\r\n  private static _scratchTransform = Transform.createIdentity();\r\n\r\n  public constructor() {\r\n    super();\r\n  }\r\n  public get requiresSynch() { return this._status === Status.OutOfSynch; }\r\n\r\n  public collectStatistics(stats: RenderMemory.Statistics): void {\r\n    if (undefined !== this._depthTexture)\r\n      stats.addShadowMap(this._depthTexture.bytesUsed);\r\n  }\r\n  public dispose() {\r\n    this._depthTexture = dispose(this._depthTexture);\r\n    this._fbo = dispose(this._fbo);\r\n    this.clearGraphics();\r\n  }\r\n  public set(viewFrustum: Frustum, direction: Vector3d, settings: SolarShadows.Settings, models: ModelSelectorState, categories: CategorySelectorState) {\r\n    const minimumHorizonDirection = -.01;\r\n    this._settings = settings.clone();\r\n    if (direction.z > minimumHorizonDirection) {\r\n      this._status = Status.BelowHorizon;\r\n      return;\r\n    }\r\n    if (this._doFitToFrustum && !this._viewFrustum.equals(viewFrustum)) {\r\n      this._status = Status.OutOfSynch;\r\n      this._viewFrustum.setFrom(viewFrustum);\r\n    }\r\n\r\n    if (undefined === this._direction ||\r\n      !this._direction.isAlmostEqual(direction) ||\r\n      undefined === this._models ||\r\n      !this._models!.equalState(models) ||\r\n      undefined === this._categories ||\r\n      !this._categories!.equalState(categories)) {\r\n      // The solar direction, models and categories have changed..\r\n      this._direction = direction.clone();\r\n      this._models = models.clone();\r\n      this._categories = categories.clone();\r\n      this._status = Status.OutOfSynch;\r\n    }\r\n  }\r\n\r\n  private forEachTileTree(iModel: IModelConnection, func: (tileTree: TileTree) => void) {\r\n    if (this._models) {\r\n      for (const modelId of this._models.models) {\r\n        const model = iModel.models.getLoaded(modelId);\r\n        const model3d = undefined !== model ? model.asGeometricModel3d : undefined;\r\n        if (undefined !== model3d && undefined !== model3d.tileTree) {\r\n          func(model3d.tileTree);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  private clearGraphics() {\r\n    for (const graphic of this._graphics)\r\n      graphic.dispose();\r\n\r\n    this._graphics.length = 0;\r\n  }\r\n  public collectGraphics(sceneContext: SceneContext) {\r\n    if (this.isReady)\r\n      return;\r\n    const iModel = sceneContext.viewport.iModel;\r\n    if (this._status === Status.BelowHorizon)\r\n      return;\r\n    if (this._direction === undefined ||\r\n      this._models === undefined ||\r\n      this._categories === undefined) {\r\n      assert(false);\r\n      return;\r\n    }\r\n    for (const modelId of this._models.models) {\r\n      const model = iModel.models.getLoaded(modelId);\r\n      const model3d = undefined !== model ? model.asGeometricModel3d : undefined;\r\n      if (undefined !== model3d && model3d.loadStatus < TileTree.LoadStatus.Loaded) {\r\n        this._status = Status.WaitingForTiles;\r\n        return;\r\n      }\r\n    }\r\n\r\n    const worldToMapTransform = Transform.createRefs(Point3d.createZero(), Matrix3d.createRigidHeadsUp(this._direction.negate()).inverse()!);\r\n    const worldToMap = Matrix4d.createTransform(worldToMapTransform);\r\n    const mapToWorld = worldToMap.createInverse()!;\r\n\r\n    const backgroundOn = sceneContext.viewFlags.backgroundMap;\r\n    let shadowRange;\r\n    if (this._doFitToFrustum) {\r\n      shadowRange = Range3d.createTransformedArray(worldToMapTransform, this._viewFrustum.points);\r\n\r\n      // By fitting to the actual tiles we can reduce the shadowRange and make better use of the texture pixels.\r\n      if (!backgroundOn) {\r\n        const viewTileRange = Range3d.createNull();\r\n        const viewPlanes = new FrustumPlanes(this._viewFrustum);\r\n        this.forEachTileTree(iModel, (tileTree) => tileTree.accumlateTransformedRange(viewTileRange, worldToMap, viewPlanes));\r\n        if (!viewTileRange.isNull)\r\n          shadowRange.intersect(viewTileRange, shadowRange);\r\n      }\r\n      const projectRange = worldToMapTransform.multiplyRange(iModel.projectExtents, SolarShadowMap._scratchRange);\r\n      shadowRange.low.x = Math.max(shadowRange.low.x, projectRange.low.x);\r\n      shadowRange.high.x = Math.min(shadowRange.high.x, projectRange.high.x);\r\n      shadowRange.low.y = Math.max(shadowRange.low.y, projectRange.low.y);\r\n      shadowRange.high.y = Math.min(shadowRange.high.y, projectRange.high.y);\r\n      shadowRange.high.z = projectRange.high.z;\r\n    } else {\r\n      shadowRange = worldToMapTransform.multiplyRange(iModel.projectExtents);\r\n    }\r\n\r\n    if (shadowRange.isNull) {\r\n      return;\r\n    }\r\n\r\n    this._shadowFrustum.initFromRange(shadowRange);\r\n    mapToWorld.multiplyPoint3dArrayQuietNormalize(this._shadowFrustum.points);\r\n\r\n    const tileRange = Range3d.createNull();\r\n    const frustumPlanes = new FrustumPlanes(this._shadowFrustum);\r\n    const originalMissingTileCount = sceneContext.missingTiles.entries.length;\r\n    this.forEachTileTree(iModel, ((tileTree) => {\r\n      const drawArgs = SolarShadowMapDrawArgs.create(sceneContext, this, tileTree, frustumPlanes);\r\n      const tileToMapTransform = worldToMapTransform.multiplyTransformTransform(tileTree.location, SolarShadowMap._scratchTransform);\r\n      const selectedTiles = tileTree.selectTiles(drawArgs);\r\n\r\n      for (const selectedTile of selectedTiles) {\r\n        tileRange.extendRange(tileToMapTransform.multiplyRange(selectedTile.range, SolarShadowMap._scratchRange));\r\n        selectedTile.drawGraphics(drawArgs);\r\n      }\r\n\r\n      drawArgs.drawGraphics();\r\n      sceneContext.viewport.numSelectedTiles += selectedTiles.length;\r\n    }));\r\n    if (tileRange.isNull || sceneContext.missingTiles.entries.length > originalMissingTileCount) {\r\n      this._status = Status.WaitingForTiles;\r\n      this.clearGraphics();\r\n    } else {\r\n      this._status = Status.GraphicsReady;\r\n      if (!backgroundOn) {\r\n        shadowRange.intersect(tileRange, shadowRange);\r\n        this._shadowFrustum.initFromRange(shadowRange);\r\n        mapToWorld.multiplyPoint3dArrayQuietNormalize(this._shadowFrustum.points);\r\n      }\r\n      const frustumMap = this._shadowFrustum.toMap4d();\r\n      if (undefined === frustumMap) {\r\n        assert(false);\r\n        return;\r\n      }\r\n      this._projectionMatrix.initFromMatrix4d(frustumMap.transform0);\r\n    }\r\n  }\r\n\r\n  public draw(target: Target) {\r\n    if (this._status !== Status.GraphicsReady)\r\n      return;\r\n\r\n    const shadowMapWidth = 4096;\r\n    const shadowMapHeight = shadowMapWidth;   // TBD - Adjust for aspect ratio.\r\n    if (undefined === this._fbo || undefined === this._depthTexture) {\r\n      const depthTextureHandle = System.instance.createDepthBuffer(shadowMapWidth, shadowMapHeight) as TextureHandle;\r\n      if (undefined === depthTextureHandle ||\r\n        undefined === (this._fbo = FrameBuffer.create([], depthTextureHandle))) {\r\n        assert(false, \"Failed to create shadow depth buffer\");\r\n        return;\r\n      }\r\n      this._depthTexture = new Texture(new RenderTexture.Params(undefined, RenderTexture.Type.TileSection, true), depthTextureHandle);\r\n    }\r\n\r\n    const prevState = System.instance.currentRenderState.clone();\r\n    System.instance.context.viewport(0, 0, shadowMapWidth, shadowMapHeight);\r\n\r\n    const state = new RenderState();\r\n    state.flags.depthMask = true;\r\n    state.flags.blend = false;\r\n    state.flags.depthTest = true;\r\n\r\n    const viewFlags = target.currentViewFlags.clone();\r\n    viewFlags.renderMode = RenderMode.SmoothShade;\r\n    viewFlags.transparency = false;\r\n    viewFlags.textures = false;\r\n    viewFlags.sourceLights = false;\r\n    viewFlags.cameraLights = false;\r\n    viewFlags.solarLight = false;\r\n    viewFlags.shadows = false;\r\n    viewFlags.noGeometryMap = true;\r\n    viewFlags.monochrome = false;\r\n    viewFlags.materials = false;\r\n    viewFlags.ambientOcclusion = false;\r\n    viewFlags.visibleEdges = viewFlags.hiddenEdges = false;\r\n\r\n    const batchState = new BatchState();\r\n    System.instance.applyRenderState(state);\r\n    const prevPlan = target.plan;\r\n\r\n    target.changeFrustum(this._shadowFrustum, this._shadowFrustum.getFraction(), true);\r\n    target.branchStack.setViewFlags(viewFlags);\r\n\r\n    const renderCommands = new RenderCommands(target, new BranchStack(), batchState);\r\n    renderCommands.addGraphics(this._graphics);\r\n\r\n    System.instance.frameBufferStack.execute(this._fbo, true, () => {\r\n      System.instance.context.clearDepth(1.0);\r\n      System.instance.context.clear(GL.BufferBit.Depth);\r\n      target.techniques.execute(target, renderCommands.getCommands(RenderPass.OpaquePlanar), RenderPass.PlanarClassification);    // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.\r\n      target.techniques.execute(target, renderCommands.getCommands(RenderPass.OpaqueGeneral), RenderPass.PlanarClassification);    // Draw these with RenderPass.PlanarClassification (rather than Opaque...) so that the pick ordering is avoided.\r\n    });\r\n\r\n    batchState.reset();   // Reset the batch Ids...\r\n    if (prevPlan)\r\n      target.changeRenderPlan(prevPlan);\r\n\r\n    System.instance.applyRenderState(prevState);\r\n    System.instance.context.viewport(0, 0, target.viewRect.width, target.viewRect.height); // Restore viewport\r\n    this.clearGraphics();\r\n    this._status = Status.TextureReady;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { IModelError, RenderTexture, RenderMaterial, Gradient, ImageBuffer, ElementAlignedBox3d, ColorDef, QPoint3dList, QParams3d, QPoint3d, SpatialClassificationProps, Frustum, SolarShadows } from \"@bentley/imodeljs-common\";\nimport {\n  ClipVector, Transform, Point3d, ClipUtilities, PolyfaceBuilder, Point2d, IndexedPolyface, Range3d,\n  IndexedPolyfaceVisitor, Triangulator, StrokeOptions, HalfEdgeGraph, HalfEdge, HalfEdgeMask, Vector3d,\n} from \"@bentley/geometry-core\";\nimport {\n  InstancedGraphicParams,\n  RenderGraphic,\n  GraphicBranch,\n  RenderSystem,\n  RenderDiagnostics,\n  RenderTarget,\n  RenderClipVolume,\n  RenderClassifierModel,\n  RenderPlanarClassifier,\n  GraphicList,\n  PackedFeatureTable,\n  WebGLExtensionName,\n  RenderSolarShadowMap,\n} from \"../System\";\nimport { SkyBox } from \"../../DisplayStyleState\";\nimport { OnScreenTarget, OffScreenTarget } from \"./Target\";\nimport { GraphicBuilder, GraphicType } from \"../GraphicBuilder\";\nimport { PrimitiveBuilder } from \"../primitives/geometry/GeometryListBuilder\";\nimport { PointCloudArgs } from \"../primitives/PointCloudPrimitive\";\nimport { PointStringParams, MeshParams, PolylineParams } from \"../primitives/VertexTable\";\nimport { MeshArgs } from \"../primitives/mesh/MeshPrimitives\";\nimport { Branch, Batch, GraphicsArray } from \"./Graphic\";\nimport { IModelConnection } from \"../../IModelConnection\";\nimport { assert, BentleyStatus, Dictionary, IDisposable, dispose, Id64String } from \"@bentley/bentleyjs-core\";\nimport { Techniques } from \"./Technique\";\nimport { IModelApp } from \"../../IModelApp\";\nimport { ViewRect, Viewport } from \"../../Viewport\";\nimport { WebGLFeature, WebGLRenderCompatibilityInfo, WebGLRenderCompatibilityStatus } from \"../../RenderCompatibility\";\nimport { RenderState } from \"./RenderState\";\nimport { FrameBufferStack, DepthBuffer } from \"./FrameBuffer\";\nimport { RenderBuffer } from \"./RenderBuffer\";\nimport { TextureHandle, Texture } from \"./Texture\";\nimport { GL } from \"./GL\";\nimport { PolylineGeometry } from \"./Polyline\";\nimport { PointStringGeometry } from \"./PointString\";\nimport { MeshGraphic } from \"./Mesh\";\nimport { PointCloudGeometry } from \"./PointCloud\";\nimport { LineCode } from \"./EdgeOverrides\";\nimport { Material } from \"./Material\";\nimport { SkyBoxQuadsGeometry, SkySphereViewportQuadGeometry } from \"./CachedGeometry\";\nimport { SkyCubePrimitive, SkySpherePrimitive, Primitive } from \"./Primitive\";\nimport { ClipPlanesVolume, ClipMaskVolume } from \"./ClipVolume\";\nimport { SolarShadowMap } from \"./SolarShadowMap\";\nimport { TextureUnit } from \"./RenderFlags\";\nimport { UniformHandle } from \"./Handle\";\nimport { Debug } from \"./Diagnostics\";\nimport { PlanarClassifier } from \"./PlanarClassifier\";\nimport { TileTreeModelState } from \"../../ModelState\";\nimport { TileTree } from \"../../tile/TileTree\";\nimport { SceneContext } from \"../../ViewContext\";\nimport { ModelSelectorState } from \"../../ModelSelectorState\";\nimport { CategorySelectorState } from \"../../CategorySelectorState\";\n\n// tslint:disable:no-const-enum\n\n/** @internal */\nexport const enum ContextState {\n  Uninitialized,\n  Success,\n  Error,\n}\n\n/** Describes the type of a render target. Used by Capabilities to represent maximum precision render target available on host system.\n * @internal\n */\nexport const enum RenderType {\n  TextureUnsignedByte,\n  TextureHalfFloat,\n  TextureFloat,\n}\n\n/**\n * Describes the type of a depth buffer. Used by Capabilities to represent maximum depth buffer precision available on host system.\n * Note: the commented-out values are unimplemented but left in place for reference, in case desired for future implementation.\n * @internal\n */\nexport const enum DepthType {\n  RenderBufferUnsignedShort16,     // core to WebGL1\n  // TextureUnsignedShort16,       // core to WebGL2; available to WebGL1 via WEBGL_depth_texture\n  // TextureUnsignedInt24,         // core to WebGL2\n  TextureUnsignedInt24Stencil8,    // core to WebGL2; available to WebGL1 via WEBGL_depth_texture\n  TextureUnsignedInt32,            // core to WebGL2; available to WebGL1 via WEBGL_depth_texture\n  // TextureFloat32,               // core to WebGL2\n  // TextureFloat32Stencil8,       // core to WeBGL2\n}\n\nconst knownExtensions: WebGLExtensionName[] = [\n  \"WEBGL_draw_buffers\",\n  \"OES_element_index_uint\",\n  \"OES_texture_float\",\n  \"OES_texture_half_float\",\n  \"WEBGL_depth_texture\",\n  \"EXT_color_buffer_float\",\n  \"EXT_shader_texture_lod\",\n  \"ANGLE_instanced_arrays\",\n];\n\n/** Describes the rendering capabilities of the host system.\n * @internal\n */\nexport class Capabilities {\n  private _maxRenderType: RenderType = RenderType.TextureUnsignedByte;\n  private _maxDepthType: DepthType = DepthType.RenderBufferUnsignedShort16;\n  private _maxTextureSize: number = 0;\n  private _maxColorAttachments: number = 0;\n  private _maxDrawBuffers: number = 0;\n  private _maxFragTextureUnits: number = 0;\n  private _maxVertTextureUnits: number = 0;\n  private _maxVertAttribs: number = 0;\n  private _maxVertUniformVectors: number = 0;\n  private _maxVaryingVectors: number = 0;\n  private _maxFragUniformVectors: number = 0;\n\n  private _extensionMap: { [key: string]: any } = {}; // Use this map to store actual extension objects retrieved from GL.\n  private _presentFeatures: WebGLFeature[] = []; // List of features the system can support (not necessarily dependent on extensions)\n\n  public get maxRenderType(): RenderType { return this._maxRenderType; }\n  public get maxDepthType(): DepthType { return this._maxDepthType; }\n  public get maxTextureSize(): number { return this._maxTextureSize; }\n  public get maxColorAttachments(): number { return this._maxColorAttachments; }\n  public get maxDrawBuffers(): number { return this._maxDrawBuffers; }\n  public get maxFragTextureUnits(): number { return this._maxFragTextureUnits; }\n  public get maxVertTextureUnits(): number { return this._maxVertTextureUnits; }\n  public get maxVertAttribs(): number { return this._maxVertAttribs; }\n  public get maxVertUniformVectors(): number { return this._maxVertUniformVectors; }\n  public get maxVaryingVectors(): number { return this._maxVaryingVectors; }\n  public get maxFragUniformVectors(): number { return this._maxFragUniformVectors; }\n\n  /** These getters check for existence of extension objects to determine availability of features.  In WebGL2, could just return true for some. */\n  public get supportsNonPowerOf2Textures(): boolean { return false; }\n  public get supportsDrawBuffers(): boolean { return this.queryExtensionObject<WEBGL_draw_buffers>(\"WEBGL_draw_buffers\") !== undefined; }\n  public get supportsInstancing(): boolean { return this.queryExtensionObject<ANGLE_instanced_arrays>(\"ANGLE_instanced_arrays\") !== undefined; }\n  public get supports32BitElementIndex(): boolean { return this.queryExtensionObject<OES_element_index_uint>(\"OES_element_index_uint\") !== undefined; }\n  public get supportsTextureFloat(): boolean { return this.queryExtensionObject<OES_texture_float>(\"OES_texture_float\") !== undefined; }\n  public get supportsTextureHalfFloat(): boolean { return this.queryExtensionObject<OES_texture_half_float>(\"OES_texture_half_float\") !== undefined; }\n  public get supportsShaderTextureLOD(): boolean { return this.queryExtensionObject<EXT_shader_texture_lod>(\"EXT_shader_texture_lod\") !== undefined; }\n\n  public get supportsMRTTransparency(): boolean { return this.maxColorAttachments >= 2; }\n  public get supportsMRTPickShaders(): boolean { return this.maxColorAttachments >= 3; }\n\n  /** Queries an extension object if available.  This is necessary for other parts of the system to access some constants within extensions. */\n  public queryExtensionObject<T>(ext: WebGLExtensionName): T | undefined {\n    const extObj: any = this._extensionMap[ext];\n    return (null !== extObj) ? extObj as T : undefined;\n  }\n\n  public static readonly optionalFeatures: WebGLFeature[] = [WebGLFeature.MrtTransparency, WebGLFeature.MrtPick, WebGLFeature.DepthTexture, WebGLFeature.FloatRendering, WebGLFeature.Instancing];\n  public static readonly requiredFeatures: WebGLFeature[] = [WebGLFeature.UintElementIndex, WebGLFeature.MinimalTextureUnits];\n\n  private get _hasRequiredTextureUnits(): boolean { return this.maxFragTextureUnits >= 4 && this.maxVertTextureUnits >= 5; }\n\n  /** Return an array containing any features not supported by the system as compared to the input array. */\n  private _findMissingFeatures(featuresToSeek: WebGLFeature[]): WebGLFeature[] {\n    const missingFeatures: WebGLFeature[] = [];\n    for (const featureName of featuresToSeek) {\n      if (-1 === this._presentFeatures.indexOf(featureName))\n        missingFeatures.push(featureName);\n    }\n    return missingFeatures;\n  }\n\n  /** Populate and return an array containing features that this system supports. */\n  private _gatherFeatures(): WebGLFeature[] {\n    const features: WebGLFeature[] = [];\n\n    // simply check for presence of various extensions if that gives enough information\n    if (this._extensionMap[\"OES_element_index_uint\" as WebGLExtensionName] !== undefined)\n      features.push(WebGLFeature.UintElementIndex);\n    if (this._extensionMap[\"ANGLE_instanced_arrays\" as WebGLExtensionName] !== undefined)\n      features.push(WebGLFeature.Instancing);\n\n    if (this.supportsMRTTransparency)\n      features.push(WebGLFeature.MrtTransparency);\n    if (this.supportsMRTPickShaders)\n      features.push(WebGLFeature.MrtPick);\n    if (this._hasRequiredTextureUnits)\n      features.push(WebGLFeature.MinimalTextureUnits);\n\n    if (DepthType.TextureUnsignedInt24Stencil8 === this._maxDepthType)\n      features.push(WebGLFeature.DepthTexture);\n\n    // check if full float rendering is available based on maximum discovered renderable target\n    if (RenderType.TextureFloat === this._maxRenderType)\n      features.push(WebGLFeature.FloatRendering);\n\n    return features;\n  }\n\n  /** Retrieve compatibility status based on presence of various features. */\n  private _getCompatibilityStatus(missingRequiredFeatures: WebGLFeature[], missingOptionalFeatures: WebGLFeature[]): WebGLRenderCompatibilityStatus {\n    let status: WebGLRenderCompatibilityStatus = WebGLRenderCompatibilityStatus.AllOkay;\n    if (missingOptionalFeatures.length > 0)\n      status = WebGLRenderCompatibilityStatus.MissingOptionalFeatures;\n    if (missingRequiredFeatures.length > 0)\n      status = WebGLRenderCompatibilityStatus.MissingRequiredFeatures;\n    return status;\n  }\n\n  /** Initializes the capabilities based on a GL context. Must be called first. */\n  public init(gl: WebGLRenderingContext, disabledExtensions?: WebGLExtensionName[]): WebGLRenderCompatibilityInfo {\n    this._maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\n    this._maxFragTextureUnits = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\n    this._maxVertTextureUnits = gl.getParameter(gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS);\n    this._maxVertAttribs = gl.getParameter(gl.MAX_VERTEX_ATTRIBS);\n    this._maxVertUniformVectors = gl.getParameter(gl.MAX_VERTEX_UNIFORM_VECTORS);\n    this._maxVaryingVectors = gl.getParameter(gl.MAX_VARYING_VECTORS);\n    this._maxFragUniformVectors = gl.getParameter(gl.MAX_FRAGMENT_UNIFORM_VECTORS);\n\n    const extensions = gl.getSupportedExtensions(); // This just retrieves a list of available extensions (not necessarily enabled).\n    if (extensions) {\n      for (const extStr of extensions) {\n        const ext = extStr as WebGLExtensionName;\n        if (-1 === knownExtensions.indexOf(ext))\n          continue;\n        else if (undefined !== disabledExtensions && -1 !== disabledExtensions.indexOf(ext))\n          continue;\n\n        const extObj: any = gl.getExtension(ext); // This call enables the extension and returns a WebGLObject containing extension instance.\n        if (null !== extObj)\n          this._extensionMap[ext] = extObj;\n      }\n    }\n\n    const dbExt: WEBGL_draw_buffers | undefined = this.queryExtensionObject<WEBGL_draw_buffers>(\"WEBGL_draw_buffers\");\n    this._maxColorAttachments = dbExt !== undefined ? gl.getParameter(dbExt.MAX_COLOR_ATTACHMENTS_WEBGL) : 1;\n    this._maxDrawBuffers = dbExt !== undefined ? gl.getParameter(dbExt.MAX_DRAW_BUFFERS_WEBGL) : 1;\n\n    // Determine the maximum color-renderable attachment type.\n    const allowFloatRender = undefined === disabledExtensions || -1 === disabledExtensions.indexOf(\"OES_texture_float\");\n    if (allowFloatRender && this.isTextureRenderable(gl, gl.FLOAT))\n      this._maxRenderType = RenderType.TextureFloat;\n    else {\n      const hfExt: OES_texture_half_float | undefined = this.queryExtensionObject<OES_texture_half_float>(\"OES_texture_half_float\");\n      this._maxRenderType = (hfExt !== undefined && this.isTextureRenderable(gl, hfExt.HALF_FLOAT_OES)) ? RenderType.TextureHalfFloat : RenderType.TextureUnsignedByte;\n    }\n\n    // Determine the maximum depth attachment type.\n    // this._maxDepthType = this.queryExtensionObject(\"WEBGL_depth_texture\") !== undefined ? DepthType.TextureUnsignedInt32 : DepthType.RenderBufferUnsignedShort16;\n    this._maxDepthType = this.queryExtensionObject(\"WEBGL_depth_texture\") !== undefined ? DepthType.TextureUnsignedInt24Stencil8 : DepthType.RenderBufferUnsignedShort16;\n\n    this._presentFeatures = this._gatherFeatures();\n    const missingRequiredFeatures = this._findMissingFeatures(Capabilities.requiredFeatures);\n    const missingOptionalFeatures = this._findMissingFeatures(Capabilities.optionalFeatures);\n\n    this.debugPrint(gl, missingRequiredFeatures, missingOptionalFeatures);\n\n    return {\n      status: this._getCompatibilityStatus(missingRequiredFeatures, missingOptionalFeatures),\n      missingRequiredFeatures,\n      missingOptionalFeatures,\n    };\n  }\n\n  public static create(gl: WebGLRenderingContext, disabledExtensions?: WebGLExtensionName[]): Capabilities | undefined {\n    const caps = new Capabilities();\n    const compatibility = caps.init(gl, disabledExtensions);\n    if (WebGLRenderCompatibilityStatus.CannotCreateContext === compatibility.status || WebGLRenderCompatibilityStatus.MissingRequiredFeatures === compatibility.status)\n      return undefined;\n    return caps;\n  }\n\n  /** Determines if a particular texture type is color-renderable on the host system. */\n  private isTextureRenderable(gl: WebGLRenderingContext, texType: number): boolean {\n    const tex: WebGLTexture | null = gl.createTexture();\n    gl.bindTexture(gl.TEXTURE_2D, tex);\n    gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, 1, 1, 0, gl.RGBA, texType, null);\n\n    const fb: WebGLFramebuffer | null = gl.createFramebuffer();\n    gl.bindFramebuffer(gl.FRAMEBUFFER, fb);\n    gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, tex, 0);\n\n    const fbStatus: number = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\n    gl.bindFramebuffer(gl.FRAMEBUFFER, null);\n    gl.deleteFramebuffer(fb);\n    gl.deleteTexture(tex);\n\n    gl.getError(); // clear any errors\n\n    return fbStatus === gl.FRAMEBUFFER_COMPLETE;\n  }\n\n  private debugPrint(gl: WebGLRenderingContext, missingRequiredFeatures: WebGLFeature[], _missingOptionalFeatures: WebGLFeature[]) {\n    if (!Debug.printEnabled)\n      return;\n\n    Debug.print(() => \"GLES Capabilities Information:\");\n    Debug.print(() => \"     hasRequiredFeatures : \" + (0 === missingRequiredFeatures.length ? \"yes\" : \"no\"));\n    Debug.print(() => \" missingOptionalFeatures : \" + (missingRequiredFeatures.length > 0 ? \"yes\" : \"no\"));\n    Debug.print(() => \" hasRequiredTextureUnits : \" + this._hasRequiredTextureUnits);\n    Debug.print(() => \"              GL_VERSION : \" + gl.getParameter(gl.VERSION));\n    Debug.print(() => \"               GL_VENDOR : \" + gl.getParameter(gl.VENDOR));\n    Debug.print(() => \"             GL_RENDERER : \" + gl.getParameter(gl.RENDERER));\n    Debug.print(() => \"          maxTextureSize : \" + this.maxTextureSize);\n    Debug.print(() => \"     maxColorAttachments : \" + this.maxColorAttachments);\n    Debug.print(() => \"          maxDrawBuffers : \" + this.maxDrawBuffers);\n    Debug.print(() => \"     maxFragTextureUnits : \" + this.maxFragTextureUnits);\n    Debug.print(() => \"     maxVertTextureUnits : \" + this.maxVertTextureUnits);\n    Debug.print(() => \"     nonPowerOf2Textures : \" + (this.supportsNonPowerOf2Textures ? \"yes\" : \"no\"));\n    Debug.print(() => \"             drawBuffers : \" + (this.supportsDrawBuffers ? \"yes\" : \"no\"));\n    Debug.print(() => \"              instancing : \" + (this.supportsInstancing ? \"yes\" : \"no\"));\n    Debug.print(() => \"       32BitElementIndex : \" + (this.supports32BitElementIndex ? \"yes\" : \"no\"));\n    Debug.print(() => \"            textureFloat : \" + (this.supportsTextureFloat ? \"yes\" : \"no\"));\n    Debug.print(() => \"        textureHalfFloat : \" + (this.supportsTextureHalfFloat ? \"yes\" : \"no\"));\n    Debug.print(() => \"        shaderTextureLOD : \" + (this.supportsShaderTextureLOD ? \"yes\" : \"no\"));\n\n    switch (this.maxRenderType) {\n      case RenderType.TextureUnsignedByte:\n        Debug.print(() => \"           maxRenderType : TextureUnsigedByte\");\n        break;\n      case RenderType.TextureHalfFloat:\n        Debug.print(() => \"           maxRenderType : TextureHalfFloat\");\n        break;\n      case RenderType.TextureFloat:\n        Debug.print(() => \"           maxRenderType : TextureFloat\");\n        break;\n      default:\n        Debug.print(() => \"           maxRenderType : Unknown\");\n    }\n\n    switch (this.maxDepthType) {\n      case DepthType.RenderBufferUnsignedShort16:\n        Debug.print(() => \"            maxDepthType : RenderBufferUnsignedShort16\");\n        break;\n      case DepthType.TextureUnsignedInt24Stencil8:\n        Debug.print(() => \"            maxDepthType : TextureUnsignedInt24Stencil8\");\n        break;\n      case DepthType.TextureUnsignedInt32:\n        Debug.print(() => \"            maxDepthType : TextureUnsignedInt32\");\n        break;\n      default:\n        Debug.print(() => \"            maxDepthType : Unknown\");\n    }\n  }\n}\n\n/** Id map holds key value pairs for both materials and textures, useful for caching such objects.\n * @internal\n */\nexport class IdMap implements IDisposable {\n  /** Mapping of materials by their key values. */\n  public readonly materials: Map<string, RenderMaterial>;\n  /** Mapping of textures by their key values. */\n  public readonly textures: Map<string, RenderTexture>;\n  /** Mapping of textures using gradient symbology. */\n  public readonly gradients: Dictionary<Gradient.Symb, RenderTexture>;\n  /** Mapping of (planar) classification model ID to textures */\n  public readonly classifiers: Map<Id64String, RenderClassifierModel>;\n  /** Solar shadow map (one for IModel) */\n  private _solarShadowMap?: RenderSolarShadowMap;\n  public constructor() {\n    this.materials = new Map<string, RenderMaterial>();\n    this.textures = new Map<string, RenderTexture>();\n    this.gradients = new Dictionary<Gradient.Symb, RenderTexture>(Gradient.Symb.compareSymb);\n    this.classifiers = new Map<Id64String, RenderClassifierModel>();\n  }\n\n  public dispose() {\n    const textureArr = Array.from(this.textures.values());\n    const gradientArr = this.gradients.extractArrays().values;\n    for (const texture of textureArr)\n      dispose(texture);\n\n    for (const gradient of gradientArr)\n      dispose(gradient);\n\n    this.textures.clear();\n    this.gradients.clear();\n  }\n\n  /** Add a material to this IdMap, given that it has a valid key. */\n  public addMaterial(material: RenderMaterial) {\n    if (material.key)\n      this.materials.set(material.key, material);\n  }\n\n  /** Add a texture to this IdMap, given that it has a valid key. */\n  public addTexture(texture: RenderTexture) {\n    if (texture.key)\n      this.textures.set(texture.key, texture);\n  }\n\n  /** Add a texture to this IdMap using gradient symbology. */\n  public addGradient(gradientSymb: Gradient.Symb, texture: RenderTexture) {\n    this.gradients.set(gradientSymb, texture);\n  }\n\n  /** Find a cached material using its key. If not found, returns undefined. */\n  public findMaterial(key: string): RenderMaterial | undefined {\n    return this.materials.get(key);\n  }\n\n  /** Find a cached gradient using the gradient symbology. If not found, returns undefined. */\n  public findGradient(symb: Gradient.Symb): RenderTexture | undefined {\n    return this.gradients.get(symb);\n  }\n\n  /** Find or create a new material given material parameters. This will cache the material if its key is valid. */\n  public getMaterial(params: RenderMaterial.Params): RenderMaterial {\n    if (!params.key)\n      return new Material(params);\n\n    let material = this.materials.get(params.key);\n    if (!material) {\n      material = new Material(params);\n      this.materials.set(params.key, material);\n    }\n    return material;\n  }\n\n  private createTexture(params: RenderTexture.Params, handle?: TextureHandle): Texture | undefined {\n    if (undefined === handle)\n      return undefined;\n\n    const texture = new Texture(params, handle);\n    this.addTexture(texture);\n    return texture;\n  }\n\n  /** Attempt to create and return a new texture from an ImageBuffer. This will cache the texture if its key is valid */\n  private createTextureFromImageBuffer(img: ImageBuffer, params: RenderTexture.Params): RenderTexture | undefined {\n    return this.createTexture(params, TextureHandle.createForImageBuffer(img, params.type));\n  }\n\n  private createTextureFromImage(image: HTMLImageElement, hasAlpha: boolean, params: RenderTexture.Params): RenderTexture | undefined {\n    return this.createTexture(params, TextureHandle.createForImage(image, hasAlpha, params.type));\n  }\n\n  private createTextureFromCubeImages(posX: HTMLImageElement, negX: HTMLImageElement, posY: HTMLImageElement, negY: HTMLImageElement, posZ: HTMLImageElement, negZ: HTMLImageElement, params: RenderTexture.Params) {\n    return this.createTexture(params, TextureHandle.createForCubeImages(posX, negX, posY, negY, posZ, negZ));\n  }\n\n  public findTexture(key?: string): RenderTexture | undefined { return undefined !== key ? this.textures.get(key) : undefined; }\n\n  /** Find or attempt to create a new texture using an ImageBuffer. If a new texture was created, it will be cached provided its key is valid. */\n  public getTexture(img: ImageBuffer, params: RenderTexture.Params): RenderTexture | undefined {\n    const tex = this.findTexture(params.key);\n    return undefined !== tex ? tex : this.createTextureFromImageBuffer(img, params);\n  }\n\n  public getTextureFromImage(image: HTMLImageElement, hasAlpha: boolean, params: RenderTexture.Params): RenderTexture | undefined {\n    const tex = this.findTexture(params.key);\n    return undefined !== tex ? tex : this.createTextureFromImage(image, hasAlpha, params);\n  }\n\n  public getTextureFromCubeImages(posX: HTMLImageElement, negX: HTMLImageElement, posY: HTMLImageElement, negY: HTMLImageElement, posZ: HTMLImageElement, negZ: HTMLImageElement, params: RenderTexture.Params): RenderTexture | undefined {\n    return this.createTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, params);\n  }\n\n  /** Find or attempt to create a new texture using gradient symbology. If a new texture was created, it will be cached using the gradient. */\n  public getGradient(grad: Gradient.Symb): RenderTexture | undefined {\n    const existingGrad = this.gradients.get(grad);\n    if (existingGrad)\n      return existingGrad;\n\n    const image: ImageBuffer = grad.getImage(0x100, 0x100);\n\n    const textureHandle = TextureHandle.createForImageBuffer(image, RenderTexture.Type.Normal);\n    if (!textureHandle)\n      return undefined;\n\n    const params = new Texture.Params(undefined, Texture.Type.Normal, true); // gradient textures are unnamed, but owned by this IdMap.\n    const texture = new Texture(params, textureHandle);\n    this.addGradient(grad, texture);\n    return texture;\n  }\n\n  /** Get a classifier model */\n  public getSpatialClassificationModel(modelId: Id64String): RenderClassifierModel | undefined { return this.classifiers.get(modelId); }\n\n  /** @internal */\n  /** Add a new classifier */\n  public addSpatialClassificationModel(modelId: Id64String, classifier: RenderClassifierModel) { this.classifiers.set(modelId, classifier); }\n\n  /** @internal */\n  /** Get solar shadow map */\n  public getSolarShadowMap(frustum: Frustum, direction: Vector3d, settings: SolarShadows.Settings, models: ModelSelectorState, categories: CategorySelectorState) {\n    if (undefined === this._solarShadowMap)\n      this._solarShadowMap = new SolarShadowMap();\n\n    (this._solarShadowMap as SolarShadowMap)!.set(frustum, direction, settings, models, categories);\n    return this._solarShadowMap;\n  }\n}\n\nexport type TextureBinding = WebGLTexture | undefined;\n\nconst enum VertexAttribState {\n  Disabled = 0,\n  Enabled = 1 << 0,\n  Instanced = 1 << 2,\n  InstancedEnabled = Instanced | Enabled,\n}\n\n/** @internal */\nexport class System extends RenderSystem {\n  public readonly canvas: HTMLCanvasElement;\n  public readonly currentRenderState = new RenderState();\n  public readonly context: WebGLRenderingContext;\n  public readonly frameBufferStack = new FrameBufferStack();  // frame buffers are not owned by the system\n  public readonly capabilities: Capabilities;\n  public readonly resourceCache: Map<IModelConnection, IdMap>;\n  public readonly enableOptimizedSurfaceShaders: boolean;\n  private readonly _drawBuffersExtension?: WEBGL_draw_buffers;\n  private readonly _instancingExtension?: ANGLE_instanced_arrays;\n  private readonly _textureBindings: TextureBinding[] = [];\n\n  // NB: Increase the size of these arrays when the maximum number of attributes used by any one shader increases.\n  private readonly _curVertexAttribStates: VertexAttribState[] = [\n    VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled,\n    VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled,\n    VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled,\n  ];\n  private readonly _nextVertexAttribStates: VertexAttribState[] = [\n    VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled,\n    VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled,\n    VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled, VertexAttribState.Disabled,\n  ];\n\n  // The following are initialized immediately after the System is constructed.\n  private _lineCodeTexture?: TextureHandle;\n  private _noiseTexture?: TextureHandle;\n  private _techniques?: Techniques;\n\n  public static get instance() { return IModelApp.renderSystem as System; }\n\n  public get isValid(): boolean { return this.canvas !== undefined; }\n  public get lineCodeTexture() { return this._lineCodeTexture; }\n  public get noiseTexture() { return this._noiseTexture; }\n  public get techniques() { return this._techniques!; }\n\n  public get maxTextureSize(): number { return this.capabilities.maxTextureSize; }\n  public get supportsInstancing(): boolean { return this.capabilities.supportsInstancing; }\n\n  public setDrawBuffers(attachments: GLenum[]): void {\n    // NB: The WEBGL_draw_buffers member is not exported directly because that type name is not available in some contexts (e.g. test-imodel-service).\n    if (undefined !== this._drawBuffersExtension)\n      this._drawBuffersExtension.drawBuffersWEBGL(attachments);\n  }\n\n  /** Attempt to create a WebGLRenderingContext, returning undefined if unsuccessful. */\n  public static createContext(canvas: HTMLCanvasElement, contextAttributes?: WebGLContextAttributes): WebGLRenderingContext | undefined {\n    let context = canvas.getContext(\"webgl\", contextAttributes);\n    if (null === context) {\n      context = canvas.getContext(\"experimental-webgl\", contextAttributes); // IE, Edge...\n      if (null === context) {\n        return undefined;\n      }\n    }\n    return context;\n  }\n\n  public static queryRenderCompatibility(): WebGLRenderCompatibilityInfo {\n    const canvas = document.createElement(\"canvas\") as HTMLCanvasElement;\n    if (null === canvas)\n      return { status: WebGLRenderCompatibilityStatus.CannotCreateContext, missingOptionalFeatures: [], missingRequiredFeatures: [] };\n\n    let errorMessage: string | undefined;\n    canvas.addEventListener(\"webglcontextcreationerror\", (event) => {\n      errorMessage = (event as WebGLContextEvent).statusMessage || \"webglcontextcreationerror was triggered with no error provided\";\n    }, false);\n\n    let hasMajorPerformanceCaveat = false;\n    let context = System.createContext(canvas, { failIfMajorPerformanceCaveat: true });\n    if (undefined === context) {\n      hasMajorPerformanceCaveat = true;\n      context = System.createContext(canvas); // try to create context without black-listed GPU\n      if (undefined === context)\n        return { status: WebGLRenderCompatibilityStatus.CannotCreateContext, missingOptionalFeatures: [], missingRequiredFeatures: [] };\n    }\n\n    const capabilities = new Capabilities();\n    const compatibility = capabilities.init(context);\n    compatibility.contextErrorMessage = errorMessage;\n\n    if (hasMajorPerformanceCaveat && compatibility.status !== WebGLRenderCompatibilityStatus.MissingRequiredFeatures)\n      compatibility.status = WebGLRenderCompatibilityStatus.MajorPerformanceCaveat;\n\n    return compatibility;\n  }\n\n  public static create(optionsIn?: RenderSystem.Options): System {\n    const options: RenderSystem.Options = undefined !== optionsIn ? optionsIn : {};\n    const canvas = document.createElement(\"canvas\") as HTMLCanvasElement;\n    if (null === canvas)\n      throw new IModelError(BentleyStatus.ERROR, \"Failed to obtain HTMLCanvasElement\");\n\n    const context = System.createContext(canvas);\n    if (undefined === context) {\n      throw new IModelError(BentleyStatus.ERROR, \"Failed to obtain WebGL context\");\n    }\n\n    const capabilities = Capabilities.create(context, options.disabledExtensions);\n    if (undefined === capabilities)\n      throw new IModelError(BentleyStatus.ERROR, \"Failed to initialize rendering capabilities\");\n\n    // set actual gl state to match desired state defaults\n    context.depthFunc(GL.DepthFunc.Default);  // LessOrEqual\n\n    return new System(canvas, context, capabilities, options);\n  }\n\n  // Note: FrameBuffers inside of the FrameBufferStack are not owned by the System, and are only used as a central storage device\n  public dispose() {\n    this._techniques = dispose(this._techniques);\n    this._lineCodeTexture = dispose(this._lineCodeTexture);\n    this._noiseTexture = dispose(this._noiseTexture);\n\n    // We must attempt to dispose of each idmap in the resourceCache (if idmap is already disposed, has no effect)\n    this.resourceCache.forEach((idMap: IdMap) => {\n      dispose(idMap);\n    });\n\n    this.resourceCache.clear();\n    IModelConnection.onClose.removeListener(this.removeIModelMap);\n  }\n\n  public onInitialized(): void {\n    this._techniques = Techniques.create(this.context);\n\n    const noiseDim = 4;\n    const noiseArr = new Uint8Array([152, 235, 94, 173, 219, 215, 115, 176, 73, 205, 43, 201, 10, 81, 205, 198]);\n    this._noiseTexture = TextureHandle.createForData(noiseDim, noiseDim, noiseArr, false, GL.Texture.WrapMode.Repeat, GL.Texture.Format.Luminance);\n    assert(undefined !== this._noiseTexture, \"System.noiseTexture not created.\");\n\n    this._lineCodeTexture = TextureHandle.createForData(LineCode.size, LineCode.count, new Uint8Array(LineCode.lineCodeData), false, GL.Texture.WrapMode.Repeat, GL.Texture.Format.Luminance);\n    assert(undefined !== this._lineCodeTexture, \"System.lineCodeTexture not created.\");\n  }\n\n  public createTarget(canvas: HTMLCanvasElement): RenderTarget { return new OnScreenTarget(canvas); }\n  public createOffscreenTarget(rect: ViewRect): RenderTarget { return new OffScreenTarget(rect); }\n  public createGraphicBuilder(placement: Transform, type: GraphicType, viewport: Viewport, pickableId?: Id64String): GraphicBuilder { return new PrimitiveBuilder(this, type, viewport, placement, pickableId); }\n\n  public createMesh(params: MeshParams, instances?: InstancedGraphicParams): RenderGraphic | undefined { return MeshGraphic.create(params, instances); }\n  public createPolyline(params: PolylineParams, instances?: InstancedGraphicParams): RenderGraphic | undefined { return Primitive.create(() => PolylineGeometry.create(params), instances); }\n  public createPointString(params: PointStringParams, instances?: InstancedGraphicParams): RenderGraphic | undefined { return Primitive.create(() => PointStringGeometry.create(params), instances); }\n  public createPointCloud(args: PointCloudArgs): RenderGraphic | undefined { return Primitive.create(() => new PointCloudGeometry(args)); }\n\n  public createGraphicList(primitives: RenderGraphic[]): RenderGraphic { return new GraphicsArray(primitives); }\n  public createGraphicBranch(branch: GraphicBranch, transform: Transform, clips?: ClipPlanesVolume | ClipMaskVolume, planarClassifier?: PlanarClassifier): RenderGraphic { return new Branch(branch, transform, clips, undefined, planarClassifier); }\n  public createBatch(graphic: RenderGraphic, features: PackedFeatureTable, range: ElementAlignedBox3d): RenderGraphic { return new Batch(graphic, features, range); }\n\n  public createSkyBox(params: SkyBox.CreateParams): RenderGraphic | undefined {\n    if (undefined !== params.cube) {\n      return SkyCubePrimitive.create(() => SkyBoxQuadsGeometry.create(params.cube!));\n    } else {\n      assert(undefined !== params.sphere || undefined !== params.gradient);\n      return SkySpherePrimitive.create(() => SkySphereViewportQuadGeometry.createGeometry(params));\n    }\n  }\n\n  public applyRenderState(newState: RenderState) {\n    newState.apply(this.currentRenderState);\n    this.currentRenderState.copyFrom(newState);\n  }\n\n  public createDepthBuffer(width: number, height: number): DepthBuffer | undefined {\n    // Note: The buffer/texture created here have ownership passed to the caller (system will not dispose of these)\n    switch (this.capabilities.maxDepthType) {\n      case DepthType.RenderBufferUnsignedShort16: {\n        return RenderBuffer.create(width, height);\n      }\n      case DepthType.TextureUnsignedInt32: {\n        return TextureHandle.createForAttachment(width, height, GL.Texture.Format.DepthComponent, GL.Texture.DataType.UnsignedInt);\n      }\n      case DepthType.TextureUnsignedInt24Stencil8: {\n        const dtExt: WEBGL_depth_texture | undefined = this.capabilities.queryExtensionObject<WEBGL_depth_texture>(\"WEBGL_depth_texture\");\n        return TextureHandle.createForAttachment(width, height, GL.Texture.Format.DepthStencil, dtExt!.UNSIGNED_INT_24_8_WEBGL);\n      }\n      default: {\n        assert(false);\n        return undefined;\n      }\n    }\n  }\n\n  /** Returns the corresponding IdMap for an IModelConnection. Creates a new one if it doesn't exist. */\n  public createIModelMap(imodel: IModelConnection): IdMap {\n    let idMap = this.resourceCache.get(imodel);\n    if (!idMap) {\n      idMap = new IdMap();\n      this.resourceCache.set(imodel, idMap);\n    }\n    return idMap;\n  }\n\n  /** Removes an IModelConnection-IdMap pairing from the system's resource cache. */\n  private removeIModelMap(imodel: IModelConnection) {\n    const idMap = this.resourceCache.get(imodel);\n    if (idMap === undefined)\n      return;\n    dispose(idMap);\n    this.resourceCache.delete(imodel);\n  }\n\n  /** Attempt to create a material for the given iModel using a set of material parameters. */\n  public createMaterial(params: RenderMaterial.Params, imodel: IModelConnection): RenderMaterial | undefined {\n    const idMap = this.getIdMap(imodel);\n    const material = idMap.getMaterial(params);\n    return material;\n  }\n\n  /** Using its key, search for an existing material of an open iModel. */\n  public findMaterial(key: string, imodel: IModelConnection): RenderMaterial | undefined {\n    const idMap = this.resourceCache.get(imodel);\n    if (!idMap)\n      return undefined;\n    return idMap.findMaterial(key);\n  }\n\n  /** Attempt to create a texture for the given iModel using an ImageBuffer. */\n  public createTextureFromImageBuffer(image: ImageBuffer, imodel: IModelConnection, params: RenderTexture.Params): RenderTexture | undefined {\n    return this.getIdMap(imodel).getTexture(image, params);\n  }\n\n  /** Attempt to create a texture for the given iModel using an HTML image element. */\n  public createTextureFromImage(image: HTMLImageElement, hasAlpha: boolean, imodel: IModelConnection | undefined, params: RenderTexture.Params): RenderTexture | undefined {\n    // if imodel is undefined, caller is responsible for disposing texture. It will not be associated with an IModelConnection\n    if (undefined === imodel) {\n      const textureHandle = TextureHandle.createForImage(image, hasAlpha, params.type);\n      return undefined !== textureHandle ? new Texture(params, textureHandle) : undefined;\n    }\n\n    return this.getIdMap(imodel).getTextureFromImage(image, hasAlpha, params);\n  }\n\n  /** Attempt to create a texture from a cube of HTML images. */\n  public createTextureFromCubeImages(posX: HTMLImageElement, negX: HTMLImageElement, posY: HTMLImageElement, negY: HTMLImageElement, posZ: HTMLImageElement, negZ: HTMLImageElement, imodel: IModelConnection, params: RenderTexture.Params): RenderTexture | undefined {\n    return this.getIdMap(imodel).getTextureFromCubeImages(posX, negX, posY, negY, posZ, negZ, params);\n  }\n\n  /** Attempt to create a texture using gradient symbology. */\n  public getGradientTexture(symb: Gradient.Symb, imodel: IModelConnection): RenderTexture | undefined {\n    const idMap = this.getIdMap(imodel);\n    const texture = idMap.getGradient(symb);\n    return texture;\n  }\n\n  /** Using its key, search for an existing texture of an open iModel. */\n  public findTexture(key: string, imodel: IModelConnection): RenderTexture | undefined {\n    const idMap = this.resourceCache.get(imodel);\n    if (!idMap)\n      return undefined;\n    return idMap.findTexture(key);\n  }\n\n  public createClipVolume(clipVector: ClipVector): RenderClipVolume | undefined {\n    let clipVolume: RenderClipVolume | undefined = ClipMaskVolume.create(clipVector);\n    if (undefined === clipVolume)\n      clipVolume = ClipPlanesVolume.create(clipVector);\n\n    return clipVolume;\n  }\n  public getSpatialClassificationModel(modelId: Id64String, iModel: IModelConnection): RenderClassifierModel | undefined { return this.getIdMap(iModel).classifiers.get(modelId); }\n  public addSpatialClassificationModel(modelId: Id64String, classifier: RenderClassifierModel, iModel: IModelConnection) { this.getIdMap(iModel).classifiers.set(modelId, classifier); }\n  public createPlanarClassifier(properties: SpatialClassificationProps.Properties, tileTree: TileTree, classifiedModel: TileTreeModelState, sceneContext: SceneContext): RenderPlanarClassifier | undefined { return PlanarClassifier.create(properties, tileTree, classifiedModel, sceneContext); }\n  /** Solar Shadow Map */\n  public getSolarShadowMap(frustum: Frustum, direction: Vector3d, settings: SolarShadows.Settings, models: ModelSelectorState, categories: CategorySelectorState, iModel: IModelConnection): RenderSolarShadowMap | undefined { return this.getIdMap(iModel).getSolarShadowMap(frustum, direction, settings, models, categories); }\n\n  private constructor(canvas: HTMLCanvasElement, context: WebGLRenderingContext, capabilities: Capabilities, options: RenderSystem.Options) {\n    super(options);\n    this.canvas = canvas;\n    this.context = context;\n    this.capabilities = capabilities;\n    this._drawBuffersExtension = capabilities.queryExtensionObject<WEBGL_draw_buffers>(\"WEBGL_draw_buffers\");\n    this._instancingExtension = capabilities.queryExtensionObject<ANGLE_instanced_arrays>(\"ANGLE_instanced_arrays\");\n    this.resourceCache = new Map<IModelConnection, IdMap>();\n    this.enableOptimizedSurfaceShaders = undefined !== options && true === options.enableOptimizedSurfaceShaders;\n\n    // Make this System a subscriber to the the IModelConnection onClose event\n    IModelConnection.onClose.addListener(this.removeIModelMap.bind(this));\n  }\n\n  private getIdMap(imodel: IModelConnection): IdMap {\n    const map = this.resourceCache.get(imodel);\n    return undefined !== map ? map : this.createIModelMap(imodel);\n  }\n\n  public createSheetTilePolyfaces(corners: Point3d[], clip?: ClipVector): IndexedPolyface[] {\n    const sheetTilePolys: IndexedPolyface[] = [];\n\n    // Texture params for this sheet tile will always go from (0,0) to (1,1). However, we may be dealing with a tile that is a sub-division. Store the\n    // lower-left corner to subtract from point values later to get UV params.\n    const sheetTileRange = Range3d.createArray(corners);\n    const sheetTileScale = 1 / (sheetTileRange.high.x - sheetTileRange.low.x);\n    const sheetTileOrigin = sheetTileRange.low;\n\n    let clippedPolygons: Point3d[][];\n    if (clip !== undefined)\n      clippedPolygons = ClipUtilities.clipPolygonToClipShape(corners, clip.clips[0]); // ###TODO: Currently assume that there is only one shape...\n    else\n      clippedPolygons = [corners];\n\n    if (clippedPolygons.length === 0)\n      return sheetTilePolys;    // return empty\n\n    // The result of clipping will be several polygons, which may lie next to each other, or be detached, and can be of any length. Let's stitch these into a single polyface.\n    const strokeOptions = new StrokeOptions();\n    strokeOptions.needParams = true;\n    strokeOptions.shouldTriangulate = true;\n    const polyfaceBuilder = PolyfaceBuilder.create(strokeOptions);\n\n    for (const polygon of clippedPolygons) {\n      if (polygon.length < 3)\n        continue;\n      else if (polygon.length === 3) {\n        const params: Point2d[] = [];\n        for (const point of polygon) {\n          const paramUnscaled = point.minus(sheetTileOrigin);\n          params.push(Point2d.create(paramUnscaled.x * sheetTileScale, paramUnscaled.y * sheetTileScale));\n        }\n        polyfaceBuilder.addTriangleFacet(polygon, params);\n\n      } else if (polygon.length === 4) {\n        const params: Point2d[] = [];\n        for (const point of polygon) {\n          const paramUnscaled = point.minus(sheetTileOrigin);\n          params.push(Point2d.create(paramUnscaled.x * sheetTileScale, paramUnscaled.y * sheetTileScale));\n        }\n        polyfaceBuilder.addQuadFacet(polygon, params);\n\n      } else {\n        // ### TODO: There are a lot of inefficiencies here (what if it is a simple convex polygon... we must adjust UV params ourselves afterwards, a PolyfaceVisitor....)\n        // We are also assuming that when we use the polyface visitor, it will iterate over the points in order of the entire array\n        const triangulatedPolygon = Triangulator.createTriangulatedGraphFromSingleLoop(polygon);\n        Triangulator.flipTriangles(triangulatedPolygon);\n\n        triangulatedPolygon.announceFaceLoops((_graph: HalfEdgeGraph, edge: HalfEdge): boolean => {\n          if (!edge.isMaskSet(HalfEdgeMask.EXTERIOR)) {\n            const trianglePoints: Point3d[] = [];\n            const params: Point2d[] = [];\n\n            edge.collectAroundFace((node: HalfEdge) => {\n              const point = Point3d.create(node.x, node.y, 0.5);\n              trianglePoints.push(point);\n              const paramUnscaled = point.minus(sheetTileOrigin);\n              params.push(Point2d.create(paramUnscaled.x * sheetTileScale, paramUnscaled.y * sheetTileScale));\n            });\n\n            assert(trianglePoints.length === 3);\n            polyfaceBuilder.addTriangleFacet(trianglePoints, params);\n          }\n          return true;\n        });\n      }\n    }\n\n    sheetTilePolys.push(polyfaceBuilder.claimPolyface());\n    return sheetTilePolys;\n  }\n\n  public createSheetTile(tile: RenderTexture, polyfaces: IndexedPolyface[], tileColor: ColorDef): GraphicList {\n    const sheetTileGraphics: GraphicList = [];\n\n    for (const polyface of polyfaces) {\n      const rawParams = polyface.data.param;\n      if (rawParams === undefined)\n        return sheetTileGraphics;   // return empty\n\n      const meshArgs = new MeshArgs();\n      const pts = polyface.data.point.getPoint3dArray();\n\n      meshArgs.points = new QPoint3dList(QParams3d.fromRange(Range3d.createArray(pts)));  // use these point params\n      for (const point of pts)\n        meshArgs.points.push(QPoint3d.create(point, meshArgs.points.params));\n\n      const uvs: Point2d[] = rawParams.getPoint2dArray();\n\n      const pointIndices: number[] = [];\n      const uvIndices: number[] = [];\n      const visitor = IndexedPolyfaceVisitor.create(polyface, 0);\n      while (visitor.moveToNextFacet()) {\n        for (let i = 0; i < 3; i++) {\n          pointIndices.push(visitor.clientPointIndex(i));\n          uvIndices.push(visitor.clientParamIndex(i));\n        }\n      }\n\n      // make uv arrangement and indices match that of points\n      // this is necessary because MeshArgs assumes vertIndices refers to both points and UVs\n      // output uvsOut to clippedTile\n      let j = 0;\n      const uvsOut: Point2d[] = [];\n      for (const pointIdx of pointIndices)\n        uvsOut[pointIdx] = uvs[uvIndices[j++]];   // passing the reference should not matter\n\n      meshArgs.textureUv = uvsOut;\n      meshArgs.vertIndices = pointIndices;\n      meshArgs.texture = tile;\n      meshArgs.material = undefined;\n      meshArgs.isPlanar = true;\n      meshArgs.colors.initUniform(tileColor);\n\n      const mesh = this.createTriMesh(meshArgs);\n      if (mesh !== undefined)\n        sheetTileGraphics.push(mesh);\n    }\n\n    return sheetTileGraphics;\n  }\n\n  private bindTexture(unit: TextureUnit, target: GL.Texture.Target, texture: TextureBinding): void {\n    const index = unit - TextureUnit.Zero;\n    if (this._textureBindings[index] === texture)\n      return;\n\n    this._textureBindings[index] = texture;\n    this.context.activeTexture(unit);\n    this.context.bindTexture(target, undefined !== texture ? texture : null);\n  }\n\n  public bindTexture2d(unit: TextureUnit, texture: TextureBinding) { this.bindTexture(unit, GL.Texture.Target.TwoDee, texture); }\n  public bindTextureCubeMap(unit: TextureUnit, texture: TextureBinding) { this.bindTexture(unit, GL.Texture.Target.CubeMap, texture); }\n\n  // Ensure *something* is bound to suppress 'no texture assigned to unit x' warnings.\n  public ensureSamplerBound(uniform: UniformHandle, unit: TextureUnit): void {\n    this.lineCodeTexture!.bindSampler(uniform, unit);\n  }\n\n  public disposeTexture(texture: WebGLTexture) {\n    System.instance.context.deleteTexture(texture);\n    for (let i = 0; i < this._textureBindings.length; i++) {\n      if (this._textureBindings[i] === texture) {\n        this._textureBindings[i] = undefined;\n        break;\n      }\n    }\n  }\n\n  // System keeps track of current enabled state of vertex attribute arrays.\n  // This prevents errors caused by leaving a vertex attrib array enabled after disposing of the buffer bound to it;\n  // also prevents unnecessarily 'updating' the enabled state of a vertex attrib array when it hasn't actually changed.\n  public enableVertexAttribArray(id: number, instanced: boolean): void {\n    assert(id < this._nextVertexAttribStates.length, \"if you add new vertex attributes you must update array length\");\n    assert(id < this._curVertexAttribStates.length, \"if you add new vertex attributes you must update array length\");\n\n    this._nextVertexAttribStates[id] = instanced ? VertexAttribState.InstancedEnabled : VertexAttribState.Enabled;\n  }\n\n  public updateVertexAttribArrays(): void {\n    const cur = this._curVertexAttribStates;\n    const next = this._nextVertexAttribStates;\n    const context = this.context;\n\n    for (let i = 0; i < next.length; i++) {\n      const oldState = cur[i];\n      const newState = next[i];\n      if (oldState !== newState) {\n        // Update the enabled state if it changed.\n        const wasEnabled = 0 !== (VertexAttribState.Enabled & oldState);\n        const nowEnabled = 0 !== (VertexAttribState.Enabled & newState);\n        if (wasEnabled !== nowEnabled) {\n          if (nowEnabled) {\n            context.enableVertexAttribArray(i);\n          } else {\n            context.disableVertexAttribArray(i);\n          }\n        }\n\n        // Only update the divisor if the attribute is enabled.\n        if (nowEnabled) {\n          const wasInstanced = 0 !== (VertexAttribState.Instanced & oldState);\n          const nowInstanced = 0 !== (VertexAttribState.Instanced & newState);\n          if (wasInstanced !== nowInstanced) {\n            assert(undefined !== this._instancingExtension);\n            this._instancingExtension!.vertexAttribDivisorANGLE(i, nowInstanced ? 1 : 0);\n          }\n        }\n\n        cur[i] = newState;\n      }\n\n      // Set the attribute back to disabled, but preserve the divisor.\n      next[i] &= ~VertexAttribState.Enabled;\n    }\n  }\n\n  public drawArrays(type: GL.PrimitiveType, first: number, count: number, numInstances: number): void {\n    if (0 !== numInstances) {\n      if (undefined !== this._instancingExtension)\n        this._instancingExtension.drawArraysInstancedANGLE(type, first, count, numInstances);\n    } else {\n      this.context.drawArrays(type, first, count);\n    }\n  }\n\n  public enableDiagnostics(enable: RenderDiagnostics): void {\n    Debug.printEnabled = RenderDiagnostics.None !== (enable & RenderDiagnostics.DebugOutput);\n    Debug.evaluateEnabled = RenderDiagnostics.None !== (enable & RenderDiagnostics.WebGL);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ClipPlaneContainment, ClipUtilities, ClipVector, Transform, Vector3d, Point3d, Matrix4d, Point2d, Range3d, XAndY } from \"@bentley/geometry-core\";\nimport { assert, BeTimePoint, Id64String, Id64, StopWatch, dispose, disposeArray } from \"@bentley/bentleyjs-core\";\nimport { RenderTarget, RenderSystem, Decorations, GraphicList, RenderPlan, ClippingType, CanvasDecoration, Pixel, AnimationBranchStates, PlanarClassifierMap, RenderSolarShadowMap } from \"../System\";\nimport { HiliteSet } from \"../../SelectionSet\";\nimport { ViewFlags, Frustum, Hilite, ColorDef, Npc, RenderMode, ImageBuffer, ImageBufferFormat, AnalysisStyle, RenderTexture, AmbientOcclusion } from \"@bentley/imodeljs-common\";\nimport { FeatureSymbology } from \"../FeatureSymbology\";\nimport { Techniques } from \"./Technique\";\nimport { TechniqueId } from \"./TechniqueId\";\nimport { System } from \"./System\";\nimport { BranchStack, BranchState, BatchState } from \"./BranchState\";\nimport { ShaderFlags, ShaderProgramExecutor } from \"./ShaderProgram\";\nimport { Branch, WorldDecorations, FeatureOverrides, Batch } from \"./Graphic\";\nimport { EdgeOverrides } from \"./EdgeOverrides\";\nimport { ViewRect } from \"../../Viewport\";\nimport { RenderCommands, DrawParams, ShaderProgramParams } from \"./DrawCommand\";\nimport { ColorInfo } from \"./ColorInfo\";\nimport { RenderPass } from \"./RenderFlags\";\nimport { RenderState } from \"./RenderState\";\nimport { GL } from \"./GL\";\nimport { SceneCompositor } from \"./SceneCompositor\";\nimport { FrameBuffer } from \"./FrameBuffer\";\nimport { TextureHandle } from \"./Texture\";\nimport { PlanarClassifier } from \"./PlanarClassifier\";\nimport { CachedGeometry, SingleTexturedViewportQuadGeometry } from \"./CachedGeometry\";\nimport { ShaderLights } from \"./Lighting\";\nimport { ClipDef } from \"./TechniqueFlags\";\nimport { ClipMaskVolume, ClipPlanesVolume } from \"./ClipVolume\";\nimport { FloatRgba } from \"./FloatRGBA\";\nimport { SolarShadowMap } from \"./SolarShadowMap\";\n\n// tslint:disable:no-const-enum\n\n/** @internal */\nexport const enum FrustumUniformType {\n  TwoDee,\n  Orthographic,\n  Perspective,\n}\n\nconst enum Plane {\n  kTop,\n  kBottom,\n  kLeft,\n  kRight,\n}\n\nconst enum FrustumData {\n  kNear,\n  kFar,\n  kType,\n}\n\n/** Represents the frustum for use in glsl as a pair of uniforms.\n * @internal\n */\nexport class FrustumUniforms {\n  private _planeData: Float32Array;\n  private _frustumData: Float32Array;\n\n  public constructor() {\n    const pData = [];\n    pData[Plane.kTop] = 0.0;\n    pData[Plane.kBottom] = 0.0;\n    pData[Plane.kLeft] = 0.0;\n    pData[Plane.kRight] = 0.0;\n    const fData = [];\n    fData[FrustumData.kNear] = 0.0;\n    fData[FrustumData.kFar] = 0.0;\n    fData[FrustumData.kType] = 0.0;\n    this._planeData = new Float32Array(pData);\n    this._frustumData = new Float32Array(fData);\n  }\n\n  public get frustumPlanes(): Float32Array { return this._planeData; }  // uniform vec4 u_frustumPlanes; // { top, bottom, left, right }\n  public get frustum(): Float32Array { return this._frustumData; } // uniform vec3 u_frustum; // { near, far, type }\n  public get nearPlane(): number { return this._frustumData[FrustumData.kNear]; }\n  public get farPlane(): number { return this._frustumData[FrustumData.kFar]; }\n  public get type(): FrustumUniformType { return this.frustum[FrustumData.kType] as FrustumUniformType; }\n  public get is2d(): boolean { return FrustumUniformType.TwoDee === this.type; }\n\n  public setPlanes(top: number, bottom: number, left: number, right: number): void {\n    this._planeData[Plane.kTop] = top;\n    this._planeData[Plane.kBottom] = bottom;\n    this._planeData[Plane.kLeft] = left;\n    this._planeData[Plane.kRight] = right;\n  }\n  public setFrustum(nearPlane: number, farPlane: number, type: FrustumUniformType): void {\n    this._frustumData[FrustumData.kNear] = nearPlane;\n    this._frustumData[FrustumData.kFar] = farPlane;\n    this._frustumData[FrustumData.kType] = type as number;\n  }\n}\n\n/** Interface for 3d GPU clipping.\n * @internal\n */\nexport class Clips {\n  private _texture?: TextureHandle;\n  private _clipActive: number = 0;   // count of SetActiveClip nesting (only outermost used)\n  private _clipCount: number = 0;\n\n  public get texture(): TextureHandle | undefined { return this._texture; }\n  public get count(): number { return this._clipCount; }\n  public get isValid(): boolean { return this._clipCount > 0; }\n\n  public set(numPlanes: number, texture: TextureHandle) {\n    this._clipActive++;\n    if (this._clipActive !== 1)\n      return;\n\n    this._clipCount = numPlanes;\n    this._texture = texture;\n  }\n\n  public clear() {\n    if (this._clipActive === 1) {\n      this._clipCount = 0;\n      this._texture = undefined;\n    }\n    if (this._clipActive > 0)\n      this._clipActive--;\n  }\n}\n\n/** Active classifiers - only the innermost is used.\n * @internal\n */\nexport class PlanarClassifiers {\n  private _classifiers: PlanarClassifier[] = new Array<PlanarClassifier>();\n\n  public get classifier(): PlanarClassifier | undefined { return this._classifiers.length === 0 ? undefined : this._classifiers[this._classifiers.length - 1]; }\n  public get isValid(): boolean { return this._classifiers.length > 0; }\n\n  public push(texture: PlanarClassifier) { this._classifiers.push(texture); }\n  public pop() { this._classifiers.pop(); }\n}\n\n/** @internal */\nexport class PerformanceMetrics {\n  private _lastTimePoint = BeTimePoint.now();\n  public frameTimings = new Map<string, number>();\n  public gatherGlFinish = false;\n  public gatherCurPerformanceMetrics = false;\n  public curSpfTimeIndex = 0;\n  public spfTimes: number[] = [];\n  public spfSum: number = 0;\n  public renderSpfTimes: number[] = [];\n  public renderSpfSum: number = 0;\n  public loadTileTimes: number[] = [];\n  public loadTileSum: number = 0;\n  public fpsTimer: StopWatch = new StopWatch(undefined, true);\n  public fpsTimerStart: number = 0;\n\n  public constructor(gatherGlFinish = false, gatherCurPerformanceMetrics = false) {\n    this.gatherGlFinish = gatherGlFinish;\n    this.gatherCurPerformanceMetrics = gatherCurPerformanceMetrics;\n  }\n\n  public startNewFrame(sceneTime: number = 0) {\n    this.frameTimings = new Map<string, number>();\n    this.frameTimings.set(\"Scene Time\", sceneTime);\n    this._lastTimePoint = BeTimePoint.now();\n  }\n\n  public recordTime(operationName: string) {\n    const newTimePoint = BeTimePoint.now();\n    this.frameTimings.set(operationName, (newTimePoint.milliseconds - this._lastTimePoint.milliseconds));\n    this._lastTimePoint = BeTimePoint.now();\n  }\n\n  public endFrame(operationName?: string) {\n    const newTimePoint = BeTimePoint.now();\n    let sum = 0;\n    let prevGPUTime = 0;\n    this.frameTimings.forEach((value, key) => {\n      if (key === \"Finish GPU Queue\")\n        prevGPUTime = value;\n      else\n        sum += value;\n    });\n    this.frameTimings.set(\"Total Render Time\", sum);\n    const lastTiming = (newTimePoint.milliseconds - this._lastTimePoint.milliseconds);\n    this.frameTimings.set(operationName ? operationName : \"Finish GPU Queue\", lastTiming);\n    this.frameTimings.set(\"Total Time\", sum + prevGPUTime + lastTiming);\n    this._lastTimePoint = BeTimePoint.now();\n  }\n}\n\nfunction swapImageByte(image: ImageBuffer, i0: number, i1: number) {\n  const tmp = image.data[i0];\n  image.data[i0] = image.data[i1];\n  image.data[i1] = tmp;\n}\n\ntype ClipVolume = ClipPlanesVolume | ClipMaskVolume;\n\n/** Used for debugging purposes, to toggle display of instanced or batched primitives.\n * @internal\n */\nexport const enum PrimitiveVisibility {\n  /** Draw all primitives. */\n  All,\n  /** Only draw instanced primitives. */\n  Instanced,\n  /** Only draw un-instanced primitives. */\n  Uninstanced,\n}\n\n/** @internal */\nexport interface Hilites {\n  readonly elements: Id64.Uint32Set;\n  readonly subcategories: Id64.Uint32Set;\n  readonly models: Id64.Uint32Set;\n  readonly isEmpty: boolean;\n}\n\nclass EmptyHiliteSet {\n  public readonly elements: Id64.Uint32Set;\n  public readonly subcategories: Id64.Uint32Set;\n  public readonly models: Id64.Uint32Set;\n  public readonly isEmpty = true;\n\n  public constructor() {\n    this.elements = this.subcategories = this.models = new Id64.Uint32Set();\n  }\n}\n\n/** @internal */\nexport abstract class Target extends RenderTarget {\n  protected _decorations?: Decorations;\n  private _stack = new BranchStack();\n  private _batchState = new BatchState();\n  private _scene: GraphicList = [];\n  private _backgroundMap: GraphicList = [];\n  private _planarClassifiers?: PlanarClassifierMap;\n  private _dynamics?: GraphicList;\n  private _worldDecorations?: WorldDecorations;\n  private _overridesUpdateTime = BeTimePoint.now();\n  private _hilites: Hilites = new EmptyHiliteSet();\n  private _hiliteUpdateTime = BeTimePoint.now();\n  private _flashed: Id64.Uint32Pair = { lower: 0, upper: 0 };\n  private _flashedId = Id64.invalid;\n  private _flashedUpdateTime = BeTimePoint.now();\n  private _flashIntensity: number = 0;\n  private _transparencyThreshold: number = 0;\n  private _renderCommands: RenderCommands;\n  private _overlayRenderState: RenderState;\n  protected _compositor: SceneCompositor;\n  private _activeClipVolume?: ClipVolume;\n  private _clipMask?: TextureHandle;\n  public readonly clips = new Clips();\n  public readonly planarClassifiers = new PlanarClassifiers();\n  protected _fbo?: FrameBuffer;\n  private _fStop: number = 0;\n  private _ambientLight: Float32Array = new Float32Array(3);\n  private _shaderLights?: ShaderLights;\n  protected _dcAssigned: boolean = false;\n  public performanceMetrics?: PerformanceMetrics;\n  public readonly decorationState = BranchState.createForDecorations(); // Used when rendering view background and view/world overlays.\n  public readonly frustumUniforms = new FrustumUniforms();\n  public readonly bgColor = FloatRgba.fromColorDef(ColorDef.red);\n  public readonly monoColor = FloatRgba.fromColorDef(ColorDef.white);\n  public hiliteSettings = new Hilite.Settings();\n  public hiliteColor = FloatRgba.fromColorDef(this.hiliteSettings.color);\n  public readonly planFrustum = new Frustum();\n  public readonly renderRect = new ViewRect();\n  private _planFraction: number = 0;\n  public readonly nearPlaneCenter = new Point3d();\n  public readonly viewMatrix = Transform.createIdentity();\n  public readonly projectionMatrix = Matrix4d.createIdentity();\n  private readonly _visibleEdgeOverrides = new EdgeOverrides();\n  private readonly _hiddenEdgeOverrides = new EdgeOverrides();\n  public analysisStyle?: AnalysisStyle;\n  public analysisTexture?: RenderTexture;\n  private _currentOverrides?: FeatureOverrides;\n  public ambientOcclusionSettings = AmbientOcclusion.Settings.defaults;\n  private _wantAmbientOcclusion = false;\n  private _batches: Batch[] = [];\n  public plan?: RenderPlan;\n  private _animationBranches?: AnimationBranchStates;\n  private _isReadPixelsInProgress = false;\n  private _readPixelsSelector = Pixel.Selector.None;\n  private _drawNonLocatable = true;\n  public isFadeOutActive = false;\n  public primitiveVisibility: PrimitiveVisibility = PrimitiveVisibility.All;\n  private _solarShadowMap?: SolarShadowMap;\n\n  protected constructor(rect?: ViewRect) {\n    super();\n    this._renderCommands = new RenderCommands(this, this._stack, this._batchState);\n    this._overlayRenderState = new RenderState();\n    this._overlayRenderState.flags.depthMask = false;\n    this._overlayRenderState.flags.blend = true;\n    this._overlayRenderState.blend.setBlendFunc(GL.BlendFactor.One, GL.BlendFactor.OneMinusSrcAlpha);\n    this._compositor = SceneCompositor.create(this);  // compositor is created but not yet initialized... we are still undisposed\n    this.renderRect = rect ? rect : new ViewRect();  // if the rect is undefined, expect that it will be updated dynamically in an OnScreenTarget\n  }\n\n  public get compositor() { return this._compositor; }\n  public get isReadPixelsInProgress(): boolean { return this._isReadPixelsInProgress; }\n  public get readPixelsSelector(): Pixel.Selector { return this._readPixelsSelector; }\n  public get drawNonLocatable(): boolean { return this._drawNonLocatable; }\n\n  public get currentOverrides(): FeatureOverrides | undefined { return this._currentOverrides; }\n  public set currentOverrides(ovr: FeatureOverrides | undefined) {\n    // Don't bother setting up overrides if they don't actually override anything - wastes time doing texture lookups in shaders.\n    this._currentOverrides = (undefined !== ovr && ovr.anyOverridden) ? ovr : undefined;\n  }\n\n  public get transparencyThreshold(): number { return this._transparencyThreshold; }\n  public get techniques(): Techniques { return System.instance.techniques!; }\n\n  public get hilites(): Hilites { return this._hilites; }\n  public get hiliteUpdateTime(): BeTimePoint { return this._hiliteUpdateTime; }\n\n  public get flashed(): Id64.Uint32Pair | undefined { return Id64.isValid(this._flashedId) ? this._flashed : undefined; }\n  public get flashedId(): Id64String { return this._flashedId; }\n  public get flashedUpdateTime(): BeTimePoint { return this._flashedUpdateTime; }\n  public get flashIntensity(): number { return this._flashIntensity; }\n\n  public get overridesUpdateTime(): BeTimePoint { return this._overridesUpdateTime; }\n\n  public get fStop(): number { return this._fStop; }\n  public get ambientLight(): Float32Array { return this._ambientLight; }\n  public get shaderLights(): ShaderLights | undefined { return this._shaderLights; }\n\n  public get scene(): GraphicList { return this._scene; }\n  public get dynamics(): GraphicList | undefined { return this._dynamics; }\n\n  public get animationBranches(): AnimationBranchStates | undefined { return this._animationBranches; }\n  public set animationBranches(branches: AnimationBranchStates | undefined) { this._animationBranches = branches; }\n  public get branchStack(): BranchStack { return this._stack; }\n  public get solarShadowMap(): SolarShadowMap | undefined { return this._solarShadowMap; }\n\n  public getWorldDecorations(decs: GraphicList): Branch {\n    if (undefined === this._worldDecorations) {\n\n      // Don't allow flags like monochrome etc to affect world decorations. Allow lighting in 3d only.\n      const vf = new ViewFlags();\n      vf.renderMode = RenderMode.SmoothShade;\n      vf.clipVolume = false;\n\n      const showLights = !this.is2d;\n      vf.sourceLights = showLights;\n      vf.cameraLights = showLights;\n      vf.solarLight = showLights;\n\n      this._worldDecorations = new WorldDecorations(vf);\n    }\n\n    this._worldDecorations.init(decs);\n    return this._worldDecorations;\n  }\n\n  public get currentViewFlags(): ViewFlags { return this._stack.top.viewFlags; }\n  public get currentTransform(): Transform { return this._stack.top.transform; }\n  public get currentShaderFlags(): ShaderFlags { return this.currentViewFlags.monochrome ? ShaderFlags.Monochrome : ShaderFlags.None; }\n  public get currentFeatureSymbologyOverrides(): FeatureSymbology.Overrides { return this._stack.top.symbologyOverrides; }\n\n  public get clipDef(): ClipDef {\n    if (this.hasClipVolume)\n      return new ClipDef(ClippingType.Planes, this.clips.count);\n    else if (this.hasClipMask)\n      return new ClipDef(ClippingType.Mask);\n    else\n      return new ClipDef();\n  }\n  public get hasClipVolume(): boolean { return this.clips.isValid && this._stack.top.showClipVolume; }\n  public get hasClipMask(): boolean { return undefined !== this.clipMask; }\n  public get clipMask(): TextureHandle | undefined { return this._clipMask; }\n  public set clipMask(mask: TextureHandle | undefined) {\n    assert((mask === undefined) === this.hasClipMask);\n    assert(this.is2d);\n    this._clipMask = mask;\n  }\n\n  public get is2d(): boolean { return this.frustumUniforms.is2d; }\n  public get is3d(): boolean { return !this.is2d; }\n\n  public dispose() {\n    this.reset();\n\n    dispose(this._compositor);\n\n    this._dcAssigned = false;   // necessary to reassign to OnScreenTarget fbo member when re-validating render plan\n  }\n\n  public pushBranch(exec: ShaderProgramExecutor, branch: Branch): void {\n    this._stack.pushBranch(branch);\n    const clip = this._stack.top.clipVolume;\n    if (undefined !== clip) {\n      clip.pushToShaderExecutor(exec);\n    }\n    const planarClassifier = this._stack.top.planarClassifier;\n    if (undefined !== planarClassifier)\n      planarClassifier.push(exec);\n  }\n  public pushState(state: BranchState) {\n    assert(undefined === state.clipVolume);\n    this._stack.pushState(state);\n  }\n  public popBranch(): void {\n    const clip = this._stack.top.clipVolume;\n    if (undefined !== clip) {\n      clip.pop(this);\n    }\n    const planarClassifier = this._stack.top.planarClassifier;\n    if (undefined !== planarClassifier)\n      planarClassifier.pop(this);\n\n    this._stack.pop();\n  }\n\n  public pushActiveVolume(): void {\n    if (this._activeClipVolume !== undefined)\n      this._activeClipVolume.pushToTarget(this);\n  }\n\n  public popActiveVolume(): void {\n    if (this._activeClipVolume !== undefined)\n      this._activeClipVolume.pop(this);\n  }\n\n  private updateActiveVolume(clip?: ClipVector): void {\n    if (undefined === clip) {\n      this._activeClipVolume = dispose(this._activeClipVolume);\n      return;\n    }\n\n    // ###TODO: Currently we assume the active view ClipVector is never mutated in place.\n    // ###TODO: We may want to compare differing ClipVectors to determine if they are logically equivalent to avoid reallocating clip volume.\n    if (undefined === this._activeClipVolume || this._activeClipVolume.clipVector !== clip) {\n      this._activeClipVolume = dispose(this._activeClipVolume);\n      this._activeClipVolume = System.instance.createClipVolume(clip) as ClipVolume;\n    }\n  }\n\n  private _scratchRangeCorners: Point3d[] = [\n    new Point3d(), new Point3d(), new Point3d(), new Point3d(),\n    new Point3d(), new Point3d(), new Point3d(), new Point3d(),\n  ];\n\n  private _getRangeCorners(r: Range3d): Point3d[] {\n    const p = this._scratchRangeCorners;\n    p[0].setFromPoint3d(r.low);\n    p[1].set(r.high.x, r.low.y, r.low.z),\n    p[2].set(r.low.x, r.high.y, r.low.z),\n    p[3].set(r.high.x, r.high.y, r.low.z),\n    p[4].set(r.low.x, r.low.y, r.high.z),\n    p[5].set(r.high.x, r.low.y, r.high.z),\n    p[6].set(r.low.x, r.high.y, r.high.z),\n    p[7].setFromPoint3d(r.high);\n    return p;\n  }\n\n  /** @internal */\n  public isRangeOutsideActiveVolume(range: Range3d): boolean {\n    if (undefined === this._activeClipVolume || !this._stack.top.showClipVolume || !this.clips.isValid)\n      return false;\n\n    range = this.currentTransform.multiplyRange(range, range);\n\n    const testIntersection = false;\n    if (testIntersection) {\n      // ###TODO: Avoid allocation of Range3d inside called function...\n      // ###TODO: Use some not-yet-existent API which will return as soon as it determines ANY intersection (we don't care about the actual intersection range).\n      const clippedRange = ClipUtilities.rangeOfClipperIntersectionWithRange(this._activeClipVolume.clipVector, range);\n      return clippedRange.isNull;\n    } else {\n      // Do the cheap, imprecise check. The above is far too slow and allocates way too many objects, especially for clips produced from non-convex shapes.\n      return ClipPlaneContainment.StronglyOutside === this._activeClipVolume.clipVector.classifyPointContainment(this._getRangeCorners(range));\n    }\n  }\n\n  private readonly _scratchRange = new Range3d();\n  /** @internal */\n  public isGeometryOutsideActiveVolume(geom: CachedGeometry): boolean {\n    if (undefined === this._activeClipVolume || !this._stack.top.showClipVolume || !this.clips.isValid)\n      return false;\n\n    const range = geom.computeRange(this._scratchRange);\n    return this.isRangeOutsideActiveVolume(range);\n  }\n\n  public get batchState(): BatchState { return this._batchState; }\n  public get currentBatchId(): number { return this._batchState.currentBatchId; }\n  public pushBatch(batch: Batch) {\n    this._batchState.push(batch, false);\n    this.currentOverrides = batch.getOverrides(this);\n  }\n  public popBatch() {\n    this.currentOverrides = undefined;\n    this._batchState.pop();\n  }\n\n  public addBatch(batch: Batch) {\n    assert(this._batches.indexOf(batch) < 0);\n    this._batches.push(batch);\n  }\n\n  public onBatchDisposed(batch: Batch) {\n    const index = this._batches.indexOf(batch);\n    assert(index > -1);\n    this._batches.splice(index, 1);\n  }\n\n  public get wantAmbientOcclusion(): boolean {\n    return this._wantAmbientOcclusion;\n  }\n\n  // ---- Implementation of RenderTarget interface ---- //\n\n  public get renderSystem(): RenderSystem { return System.instance; }\n  public get cameraFrustumNearScaleLimit() {\n    return 0; // ###TODO\n  }\n  public get planFraction() { return this._planFraction; }\n\n  public changeDecorations(decs: Decorations): void {\n    dispose(this._decorations);\n    this._decorations = decs;\n  }\n  public changeScene(scene: GraphicList) {\n    this._scene = scene;\n  }\n  public changeBackgroundMap(backgroundMap: GraphicList) {\n    this._backgroundMap = backgroundMap;\n  }\n  public changePlanarClassifiers(planarClassifiers?: PlanarClassifierMap) {\n    if (this._planarClassifiers)\n      for (const planarClassifier of this._planarClassifiers)\n        planarClassifier[1].dispose();\n\n    this._planarClassifiers = planarClassifiers;\n  }\n  public changeSolarShadowMap(solarShadowMap?: RenderSolarShadowMap): void {\n    this._solarShadowMap = solarShadowMap as SolarShadowMap;\n  }\n\n  public changeDynamics(dynamics?: GraphicList) {\n    // ###TODO: set feature IDs into each graphic so that edge display works correctly...\n    // See IModelConnection.transientIds\n    disposeArray(this._dynamics);\n    this._dynamics = dynamics;\n  }\n  public overrideFeatureSymbology(ovr: FeatureSymbology.Overrides): void {\n    this._stack.setSymbologyOverrides(ovr);\n    this._overridesUpdateTime = BeTimePoint.now();\n  }\n  public setHiliteSet(hilite: HiliteSet): void {\n    this._hilites = hilite;\n    this._hiliteUpdateTime = BeTimePoint.now();\n  }\n  public setFlashed(id: Id64String, intensity: number) {\n    if (id !== this._flashedId) {\n      this._flashedId = id;\n      this._flashed = Id64.getUint32Pair(id);\n      this._flashedUpdateTime = BeTimePoint.now();\n    }\n\n    this._flashIntensity = intensity;\n  }\n  private static _scratch = {\n    viewFlags: new ViewFlags(),\n    nearCenter: new Point3d(),\n    viewX: new Vector3d(),\n    viewY: new Vector3d(),\n    viewZ: new Vector3d(),\n    vec3: new Vector3d(),\n    point3: new Point3d(),\n    //  visibleEdges: new HiddenLine.Style({}),\n    // hiddenEdges: new HiddenLine.Style({ ovrColor: false, color: new ColorDef(ColorByName.white), width: 1, pattern: LinePixels.HiddenLine }),\n    animationDisplay: undefined,\n  };\n\n  public changeFrustum(newFrustum: Frustum, newFraction: number, is3d: boolean): void {\n    newFrustum.clone(this.planFrustum);\n\n    const farLowerLeft = newFrustum.getCorner(Npc.LeftBottomRear);\n    const farLowerRight = newFrustum.getCorner(Npc.RightBottomRear);\n    const farUpperLeft = newFrustum.getCorner(Npc.LeftTopRear);\n    const farUpperRight = newFrustum.getCorner(Npc.RightTopRear);\n    const nearLowerLeft = newFrustum.getCorner(Npc.LeftBottomFront);\n    const nearLowerRight = newFrustum.getCorner(Npc.RightBottomFront);\n    const nearUpperLeft = newFrustum.getCorner(Npc.LeftTopFront);\n    const nearUpperRight = newFrustum.getCorner(Npc.RightTopFront);\n\n    const scratch = Target._scratch;\n    const nearCenter = nearLowerLeft.interpolate(0.5, nearUpperRight, scratch.nearCenter);\n\n    const viewX = normalizedDifference(nearLowerRight, nearLowerLeft, scratch.viewX);\n    const viewY = normalizedDifference(nearUpperLeft, nearLowerLeft, scratch.viewY);\n    const viewZ = viewX.crossProduct(viewY, scratch.viewZ).normalize()!;\n\n    this._planFraction = newFraction;\n\n    if (!is3d) {\n      const halfWidth = Vector3d.createStartEnd(farLowerRight, farLowerLeft, scratch.vec3).magnitude() * 0.5;\n      const halfHeight = Vector3d.createStartEnd(farLowerRight, farUpperRight).magnitude() * 0.5;\n      const depth = 2 * RenderTarget.frustumDepth2d;\n\n      this.nearPlaneCenter.set(nearCenter.x, nearCenter.y, RenderTarget.frustumDepth2d);\n\n      lookIn(this.nearPlaneCenter, viewX, viewY, viewZ, this.viewMatrix);\n      ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, 0, depth, this.projectionMatrix);\n\n      this.frustumUniforms.setPlanes(halfHeight, -halfHeight, -halfWidth, halfWidth);\n      this.frustumUniforms.setFrustum(0, depth, FrustumUniformType.TwoDee);\n    } else if (newFraction > 0.999) { // ortho\n      const halfWidth = Vector3d.createStartEnd(farLowerRight, farLowerLeft, scratch.vec3).magnitude() * 0.5;\n      const halfHeight = Vector3d.createStartEnd(farLowerRight, farUpperRight).magnitude() * 0.5;\n      const depth = Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratch.vec3).magnitude();\n\n      lookIn(nearCenter, viewX, viewY, viewZ, this.viewMatrix);\n      ortho(-halfWidth, halfWidth, -halfHeight, halfHeight, 0, depth, this.projectionMatrix);\n\n      this.nearPlaneCenter.setFrom(nearLowerLeft);\n      this.nearPlaneCenter.interpolate(0.5, nearUpperRight, this.nearPlaneCenter);\n\n      this.frustumUniforms.setPlanes(halfHeight, -halfHeight, -halfWidth, halfWidth);\n      this.frustumUniforms.setFrustum(0, depth, FrustumUniformType.Orthographic);\n    } else { // perspective\n      const scale = 1.0 / (1.0 - newFraction);\n      const zVec = Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratch.vec3);\n      const cameraPosition = fromSumOf(farLowerLeft, zVec, scale, scratch.point3);\n\n      const frustumLeft = dotDifference(farLowerLeft, cameraPosition, viewX) * newFraction;\n      const frustumRight = dotDifference(farLowerRight, cameraPosition, viewX) * newFraction;\n      const frustumBottom = dotDifference(farLowerLeft, cameraPosition, viewY) * newFraction;\n      const frustumTop = dotDifference(farUpperLeft, cameraPosition, viewY) * newFraction;\n      const frustumFront = -dotDifference(nearLowerLeft, cameraPosition, viewZ);\n      const frustumBack = -dotDifference(farLowerLeft, cameraPosition, viewZ);\n\n      lookIn(cameraPosition, viewX, viewY, viewZ, this.viewMatrix);\n      frustum(frustumLeft, frustumRight, frustumBottom, frustumTop, frustumFront, frustumBack, this.projectionMatrix);\n\n      this.nearPlaneCenter.setFrom(nearLowerLeft);\n      this.nearPlaneCenter.interpolate(0.5, nearUpperRight, this.nearPlaneCenter);\n\n      this.frustumUniforms.setPlanes(frustumTop, frustumBottom, frustumLeft, frustumRight);\n      this.frustumUniforms.setFrustum(frustumFront, frustumBack, FrustumUniformType.Perspective);\n    }\n  }\n\n  public changeRenderPlan(plan: RenderPlan): void {\n    this.plan = plan;\n\n    if (this._dcAssigned && plan.is3d !== this.is3d) {\n      // changed the dimensionality of the Target. World decorations no longer valid.\n      // (lighting is enabled or disabled based on 2d vs 3d).\n      this._worldDecorations = dispose(this._worldDecorations);\n    }\n\n    if (!this.assignDC()) {\n      assert(false);\n      return;\n    }\n\n    this.bgColor.setFromColorDef(plan.bgColor);\n    this.monoColor.setFromColorDef(plan.monoColor);\n    this.hiliteSettings = plan.hiliteSettings;\n    this.hiliteColor.setFromColorDef(this.hiliteSettings.color);\n    this.isFadeOutActive = plan.isFadeOutActive;\n    this._transparencyThreshold = 0.0;\n    this.analysisStyle = plan.analysisStyle === undefined ? undefined : plan.analysisStyle.clone();\n    this.analysisTexture = plan.analysisTexture;\n\n    this.updateActiveVolume(plan.activeVolume);\n\n    const scratch = Target._scratch;\n    let visEdgeOvrs = undefined !== plan.hline ? plan.hline.visible : undefined;\n    let hidEdgeOvrs = undefined !== plan.hline ? plan.hline.hidden : undefined;\n\n    const vf = ViewFlags.createFrom(plan.viewFlags, scratch.viewFlags);\n    let forceEdgesOpaque = true; // most render modes want edges to be opaque so don't allow overrides to their alpha\n    switch (vf.renderMode) {\n      case RenderMode.Wireframe: {\n        // Edge overrides never apply in wireframe mode\n        vf.visibleEdges = false;\n        vf.hiddenEdges = false;\n        forceEdgesOpaque = false;\n        break;\n      }\n      case RenderMode.SmoothShade: {\n        // Hidden edges require visible edges\n        if (!vf.visibleEdges)\n          vf.hiddenEdges = false;\n\n        break;\n      }\n      case RenderMode.SolidFill: {\n        // In solid fill, if the edge color is not overridden, the edges do not use the element's line color\n        if (undefined !== visEdgeOvrs && !visEdgeOvrs.ovrColor) {\n          // ###TODO? Probably supposed to be contrast with fill and/or background color...\n          assert(undefined !== hidEdgeOvrs);\n          visEdgeOvrs = visEdgeOvrs.overrideColor(ColorDef.white);\n          hidEdgeOvrs = hidEdgeOvrs!.overrideColor(ColorDef.white);\n        }\n      }\n      /* falls through */\n      case RenderMode.HiddenLine: {\n        // In solid fill and hidden line mode, visible edges always rendered and edge overrides always apply\n        vf.visibleEdges = true;\n\n        assert(undefined !== plan.hline); // these render modes only supported in 3d, in which case hline always initialized\n        if (undefined !== plan.hline) {\n          // The threshold in HiddenLineParams ranges from 0.0 (hide anything that's not 100% opaque)\n          // to 1.0 (don't hide anything regardless of transparency). Convert it to an alpha value.\n          let threshold = plan.hline.transparencyThreshold;\n          threshold = Math.min(1.0, Math.max(0.0, threshold));\n          this._transparencyThreshold = 1.0 - threshold;\n        }\n\n        break;\n      }\n    }\n\n    if (RenderMode.SmoothShade === vf.renderMode && plan.is3d && undefined !== plan.ao && vf.ambientOcclusion) {\n      this._wantAmbientOcclusion = true;\n      this.ambientOcclusionSettings = plan.ao;\n    } else {\n      this._wantAmbientOcclusion = vf.ambientOcclusion = false;\n    }\n\n    this._visibleEdgeOverrides.init(forceEdgesOpaque, visEdgeOvrs);\n    this._hiddenEdgeOverrides.init(forceEdgesOpaque, hidEdgeOvrs);\n\n    this._stack.setViewFlags(vf);\n\n    this.changeFrustum(plan.frustum, plan.fraction, plan.is3d);\n\n    // this.shaderlights.clear // ###TODO : Lighting\n    this._fStop = 0.0;\n    this._ambientLight[0] = 0.2;\n    this._ambientLight[1] = 0.2;\n    this._ambientLight[2] = 0.2;\n    if (plan.is3d && undefined !== plan.lights) {\n      // convertLights(...); // TODO: Lighting\n      this._fStop = plan.lights.fstop;\n    }\n  }\n\n  public drawFrame(sceneMilSecElapsed?: number): void {\n    assert(System.instance.frameBufferStack.isEmpty);\n    if (undefined === this._scene) {\n      return;\n    }\n\n    this.paintScene(sceneMilSecElapsed);\n    this.drawOverlayDecorations();\n    assert(System.instance.frameBufferStack.isEmpty);\n  }\n\n  protected drawOverlayDecorations(): void { }\n\n  /*\n   * Invoked via Viewport.changeView() when the owning Viewport is changed to look at a different view.\n   * Invoked via dispose() when the target is being destroyed.\n   * The primary difference is that in the former case we retain the SceneCompositor.\n   */\n  public reset(): void {\n    // Clear the scene\n    this._scene.length = 0;\n\n    // Clear decorations\n    this._decorations = dispose(this._decorations);\n    this._dynamics = disposeArray(this._dynamics);\n    this._worldDecorations = dispose(this._worldDecorations);\n\n    // Clear render commands\n    this._renderCommands.clear();\n\n    // Clear FeatureOverrides for this Target.\n    // This may not be strictly necessary as the Target may still be viewing some of these batches, but better to clean up and recreate\n    // than to leave unused in memory.\n    for (const batch of this._batches)\n      batch.onTargetDisposed(this);\n\n    this._batches = [];\n\n    this._activeClipVolume = dispose(this._activeClipVolume);\n  }\n\n  public get wantInvertBlackBackground(): boolean { return false; }\n\n  public get visibleEdgeOverrides(): EdgeOverrides | undefined { return this.getEdgeOverrides(RenderPass.OpaqueLinear); }\n  public get hiddenEdgeOverrides(): EdgeOverrides | undefined { return this.getEdgeOverrides(RenderPass.HiddenEdge); }\n  public get isEdgeColorOverridden(): boolean {\n    const ovrs = this.visibleEdgeOverrides;\n    return undefined !== ovrs && ovrs.overridesColor;\n  }\n  public get isEdgeWeightOverridden(): boolean {\n    const ovrs = this.visibleEdgeOverrides;\n    return undefined !== ovrs && ovrs.overridesWeight;\n  }\n  public getEdgeOverrides(pass: RenderPass): EdgeOverrides | undefined {\n    let ovrs: EdgeOverrides | undefined;\n    let enabled = false;\n    if (RenderPass.HiddenEdge === pass) {\n      ovrs = this._hiddenEdgeOverrides;\n      enabled = this.currentViewFlags.hiddenEdges;\n    } else {\n      ovrs = this._visibleEdgeOverrides;\n      enabled = this.currentViewFlags.visibleEdges;\n    }\n\n    return enabled ? ovrs : undefined;\n  }\n  public getEdgeWeight(params: ShaderProgramParams, baseWeight: number): number {\n    const ovrs = this.getEdgeOverrides(params.renderPass);\n    return undefined !== ovrs && undefined !== ovrs.weight ? ovrs.weight : baseWeight;\n  }\n  public getEdgeLineCode(params: ShaderProgramParams, baseCode: number): number {\n    const ovrs = this.getEdgeOverrides(params.renderPass);\n    return undefined !== ovrs && undefined !== ovrs.lineCode ? ovrs.lineCode : baseCode;\n  }\n  public get edgeColor(): ColorInfo {\n    assert(this.isEdgeColorOverridden);\n    return ColorInfo.createUniform(this._visibleEdgeOverrides.color!);\n  }\n\n  private _doDebugPaint: boolean = false;\n  protected debugPaint(): void { }\n\n  public recordPerformanceMetric(operation: string): void {\n    if (this.performanceMetrics)\n      this.performanceMetrics.recordTime(operation);\n  }\n\n  private paintScene(sceneMilSecElapsed?: number): void {\n    if (this._doDebugPaint) {\n      this.debugPaint();\n      return;\n    }\n\n    if (!this._dcAssigned) {\n      return;\n    }\n\n    if (this.performanceMetrics) this.performanceMetrics.startNewFrame(sceneMilSecElapsed);\n    this._beginPaint();\n\n    const gl = System.instance.context;\n    const rect = this.viewRect;\n    gl.viewport(0, 0, rect.width, rect.height);\n\n    // Set this to true to visualize the output of readPixels()...useful for debugging pick.\n    const drawForReadPixels = false;\n    if (drawForReadPixels) {\n      this._isReadPixelsInProgress = true;\n      this._readPixelsSelector = Pixel.Selector.Feature;\n\n      this.recordPerformanceMetric(\"Begin Paint\");\n      const vf = this.currentViewFlags.clone(this._scratchViewFlags);\n      vf.transparency = false;\n      vf.textures = false;\n      vf.sourceLights = false;\n      vf.cameraLights = false;\n      vf.solarLight = false;\n      vf.shadows = false;\n      vf.noGeometryMap = true;\n      vf.acsTriad = false;\n      vf.grid = false;\n      vf.monochrome = false;\n      vf.materials = false;\n\n      const state = BranchState.create(this._stack.top.symbologyOverrides, vf);\n      this.pushState(state);\n\n      this._renderCommands.init(this._scene, this._backgroundMap, this._decorations, this._dynamics, true);\n      this.recordPerformanceMetric(\"Init Commands\");\n      this.compositor.drawForReadPixels(this._renderCommands);\n      this._stack.pop();\n\n      this._isReadPixelsInProgress = false;\n    } else {\n      this.recordPerformanceMetric(\"Begin Draw Planar Classifiers\");\n      this.drawPlanarClassifiers();\n      this.recordPerformanceMetric(\"Begin Draw Shadow Maps\");\n      this.drawSolarShadowMap();\n      this.recordPerformanceMetric(\"Begin Paint\");\n      this._renderCommands.init(this._scene, this._backgroundMap, this._decorations, this._dynamics);\n\n      this.recordPerformanceMetric(\"Init Commands\");\n      this.compositor.draw(this._renderCommands); // scene compositor gets disposed and then re-initialized... target remains undisposed\n\n      this._stack.pushState(this.decorationState);\n      this.drawPass(RenderPass.WorldOverlay);\n      this.drawPass(RenderPass.ViewOverlay);\n      this._stack.pop();\n\n      this.recordPerformanceMetric(\"Overlay Draws\");\n    }\n\n    // Reset the batch IDs in all batches drawn for this call.\n    this._batchState.reset();\n\n    this._endPaint();\n    this.recordPerformanceMetric(\"End Paint\");\n\n    if (this.performanceMetrics) {\n      if (this.performanceMetrics.gatherCurPerformanceMetrics) {\n        const perfMet = this.performanceMetrics;\n        const fpsTimerElapsed = perfMet.fpsTimer.currentSeconds - perfMet.fpsTimerStart;\n        if (perfMet.spfTimes[perfMet.curSpfTimeIndex]) perfMet.spfSum -= perfMet.spfTimes[perfMet.curSpfTimeIndex];\n        perfMet.spfSum += fpsTimerElapsed;\n        perfMet.spfTimes[perfMet.curSpfTimeIndex] = fpsTimerElapsed;\n\n        let renderTimeElapsed = 0;\n        perfMet.frameTimings.forEach((val) => {\n          renderTimeElapsed += val;\n        });\n        if (perfMet.renderSpfTimes[perfMet.curSpfTimeIndex]) perfMet.renderSpfSum -= perfMet.renderSpfTimes[perfMet.curSpfTimeIndex];\n        perfMet.renderSpfSum += renderTimeElapsed;\n        perfMet.renderSpfTimes[perfMet.curSpfTimeIndex] = renderTimeElapsed;\n\n        if (sceneMilSecElapsed !== undefined) {\n          if (perfMet.loadTileTimes[perfMet.curSpfTimeIndex]) perfMet.loadTileSum -= perfMet.loadTileTimes[perfMet.curSpfTimeIndex];\n          perfMet.loadTileSum += sceneMilSecElapsed;\n          perfMet.loadTileTimes[perfMet.curSpfTimeIndex] = sceneMilSecElapsed;\n        }\n        perfMet.curSpfTimeIndex++;\n        if (perfMet.curSpfTimeIndex >= 50) perfMet.curSpfTimeIndex = 0;\n        perfMet.fpsTimerStart = perfMet.fpsTimer.currentSeconds;\n      }\n      if (this.performanceMetrics.gatherGlFinish) {\n        // Ensure all previously queued webgl commands are finished by reading back one pixel since gl.Finish didn't work\n        const bytes = new Uint8Array(4);\n        System.instance.frameBufferStack.execute(this._fbo!, true, () => {\n          gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, bytes);\n        });\n        if (this.performanceMetrics) this.performanceMetrics.endFrame(\"Finish GPU Queue\");\n      }\n    }\n  }\n\n  private drawPass(pass: RenderPass): void {\n    System.instance.applyRenderState(this.getRenderState(pass));\n    this.techniques.execute(this, this._renderCommands.getCommands(pass), pass);\n  }\n\n  private getRenderState(pass: RenderPass): RenderState {\n    // the other passes are handled by SceneCompositor\n    assert(RenderPass.ViewOverlay === pass || RenderPass.WorldOverlay === pass);\n    return this._overlayRenderState;\n  }\n\n  private assignDC(): boolean {\n    if (!this._dcAssigned) {\n      this._dcAssigned = this._assignDC();\n    }\n\n    assert(this._dcAssigned);\n    return this._dcAssigned;\n  }\n\n  public readPixels(rect: ViewRect, selector: Pixel.Selector, receiver: Pixel.Receiver, excludeNonLocatable: boolean): void {\n    if (this.performanceMetrics) this.performanceMetrics.startNewFrame();\n\n    // We can't reuse the previous frame's data for a variety of reasons, chief among them that some types of geometry (surfaces, translucent stuff) don't write\n    // to the pick buffers and others we don't want - such as non-pickable decorations - do.\n    // Render to an offscreen buffer so that we don't destroy the current color buffer.\n    const texture = TextureHandle.createForAttachment(rect.width, rect.height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n    if (undefined === texture) {\n      receiver(undefined);\n      return;\n    }\n\n    let result: Pixel.Buffer | undefined;\n    const fbo = FrameBuffer.create([texture]);\n    if (undefined !== fbo) {\n      System.instance.frameBufferStack.execute(fbo, true, () => {\n        this._drawNonLocatable = !excludeNonLocatable;\n        result = this.readPixelsFromFbo(rect, selector);\n        this._drawNonLocatable = true;\n      });\n\n      dispose(fbo);\n    }\n\n    dispose(texture);\n\n    receiver(result);\n\n    // Reset the batch IDs in all batches drawn for this call.\n    this._batchState.reset();\n  }\n\n  private readonly _scratchTmpFrustum = new Frustum();\n  private readonly _scratchRectFrustum = new Frustum();\n  private readonly _scratchViewFlags = new ViewFlags();\n  private readPixelsFromFbo(rect: ViewRect, selector: Pixel.Selector): Pixel.Buffer | undefined {\n    this._isReadPixelsInProgress = true;\n    this._readPixelsSelector = selector;\n\n    // Temporarily turn off lighting to speed things up.\n    // ###TODO: Disable textures *unless* they contain transparency. If we turn them off unconditionally then readPixels() will locate fully-transparent pixels, which we don't want.\n    const vf = this.currentViewFlags.clone(this._scratchViewFlags);\n    vf.transparency = false;\n    vf.textures = true; // false;\n    vf.sourceLights = false;\n    vf.cameraLights = false;\n    vf.solarLight = false;\n    vf.shadows = false;\n    vf.noGeometryMap = true;\n    vf.acsTriad = false;\n    vf.grid = false;\n    vf.monochrome = false;\n    vf.materials = false;\n    vf.ambientOcclusion = false;\n\n    const state = BranchState.create(this._stack.top.symbologyOverrides, vf);\n    this.pushState(state);\n\n    // Create a culling frustum based on the input rect.\n    const viewRect = this.viewRect;\n    const leftScale = (rect.left - viewRect.left) / (viewRect.right - viewRect.left);\n    const rightScale = (viewRect.right - rect.right) / (viewRect.right - viewRect.left);\n    const topScale = (rect.top - viewRect.top) / (viewRect.bottom - viewRect.top);\n    const bottomScale = (viewRect.bottom - rect.bottom) / (viewRect.bottom - viewRect.top);\n\n    const tmpFrust = this._scratchTmpFrustum;\n    const planFrust = this.planFrustum;\n    interpolateFrustumPoint(tmpFrust, planFrust, Npc._000, leftScale, Npc._100);\n    interpolateFrustumPoint(tmpFrust, planFrust, Npc._100, rightScale, Npc._000);\n    interpolateFrustumPoint(tmpFrust, planFrust, Npc._010, leftScale, Npc._110);\n    interpolateFrustumPoint(tmpFrust, planFrust, Npc._110, rightScale, Npc._010);\n    interpolateFrustumPoint(tmpFrust, planFrust, Npc._001, leftScale, Npc._101);\n    interpolateFrustumPoint(tmpFrust, planFrust, Npc._101, rightScale, Npc._001);\n    interpolateFrustumPoint(tmpFrust, planFrust, Npc._011, leftScale, Npc._111);\n    interpolateFrustumPoint(tmpFrust, planFrust, Npc._111, rightScale, Npc._011);\n\n    const rectFrust = this._scratchRectFrustum;\n    interpolateFrustumPoint(rectFrust, tmpFrust, Npc._000, bottomScale, Npc._010);\n    interpolateFrustumPoint(rectFrust, tmpFrust, Npc._100, bottomScale, Npc._110);\n    interpolateFrustumPoint(rectFrust, tmpFrust, Npc._010, topScale, Npc._000);\n    interpolateFrustumPoint(rectFrust, tmpFrust, Npc._110, topScale, Npc._100);\n    interpolateFrustumPoint(rectFrust, tmpFrust, Npc._001, bottomScale, Npc._011);\n    interpolateFrustumPoint(rectFrust, tmpFrust, Npc._101, bottomScale, Npc._111);\n    interpolateFrustumPoint(rectFrust, tmpFrust, Npc._011, topScale, Npc._001);\n    interpolateFrustumPoint(rectFrust, tmpFrust, Npc._111, topScale, Npc._101);\n\n    // If a clip has been applied to the view, trivially do nothing if aperture does not intersect\n    if (undefined !== this._activeClipVolume && this._stack.top.showClipVolume && this.clips.isValid)\n      if (ClipPlaneContainment.StronglyOutside === this._activeClipVolume.clipVector.classifyPointContainment(rectFrust.points))\n        return undefined;\n\n    // Repopulate the command list, omitting non-pickable decorations and putting transparent stuff into the opaque passes.\n    this._renderCommands.clear();\n    this._renderCommands.setCheckRange(rectFrust);\n    this._renderCommands.init(this._scene, this._backgroundMap, this._decorations, this._dynamics, true);\n    this._renderCommands.clearCheckRange();\n    this.recordPerformanceMetric(\"Init Commands\");\n\n    // Draw the scene\n    this.compositor.drawForReadPixels(this._renderCommands, undefined !== this._decorations ? this._decorations.worldOverlay : undefined);\n\n    if (this.performanceMetrics && this.performanceMetrics.gatherGlFinish) {\n      // Ensure all previously queued webgl commands are finished by reading back one pixel since gl.Finish didn't work\n      const gl = System.instance.context;\n      const bytes = new Uint8Array(4);\n      System.instance.frameBufferStack.execute(this._fbo!, true, () => {\n        gl.readPixels(0, 0, 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, bytes);\n      });\n      this.recordPerformanceMetric(\"Finish GPU Queue\");\n    }\n\n    // Restore the state\n    this._stack.pop();\n\n    const result = this.compositor.readPixels(rect, selector);\n    if (this.performanceMetrics) this.performanceMetrics.endFrame(\"Read Pixels\");\n    this._isReadPixelsInProgress = false;\n    return result;\n  }\n\n  /** Given a ViewRect, return a new rect that has been adjusted for the given aspect ratio. */\n  private adjustRectForAspectRatio(requestedRect: ViewRect, targetAspectRatio: number): ViewRect {\n    const rect = requestedRect.clone();\n    if (targetAspectRatio >= 1) {\n      const requestedWidth = rect.width;\n      const requiredWidth = rect.height * targetAspectRatio;\n      const adj = requiredWidth - requestedWidth;\n      rect.inset(-adj / 2, 0);\n    } else {\n      const requestedHeight = rect.height;\n      const requiredHeight = rect.width / targetAspectRatio;\n      const adj = requiredHeight - requestedHeight;\n      rect.inset(0, -adj / 2);\n    }\n    return rect;\n  }\n\n  protected readImagePixels(out: Uint8Array, x: number, y: number, w: number, h: number): boolean {\n    assert(this._fbo !== undefined);\n    if (this._fbo === undefined)\n      return false;\n\n    const context = System.instance.context;\n    let didSucceed = true;\n    System.instance.frameBufferStack.execute(this._fbo, true, () => {\n      try {\n        context.readPixels(x, y, w, h, context.RGBA, context.UNSIGNED_BYTE, out);\n      } catch (e) {\n        didSucceed = false;\n      }\n    });\n    if (!didSucceed)\n      return false;\n    return true;\n  }\n\n  public readImage(wantRectIn: ViewRect, targetSizeIn: Point2d, flipVertically: boolean): ImageBuffer | undefined {\n    // Determine capture rect and validate\n    const actualViewRect = this.renderRect;\n\n    const wantRect = wantRectIn.clone();\n    if (wantRect.right === -1 || wantRect.bottom === -1) {  // Indicates to get the entire view, no clipping\n      wantRect.right = actualViewRect.right;\n      wantRect.bottom = actualViewRect.bottom;\n    }\n\n    const targetSize = targetSizeIn.clone();\n    if (targetSize.x === 0 || targetSize.y === 0) { // Indicates image should have same dimensions as rect (no scaling)\n      targetSize.x = wantRect.width;\n      targetSize.y = wantRect.height;\n    }\n\n    const lowerRight = Point2d.create(wantRect.right - 1, wantRect.bottom - 1); // in BSIRect, the right and bottom are actually *outside* of the rectangle\n    if (!actualViewRect.containsPoint(Point2d.create(wantRect.left, wantRect.top)) || !actualViewRect.containsPoint(lowerRight))\n      return undefined;\n\n    let captureRect = this.adjustRectForAspectRatio(wantRect, targetSize.x / targetSize.y);\n\n    captureRect = wantRect.clone();\n    targetSize.x = captureRect.width;\n    targetSize.y = captureRect.height;\n\n    if (!actualViewRect.containsPoint(Point2d.create(wantRect.left, wantRect.top)) || !actualViewRect.containsPoint(lowerRight))\n      return undefined; // ###TODO: additional logic to shrink requested rectangle to fit inside view\n\n    this.assignDC();\n\n    // Read pixels. Note ViewRect thinks (0,0) = top-left. gl.readPixels expects (0,0) = bottom-left.\n    const bytesPerPixel = 4;\n    const imageData = new Uint8Array(bytesPerPixel * captureRect.width * captureRect.height);\n    const isValidImageData = this.readImagePixels(imageData, captureRect.left, actualViewRect.height - captureRect.bottom, captureRect.width, captureRect.height);\n    if (!isValidImageData)\n      return undefined;\n    const image = ImageBuffer.create(imageData, ImageBufferFormat.Rgba, targetSize.x);\n    if (!image)\n      return undefined;\n\n    // No need to scale image.\n    // Some callers want background pixels to be treated as fully-transparent\n    // They indicate this by supplying a background color with full transparency\n    // Any other pixels are treated as fully-opaque as alpha has already been blended\n    // ###TODO: This introduces a defect in that we are not preserving alpha of translucent pixels, and therefore the returned image cannot be blended\n    const preserveBGAlpha = 0.0 === this.bgColor.alpha;\n\n    // Optimization for view attachments: if image consists entirely of background pixels, return an undefined\n    let isEmptyImage = true;\n    for (let i = 3; i < image.data.length; i += 4) {\n      const a = image.data[i];\n      if (!preserveBGAlpha || 0 < a) {\n        image.data[i] = 0xff;\n        isEmptyImage = false;\n      }\n    }\n    if (isEmptyImage)\n      return undefined;\n\n    if (flipVertically) {\n      const halfHeight = Math.floor(image.height / 2);\n      const numBytesPerRow = image.width * 4;\n      for (let loY = 0; loY < halfHeight; loY++) {\n        for (let x = 0; x < image.width; x++) {\n          const hiY = (image.height - 1) - loY;\n          const loIdx = loY * numBytesPerRow + x * 4;\n          const hiIdx = hiY * numBytesPerRow + x * 4;\n\n          swapImageByte(image, loIdx, hiIdx);\n          swapImageByte(image, loIdx + 1, hiIdx + 1);\n          swapImageByte(image, loIdx + 2, hiIdx + 2);\n          swapImageByte(image, loIdx + 3, hiIdx + 3);\n        }\n      }\n    }\n\n    return image;\n  }\n\n  public drawPlanarClassifiers() {\n    if (this._planarClassifiers)\n      this._planarClassifiers.forEach((classifier) => (classifier as PlanarClassifier).draw(this));\n  }\n  public drawSolarShadowMap() {\n    if (this._solarShadowMap)\n      (this._solarShadowMap as SolarShadowMap).draw(this);\n  }\n\n  // ---- Methods expected to be overridden by subclasses ---- //\n\n  protected abstract _assignDC(): boolean;\n  protected abstract _beginPaint(): void;\n  protected abstract _endPaint(): void;\n}\n\n/** A Target that renders to a canvas on the screen\n * @internal\n */\nexport class OnScreenTarget extends Target {\n  private readonly _canvas: HTMLCanvasElement;\n  private _blitGeom?: SingleTexturedViewportQuadGeometry;\n  private readonly _prevViewRect = new ViewRect();\n  private _animationFraction: number = 0;\n\n  public constructor(canvas: HTMLCanvasElement) {\n    super();\n    this._canvas = canvas;\n  }\n\n  public dispose() {\n    this._fbo = dispose(this._fbo);\n    this._blitGeom = dispose(this._blitGeom);\n    super.dispose();\n  }\n\n  public get animationFraction(): number { return this._animationFraction; }\n  public set animationFraction(fraction: number) { this._animationFraction = fraction; }\n\n  public get viewRect(): ViewRect {\n    assert(0 < this.renderRect.width && 0 < this.renderRect.height, \"Zero-size view rect\");\n    assert(Math.floor(this.renderRect.width) === this.renderRect.width && Math.floor(this.renderRect.height) === this.renderRect.height, \"fractional view rect dimensions\");\n    return this.renderRect;\n  }\n\n  public setViewRect(_rect: ViewRect, _temporary: boolean): void { assert(false); }\n\n  protected _assignDC(): boolean {\n    assert(undefined === this._fbo);\n\n    const rect = this.viewRect; // updates the render rect to be the client width and height\n    const color = TextureHandle.createForAttachment(rect.width, rect.height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n    if (undefined === color) {\n      return false;\n    }\n\n    this._fbo = FrameBuffer.create([color]);\n    if (undefined === this._fbo) {\n      return false;\n    }\n\n    const tx = this._fbo.getColor(0);\n    assert(undefined !== tx.getHandle());\n    this._blitGeom = SingleTexturedViewportQuadGeometry.createGeometry(tx.getHandle()!, TechniqueId.CopyColorNoAlpha);\n    return undefined !== this._blitGeom;\n  }\n\n  protected debugPaint(): void {\n    const rect = this.viewRect;\n    const canvas = System.instance.canvas;\n    canvas.width = rect.width;\n    canvas.height = rect.height;\n\n    const gl = System.instance.context;\n    gl.viewport(0, 0, rect.width, rect.height);\n    gl.clearColor(1, 0, 1, 1);\n    gl.clear(gl.COLOR_BUFFER_BIT);\n\n    const context = this._canvas.getContext(\"2d\", { alpha: false });\n    assert(null !== context);\n    context!.drawImage(canvas, 0, 0);\n  }\n\n  public updateViewRect(): boolean {\n    this.renderRect.init(0, 0, this._canvas.clientWidth, this._canvas.clientHeight);\n    const viewRect = this.renderRect;\n\n    if (this._prevViewRect.width !== viewRect.width || this._prevViewRect.height !== viewRect.height) {\n      // Must ensure internal bitmap grid dimensions of on-screen canvas match its own on-screen appearance\n      this._canvas.width = viewRect.width;\n      this._canvas.height = viewRect.height;\n      this._prevViewRect.setFrom(viewRect);\n      return true;\n    }\n    return false;\n  }\n\n  protected _beginPaint(): void {\n    assert(undefined !== this._fbo);\n\n    // Render to our framebuffer\n    const system = System.instance;\n    system.frameBufferStack.push(this._fbo!, true);\n\n    const viewRect = this.viewRect;\n\n    // Ensure off-screen canvas dimensions match on-screen canvas dimensions\n    if (system.canvas.width !== viewRect.width)\n      system.canvas.width = viewRect.width;\n    if (system.canvas.height !== viewRect.height)\n      system.canvas.height = viewRect.height;\n\n    assert(system.context.drawingBufferWidth === viewRect.width, \"offscreen context dimensions don't match onscreen\");\n    assert(system.context.drawingBufferHeight === viewRect.height, \"offscreen context dimensions don't match onscreen\");\n  }\n\n  private static _progParams?: ShaderProgramParams;\n  private static _drawParams?: DrawParams;\n  private static getDrawParams(target: OnScreenTarget, geom: SingleTexturedViewportQuadGeometry) {\n    if (undefined === this._progParams) {\n      this._progParams = new ShaderProgramParams();\n      this._drawParams = new DrawParams();\n    }\n\n    this._progParams.init(target);\n    this._drawParams!.init(this._progParams, geom);\n    return this._drawParams!;\n  }\n\n  protected _endPaint(): void {\n    const onscreenContext = this._canvas.getContext(\"2d\", { alpha: false });\n    assert(null !== onscreenContext);\n    assert(undefined !== this._blitGeom);\n    if (undefined === this._blitGeom || null === onscreenContext) {\n      return;\n    }\n\n    const system = System.instance;\n    system.frameBufferStack.pop();\n\n    // Copy framebuffer contents to off-screen canvas\n    system.applyRenderState(RenderState.defaults);\n    const drawParams = OnScreenTarget.getDrawParams(this, this._blitGeom);\n    system.techniques.draw(drawParams);\n\n    // NB: Very early on we found that we needed to do a clearRect() on the 2d context to prevent artifacts in final image...\n    // this turned out to be a significant performance issue in Firefox and removal produced no artifacts.\n    // onscreenContext.clearRect(0, 0, this._canvas.clientWidth, this._canvas.clientHeight);\n\n    // Copy off-screen canvas contents to on-screen canvas\n    onscreenContext.drawImage(system.canvas, 0, 0);\n  }\n\n  protected drawOverlayDecorations(): void {\n    if (undefined !== this._decorations && undefined !== this._decorations.canvasDecorations) {\n      const ctx = this._canvas.getContext(\"2d\", { alpha: false })!;\n      for (const overlay of this._decorations.canvasDecorations) {\n        ctx.save();\n        if (overlay.position)\n          ctx.translate(overlay.position.x, overlay.position.y);\n        overlay.drawDecoration(ctx);\n        ctx.restore();\n      }\n    }\n  }\n\n  public pickOverlayDecoration(pt: XAndY): CanvasDecoration | undefined {\n    let overlays: CanvasDecoration[] | undefined;\n    if (undefined === this._decorations || undefined === (overlays = this._decorations.canvasDecorations))\n      return undefined;\n\n    // loop over array backwards, because later entries are drawn on top.\n    for (let i = overlays.length - 1; i >= 0; --i) {\n      const overlay = overlays[i];\n      if (undefined !== overlay.pick && overlay.pick(pt))\n        return overlay;\n    }\n    return undefined;\n  }\n\n  public onResized(): void {\n    this._dcAssigned = false;\n    this._fbo = dispose(this._fbo);\n  }\n}\n\n/** @internal */\nexport class OffScreenTarget extends Target {\n  private _animationFraction: number = 0;\n\n  public constructor(rect: ViewRect) {\n    super(rect);\n  }\n\n  public get animationFraction(): number { return this._animationFraction; }\n  public set animationFraction(fraction: number) { this._animationFraction = fraction; }\n\n  public get viewRect(): ViewRect { return this.renderRect; }\n\n  public onResized(): void { assert(false); } // offscreen viewport's dimensions are set once, in constructor.\n  public updateViewRect(): boolean { return false; } // offscreen target does not dynamically resize the view rect\n\n  public setViewRect(rect: ViewRect, temporary: boolean): void {\n    if (this.renderRect.equals(rect))\n      return;\n\n    this.renderRect.setFrom(rect);\n    if (temporary) {\n      // Temporarily adjust view rect to create scene for a view attachment.\n      // Will be reset before attachment is rendered - so don't blow away our framebuffers + textures\n      return;\n    }\n\n    this._dcAssigned = false;\n    this._fbo = dispose(this._fbo);\n    dispose(this._compositor);\n  }\n\n  protected _assignDC(): boolean {\n    if (!this.updateViewRect() && this._fbo !== undefined)\n      return true;\n\n    const rect = this.viewRect;\n    const color = TextureHandle.createForAttachment(rect.width, rect.height, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte);\n    if (color === undefined)\n      return false;\n    this._fbo = FrameBuffer.create([color]);\n    assert(this._fbo !== undefined);\n    return this._fbo !== undefined;\n  }\n\n  protected _beginPaint(): void {\n    assert(this._fbo !== undefined);\n    System.instance.frameBufferStack.push(this._fbo!, true);\n  }\n\n  protected _endPaint(): void {\n    System.instance.frameBufferStack.pop();\n  }\n}\n\nfunction normalizedDifference(p0: Point3d, p1: Point3d, out?: Vector3d): Vector3d {\n  const result = undefined !== out ? out : new Vector3d();\n  result.x = p0.x - p1.x;\n  result.y = p0.y - p1.y;\n  result.z = p0.z - p1.z;\n  result.normalizeInPlace();\n  return result;\n}\n\n/** @internal */\nexport function fromSumOf(p: Point3d, v: Vector3d, scale: number, out?: Point3d) {\n  const result = undefined !== out ? out : new Point3d();\n  result.x = p.x + v.x * scale;\n  result.y = p.y + v.y * scale;\n  result.z = p.z + v.z * scale;\n  return result;\n}\n\nfunction dotDifference(pt: Point3d, origin: Point3d, vec: Vector3d): number {\n  return (pt.x - origin.x) * vec.x + (pt.y - origin.y) * vec.y + (pt.z - origin.z) * vec.z;\n}\n\nfunction lookIn(eye: Point3d, viewX: Vector3d, viewY: Vector3d, viewZ: Vector3d, result: Transform) {\n  const rot = result.matrix.coffs;\n  rot[0] = viewX.x; rot[1] = viewX.y; rot[2] = viewX.z;\n  rot[3] = viewY.x; rot[4] = viewY.y; rot[5] = viewY.z;\n  rot[6] = viewZ.x; rot[7] = viewZ.y; rot[8] = viewZ.z;\n\n  result.origin.x = -viewX.dotProduct(eye);\n  result.origin.y = -viewY.dotProduct(eye);\n  result.origin.z = -viewZ.dotProduct(eye);\n}\n\nfunction ortho(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4d) {\n  Matrix4d.createRowValues(\n    2.0 / (right - left), 0.0, 0.0, -(right + left) / (right - left),\n    0.0, 2.0 / (top - bottom), 0.0, -(top + bottom) / (top - bottom),\n    0.0, 0.0, -2.0 / (far - near), -(far + near) / (far - near),\n    0.0, 0.0, 0.0, 1.0,\n    result);\n}\n\nfunction frustum(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4d) {\n  Matrix4d.createRowValues(\n    (2.0 * near) / (right - left), 0.0, (right + left) / (right - left), 0.0,\n    0.0, (2.0 * near) / (top - bottom), (top + bottom) / (top - bottom), 0.0,\n    0.0, 0.0, -(far + near) / (far - near), -(2.0 * far * near) / (far - near),\n    0.0, 0.0, -1.0, 0.0,\n    result);\n}\n\nfunction interpolatePoint(p0: Point3d, fraction: number, p1: Point3d, out: Point3d): Point3d {\n  let x: number;\n  let y: number;\n  let z: number;\n  if (fraction <= 0.5) {\n    x = p0.x + fraction * (p1.x - p0.x);\n    y = p0.y + fraction * (p1.y - p0.y);\n    z = p0.z + fraction * (p1.z - p0.z);\n  } else {\n    const t = fraction - 1.0;\n    x = p1.x + t * (p1.x - p0.x);\n    y = p1.y + t * (p1.y - p0.y);\n    z = p1.z + t * (p1.z - p0.z);\n  }\n\n  return Point3d.create(x, y, z, out);\n}\n\nfunction interpolateFrustumPoint(destFrust: Frustum, srcFrust: Frustum, destPoint: Npc, scale: number, srcPoint: Npc): void {\n  interpolatePoint(srcFrust.getCorner(destPoint), scale, srcFrust.getCorner(srcPoint), destFrust.points[destPoint]);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert, using, IDisposable, dispose } from \"@bentley/bentleyjs-core\";\nimport { ShaderProgram, ShaderProgramExecutor } from \"./ShaderProgram\";\nimport { TechniqueId, computeCompositeTechniqueId } from \"./TechniqueId\";\nimport { IsInstanced, IsAnimated, IsClassified, IsShadowable, TechniqueFlags, FeatureMode, ClipDef, IsEdgeTestNeeded } from \"./TechniqueFlags\";\nimport { ProgramBuilder, FragmentShaderComponent, ClippingShaders } from \"./ShaderBuilder\";\nimport { DrawParams, DrawCommands, OmitStatus } from \"./DrawCommand\";\nimport { Target } from \"./Target\";\nimport { RenderPass } from \"./RenderFlags\";\nimport { createClearTranslucentProgram } from \"./glsl/ClearTranslucent\";\nimport { createClearPickAndColorProgram } from \"./glsl/ClearPickAndColor\";\nimport { createCopyColorProgram } from \"./glsl/CopyColor\";\nimport { createCopyPickBuffersProgram } from \"./glsl/CopyPickBuffers\";\nimport { createCopyStencilProgram } from \"./glsl/CopyStencil\";\nimport { createCompositeProgram } from \"./glsl/Composite\";\nimport { createClipMaskProgram } from \"./glsl/ClipMask\";\nimport { addTranslucency } from \"./glsl/Translucency\";\nimport { addMonochrome } from \"./glsl/Monochrome\";\nimport { createSurfaceBuilder, createSurfaceHiliter, addMaterial, addSurfaceDiscardByAlpha } from \"./glsl/Surface\";\nimport { createPointStringBuilder, createPointStringHiliter } from \"./glsl/PointString\";\nimport { createPointCloudBuilder, createPointCloudHiliter } from \"./glsl/PointCloud\";\nimport { addFeatureId, addFeatureSymbology, addUniformFeatureSymbology, addRenderOrder, FeatureSymbologyOptions } from \"./glsl/FeatureSymbology\";\nimport { GLSLFragment, addPickBufferOutputs } from \"./glsl/Fragment\";\nimport { addFrustum, addEyeSpace } from \"./glsl/Common\";\nimport { addModelViewMatrix } from \"./glsl/Vertex\";\nimport { createPolylineBuilder, createPolylineHiliter } from \"./glsl/Polyline\";\nimport { createEdgeBuilder } from \"./glsl/Edge\";\nimport { createSkyBoxProgram } from \"./glsl/SkyBox\";\nimport { createSkySphereProgram } from \"./glsl/SkySphere\";\nimport { createAmbientOcclusionProgram } from \"./glsl/AmbientOcclusion\";\nimport { createBlurProgram } from \"./glsl/Blur\";\nimport { createCombineTexturesProgram } from \"./glsl/CombineTextures\";\n\n/** Defines a rendering technique implemented using one or more shader programs.\n * @internal\n */\nexport interface Technique extends IDisposable {\n  getShader(flags: TechniqueFlags): ShaderProgram;\n\n  // Chiefly for tests - compiles all shader programs - more generally programs are compiled on demand.\n  compileShaders(): boolean;\n}\n\n/** A rendering technique implemented using a single shader program, typically for some specialized purpose.\n * @internal\n */\nexport class SingularTechnique implements Technique {\n  public readonly program: ShaderProgram;\n\n  // Note: Technique assumes ownership of a program\n  public constructor(program: ShaderProgram) { this.program = program; }\n\n  public getShader(_flags: TechniqueFlags) { return this.program; }\n  public compileShaders(): boolean { return this.program.compile(); }\n\n  public dispose(): void {\n    dispose(this.program);\n  }\n}\n\nfunction numFeatureVariants(numBaseShaders: number) { return numBaseShaders * 3; }\nconst numHiliteVariants = 2; // instanced and non-instanced.\nconst featureModes = [FeatureMode.None, FeatureMode.Pick, FeatureMode.Overrides];\nconst scratchTechniqueFlags = new TechniqueFlags();\nconst scratchHiliteFlags = new TechniqueFlags();\n\n/** A rendering technique implemented using multiple shader programs, selected based on TechniqueFlags.\n * @internal\n */\nexport abstract class VariedTechnique implements Technique {\n  private readonly _basicPrograms: ShaderProgram[] = [];\n  private readonly _clippingPrograms: ClippingShaders[] = [];\n\n  public compileShaders(): boolean {\n    let allCompiled = true;\n    for (const program of this._basicPrograms) {\n      if (!program.compile()) allCompiled = false;\n    }\n\n    for (const clipProg of this._clippingPrograms) {\n      if (!clipProg.compileShaders()) allCompiled = false;\n    }\n\n    return allCompiled;\n  }\n\n  protected verifyShadersContiguous(): void {\n    let emptyShaderIndex = -1;\n    assert(-1 === (emptyShaderIndex = this._basicPrograms.findIndex((prog) => undefined === prog)), \"Shader index \" + emptyShaderIndex + \" is undefined in \" + this.constructor.name);\n  }\n\n  public dispose(): void {\n    for (const program of this._basicPrograms) {\n      assert(undefined !== program);\n      dispose(program);\n    }\n\n    this._basicPrograms.length = 0;\n    for (const clipShaderObj of this._clippingPrograms) {\n      assert(undefined !== clipShaderObj);\n      assert(undefined !== clipShaderObj.maskShader);\n      dispose(clipShaderObj.maskShader);\n\n      for (const clipShader of clipShaderObj.shaders) {\n        assert(undefined !== clipShader);\n        dispose(clipShader);\n      }\n\n      clipShaderObj.shaders.length = 0;\n      clipShaderObj.maskShader = undefined;\n    }\n  }\n\n  protected constructor(numPrograms: number) {\n    this._basicPrograms.length = numPrograms;\n  }\n\n  protected abstract computeShaderIndex(flags: TechniqueFlags): number;\n  protected abstract get _debugDescription(): string;\n\n  protected addShader(builder: ProgramBuilder, flags: TechniqueFlags, gl: WebGLRenderingContext): void {\n    const descr = this._debugDescription + \": \" + flags.buildDescription();\n    builder.setDebugDescription(descr);\n\n    const index = this.getShaderIndex(flags);\n    assert(this._basicPrograms[index] === undefined);\n    this._basicPrograms[index] = builder.buildProgram(gl);\n    assert(this._basicPrograms[index] !== undefined);\n\n    assert(this._clippingPrograms[index] === undefined);\n    this._clippingPrograms[index] = new ClippingShaders(builder, gl);\n    assert(this._clippingPrograms[index] !== undefined);\n  }\n\n  protected addProgram(flags: TechniqueFlags, program: ShaderProgram): void {\n    const index = this.getShaderIndex(flags);\n    assert(undefined === this._basicPrograms[index], \"program already exists\");\n    this._basicPrograms[index] = program;\n  }\n\n  protected addHiliteShader(gl: WebGLRenderingContext, instanced: IsInstanced, classified: IsClassified, create: (instanced: IsInstanced, classified: IsClassified) => ProgramBuilder): void {\n    const builder = create(instanced, classified);\n    scratchHiliteFlags.initForHilite(new ClipDef(), instanced, classified);\n    this.addShader(builder, scratchHiliteFlags, gl);\n  }\n\n  protected addTranslucentShader(builder: ProgramBuilder, flags: TechniqueFlags, gl: WebGLRenderingContext): void {\n    flags.isTranslucent = true;\n    addTranslucency(builder);\n    this.addShader(builder, flags, gl);\n  }\n\n  protected addFeatureId(builder: ProgramBuilder, feat: FeatureMode) {\n    const frag = builder.frag;\n    if (FeatureMode.None === feat)\n      frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n    else {\n      const vert = builder.vert;\n      addFrustum(builder);\n      addEyeSpace(builder);\n      addModelViewMatrix(vert);\n      addRenderOrder(frag);\n      addFeatureId(builder);\n      addPickBufferOutputs(frag);\n    }\n  }\n\n  private getShaderIndex(flags: TechniqueFlags) {\n    assert(!flags.isHilite || (!flags.isTranslucent && (flags.isClassified === IsClassified.Yes || flags.hasFeatures)), \"invalid technique flags\");\n    const index = this.computeShaderIndex(flags);\n    assert(index < this._basicPrograms.length, \"shader index out of bounds\");\n    return index;\n  }\n\n  public getShader(flags: TechniqueFlags): ShaderProgram {\n    const index = this.getShaderIndex(flags);\n    let program: ShaderProgram | undefined;\n\n    if (flags.hasClip) {\n      const entry = this._clippingPrograms[index];\n      assert(undefined !== entry);\n      program = entry.getProgram(flags.clip);\n    }\n\n    if (program === undefined)\n      program = this._basicPrograms[index];\n\n    return program;\n  }\n}\n\n/** @internal */\nconst enum HasAnimationOrShadows { Neither, Animation, Shadows }\n\nclass SurfaceTechnique extends VariedTechnique {\n  private static readonly _kOpaque = 0;\n  private static readonly _kTranslucent = 1;\n  private static readonly _kInstanced = 2;\n  private static readonly _kFeature = 4;\n  private static readonly _kEdgeTestNeeded = 8; // only when hasFeatures\n  private static readonly _kAnimated = numFeatureVariants(SurfaceTechnique._kFeature) + SurfaceTechnique._kEdgeTestNeeded;\n  private static readonly _kShadowable = SurfaceTechnique._kAnimated + numFeatureVariants(SurfaceTechnique._kFeature) + SurfaceTechnique._kEdgeTestNeeded;\n  private static readonly _kHilite = SurfaceTechnique._kShadowable + numFeatureVariants(SurfaceTechnique._kFeature) + SurfaceTechnique._kEdgeTestNeeded;\n  // Classifiers are a special case - they are never translucent, animated, or instanced. We have 4 variants: 1 for each of the 3 feature modes, plus 1 for hilite.\n  private static readonly _kClassified = SurfaceTechnique._kHilite + numHiliteVariants;\n\n  public constructor(gl: WebGLRenderingContext) {\n    super(SurfaceTechnique._kClassified + numFeatureVariants(1) + 1);\n    const flags = scratchTechniqueFlags;\n\n    for (let instanced = IsInstanced.No; instanced <= IsInstanced.Yes; instanced++) {\n      this.addHiliteShader(gl, instanced, IsClassified.No, createSurfaceHiliter);\n      for (let hasAnimOrShadow = HasAnimationOrShadows.Neither; hasAnimOrShadow <= HasAnimationOrShadows.Shadows; hasAnimOrShadow++) {\n        const iAnimate = HasAnimationOrShadows.Animation === hasAnimOrShadow ? IsAnimated.Yes : IsAnimated.No;\n        const shadowable = HasAnimationOrShadows.Shadows === hasAnimOrShadow ? IsShadowable.Yes : IsShadowable.No;\n        for (let edgeTestNeeded = IsEdgeTestNeeded.No; edgeTestNeeded <= IsEdgeTestNeeded.Yes; edgeTestNeeded++) {\n          for (const featureMode of featureModes) {\n            if (FeatureMode.None !== featureMode || IsEdgeTestNeeded.No === edgeTestNeeded) {\n              flags.reset(featureMode, instanced, shadowable);\n              flags.isAnimated = iAnimate;\n              flags.isEdgeTestNeeded = edgeTestNeeded;\n              const builder = createSurfaceBuilder(featureMode, flags.isInstanced, flags.isAnimated, IsClassified.No, flags.isShadowable, flags.isEdgeTestNeeded);\n              addMonochrome(builder.frag);\n              addMaterial(builder.frag);\n\n              addSurfaceDiscardByAlpha(builder.frag);\n              this.addShader(builder, flags, gl);\n\n              builder.frag.unset(FragmentShaderComponent.DiscardByAlpha);\n              this.addTranslucentShader(builder, flags, gl);\n            }\n          }\n        }\n      }\n    }\n\n    this.addHiliteShader(gl, IsInstanced.No, IsClassified.Yes, createSurfaceHiliter);\n    for (const featureMode of featureModes) {\n      flags.reset(featureMode, IsInstanced.No, IsShadowable.No);\n      flags.isClassified = IsClassified.Yes;\n\n      const builder = createSurfaceBuilder(featureMode, IsInstanced.No, IsAnimated.No, IsClassified.Yes, IsShadowable.No, flags.isEdgeTestNeeded);\n      addMonochrome(builder.frag);\n      addMaterial(builder.frag);\n      addSurfaceDiscardByAlpha(builder.frag);\n\n      this.addShader(builder, flags, gl);\n    }\n\n    this.verifyShadersContiguous();\n  }\n\n  protected get _debugDescription() { return \"Surface\"; }\n\n  public computeShaderIndex(flags: TechniqueFlags): number {\n    if (flags.isClassified) {\n      assert(!flags.isAnimated);\n      assert(!flags.isTranslucent);\n      assert(!flags.isInstanced);\n      assert(!flags.isShadowable);\n      assert(!flags.isEdgeTestNeeded);\n\n      const baseIndex = SurfaceTechnique._kClassified;\n      return flags.isHilite ? baseIndex + numFeatureVariants(1) : baseIndex + flags.featureMode;\n    } else if (flags.isHilite) {\n      assert(flags.hasFeatures);\n      return SurfaceTechnique._kHilite + flags.isInstanced;\n    }\n\n    assert(flags.hasFeatures || flags.isEdgeTestNeeded === IsEdgeTestNeeded.No);\n    let index = flags.isTranslucent ? SurfaceTechnique._kTranslucent : SurfaceTechnique._kOpaque;\n    if (flags.isInstanced)\n      index += SurfaceTechnique._kInstanced;\n    index += SurfaceTechnique._kFeature * flags.featureMode;\n    if (flags.isEdgeTestNeeded)\n      index += SurfaceTechnique._kEdgeTestNeeded;\n    if (flags.isAnimated)\n      index += SurfaceTechnique._kAnimated;\n    if (flags.isShadowable)\n      index += SurfaceTechnique._kShadowable;\n\n    return index;\n  }\n}\n\nclass PolylineTechnique extends VariedTechnique {\n  private static readonly _kOpaque = 0;\n  private static readonly _kTranslucent = 1;\n  private static readonly _kInstanced = 2;\n  private static readonly _kFeature = 4;\n  private static readonly _kHilite = numFeatureVariants(PolylineTechnique._kFeature);\n\n  public constructor(gl: WebGLRenderingContext) {\n    super(PolylineTechnique._kHilite + numHiliteVariants);\n\n    const flags = scratchTechniqueFlags;\n    for (let instanced = IsInstanced.No; instanced <= IsInstanced.Yes; instanced++) {\n      this.addHiliteShader(gl, instanced, IsClassified.No, createPolylineHiliter);\n      for (const featureMode of featureModes) {\n        flags.reset(featureMode, instanced, IsShadowable.No);\n        const builder = createPolylineBuilder(instanced);\n        addMonochrome(builder.frag);\n\n        // The translucent shaders do not need the element IDs.\n        const builderTrans = createPolylineBuilder(instanced);\n        addMonochrome(builderTrans.frag);\n        if (FeatureMode.Overrides === featureMode) {\n          addFeatureSymbology(builderTrans, featureMode, FeatureSymbologyOptions.Linear);\n          addFeatureSymbology(builder, featureMode, FeatureSymbologyOptions.Linear);\n          this.addTranslucentShader(builderTrans, flags, gl);\n        } else {\n          this.addTranslucentShader(builderTrans, flags, gl);\n          addFeatureSymbology(builder, featureMode, FeatureSymbologyOptions.None);\n        }\n\n        this.addFeatureId(builder, featureMode);\n        flags.reset(featureMode, instanced, IsShadowable.No);\n        this.addShader(builder, flags, gl);\n      }\n    }\n    this.verifyShadersContiguous();\n  }\n\n  protected get _debugDescription() { return \"Polyline\"; }\n\n  public computeShaderIndex(flags: TechniqueFlags): number {\n    if (flags.isHilite) {\n      assert(flags.hasFeatures);\n      return PolylineTechnique._kHilite + flags.isInstanced;\n    }\n\n    let index = flags.isTranslucent ? PolylineTechnique._kTranslucent : PolylineTechnique._kOpaque;\n    index += PolylineTechnique._kFeature * flags.featureMode;\n    index += PolylineTechnique._kInstanced * flags.isInstanced;\n    return index;\n  }\n}\n\nclass EdgeTechnique extends VariedTechnique {\n  private static readonly _kOpaque = 0;\n  private static readonly _kTranslucent = 1;\n  private static readonly _kAnimated = 2;\n  private static readonly _kInstanced = 4;\n  private static readonly _kFeature = 8;\n  private readonly _isSilhouette: boolean;\n\n  public constructor(gl: WebGLRenderingContext, isSilhouette: boolean = false) {\n    super(numFeatureVariants(EdgeTechnique._kFeature));\n    this._isSilhouette = isSilhouette;\n\n    const flags = scratchTechniqueFlags;\n    for (let instanced = IsInstanced.No; instanced <= IsInstanced.Yes; instanced++) {\n      for (let iAnimate = IsAnimated.No; iAnimate <= IsAnimated.Yes; iAnimate++) {\n        for (const featureMode of featureModes) {\n          flags.reset(featureMode, instanced, IsShadowable.No);\n          flags.isAnimated = iAnimate;\n          const builder = createEdgeBuilder(isSilhouette, flags.isInstanced, flags.isAnimated);\n          addMonochrome(builder.frag);\n\n          // The translucent shaders do not need the element IDs.\n          const builderTrans = createEdgeBuilder(isSilhouette, flags.isInstanced, flags.isAnimated);\n          addMonochrome(builderTrans.frag);\n          if (FeatureMode.Overrides === featureMode) {\n            addFeatureSymbology(builderTrans, featureMode, FeatureSymbologyOptions.Linear);\n            addFeatureSymbology(builder, featureMode, FeatureSymbologyOptions.Linear);\n            this.addTranslucentShader(builderTrans, flags, gl);\n          } else {\n            this.addTranslucentShader(builderTrans, flags, gl);\n            addFeatureSymbology(builder, featureMode, FeatureSymbologyOptions.None);\n          }\n\n          this.addFeatureId(builder, featureMode);\n          flags.reset(featureMode, instanced, IsShadowable.No);\n          flags.isAnimated = iAnimate;\n          this.addShader(builder, flags, gl);\n        }\n      }\n    }\n    this.verifyShadersContiguous();\n  }\n\n  protected get _debugDescription() { return this._isSilhouette ? \"Silhouette\" : \"Edge\"; }\n\n  public computeShaderIndex(flags: TechniqueFlags): number {\n    let index = flags.isTranslucent ? EdgeTechnique._kTranslucent : EdgeTechnique._kOpaque;\n    index += EdgeTechnique._kFeature * flags.featureMode;\n    if (flags.isAnimated)\n      index += EdgeTechnique._kAnimated;\n    if (flags.isInstanced)\n      index += EdgeTechnique._kInstanced;\n\n    return index;\n  }\n}\n\nclass PointStringTechnique extends VariedTechnique {\n  private static readonly _kOpaque = 0;\n  private static readonly _kTranslucent = 1;\n  private static readonly _kInstanced = 2;\n  private static readonly _kFeature = 4;\n  private static readonly _kHilite = numFeatureVariants(PointStringTechnique._kFeature);\n\n  public constructor(gl: WebGLRenderingContext) {\n    super((PointStringTechnique._kHilite + numHiliteVariants));\n\n    const flags = scratchTechniqueFlags;\n    for (let instanced = IsInstanced.No; instanced <= IsInstanced.Yes; instanced++) {\n      this.addHiliteShader(gl, instanced, IsClassified.No, createPointStringHiliter);\n      for (const featureMode of featureModes) {\n        flags.reset(featureMode, instanced, IsShadowable.No);\n        const builder = createPointStringBuilder(instanced);\n        addMonochrome(builder.frag);\n\n        // The translucent shaders do not need the element IDs.\n        const builderTrans = createPointStringBuilder(instanced);\n        addMonochrome(builderTrans.frag);\n        if (FeatureMode.Overrides === featureMode) {\n          addFeatureSymbology(builderTrans, featureMode, FeatureSymbologyOptions.Point);\n          addFeatureSymbology(builder, featureMode, FeatureSymbologyOptions.Point);\n          this.addTranslucentShader(builderTrans, flags, gl);\n        } else {\n          this.addTranslucentShader(builderTrans, flags, gl);\n          addFeatureSymbology(builder, featureMode, FeatureSymbologyOptions.None);\n        }\n\n        this.addFeatureId(builder, featureMode);\n        flags.reset(featureMode, instanced, IsShadowable.No);\n        this.addShader(builder, flags, gl);\n      }\n    }\n    this.verifyShadersContiguous();\n  }\n\n  protected get _debugDescription() { return \"PointString\"; }\n\n  public computeShaderIndex(flags: TechniqueFlags): number {\n    if (flags.isHilite) {\n      assert(flags.hasFeatures);\n      return PointStringTechnique._kHilite + flags.isInstanced;\n    }\n\n    let index = flags.isTranslucent ? PointStringTechnique._kTranslucent : PointStringTechnique._kOpaque;\n    index += PointStringTechnique._kFeature * flags.featureMode;\n    index += PointStringTechnique._kInstanced * flags.isInstanced;\n    return index;\n  }\n}\n\nclass PointCloudTechnique extends VariedTechnique {\n\n  private static readonly _kHilite = 4;\n\n  public constructor(gl: WebGLRenderingContext) {\n    super(PointCloudTechnique._kHilite + 2);\n    for (let iClassified = IsClassified.No; iClassified <= IsClassified.Yes; iClassified++) {\n      this.addHiliteShader(gl, IsInstanced.No, iClassified, () => createPointCloudHiliter(iClassified));\n      const flags = scratchTechniqueFlags;\n      const pointCloudFeatureModes = [FeatureMode.None, FeatureMode.Overrides];\n      for (const featureMode of pointCloudFeatureModes) {\n        flags.reset(featureMode, IsInstanced.No, IsShadowable.No);\n        flags.isClassified = iClassified;\n        const builder = createPointCloudBuilder(flags.isClassified, featureMode);\n        if (FeatureMode.Overrides === featureMode)\n          addUniformFeatureSymbology(builder);\n\n        this.addFeatureId(builder, featureMode);\n        this.addShader(builder, flags, gl);\n      }\n    }\n    this.verifyShadersContiguous();\n  }\n\n  protected get _debugDescription() { return \"PointCloud\"; }\n\n  public computeShaderIndex(flags: TechniqueFlags): number {\n    if (flags.isHilite)\n      return PointCloudTechnique._kHilite + flags.isClassified;\n    else\n      return 2 * flags.isClassified + ((flags.featureMode === FeatureMode.None) ? 0 : 1);\n  }\n}\n\n/** A collection of rendering techniques accessed by ID.\n * @internal\n */\nexport class Techniques implements IDisposable {\n  private readonly _list = new Array<Technique>(); // indexed by TechniqueId, which may exceed TechniqueId.NumBuiltIn for dynamic techniques.\n  private readonly _dynamicTechniqueIds = new Array<string>(); // technique ID = (index in this array) + TechniqueId.NumBuiltIn\n\n  public static create(gl: WebGLRenderingContext): Techniques {\n    const techs = new Techniques();\n    techs.initializeBuiltIns(gl);\n    return techs;\n  }\n\n  public getTechnique(id: TechniqueId): Technique {\n    assert(id < this._list.length, \"technique index out of bounds\");\n    return this._list[id];\n  }\n\n  public addDynamicTechnique(technique: Technique, name: string): TechniqueId {\n    for (let i = 0; i < this._dynamicTechniqueIds.length; i++) {\n      if (this._dynamicTechniqueIds[i] === name) {\n        return TechniqueId.NumBuiltIn + i;\n      }\n    }\n\n    this._dynamicTechniqueIds.push(name);\n    this._list.push(technique);\n    return TechniqueId.NumBuiltIn + this._dynamicTechniqueIds.length - 1;\n  }\n\n  private readonly _scratchTechniqueFlags = new TechniqueFlags();\n\n  /** Execute each command in the list */\n  public execute(target: Target, commands: DrawCommands, renderPass: RenderPass) {\n    assert(RenderPass.None !== renderPass, \"invalid render pass\");\n\n    const flags = this._scratchTechniqueFlags;\n    using(new ShaderProgramExecutor(target, renderPass), (executor: ShaderProgramExecutor) => {\n      let omitCounter = 0;\n      for (const command of commands) {\n        const omitStatus = command.getOmitStatus(target);\n        if ((omitCounter += omitStatus) !== 0 || omitStatus !== OmitStatus.Neutral)\n          continue;\n        command.preExecute(executor);\n        const techniqueId = command.getTechniqueId(target);\n        if (TechniqueId.Invalid !== techniqueId) {\n          // A primitive command.\n          assert(command.isPrimitiveCommand, \"expected primitive command\");\n          const shadowable = techniqueId === TechniqueId.Surface && target.solarShadowMap !== undefined && target.solarShadowMap.isReady;   // TBD - Avoid shadows for pick?\n          flags.init(target, renderPass, IsInstanced.No, IsAnimated.No, target.planarClassifiers.isValid ? IsClassified.Yes : IsClassified.No, shadowable ? IsShadowable.Yes : IsShadowable.No);\n          flags.setAnimated(command.hasAnimation);\n          flags.setInstanced(command.isInstanced);\n          const tech = this.getTechnique(techniqueId);\n          const program = tech.getShader(flags);\n          if (executor.setProgram(program)) {\n            command.execute(executor);\n          }\n        } else {\n          // A branch command.\n          assert(!command.isPrimitiveCommand, \"expected non-primitive command\");\n          command.execute(executor);\n        }\n\n        command.postExecute(executor);\n      }\n    });\n  }\n\n  /** Execute the commands for a single given classification primitive */\n  public executeForIndexedClassifier(target: Target, cmdsByIndex: DrawCommands, renderPass: RenderPass, index: number, techId?: TechniqueId) {\n    assert(RenderPass.None !== renderPass, \"invalid render pass\");\n    // There should be 3 commands per classifier in the cmdsByIndex array.\n    index *= 3;\n    if (index < 0 || index > cmdsByIndex.length - 3)\n      return; // index out of range\n\n    const pushCmd = cmdsByIndex[index];\n    const primCmd = cmdsByIndex[index + 1];\n    const popCmd = cmdsByIndex[index + 2];\n\n    const flags = this._scratchTechniqueFlags;\n    using(new ShaderProgramExecutor(target, renderPass), (executor: ShaderProgramExecutor) => {\n\n      // First execute the push.\n      pushCmd.preExecute(executor);\n      let techniqueId = pushCmd.getTechniqueId(target);\n      assert(TechniqueId.Invalid === techniqueId);\n      assert(!pushCmd.isPrimitiveCommand, \"expected non-primitive command\");\n      pushCmd.execute(executor);\n      pushCmd.postExecute(executor);\n\n      // Execute the command for the given classification primitive.\n      primCmd.preExecute(executor);\n      techniqueId = primCmd.getTechniqueId(target);\n      assert(TechniqueId.Invalid !== techniqueId);\n      // A primitive command.\n      assert(primCmd.isPrimitiveCommand, \"expected primitive command\");\n      flags.init(target, renderPass, IsInstanced.No);\n      flags.setAnimated(primCmd.hasAnimation);\n      const tech = this.getTechnique(undefined !== techId ? techId : techniqueId);\n      const program = tech.getShader(flags);\n      if (executor.setProgram(program)) {\n        primCmd.execute(executor);\n      }\n      primCmd.postExecute(executor);\n\n      // Execute the batch pop.\n      popCmd.preExecute(executor);\n      techniqueId = popCmd.getTechniqueId(target);\n      assert(TechniqueId.Invalid === techniqueId);\n      assert(!popCmd.isPrimitiveCommand, \"expected non-primitive command\");\n      popCmd.execute(executor);\n      popCmd.postExecute(executor);\n    });\n  }\n\n  /** Draw a single primitive. Usually used for special-purpose rendering techniques. */\n  public draw(params: DrawParams): void {\n    const tech = this.getTechnique(params.geometry.getTechniqueId(params.target));\n    const program = tech.getShader(TechniqueFlags.defaults);\n    using(new ShaderProgramExecutor(params.target, params.renderPass, program), (executor: ShaderProgramExecutor) => {\n      assert(executor.isValid);\n      if (executor.isValid) {\n        executor.draw(params);\n      }\n    });\n  }\n\n  public dispose(): void {\n    for (const tech of this._list)\n      dispose(tech);\n    this._list.length = 0;\n  }\n\n  // Chiefly for tests - compiles all shader programs - more generally programs are compiled on demand.\n  public compileShaders(): boolean {\n    let allCompiled = true;\n\n    for (const tech of this._list) {\n      if (!tech.compileShaders()) {\n        allCompiled = false;\n      }\n    }\n\n    return allCompiled;\n  }\n\n  private constructor() { }\n\n  private initializeBuiltIns(gl: WebGLRenderingContext): void {\n    this._list[TechniqueId.OITClearTranslucent] = new SingularTechnique(createClearTranslucentProgram(gl));\n    this._list[TechniqueId.ClearPickAndColor] = new SingularTechnique(createClearPickAndColorProgram(gl));\n    this._list[TechniqueId.CopyColor] = new SingularTechnique(createCopyColorProgram(gl));\n    this._list[TechniqueId.CopyColorNoAlpha] = new SingularTechnique(createCopyColorProgram(gl, false));\n    this._list[TechniqueId.CopyPickBuffers] = new SingularTechnique(createCopyPickBuffersProgram(gl));\n    this._list[TechniqueId.CopyStencil] = new SingularTechnique(createCopyStencilProgram(gl));\n    this._list[TechniqueId.ClipMask] = new SingularTechnique(createClipMaskProgram(gl));\n    this._list[TechniqueId.SkyBox] = new SingularTechnique(createSkyBoxProgram(gl));\n    this._list[TechniqueId.SkySphereGradient] = new SingularTechnique(createSkySphereProgram(gl, true));\n    this._list[TechniqueId.SkySphereTexture] = new SingularTechnique(createSkySphereProgram(gl, false));\n    this._list[TechniqueId.AmbientOcclusion] = new SingularTechnique(createAmbientOcclusionProgram(gl));\n    this._list[TechniqueId.Blur] = new SingularTechnique(createBlurProgram(gl));\n    this._list[TechniqueId.CombineTextures] = new SingularTechnique(createCombineTexturesProgram(gl));\n    this._list[TechniqueId.Surface] = new SurfaceTechnique(gl);\n    this._list[TechniqueId.Edge] = new EdgeTechnique(gl, false);\n    this._list[TechniqueId.SilhouetteEdge] = new EdgeTechnique(gl, true);\n    this._list[TechniqueId.Polyline] = new PolylineTechnique(gl);\n    this._list[TechniqueId.PointString] = new PointStringTechnique(gl);\n    this._list[TechniqueId.PointCloud] = new PointCloudTechnique(gl);\n\n    for (let compositeFlags = 1; compositeFlags <= 7; compositeFlags++) {\n      const techId = computeCompositeTechniqueId(compositeFlags);\n      this._list[techId] = new SingularTechnique(createCompositeProgram(compositeFlags, gl));\n    }\n\n    assert(this._list.length === TechniqueId.NumBuiltIn, \"unexpected number of built-in techniques\");\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { System } from \"./System\";\nimport { Target } from \"./Target\";\nimport { RenderPass } from \"./RenderFlags\";\nimport { ClippingType } from \"../System\";\nimport { RenderMode } from \"@bentley/imodeljs-common\";\n\n// tslint:disable:no-const-enum\n\n/** Specifies how a TechniqueFlags handles feature table/overrides.\n * @internal\n */\nexport const enum FeatureMode {\n  None,       // no features\n  Pick,       // feature table only\n  Overrides,  // feature table with symbology overrides\n}\n\n/** Meta data for what type of clip volume is being stored (mask or planes).\n * @internal\n */\nexport class ClipDef {\n  public type: ClippingType;\n  public numberOfPlanes: number;\n\n  public constructor(type: ClippingType = ClippingType.None, numberOfPlanes: number = 0) { this.type = type; this.numberOfPlanes = numberOfPlanes; }\n  public static forMask() { return new ClipDef(ClippingType.Mask); }\n  public static forPlanes(numPlanes: number) { return new ClipDef(ClippingType.Planes, numPlanes); }\n}\n\n/** @internal */\nexport const enum IsInstanced { No, Yes }\n\n/** @internal */\nexport const enum IsAnimated { No, Yes }\n\n/** @internal */\nexport const enum IsClassified { No, Yes }\n\n/** @internal */\nexport const enum IsEdgeTestNeeded { No, Yes }\nexport const enum IsShadowable { No, Yes }\n\n/** Flags used to control which shader program is used by a rendering Technique.\n * @internal\n */\nexport class TechniqueFlags {\n  public clip: ClipDef = new ClipDef();\n  public featureMode = FeatureMode.None;\n  public isTranslucent: boolean;\n  public isEdgeTestNeeded: IsEdgeTestNeeded = IsEdgeTestNeeded.No;\n  public isAnimated: IsAnimated = IsAnimated.No;\n  public isInstanced: IsInstanced = IsInstanced.No;\n  public isClassified: IsClassified = IsClassified.No;\n  public isShadowable: IsShadowable = IsShadowable.No;\n  private _isHilite = false;\n\n  public constructor(translucent: boolean = false) {\n    this.isTranslucent = translucent;\n  }\n\n  public get hasClip(): boolean { return this.clip.type !== ClippingType.None; }\n\n  public init(target: Target, pass: RenderPass, instanced: IsInstanced, animated: IsAnimated = IsAnimated.No, classified = IsClassified.No, shadowable = IsShadowable.No): void {\n    if (RenderPass.Hilite === pass || RenderPass.HiliteClassification === pass || RenderPass.HilitePlanarClassification === pass) {\n      this.initForHilite(target.clipDef, instanced, (classified === IsClassified.Yes && RenderPass.HilitePlanarClassification === pass) ? IsClassified.Yes : IsClassified.No);\n    } else {\n      this._isHilite = false;\n      this.isTranslucent = RenderPass.Translucent === pass;\n      this.clip = target.clipDef;\n      this.isAnimated = shadowable ? IsAnimated.No : animated;    // no animation with shadows (they share texture unit).\n      this.isInstanced = instanced;\n      this.isClassified = classified;\n      this.isShadowable = shadowable;\n\n      if (undefined !== target.currentOverrides)\n        this.featureMode = FeatureMode.Overrides;\n      else if (0 !== target.currentBatchId)\n        this.featureMode = FeatureMode.Pick;\n      else\n        this.featureMode = FeatureMode.None;\n\n      // Determine if we should use the shaders which support discarding surfaces in favor of their edges (and discarding non-planar surfaces in favor of coincident planar surfaces).\n      // These are only useful if the geometry defines feature Ids.\n      // In 3d, if we're only displaying surfaces or edges, not both, don't bother, unless forceSurfaceDiscard is true.\n      this.isEdgeTestNeeded = this.hasFeatures ? (this.isClassified ? IsEdgeTestNeeded.No : IsEdgeTestNeeded.Yes) : IsEdgeTestNeeded.No;\n      if (!target.currentViewFlags.forceSurfaceDiscard && target.is3d && !target.isReadPixelsInProgress && System.instance.enableOptimizedSurfaceShaders && this.isEdgeTestNeeded) {\n        switch (target.currentViewFlags.renderMode) {\n          case RenderMode.Wireframe:\n            // We're only displaying edges (ignoring filled planar regions)\n            this.isEdgeTestNeeded = IsEdgeTestNeeded.No;\n            break;\n          case RenderMode.SmoothShade:\n            if (!target.currentViewFlags.visibleEdges && !target.wantAmbientOcclusion) {\n              // We're only display surfaces (ignoring filled planar regions). NB: Filled text with outline is handled by gl.polygonOffset().\n              this.isEdgeTestNeeded = IsEdgeTestNeeded.No;\n            }\n            break;\n          default:\n            // SolidFill and HiddenLine always display edges and surfaces.\n            break;\n        }\n      }\n    }\n  }\n\n  public reset(mode: FeatureMode, instanced: IsInstanced = IsInstanced.No, shadowable: IsShadowable) {\n    this._isHilite = false;\n    this.featureMode = mode;\n    this.isTranslucent = false;\n    this.isEdgeTestNeeded = IsEdgeTestNeeded.No;\n    this.isAnimated = IsAnimated.No;\n    this.isClassified = IsClassified.No;\n    this.isInstanced = instanced;\n    this.isShadowable = shadowable;\n    this.clip.type = ClippingType.None;\n    this.clip.numberOfPlanes = 0;\n  }\n\n  public get hasFeatures() { return FeatureMode.None !== this.featureMode; }\n\n  public setAnimated(animated: boolean) { this.isAnimated = animated ? IsAnimated.Yes : IsAnimated.No; }\n  public setInstanced(instanced: boolean) { this.isInstanced = instanced ? IsInstanced.Yes : IsInstanced.No; }\n  public setClassified(classified: boolean) {\n    this.isClassified = classified ? IsClassified.Yes : IsClassified.No;\n  }\n\n  public get isHilite() { return this._isHilite; }\n  public initForHilite(clip: ClipDef, instanced: IsInstanced, classified: IsClassified) {\n    this.featureMode = classified ? FeatureMode.None : FeatureMode.Overrides;\n    this._isHilite = true;\n    this.isTranslucent = false;\n    this.isEdgeTestNeeded = IsEdgeTestNeeded.No;\n    this.isAnimated = IsAnimated.No;\n    this.isInstanced = instanced;\n    this.isClassified = classified;\n    this.clip = clip;\n  }\n\n  public buildDescription(): string {\n    const parts = [this.isTranslucent ? \"Translucent\" : \"Opaque\"];\n    if (this.isInstanced) parts.push(\"instanced\");\n    if (this.isEdgeTestNeeded) parts.push(\"edgeTestNeeded\");\n    if (this.isAnimated) parts.push(\"animated\");\n    if (this.isHilite) parts.push(\"hilite\");\n    if (this.isClassified) parts.push(\"classified\");\n    if (this.hasClip) parts.push(\"clip\");\n    if (this.isShadowable) parts.push(\"shadowable\");\n    if (this.hasFeatures) parts.push(FeatureMode.Pick === this.featureMode ? \"pick\" : \"overrides\");\n    return parts.join(\"; \");\n  }\n\n  public static readonly defaults = new TechniqueFlags();\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { CompositeFlags } from \"./RenderFlags\";\nimport { assert } from \"@bentley/bentleyjs-core\";\n\n// tslint:disable:no-const-enum\n\n/** Technique enumeration\n * @internal\n */\nexport const enum TechniqueId {\n  // Techniques with many different variations\n  Invalid = -1,\n  Surface,\n  Polyline,\n  PointCloud,\n  PointString,\n  Edge,\n  SilhouetteEdge,\n\n  // Techniques with a single associated shader that operates on the entire image\n  CompositeHilite,\n  CompositeTranslucent,\n  CompositeHiliteAndTranslucent,\n  CompositeOcclusion,\n  CompositeTranslucentAndOcclusion,\n  CompositeHiliteAndOcclusion,\n  CompositeAll,\n  OITClearTranslucent,\n  CopyPickBuffers,\n  CopyColor,\n  CopyColorNoAlpha,\n  CopyStencil,\n  ClearPickAndColor,\n  ClipMask,\n  SkyBox,\n  SkySphereGradient,\n  SkySphereTexture,\n  AmbientOcclusion,\n  Blur,\n  CombineTextures,\n\n  NumBuiltIn,\n  COUNT = NumBuiltIn,\n}\n\nconst compositeTechniqueIds = [\n  TechniqueId.Invalid, // None = 0\n  TechniqueId.CompositeTranslucent, // Translucent == 1 << 0\n  TechniqueId.CompositeHilite, // Hilite == 1 << 1 == 2\n  TechniqueId.CompositeHiliteAndTranslucent, // Hilite | Translucent == 1 | 2 == 3\n  TechniqueId.CompositeOcclusion, // AmbientOcclusion == 1 << 2 == 4\n  TechniqueId.CompositeTranslucentAndOcclusion, // Translucent | AmbientOcclusion == 1 | 4 == 5\n  TechniqueId.CompositeHiliteAndOcclusion, // Hilite | AmbientOcclusion == 2 | 4 == 6\n  TechniqueId.CompositeAll, // Translucent | Hilite | AmbientOcclusion == 1 | 2 | 4 == 7\n];\n\n/** @internal */\nexport function computeCompositeTechniqueId(flags: CompositeFlags): TechniqueId {\n  assert(flags >= 0 && flags <= 7);\n  return compositeTechniqueIds[flags];\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert, IDisposable, dispose } from \"@bentley/bentleyjs-core\";\nimport { ImageBuffer, ImageBufferFormat, isPowerOfTwo, nextHighestPowerOfTwo, RenderTexture } from \"@bentley/imodeljs-common\";\nimport { GL } from \"./GL\";\nimport { System } from \"./System\";\nimport { UniformHandle } from \"./Handle\";\nimport { TextureUnit, OvrFlags } from \"./RenderFlags\";\n\ntype CanvasOrImage = HTMLCanvasElement | HTMLImageElement;\n\n/** @internal */\nexport type Texture2DData = Uint8Array | Float32Array;\n\nfunction computeBytesUsed(width: number, height: number, format: GL.Texture.Format, dataType: GL.Texture.DataType): number {\n  const bytesPerComponent = GL.Texture.DataType.UnsignedByte === dataType ? 1 : 4;\n  let componentsPerPixel = 1;\n  switch (format) {\n    case GL.Texture.Format.Rgb:\n      componentsPerPixel = 3;\n      break;\n    case GL.Texture.Format.Rgba:\n      componentsPerPixel = 4;\n      break;\n  }\n\n  return width * height * componentsPerPixel * bytesPerComponent;\n}\n\n/** Associate texture data with a WebGLTexture from a canvas, image, OR a bitmap. */\nfunction loadTexture2DImageData(handle: TextureHandle, params: Texture2DCreateParams, bytes?: Texture2DData, element?: CanvasOrImage): void {\n  handle.bytesUsed = undefined !== bytes ? bytes.byteLength : computeBytesUsed(params.width, params.height, params.format, params.dataType);\n\n  const tex = handle.getHandle()!;\n  const gl = System.instance.context;\n\n  // Use tightly packed data\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n  // Bind the texture object; make sure we do not interfere with other active textures\n  System.instance.bindTexture2d(TextureUnit.Zero, tex);\n\n  // send the texture data\n  if (undefined !== element) {\n    gl.texImage2D(gl.TEXTURE_2D, 0, params.format, params.format, params.dataType, element);\n  } else {\n    const pixelData = undefined !== bytes ? bytes : null;\n    gl.texImage2D(gl.TEXTURE_2D, 0, params.format, params.width, params.height, 0, params.format, params.dataType, pixelData);\n  }\n\n  if (params.useMipMaps) {\n    gl.generateMipmap(gl.TEXTURE_2D);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_LINEAR);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  } else {\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, params.interpolate ? gl.LINEAR : gl.NEAREST);\n    gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, params.interpolate ? gl.LINEAR : gl.NEAREST);\n  }\n\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, params.wrapMode);\n  gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, params.wrapMode);\n\n  System.instance.bindTexture2d(TextureUnit.Zero, undefined);\n}\n\nfunction loadTextureFromBytes(handle: TextureHandle, params: Texture2DCreateParams, bytes?: Texture2DData): void { loadTexture2DImageData(handle, params, bytes); }\n\n/** Associate cube texture data with a WebGLTexture from an image. */\nfunction loadTextureCubeImageData(handle: TextureHandle, params: TextureCubeCreateParams, images: CanvasOrImage[]): void {\n  handle.bytesUsed = computeBytesUsed(params.dim * 6, params.dim, params.format, params.dataType);\n\n  const tex = handle.getHandle()!;\n  const gl = System.instance.context;\n\n  // Use tightly packed data\n  gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n  // Bind the texture object; make sure we do not interfere with other active textures\n  System.instance.bindTextureCubeMap(TextureUnit.Zero, tex);\n\n  const cubeTargets: number[] = [GL.Texture.Target.CubeMapPositiveX, GL.Texture.Target.CubeMapNegativeX, GL.Texture.Target.CubeMapPositiveY, GL.Texture.Target.CubeMapNegativeY, GL.Texture.Target.CubeMapPositiveZ, GL.Texture.Target.CubeMapNegativeZ];\n\n  for (let i = 0; i < 6; i++) {\n    gl.texImage2D(cubeTargets[i], 0, params.format, params.format, params.dataType, images[i]);\n  }\n\n  gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_MAG_FILTER, gl.LINEAR);\n  gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n  gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_S, params.wrapMode);\n  gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_T, params.wrapMode);\n  // gl.texParameteri(GL.Texture.Target.CubeMap, gl.TEXTURE_WRAP_R, params.wrapMode); // Unavailable in GLES2\n\n  System.instance.bindTextureCubeMap(TextureUnit.Zero, undefined);\n}\n\ntype TextureFlag = true | undefined;\ntype Load2DImageData = (handle: TextureHandle, params: Texture2DCreateParams) => void;\ntype LoadCubeImageData = (handle: TextureHandle, params: TextureCubeCreateParams) => void;\n\ninterface TextureImageProperties {\n  wrapMode: GL.Texture.WrapMode;\n  useMipMaps: TextureFlag;\n  interpolate: TextureFlag;\n  format: GL.Texture.Format;\n}\n\n/** Wrapper class for a WebGL texture handle and parameters specific to an individual texture.\n * @internal\n */\nexport class Texture extends RenderTexture {\n  public readonly texture: TextureHandle;\n\n  public get bytesUsed(): number { return this.texture.bytesUsed; }\n\n  public constructor(params: RenderTexture.Params, texture: TextureHandle) {\n    super(params);\n    this.texture = texture;\n  }\n\n  /** Free this object in the WebGL wrapper. */\n  public dispose() {\n    dispose(this.texture);\n  }\n\n  public get hasTranslucency(): boolean { return GL.Texture.Format.Rgba === this.texture.format; }\n}\n\nfunction getDataType(data: Texture2DData): GL.Texture.DataType {\n  return data instanceof Float32Array ? GL.Texture.DataType.Float : GL.Texture.DataType.UnsignedByte;\n}\n\n/** Parameters used internally to define how to create a texture for use with WebGL. */\nclass Texture2DCreateParams {\n  private constructor(\n    public width: number,\n    public height: number,\n    public format: GL.Texture.Format,\n    public dataType: GL.Texture.DataType,\n    public wrapMode: GL.Texture.WrapMode,\n    public loadImageData: Load2DImageData,\n    public useMipMaps?: TextureFlag,\n    public interpolate?: TextureFlag,\n    public dataBytes?: Uint8Array) { }\n\n  public static createForData(width: number, height: number, data: Texture2DData, preserveData = false, wrapMode = GL.Texture.WrapMode.ClampToEdge, format = GL.Texture.Format.Rgba) {\n    const bytes = (preserveData && data instanceof Uint8Array) ? data : undefined;\n    return new Texture2DCreateParams(width, height, format, getDataType(data), wrapMode,\n      (tex: TextureHandle, params: Texture2DCreateParams) => loadTextureFromBytes(tex, params, data), undefined, undefined, bytes);\n  }\n\n  public static createForImageBuffer(image: ImageBuffer, type: RenderTexture.Type) {\n    const props = this.getImageProperties(ImageBufferFormat.Rgba === image.format, type);\n\n    return new Texture2DCreateParams(image.width, image.height, props.format, GL.Texture.DataType.UnsignedByte, props.wrapMode,\n      (tex: TextureHandle, params: Texture2DCreateParams) => loadTextureFromBytes(tex, params, image.data), props.useMipMaps, props.interpolate);\n  }\n\n  public static createForAttachment(width: number, height: number, format: GL.Texture.Format, dataType: GL.Texture.DataType) {\n    return new Texture2DCreateParams(width, height, format, dataType, GL.Texture.WrapMode.ClampToEdge,\n      (tex: TextureHandle, params: Texture2DCreateParams) => loadTextureFromBytes(tex, params), undefined, undefined);\n  }\n\n  public static createForImage(image: HTMLImageElement, hasAlpha: boolean, type: RenderTexture.Type) {\n    const props = this.getImageProperties(hasAlpha, type);\n\n    let targetWidth = image.naturalWidth;\n    let targetHeight = image.naturalHeight;\n\n    const caps = System.instance.capabilities;\n    if (RenderTexture.Type.Glyph === type) {\n      targetWidth = nextHighestPowerOfTwo(targetWidth);\n      targetHeight = nextHighestPowerOfTwo(targetHeight);\n    } else if (!caps.supportsNonPowerOf2Textures && (!isPowerOfTwo(targetWidth) || !isPowerOfTwo(targetHeight))) {\n      if (GL.Texture.WrapMode.ClampToEdge === props.wrapMode) {\n        // NPOT are supported but not mipmaps\n        // Probably on poor hardware so I choose to disable mipmaps for lower memory usage over quality. If quality is required we need to resize the image to a pow of 2.\n        // Above comment is not necessarily true - WebGL doesn't support NPOT mipmapping, only supporting base NPOT caps\n        props.useMipMaps = undefined;\n      } else if (GL.Texture.WrapMode.Repeat === props.wrapMode) {\n        targetWidth = nextHighestPowerOfTwo(targetWidth);\n        targetHeight = nextHighestPowerOfTwo(targetHeight);\n      }\n    }\n\n    // Cap texture dimensions to system WebGL capabilities\n    const maxTexSize = System.instance.capabilities.maxTextureSize;\n    targetWidth = Math.min(targetWidth, maxTexSize);\n    targetHeight = Math.min(targetHeight, maxTexSize);\n\n    let element: CanvasOrImage = image;\n    if (targetWidth !== image.naturalWidth || targetHeight !== image.naturalHeight) {\n      // Resize so dimensions are powers-of-two\n      const canvas = document.createElement(\"canvas\");\n      canvas.width = targetWidth;\n      canvas.height = targetHeight;\n\n      const context = canvas.getContext(\"2d\")!;\n      context.drawImage(image, 0, 0, canvas.width, canvas.height);\n\n      element = canvas;\n    }\n\n    return new Texture2DCreateParams(targetWidth, targetHeight, props.format, GL.Texture.DataType.UnsignedByte, props.wrapMode,\n      (tex: TextureHandle, params: Texture2DCreateParams) => loadTexture2DImageData(tex, params, undefined, element), props.useMipMaps, props.interpolate);\n  }\n\n  private static getImageProperties(isTranslucent: boolean, type: RenderTexture.Type): TextureImageProperties {\n    const isSky = RenderTexture.Type.SkyBox === type;\n    const isTile = RenderTexture.Type.TileSection === type;\n\n    const wrapMode = RenderTexture.Type.Normal === type ? GL.Texture.WrapMode.Repeat : GL.Texture.WrapMode.ClampToEdge;\n    const useMipMaps: TextureFlag = (!isSky && !isTile) ? true : undefined;\n    const interpolate: TextureFlag = true;\n    const format = isTranslucent ? GL.Texture.Format.Rgba : GL.Texture.Format.Rgb;\n\n    return { format, wrapMode, useMipMaps, interpolate };\n  }\n\n  public static readonly placeholderParams = new Texture2DCreateParams(1, 1, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte, GL.Texture.WrapMode.ClampToEdge,\n    (_tex: TextureHandle, _params: Texture2DCreateParams) => undefined);\n}\n\nclass TextureCubeCreateParams {\n  private constructor(\n    public dim: number,\n    public format: GL.Texture.Format,\n    public dataType: GL.Texture.DataType,\n    public wrapMode: GL.Texture.WrapMode,\n    public loadImageData: LoadCubeImageData) { }\n\n  public static createForCubeImages(posX: HTMLImageElement, negX: HTMLImageElement, posY: HTMLImageElement, negY: HTMLImageElement, posZ: HTMLImageElement, negZ: HTMLImageElement): TextureCubeCreateParams | undefined {\n    const targetDim = posX.naturalWidth;\n\n    if (posX.naturalHeight !== targetDim) // Cube texture dimensions must match (width must equal height)\n      return undefined;\n\n    const images: HTMLImageElement[] = [posX, negX, posY, negY, posZ, negZ];\n\n    for (let i = 1; i < images.length; i++) { // Dimensions of all six sides must match each other\n      if (images[i].naturalWidth !== targetDim || images[i].naturalHeight !== targetDim)\n        return undefined;\n    }\n\n    return new TextureCubeCreateParams(targetDim, GL.Texture.Format.Rgba, GL.Texture.DataType.UnsignedByte, GL.Texture.WrapMode.ClampToEdge,\n      (tex: TextureHandle, params: TextureCubeCreateParams) => loadTextureCubeImageData(tex, params, images));\n  }\n}\n\n/** Wraps a WebGLTextureHandle\n * @internal\n */\nexport abstract class TextureHandle implements IDisposable {\n  protected _glTexture?: WebGLTexture;\n  protected _bytesUsed = 0;\n\n  public abstract get width(): number;\n  public abstract get height(): number;\n  public abstract get format(): GL.Texture.Format;\n  public abstract get dataType(): GL.Texture.DataType;\n  public abstract get dataBytes(): Uint8Array | undefined;\n  public get bytesUsed(): number { return this._bytesUsed; }\n  public set bytesUsed(bytesUsed: number) {\n    assert(0 === this.bytesUsed);\n    this._bytesUsed = bytesUsed;\n  }\n\n  /** Get the WebGLTexture for this TextureHandle. */\n  public getHandle(): WebGLTexture | undefined { return this._glTexture; }\n\n  /** Bind texture handle (if available) associated with an instantiation of this class to specified texture unit. */\n  public abstract bind(_texUnit: TextureUnit): boolean;\n\n  /** Bind this texture to a uniform sampler. */\n  public abstract bindSampler(_uniform: UniformHandle, _unit: TextureUnit): void;\n\n  public get isDisposed(): boolean { return this._glTexture === undefined; }\n\n  public dispose() {\n    if (!this.isDisposed) {\n      System.instance.disposeTexture(this._glTexture!);\n      this._glTexture = undefined;\n    }\n  }\n\n  /** Create a 2D texture for use as a color attachment for rendering */\n  public static createForAttachment(width: number, height: number, format: GL.Texture.Format, dataType: GL.Texture.DataType) {\n    return Texture2DHandle.createForAttachment(width, height, format, dataType);\n  }\n\n  /** Create a 2D texture to hold non-image data */\n  public static createForData(width: number, height: number, data: Texture2DData, wantPreserveData = false, wrapMode = GL.Texture.WrapMode.ClampToEdge, format = GL.Texture.Format.Rgba) {\n    return Texture2DHandle.createForData(width, height, data, wantPreserveData, wrapMode, format);\n  }\n\n  /** Create a 2D texture from a bitmap */\n  public static createForImageBuffer(image: ImageBuffer, type: RenderTexture.Type) {\n    return Texture2DHandle.createForImageBuffer(image, type);\n  }\n\n  /** Create a 2D texture from an HTMLImageElement. */\n  public static createForImage(image: HTMLImageElement, hasAlpha: boolean, type: RenderTexture.Type) {\n    return Texture2DHandle.createForImage(image, hasAlpha, type);\n  }\n\n  /** Create a cube map texture from six HTMLImageElement objects. */\n  public static createForCubeImages(posX: HTMLImageElement, negX: HTMLImageElement, posY: HTMLImageElement, negY: HTMLImageElement, posZ: HTMLImageElement, negZ: HTMLImageElement) {\n    return TextureCubeHandle.createForCubeImages(posX, negX, posY, negY, posZ, negZ);\n  }\n\n  protected constructor(glTexture: WebGLTexture) {\n    this._glTexture = glTexture;\n  }\n}\n\n/** @internal */\nexport class Texture2DHandle extends TextureHandle {\n  private _width: number;\n  private _height: number;\n  private _format: GL.Texture.Format;\n  private _dataType: GL.Texture.DataType;\n  private _dataBytes?: Uint8Array;\n\n  public get width(): number { return this._width; }\n  public get height(): number { return this._height; }\n  public get format(): GL.Texture.Format { return this._format; }\n  public get dataType(): GL.Texture.DataType { return this._dataType; }\n  public get dataBytes(): Uint8Array | undefined { return this._dataBytes; }\n\n  /** Bind specified texture handle to specified texture unit. */\n  public static bindTexture(texUnit: TextureUnit, glTex: WebGLTexture | undefined) {\n    assert(!(glTex instanceof TextureHandle));\n    System.instance.bindTexture2d(texUnit, glTex);\n  }\n\n  /** Bind the specified texture to a uniform sampler2D */\n  public static bindSampler(uniform: UniformHandle, tex: WebGLTexture, unit: TextureUnit): void {\n    assert(!(tex instanceof TextureHandle));\n    this.bindTexture(unit, tex);\n    uniform.setUniform1i(unit - TextureUnit.Zero);\n  }\n\n  /** Bind texture handle (if available) associated with an instantiation of this class to specified texture unit. */\n  public bind(texUnit: TextureUnit): boolean {\n    if (undefined === this._glTexture)\n      return false;\n    Texture2DHandle.bindTexture(texUnit, this._glTexture);\n    return true;\n  }\n\n  /** Bind this texture to a uniform sampler2D */\n  public bindSampler(uniform: UniformHandle, unit: TextureUnit): void {\n    if (undefined !== this._glTexture)\n      Texture2DHandle.bindSampler(uniform, this._glTexture, unit);\n  }\n\n  /** Update the 2D texture contents. */\n  public update(updater: Texture2DDataUpdater): boolean {\n    if (0 === this.width || 0 === this.height || undefined === this._dataBytes || 0 === this._dataBytes.length) {\n      assert(false);\n      return false;\n    }\n\n    if (!updater.modified)\n      return false;\n\n    return this.replaceTextureData(this._dataBytes);\n  }\n\n  /** Replace the 2D texture contents. */\n  public replaceTextureData(data: Texture2DData): boolean {\n    assert((GL.Texture.DataType.Float === this._dataType) === (data instanceof Float32Array));\n\n    const tex = this.getHandle()!;\n    if (undefined === tex)\n      return false;\n\n    const gl = System.instance.context;\n    gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);\n\n    // Go through System to ensure we don't interfere with currently-bound textures!\n    System.instance.bindTexture2d(TextureUnit.Zero, tex);\n    gl.texSubImage2D(gl.TEXTURE_2D, 0, 0, 0, this.width, this.height, this._format, this._dataType, data);\n    System.instance.bindTexture2d(TextureUnit.Zero, undefined);\n\n    return true;\n  }\n\n  private static create(params: Texture2DCreateParams): Texture2DHandle | undefined {\n    const glTex = System.instance.context.createTexture();\n    return null !== glTex ? new Texture2DHandle(glTex, params) : undefined;\n  }\n\n  /** Create a texture for use as a color attachment for rendering */\n  public static createForAttachment(width: number, height: number, format: GL.Texture.Format, dataType: GL.Texture.DataType) {\n    return this.create(Texture2DCreateParams.createForAttachment(width, height, format, dataType));\n  }\n\n  /** Create a texture to hold non-image data */\n  public static createForData(width: number, height: number, data: Texture2DData, wantPreserveData = false, wrapMode = GL.Texture.WrapMode.ClampToEdge, format = GL.Texture.Format.Rgba) {\n    return this.create(Texture2DCreateParams.createForData(width, height, data, wantPreserveData, wrapMode, format));\n  }\n\n  /** Create a texture from a bitmap */\n  public static createForImageBuffer(image: ImageBuffer, type: RenderTexture.Type) {\n    assert(isPowerOfTwo(image.width) && isPowerOfTwo(image.height), \"###TODO: Resize image dimensions to powers-of-two if necessary\");\n    return this.create(Texture2DCreateParams.createForImageBuffer(image, type));\n  }\n\n  /** Create a 2D texture from an HTMLImageElement. */\n  public static createForImage(image: HTMLImageElement, hasAlpha: boolean, type: RenderTexture.Type) {\n    return this.create(Texture2DCreateParams.createForImage(image, hasAlpha, type));\n  }\n\n  private constructor(glTexture: WebGLTexture, params: Texture2DCreateParams) {\n    super(glTexture);\n    this._width = params.width;\n    this._height = params.height;\n    this._format = params.format;\n    this._dataType = params.dataType;\n    this._dataBytes = params.dataBytes;\n\n    params.loadImageData(this, params);\n  }\n}\n\n/** @internal */\nexport class TextureCubeHandle extends TextureHandle {\n  private _dim: number; // Cubemap texture height and width must match.  This must be the same for each of the six faces.\n  private _format: GL.Texture.Format; // Format must be the same for each of the six faces.\n  private _dataType: GL.Texture.DataType; // Type must be the same for each of the six faces.\n\n  public get width(): number { return this._dim; }\n  public get height(): number { return this._dim; }\n  public get format(): GL.Texture.Format { return this._format; }\n  public get dataType(): GL.Texture.DataType { return this._dataType; }\n  public get dataBytes(): Uint8Array | undefined { return undefined; }\n\n  /** Bind specified cubemap texture handle to specified texture unit. */\n  public static bindTexture(texUnit: TextureUnit, glTex: WebGLTexture | undefined) {\n    assert(!(glTex instanceof TextureHandle));\n    System.instance.bindTextureCubeMap(texUnit, glTex);\n  }\n\n  /** Bind the specified texture to a uniform sampler2D */\n  public static bindSampler(uniform: UniformHandle, tex: WebGLTexture, unit: TextureUnit): void {\n    assert(!(tex instanceof TextureHandle));\n    this.bindTexture(unit, tex);\n    uniform.setUniform1i(unit - TextureUnit.Zero);\n  }\n\n  /** Bind texture handle (if available) associated with an instantiation of this class to specified texture unit. */\n  public bind(texUnit: TextureUnit): boolean {\n    if (undefined === this._glTexture)\n      return false;\n    TextureCubeHandle.bindTexture(texUnit, this._glTexture);\n    return true;\n  }\n\n  /** Bind this texture to a uniform sampler2D */\n  public bindSampler(uniform: UniformHandle, unit: TextureUnit): void {\n    if (undefined !== this._glTexture)\n      TextureCubeHandle.bindSampler(uniform, this._glTexture, unit);\n  }\n\n  private static create(params: TextureCubeCreateParams): TextureHandle | undefined {\n    const glTex = System.instance.context.createTexture();\n    return null !== glTex ? new TextureCubeHandle(glTex, params) : undefined;\n  }\n\n  /** Create a cube map texture from six HTMLImageElement objects. */\n  public static createForCubeImages(posX: HTMLImageElement, negX: HTMLImageElement, posY: HTMLImageElement, negY: HTMLImageElement, posZ: HTMLImageElement, negZ: HTMLImageElement) {\n    const params = TextureCubeCreateParams.createForCubeImages(posX, negX, posY, negY, posZ, negZ);\n    return params !== undefined ? this.create(params) : undefined;\n  }\n\n  private constructor(glTexture: WebGLTexture, params: TextureCubeCreateParams) {\n    super(glTexture);\n    this._dim = params.dim;\n    this._format = params.format;\n    this._dataType = params.dataType;\n\n    params.loadImageData(this, params);\n  }\n}\n\n/** @internal */\nexport class Texture2DDataUpdater {\n  public data: Uint8Array;\n  public modified: boolean = false;\n\n  public constructor(data: Uint8Array) { this.data = data; }\n\n  public setByteAtIndex(index: number, byte: number) {\n    assert(index < this.data.length);\n    if (byte !== this.data[index]) {\n      this.data[index] = byte;\n      this.modified = true;\n    }\n  }\n  public setOvrFlagsAtIndex(index: number, value: OvrFlags) {\n    assert(index < this.data.length);\n    if (value !== this.data[index]) {\n      this.data[index] = value;\n      this.modified = true;\n    }\n  }\n  public getByteAtIndex(index: number): number { assert(index < this.data.length); return this.data[index]; }\n  public getFlagsAtIndex(index: number): OvrFlags { return this.getByteAtIndex(index); }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { IDisposable, dispose } from \"@bentley/bentleyjs-core\";\nimport { QParams2d, QParams3d } from \"@bentley/imodeljs-common\";\nimport { ColorInfo } from \"./ColorInfo\";\nimport { TextureHandle } from \"./Texture\";\nimport { qparams2dToArray, qorigin3dToArray, qscale3dToArray } from \"./Handle\";\nimport { VertexTable } from \"../primitives/VertexTable\";\nimport { AuxChannelTable, AuxChannel, AuxDisplacementChannel, AuxParamChannel } from \"../primitives/AuxChannelTable\";\n\ntype ChannelPropName = \"normals\" | \"displacements\" | \"params\";\n\n/** @internal */\nexport class AuxChannelLUT implements IDisposable {\n  public readonly texture: TextureHandle;\n  public readonly numVertices: number;\n  public readonly numBytesPerVertex: number;\n  public displacements?: Map<string, AuxDisplacementChannel>;\n  public normals?: Map<string, AuxChannel>;\n  public params?: Map<string, AuxParamChannel>;\n\n  private constructor(texture: TextureHandle, table: AuxChannelTable) {\n    this.texture = texture;\n    this.numVertices = table.numVertices;\n    this.numBytesPerVertex = table.numBytesPerVertex;\n\n    this.initChannels<AuxDisplacementChannel>(table, \"displacements\");\n    this.initChannels<AuxChannel>(table, \"normals\");\n    this.initChannels<AuxParamChannel>(table, \"params\");\n  }\n\n  private initChannels<T extends AuxChannel>(table: AuxChannelTable, name: ChannelPropName): void {\n    const channels = table[name];\n    if (undefined === channels)\n      return;\n\n    const map = (this[name] = new Map<string, T>());\n    for (const channel of channels) {\n      // Compiler doesn't appear to deduce specific T here? 'as any' to work around...\n      // error TS2345: Argument of type 'AuxChannel | AuxDisplacementChannel | AuxParamChannel' is not assignable to parameter of type 'T'.\n      map.set(channel.name, channel as any);\n    }\n  }\n\n  public get bytesUsed(): number { return this.texture.bytesUsed; }\n  public get hasScalarAnimation() { return undefined !== this.params; }\n\n  public dispose() {\n    dispose(this.texture);\n  }\n\n  public static create(table: AuxChannelTable): AuxChannelLUT | undefined {\n    const texture = TextureHandle.createForData(table.width, table.height, table.data);\n    return undefined !== texture ? new AuxChannelLUT(texture, table) : undefined;\n  }\n}\n\n/** Represents the finished lookup table ready for submittal to GPU.\n * @internal\n */\nexport class VertexLUT implements IDisposable {\n  public readonly texture: TextureHandle; // Texture containing vertex data\n  public readonly numVertices: number;\n  public readonly numRgbaPerVertex: number;\n  public readonly colorInfo: ColorInfo;\n  public readonly qOrigin: Float32Array;  // Origin of quantized positions\n  public readonly qScale: Float32Array;   // Scale of quantized positions\n  public readonly uvQParams?: Float32Array; // If vertices contain texture UV params, quantization parameters as [origin.x, origin.y, scale.x, scale.y ]\n  public readonly auxChannels?: AuxChannelLUT;\n\n  public get hasAnimation() { return undefined !== this.auxChannels; }\n  public get hasScalarAnimation() { return undefined !== this.auxChannels && this.auxChannels.hasScalarAnimation; }\n\n  public get bytesUsed(): number {\n    let bytesUsed = this.texture.bytesUsed;\n    if (undefined !== this.auxChannels)\n      bytesUsed += this.auxChannels.bytesUsed;\n\n    return bytesUsed;\n  }\n\n  public static createFromVertexTable(vt: VertexTable, aux?: AuxChannelTable): VertexLUT | undefined {\n    const texture = TextureHandle.createForData(vt.width, vt.height, vt.data);\n    if (undefined === texture)\n      return undefined;\n\n    const auxLUT = undefined !== aux ? AuxChannelLUT.create(aux) : undefined;\n    return new VertexLUT(texture, vt, ColorInfo.createFromVertexTable(vt), vt.qparams, vt.uvParams, auxLUT);\n  }\n\n  private constructor(texture: TextureHandle, table: VertexTable, colorInfo: ColorInfo, qparams: QParams3d, uvParams?: QParams2d, auxChannels?: AuxChannelLUT) {\n    this.texture = texture;\n    this.numVertices = table.numVertices;\n    this.numRgbaPerVertex = table.numRgbaPerVertex;\n    this.colorInfo = colorInfo;\n    this.qOrigin = qorigin3dToArray(qparams.origin);\n    this.qScale = qscale3dToArray(qparams.scale);\n    this.auxChannels = auxChannels;\n\n    if (undefined !== uvParams)\n      this.uvQParams = qparams2dToArray(uvParams);\n  }\n\n  public dispose() {\n    dispose(this.texture);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\n// portions adapted from Cesium.js Copyright 2011 - 2017 Cesium Contributors\n\nimport { TextureUnit } from \"../RenderFlags\";\nimport { VariableType, FragmentShaderComponent, VariablePrecision } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { GLSLFragment, addWindowToTexCoords } from \"./Fragment\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { AmbientOcclusionGeometry } from \"../CachedGeometry\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { GLSLDecode } from \"./Decode\";\nimport { readDepthAndOrder } from \"./FeatureSymbology\";\nimport { addViewport } from \"./Viewport\";\nimport { addFrustum } from \"./Common\";\n\nconst computeAmbientOcclusion = `\n  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\n  float linearDepth = readDepthAndOrder(tc).y;\n  float nonLinearDepth = computeNonLinearDepth(linearDepth);\n  vec3 viewPos = computePositionFromDepth(tc, nonLinearDepth).xyz;\n\n  vec2 pixelSize = 1.0 / u_viewport.zw; // could use uniform for this\n  vec3 viewNormal = computeNormalFromDepth(viewPos, tc, pixelSize);\n\n  vec2 sampleDirection = vec2(1.0, 0.0);\n  float gapAngle = 90.0 * 0.017453292519943295; // radians per degree\n\n  // Grab some random noise\n  // Multiply screen UV (range 0..1) with size of viewport divided by 4 in order to tile the 4x4 noise texture across the screen.\n  // Multiply the random 0..1 vec3 by 2 and then substract 1.  This puts the components of the vec3 in the range -1..1.\n  vec3 noiseVec = (TEXTURE(u_noise, tc * vec2(u_viewport.z / 4.0, u_viewport.w / 4.0)).rgb + 1.0) / 2.0;\n\n  // Potential ###TODO: frustumLength (If the current fragment has a distance from the camera greater than this value, ambient occlusion is not computed for the fragment.)\n\n  float bias = u_hbaoSettings.x; // Represents an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value, sampling stops in the current direction. This is used to remove shadows from near planar edges.\n  float zLengthCap = u_hbaoSettings.y; // If the distance in linear Z from the current sample to first sample is greater than this value, sampling stops in the current direction.\n  float intensity = u_hbaoSettings.z; // Raise the final occlusion to the power of this value.  Larger values make the ambient shadows darker.\n  float texelStepSize = u_hbaoSettings.w; // Indicates the distance to step toward the next texel sample in the current direction.\n\n  float tOcclusion = 0.0;\n\n  // loop for each direction\n  for (int i = 0; i < 4; i++) {\n    float newGapAngle = gapAngle * (float(i) + noiseVec.x);\n    float cosVal = cos(newGapAngle);\n    float sinVal = sin(newGapAngle);\n\n    // rotate sampling direction\n    vec2 rotatedSampleDirection = vec2(cosVal * sampleDirection.x - sinVal * sampleDirection.y, sinVal * sampleDirection.x + cosVal * sampleDirection.y);\n    float curOcclusion = 0.0;\n    float curStepSize = texelStepSize; // 1.0 = stepsize, StepSize should be specified by uniform - what are good values?\n\n    // loop for each step\n    for (int j = 0; j < 6; j++) {\n      vec2 directionWithStep = vec2(rotatedSampleDirection.x * curStepSize * pixelSize.x, rotatedSampleDirection.y * curStepSize * pixelSize.y);\n      vec2 newCoords = directionWithStep + tc;\n\n      // do not repeat around the depth texture\n      if(newCoords.x > 1.0 || newCoords.y > 1.0 || newCoords.x < 0.0 || newCoords.y < 0.0) {\n          break;\n      }\n\n      float curLinearDepth = readDepthAndOrder(newCoords).y;\n      float curNonLinearDepth = computeNonLinearDepth(curLinearDepth);\n      vec3 curViewPos = computePositionFromDepth(newCoords, curNonLinearDepth).xyz;\n      vec3 diffVec = curViewPos.xyz - viewPos.xyz;\n      float zLength = abs(curLinearDepth - linearDepth);\n\n      float dotVal = clamp(dot(viewNormal, normalize(diffVec)), 0.0, 1.0);\n      float weight = smoothstep(0.0, 1.0, zLengthCap / zLength);\n\n      if (dotVal < bias) {\n          dotVal = 0.0;\n      }\n\n      curOcclusion = max(curOcclusion, dotVal * weight);\n      curStepSize += texelStepSize;\n    }\n    tOcclusion += curOcclusion;\n  }\n\n  tOcclusion /= 4.0;\n  tOcclusion = 1.0 - clamp(tOcclusion, 0.0, 1.0);\n  tOcclusion = pow(tOcclusion, intensity);\n\n  return vec4(tOcclusion, tOcclusion, tOcclusion, 1.0);\n`;\n\nconst computeNonLinearDepth = `\nfloat computeNonLinearDepth(float linearDepth) {\n  return mix(u_frustum.y, u_frustum.x, linearDepth);\n}\n`;\n\nconst computePositionFromDepth = `\nvec4 computePositionFromDepth(vec2 tc, float nonLinearDepth) {\n  if (kFrustumType_Perspective == u_frustum.z) {\n    vec2 xy = vec2((tc.x * 2.0 - 1.0), ((1.0 - tc.y) * 2.0 - 1.0));\n    vec4 posEC = u_invProj * vec4(xy, nonLinearDepth, 1.0);\n    posEC = posEC / posEC.w;\n    return posEC;\n  } else {\n    float top = u_frustumPlanes.x;\n    float bottom = u_frustumPlanes.y;\n    float left = u_frustumPlanes.z;\n    float right = u_frustumPlanes.w;\n    return vec4(mix(left, right, tc.x), mix(bottom, top, tc.y), nonLinearDepth, 1.0);\n  }\n}\n`;\n\nconst computeNormalFromDepth = `\nvec3 computeNormalFromDepth(vec3 viewPos, vec2 tc, vec2 pixelSize) {\n  float nonLinearDepthU = computeNonLinearDepth(readDepthAndOrder(tc - vec2(0.0, pixelSize.y)).y);\n  float nonLinearDepthD = computeNonLinearDepth(readDepthAndOrder(tc + vec2(0.0, pixelSize.y)).y);\n  float nonLinearDepthL = computeNonLinearDepth(readDepthAndOrder(tc - vec2(pixelSize.x, 0.0)).y);\n  float nonLinearDepthR = computeNonLinearDepth(readDepthAndOrder(tc + vec2(pixelSize.x, 0.0)).y);\n\n  vec3 viewPosUp = computePositionFromDepth(tc - vec2(0.0, pixelSize.y), nonLinearDepthU).xyz;\n  vec3 viewPosDown = computePositionFromDepth(tc + vec2(0.0, pixelSize.y), nonLinearDepthD).xyz;\n  vec3 viewPosLeft = computePositionFromDepth(tc - vec2(pixelSize.x, 0.0), nonLinearDepthL).xyz;\n  vec3 viewPosRight = computePositionFromDepth(tc + vec2(pixelSize.x, 0.0), nonLinearDepthR).xyz;\n\n  vec3 up = viewPos.xyz - viewPosUp.xyz;\n  vec3 down = viewPosDown.xyz - viewPos.xyz;\n  vec3 left = viewPos.xyz - viewPosLeft.xyz;\n  vec3 right = viewPosRight.xyz - viewPos.xyz;\n\n  vec3 dx = length(left) < length(right) ? left : right;\n  vec3 dy = length(up) < length(down) ? up : down;\n\n  return normalize(cross(dy, dx));\n}\n`;\n\n/** @internal */\nexport function createAmbientOcclusionProgram(context: WebGLRenderingContext): ShaderProgram {\n  const builder = createViewportQuadBuilder(true);\n  const frag = builder.frag;\n\n  addWindowToTexCoords(frag);\n  frag.addFunction(GLSLDecode.depthRgb);\n  frag.addFunction(readDepthAndOrder);\n  frag.addFunction(computeNonLinearDepth);\n  frag.addFunction(computePositionFromDepth);\n  frag.addFunction(computeNormalFromDepth);\n  frag.addFunction(GLSLFragment.computeLinearDepth);\n\n  frag.set(FragmentShaderComponent.ComputeBaseColor, computeAmbientOcclusion);\n  frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n\n  frag.addUniform(\"u_pickDepthAndOrder\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_pickDepthAndOrder\", (uniform, params) => {\n      const geom = params.geometry as AmbientOcclusionGeometry;\n      Texture2DHandle.bindSampler(uniform, geom.depthAndOrder, TextureUnit.Zero);\n    });\n  });\n\n  frag.addUniform(\"u_noise\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_noise\", (uniform, params) => {\n      const geom = params.geometry as AmbientOcclusionGeometry;\n      Texture2DHandle.bindSampler(uniform, geom.noise, TextureUnit.One);\n    });\n  });\n\n  addFrustum(builder);\n  addViewport(frag);\n\n  frag.addUniform(\"u_invProj\", VariableType.Mat4, (prog) => {\n    prog.addProgramUniform(\"u_invProj\", (uniform, params) => {\n      const invProj = params.projectionMatrix.clone();\n      invProj.invert();\n      uniform.setMatrix4(invProj);\n    });\n  });\n\n  frag.addUniform(\"u_frustumPlanes\", VariableType.Vec4, (prog) => {\n    prog.addProgramUniform(\"u_frustumPlanes\", (uniform, params) => {\n      uniform.setUniform4fv(params.target.frustumUniforms.frustumPlanes);\n    });\n  });\n\n  frag.addUniform(\"u_hbaoSettings\", VariableType.Vec4, (prog) => {\n    prog.addProgramUniform(\"u_hbaoSettings\", (uniform, params) => {\n      const hbaoSettings = new Float32Array([\n        params.target.ambientOcclusionSettings.bias!,\n        params.target.ambientOcclusionSettings.zLengthCap!,\n        params.target.ambientOcclusionSettings.intensity!,\n        params.target.ambientOcclusionSettings.texelStepSize!]);\n      uniform.setUniform4fv(hbaoSettings);\n    });\n  }, VariablePrecision.High);\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module WebGL */\r\n\r\nimport { AuxChannel, AuxParamChannel, AuxDisplacementChannel } from \"../../primitives/AuxChannelTable\";\r\nimport { VertexShaderComponent, VertexShaderBuilder, VariableType } from \"../ShaderBuilder\";\r\nimport { DrawParams } from \"../DrawCommand\";\r\nimport { octDecodeNormal } from \"./Surface\";\r\nimport { AnalysisStyle, Gradient } from \"@bentley/imodeljs-common\";\r\nimport { assert } from \"@bentley/bentleyjs-core\";\r\nimport { TextureUnit } from \"../RenderFlags\";\r\n\r\nconst initialize = `\r\n  g_anim_step = vec2(1.0) / u_animLUTParams.xy;\r\n  g_anim_center = g_anim_step * 0.5;\r\n`;\r\n\r\n// The vertex index is an integer in [0..numVertices].\r\n// The frame index is an integer in [0..numBytesPerVertex/2].\r\n// Therefore each frame index points at 2 bytes within the texture.\r\n// The third component of the return value is 0.0 if the input index points to the first 2 bytes of the texel, or 1.0 if pointing to the second 2 bytes\r\nconst computeAnimLUTCoords = `\r\nvec3 computeAnimLUTCoords(float vertIndex, float frameIndex) {\r\n  // float baseIndex = (vertIndex * 2.0) + frameIndex;\r\n  float baseIndex = (vertIndex * u_animLUTParams.z) + frameIndex;\r\n  float halfIndex = baseIndex * 0.5;\r\n  float index = floor(halfIndex);\r\n\r\n  float epsilon = 0.5 / u_animLUTParams.x;\r\n  float yId = floor(index / u_animLUTParams.x + epsilon);\r\n  float xId = index - u_animLUTParams.x * yId;\r\n\r\n  vec2 texCoord = g_anim_center + vec2(xId / u_animLUTParams.x, yId / u_animLUTParams.y);\r\n  return vec3(texCoord, 2.0 * (halfIndex - index));\r\n}`;\r\n\r\n// Sample 2 bytes at the specified index.\r\nconst sampleAnimVec2 = `\r\nvec2 sampleAnimVec2(float vertIndex, float frameIndex) {\r\n  vec3 tc = computeAnimLUTCoords(vertIndex, frameIndex);\r\n  vec4 texel = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);\r\n  return texel.xy * (1.0 - tc.z) + texel.zw * tc.z;\r\n}`;\r\n\r\n// Position is quantized to 6 bytes (2 bytes per component). So we always must sample two adjacent texels. We discard two bytes based on whether the index is even or odd.\r\nconst computeAnimationFrameDisplacement = `\r\nvec3 computeAnimationFrameDisplacement(float vertIndex, float frameIndex, vec3 origin, vec3 scale) {\r\n  vec3 tc = computeAnimLUTCoords(vertIndex, frameIndex);\r\n  vec4 enc1 = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);\r\n  tc.x += g_anim_step.x;\r\n  vec4 enc2 = floor(TEXTURE(u_animLUT, tc.xy) * 255.0 + 0.5);\r\n\r\n  vec2 ex = enc1.xy * (1.0 - tc.z) + enc1.zw * tc.z;\r\n  vec2 ey = enc1.zw * (1.0 - tc.z) + enc2.xy * tc.z;\r\n  vec2 ez = enc2.xy * (1.0 - tc.z) + enc2.zw * tc.z;\r\n\r\n  vec3 qpos = vec3(decodeUInt16(ex), decodeUInt16(ey), decodeUInt16(ez));\r\n  return unquantizePosition(qpos, origin, scale).xyz;\r\n}`;\r\n\r\nconst computeAnimationDisplacement = `\r\nvec3 computeAnimationDisplacement(float vertIndex, float frameIndex0, float frameIndex1, float fraction, vec3 origin, vec3 scale) {\r\n  if (frameIndex0 < 0.0)\r\n    return vec3(0.0, 0.0, 0.0);\r\n\r\n  vec3 displacement = computeAnimationFrameDisplacement(vertIndex, frameIndex0, origin, scale);\r\n  if (fraction > 0.0) {\r\n    vec3 displacement1 = computeAnimationFrameDisplacement(vertIndex, frameIndex1, origin, scale);\r\n    displacement += fraction * (displacement1 - displacement);\r\n    }\r\n\r\n  return displacement;\r\n}`;\r\n\r\nconst adjustRawPosition = `\r\n  rawPos.xyz += computeAnimationDisplacement(g_vertexLUTIndex, u_animDispParams.x, u_animDispParams.y, u_animDispParams.z, u_qAnimDispOrigin, u_qAnimDispScale);\r\n  return rawPos;\r\n`;\r\n\r\nconst computeAnimationFrameNormal = `\r\nvec3 computeAnimationFrameNormal(float frameIndex) {\r\n  vec2 enc = sampleAnimVec2(g_vertexLUTIndex, frameIndex);\r\n  return octDecodeNormal(enc);\r\n}`;\r\n\r\nconst computeAnimationNormal = `\r\nvec3 computeAnimationNormal(float frameIndex0, float frameIndex1, float fraction) {\r\nvec3 normal = computeAnimationFrameNormal(frameIndex0);\r\nif (fraction > 0.0) {\r\n  vec3 normal1 = computeAnimationFrameNormal(frameIndex1);\r\n  normal += fraction * (normal1 - normal);\r\n  }\r\n\r\nreturn normal;\r\n}`;\r\n\r\nconst computeAnimationFrameParam = `\r\nfloat computeAnimationFrameParam(float frameIndex, float origin, float scale) {\r\n  vec2 enc = sampleAnimVec2(g_vertexLUTIndex, frameIndex);\r\n  return clamp((origin + scale * decodeUInt16(enc)), 0.0, 1.0);\r\n}`;\r\n\r\nconst computeAnimationParam = `\r\nvec2 computeAnimationParam(float frameIndex0, float frameIndex1, float fraction, float origin, float scale) {\r\nfloat param = computeAnimationFrameParam(frameIndex0, origin, scale);\r\nif (fraction > 0.0) {\r\n  float param1 = computeAnimationFrameParam(frameIndex1, origin, scale);\r\n  param += fraction * (param1 - param);\r\n  }\r\n\r\n  return vec2(.5, param);\r\n}`;\r\n\r\nconst scratchAnimParams = [\r\n  undefined,\r\n  undefined,\r\n  new Float32Array(2), // origin, scale\r\n  new Float32Array(3), // index0, index1, fraction\r\n];\r\n\r\nfunction getAnimParams(size: 2 | 3, initialValue?: number): Float32Array {\r\n  const array = scratchAnimParams[size]!;\r\n  if (undefined !== initialValue)\r\n    for (let i = 0; i < array.length; i++)\r\n      array[i] = initialValue;\r\n\r\n  return array;\r\n}\r\n\r\nfunction getDisplacementChannel(params: DrawParams): { channel: AuxDisplacementChannel, style: AnalysisStyle } | undefined {\r\n  const style = params.target.analysisStyle;\r\n  if (undefined === style || undefined === style.displacementChannelName)\r\n    return undefined;\r\n\r\n  const lutGeom = params.geometry.asLUT!;\r\n  const displacements = undefined !== lutGeom.lut.auxChannels ? lutGeom.lut.auxChannels.displacements : undefined;\r\n  const channel = undefined !== displacements ? displacements.get(style.displacementChannelName) : undefined;\r\n  return undefined !== channel ? { channel, style } : undefined;\r\n}\r\n\r\nfunction getNormalChannel(params: DrawParams): AuxChannel | undefined {\r\n  const style = params.target.analysisStyle;\r\n  if (undefined === style || undefined === style.normalChannelName)\r\n    return undefined;\r\n\r\n  const lutGeom = params.geometry.asLUT!;\r\n  const normals = undefined !== lutGeom.lut.auxChannels ? lutGeom.lut.auxChannels.normals : undefined;\r\n  return undefined !== normals ? normals.get(style.normalChannelName) : undefined;\r\n}\r\n\r\nfunction getScalarChannel(params: DrawParams): { channel: AuxParamChannel, style: AnalysisStyle } | undefined {\r\n  const style = params.target.analysisStyle;\r\n  if (undefined === style || undefined === style.scalarChannelName)\r\n    return undefined;\r\n\r\n  const geom = params.geometry.asMesh!;\r\n  const scalars = undefined !== geom.lut.auxChannels ? geom.lut.auxChannels.params : undefined;\r\n  const channel = undefined !== scalars ? scalars.get(style.scalarChannelName) : undefined;\r\n  return undefined !== channel ? { channel, style } : undefined;\r\n}\r\n\r\nfunction computeAnimParams(params: Float32Array, channel: AuxChannel, fraction: number): void {\r\n  const { inputs, indices } = channel;\r\n  const inputValue = fraction * inputs[inputs.length - 1];\r\n  for (let i = 0; i < inputs.length - 1; i++) {\r\n    if (inputValue >= inputs[i] && inputValue < inputs[i + 1]) {\r\n      params[0] = indices[i];\r\n      params[1] = indices[i + 1];\r\n      params[2] = inputValue - inputs[i] / (inputs[i + 1] - inputs[i]);\r\n      return;\r\n    }\r\n  }\r\n  params[0] = params[1] = indices[inputs.length - 1];\r\n  params[2] = 0.0;\r\n}\r\n\r\n/** @internal */\r\nexport function addAnimation(vert: VertexShaderBuilder, isSurface: boolean): void {\r\n  // Lookup table\r\n  vert.addGlobal(\"g_anim_step\", VariableType.Vec2);\r\n  vert.addGlobal(\"g_anim_center\", VariableType.Vec2);\r\n  vert.addInitializer(initialize);\r\n\r\n  vert.addUniform(\"u_animLUT\", VariableType.Sampler2D, (prog) => {\r\n    prog.addGraphicUniform(\"u_animLUT\", (uniform, params) => {\r\n      const channels = (params.geometry.asLUT!).lut.auxChannels!;\r\n      assert(undefined !== channels);\r\n      channels.texture.bindSampler(uniform, TextureUnit.AuxChannelLUT);\r\n    });\r\n  });\r\n\r\n  vert.addUniform(\"u_animLUTParams\", VariableType.Vec3, (prog) => {\r\n    prog.addGraphicUniform(\"u_animLUTParams\", (uniform, params) => {\r\n      const geom = params.geometry.asLUT!;\r\n      assert(undefined !== geom && undefined !== geom.lut.auxChannels);\r\n      const tex = geom.lut.auxChannels!.texture;\r\n      const array = getAnimParams(3);\r\n      array[0] = tex.width;\r\n      array[1] = tex.height;\r\n      array[2] = geom.lut.auxChannels!.numBytesPerVertex / 2;\r\n      uniform.setUniform3fv(array);\r\n    });\r\n  });\r\n\r\n  vert.addFunction(computeAnimLUTCoords);\r\n  vert.addFunction(sampleAnimVec2);\r\n\r\n  // Displacement\r\n  vert.addFunction(computeAnimationFrameDisplacement);\r\n  vert.addFunction(computeAnimationDisplacement);\r\n  vert.set(VertexShaderComponent.AdjustRawPosition, adjustRawPosition);\r\n\r\n  vert.addUniform(\"u_animDispParams\", VariableType.Vec3, (prog) => {\r\n    prog.addGraphicUniform(\"u_animDispParams\", (uniform, params) => {\r\n      const animParams = getAnimParams(3, 0.0);\r\n      const disp = getDisplacementChannel(params);\r\n      if (undefined !== disp)\r\n        computeAnimParams(animParams, disp.channel, params.target.animationFraction);\r\n\r\n      uniform.setUniform3fv(animParams);\r\n    });\r\n  });\r\n  vert.addUniform(\"u_qAnimDispScale\", VariableType.Vec3, (prog) => {\r\n    prog.addGraphicUniform(\"u_qAnimDispScale\", (uniform, params) => {\r\n      const animParams = getAnimParams(3, 0.0);\r\n      const disp = getDisplacementChannel(params);\r\n      if (undefined !== disp) {\r\n        const displacementScale = disp.style.displacementScale ? disp.style.displacementScale : 1.0;\r\n        for (let i = 0; i < 3; i++)\r\n          animParams[i] = disp.channel.qScale[i] * displacementScale; // Apply displacement scale.\r\n      }\r\n\r\n      uniform.setUniform3fv(animParams);\r\n    });\r\n  });\r\n  vert.addUniform(\"u_qAnimDispOrigin\", VariableType.Vec3, (prog) => {\r\n    prog.addGraphicUniform(\"u_qAnimDispOrigin\", (uniform, params) => {\r\n      const animParams = getAnimParams(3, 0.0);\r\n      const disp = getDisplacementChannel(params);\r\n      if (undefined !== disp) {\r\n        const displacementScale = disp.style.displacementScale ? disp.style.displacementScale : 1.0;\r\n        for (let i = 0; i < 3; i++)\r\n          animParams[i] = disp.channel.qOrigin[i] * displacementScale;   // Apply displacement scale\r\n      }\r\n\r\n      uniform.setUniform3fv(animParams);\r\n    });\r\n  });\r\n\r\n  // Normal and param\r\n  if (isSurface) {\r\n    vert.addFunction(octDecodeNormal);\r\n    vert.addFunction(computeAnimationFrameNormal);\r\n    vert.addFunction(computeAnimationNormal);\r\n\r\n    vert.addFunction(computeAnimationFrameParam);\r\n    vert.addFunction(computeAnimationParam);\r\n\r\n    vert.addUniform(\"u_animNormalParams\", VariableType.Vec3, (prog) => {\r\n      prog.addGraphicUniform(\"u_animNormalParams\", (uniform, params) => {\r\n        const animParams = getAnimParams(3, -1.0);\r\n        const channel = getNormalChannel(params);\r\n        if (undefined !== channel)\r\n          computeAnimParams(animParams, channel, params.target.animationFraction);\r\n\r\n        uniform.setUniform3fv(animParams);\r\n      });\r\n    });\r\n\r\n    vert.addUniform(\"u_animScalarParams\", VariableType.Vec3, (prog) => {\r\n      prog.addGraphicUniform(\"u_animScalarParams\", (uniform, params) => {\r\n        const scalars = getScalarChannel(params);\r\n        const animParams = getAnimParams(3, -1.0);\r\n        if (undefined !== scalars)\r\n          computeAnimParams(animParams, scalars.channel, params.target.animationFraction);\r\n\r\n        uniform.setUniform3fv(animParams);\r\n      });\r\n    });\r\n\r\n    vert.addUniform(\"u_animScalarQParams\", VariableType.Vec2, (prog) => {\r\n      prog.addGraphicUniform(\"u_animScalarQParams\", (uniform, params) => {\r\n        const scalars = getScalarChannel(params);\r\n        const animParams = getAnimParams(2, 1.0);\r\n        if (undefined !== scalars) {\r\n          const rangeScale = scalars.style.scalarRange!.high - scalars.style.scalarRange!.low;\r\n          animParams[0] = Gradient.ThematicSettings.margin + (scalars.channel.qOrigin - scalars.style.scalarRange!.low) / rangeScale;\r\n          animParams[1] = Gradient.ThematicSettings.contentRange * scalars.channel.qScale / rangeScale;\r\n        }\r\n\r\n        uniform.setUniform2fv(animParams);\r\n      });\r\n    });\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { VariableType, FragmentShaderComponent, VariablePrecision } from \"../ShaderBuilder\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { GLSLFragment, addWindowToTexCoords } from \"./Fragment\";\nimport { BlurGeometry } from \"../CachedGeometry\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { addViewport } from \"./Viewport\";\nimport { GLSLDecode } from \"./Decode\";\n\n// This shader applies a Gaussian blur in one dimension.\nconst computeBlur = `\n  float delta = u_blurSettings.x;\n  float sigma = u_blurSettings.y;\n  float texelStepSize = u_blurSettings.z;\n\n  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\n  vec2 step = texelStepSize / u_viewport.zw;\n\n  vec3 gaussian;\n  const float twoPi = 6.283185307179586;\n  gaussian.x = 1.0 / (sqrt(twoPi) * sigma);\n  gaussian.y = exp((-0.5 * delta * delta) / (sigma * sigma));\n  gaussian.z = gaussian.y * gaussian.y;\n\n  vec4 origColor = TEXTURE(u_textureToBlur, tc);\n  vec4 result = origColor * gaussian.x;\n  for (int i = 1; i < 8; i++) {\n    gaussian.xy *= gaussian.yz;\n\n    vec2 offset = float(i) * u_blurDir * step;\n    vec2 tcMinusOffset = tc - offset;\n    vec2 tcPlusOffset = tc + offset;\n\n    result += TEXTURE(u_textureToBlur, tcMinusOffset) * gaussian.x;\n    result += TEXTURE(u_textureToBlur, tcPlusOffset) * gaussian.x;\n  }\n\n  return result;\n`;\n\n/** @internal */\nexport function createBlurProgram(context: WebGLRenderingContext): ShaderProgram {\n  const builder = createViewportQuadBuilder(true);\n  const frag = builder.frag;\n\n  addWindowToTexCoords(frag);\n\n  frag.addFunction(GLSLDecode.depthRgb);\n\n  frag.set(FragmentShaderComponent.ComputeBaseColor, computeBlur);\n  frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n\n  addViewport(frag);\n\n  frag.addUniform(\"u_textureToBlur\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_textureToBlur\", (uniform, params) => {\n      const geom = params.geometry as BlurGeometry;\n      Texture2DHandle.bindSampler(uniform, geom.textureToBlur, TextureUnit.Zero);\n    });\n  });\n\n  frag.addUniform(\"u_blurDir\", VariableType.Vec2, (prog) => {\n    prog.addGraphicUniform(\"u_blurDir\", (uniform, params) => {\n      const geom = params.geometry as BlurGeometry;\n      uniform.setUniform2fv(new Float32Array([geom.blurDir.x, geom.blurDir.y]));\n    });\n  });\n\n  frag.addUniform(\"u_blurSettings\", VariableType.Vec3, (prog) => {\n    prog.addProgramUniform(\"u_blurSettings\", (uniform, params) => {\n      const hbaoSettings = new Float32Array([\n        // ###TODO: If we want to apply this blur shader to situations other than AO, we should move these settings away from the ambient occlusion params.\n        params.target.ambientOcclusionSettings.blurDelta!,\n        params.target.ambientOcclusionSettings.blurSigma!,\n        params.target.ambientOcclusionSettings.blurTexelStepSize!]);\n      uniform.setUniform3fv(hbaoSettings);\n    });\n  }, VariablePrecision.High);\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { VariableType, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { System } from \"../System\";\n\nconst computeBaseColor = \"return u_bgColor;\";\n\nconst assignFragData = `\n  FragColor0 = baseColor;\n  FragColor1 = vec4(0.0);\n  FragColor2 = vec4(0.0);\n`;\n\n/** @internal */\nexport function createClearPickAndColorProgram(context: WebGLRenderingContext): ShaderProgram {\n  const builder = createViewportQuadBuilder(false);\n  const frag = builder.frag;\n  frag.addUniform(\"u_bgColor\", VariableType.Vec4, (prog) => {\n    prog.addProgramUniform(\"u_bgColor\", (uniform, params) => {\n      params.target.bgColor.bind(uniform);\n    });\n  });\n\n  frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\n\n  if (!System.instance.capabilities.supportsMRTPickShaders) {\n    // NB: This shader is never used - we gl.clear() directly\n    frag.set(FragmentShaderComponent.AssignFragData, \"FragColor = baseColor;\");\n  } else {\n    frag.addDrawBuffersExtension();\n    frag.set(FragmentShaderComponent.AssignFragData, assignFragData);\n  }\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { System } from \"../System\";\n\nconst computeBaseColor = \"return vec4(0.0);\";\nconst assignFragData = `\n  FragColor0 = vec4(0.0, 0.0, 0.0, 1.0);\n  FragColor1 = vec4(1.0, 0.0, 0.0, 1.0);\n`;\n\nconst assignFragColor = `FragColor = vec4(0.0, 0.0, 0.0, 1.0);`;\n\n/** @internal */\nexport function createClearTranslucentProgram(context: WebGLRenderingContext): ShaderProgram {\n  const builder = createViewportQuadBuilder(false);\n  const frag = builder.frag;\n  frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\n  if (System.instance.capabilities.supportsMRTTransparency) {\n    frag.addDrawBuffersExtension();\n    frag.set(FragmentShaderComponent.AssignFragData, assignFragData);\n  } else {\n    // NB: This shader is never used - we just gl.clear() directly\n    frag.set(FragmentShaderComponent.AssignFragData, assignFragColor);\n  }\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ProgramBuilder, FragmentShaderComponent, VertexShaderComponent } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { GLSLFragment } from \"./Fragment\";\nimport { addModelViewProjectionMatrix } from \"./Vertex\";\n\nconst computePosition = \"return MAT_MVP * rawPos;\";\n\nconst computeBaseColor = \"return vec4(1.0);\";\n\n/** @internal */\nexport function createClipMaskProgram(context: WebGLRenderingContext): ShaderProgram {\n  const builder = new ProgramBuilder();\n\n  addModelViewProjectionMatrix(builder.vert);\n  builder.vert.set(VertexShaderComponent.ComputePosition, computePosition);\n\n  builder.frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\n  builder.frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { ProgramBuilder, VariableType, VariablePrecision, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { addModelViewMatrix } from \"./Vertex\";\nimport { addWindowToTexCoords } from \"./Fragment\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { System } from \"../System\";\nimport { ClipDef } from \"../TechniqueFlags\";\nimport { addEyeSpace } from \"./Common\";\nimport { ClippingType } from \"../../System\";\n\nconst getClipPlaneFloat = `\n  vec4 getClipPlane(int index) {\n    float x = 0.5;\n    float y = (float(index) + 0.5) / float(u_numClips);\n    return TEXTURE(s_clipSampler, vec2(x, y));\n  }\n`;\n\nconst unpackFloat = `\n  float unpackFloat(vec4 v) {\n    const float bias = 38.0;\n    v *= 255.0;\n    float temp = v.w / 2.0;\n    float exponent = floor(temp);\n    float sign = (temp - exponent) * 2.0;\n    exponent = exponent - bias;\n    sign = -(sign * 2.0 - 1.0);\n    float unpacked = sign * v.x * (1.0 / 256.0); // shift right 8\n    unpacked += sign * v.y * (1.0 / 65536.0); // shift right 16\n    unpacked += sign * v.z * (1.0 / 16777216.0); // shift right 24\n    return unpacked * pow(10.0, exponent);\n  }\n`;\n\n// ###TODO: oct-encode the normal to reduce # of samples from 4 to 2\nconst unpackClipPlane = `\n  vec4 getClipPlane(int index) {\n    float y = (float(index) + 0.5) / float(u_numClips);\n    float sx = 0.25;\n    vec2 tc = vec2(0.125, y);\n    float nx = unpackFloat(TEXTURE(s_clipSampler, tc));\n    tc.x += sx;\n    float ny = unpackFloat(TEXTURE(s_clipSampler, tc));\n    tc.x += sx;\n    float nz = unpackFloat(TEXTURE(s_clipSampler, tc));\n    tc.x += sx;\n    float dist = unpackFloat(TEXTURE(s_clipSampler, tc));\n    return vec4(nx, ny, nz, dist);\n  }\n`;\n\nconst calcClipPlaneDist = `\n  float calcClipPlaneDist(vec4 camPos, vec4 plane) {\n    return dot(camPos, plane);\n  }\n`;\n\nconst applyClipPlanes = `\n  int numPlaneSets = 1;\n  int numSetsClippedBy = 0;\n  bool clippedByCurrentPlaneSet = false;\n  for (int i = 0; i < MAX_CLIPPING_PLANES; i++)\n      {\n      if (i >= u_numClips)\n          break;\n\n      vec4 plane = getClipPlane(i);\n      if (plane.xyz == vec3(0.0)) // indicates start of new clip plane set\n          {\n          numPlaneSets = numPlaneSets + 1;\n          numSetsClippedBy += int(clippedByCurrentPlaneSet);\n          clippedByCurrentPlaneSet = false;\n          }\n      else if (!clippedByCurrentPlaneSet && calcClipPlaneDist(v_eyeSpace, plane) < 0.0)\n          clippedByCurrentPlaneSet = true;\n      }\n\n  numSetsClippedBy += int(clippedByCurrentPlaneSet);\n  if (numSetsClippedBy == numPlaneSets)\n      discard;\n`;\n\nconst applyClipMask = `\n  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\n  vec4 texel = TEXTURE(s_clipSampler, tc);\n  if (texel.r < 0.5)\n    discard;\n`;\n\n/** @internal */\nexport function addClipping(prog: ProgramBuilder, clipDef: ClipDef) {\n  if (clipDef.type === ClippingType.Mask)\n    addClippingMask(prog);\n  else if (clipDef.type === ClippingType.Planes)\n    addClippingPlanes(prog, clipDef.numberOfPlanes);\n}\n\nfunction addClippingPlanes(prog: ProgramBuilder, maxClipPlanes: number) {\n  assert(maxClipPlanes > 0);\n  const frag = prog.frag;\n  const vert = prog.vert;\n\n  addEyeSpace(prog);\n  prog.addUniform(\"u_numClips\", VariableType.Int, (program) => {\n    program.addGraphicUniform(\"u_numClips\", (uniform, params) => {\n      const doClipping = true; // set to false to visualize pre-shader culling of geometry...\n      const numClips = (doClipping && params.target.hasClipVolume) ? params.target.clips.count : 0;\n      assert(numClips > 0 || !doClipping);\n      uniform.setUniform1i(numClips);\n    });\n  });\n\n  addModelViewMatrix(vert);\n\n  if (System.instance.capabilities.supportsTextureFloat) {\n    frag.addFunction(getClipPlaneFloat);\n  } else {\n    frag.addFunction(unpackFloat);\n    frag.addFunction(unpackClipPlane);\n  }\n\n  frag.addFunction(calcClipPlaneDist);\n  frag.maxClippingPlanes = maxClipPlanes;\n  frag.addUniform(\"s_clipSampler\", VariableType.Sampler2D, (program) => {\n    program.addGraphicUniform(\"s_clipSampler\", (uniform, params) => {\n      const texture = params.target.clips.texture;\n      assert(texture !== undefined);\n      if (texture !== undefined)\n        texture.bindSampler(uniform, TextureUnit.ClipVolume);\n    });\n  }, VariablePrecision.High);\n  frag.set(FragmentShaderComponent.ApplyClipping, applyClipPlanes);\n}\n\nfunction addClippingMask(prog: ProgramBuilder) {\n  prog.frag.addUniform(\"s_clipSampler\", VariableType.Sampler2D, (program) => {\n    program.addGraphicUniform(\"s_clipSampler\", (uniform, params) => {\n      const texture = params.target.clipMask;\n      assert(texture !== undefined);\n      if (texture !== undefined)\n        texture.bindSampler(uniform, TextureUnit.ClipVolume);\n    });\n  }, VariablePrecision.High);\n\n  addWindowToTexCoords(prog.frag);\n  prog.frag.set(FragmentShaderComponent.ApplyClipping, applyClipMask);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Rendering */\n\nimport {\n  FragmentShaderComponent,\n  ProgramBuilder,\n  VariableType,\n  VertexShaderBuilder,\n} from \"../ShaderBuilder\";\nimport { GLSLFragment } from \"./Fragment\";\nimport { addRenderPass } from \"./RenderPass\";\nimport { addInstanceColor } from \"./Instancing\";\n\n// Vertex\n// Color table is appended to vertex data. Compute the index of the vertex one-past-the-end of the vertex data\nconst computeElementColor = `\n  float colorTableStart = u_vertParams.z * u_vertParams.w; // num rgba per-vertex times num vertices\n  float colorIndex = decodeUInt16(g_vertexData2);\n  vec2 tc = computeLUTCoords(colorTableStart+colorIndex, u_vertParams.xy, g_vert_center, 1.0);\n  vec4 color = mix(u_color, TEXTURE(u_vertLUT, tc), extractShaderBit(kShaderBit_NonUniformColor));\n`;\nconst computeBaseAlpha = `\n  g_baseAlpha = color.a;\n`;\n// If in opaque pass, un-premultiply any alpha\nconst adjustAndReturnColor = `\n  float inOpaquePass = float(kRenderPass_OpaqueLinear <= u_renderPass && kRenderPass_OpaqueGeneral >= u_renderPass);\n  color = mix(color, adjustPreMultipliedAlpha(color, 1.0), inOpaquePass);\n  return color;\n`;\nconst applyInstanceColor = `\n  color.rgb /= max(0.0001, color.a); // revert pre-multiplied alpha\n  color.rgb = mix(color.rgb, a_instanceRgba.rgb / 255.0, extractInstanceBit(kOvrBit_Rgb));\n  color.a = mix(color.a, a_instanceRgba.a / 255.0, extractInstanceBit(kOvrBit_Alpha));\n  color.rgb *= color.a; // pre-multiply alpha\n`;\n\nconst computeInstancedElementColor = computeElementColor + applyInstanceColor;\nconst computeColor = computeElementColor + adjustAndReturnColor;\nconst computeInstancedColor = computeInstancedElementColor + adjustAndReturnColor;\nconst computeSurfaceColor = computeElementColor + computeBaseAlpha + adjustAndReturnColor;\nconst computeInstancedSurfaceColor = computeInstancedElementColor + computeBaseAlpha + adjustAndReturnColor;\n\nfunction getComputeColor(vert: VertexShaderBuilder, forwardBaseAlpha: boolean): string {\n  if (vert.usesInstancedGeometry) {\n    addInstanceColor(vert);\n    return forwardBaseAlpha ? computeInstancedSurfaceColor : computeInstancedColor;\n  } else {\n    return forwardBaseAlpha ? computeSurfaceColor : computeColor;\n  }\n}\n\n// Fragment\nconst computeBaseColor = \"return v_color;\";\n\n/** @internal */\nexport function addColor(builder: ProgramBuilder, forwardBaseAlpha: boolean = false) {\n  // ShaderSource::AddRenderPass\n  builder.vert.addUniform(\"u_color\", VariableType.Vec4, (prog) => {\n    prog.addGraphicUniform(\"u_color\", (uniform, params) => {\n      const lutGeom = params.geometry.asLUT!;\n      const color = lutGeom.getColor(params.target);\n      if (color.isUniform) {\n        color.uniform.bind(uniform);\n      }\n    });\n  });\n  builder.vert.addFunction(GLSLFragment.adjustPreMultipliedAlpha);\n\n  if (forwardBaseAlpha)\n    builder.addGlobal(\"g_baseAlpha\", VariableType.Float);\n\n  addRenderPass(builder.vert);\n  builder.addFunctionComputedVarying(\"v_color\", VariableType.Vec4, \"computeColor\", getComputeColor(builder.vert, forwardBaseAlpha));\n\n  builder.frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { TextureUnit } from \"../RenderFlags\";\nimport { VariableType, VariablePrecision, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { CombineTexturesGeometry } from \"../CachedGeometry\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\n\nconst computeBaseColor = \"return vec4(1.0);\";\n\nconst assignFragData = `\n  if (v_texCoord.y < .5)\n   FragColor0 = TEXTURE(u_texture0, vec2(v_texCoord.x, v_texCoord.y * 2.0));\n  else\n   FragColor0 = TEXTURE(u_texture1, vec2(v_texCoord.x, v_texCoord.y * 2.0 - 1.0));\n`;\n\n/** @internal */\nexport function createCombineTexturesProgram(context: WebGLRenderingContext): ShaderProgram {\n  const builder = createViewportQuadBuilder(true);\n  const frag = builder.frag;\n\n  frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\n\n  frag.addUniform(\"u_texture0\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_texture0\", (uniform, params) => {\n      Texture2DHandle.bindSampler(uniform, (params.geometry as CombineTexturesGeometry).texture0, TextureUnit.Zero);\n    });\n  }, VariablePrecision.High);\n\n  frag.addUniform(\"u_texture1\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_texture1\", (uniform, params) => {\n      Texture2DHandle.bindSampler(uniform, (params.geometry as CombineTexturesGeometry).texture1, TextureUnit.One);\n    });\n  }, VariablePrecision.High);\n\n  frag.addDrawBuffersExtension();\n  frag.set(FragmentShaderComponent.AssignFragData, assignFragData);\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ShaderBuilder, ProgramBuilder, VariableType, ShaderType } from \"../ShaderBuilder\";\nimport { UniformHandle } from \"../Handle\";\nimport { DrawParams } from \"../DrawCommand\";\nimport { ShaderFlags } from \"../ShaderProgram\";\nimport { System, RenderType } from \"../System\";\nimport { assert } from \"@bentley/bentleyjs-core\";\n\nconst extractShaderBit = `\n  float extractShaderBit(float flag) { return extractNthBit(floor(u_shaderFlags + 0.5), flag); }\n`;\nconst isShaderBitSet = `\nbool isShaderBitSet(float flag) { return 0.0 != extractShaderBit(flag); }\n`;\n\nfunction addShaderFlagsLookup(shader: ShaderBuilder) {\n  shader.addConstant(\"kShaderBit_Monochrome\", VariableType.Float, \"0.0\");\n  shader.addConstant(\"kShaderBit_NonUniformColor\", VariableType.Float, \"1.0\");\n  shader.addConstant(\"kShaderBit_OITFlatAlphaWeight\", VariableType.Float, \"2.0\");\n  shader.addConstant(\"kShaderBit_OITScaleOutput\", VariableType.Float, \"3.0\");\n  shader.addConstant(\"kShaderBit_IgnoreNonLocatable\", VariableType.Float, \"4.0\");\n\n  shader.addFunction(GLSLCommon.extractNthBit);\n  shader.addFunction(extractShaderBit);\n  shader.addFunction(isShaderBitSet);\n}\n\n/** @internal */\nexport function addViewMatrix(vert: ShaderBuilder): void {\n  vert.addUniform(\"u_viewMatrix\", VariableType.Mat4, (prog) => {\n    prog.addGraphicUniform(\"u_viewMatrix\", (uniform, params) => {\n      uniform.setMatrix4(params.viewMatrix);\n    });\n  });\n}\n\nfunction setShaderFlags(uniform: UniformHandle, params: DrawParams) {\n  assert(params.geometry.asLUT !== undefined);\n  const geom = params.geometry.asLUT!;\n  let flags = params.target.currentShaderFlags;\n\n  const color = geom.getColor(params.target);\n  if (color.isNonUniform)\n    flags |= ShaderFlags.NonUniformColor;\n\n  // Certain textures render in the translucent pass but we actually want to maintain true opacity for opaque pixels.\n  // For these, use a constant Z to calculate alpha weight.  Otherwise, the opaque things in the texture are weighted by their Z due\n  // to the nature of the OIT algorithm.  In this case, we set OITFlatAlphaWeight.\n\n  // Since RGBA8 rendering is very low precision, if we are using that kind of output, we also want to flatten alpha weight.\n  // Otherwise, the very tiny Z range makes things fade to black as the precision limit is encountered.  This workaround disregards Z\n  // in calculating the color, so it means that transparency is less accurate based on Z-ordering, but it is the best we can do with\n  // this algorithm on low-end hardware.\n\n  // Finally, the application can put the viewport into \"fadeout mode\", which explicitly enables flat alpha weight in order to de-emphasize transparent geometry.\n  const maxRenderType = System.instance.capabilities.maxRenderType;\n  let flatAlphaWeight = RenderType.TextureUnsignedByte === maxRenderType || params.target.isFadeOutActive;\n  if (!flatAlphaWeight) {\n    const surface = params.geometry.asSurface;\n    flatAlphaWeight = undefined !== surface && (surface.isGlyph || surface.isTileSection);\n  }\n\n  if (flatAlphaWeight)\n    flags |= ShaderFlags.OITFlatAlphaWeight;\n\n  // If Cesium-style transparency is being used with non-float texture targets, we must scale the output in the shaders to 0-1 range.\n  // Otherwise, it will get implicitly clamped to that range and we'll lose any semblance our desired precision (even though it is low).\n  if (maxRenderType < RenderType.TextureHalfFloat)\n    flags |= ShaderFlags.OITScaleOutput;\n\n  if (!params.target.drawNonLocatable)\n    flags |= ShaderFlags.IgnoreNonLocatable;\n\n  uniform.setUniform1f(flags);\n}\n\n/** @internal */\nexport function addShaderFlags(builder: ProgramBuilder) {\n  addShaderFlagsLookup(builder.vert);\n  addShaderFlagsLookup(builder.frag);\n\n  builder.addUniform(\"u_shaderFlags\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_shaderFlags\", (uniform, params) => { setShaderFlags(uniform, params); });\n  });\n}\n\n/** @internal */\nexport function addFrustum(builder: ProgramBuilder) {\n  builder.addUniform(\"u_frustum\", VariableType.Vec3, (prog) => {\n    prog.addProgramUniform(\"u_frustum\", (uniform, params) => {\n      uniform.setUniform3fv(params.target.frustumUniforms.frustum);\n    });\n  });\n\n  builder.addGlobal(\"kFrustumType_Ortho2d\", VariableType.Float, ShaderType.Both, \"0.0\", true);\n  builder.addGlobal(\"kFrustumType_Ortho3d\", VariableType.Float, ShaderType.Both, \"1.0\", true);\n  builder.addGlobal(\"kFrustumType_Perspective\", VariableType.Float, ShaderType.Both, \"2.0\", true);\n}\n\nconst computeEyeSpace = \"v_eyeSpace = (MAT_MV * rawPosition);\";\n\n/** @internal */\nexport function addEyeSpace(builder: ProgramBuilder) {\n  builder.addInlineComputedVarying(\"v_eyeSpace\", VariableType.Vec4, computeEyeSpace);\n}\n\n/** @internal */\nexport const addUInt32s = `\n  vec4 addUInt32s(vec4 a, vec4 b)\n      {\n      vec4 c = a + b;\n      if (c.x > 255.0) { c.x -= 256.0; c.y += 1.0; }\n      if (c.y > 255.0) { c.y -= 256.0; c.z += 1.0; }\n      if (c.z > 255.0) { c.z -= 256.0; c.w += 1.0; }\n      return c;\n      }\n`;\n\n/** @internal */\nexport namespace GLSLCommon {\n  // Expects flags in range [0...256] with no fraction; and bit is [0..31] with no fraction.\n  // Returns 1.0 if the nth bit is set, 0.0 otherwise.\n  // dividing flags by 2^(n+1) yields #.5##... if the nth bit is set, #.0##... otherwise\n  // Taking the fractional part yields 0.5##...\n  // Multiplying by 2.0 and taking the floor yields 1.0 or 0.0\n  export const extractNthBit = `\nfloat extractNthBit(float flags, float n) {\n  float denom = pow(2.0, n+1.0);\n  return floor(fract(flags/denom)*2.0);\n}\n`;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { TextureUnit, CompositeFlags } from \"../RenderFlags\";\nimport { VariableType, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { CompositeGeometry } from \"../CachedGeometry\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { GLSLFragment, addWindowToTexCoords } from \"./Fragment\";\nimport { addHiliteSettings } from \"./FeatureSymbology\";\nimport { assert } from \"@bentley/bentleyjs-core\";\n\nconst isEdgePixel = `\nbool isEdgePixel(float xOffset, float yOffset) {\n  vec2 t = windowCoordsToTexCoords(gl_FragCoord.xy + vec2(xOffset, yOffset));\n  vec4 texel = TEXTURE(u_hilite, t);\n  return 0.0 != texel.r;\n}\n`;\n\nconst isOutlined = `\nbool isOutlined() {\n  float width = u_hilite_settings.z;\n  if (0.0 == width)\n    return false;\n\n  // 1-pixel-wide outline requires max 9 samples. 2-pixel-wide requires max 25 samples.\n  if (isEdgePixel(0.0, 1.0) || isEdgePixel(1.0, 0.0) || isEdgePixel(1.0, 1.0)\n      || isEdgePixel(0.0, -1.0) || isEdgePixel(-1.0, 0.0) || isEdgePixel(-1.0, -1.0)\n      || isEdgePixel(1.0, -1.0) || isEdgePixel(-1.0, 1.0))\n    return true;\n\n  if (1.0 == width)\n    return false;\n\n  return isEdgePixel(-2.0, -2.0) || isEdgePixel(-1.0, -2.0) || isEdgePixel(0.0, -2.0) || isEdgePixel(1.0, -2.0) || isEdgePixel(2.0, -2.0)\n    || isEdgePixel(-2.0, -1.0) || isEdgePixel(2.0, -1.0)\n    || isEdgePixel(-2.0, 0.0) || isEdgePixel(2.0, 0.0)\n    || isEdgePixel(-2.0, 1.0) || isEdgePixel(2.0, 1.0)\n    || isEdgePixel(-2.0, 2.0) || isEdgePixel(-1.0, 2.0) || isEdgePixel(0.0, 2.0) || isEdgePixel(1.0, 2.0) || isEdgePixel(2.0, 2.0);\n}\n`;\n\nconst computeOpaqueColor = `\nvec4 computeOpaqueColor() {\n  vec4 opaque = TEXTURE(u_opaque, v_texCoord);\n  opaque.rgb *= computeAmbientOcclusion();\n  return opaque;\n}\n`;\n\nconst computeDefaultAmbientOcclusion = `\\nfloat computeAmbientOcclusion() { return 1.0; }\\n`;\nconst computeAmbientOcclusion = `\\nfloat computeAmbientOcclusion() { return TEXTURE(u_occlusion, v_texCoord).r; }\\n`;\n\nconst computeHiliteColor = \"\\nvec4 computeColor() { return computeOpaqueColor(); }\\n\";\n\nconst computeHiliteBaseColor = `\n  float isHilite = floor(TEXTURE(u_hilite, v_texCoord).r + 0.5);\n  float ratio = u_hilite_settings.y * isHilite;\n  vec4 baseColor = computeColor();\n  baseColor.rgb = mix(baseColor.rgb, u_hilite_color.rgb, ratio);\n  // If outlined, use hilite color for boundaries, else use base color, mixed with hilite color if inside hilite region.\n  return mix(vec4(u_hilite_color.rgb, 1.0), baseColor, max(isHilite, 1.0 - float(isOutlined())));\n`;\n\nconst computeTranslucentColor = `\nvec4 computeColor() {\n  vec4 opaque = computeOpaqueColor();\n  vec4 accum = TEXTURE(u_accumulation, v_texCoord);\n  float r = TEXTURE(u_revealage, v_texCoord).r;\n\n  vec4 transparent = vec4(accum.rgb / clamp(r, 1e-4, 5e4), accum.a);\n  vec4 col = (1.0 - transparent.a) * transparent + transparent.a * opaque;\n  return col;\n}\n`;\n\nconst computeTranslucentBaseColor = \"return computeColor();\";\nconst computeAmbientOcclusionBaseColor = `\\nreturn computeOpaqueColor();\\n`;\n\n/** @internal */\nexport function createCompositeProgram(flags: CompositeFlags, context: WebGLRenderingContext): ShaderProgram {\n  assert(CompositeFlags.None !== flags);\n\n  const wantHilite = CompositeFlags.None !== (flags & CompositeFlags.Hilite);\n  const wantTranslucent = CompositeFlags.None !== (flags & CompositeFlags.Translucent);\n  const wantOcclusion = CompositeFlags.None !== (flags & CompositeFlags.AmbientOcclusion);\n\n  const builder = createViewportQuadBuilder(true);\n  const frag = builder.frag;\n\n  frag.addFunction(wantOcclusion ? computeAmbientOcclusion : computeDefaultAmbientOcclusion);\n  frag.addFunction(computeOpaqueColor);\n\n  frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n  frag.addUniform(\"u_opaque\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_opaque\", (uniform, params) => {\n      Texture2DHandle.bindSampler(uniform, (params.geometry as CompositeGeometry).opaque, TextureUnit.Zero);\n    });\n  });\n\n  if (wantHilite) {\n    addHiliteSettings(frag);\n    addWindowToTexCoords(frag);\n    frag.addFunction(isEdgePixel);\n    frag.addFunction(isOutlined);\n\n    frag.addUniform(\"u_hilite\", VariableType.Sampler2D, (prog) => {\n      prog.addGraphicUniform(\"u_hilite\", (uniform, params) => {\n        Texture2DHandle.bindSampler(uniform, (params.geometry as CompositeGeometry).hilite, TextureUnit.Three);\n      });\n    });\n\n    frag.set(FragmentShaderComponent.ComputeBaseColor, computeHiliteBaseColor);\n    if (!wantTranslucent) {\n      frag.addFunction(computeHiliteColor);\n    }\n  }\n\n  if (wantTranslucent) {\n    frag.addUniform(\"u_accumulation\", VariableType.Sampler2D, (prog) => {\n      prog.addGraphicUniform(\"u_accumulation\", (uniform, params) => {\n        Texture2DHandle.bindSampler(uniform, (params.geometry as CompositeGeometry).accum, TextureUnit.One);\n      });\n    });\n\n    frag.addUniform(\"u_revealage\", VariableType.Sampler2D, (prog) => {\n      prog.addGraphicUniform(\"u_revealage\", (uniform, params) => {\n        Texture2DHandle.bindSampler(uniform, (params.geometry as CompositeGeometry).reveal, TextureUnit.Two);\n      });\n    });\n\n    frag.addFunction(computeTranslucentColor);\n    if (!wantHilite) {\n      frag.set(FragmentShaderComponent.ComputeBaseColor, computeTranslucentBaseColor);\n    }\n  }\n\n  if (wantOcclusion) {\n    frag.addUniform(\"u_occlusion\", VariableType.Sampler2D, (prog) => {\n      prog.addGraphicUniform(\"u_occlusion\", (uniform, params) => {\n        Texture2DHandle.bindSampler(uniform, (params.geometry as CompositeGeometry).occlusion!, TextureUnit.Four);\n      });\n    });\n\n    if (!wantHilite && !wantTranslucent)\n      frag.set(FragmentShaderComponent.ComputeBaseColor, computeAmbientOcclusionBaseColor);\n  }\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { TextureUnit } from \"../RenderFlags\";\nimport { VariableType, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { SingleTexturedViewportQuadGeometry } from \"../CachedGeometry\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { GLSLFragment } from \"./Fragment\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\n\nconst computeColor = \"return TEXTURE(u_color, v_texCoord);\";\n\nconst computeColorNoAlpha = \"return vec4(TEXTURE(u_color, v_texCoord).rgb, 1.0);\";\n\n/** @internal */\nexport function createCopyColorProgram(context: WebGLRenderingContext, copyAlpha: boolean = true): ShaderProgram {\n  const builder = createViewportQuadBuilder(true);\n  const frag = builder.frag;\n\n  frag.set(FragmentShaderComponent.ComputeBaseColor, copyAlpha ? computeColor : computeColorNoAlpha);\n  frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n  frag.addUniform(\"u_color\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_color\", (uniform, params) => {\n      const geom = params.geometry as SingleTexturedViewportQuadGeometry;\n      Texture2DHandle.bindSampler(uniform, geom.texture, TextureUnit.Zero);\n    });\n  });\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { TextureUnit } from \"../RenderFlags\";\nimport { VariableType, VariablePrecision, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { CopyPickBufferGeometry } from \"../CachedGeometry\";\nimport { Texture2DHandle } from \"../Texture\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { System } from \"../System\";\n\nconst computeBaseColor = \"return vec4(1.0);\";\n\nconst assignFragData = `\n  FragColor0 = TEXTURE(u_pickFeatureId, v_texCoord);\n  FragColor1 = TEXTURE(u_pickDepthAndOrder, v_texCoord);\n`;\n\n/** @internal */\nexport function createCopyPickBuffersProgram(context: WebGLRenderingContext): ShaderProgram {\n  const builder = createViewportQuadBuilder(true);\n  const frag = builder.frag;\n\n  frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\n\n  if (System.instance.capabilities.maxColorAttachments < 3) {\n    // NB: Never used - we gl.clear() each attachment directly.\n    frag.set(FragmentShaderComponent.AssignFragData, \"FragColor = vec4(0.0);\");\n  } else {\n    frag.addUniform(\"u_pickFeatureId\", VariableType.Sampler2D, (prog) => {\n      prog.addGraphicUniform(\"u_pickFeatureId\", (uniform, params) => {\n        Texture2DHandle.bindSampler(uniform, (params.geometry as CopyPickBufferGeometry).featureId, TextureUnit.Zero);\n      });\n    }, VariablePrecision.High);\n\n    frag.addUniform(\"u_pickDepthAndOrder\", VariableType.Sampler2D, (prog) => {\n      prog.addGraphicUniform(\"u_pickDepthAndOrder\", (uniform, params) => {\n        Texture2DHandle.bindSampler(uniform, (params.geometry as CopyPickBufferGeometry).depthAndOrder, TextureUnit.One);\n      });\n    }, VariablePrecision.High);\n\n    frag.addDrawBuffersExtension();\n    frag.set(FragmentShaderComponent.AssignFragData, assignFragData);\n  }\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { FragmentShaderComponent, VariableType } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { GLSLFragment } from \"./Fragment\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { MutableFloatRgba } from \"../FloatRGBA\";\nimport { ColorDef } from \"@bentley/imodeljs-common\";\n\nconst computeColor = \"return vec4(u_hilite_color.rgb, 1.0);\";\n\nconst scratchHiliteColor: MutableFloatRgba = MutableFloatRgba.fromColorDef(ColorDef.white);\n\n/** @internal */\nexport function createCopyStencilProgram(context: WebGLRenderingContext): ShaderProgram {\n  const builder = createViewportQuadBuilder(true);\n  const frag = builder.frag;\n  frag.set(FragmentShaderComponent.ComputeBaseColor, computeColor);\n  frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n  frag.addUniform(\"u_hilite_color\", VariableType.Vec4, (prog) => {\n    prog.addGraphicUniform(\"u_hilite_color\", (uniform, params) => {\n      const vf = params.target.currentViewFlags;\n      const useLighting = params.geometry.wantMixHiliteColorForFlash(vf, params.target);\n      const hiliteColor = params.target.hiliteColor;\n      scratchHiliteColor.setRgbaValues(hiliteColor.red, hiliteColor.green, hiliteColor.blue, useLighting ? 1.0 : 0.0);\n      scratchHiliteColor.bind(uniform);\n    });\n  });\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\n/** GLSLDecode\n * @internal\n */\nexport namespace GLSLDecode {\n  export const uint16 = `\nfloat decodeUInt16(vec2 v) {\n  v = v * vec2(1.0, 256.0); // v.y <<= 8\n  return dot(v, vec2(1.0)); // v.x+v.y => v.x | v.y\n}\n`;\n\n  export const uint32 = `\nfloat decodeUInt32(vec3 v) {\n  v = v * vec3(1.0, 256.0, 256.0*256.0); // v.y <<= 8; v.z <<= 16\n  return dot(v, vec3(1.0)); // v.x+v.y+v.z => v.x | v.y | v.z\n}\n`;\n\n  export const unquantize3d = `\nvec3 unquantize3d(vec3 qpos, vec3 origin, vec3 scale) { return origin + scale * qpos; }\n`;\n\n  export const unquantize2d = `\n// params.xy = origin. params.zw = scale.\nvec2 unquantize2d(vec2 qpos, vec4 params) { return params.xy + params.zw * qpos; }\n`;\n\n  export const depthRgb = `\nfloat decodeDepthRgb(vec3 rgb) { return dot(rgb, vec3(1.0, 1.0 / 255.0, 1.0 / 65025.0)); }\n`;\n\n  export const encodeDepthRgb = `\nvec3 encodeDepthRgb(float depth) {\n  // 1.0 must be reduced slightly; otherwise decoding will produce zero. It's the far plane, so we don't care (and decoding produces 1.0 anyway).\n  depth = min(depth, 16777215.0/16777216.0);\n\n  vec3 enc = vec3(1.0, 255.0, 65025.0) * depth;\n  enc = fract(enc);\n  enc.xy -= enc.yz / 255.0;\n  return enc;\n}\n`;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport {\n  ProgramBuilder,\n  ShaderBuilderFlags,\n  VariableType,\n  VertexShaderComponent,\n} from \"../ShaderBuilder\";\nimport { addModelViewMatrix, addProjectionMatrix, addLineWeight, addNormalMatrix } from \"./Vertex\";\nimport { addAnimation } from \"./Animation\";\nimport { addViewport, addModelToWindowCoordinates } from \"./Viewport\";\nimport { GL } from \"../GL\";\nimport { addColor } from \"./Color\";\nimport { addWhiteOnWhiteReversal } from \"./Fragment\";\nimport { addShaderFlags } from \"./Common\";\nimport { addLineCode, adjustWidth } from \"./Polyline\";\nimport { octDecodeNormal } from \"./Surface\";\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { IsInstanced, IsAnimated } from \"../TechniqueFlags\";\n\nconst decodeEndPointAndQuadIndices = `\n  g_otherIndex = decodeUInt32(a_endPointAndQuadIndices.xyz);\n  vec2 tc = computeLUTCoords(g_otherIndex, u_vertParams.xy, g_vert_center, u_vertParams.z);\n  vec4 enc1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\n  tc.x += g_vert_stepX;\n  vec4 enc2 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\n  vec3 qpos = vec3(decodeUInt16(enc1.xy), decodeUInt16(enc1.zw), decodeUInt16(enc2.xy));\n  g_otherPos = unquantizePosition(qpos, u_qOrigin, u_qScale);\n  g_quadIndex = a_endPointAndQuadIndices.w;\n`;\nconst animateEndPoint = `g_otherPos.xyz += computeAnimationDisplacement(g_otherIndex, u_animDispParams.x, u_animDispParams.y, u_animDispParams.z, u_qAnimDispOrigin, u_qAnimDispScale);\n`;\n\nconst checkForSilhouetteDiscard = `\n  vec3 n0 = MAT_NORM * octDecodeNormal(a_normals.xy);\n  vec3 n1 = MAT_NORM * octDecodeNormal(a_normals.zw);\n\n  if (0.0 == MAT_MVP[0].w) {\n    return n0.z * n1.z > 0.0;           // orthographic.\n  } else {\n    vec4  viewPos = MAT_MV * rawPos;     // perspective\n    vec3  toEye = normalize(viewPos.xyz);\n    float dot0 = dot(n0, toEye);\n    float dot1 = dot(n1, toEye);\n\n    if (dot0 * dot1 > 0.0)\n      return true;\n\n    // Need to discard if either is non-silhouette.\n    vec4 otherPosition = g_otherPos;\n    viewPos = MAT_MV * otherPosition;\n    toEye = normalize(viewPos.xyz);\n    dot0 = dot(n0, toEye);\n    dot1 = dot(n1, toEye);\n\n    return dot0 * dot1 > 0.0;\n  }\n`;\n\nconst computePosition = `\n  v_lnInfo = vec4(0.0, 0.0, 0.0, 0.0);  // init and set flag to false\n  vec4  pos = MAT_MVP * rawPos;\n  vec4  other = g_otherPos;\n  vec3  modelDir = other.xyz - pos.xyz;\n  float miterAdjust = 0.0;\n  float weight = computeLineWeight();\n\n  g_windowPos = modelToWindowCoordinates(rawPos, other);\n\n  if (g_windowPos.w == 0.0) // Clipped out.\n    return g_windowPos;\n\n  vec4 projOther = modelToWindowCoordinates(other, rawPos);\n\n  g_windowDir = projOther.xy - g_windowPos.xy;\n\n  adjustWidth(weight, g_windowDir, g_windowPos.xy);\n  g_windowDir = normalize(g_windowDir);\n\n  vec2  perp = vec2(-g_windowDir.y, g_windowDir.x);\n  float perpDist = weight / 2.0;\n  float alongDist = 0.0;\n\n  perpDist *= sign(0.5 - float(g_quadIndex == 0.0 || g_quadIndex == 3.0)); // negate for index 0 and 3\n  alongDist += distance(rawPos, other) * float(g_quadIndex >= 2.0); // index 2 and 3 correspond to 'far' endpoint of segment\n\n  pos.x += perp.x * perpDist * 2.0 * pos.w / u_viewport.z;\n  pos.y += perp.y * perpDist * 2.0 * pos.w / u_viewport.w;\n\n  lineCodeEyePos = .5 * (rawPos + other);\n  lineCodeDist = alongDist;\n\n  return pos;\n`;\nconst lineCodeArgs = \"g_windowDir, g_windowPos, 0.0\";\n\nfunction createBase(isSilhouette: boolean, instanced: IsInstanced, isAnimated: IsAnimated): ProgramBuilder {\n  const builder = new ProgramBuilder(instanced ? ShaderBuilderFlags.InstancedVertexTable : ShaderBuilderFlags.VertexTable);\n  const vert = builder.vert;\n\n  vert.addGlobal(\"g_otherPos\", VariableType.Vec4);\n  vert.addGlobal(\"g_quadIndex\", VariableType.Float);\n  vert.addGlobal(\"g_windowPos\", VariableType.Vec4);\n  vert.addGlobal(\"g_windowDir\", VariableType.Vec2);\n  vert.addGlobal(\"g_otherIndex\", VariableType.Float);\n\n  vert.addInitializer(decodeEndPointAndQuadIndices);\n  if (isAnimated) {\n    addAnimation(vert, false);\n    vert.addInitializer(animateEndPoint);\n  }\n\n  vert.addGlobal(\"lineCodeEyePos\", VariableType.Vec4);\n  vert.addGlobal(\"lineCodeDist\", VariableType.Float, \"0.0\");\n\n  addModelToWindowCoordinates(vert); // adds u_mvp, u_viewportTransformation\n  addProjectionMatrix(vert);\n  addLineCode(builder, lineCodeArgs);\n  vert.set(VertexShaderComponent.ComputePosition, computePosition);\n  builder.addVarying(\"v_lnInfo\", VariableType.Vec4);\n  vert.addFunction(adjustWidth);\n\n  addViewport(vert);\n  addModelViewMatrix(vert);\n\n  vert.addAttribute(\"a_endPointAndQuadIndices\", VariableType.Vec4, (shaderProg) => {\n    shaderProg.addAttribute(\"a_endPointAndQuadIndices\", (attr, params) => {\n      const geom = params.geometry;\n      assert(undefined !== geom.asEdge);\n      const edgeGeom = geom.asEdge!;\n      attr.enableArray(edgeGeom.endPointAndQuadIndices, 4, GL.DataType.UnsignedByte, false, 0, 0);\n    });\n  });\n\n  addLineWeight(vert);\n\n  if (isSilhouette) {\n    addNormalMatrix(vert);\n    vert.set(VertexShaderComponent.CheckForEarlyDiscard, checkForSilhouetteDiscard);\n    vert.addFunction(octDecodeNormal);\n    vert.addAttribute(\"a_normals\", VariableType.Vec4, (shaderProg) => {\n      shaderProg.addAttribute(\"a_normals\", (attr, params) => {\n        const geom = params.geometry;\n        assert(undefined !== geom.asSilhouette);\n        const silhouetteGeom = geom.asSilhouette!;\n        attr.enableArray(silhouetteGeom.normalPairs, 4, GL.DataType.UnsignedByte, false, 0, 0);\n      });\n    });\n  }\n\n  return builder;\n}\n\n/** @internal */\nexport function createEdgeBuilder(isSilhouette: boolean, instanced: IsInstanced, isAnimated: IsAnimated): ProgramBuilder {\n  const builder = createBase(isSilhouette, instanced, isAnimated);\n  addShaderFlags(builder);\n  addColor(builder);\n  addWhiteOnWhiteReversal(builder.frag);\n  return builder;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport {\n  ProgramBuilder,\n  ShaderBuilder,\n  VertexShaderBuilder,\n  FragmentShaderBuilder,\n  VariableType,\n  VertexShaderComponent,\n  VariablePrecision,\n  FragmentShaderComponent,\n} from \"../ShaderBuilder\";\nimport { Hilite, ColorDef } from \"@bentley/imodeljs-common\";\nimport { TextureUnit, OvrFlags } from \"../RenderFlags\";\nimport { FeatureMode, IsEdgeTestNeeded, IsClassified } from \"../TechniqueFlags\";\nimport { addLineWeight, replaceLineWeight, replaceLineCode, addAlpha } from \"./Vertex\";\nimport { GLSLFragment, addWindowToTexCoords } from \"./Fragment\";\nimport { GLSLCommon, addEyeSpace, addUInt32s } from \"./Common\";\nimport { GLSLDecode } from \"./Decode\";\nimport { addLookupTable } from \"./LookupTable\";\nimport { addRenderPass } from \"./RenderPass\";\nimport { UniformHandle } from \"../Handle\";\nimport { GL } from \"../GL\";\nimport { DrawParams } from \"../DrawCommand\";\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { MutableFloatRgba } from \"../FloatRGBA\";\n\n// tslint:disable:no-const-enum\n\n/** @internal */\nexport const enum FeatureSymbologyOptions {\n  None = 0,\n  Weight = 1 << 0,\n  LineCode = 1 << 1,\n  HasOverrides = 1 << 2,\n  Color = 1 << 3,\n  Alpha = 1 << 4,\n\n  Surface = HasOverrides | Color | Alpha,\n  Point = HasOverrides | Color | Weight | Alpha,\n  Linear = HasOverrides | Color | Weight | LineCode | Alpha,\n}\n\n/** @internal */\nexport function addOvrFlagConstants(builder: ShaderBuilder): void {\n  // NB: These are the bit positions of each flag in OvrFlags enum - not the flag values\n  builder.addConstant(\"kOvrBit_Visibility\", VariableType.Float, \"0.0\");\n  builder.addConstant(\"kOvrBit_Rgb\", VariableType.Float, \"1.0\");\n  builder.addConstant(\"kOvrBit_Alpha\", VariableType.Float, \"2.0\");\n  builder.addConstant(\"kOvrBit_Weight\", VariableType.Float, \"3.0\");\n  builder.addConstant(\"kOvrBit_Flashed\", VariableType.Float, \"4.0\");\n  builder.addConstant(\"kOvrBit_Hilited\", VariableType.Float, \"5.0\");\n  builder.addConstant(\"kOvrBit_LineCode\", VariableType.Float, \"6.0\");\n  builder.addConstant(\"kOvrBit_IgnoreMaterial\", VariableType.Float, \"7.0\");\n}\n\nconst computeLUTFeatureIndex = `floor(TEXTURE(u_vertLUT, g_featureIndexCoords) * 255.0 + 0.5)`;\nconst computeInstanceFeatureIndex = `vec4(a_featureId, 0.0)`;\nfunction computeFeatureIndex(instanced: boolean): string {\n  return `g_featureIndex = ` + (instanced ? computeInstanceFeatureIndex : computeLUTFeatureIndex) + `;`;\n}\nfunction getFeatureIndex(instanced: boolean): string {\n  return `\n  float getFeatureIndex() {\n    g_featureIndex = ` + computeFeatureIndex(instanced) + `;\n    return decodeUInt32(g_featureIndex.xyz);\n  }`;\n}\n\n// Returns 1.0 if the specified flag is not globally overridden and is set in flags\nconst extractNthFeatureBit = `\nfloat extractNthFeatureBit(float flags, float n) {\n  return (1.0 - extractNthBit(u_globalOvrFlags, n)) * extractNthBit(flags, n);\n}\n`;\n\nconst computeFeatureTextureCoords = `\nvec2 computeFeatureTextureCoords() { return compute_feature_coords(getFeatureIndex()); }\n`;\n\nconst getFirstFeatureRgba = `\nvec4 getFirstFeatureRgba() {\n  feature_texCoord = computeFeatureTextureCoords();\n  return TEXTURE(u_featureLUT, feature_texCoord);\n}\n`;\n\nconst getSecondFeatureRgba = `\nvec4 getSecondFeatureRgba() {\n  vec2 coord = feature_texCoord;\n  coord.x += g_feature_stepX;\n  return TEXTURE(u_featureLUT, coord);\n}\n`;\n\nconst computeLineWeight = `\nfloat computeLineWeight() {\n  return mix(g_lineWeight, linear_feature_overrides.y, linear_feature_overrides.x);\n}\n`;\n\nconst computeLineCode = `\nfloat computeLineCode() {\n  return mix(g_lineCode, linear_feature_overrides.w, linear_feature_overrides.z);\n}\n`;\n\nfunction addFeatureIndex(vert: VertexShaderBuilder): void {\n  vert.addGlobal(\"g_featureIndex\", VariableType.Vec4);\n  vert.addFunction(getFeatureIndex(vert.usesInstancedGeometry));\n  if (vert.usesInstancedGeometry) {\n    vert.addAttribute(\"a_featureId\", VariableType.Vec3, (prog) => {\n      prog.addAttribute(\"a_featureId\", (attr, params) => {\n        const geom = params.geometry.asInstanced!;\n        assert(undefined !== geom);\n        assert(undefined !== geom.featureIds, \"Cannot use feature shaders if no features\");\n        if (undefined !== geom.featureIds)\n          attr.enableArray(geom.featureIds, 3, GL.DataType.UnsignedByte, false, 0, 0, true);\n      });\n    });\n  }\n}\n\n// Discards vertex if feature is invisible; or rendering opaque during translucent pass or vice-versa\n// (The latter occurs when some translucent feature is overridden to be opaque, or vice-versa)\nconst checkVertexDiscard = `\n  if (feature_invisible)\n    return true;\n\n  bool hasAlpha = 1.0 == u_hasAlpha;\n  if (v_feature_alpha_flashed.x > 0.0) {\n    const float s_minTransparency = 15.0; // NB: See DisplayParams.getMinTransparency() - this must match!\n    const float s_maxAlpha = (255.0 - s_minTransparency) / 255.0;\n    hasAlpha = v_feature_alpha_flashed.x < s_maxAlpha;\n  }\n\n  bool isOpaquePass = (kRenderPass_OpaqueLinear <= u_renderPass && kRenderPass_OpaqueGeneral >= u_renderPass);\n  bool isTranslucentPass = kRenderPass_Translucent == u_renderPass;\n  return (isOpaquePass && hasAlpha) || (isTranslucentPass && !hasAlpha);\n`;\n\nfunction addCommon(builder: ProgramBuilder, mode: FeatureMode, opts: FeatureSymbologyOptions): boolean {\n  if (FeatureMode.None === mode)\n    return false;\n\n  const vert = builder.vert;\n  addFeatureIndex(vert);\n\n  const haveOverrides = FeatureSymbologyOptions.None !== (opts & FeatureSymbologyOptions.HasOverrides);\n  if (!haveOverrides) {\n    // For pick output we must compute g_featureIndex...\n    if (FeatureMode.Pick === mode)\n      vert.set(VertexShaderComponent.ComputeFeatureOverrides, computeFeatureIndex(vert.usesInstancedGeometry));\n\n    return true;\n  }\n\n  const wantWeight = FeatureSymbologyOptions.None !== (opts & FeatureSymbologyOptions.Weight);\n  const wantLineCode = FeatureSymbologyOptions.None !== (opts & FeatureSymbologyOptions.LineCode);\n  const wantColor = FeatureSymbologyOptions.None !== (opts & FeatureSymbologyOptions.Color);\n  const wantAlpha = FeatureSymbologyOptions.None !== (opts & FeatureSymbologyOptions.Alpha);\n  assert(wantColor || !wantAlpha);\n\n  vert.addGlobal(\"feature_invisible\", VariableType.Boolean, \"false\");\n  vert.addFunction(GLSLCommon.extractNthBit);\n  addOvrFlagConstants(vert);\n\n  vert.addGlobal(\"linear_feature_overrides\", VariableType.Vec4, \"vec4(0.0)\");\n  vert.addGlobal(\"feature_ignore_material\", VariableType.Boolean, \"false\");\n\n  vert.addFunction(extractNthFeatureBit);\n  if (wantWeight || wantLineCode) {\n    if (wantLineCode)\n      replaceLineCode(vert, computeLineCode);\n\n    if (wantWeight) {\n      replaceLineWeight(vert, computeLineWeight);\n      vert.addUniform(\"u_globalOvrFlags\", VariableType.Float, (prog) => {\n        prog.addGraphicUniform(\"u_globalOvrFlags\", (uniform, params) => {\n          let flags = 0.0;\n          if (params.geometry.isEdge) {\n            const edgeOvrs = params.target.getEdgeOverrides(params.renderPass);\n            if (undefined !== edgeOvrs)\n              flags = edgeOvrs.computeOvrFlags();\n          }\n\n          uniform.setUniform1f(flags);\n        });\n      });\n    }\n  } else {\n    vert.addUniform(\"u_globalOvrFlags\", VariableType.Float, (prog) => {\n      prog.addGraphicUniform(\"u_globalOvrFlags\", (uniform, params) => {\n        // If transparency view flag is off, do not allow features to override transparency.\n        // This is particularly important for Target.readPixels(), which draws everything opaque - otherwise we cannot locate elements with transparent overrides.\n        const flags = params.target.currentViewFlags.transparency ? 0.0 : OvrFlags.Alpha;\n        uniform.setUniform1f(flags);\n      });\n    });\n  }\n\n  addLookupTable(vert, \"feature\", \"2.0\");\n  vert.addGlobal(\"feature_texCoord\", VariableType.Vec2);\n  vert.addFunction(computeFeatureTextureCoords);\n  vert.addFunction(getFirstFeatureRgba);\n\n  vert.addUniform(\"u_featureLUT\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_featureLUT\", (uniform, params) => {\n      const ovr = params.target.currentOverrides;\n      assert(undefined !== ovr);\n      ovr!.lut!.bindSampler(uniform, TextureUnit.FeatureSymbology);\n    });\n  });\n  vert.addUniform(\"u_featureParams\", VariableType.Vec2, (prog) => {\n    prog.addGraphicUniform(\"u_featureParams\", (uniform, params) => {\n      const ovr = params.target.currentOverrides!;\n      uniform.setUniform2fv([ovr.lut!.width, ovr.lut!.height]);\n    });\n  });\n\n  if (wantColor) {\n    vert.addFunction(getSecondFeatureRgba);\n    if (wantAlpha) {\n      addAlpha(vert);\n      vert.set(VertexShaderComponent.CheckForDiscard, checkVertexDiscard);\n    }\n  }\n\n  return true;\n}\n\nconst scratchHiliteColor: MutableFloatRgba = MutableFloatRgba.fromColorDef(ColorDef.white);\n\n/** @internal */\nexport function addHiliteSettings(frag: FragmentShaderBuilder): void {\n  frag.addUniform(\"u_hilite_color\", VariableType.Vec4, (prog) => {\n    prog.addGraphicUniform(\"u_hilite_color\", (uniform, params) => {\n      const vf = params.target.currentViewFlags;\n      const useLighting = params.geometry.wantMixHiliteColorForFlash(vf, params.target);\n      const hiliteColor = params.target.hiliteColor;\n      scratchHiliteColor.setRgbaValues(hiliteColor.red, hiliteColor.green, hiliteColor.blue, useLighting ? 1.0 : 0.0);\n      scratchHiliteColor.bind(uniform);\n    });\n  });\n\n  frag.addUniform(\"u_hilite_settings\", VariableType.Vec3, (prog) => {\n    prog.addProgramUniform(\"u_hilite_settings\", (uniform, params) => {\n      const hilite = params.target.hiliteSettings;\n      let silhouette = 2.0;\n      switch (hilite.silhouette) {\n        case Hilite.Silhouette.None: silhouette = 0.0; break;\n        case Hilite.Silhouette.Thin: silhouette = 1.0; break;\n      }\n\n      // During the normal pass (with depth testing), we mix the hilite color with the element color.\n      // During the compositing pass, we mix the hilite color with the fragment color.\n      // We have no idea if we're hiliting an occluded or visible portion of the hilited element.\n      const hidden = hilite.hiddenRatio;\n      const visible = Math.max(0, hilite.visibleRatio - hidden);\n      uniform.setUniform3fv([visible, hidden, silhouette]);\n    });\n  });\n}\n\n// If feature is not hilited, discard it.\nconst checkVertexHiliteDiscard = \"return 0.0 == v_feature_hilited;\";\n\n// The result is a mask in which each highlighted pixel is white, all other pixels are black.\nconst computeHiliteColor = \"return vec4(ceil(v_feature_hilited));\";\nconst computeSurfaceHiliteColor = `\nif (ceil(v_feature_hilited) >= 1.0 && isSurfaceBitSet(kSurfaceBit_HasTexture))\n  return vec4(TEXTURE(s_texture, v_texCoord).a > 0.15 ? 1.0 : 0.0);\nelse\n  return vec4(ceil(v_feature_hilited));\n`;\n\nconst computeHiliteOverrides = `\n  vec4 value = getFirstFeatureRgba();\n  float flags = value.r * 256.0;\n  feature_invisible = 1.0 == extractNthFeatureBit(flags, kOvrBit_Visibility);\n  v_feature_hilited = extractNthFeatureBit(flags, kOvrBit_Hilited);\n`;\n\nconst computeHiliteOverridesWithWeight = computeHiliteOverrides + `\n  linear_feature_overrides = vec4(1.0 == extractNthFeatureBit(flags, kOvrBit_Weight),\n  value.g * 256.0,\n  1.0 == extractNthFeatureBit(flags, kOvrBit_LineCode),\n  value.b * 256.0);\n`;\n\n/** @internal */\nexport function addSurfaceHiliter(builder: ProgramBuilder, wantWeight: boolean = false): void {\n  addHiliter(builder, wantWeight);\n  builder.frag.set(FragmentShaderComponent.ComputeBaseColor, computeSurfaceHiliteColor);\n}\n\n/** @internal */\nexport function addHiliter(builder: ProgramBuilder, wantWeight: boolean = false): void {\n  let opts = FeatureSymbologyOptions.HasOverrides;\n  if (wantWeight)\n    opts |= FeatureSymbologyOptions.Weight; // hiliter never needs line code or color...\n\n  if (!addCommon(builder, FeatureMode.Overrides, opts))\n    return;\n\n  builder.addVarying(\"v_feature_hilited\", VariableType.Float);\n\n  builder.vert.set(VertexShaderComponent.ComputeFeatureOverrides, wantWeight ? computeHiliteOverridesWithWeight : computeHiliteOverrides);\n  builder.vert.set(VertexShaderComponent.CheckForDiscard, checkVertexHiliteDiscard);\n\n  builder.frag.set(FragmentShaderComponent.ComputeBaseColor, computeHiliteColor);\n  builder.frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n}\n\nfunction addSamplers(frag: FragmentShaderBuilder, testFeatureId: boolean) {\n  if (testFeatureId) {\n    frag.addUniform(\"u_pickFeatureId\", VariableType.Sampler2D, (prog) => {\n      prog.addProgramUniform(\"u_pickFeatureId\", (uniform, params) => {\n        params.target.compositor.featureIds.bindSampler(uniform, TextureUnit.PickFeatureId);\n      });\n    }, VariablePrecision.High);\n  }\n\n  frag.addUniform(\"u_pickDepthAndOrder\", VariableType.Sampler2D, (prog) => {\n    prog.addProgramUniform(\"u_pickDepthAndOrder\", (uniform, params) => {\n      params.target.compositor.depthAndOrder.bindSampler(uniform, TextureUnit.PickDepthAndOrder);\n    });\n  }, VariablePrecision.High);\n}\n\n/** @internal */\nexport const readDepthAndOrder = `\nvec2 readDepthAndOrder(vec2 tc) {\n  vec4 pdo = TEXTURE(u_pickDepthAndOrder, tc);\n  float order = floor(pdo.x * 16.0 + 0.5);\n  return vec2(order, decodeDepthRgb(pdo.yzw));\n}\n`;\n\n// ####TODO vertex shader already tests transparency threshold...native renderer tests here as well?\nconst checkForEarlySurfaceDiscard = `\n  float factor = float(u_renderPass <= kRenderPass_Translucent); // never discard during specific passes\n  float term = 0.0; // float(isBelowTransparencyThreshold()); // else always discard if alpha < transparency threshold\n\n  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\n  vec2 depthAndOrder = readDepthAndOrder(tc);\n  float surfaceDepth = computeLinearDepth(v_eyeSpace.z);\n  term += float(depthAndOrder.x > u_renderOrder && abs(depthAndOrder.y - surfaceDepth) < 4.0e-5);\n  return factor * term > 0.0;\n`;\n\n// ####TODO vertex shader already tests transparency threshold...native renderer tests here as well?\nconst checkForEarlySurfaceDiscardWithFeatureID = `\n  // No normals => unlt => reality model => no edges.\n  bool neverDiscard = u_renderPass > kRenderPass_Translucent || !isSurfaceBitSet(kSurfaceBit_HasNormals);\n  bool alwaysDiscard = false; // !neverDiscard && isBelowTransparencyThreshold();\n\n  vec2 tc = windowCoordsToTexCoords(gl_FragCoord.xy);\n  vec2 depthAndOrder = readDepthAndOrder(tc);\n  bool discardByOrder = depthAndOrder.x > u_renderOrder;\n\n  // Calculate depthTolerance for letting edges show through their own surfaces\n  float perspectiveFrustum = step(kFrustumType_Perspective, u_frustum.z);\n  vec4 eyeDirAndWidthFactor = mix(vec4(0.0, 0.0, 1.0, u_pixelWidthFactor), vec4(normalize(-v_eyeSpace.xyz), -v_eyeSpace.z * u_pixelWidthFactor), perspectiveFrustum);\n  vec3 eyeDir = eyeDirAndWidthFactor.xyz;\n  float dtWidthFactor = eyeDirAndWidthFactor.w;\n\n  // Compute depth tolerance based on angle of triangle to screen\n  float isSilhouette = float(depthAndOrder.x == kRenderOrder_Silhouette);\n  float dSq = dot(eyeDir, v_n);\n  dSq *= 0.5 + 0.4 * (1.0 - isSilhouette);\n  dSq = dSq * dSq;\n  dSq = max(dSq, 0.0001);\n  dSq = min(dSq, 0.999);\n\n  float depthTolerance = dtWidthFactor * v_lineWeight * sqrt((1.0 - dSq) / dSq);\n  depthTolerance *= 1.0 + .333 * isSilhouette;\n\n  // Make sure stuff behind camera doesn't get pushed in front of it\n  depthTolerance = max(depthTolerance, 0.0);\n\n  // Convert depthTolerance from eye space to linear depth\n  depthTolerance /= (u_frustum.y - u_frustum.x);\n\n  float surfaceDepth = computeLinearDepth(v_eyeSpace.z);\n  float depthDelta = abs(depthAndOrder.y - surfaceDepth);\n  bool withinDepthTolerance = depthDelta <= depthTolerance;\n\n  // Does pick buffer contain same feature?\n  vec4 featId = TEXTURE(u_pickFeatureId, tc);\n\n  // Converting to ints to test since varying floats can be interpolated incorrectly\n  ivec4 featId_i = ivec4(featId * 255.0 + 0.5);\n  ivec4 v_feature_id_i = ivec4(v_feature_id * 255.0 + 0.5);\n  bool isSameFeature = featId_i == v_feature_id_i;\n\n  // If what was in the pick buffer is a planar line/edge/silhouette then we've already tested the depth so return true to discard.\n  // If it was a planar surface then use a tighter and constant tolerance to see if we want to let it show through since we're only fighting roundoff error.\n  return alwaysDiscard || (!neverDiscard && discardByOrder && withinDepthTolerance && (isSameFeature || ((depthAndOrder.x > kRenderOrder_PlanarSurface) || ((depthAndOrder.x == kRenderOrder_PlanarSurface) && (depthDelta <= 4.0e-5)))));\n`;\n\n/** @internal */\nexport const computeFeatureId = `v_feature_id = addUInt32s(u_batch_id, g_featureIndex) / 255.0;`;\n\nfunction addRenderOrderConstants(builder: ShaderBuilder) {\n  builder.addConstant(\"kRenderOrder_None\", VariableType.Float, \"0.0\");\n  builder.addConstant(\"kRenderOrder_BlankingRegion\", VariableType.Float, \"1.0\");\n  builder.addConstant(\"kRenderOrder_Surface\", VariableType.Float, \"2.0\");\n  builder.addConstant(\"kRenderOrder_Linear\", VariableType.Float, \"3.0\");\n  builder.addConstant(\"kRenderOrder_Edge\", VariableType.Float, \"4.0\");\n  builder.addConstant(\"kRenderOrder_Silhouette\", VariableType.Float, \"5.0\");\n\n  builder.addConstant(\"kRenderOrder_PlanarSurface\", VariableType.Float, \"10.0\");\n  builder.addConstant(\"kRenderOrder_PlanarLinear\", VariableType.Float, \"11.0\");\n  builder.addConstant(\"kRenderOrder_PlanarEdge\", VariableType.Float, \"12.0\");\n  builder.addConstant(\"kRenderOrder_PlanarSilhouette\", VariableType.Float, \"13.0\");\n}\n\n/** @internal */\nexport function addRenderOrder(builder: ShaderBuilder) {\n  builder.addUniform(\"u_renderOrder\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_renderOrder\", (uniform, params) => {\n      uniform.setUniform1f(params.geometry.renderOrder);\n    });\n  });\n}\n\nfunction setPixelWidthFactor(uniform: UniformHandle, params: DrawParams) {\n  const rect = params.target.viewRect;\n  const width = rect.width;\n  const height = rect.height;\n\n  const frustumPlanes = params.target.frustumUniforms.frustumPlanes;\n  const top = frustumPlanes[0];\n  const bottom = frustumPlanes[1];\n  const left = frustumPlanes[2];\n  const right = frustumPlanes[3];\n\n  let halfPixelWidth: number;\n  let halfPixelHeight: number;\n  const frustum = params.target.frustumUniforms.frustum;\n  if (2.0 === frustum[2]) { // perspective\n    const inverseNear = 1.0 / frustum[0];\n    const tanTheta = top * inverseNear;\n    halfPixelHeight = tanTheta / height;\n    halfPixelWidth = tanTheta / width;\n  } else {\n    halfPixelWidth = 0.5 * (right - left) / width;\n    halfPixelHeight = 0.5 * (top - bottom) / height;\n  }\n\n  const pixelWidthFactor = Math.sqrt(halfPixelWidth * halfPixelWidth + halfPixelHeight * halfPixelHeight);\n  uniform.setUniform1f(pixelWidthFactor);\n}\n\nfunction addPixelWidthFactor(builder: ShaderBuilder) {\n  builder.addUniform(\"u_pixelWidthFactor\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_pixelWidthFactor\", (uniform, params) => { setPixelWidthFactor(uniform, params); });\n  });\n}\n\nconst scratchBytes = new Uint8Array(4);\nconst scratchBatchId = new Uint32Array(scratchBytes.buffer);\nconst scratchBatchComponents = [0, 0, 0, 0];\n\nfunction addBatchId(vert: VertexShaderBuilder) {\n  vert.addUniform(\"u_batch_id\", VariableType.Vec4, (prog) => {\n    prog.addGraphicUniform(\"u_batch_id\", (uniform, params) => {\n      const batchId = params.target.currentBatchId;\n      scratchBatchId[0] = batchId;\n      scratchBatchComponents[0] = scratchBytes[0];\n      scratchBatchComponents[1] = scratchBytes[1];\n      scratchBatchComponents[2] = scratchBytes[2];\n      scratchBatchComponents[3] = scratchBytes[3];\n      uniform.setUniform4fv(scratchBatchComponents);\n    });\n  }, VariablePrecision.High);\n}\n\n/** @internal */\nexport function addFeatureId(builder: ProgramBuilder) {\n  const vert = builder.vert;\n  vert.addFunction(addUInt32s);\n  builder.addInlineComputedVarying(\"v_feature_id\", VariableType.Vec4, computeFeatureId);\n  addBatchId(vert);\n}\n\n// For hidden line + solid fill modes...translucent + opaque passes only.\n// Note the test is based on the element color's alpha, ignoring any feature overrides etc.\nconst isBelowTransparencyThreshold = `\n  return g_baseAlpha < u_transparencyThreshold && isSurfaceBitSet(kSurfaceBit_TransparencyThreshold);\n`;\n\n/** @internal */\nexport function addSurfaceDiscard(builder: ProgramBuilder, feat: FeatureMode, isEdgeTestNeeded: IsEdgeTestNeeded, isClassified: IsClassified) {\n  const frag = builder.frag;\n  const vert = builder.vert;\n\n  vert.set(VertexShaderComponent.CheckForLateDiscard, isBelowTransparencyThreshold);\n  vert.addUniform(\"u_transparencyThreshold\", VariableType.Float, (prog) => {\n    prog.addProgramUniform(\"u_transparencyThreshold\", (uniform, params) => {\n      uniform.setUniform1f(params.target.transparencyThreshold);\n    });\n  });\n\n  if (isEdgeTestNeeded) {\n    addWindowToTexCoords(frag);\n\n    if (FeatureMode.None === feat) {\n      addSamplers(frag, false);\n      frag.addFunction(GLSLFragment.computeLinearDepth);\n      frag.addFunction(GLSLDecode.depthRgb);\n      frag.addFunction(readDepthAndOrder);\n      addEyeSpace(builder);\n      frag.set(FragmentShaderComponent.CheckForEarlyDiscard, checkForEarlySurfaceDiscard);\n    } else {\n      addFeatureIndex(vert);\n      addLineWeight(vert);\n\n      addSamplers(frag, true);\n      addRenderOrderConstants(frag);\n      addPixelWidthFactor(frag);\n      frag.addFunction(GLSLFragment.computeLinearDepth);\n      frag.addFunction(GLSLDecode.depthRgb);\n      frag.addFunction(readDepthAndOrder);\n      frag.set(FragmentShaderComponent.CheckForEarlyDiscard, checkForEarlySurfaceDiscardWithFeatureID);\n\n      addEyeSpace(builder);\n      builder.addInlineComputedVarying(\"v_lineWeight\", VariableType.Float, \"v_lineWeight = computeLineWeight();\");\n      addFeatureId(builder);\n    }\n\n    addRenderOrder(frag);\n    addRenderPass(frag);\n  } else if (isClassified && FeatureMode.None !== feat) {\n    addFeatureIndex(vert);\n    addEyeSpace(builder);\n    addFeatureId(builder);\n    addRenderOrder(frag);\n  }\n}\n\n// bool feature_invisible = false;\n// varying vec3 v_feature_rgb; // if not overridden, .r < 0; else rgb color override\n// varying vec4 v_feature_alpha_flashed; // x = alpha if overridden, else < 0; y = 1 if flashed, 2 if hilited, 3 if both, 0 if neither\n// varying vec4 v_feature_alpha_flashed; // y > 0.0 if overridden. z > 0.0 if flashed. w > 0.0 if hilited.\n// vec4 linear_feature_overrides; // x: weight overridden y: weight z: line code overridden w: line code\nconst computeFeatureOverrides = `\n  v_feature_rgb = vec3(-1.0);\n  v_feature_alpha_flashed = vec2(-1.0, 0.0);\n  vec4 value = getFirstFeatureRgba();\n\n  // 2 RGBA values per feature - first R is override flags mask, first A is 1.0 for non-locatable feature.\n  // The latter makes the feature invisible only if the \"ignore non-locatable\" shader flag is set.\n  float nonLocatable = value.a * extractShaderBit(kShaderBit_IgnoreNonLocatable);\n  if (0.0 == value.r + nonLocatable)\n    return; // nothing overridden for this feature\n\n  float flags = value.r * 256.0;\n  float invisible = extractNthFeatureBit(flags, kOvrBit_Visibility);\n  feature_invisible = 0.0 != (invisible + nonLocatable);\n  if (feature_invisible)\n    return;\n\n  bool rgbOverridden = extractNthFeatureBit(flags, kOvrBit_Rgb) > 0.0;\n  bool alphaOverridden = extractNthFeatureBit(flags, kOvrBit_Alpha) > 0.0;\n  if (alphaOverridden || rgbOverridden) {\n    vec4 rgba = getSecondFeatureRgba();\n    if (rgbOverridden)\n      v_feature_rgb = rgba.rgb;\n\n    if (alphaOverridden)\n      v_feature_alpha_flashed.x = rgba.a;\n  }\n\n  linear_feature_overrides = vec4(1.0 == extractNthFeatureBit(flags, kOvrBit_Weight),\n                                  value.g * 256.0,\n                                  1.0 == extractNthFeatureBit(flags, kOvrBit_LineCode),\n                                  value.b * 256.0);\n\n  feature_ignore_material = 0.0 != extractNthFeatureBit(flags, kOvrBit_IgnoreMaterial);\n  v_feature_alpha_flashed.y = extractNthFeatureBit(flags, kOvrBit_Flashed);\n  v_feature_alpha_flashed.y += 2.0 * extractNthFeatureBit(flags, kOvrBit_Hilited);\n`;\n\n// v_feature_rgb.r = -1.0 if rgb color not overridden for feature.\n// v_feature_alpha_flashed.x = -1.0 if alpha not overridden for feature.\nconst applyFeatureColor = `\n  vec4 color = mix(baseColor, vec4(v_feature_rgb.rgb * baseColor.a, baseColor.a), step(0.0, v_feature_rgb.r));\n  return mix(color, adjustPreMultipliedAlpha(color, v_feature_alpha_flashed.x), step(0.0, v_feature_alpha_flashed.x));\n`;\n\nconst applyFlash = `\n  float flashHilite = floor(v_feature_alpha_flashed.y + 0.5);\n  return doApplyFlash(flashHilite, baseColor);\n`;\n\n// u_hilite_color.a is 1.0 for lit geometry, 0.0 for unlit. Lit gets brightened; unlit gets tweened.\nconst doApplyFlash = `\nvec4 doApplyFlash(float flashHilite, vec4 baseColor) {\n  float isFlashed = (flashHilite == 1.0 || flashHilite == 3.0) ? 1.0 : 0.0;\n  float isHilited = (flashHilite >= 2.0) ? 1.0 : 0.0;\n\n  float hiliteRatio = u_hilite_settings.x * isHilited;\n  baseColor = revertPreMultipliedAlpha(baseColor);\n  baseColor.rgb = mix(baseColor.rgb, u_hilite_color.rgb, hiliteRatio);\n\n  const float maxBrighten = 0.2;\n  float brighten = u_flash_intensity * maxBrighten;\n  vec3 brightRgb = baseColor.rgb + isFlashed * brighten;\n\n  const float maxTween = 0.75;\n  float hiliteFraction = u_flash_intensity * isFlashed * maxTween;\n  vec3 tweenRgb = baseColor.rgb * (1.0 - hiliteFraction);\n  tweenRgb += u_hilite_color.rgb * hiliteFraction;\n\n  vec4 color = vec4(mix(tweenRgb, brightRgb, u_hilite_color.a), baseColor.a);\n  return applyPreMultipliedAlpha(color);\n}\n`;\n\nfunction addApplyFlash(frag: FragmentShaderBuilder) {\n  addHiliteSettings(frag);\n\n  frag.addFunction(GLSLFragment.revertPreMultipliedAlpha);\n  frag.addFunction(GLSLFragment.applyPreMultipliedAlpha);\n  frag.addFunction(GLSLFragment.adjustPreMultipliedAlpha);\n  frag.addFunction(doApplyFlash);\n  frag.set(FragmentShaderComponent.ApplyFlash, applyFlash);\n\n  frag.addUniform(\"u_flash_intensity\", VariableType.Float, (prog) => {\n    prog.addProgramUniform(\"u_flash_intensity\", (uniform, params) => {\n      uniform.setUniform1f(params.target.flashIntensity);\n    });\n  });\n}\n\n/** @internal */\nexport function addFeatureSymbology(builder: ProgramBuilder, feat: FeatureMode, opts: FeatureSymbologyOptions): void {\n  if (!addCommon(builder, feat, opts) || FeatureSymbologyOptions.None === opts)\n    return;\n\n  assert((FeatureSymbologyOptions.HasOverrides | FeatureSymbologyOptions.Color) === (opts & (FeatureSymbologyOptions.HasOverrides | FeatureSymbologyOptions.Color)));\n\n  builder.addVarying(\"v_feature_rgb\", VariableType.Vec3);\n  builder.addVarying(\"v_feature_alpha_flashed\", VariableType.Vec2);\n\n  const vert = builder.vert;\n  vert.set(VertexShaderComponent.ComputeFeatureOverrides, computeFeatureOverrides);\n\n  const frag = builder.frag;\n  addApplyFlash(frag);\n  frag.set(FragmentShaderComponent.ApplyFeatureColor, applyFeatureColor);\n}\n\n/** If we're running the hilite shader for a uniform feature, it follows that the feature must be hilited.\n * So the hilite shader simply needs to output '1' for every fragment.\n * @internal\n */\nexport function addUniformHiliter(builder: ProgramBuilder): void {\n  builder.frag.set(FragmentShaderComponent.ComputeBaseColor, `return vec4(1.0);`);\n  builder.frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n}\n\n/** For a uniform feature table, the feature ID output to pick buffers is equal to the batch ID.\n * The following symbology overrides are supported:\n *  - Visibility - implcitly, because if the feature is invisible its geometry will never be drawn.\n *  - Flash\n *  - Hilite\n * In future we may find a reason to support color and/or transparency.\n * This shader could be simplified, but want to share code with the non-uniform versions...hence uniforms/globals with \"v_\" prefix typically used for varyings...\n * @internal\n */\nexport function addUniformFeatureSymbology(builder: ProgramBuilder): void {\n  // addFeatureIndex()\n  builder.vert.addGlobal(\"g_featureIndex\", VariableType.Vec4, \"vec4(0.0)\", true);\n\n  // addFeatureSymbology()\n  builder.frag.addUniform(\"v_feature_alpha_flashed\", VariableType.Vec2, (prog) => {\n    prog.addGraphicUniform(\"v_feature_alpha_flashed\", (uniform, params) => {\n      // only the 'y' component is used. first bit = flashed, second = hilited.\n      let value = 0;\n      const ovr = params.target.currentOverrides;\n      if (undefined !== ovr) {\n        if (ovr.anyHilited) // any hilited implies all hilited.\n          value = 2;\n\n        if (ovr.isUniformFlashed)\n          value += 1;\n      }\n\n      uniform.setUniform2fv([0.0, value]);\n    });\n  });\n\n  addApplyFlash(builder.frag);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { FragmentShaderBuilder, VariableType, FragmentShaderComponent, SourceBuilder } from \"../ShaderBuilder\";\nimport { GLSLDecode } from \"./Decode\";\nimport { System } from \"../System\";\n\n/** @internal */\nexport function addWindowToTexCoords(frag: FragmentShaderBuilder) {\n  const windowCoordsToTexCoords = `\\nvec2 windowCoordsToTexCoords(vec2 wc) { return wc * u_invScreenSize; }\\n`;\n  frag.addFunction(windowCoordsToTexCoords);\n  frag.addUniform(\"u_invScreenSize\", VariableType.Vec2, (prog) => {\n    prog.addProgramUniform(\"u_invScreenSize\", (uniform, params) => {\n      const rect = params.target.viewRect;\n      const invScreenSize = [1.0 / rect.width, 1.0 / rect.height];\n      uniform.setUniform2fv(invScreenSize);\n    });\n  });\n}\n\n/** @internal */\nexport function addWhiteOnWhiteReversal(frag: FragmentShaderBuilder) {\n  frag.addUniform(\"u_reverseWhiteOnWhite\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_reverseWhiteOnWhite\", (uniform, params) => {\n      const bgColor = params.target.bgColor;\n      const doReversal = (bgColor.isWhite && params.geometry.wantWoWReversal(params.programParams)) ? 1.0 : 0.0;\n      uniform.setUniform1f(doReversal);\n    });\n  });\n  frag.set(FragmentShaderComponent.ReverseWhiteOnWhite, reverseWhiteOnWhite);\n}\n\n/** For techniques which by default use MRT, on devices which don't support MRT we fall back to\n * multi-pass rendering. The same shader is used each pass, with a uniform supplied indicating\n * which value to output to gl_FragColor. It's specified as an index - the same one that would be\n * used to index into gl_FragData[] in MRT context.\n * @internal\n */\nexport function addRenderTargetIndex(frag: FragmentShaderBuilder) {\n  frag.addUniform(\"u_renderTargetIndex\", VariableType.Int, (prog) => {\n    prog.addProgramUniform(\"u_renderTargetIndex\", (uniform, params) => {\n      uniform.setUniform1i(params.target.compositor.currentRenderTargetIndex);\n    });\n  });\n}\n\nconst reverseWhiteOnWhite = `\n  const vec3 white = vec3(1.0);\n  const vec3 epsilon = vec3(0.0001);\n  vec3 color = baseColor.rgb / max(0.0001, baseColor.a); // revert premultiplied alpha\n  vec3 delta = (color + epsilon) - white;\n  vec4 wowColor = vec4(baseColor.rgb * vec3(float(delta.x <= 0.0 || delta.y <= 0.0 || delta.z <= 0.0)), baseColor.a); // set to black if almost white\n  wowColor.rgb *= wowColor.a; // reapply premultiplied alpha\n  return mix(baseColor, wowColor, floor(u_reverseWhiteOnWhite + 0.5));\n`;\n\nconst computePickBufferOutputs = `\n  vec4 output0 = baseColor;\n\n  // Fix interpolation errors despite all vertices sending exact same v_feature_id...\n  ivec4 v_feature_id_i = ivec4(v_feature_id * 255.0 + 0.5);\n  vec4 output1 = vec4(v_feature_id_i) / 255.0;\n  float linearDepth = computeLinearDepth(v_eyeSpace.z);\n  vec4 output2 = vec4(u_renderOrder * 0.0625, encodeDepthRgb(linearDepth)); // near=1, far=0\n`;\n\nconst computeAltPickBufferOutputs = `\n  vec4 output0 = baseColor;\n  vec4 output1 = vec4(0.0);\n  vec4 output2 = vec4(0.0);\n`;\n\nconst assignPickBufferOutputsMRT = `\n  FragColor0 = output0;\n  FragColor1 = output1;\n  FragColor2 = output2;\n`;\n\nconst assignPickBufferOutputsMP = `\n  if (0 == u_renderTargetIndex)\n    FragColor = output0;\n  else if (1 == u_renderTargetIndex)\n    FragColor = output1;\n  else\n    FragColor = output2;\n`;\nconst reassignFeatureId = \"output1 = overrideFeatureId(output1);\";\n\n/** @internal */\nexport function addPickBufferOutputs(frag: FragmentShaderBuilder): void {\n  frag.addFunction(GLSLDecode.encodeDepthRgb);\n  frag.addFunction(GLSLFragment.computeLinearDepth);\n\n  const prelude = new SourceBuilder();\n  const overrideFeatureId = frag.get(FragmentShaderComponent.OverrideFeatureId);\n  if (undefined !== overrideFeatureId) {\n    frag.addFunction(\"vec4 overrideFeatureId(vec4 currentId)\", overrideFeatureId);\n    prelude.add(computePickBufferOutputs);\n    prelude.addline(reassignFeatureId);\n  } else\n    prelude.add(computePickBufferOutputs);\n\n  if (System.instance.capabilities.supportsMRTPickShaders) {\n    frag.addDrawBuffersExtension();\n    frag.set(FragmentShaderComponent.AssignFragData, prelude.source + assignPickBufferOutputsMRT);\n  } else {\n    addRenderTargetIndex(frag);\n    frag.set(FragmentShaderComponent.AssignFragData, prelude.source + assignPickBufferOutputsMP);\n  }\n}\n\n/** @internal */\nexport function addAltPickBufferOutputs(frag: FragmentShaderBuilder): void {\n  const prelude = new SourceBuilder();\n  prelude.add(computeAltPickBufferOutputs);\n\n  if (System.instance.capabilities.supportsMRTPickShaders) {\n    frag.addDrawBuffersExtension();\n    frag.set(FragmentShaderComponent.AssignFragData, prelude.source + assignPickBufferOutputsMRT);\n  } else {\n    addRenderTargetIndex(frag);\n    frag.set(FragmentShaderComponent.AssignFragData, prelude.source + assignPickBufferOutputsMP);\n  }\n}\n\n/** @internal */\nexport namespace GLSLFragment {\n  export const assignFragColor = \"FragColor = baseColor;\";\n\n  export const assignFragColorNoAlpha = \"FragColor = vec4(baseColor.rgb, 1.0);\";\n\n  export const revertPreMultipliedAlpha = `\nvec4 revertPreMultipliedAlpha(vec4 rgba) {\n  rgba.rgb /= max(0.0001, rgba.a);\n  return rgba;\n}\n`;\n\n  export const applyPreMultipliedAlpha = `\nvec4 applyPreMultipliedAlpha(vec4 rgba) {\n  rgba.rgb *= rgba.a;\n  return rgba;\n}\n`;\n\n  export const adjustPreMultipliedAlpha = `\nvec4 adjustPreMultipliedAlpha(vec4 rgba, float newAlpha) {\n  float oldAlpha = rgba.a;\n  rgba.rgb /= max(0.0001, oldAlpha);\n  rgba.rgb *= newAlpha;\n  rgba.a = newAlpha;\n  return rgba;\n}\n`;\n\n  export const computeLinearDepth = `\nfloat computeLinearDepth(float eyeSpaceZ) {\n  float eyeZ = -eyeSpaceZ;\n  float near = u_frustum.x, far = u_frustum.y;\n  float depthRange = far - near;\n  float linearDepth = (eyeZ - near) / depthRange;\n  return 1.0 - linearDepth;\n}\n`;\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module WebGL */\r\n\r\nimport { assert } from \"@bentley/bentleyjs-core\";\r\nimport { GL } from \"../GL\";\r\nimport { VertexShaderBuilder, VariableType } from \"../ShaderBuilder\";\r\nimport { addOvrFlagConstants } from \"./FeatureSymbology\";\r\nimport { GLSLCommon } from \"./Common\";\r\n\r\nconst extractInstanceBit = `\r\n  float extractInstanceBit(float flag) { return extractNthBit(a_instanceOverrides.r, flag); }\r\n`;\r\n\r\nconst computeInstancedModelMatrixRTC = `\r\n  g_modelMatrixRTC = mat4(\r\n    a_instanceMatrixRow0.x, a_instanceMatrixRow1.x, a_instanceMatrixRow2.x, 0.0,\r\n    a_instanceMatrixRow0.y, a_instanceMatrixRow1.y, a_instanceMatrixRow2.y, 0.0,\r\n    a_instanceMatrixRow0.z, a_instanceMatrixRow1.z, a_instanceMatrixRow2.z, 0.0,\r\n    a_instanceMatrixRow0.w, a_instanceMatrixRow1.w, a_instanceMatrixRow2.w, 1.0);\r\n`;\r\n\r\nfunction addInstanceMatrixRow(vert: VertexShaderBuilder, row: number) {\r\n  // 3 rows per instance; 4 floats per row; 4 bytes per float.\r\n  const floatsPerRow = 4;\r\n  const bytesPerVertex = floatsPerRow * 4;\r\n  const offset = row * bytesPerVertex;\r\n  const stride = 3 * bytesPerVertex;\r\n  const name = \"a_instanceMatrixRow\" + row;\r\n  vert.addAttribute(name, VariableType.Vec4, (prog) => {\r\n    prog.addAttribute(name, (attr, params) => {\r\n      const geom = params.geometry.asInstanced!;\r\n      assert(undefined !== geom);\r\n      attr.enableArray(geom.transforms, floatsPerRow, GL.DataType.Float, false, stride, offset, true);\r\n    });\r\n  });\r\n}\r\n\r\n/** @internal */\r\nexport function addInstancedModelMatrixRTC(vert: VertexShaderBuilder) {\r\n  assert(vert.usesInstancedGeometry);\r\n\r\n  addInstanceMatrixRow(vert, 0);\r\n  addInstanceMatrixRow(vert, 1);\r\n  addInstanceMatrixRow(vert, 2);\r\n\r\n  vert.addGlobal(\"g_modelMatrixRTC\", VariableType.Mat4);\r\n  vert.addInitializer(computeInstancedModelMatrixRTC);\r\n}\r\n\r\n/** @internal */\r\nexport function addInstanceOverrides(vert: VertexShaderBuilder): void {\r\n  if (undefined !== vert.find(\"a_instanceOverrides\"))\r\n    return;\r\n\r\n  addOvrFlagConstants(vert);\r\n\r\n  vert.addFunction(GLSLCommon.extractNthBit);\r\n  vert.addFunction(extractInstanceBit);\r\n\r\n  vert.addAttribute(\"a_instanceOverrides\", VariableType.Vec4, (prog) => {\r\n    prog.addAttribute(\"a_instanceOverrides\", (attr, params) => {\r\n      const geom = params.geometry.asInstanced!;\r\n      assert(undefined !== geom);\r\n\r\n      // NB: If none defined, attribute access returns constant values.\r\n      // This is *context* state. Apparently it defaults to (0, 0, 0, 1). Which is fine for us since r=0 means nothing overridden.\r\n      if (undefined !== geom.symbology)\r\n        attr.enableArray(geom.symbology, 4, GL.DataType.UnsignedByte, false, 8, 0, true);\r\n    });\r\n  });\r\n}\r\n\r\n/** @internal */\r\nexport function addInstanceColor(vert: VertexShaderBuilder): void {\r\n  addInstanceOverrides(vert);\r\n\r\n  vert.addAttribute(\"a_instanceRgba\", VariableType.Vec4, (prog) => {\r\n    prog.addAttribute(\"a_instanceRgba\", (attr, params) => {\r\n      const geom = params.geometry.asInstanced!;\r\n      if (undefined !== geom.symbology)\r\n        attr.enableArray(geom.symbology, 4, GL.DataType.UnsignedByte, false, 8, 4, true);\r\n    });\r\n  });\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport {\n  ProgramBuilder,\n  VariableType,\n  FragmentShaderComponent,\n} from \"../ShaderBuilder\";\nimport { addFrustum } from \"./Common\";\nimport { Material } from \"../Material\";\n\nconst computeSimpleLighting = `\nvoid computeSimpleLight (inout float diffuse, inout float specular, vec3 normal, vec3 toEye, vec3 lightDir, float lightIntensity, float specularExponent) {\n  diffuse += lightIntensity * max(dot(normal, lightDir), 0.0);\n  vec3 toReflectedLight = normalize(reflect(lightDir, normal));\n  float specularDot = max(dot(toReflectedLight, toEye), 0.0);\n  specular += lightIntensity * pow(specularDot, specularExponent);\n}\n`;\n\nconst applyLighting = `\n  if (isSurfaceBitSet(kSurfaceBit_ApplyLighting) && baseColor.a > 0.0) {\n    // Lighting algorithms written in terms of non-pre-multiplied alpha...\n    float alpha = baseColor.a;\n    baseColor.rgb /= alpha;\n\n    // negate normal if not front-facing\n    vec3 normal = normalize(v_n.xyz);\n    normal *= 2.0 * float(gl_FrontFacing) - 1.0;\n    vec3 toEye = mix(vec3(0.0, 0.0, -1.0), normalize(v_pos.xyz), float(kFrustumType_Perspective == u_frustum.z));\n\n    float useDefaults = extractSurfaceBit(kSurfaceBit_IgnoreMaterial);\n    const vec4 defaultSpecular = vec4(1.0, 1.0, 1.0, 43.2); // rgb, exponent\n    vec4 specular = mix(u_specular, defaultSpecular, useDefaults);\n    vec3 specularColor = specular.rgb;\n    float specularExp = specular.a;\n\n    const vec2 defaultWeights = vec2(.6, .4); // diffuse, specular\n    vec2 weights = mix(u_material.rg, defaultWeights, useDefaults);\n    float diffuseWeight = weights.r;\n    float specularWeight = weights.g;\n\n    vec3 litColor = vec3(0.0);\n\n    float diffuseIntensity = 0.0, specularIntensity = 0.0;\n\n    // Use a pair of lights that is something in-between portrait lighting & something more out-doorsy with a slightly more overhead main light.\n    // This will make more sense in a wider variety of scenes since this is the only lighting currently supported.\n    computeSimpleLight (diffuseIntensity, specularIntensity, normal, toEye, normalize(vec3(0.2, 0.5, 0.5)), 1.0, specularExp);\n    computeSimpleLight (diffuseIntensity, specularIntensity, normal, toEye, normalize(vec3(-0.3, 0.0, 0.3)), .30, specularExp);\n\n    const float directionalIntensity = 0.92;\n    const float ambientIntensity = 0.2;\n    litColor += directionalIntensity * diffuseWeight * diffuseIntensity * baseColor.rgb + specularIntensity * specularWeight * specularColor;\n    litColor.rgb += ambientIntensity * baseColor.rgb;\n\n    // Clamp while preserving hue.\n    float maxIntensity = max(litColor.r, max(litColor.g, litColor.b));\n\n    baseColor.rgb = litColor / max(1.0, maxIntensity);\n\n    // Restore pre-multiplied alpha...\n    baseColor.rgb *= alpha;\n  }\n\n  return baseColor;\n`;\n\n/** @internal */\nexport function addLighting(builder: ProgramBuilder) {\n  addFrustum(builder);\n\n  const frag = builder.frag;\n  frag.addUniform(\"u_material\", VariableType.Vec3, (shader) => {\n    shader.addGraphicUniform(\"u_material\", (uniform, params) => {\n      const material = params.target.currentViewFlags.materials ? params.geometry.material : undefined;\n      const weights = undefined !== material ? material.weights : Material.default.weights;\n      uniform.setUniform3fv(weights);\n    });\n  });\n\n  frag.addUniform(\"u_specular\", VariableType.Vec4, (shader) => {\n    shader.addGraphicUniform(\"u_specular\", (uniform, params) => {\n      let mat = params.target.currentViewFlags.materials ? params.geometry.material : undefined;\n      if (undefined === mat)\n        mat = Material.default;\n\n      uniform.setUniform4fv(mat.specular);\n    });\n  });\n\n  frag.addFunction(computeSimpleLighting);\n  frag.set(FragmentShaderComponent.ApplyLighting, applyLighting);\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module WebGL */\r\n\r\nimport { VertexShaderBuilder, VariableType } from \"../ShaderBuilder\";\r\n\r\nconst computeLUTCoords = `\r\nvec2 computeLUTCoords(float index, vec2 dimensions, vec2 center, float mult) {\r\n  float baseIndex = index*mult;\r\n\r\n  // Fix precision issues wherein mod(x,y) => y instead of 0 when x is multiple of y...\r\n  float epsilon = 0.5 / dimensions.x;\r\n  float yId = floor(baseIndex / dimensions.x + epsilon);\r\n  float xId = baseIndex - dimensions.x * yId; // replaces mod()...\r\n\r\n  return center + vec2(xId/dimensions.x, yId/dimensions.y);\r\n}\r\n`;\r\n\r\nconst computeCoordsTemplate = `\r\nvec2 compute_{LUTNAME}_coords(float index) {\r\n  return computeLUTCoords(index, u_{LUTNAME}Params.xy, g_{LUTNAME}_center, {MULT});\r\n}\r\n`;\r\n\r\nconst initializerTemplate = `\r\n  {LUTSTEPX} = 1.0 / {LUTPARAMS}.x;\r\n  float {LUTSTEPY} = 1.0 / {LUTPARAMS}.y;\r\n  {LUTCENTER} = vec2(0.5*{LUTSTEPX}, 0.5*{LUTSTEPY});\r\n`;\r\n\r\n/** @internal */\r\nexport function addLookupTable(sb: VertexShaderBuilder, lutName: string, mult: string = \"1.0\") {\r\n  sb.addFunction(computeLUTCoords);\r\n\r\n  const lutStepX = \"g_\" + lutName + \"_stepX\";\r\n  const lutStepY = lutName + \"_stepY\";\r\n  const lutCenter = \"g_\" + lutName + \"_center\";\r\n  const lutParams = \"u_\" + lutName + \"Params\";\r\n\r\n  sb.addGlobal(lutStepX, VariableType.Float);\r\n  sb.addGlobal(lutCenter, VariableType.Vec2);\r\n\r\n  let initializerSpecific = initializerTemplate;\r\n  initializerSpecific = initializerSpecific.replace(/{LUTSTEPX}/g, lutStepX);\r\n  initializerSpecific = initializerSpecific.replace(/{LUTSTEPY}/g, lutStepY);\r\n  initializerSpecific = initializerSpecific.replace(/{LUTCENTER}/g, lutCenter);\r\n  initializerSpecific = initializerSpecific.replace(/{LUTPARAMS}/g, lutParams);\r\n  sb.addInitializer(initializerSpecific);\r\n\r\n  let computeCoordsSpecific = computeCoordsTemplate;\r\n  computeCoordsSpecific = computeCoordsSpecific.replace(/{LUTNAME}/g, lutName);\r\n  computeCoordsSpecific = computeCoordsSpecific.replace(/{MULT}/g, mult);\r\n  sb.addFunction(computeCoordsSpecific);\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { FragmentShaderBuilder, FragmentShaderComponent, VariableType } from \"../ShaderBuilder\";\nimport { MutableFloatRgba } from \"../FloatRGBA\";\nimport { ColorDef } from \"@bentley/imodeljs-common\";\n\n// The alpha component of the mono color is 1.0 if lit, 0.0 if unlit.\n// Unlit stuff (edges, polylines) uses the mono color directly in order for white-on-white reversal to work correctly.\nconst applyMonochromeColor = `\n  // Compute lit monochrome color\n  vec3 litRgb = baseColor.rgb;\n  litRgb /= max(0.0001, baseColor.a); // un-premultiply alpha\n  litRgb = vec3(dot(litRgb, vec3(.222, .707, .071)));\n  litRgb *= u_monoRgb.rgb;\n\n  // Select lit or unlit based on u_monoColor.a\n  vec4 monoColor = vec4(mix(u_monoRgb.rgb, litRgb, u_monoRgb.a), baseColor.a);\n  monoColor.rgb *= monoColor.a;\n\n  // Select monochrome or element color based on shader flag\n  return mix(baseColor, monoColor, extractShaderBit(kShaderBit_Monochrome));\n`;\n\nconst scratchMonoColor: MutableFloatRgba = MutableFloatRgba.fromColorDef(ColorDef.white);\n\n/** @internal */\nexport function addMonochrome(frag: FragmentShaderBuilder): void {\n  frag.set(FragmentShaderComponent.ApplyMonochrome, applyMonochromeColor);\n  frag.addUniform(\"u_monoRgb\", VariableType.Vec4, (prog) => {\n    prog.addGraphicUniform(\"u_monoRgb\", (uniform, params) => {\n      const color = params.target.monoColor;\n      scratchMonoColor.setRgbaValues(color.red, color.green, color.blue, params.geometry.isLitSurface ? 1.0 : 0.0);\n      scratchMonoColor.bind(uniform);\n    });\n  });\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\nimport { VariableType, ProgramBuilder, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { addUInt32s } from \"./Common\";\nimport { addModelMatrix } from \"./Vertex\";\n\nconst applyPlanarClassificationColor = `\n  vec4 colorTexel = TEXTURE(s_pClassSampler, vec2(v_pClassPos.x, v_pClassPos.y / 2.0));\n  if (colorTexel.a < .5) {\n    if (s_pClassColorParams.y == 0.0)\n      return vec4(0);                          // Unclassifed, Off.\n   else if (s_pClassColorParams.y == 1.0)\n      return baseColor;                        // Unclassified, On.\n    else\n      return baseColor * .6;                   // Unclassified, Dimmed.\n   } else {\n     if (s_pClassColorParams.x == 0.0)\n       return vec4(0);                        // Classified, off.\n       else if (s_pClassColorParams.x == 1.0)\n       return baseColor;\n      else if (s_pClassColorParams.x == 2.0)\n        return baseColor * .6;                // Classified, dimmed.\n      else if (s_pClassColorParams.x == 3.0)\n        return baseColor * vec4(.8, .8, 1.0, 1.0);  // Classified, hilite.  TBD - make color configurable.\n      else\n        return baseColor * colorTexel;\n    // TBD -- mode 1.  Return baseColor unless flash or hilite\n   }\n`;\n\nconst overrideFeatureId = `\n  vec4 featureTexel = TEXTURE(s_pClassSampler, vec2(v_pClassPos.x, (1.0 + v_pClassPos.y) / 2.0));\n  return (featureTexel == vec4(0)) ? currentId : addUInt32s(u_batchBase, featureTexel * 255.0) / 255.0;\n  `;\n\nconst computeClassifiedSurfaceHiliteColor = `\n  vec4 hiliteTexel = TEXTURE(s_pClassHiliteSampler, v_pClassPos.xy);\n  if (hiliteTexel.a > 0.5 && isSurfaceBitSet(kSurfaceBit_HasTexture))\n    return vec4(TEXTURE(s_texture, v_texCoord).a > 0.15 ? 1.0 : 0.0);\n  else\n  return vec4(hiliteTexel.a > 0.5 ? 1.0 : 0.0);\n`;\n\nconst computeClassifiedSurfaceHiliteColorNoTexture = `\n  vec4 hiliteTexel = TEXTURE(s_pClassHiliteSampler, v_pClassPos.xy);\n  return vec4(hiliteTexel.a > 0.5 ? 1.0 : 0.0);\n`;\n\nconst computeClassifierPos = \"vec4 proj = u_pClassProj * MAT_MODEL * rawPosition; v_pClassPos = proj.xyz/proj.w;\";\nconst scratchBytes = new Uint8Array(4);\nconst scratchBatchBaseId = new Uint32Array(scratchBytes.buffer);\nconst scratchBatchBaseComponents = [0, 0, 0, 0];\nconst scratchColorParams = new Float32Array(2);      // Unclassified scale, classified base scale, classified classifier scale.\n\nfunction addPlanarClassifierCommon(builder: ProgramBuilder) {\n  const vert = builder.vert;\n  vert.addUniform(\"u_pClassProj\", VariableType.Mat4, (prog) => {\n    prog.addGraphicUniform(\"u_pClassProj\", (uniform, params) => {\n      const classifier = params.target.planarClassifiers.classifier!;\n      assert(undefined !== classifier);\n      uniform.setMatrix4(classifier.projectionMatrix);\n    });\n  });\n\n  addModelMatrix(vert);\n  builder.addInlineComputedVarying(\"v_pClassPos\", VariableType.Vec3, computeClassifierPos);\n}\n\n/** @internal */\nexport function addColorPlanarClassifier(builder: ProgramBuilder) {\n  addPlanarClassifierCommon(builder);\n  const frag = builder.frag;\n  const vert = builder.vert;\n\n  frag.addUniform(\"s_pClassSampler\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"s_pClassSampler\", (uniform, params) => {\n      const classifier = params.target.planarClassifiers.classifier!;\n      assert(undefined !== classifier && undefined !== classifier.combinedTexture);\n      classifier.combinedTexture!.texture.bindSampler(uniform, TextureUnit.PlanarClassification);\n    });\n  });\n  frag.addUniform(\"s_pClassColorParams\", VariableType.Vec2, (prog) => {\n    prog.addGraphicUniform(\"s_pClassColorParams\", (uniform, params) => {\n      const classifier = params.target.planarClassifiers.classifier!;\n      assert(undefined !== classifier);\n      scratchColorParams[0] = classifier.insideDisplay;\n      scratchColorParams[1] = classifier.outsideDisplay;\n      uniform.setUniform2fv(scratchColorParams);\n    });\n  });\n\n  vert.addUniform(\"u_pClassProj\", VariableType.Mat4, (prog) => {\n    prog.addGraphicUniform(\"u_pClassProj\", (uniform, params) => {\n      const classifier = params.target.planarClassifiers.classifier!;\n      assert(undefined !== classifier);\n      uniform.setMatrix4(classifier.projectionMatrix);\n    });\n  });\n\n  addModelMatrix(vert);\n  frag.set(FragmentShaderComponent.ApplyPlanarClassifier, applyPlanarClassificationColor);\n}\n\n/** @internal */\nexport function addFeaturePlanarClassifier(builder: ProgramBuilder) {\n  const frag = builder.frag;\n  frag.addUniform(\"u_batchBase\", VariableType.Vec4, (prog) => {     // TBD.  Instancing.\n    prog.addGraphicUniform(\"u_batchBase\", (uniform, params) => {\n      const classifier = params.target.planarClassifiers.classifier!;\n      assert(undefined !== classifier);\n      scratchBatchBaseId[0] = classifier.baseBatchId;\n      scratchBatchBaseComponents[0] = scratchBytes[0];\n      scratchBatchBaseComponents[1] = scratchBytes[1];\n      scratchBatchBaseComponents[2] = scratchBytes[2];\n      scratchBatchBaseComponents[3] = scratchBytes[3];\n      uniform.setUniform4fv(scratchBatchBaseComponents);\n    });\n  });\n  frag.set(FragmentShaderComponent.OverrideFeatureId, overrideFeatureId);\n  frag.addFunction(addUInt32s);\n}\n\n/** @internal */\nexport function addHilitePlanarClassifier(builder: ProgramBuilder, supportTextures = true) {\n  const frag = builder.frag;\n  frag.addUniform(\"s_pClassHiliteSampler\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"s_pClassHiliteSampler\", (uniform, params) => {\n      const classifier = params.target.planarClassifiers.classifier!;\n      assert(undefined !== classifier && undefined !== classifier.hiliteTexture);\n      classifier.hiliteTexture!.texture.bindSampler(uniform, TextureUnit.PlanarClassificationHilite);\n    });\n  });\n\n  frag.set(FragmentShaderComponent.ComputeBaseColor, supportTextures ? computeClassifiedSurfaceHiliteColor : computeClassifiedSurfaceHiliteColorNoTexture);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { addModelViewProjectionMatrix } from \"./Vertex\";\nimport { addUniformHiliter } from \"./FeatureSymbology\";\nimport { ProgramBuilder, VertexShaderComponent, FragmentShaderComponent, VariableType } from \"../ShaderBuilder\";\nimport { PointCloudGeometry } from \"../PointCloud\";\nimport { GL } from \"../GL\";\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { addColorPlanarClassifier, addHilitePlanarClassifier, addFeaturePlanarClassifier } from \"./PlanarClassification\";\nimport { IsClassified, FeatureMode } from \"../TechniqueFlags\";\n\nconst computePosition = \"gl_PointSize = 1.0; return MAT_MVP * rawPos;\";\nconst computeColor = \"return vec4(a_color, 1.0);\";\nconst computeBaseColor = \"return v_color;\";\n\nfunction createBuilder(): ProgramBuilder {\n  const builder = new ProgramBuilder();\n  const vert = builder.vert;\n  vert.set(VertexShaderComponent.ComputePosition, computePosition);\n  addModelViewProjectionMatrix(vert);\n\n  return builder;\n}\n\n/** @internal */\nexport function createPointCloudBuilder(classified: IsClassified, featureMode: FeatureMode): ProgramBuilder {\n  const builder = createBuilder();\n\n  builder.vert.addAttribute(\"a_color\", VariableType.Vec3, (shaderProg) => {\n    shaderProg.addAttribute(\"a_color\", (attr, params) => {\n      const pointCloudGeom = params.geometry as PointCloudGeometry;\n      assert(pointCloudGeom !== undefined);\n      if (undefined !== pointCloudGeom && undefined !== pointCloudGeom.colors)\n        attr.enableArray(pointCloudGeom.colors, 3, GL.DataType.UnsignedByte, true, 0, 0);\n    });\n  });\n\n  builder.addFunctionComputedVarying(\"v_color\", VariableType.Vec4, \"computeNonUniformColor\", computeColor);\n  builder.frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\n  if (classified) {\n    addColorPlanarClassifier(builder);\n    if (FeatureMode.None !== featureMode)\n      addFeaturePlanarClassifier(builder);\n  }\n\n  return builder;\n}\n\n/** @internal */\nexport function createPointCloudHiliter(classified: IsClassified): ProgramBuilder {\n  const builder = createBuilder();\n  addUniformHiliter(builder);\n  if (classified) {\n    addColorPlanarClassifier(builder);\n    addHilitePlanarClassifier(builder, false);\n  }\n\n  return builder;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { addHiliter } from \"./FeatureSymbology\";\nimport { addModelViewProjectionMatrix, addLineWeight } from \"./Vertex\";\nimport { addShaderFlags } from \"./Common\";\nimport { addColor } from \"./Color\";\nimport { addWhiteOnWhiteReversal } from \"./Fragment\";\nimport { ShaderBuilderFlags, ProgramBuilder, VertexShaderComponent, VariableType, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { IsInstanced } from \"../TechniqueFlags\";\n\nconst computePosition = `\n  float lineWeight = computeLineWeight();\n  lineWeight += 0.5 * float(lineWeight > 4.0); // fudge factor for rounding fat points...\n  gl_PointSize = lineWeight;\n  return MAT_MVP * rawPos;\n`;\n\n// gl_PointSize specifies coordinates of this fragment within the point in range [0,1].\n// This should be the most precise of the many approaches we've tried, but it still yields some asymmetry...\n// Discarding if it meets radius precisely seems to reduce that slightly...\n// ###TODO try point sprites?\nconst roundCorners = `\n  const vec2 center = vec2(0.5, 0.5);\n  vec2 vt = gl_PointCoord - center;\n  return dot(vt, vt) * v_roundCorners >= 0.25; // meets or exceeds radius of circle\n`;\n\nconst computeRoundCorners = \"  v_roundCorners = gl_PointSize > 4.0 ? 1.0 : 0.0;\";\n\nfunction createBase(instanced: IsInstanced): ProgramBuilder {\n  const builder = new ProgramBuilder(instanced ? ShaderBuilderFlags.InstancedVertexTable : ShaderBuilderFlags.VertexTable);\n  const vert = builder.vert;\n  vert.set(VertexShaderComponent.ComputePosition, computePosition);\n  addModelViewProjectionMatrix(vert);\n\n  addLineWeight(vert);\n  builder.addInlineComputedVarying(\"v_roundCorners\", VariableType.Float, computeRoundCorners);\n  builder.frag.set(FragmentShaderComponent.CheckForEarlyDiscard, roundCorners);\n\n  return builder;\n}\n\n/** @internal */\nexport function createPointStringHiliter(instanced: IsInstanced): ProgramBuilder {\n  const builder = createBase(instanced);\n  addHiliter(builder, true);\n  return builder;\n}\n\n/** @internal */\nexport function createPointStringBuilder(instanced: IsInstanced): ProgramBuilder {\n  const builder = createBase(instanced);\n  addShaderFlags(builder);\n  addColor(builder);\n  addWhiteOnWhiteReversal(builder.frag);\n  return builder;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport {\n  ProgramBuilder,\n  ShaderBuilderFlags,\n  VariableType,\n  FragmentShaderComponent,\n  VertexShaderComponent,\n  FragmentShaderBuilder,\n} from \"../ShaderBuilder\";\nimport {\n  addModelViewMatrix,\n  addProjectionMatrix,\n  addLineWeight,\n  addLineCode as addLineCodeUniform,\n} from \"./Vertex\";\nimport { addFrustum, addShaderFlags } from \"./Common\";\nimport { addViewport, addModelToWindowCoordinates } from \"./Viewport\";\nimport { GL } from \"../GL\";\nimport { GLSLDecode } from \"./Decode\";\nimport { addColor } from \"./Color\";\nimport { addWhiteOnWhiteReversal } from \"./Fragment\";\nimport { System } from \"../System\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { addHiliter } from \"./FeatureSymbology\";\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { IsInstanced } from \"../TechniqueFlags\";\n\nconst checkForDiscard = \"return discardByLineCode;\";\n\nconst applyLineCode = `\n  if (v_texc.x >= 0.0) { // v_texc = (-1,-1) for solid lines - don't bother with any of this\n    vec4 texColor = TEXTURE(u_lineCodeTexture, v_texc);\n    discardByLineCode = (0.0 == texColor.r);\n  }\n\n  if (v_lnInfo.w > 0.5) { // line needs pixel trimming\n    // calculate pixel distance from pixel center to expected line center, opposite dir from major\n    vec2 dxy = gl_FragCoord.xy - v_lnInfo.xy;\n    if (v_lnInfo.w < 1.5)  // not x-major\n      dxy = dxy.yx;\n\n    float dist = v_lnInfo.z * dxy.x - dxy.y;\n    float distA = abs(dist);\n    if (distA > 0.5 || (distA == 0.5 && dist < 0.0))\n      discardByLineCode = true;  // borrow this flag to force discard\n  }\n\n  return baseColor;\n`;\n\nconst computeTextureCoord = `\nvec2 computeLineCodeTextureCoords(vec2 windowDir, vec4 projPos, float adjust) {\n  vec2 texc;\n  float lineCode = computeLineCode();\n  if (0.0 == lineCode) {\n    // Solid line - tell frag shader not to bother.\n    texc = vec2(-1.0, -1.0);\n  } else {\n    const float imagesPerPixel = 1.0/32.0;\n    const float textureCoordinateBase = 8192.0; // Temp workardound for clipping problem in perspective views (negative values don't seem to interpolate correctly).\n\n    if (abs(windowDir.x) > abs(windowDir.y))\n      texc.x = textureCoordinateBase + imagesPerPixel * (projPos.x + adjust * windowDir.x);\n    else\n      texc.x = textureCoordinateBase + imagesPerPixel * (projPos.y + adjust * windowDir.y);\n\n    const float numLineCodes = 16.0; // NB: Actually only 10, but texture is 16px tall because it needs to be a power of 2.\n    const float rowsPerCode = 1.0;\n    const float numRows = numLineCodes*rowsPerCode;\n    const float centerY = 0.5/numRows;\n    const float stepY = rowsPerCode/numRows;\n    texc.y = stepY * lineCode + centerY;\n  }\n\n  return texc;\n}\n`;\n\n/** @internal */\nexport const adjustWidth = `\nvoid adjustWidth(inout float width, vec2 d2, vec2 org) {\n  // calculate slope based width adjustment for non-AA lines, widths 1 to 4\n  vec2 d2A = abs(d2);\n  const float s_myFltEpsilon = 0.0001;  // limit test resolution to 4 digits in case 24 bit (s16e7) is used in hardware\n  if (d2A.y > s_myFltEpsilon && width < 4.5) {\n    float len = length(d2A);\n    float tan = d2A.x / d2A.y;\n\n    if (width < 1.5) { // width 1\n      if (tan <= 1.0)\n        width = d2A.y / len;\n      else\n        width = d2A.x / len;\n      // width 1 requires additional adjustment plus trimming in frag shader using v_lnInfo\n      width *= 1.01;\n      v_lnInfo.xy = org;\n      v_lnInfo.w = 1.0; // set flag to do trimming\n      // set slope in v_lnInfo.z\n      if (d2A.x - d2A.y > s_myFltEpsilon) {\n        v_lnInfo.z = d2.y / d2.x;\n        v_lnInfo.w += 2.0; // add in x-major flag\n      } else\n        v_lnInfo.z = d2.x / d2.y;\n\n    } else if (width < 2.5) { // width 2\n      if (tan <= 0.5)\n        width = 2.0 * d2A.y / len;\n      else\n        width = (d2A.y + 2.0 * d2A.x) / len;\n\n    } else if (width < 3.5) { // width 3\n        if (tan <= 1.0)\n            width = (3.0 * d2A.y + d2A.x) / len;\n        else\n            width = (d2A.y + 3.0 * d2A.x) / len;\n\n    } else { // if (width < 4.5) // width 4\n      if (tan <= 0.5)\n        width = (4.0 * d2A.y + d2A.x) / len;\n      else if (tan <= 2.0)\n        width = (3.0 * d2A.y + 3.0 * d2A.x) / len;\n      else\n        width = (d2A.y + 4.0 * d2A.x) / len;\n    }\n  }\n}\n`;\n\n/** @internal */\nexport function addLineCodeTexture(frag: FragmentShaderBuilder) {\n  frag.addUniform(\"u_lineCodeTexture\", VariableType.Sampler2D, (prog) => {\n    prog.addProgramUniform(\"u_lineCodeTexture\", (uniform) => {\n      const lct = System.instance.lineCodeTexture;\n      assert(undefined !== lct);\n      if (undefined !== lct)\n        lct.bindSampler(uniform, TextureUnit.LineCode);\n    });\n  });\n}\n\n/** @internal */\nexport function addLineCode(prog: ProgramBuilder, args: string) {\n  const vert = prog.vert;\n  const frag = prog.frag;\n\n  addLineCodeUniform(vert);\n\n  const funcCall: string = \"computeLineCodeTextureCoords(\" + args + \")\";\n\n  prog.addFunctionComputedVaryingWithArgs(\"v_texc\", VariableType.Vec2, funcCall, computeTextureCoord);\n\n  addFrustum(prog);\n  addLineCodeTexture(prog.frag);\n\n  frag.set(FragmentShaderComponent.FinalizeBaseColor, applyLineCode);\n  frag.set(FragmentShaderComponent.CheckForDiscard, checkForDiscard);\n  frag.addGlobal(\"discardByLineCode\", VariableType.Boolean, \"false\");\n}\n\nfunction polylineAddLineCode(prog: ProgramBuilder) {\n  addLineCode(prog, lineCodeArgs);\n  addModelViewMatrix(prog.vert);\n}\n\nfunction addCommon(prog: ProgramBuilder) {\n  const vert = prog.vert;\n  addModelToWindowCoordinates(vert); // adds u_mvp, u_viewportTransformation\n  addProjectionMatrix(vert);\n  addModelViewMatrix(vert);\n  addViewport(vert);\n\n  vert.addGlobal(\"g_windowPos\", VariableType.Vec4);\n  vert.addGlobal(\"g_prevPos\", VariableType.Vec4);\n  vert.addGlobal(\"g_nextPos\", VariableType.Vec4);\n  vert.addGlobal(\"g_windowDir\", VariableType.Vec2);\n  vert.addInitializer(decodeAdjacentPositions);\n\n  vert.addAttribute(\"a_prevIndex\", VariableType.Vec3, (shaderProg) => {\n    shaderProg.addAttribute(\"a_prevIndex\", (attr, params) => {\n      const buffs = params.geometry.polylineBuffers;\n      if (undefined !== buffs)\n        attr.enableArray(buffs.prevIndices, 3, GL.DataType.UnsignedByte, false, 0, 0);\n    });\n  });\n\n  vert.addAttribute(\"a_nextIndex\", VariableType.Vec3, (shaderProg) => {\n    shaderProg.addAttribute(\"a_nextIndex\", (attr, params) => {\n      const buffs = params.geometry.polylineBuffers;\n      if (undefined !== buffs)\n        attr.enableArray(buffs.nextIndicesAndParams, 3, GL.DataType.UnsignedByte, false, 4, 0);\n    });\n  });\n\n  vert.addFunction(GLSLDecode.unquantize2d);\n\n  vert.addAttribute(\"a_param\", VariableType.Float, (shaderProg) => {\n    shaderProg.addAttribute(\"a_param\", (attr, params) => {\n      const buffs = params.geometry.polylineBuffers;\n      if (undefined !== buffs)\n        attr.enableArray(buffs.nextIndicesAndParams, 1, GL.DataType.UnsignedByte, false, 4, 3);\n    });\n  });\n\n  addLineWeight(vert);\n\n  vert.addGlobal(\"miterAdjust\", VariableType.Float, \"0.0\");\n  vert.set(VertexShaderComponent.ComputePosition, computePosition);\n  prog.addVarying(\"v_lnInfo\", VariableType.Vec4);\n  vert.addFunction(adjustWidth);\n  vert.addFunction(decodePosition);\n}\n\nconst decodePosition = `\nvec4 decodePosition(vec3 baseIndex) {\n  float index = decodeUInt32(baseIndex);\n  vec2 tc = compute_vert_coords(index);\n  vec4 e0 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\n  tc.x += g_vert_stepX;\n  vec4 e1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\n  vec3 qpos = vec3(decodeUInt16(e0.xy), decodeUInt16(e0.zw), decodeUInt16(e1.xy));\n  return unquantizePosition(qpos, u_qOrigin, u_qScale);\n}`;\n\nconst decodeAdjacentPositions = `\n  g_prevPos = decodePosition(a_prevIndex);\n  g_nextPos = decodePosition(a_nextIndex);\n`;\n\nconst computePosition = `\n  const float kNone = 0.0,\n              kSquare = 1.0*3.0,\n              kMiter = 2.0*3.0,\n              kMiterInsideOnly = 3.0*3.0,\n              kJointBase = 4.0*3.0,\n              kNegatePerp = 8.0*3.0,\n              kNegateAlong = 16.0*3.0,\n              kNoneAdjWt = 32.0*3.0;\n\n  v_lnInfo = vec4(0.0, 0.0, 0.0, 0.0);  // init and set flag to false\n\n  vec4 pos = MAT_MVP * rawPos;\n\n  vec4 next = g_nextPos;\n  g_windowPos = modelToWindowCoordinates(rawPos, next);\n\n  if (g_windowPos.w == 0.0)\n    return g_windowPos;\n\n  float param = a_param;\n  float weight = computeLineWeight();\n  float scale = 1.0, directionScale = 1.0;\n\n  if (param >= kNoneAdjWt)\n    param -= kNoneAdjWt;\n\n  if (param >= kNegateAlong) {\n    directionScale = -directionScale;\n    param -= kNegateAlong;\n  }\n\n  if (param >= kNegatePerp) {\n    scale = -1.0;\n    param -= kNegatePerp;\n  }\n\n  vec4 projNext = modelToWindowCoordinates(next, rawPos);\n  g_windowDir = projNext.xy - g_windowPos.xy;\n\n  if (param < kJointBase) {\n    vec2 dir = (directionScale > 0.0) ? g_windowDir : -g_windowDir;\n    vec2 pos = (directionScale > 0.0) ? g_windowPos.xy : projNext.xy;\n    adjustWidth(weight, dir, pos);\n  }\n\n  if (kNone != param) {\n    vec2 delta = vec2(0.0);\n    vec4 prev   = g_prevPos;\n    vec4 projPrev = modelToWindowCoordinates(prev, rawPos);\n    vec2 prevDir   = g_windowPos.xy - projPrev.xy;\n    float thisLength = sqrt(g_windowDir.x * g_windowDir.x + g_windowDir.y * g_windowDir.y);\n    const float s_minNormalizeLength = 1.0E-5;  // avoid normalizing zero length vectors.\n    float dist = weight / 2.0;\n\n    if (thisLength > s_minNormalizeLength) {\n      g_windowDir /= thisLength;\n\n      float prevLength = sqrt(prevDir.x * prevDir.x + prevDir.y * prevDir.y);\n\n      if (prevLength > s_minNormalizeLength) {\n        prevDir /= prevLength;\n        const float     s_minParallelDot= -.9999, s_maxParallelDot = .9999;\n        float           prevNextDot  = dot(prevDir, g_windowDir);\n\n        if (prevNextDot < s_minParallelDot || prevNextDot > s_maxParallelDot)    // No miter if parallel or antiparallel.\n          param = kSquare;\n      } else\n        param = kSquare;\n    } else {\n      g_windowDir = -normalize(prevDir);\n      param = kSquare;\n    }\n\n    vec2 perp = scale * vec2(-g_windowDir.y, g_windowDir.x);\n\n    if (param == kSquare) {\n      delta = perp;\n    } else {\n      vec2 bisector = normalize(prevDir - g_windowDir);\n      float dotP = dot (bisector, perp);\n\n      if (dotP != 0.0) { // Should never occur - but avoid divide by zero.\n        const float maxMiter = 3.0;\n        float miterDistance = 1.0/dotP;\n\n        if (param == kMiter) { // Straight miter.\n          delta = (abs(miterDistance) > maxMiter) ? perp : bisector * miterDistance;\n\n        } else if (param == kMiterInsideOnly) { // Miter at inside, square at outside (to make room for joint).\n          delta = (dotP  > 0.0 || abs(miterDistance) > maxMiter) ? perp : bisector * miterDistance;\n\n        } else {\n          const float jointTriangleCount = 3.0;\n          float ratio = (param - kJointBase) / jointTriangleCount; // 3 triangles per half-joint as defined in Graphics.cpp\n          delta = normalize((1.0 - ratio) * bisector + (dotP < 0.0 ? -ratio : ratio) * perp); // Miter/Straight combination.\n        }\n      }\n    }\n\n    miterAdjust = dot(g_windowDir, delta) * dist; // Not actually used for hilite shader but meh.\n    pos.x += dist * delta.x * 2.0 * pos.w / u_viewport.z;\n    pos.y += dist * delta.y * 2.0 * pos.w / u_viewport.w;\n  }\n\n  return pos;\n`;\n\nconst lineCodeArgs = \"g_windowDir, g_windowPos, miterAdjust\";\n\n/** @internal */\nexport function createPolylineBuilder(instanced: IsInstanced): ProgramBuilder {\n  const builder = new ProgramBuilder(instanced ? ShaderBuilderFlags.InstancedVertexTable : ShaderBuilderFlags.VertexTable);\n  addShaderFlags(builder);\n\n  addCommon(builder);\n\n  polylineAddLineCode(builder);\n\n  addColor(builder);\n  addWhiteOnWhiteReversal(builder.frag);\n\n  return builder;\n}\n\n/** @internal */\nexport function createPolylineHiliter(instanced: IsInstanced): ProgramBuilder {\n  const builder = new ProgramBuilder(instanced ? ShaderBuilderFlags.InstancedVertexTable : ShaderBuilderFlags.VertexTable);\n  addCommon(builder);\n  addFrustum(builder);\n  addHiliter(builder);\n  return builder;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ShaderBuilder, VariableType } from \"../ShaderBuilder\";\nimport { RenderPass } from \"../RenderFlags\";\n\n/**\n * Adds a uniform holding the current render pass and a set of kRenderPass_* constants\n * uniform float u_renderPass\n * @internal\n */\nexport function addRenderPass(builder: ShaderBuilder) {\n  builder.addUniform(\"u_renderPass\", VariableType.Float, (prog) => {\n    prog.addProgramUniform(\"u_renderPass\", (uniform, params) => {\n      let renderPass = params.renderPass;\n      if (RenderPass.HiddenEdge === renderPass) {\n        renderPass = RenderPass.OpaqueGeneral; // no distinction from shader POV...\n      }\n\n      uniform.setUniform1f(renderPass);\n    });\n  });\n\n  builder.addGlobal(\"kRenderPass_Background\", VariableType.Float, \"0.0\", true);\n  builder.addGlobal(\"kRenderPass_OpaqueLinear\", VariableType.Float, \"1.0\", true);\n  builder.addGlobal(\"kRenderPass_OpaquePlanar\", VariableType.Float, \"2.0\", true);\n  builder.addGlobal(\"kRenderPass_OpaqueGeneral\", VariableType.Float, \"3.0\", true);\n  builder.addGlobal(\"kRenderPass_Classification\", VariableType.Float, \"4.0\", true);\n  builder.addGlobal(\"kRenderPass_Translucent\", VariableType.Float, \"5.0\", true);\n  builder.addGlobal(\"kRenderPass_HiddenEdge\", VariableType.Float, \"6.0\", true);\n  builder.addGlobal(\"kRenderPass_Hilite\", VariableType.Float, \"7.0\", true);\n  builder.addGlobal(\"kRenderPass_WorldOverlay\", VariableType.Float, \"8.0\", true);\n  builder.addGlobal(\"kRenderPass_ViewOverlay\", VariableType.Float, \"9.0\", true);\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module WebGL */\r\n\r\nimport { FragmentShaderComponent, ProgramBuilder, VertexShaderComponent, VariableType } from \"../ShaderBuilder\";\r\nimport { ShaderProgram } from \"../ShaderProgram\";\r\nimport { TextureUnit } from \"../RenderFlags\";\r\nimport { Texture } from \"../Texture\";\r\nimport { Matrix3 } from \"../Matrix\";\r\nimport { SkyBoxQuadsGeometry } from \"../CachedGeometry\";\r\n\r\nconst computeBaseColor = `return vec4(0, 0, 0, 0);`;\r\nconst assignFragData = `FragColor = TEXTURE_CUBE(s_cube, v_texDir);`;\r\nconst computePosition = `vec3 pos = u_rot * vec3(rawPos.x, rawPos.z, -rawPos.y); return pos.xyzz;`; // rawPos swizzling accounts for iModel rotation.\r\nconst computeTexDir = `v_texDir = rawPosition.xyz;`;\r\n\r\n/** @internal */\r\nexport function createSkyBoxProgram(context: WebGLRenderingContext): ShaderProgram {\r\n  const prog = new ProgramBuilder();\r\n\r\n  prog.frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\r\n  prog.frag.set(FragmentShaderComponent.AssignFragData, assignFragData);\r\n  prog.vert.set(VertexShaderComponent.ComputePosition, computePosition);\r\n  prog.vert.addUniform(\"u_rot\", VariableType.Mat3, (prg) => {\r\n    prg.addGraphicUniform(\"u_rot\", (uniform, params) => {\r\n      const rot = params.viewMatrix.getRotation();\r\n      const mat3 = new Matrix3();\r\n      mat3.m00 = -rot.m00; mat3.m01 = -rot.m01; mat3.m02 = -rot.m02;\r\n      mat3.m10 = -rot.m10; mat3.m11 = -rot.m11; mat3.m12 = -rot.m12;\r\n      mat3.m20 = rot.m20; mat3.m21 = rot.m21; mat3.m22 = rot.m22;\r\n      uniform.setMatrix3(mat3);\r\n    });\r\n  });\r\n\r\n  prog.frag.addUniform(\"s_cube\", VariableType.SamplerCube, (prg) => {\r\n    prg.addGraphicUniform(\"s_cube\", (uniform, params) => {\r\n      const geom = params.geometry as SkyBoxQuadsGeometry;\r\n      (geom.cube! as Texture).texture.bindSampler(uniform, TextureUnit.Zero);\r\n    });\r\n  });\r\n  prog.addInlineComputedVarying(\"v_texDir\", VariableType.Vec3, computeTexDir);\r\n\r\n  return prog.buildProgram(context);\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { VariableType, FragmentShaderComponent, ShaderType } from \"../ShaderBuilder\";\nimport { ShaderProgram } from \"../ShaderProgram\";\nimport { GLSLFragment } from \"./Fragment\";\nimport { createViewportQuadBuilder } from \"./ViewportQuad\";\nimport { FrustumUniformType, fromSumOf } from \"../Target\";\nimport { Frustum, Npc } from \"@bentley/imodeljs-common\";\nimport { Vector3d, Point3d, Angle } from \"@bentley/geometry-core\";\nimport { SkySphereViewportQuadGeometry } from \"../CachedGeometry\";\nimport { GL } from \"../GL\";\nimport { Texture } from \"../Texture\";\nimport { TextureUnit } from \"../RenderFlags\";\nimport { System } from \"../System\";\nimport { assert } from \"@bentley/bentleyjs-core\";\n\nconst computeGradientValue = `\n  // For the gradient sky it's good enough to calculate these in the vertex shader.\n  vec3 eyeToVert = a_worldPos - u_worldEye;\n  float radius = sqrt(eyeToVert.x * eyeToVert.x + eyeToVert.y * eyeToVert.y);\n  float zValue = eyeToVert.z - radius * u_zOffset;\n  float d = atan(zValue, radius);\n  if (u_skyParams.x < 0.0) { // 2-color gradient\n    d = 0.5 - d / 3.14159265359;\n    return vec4(d, 0.0, 0.0, 0.0);\n  }\n  d = d / 1.570796326795;\n  return vec4(d, 1.0 - (d - horizonSize) / (1.0 - horizonSize), 1.0 - (-d - horizonSize) / (1.0 - horizonSize), (d + horizonSize) / (horizonSize * 2.0));\n`;\n\nconst computeSkySphereColorGradient = `\n  if (u_skyParams.x < 0.0) // 2-color\n    return vec4(mix(u_zenithColor, u_nadirColor, v_gradientValue.x), 1.0);\n\n  if (v_gradientValue.x > horizonSize) // above horizon\n    return vec4(mix(u_zenithColor, u_skyColor, pow(v_gradientValue.y, u_skyParams.y)), 1.0);\n  else if (v_gradientValue.x < -horizonSize) // below horizon\n    return vec4(mix(u_nadirColor, u_groundColor, pow(v_gradientValue.z, u_skyParams.z)), 1.0);\n\n  return vec4(mix(u_groundColor, u_skyColor, v_gradientValue.w), 1.0);\n`;\n\nconst computeEyeToVert = \"v_eyeToVert = a_worldPos - u_worldEye;\";\n\nconst computeSkySphereColorTexture = `\n  // For the texture we must calculate these per pixel.  Alternatively we could use a finer mesh.\n  float radius = sqrt(v_eyeToVert.x * v_eyeToVert.x + v_eyeToVert.y * v_eyeToVert.y);\n  float zValue = v_eyeToVert.z - radius * u_zOffset;\n  float u = 0.25 - (atan(v_eyeToVert.y, v_eyeToVert.x) + u_rotation) / 6.28318530718;\n  float v = 0.5 - atan(zValue, radius) / 3.14159265359;\n  if (u < 0.0)\n    u += 1.0;\n  if (v < 0.0)\n    v += 1.0;\n  return TEXTURE(s_skyTxtr, vec2(u, v));\n`;\n\nconst scratch3Floats = new Float32Array(3);\nconst scratchVec3 = new Vector3d();\nconst scratchPoint3 = new Point3d();\n\nfunction setPointsFromFrustum(skyGeometry: SkySphereViewportQuadGeometry, frustum: Frustum) {\n  const wp = skyGeometry.worldPos;\n  let mid = frustum.getCorner(Npc.LeftBottomRear).interpolate(0.5, frustum.getCorner(Npc.LeftBottomFront), scratchPoint3);\n  wp[0] = mid.x;\n  wp[1] = mid.y;\n  wp[2] = mid.z;\n  mid = frustum.getCorner(Npc.RightBottomRear).interpolate(0.5, frustum.getCorner(Npc.RightBottomFront), scratchPoint3);\n  wp[3] = mid.x;\n  wp[4] = mid.y;\n  wp[5] = mid.z;\n  mid = frustum.getCorner(Npc.RightTopRear).interpolate(0.5, frustum.getCorner(Npc.RightTopFront), scratchPoint3);\n  wp[6] = mid.x;\n  wp[7] = mid.y;\n  wp[8] = mid.z;\n  mid = frustum.getCorner(Npc.LeftTopRear).interpolate(0.5, frustum.getCorner(Npc.LeftTopFront), scratchPoint3);\n  wp[9] = mid.x;\n  wp[10] = mid.y;\n  wp[11] = mid.z;\n}\n\n/** @internal */\nexport function createSkySphereProgram(context: WebGLRenderingContext, isGradient: boolean): ShaderProgram {\n  const builder = createViewportQuadBuilder(false);\n  if (isGradient) {\n    builder.addFunctionComputedVarying(\"v_gradientValue\", VariableType.Vec4, \"computeGradientValue\", computeGradientValue);\n    builder.addGlobal(\"horizonSize\", VariableType.Float, ShaderType.Both, \"0.0015\", true);\n  } else\n    builder.addInlineComputedVarying(\"v_eyeToVert\", VariableType.Vec3, computeEyeToVert);\n\n  const vert = builder.vert;\n  vert.addAttribute(\"a_worldPos\", VariableType.Vec3, (shaderProg) => {\n    shaderProg.addAttribute(\"a_worldPos\", (attr, params) => {\n      // Send in the corners of the view in world space.\n      const geom = params.geometry;\n      assert(geom instanceof SkySphereViewportQuadGeometry);\n      const skyGeometry = geom as SkySphereViewportQuadGeometry;\n      setPointsFromFrustum(skyGeometry, params.target.planFrustum);\n      skyGeometry.bind();\n      attr.enableArray(skyGeometry.worldPosBuff, 3, GL.DataType.Float, false, 0, 0);\n    });\n  });\n  vert.addUniform(\"u_worldEye\", VariableType.Vec3, (shader) => {\n    shader.addGraphicUniform(\"u_worldEye\", (uniform, params) => {\n      const frustum = params.target.planFrustum;\n      if (FrustumUniformType.Perspective === params.target.frustumUniforms.type) {\n        // compute eye point from frustum.\n        const farLowerLeft = frustum.getCorner(Npc.LeftBottomRear);\n        const nearLowerLeft = frustum.getCorner(Npc.LeftBottomFront);\n        const scale = 1.0 / (1.0 - params.target.planFraction);\n        const zVec = Vector3d.createStartEnd(farLowerLeft, nearLowerLeft, scratchVec3);\n        const cameraPosition = fromSumOf(farLowerLeft, zVec, scale, scratchPoint3);\n        scratch3Floats[0] = cameraPosition.x;\n        scratch3Floats[1] = cameraPosition.y;\n        scratch3Floats[2] = cameraPosition.z;\n        uniform.setUniform3fv(scratch3Floats);\n      } else {\n        const delta = Vector3d.createStartEnd(frustum.getCorner(Npc.LeftBottomRear), frustum.getCorner(Npc.LeftBottomFront));\n        const pseudoCameraHalfAngle = 22.5;\n        const diagonal = frustum.getCorner(Npc.LeftBottomRear).distance(frustum.getCorner(Npc.RightTopRear));\n        const focalLength = diagonal / (2 * Math.atan(pseudoCameraHalfAngle * Angle.radiansPerDegree));\n        const worldEye = Point3d.createAdd3Scaled(frustum.getCorner(Npc.LeftBottomRear), .5, frustum.getCorner(Npc.RightTopRear), .5, delta, focalLength / delta.magnitude());\n        scratch3Floats[0] = worldEye.x;\n        scratch3Floats[1] = worldEye.y;\n        scratch3Floats[2] = worldEye.z;\n        uniform.setUniform3fv(scratch3Floats);\n      }\n    });\n  });\n  if (isGradient) {\n    vert.addUniform(\"u_skyParams\", VariableType.Vec3, (shader) => {\n      shader.addGraphicUniform(\"u_skyParams\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform3fv(geom.typeAndExponents);\n      });\n    });\n    vert.addUniform(\"u_zOffset\", VariableType.Float, (shader) => {\n      shader.addGraphicUniform(\"u_zOffset\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform1f(geom.zOffset);\n      });\n    });\n  }\n\n  const frag = builder.frag;\n  if (isGradient) {\n    frag.addUniform(\"u_skyParams\", VariableType.Vec3, (shader) => {\n      shader.addGraphicUniform(\"u_skyParams\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform3fv(geom.typeAndExponents);\n      });\n    });\n    frag.addUniform(\"u_zenithColor\", VariableType.Vec3, (shader) => {\n      shader.addGraphicUniform(\"u_zenithColor\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform3fv(geom.zenithColor);\n      });\n    });\n    frag.addUniform(\"u_skyColor\", VariableType.Vec3, (shader) => {\n      shader.addGraphicUniform(\"u_skyColor\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform3fv(geom.skyColor);\n      });\n    });\n    frag.addUniform(\"u_groundColor\", VariableType.Vec3, (shader) => {\n      shader.addGraphicUniform(\"u_groundColor\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform3fv(geom.groundColor);\n      });\n    });\n    frag.addUniform(\"u_nadirColor\", VariableType.Vec3, (shader) => {\n      shader.addGraphicUniform(\"u_nadirColor\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform3fv(geom.nadirColor);\n      });\n    });\n    frag.set(FragmentShaderComponent.ComputeBaseColor, computeSkySphereColorGradient);\n  } else {\n    frag.addUniform(\"s_skyTxtr\", VariableType.Sampler2D, (shader) => {\n      shader.addGraphicUniform(\"s_skyTxtr\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        if (undefined !== geom.skyTexture)\n          (geom.skyTexture! as Texture).texture.bindSampler(uniform, TextureUnit.Zero);\n        else\n          System.instance.ensureSamplerBound(uniform, TextureUnit.FeatureSymbology);\n      });\n    });\n    frag.addUniform(\"u_zOffset\", VariableType.Float, (shader) => {\n      shader.addGraphicUniform(\"u_zOffset\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform1f(geom.zOffset);\n      });\n    });\n    frag.addUniform(\"u_rotation\", VariableType.Float, (shader) => {\n      shader.addGraphicUniform(\"u_rotation\", (uniform, params) => {\n        const geom = params.geometry as SkySphereViewportQuadGeometry;\n        uniform.setUniform1f(geom.rotation);\n      });\n    });\n    frag.set(FragmentShaderComponent.ComputeBaseColor, computeSkySphereColorTexture);\n  }\n  frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n\n  builder.vert.headerComment = \"// ----- SkySphere -----\";\n  builder.frag.headerComment = \"// ----- SkySphere -----\";\n\n  return builder.buildProgram(context);\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module WebGL */\r\nimport { assert } from \"@bentley/bentleyjs-core\";\r\nimport { VariableType, ProgramBuilder, FragmentShaderComponent } from \"../ShaderBuilder\";\r\nimport { TextureUnit } from \"../RenderFlags\";\r\nimport { addModelMatrix } from \"./Vertex\";\r\nimport { Vector3d } from \"@bentley/geometry-core\";\r\n\r\nconst computeShadowPos = \"vec4 proj = u_shadowProj * MAT_MODEL * rawPosition; v_shadowPos = proj.xyz/proj.w;\";\r\nconst scratchShadowParams = new Float32Array(4);   // Color RGB, Shadow bias.\r\nconst scratchShadowDir = new Float32Array(3);\r\nconst scratchDirection = new Vector3d();\r\n\r\nconst applySolarShadowMap = `\r\n  if (v_shadowPos.x < 0.0 || v_shadowPos.x > 1.0 || v_shadowPos.y < 0.0 || v_shadowPos.y > 1.0 || v_shadowPos.x < 0.0 || v_shadowPos.z < 0.0)\r\n    return baseColor;\r\n\r\n  float cosTheta = clamp(abs(dot(normalize(v_n), u_shadowDir)), 0.0, 1.0);\r\n  float biasScale = isSurfaceBitSet(kSurfaceBit_HasNormals) ? (.1 + max(tan(acos(cosTheta)), 10.0)) : 1.0;\r\n\r\n  float shadowDepth = 1.0 - biasScale * u_shadowParams.w  - TEXTURE(s_shadowSampler, v_shadowPos.xy).r;\r\n  return (v_shadowPos.z > shadowDepth) ?  baseColor : vec4(u_shadowParams.rgb * baseColor.rgb, baseColor.a);\r\n  `;\r\n\r\n/** @internal */\r\nexport function addSolarShadowMap(builder: ProgramBuilder) {\r\n  const frag = builder.frag;\r\n  const vert = builder.vert;\r\n\r\n  frag.addUniform(\"s_shadowSampler\", VariableType.Sampler2D, (prog) => {\r\n    prog.addGraphicUniform(\"s_shadowSampler\", (uniform, params) => {\r\n      const shadowMap = params.target.solarShadowMap!;\r\n      assert(undefined !== shadowMap && undefined !== shadowMap.depthTexture);\r\n      shadowMap.depthTexture!.texture.bindSampler(uniform, TextureUnit.ShadowMap);\r\n    });\r\n  });\r\n\r\n  frag.addUniform(\"u_shadowParams\", VariableType.Vec4, (prog) => {\r\n    prog.addGraphicUniform(\"u_shadowParams\", (uniform, params) => {\r\n      const shadowMap = params.target.solarShadowMap!;\r\n      assert(undefined !== shadowMap);\r\n      const colors = shadowMap.settings.color.colors;\r\n      scratchShadowParams[0] = colors.r / 255.0;\r\n      scratchShadowParams[1] = colors.g / 255.0;\r\n      scratchShadowParams[2] = colors.b / 255.0;\r\n      scratchShadowParams[3] = shadowMap.settings.bias;\r\n      uniform.setUniform4fv(scratchShadowParams);\r\n    });\r\n  });\r\n  frag.addUniform(\"u_shadowDir\", VariableType.Vec3, (prog) => {\r\n    prog.addGraphicUniform(\"u_shadowDir\", (uniform, params) => {\r\n      const shadowMap = params.target.solarShadowMap!;\r\n      const mv = params.modelViewMatrix;\r\n      const worldDirection = shadowMap.direction!;\r\n      scratchDirection.x = mv.m00 * worldDirection.x + mv.m01 * worldDirection.y + mv.m02 * worldDirection.z;\r\n      scratchDirection.y = mv.m10 * worldDirection.x + mv.m11 * worldDirection.y + mv.m12 * worldDirection.z;\r\n      scratchDirection.z = mv.m20 * worldDirection.x + mv.m21 * worldDirection.y + mv.m22 * worldDirection.z;\r\n      scratchDirection.normalizeInPlace();\r\n\r\n      scratchShadowDir[0] = scratchDirection.x;\r\n      scratchShadowDir[1] = scratchDirection.y;\r\n      scratchShadowDir[2] = scratchDirection.z;\r\n      uniform.setUniform3fv(scratchShadowDir);\r\n    });\r\n  });\r\n\r\n  vert.addUniform(\"u_shadowProj\", VariableType.Mat4, (prog) => {\r\n    prog.addGraphicUniform(\"u_shadowProj\", (uniform, params) => {\r\n      const shadowMap = params.target.solarShadowMap!;\r\n      assert(undefined !== shadowMap);\r\n      uniform.setMatrix4(shadowMap.projectionMatrix);\r\n    });\r\n  });\r\n\r\n  addModelMatrix(vert);\r\n\r\n  builder.addInlineComputedVarying(\"v_shadowPos\", VariableType.Vec3, computeShadowPos);\r\n  frag.set(FragmentShaderComponent.ApplySolarShadowMap, applySolarShadowMap);\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport {\n  ProgramBuilder,\n  FragmentShaderBuilder,\n  VariableType,\n  FragmentShaderComponent,\n  VertexShaderComponent,\n  ShaderBuilder,\n  ShaderBuilderFlags,\n} from \"../ShaderBuilder\";\nimport { IsInstanced, IsAnimated, IsClassified, IsEdgeTestNeeded, FeatureMode, IsShadowable } from \"../TechniqueFlags\";\nimport { GLSLFragment, addWhiteOnWhiteReversal, addPickBufferOutputs, addAltPickBufferOutputs } from \"./Fragment\";\nimport { addProjectionMatrix, addModelViewMatrix, addNormalMatrix } from \"./Vertex\";\nimport { addAnimation } from \"./Animation\";\nimport { GLSLDecode } from \"./Decode\";\nimport { addColor } from \"./Color\";\nimport { addLighting } from \"./Lighting\";\nimport { addSurfaceDiscard, FeatureSymbologyOptions, addFeatureSymbology, addSurfaceHiliter } from \"./FeatureSymbology\";\nimport { addShaderFlags, GLSLCommon } from \"./Common\";\nimport { SurfaceFlags, TextureUnit } from \"../RenderFlags\";\nimport { Texture } from \"../Texture\";\nimport { Material } from \"../Material\";\nimport { System } from \"../System\";\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { addColorPlanarClassifier, addHilitePlanarClassifier, addFeaturePlanarClassifier } from \"./PlanarClassification\";\nimport { addSolarShadowMap } from \"./SolarShadowMapping\";\nimport { MutableFloatRgb, FloatRgba } from \"../FloatRGBA\";\nimport { ColorDef } from \"@bentley/imodeljs-common\";\n\nconst sampleSurfaceTexture = `\n  vec4 sampleSurfaceTexture() {\n    // Textures do NOT contain premultiplied alpha. Multiply in shader.\n    vec4 texColor = TEXTURE(s_texture, v_texCoord);\n    return applyPreMultipliedAlpha(texColor);\n  }\n`;\n\n// u_matRgb.a = 1.0 if color overridden by material, 0.0 otherwise.\n// u_matAlpha.y = 1.0 if alpha overridden by material.\n// if this is a raster glyph, the sampled color has already been modified - do not modify further.\nconst applyMaterialOverrides = `\n  float useMatColor = 1.0 - extractSurfaceBit(kSurfaceBit_IgnoreMaterial);\n  vec4 matColor = mix(baseColor, vec4(u_matRgb.rgb * baseColor.a, baseColor.a), useMatColor * u_matRgb.a);\n  matColor = mix(matColor, adjustPreMultipliedAlpha(matColor, u_matAlpha.x), useMatColor * u_matAlpha.y);\n  float textureWeight = u_textureWeight * extractSurfaceBit(kSurfaceBit_HasTexture) * (1.0 - u_applyGlyphTex);\n  return mix(matColor, g_surfaceTexel, textureWeight);\n`;\n\n/** @internal */\nexport function addMaterial(frag: FragmentShaderBuilder): void {\n  // ###TODO: We could pack rgb, alpha, and override flags into two floats.\n  frag.addFunction(GLSLFragment.revertPreMultipliedAlpha);\n  frag.addFunction(GLSLFragment.adjustPreMultipliedAlpha);\n  frag.set(FragmentShaderComponent.ApplyMaterialOverrides, applyMaterialOverrides);\n\n  frag.addUniform(\"u_matRgb\", VariableType.Vec4, (prog) => {\n    prog.addGraphicUniform(\"u_matRgb\", (uniform, params) => {\n      const mat: Material = params.target.currentViewFlags.materials && params.geometry.material ? params.geometry.material : Material.default;\n      uniform.setUniform4fv(mat.diffuseUniform);\n    });\n  });\n  frag.addUniform(\"u_matAlpha\", VariableType.Vec2, (prog) => {\n    prog.addGraphicUniform(\"u_matAlpha\", (uniform, params) => {\n      const mat = params.target.currentViewFlags.materials && params.geometry.material ? params.geometry.material : Material.default;\n      uniform.setUniform2fv(mat.alphaUniform);\n    });\n  });\n  frag.addUniform(\"u_textureWeight\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_textureWeight\", (uniform, params) => {\n      const mat = params.target.currentViewFlags.materials && params.geometry.material ? params.geometry.material : Material.default;\n      uniform.setUniform1f(mat.textureWeight);\n    });\n  });\n}\n\nconst computePosition = `\n  vec4 pos = MAT_MV * rawPos;\n  v_pos = pos.xyz;\n  return u_proj * pos;\n`;\n\nfunction createCommon(instanced: IsInstanced, animated: IsAnimated, classified: IsClassified, shadowable: IsShadowable): ProgramBuilder {\n  const builder = new ProgramBuilder(instanced ? ShaderBuilderFlags.InstancedVertexTable : ShaderBuilderFlags.VertexTable);\n  const vert = builder.vert;\n\n  if (animated)\n    addAnimation(vert, true);\n  if (classified)\n    addColorPlanarClassifier(builder);\n  if (shadowable)\n    addSolarShadowMap(builder);\n\n  addProjectionMatrix(vert);\n  addModelViewMatrix(vert);\n  builder.addVarying(\"v_pos\", VariableType.Vec3);\n  vert.set(VertexShaderComponent.ComputePosition, computePosition);\n\n  return builder;\n}\n\n/** @internal */\nexport function createSurfaceHiliter(instanced: IsInstanced, classified: IsClassified): ProgramBuilder {\n  const builder = createCommon(instanced, IsAnimated.No, classified, IsShadowable.No);\n\n  addSurfaceFlags(builder, true);\n  addTexture(builder, IsAnimated.No);\n  if (classified) {\n    addHilitePlanarClassifier(builder);\n    builder.vert.addGlobal(\"feature_ignore_material\", VariableType.Boolean, \"false\");\n    builder.frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n  } else\n    addSurfaceHiliter(builder);\n\n  return builder;\n}\n\n// nvidia hardware incorrectly interpolates varying floats when we send the same exact value for every vertex...\nconst extractSurfaceBit = `\nfloat extractSurfaceBit(float flag) { return extractNthBit(floor(v_surfaceFlags + 0.5), flag); }\n`;\n\nconst isSurfaceBitSet = `\nbool isSurfaceBitSet(float flag) { return 0.0 != extractSurfaceBit(flag); }\n`;\n\nfunction addSurfaceFlagsLookup(builder: ShaderBuilder) {\n  builder.addConstant(\"kSurfaceBit_HasTexture\", VariableType.Float, \"0.0\");\n  builder.addConstant(\"kSurfaceBit_ApplyLighting\", VariableType.Float, \"1.0\");\n  builder.addConstant(\"kSurfaceBit_HasNormals\", VariableType.Float, \"2.0\");\n  builder.addConstant(\"kSurfaceBit_IgnoreMaterial\", VariableType.Float, \"3.0\");\n  builder.addConstant(\"kSurfaceBit_TransparencyThreshold\", VariableType.Float, \"4.0\");\n  builder.addConstant(\"kSurfaceBit_BackgroundFill\", VariableType.Float, \"5.0\");\n  builder.addConstant(\"kSurfaceBit_HasColorAndNormal\", VariableType.Float, \"6.0\");\n\n  builder.addConstant(\"kSurfaceMask_None\", VariableType.Float, \"0.0\");\n  builder.addConstant(\"kSurfaceMask_HasTexture\", VariableType.Float, \"1.0\");\n  builder.addConstant(\"kSurfaceMask_ApplyLighting\", VariableType.Float, \"2.0\");\n  builder.addConstant(\"kSurfaceMask_HasNormals\", VariableType.Float, \"4.0\");\n  builder.addConstant(\"kSurfaceMask_IgnoreMaterial\", VariableType.Float, \"8.0\");\n  builder.addConstant(\"kSurfaceMask_TransparencyThreshold\", VariableType.Float, \"16.0\");\n  builder.addConstant(\"kSurfaceMask_BackgroundFill\", VariableType.Float, \"32.0\");\n  builder.addConstant(\"kSurfaceMask_HasColorAndNormal\", VariableType.Float, \"64.0\");\n\n  builder.addFunction(GLSLCommon.extractNthBit);\n  builder.addFunction(extractSurfaceBit);\n  builder.addFunction(isSurfaceBitSet);\n}\n\nconst getSurfaceFlags = \"return u_surfaceFlags;\";\n\nconst computeSurfaceFlags = `\n  float flags = u_surfaceFlags;\n  if (feature_ignore_material) {\n    bool hasTexture = 0.0 != fract(flags / 2.0); // kSurfaceMask_HasTexture = 1.0...\n    if (hasTexture)\n      flags -= kSurfaceMask_HasTexture;\n\n    flags += kSurfaceMask_IgnoreMaterial;\n  }\n\n  return flags;\n`;\n\n/** @internal */\nexport const octDecodeNormal = `\nvec3 octDecodeNormal(vec2 e) {\n  e = e / 255.0 * 2.0 - 1.0;\n  vec3 n = vec3(e.x, e.y, 1.0 - abs(e.x) - abs(e.y));\n  if (n.z < 0.0) {\n    vec2 signNotZero = vec2(n.x >= 0.0 ? 1.0 : -1.0, n.y >= 0.0 ? 1.0 : -1.0);\n    n.xy = (1.0 - abs(n.yx)) * signNotZero;\n  }\n\n  return normalize(n);\n}\n`;\n\nconst computeNormal = `\n  vec2 tc = g_vertexBaseCoords;\n  tc.x += 3.0 * g_vert_stepX;\n  vec4 enc = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\n  vec2 normal = mix(g_vertexData2, enc.xy, extractSurfaceBit(kSurfaceBit_HasColorAndNormal));\n  return mix(vec3(0.0), normalize(MAT_NORM * octDecodeNormal(normal)), extractSurfaceBit(kSurfaceBit_HasNormals));\n`;\n\nconst computeAnimatedNormal = `\n  if (u_animNormalParams.x >= 0.0)\n    return normalize(MAT_NORM * computeAnimationNormal(u_animNormalParams.x, u_animNormalParams.y, u_animNormalParams.z));\n` + computeNormal;\n\nconst applyBackgroundColor = `\n  return mix(baseColor, vec4(u_bgColor.rgb, 1.0), extractSurfaceBit(kSurfaceBit_BackgroundFill));\n`;\n\nconst computeTexCoord = `\n  vec2 tc = g_vertexBaseCoords;\n  tc.x += 3.0 * g_vert_stepX;  vec4 rgba = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\n  vec2 qcoords = vec2(decodeUInt16(rgba.xy), decodeUInt16(rgba.zw));\n  return mix(vec2(0.0), unquantize2d(qcoords, u_qTexCoordParams), extractSurfaceBit(kSurfaceBit_HasTexture));\n`;\nconst computeAnimatedTexCoord = `\n  if (u_animScalarQParams.x >= 0.0)\n    return computeAnimationParam(u_animScalarParams.x, u_animScalarParams.y, u_animScalarParams.z, u_animScalarQParams.x, u_animScalarQParams.y);\n` + computeTexCoord;\nconst getSurfaceColor = `\nvec4 getSurfaceColor() { return v_color; }\n`;\n\n// If we have texture weight < 1.0 we must compute the element/material color first then mix with texture color\n// in ApplyMaterialOverrides(). Do the sample once, here, and store in a global variable for possible later use.\n// If a glyph texture, must mix getSurfaceColor() with texture color so texture color alpha is applied 100% and\n// surface color rgb is scaled by texture color rgb (latter is full white originally but stretched via mipmapping).\nconst computeBaseColor = `\n  g_surfaceTexel = sampleSurfaceTexture();\n  vec4 surfaceColor = getSurfaceColor();\n\n  // Compute color for raster glyph.\n  vec4 glyphColor = surfaceColor;\n  const vec3 white = vec3(1.0);\n  const vec3 epsilon = vec3(0.0001);\n  vec3 color = glyphColor.rgb / max(0.0001, glyphColor.a); // revert premultiplied alpha\n  vec3 delta = (color + epsilon) - white;\n\n  // set to black if almost white\n  glyphColor.rgb *= float(u_reverseWhiteOnWhite <= 0.5 || delta.x <= 0.0 || delta.y <= 0.0 || delta.z <= 0.0);\n  glyphColor = vec4(glyphColor.rgb * g_surfaceTexel.rgb, g_surfaceTexel.a);\n\n  // Choose glyph color or unmodified texture sample\n  vec4 texColor = mix(g_surfaceTexel, glyphColor, u_applyGlyphTex);\n\n  // If untextured, or textureWeight < 1.0, choose surface color.\n  return mix(surfaceColor, texColor, extractSurfaceBit(kSurfaceBit_HasTexture) * floor(u_textureWeight));\n`;\n\nfunction addSurfaceFlags(builder: ProgramBuilder, withFeatureOverrides: boolean) {\n  builder.addFunctionComputedVarying(\"v_surfaceFlags\", VariableType.Float, \"computeSurfaceFlags\", withFeatureOverrides ? computeSurfaceFlags : getSurfaceFlags);\n\n  addSurfaceFlagsLookup(builder.vert);\n  addSurfaceFlagsLookup(builder.frag);\n  builder.addUniform(\"u_surfaceFlags\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_surfaceFlags\", (uniform, params) => {\n      assert(undefined !== params.geometry.asSurface);\n      const mesh = params.geometry.asSurface!;\n      const surfFlags = mesh.computeSurfaceFlags(params.programParams);\n      uniform.setUniform1f(surfFlags);\n    });\n  });\n}\n\nfunction addNormal(builder: ProgramBuilder, animated: IsAnimated) {\n  addNormalMatrix(builder.vert);\n\n  builder.vert.addFunction(octDecodeNormal);\n  builder.addFunctionComputedVarying(\"v_n\", VariableType.Vec3, \"computeLightingNormal\", animated ? computeAnimatedNormal : computeNormal);\n}\n\nfunction addTexture(builder: ProgramBuilder, animated: IsAnimated) {\n  builder.vert.addFunction(GLSLDecode.unquantize2d);\n  builder.addFunctionComputedVarying(\"v_texCoord\", VariableType.Vec2, \"computeTexCoord\", animated ? computeAnimatedTexCoord : computeTexCoord);\n  builder.vert.addUniform(\"u_qTexCoordParams\", VariableType.Vec4, (prog) => {\n    prog.addGraphicUniform(\"u_qTexCoordParams\", (uniform, params) => {\n      const surfGeom = params.geometry.asSurface!;\n      const surfFlags: SurfaceFlags = surfGeom.computeSurfaceFlags(params.programParams);\n      if (SurfaceFlags.None !== (SurfaceFlags.HasTexture & surfFlags)) {\n        const uvQParams = surfGeom.lut.uvQParams;\n        if (undefined !== uvQParams) {\n          uniform.setUniform4fv(uvQParams);\n        }\n      }\n    });\n  });\n\n  builder.frag.addFunction(GLSLFragment.applyPreMultipliedAlpha);\n  builder.frag.addFunction(sampleSurfaceTexture);\n  builder.frag.addUniform(\"s_texture\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"s_texture\", (uniform, params) => {\n      const surfGeom = params.geometry.asSurface!;\n      const surfFlags = surfGeom.computeSurfaceFlags(params.programParams);\n      if (SurfaceFlags.None !== (SurfaceFlags.HasTexture & surfFlags)) {\n        const texture = (params.target.analysisTexture ? params.target.analysisTexture : surfGeom.texture) as Texture;\n        assert(undefined !== texture);\n        texture.texture.bindSampler(uniform, TextureUnit.SurfaceTexture);\n      } else {\n        System.instance.ensureSamplerBound(uniform, TextureUnit.SurfaceTexture);\n      }\n    });\n  });\n}\n\nconst scratchBgColor: MutableFloatRgb = MutableFloatRgb.fromColorDef(ColorDef.white);\nconst blackColor = FloatRgba.fromColorDef(ColorDef.black);\n\n/** @internal */\nexport function createSurfaceBuilder(feat: FeatureMode, isInstanced: IsInstanced, isAnimated: IsAnimated, isClassified: IsClassified, isShadowable: IsShadowable, isEdgeTestNeeded: IsEdgeTestNeeded): ProgramBuilder {\n  const builder = createCommon(isInstanced, isAnimated, isClassified, isShadowable);\n  addShaderFlags(builder);\n\n  addFeatureSymbology(builder, feat, FeatureMode.Overrides === feat ? FeatureSymbologyOptions.Surface : FeatureSymbologyOptions.None);\n  addSurfaceFlags(builder, FeatureMode.Overrides === feat);\n  addSurfaceDiscard(builder, feat, isEdgeTestNeeded, isClassified);\n  addNormal(builder, isAnimated);\n\n  // In HiddenLine mode, we must compute the base color (plus feature overrides etc) in order to get the alpha, then replace with background color (preserving alpha for the transparency threshold test).\n  builder.frag.set(FragmentShaderComponent.FinalizeBaseColor, applyBackgroundColor);\n  builder.frag.addUniform(\"u_bgColor\", VariableType.Vec3, (prog) => {\n    prog.addProgramUniform(\"u_bgColor\", (uniform, params) => {\n      const bgColor = params.target.bgColor.alpha === 0.0 ? blackColor : params.target.bgColor;\n      scratchBgColor.setRgbValues(bgColor.red, bgColor.green, bgColor.blue);\n      scratchBgColor.bind(uniform);\n    });\n  });\n\n  addTexture(builder, isAnimated);\n\n  builder.frag.addUniform(\"u_applyGlyphTex\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_applyGlyphTex\", (uniform, params) => {\n      const surfGeom = params.geometry.asSurface!;\n      const surfFlags: SurfaceFlags = surfGeom.computeSurfaceFlags(params.programParams);\n      let isGlyph = false;\n      if (SurfaceFlags.None !== (SurfaceFlags.HasTexture & surfFlags))\n        isGlyph = surfGeom.isGlyph;\n\n      uniform.setUniform1f(isGlyph ? 1 : 0);\n    });\n  });\n\n  // Fragment and Vertex\n  addColor(builder, true);\n\n  // Fragment\n  builder.frag.addFunction(getSurfaceColor);\n  addLighting(builder);\n  addWhiteOnWhiteReversal(builder.frag);\n\n  if (FeatureMode.None === feat) {\n    builder.frag.set(FragmentShaderComponent.AssignFragData, GLSLFragment.assignFragColor);\n  } else {\n    if (isClassified)\n      addFeaturePlanarClassifier(builder);\n    builder.frag.addFunction(GLSLDecode.depthRgb);\n    if (isEdgeTestNeeded || isClassified)\n      addPickBufferOutputs(builder.frag);\n    else\n      addAltPickBufferOutputs(builder.frag);\n  }\n\n  builder.frag.addGlobal(\"g_surfaceTexel\", VariableType.Vec4);\n  builder.frag.set(FragmentShaderComponent.ComputeBaseColor, computeBaseColor);\n\n  return builder;\n}\n\n// Target.readPixels() renders everything in opaque pass. It turns off textures for normal surfaces but keeps them for things like 3d view attachment tiles.\n// We want to discard fully-transparent pixels of those things during readPixels() so that we don't locate the attachment unless the cursor is over a\n// non-transparent pixel of it.\nconst discardTransparentTexel = `return isSurfaceBitSet(kSurfaceBit_HasTexture) && alpha == 0.0;`;\n\n/** @internal */\nexport function addSurfaceDiscardByAlpha(frag: FragmentShaderBuilder): void {\n  frag.set(FragmentShaderComponent.DiscardByAlpha, discardTransparentTexel);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ProgramBuilder, FragmentShaderComponent } from \"../ShaderBuilder\";\nimport { GLSLFragment, addRenderTargetIndex } from \"./Fragment\";\nimport { addModelViewMatrix } from \"./Vertex\";\nimport { addFrustum, addEyeSpace } from \"./Common\";\nimport { System } from \"../System\";\n\nconst computeAlphaWeight = `\nfloat computeAlphaWeight(float a, float flatAlpha) {\n  // See Weighted Blended Order-Independent Transparency for examples of different weighting functions:\n  // http://jcgt.org/published/0002/02/09/\n  // We are using Equation 10 from the above paper.  Equation 10 directly uses screen-space gl_FragCoord.z.\n\n  // flatAlphaWeight bit is set if we want to apply OIT transparency using a constant Z value of 1.\n  // computeLinearDepth() removes the perspective and puts z in linear [0..1]\n  float z = mix(computeLinearDepth(v_eyeSpace.z), 1.0, flatAlpha);\n  return pow(a + 0.01, 4.0) + max(1e-2, 3.0 * 1e3 * pow(z, 3.0));\n}\n`;\n\nconst computeOutputs = `\n  float flatAlpha = extractShaderBit(kShaderBit_OITFlatAlphaWeight);\n  float scaleOutput = extractShaderBit(kShaderBit_OITScaleOutput);\n  vec3 Ci = baseColor.rgb;\n  float ai = min(0.99, baseColor.a); // OIT algorithm does not nicely handle a=1\n  float wzi = computeAlphaWeight(ai, flatAlpha);\n\n  // If we are scaling output into the 0 to 1 range, we use the maximum output of the alpha weight function.\n  float outputScale = mix(1.0, 1.0 / 3001.040604, scaleOutput);\n\n  vec4 output0 = vec4(Ci * wzi * outputScale, ai);\n  vec4 output1 = vec4(ai * wzi * outputScale);\n`;\n\nconst assignFragData = computeOutputs + `\n  FragColor0 = output0;\n  FragColor1 = output1;\n`;\n\nconst assignFragColor = computeOutputs + `\n  FragColor = (0 == u_renderTargetIndex) ? output0 : output1;\n`;\n\n/** @internal */\nexport function addTranslucency(prog: ProgramBuilder): void {\n  const frag = prog.frag;\n\n  addEyeSpace(prog);\n  addFrustum(prog);\n  addModelViewMatrix(prog.vert);\n\n  frag.addFunction(GLSLFragment.computeLinearDepth);\n  frag.addFunction(computeAlphaWeight);\n\n  if (System.instance.capabilities.supportsMRTTransparency) {\n    frag.addDrawBuffersExtension();\n    frag.set(FragmentShaderComponent.AssignFragData, assignFragData);\n  } else {\n    addRenderTargetIndex(frag);\n    frag.set(FragmentShaderComponent.AssignFragData, assignFragColor);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { assert } from \"@bentley/bentleyjs-core\";\nimport { VertexShaderBuilder, VariableType } from \"../ShaderBuilder\";\nimport { Matrix4 } from \"../Matrix\";\nimport { TextureUnit, RenderPass } from \"../RenderFlags\";\nimport { GLSLDecode } from \"./Decode\";\nimport { addLookupTable } from \"./LookupTable\";\nimport { addInstanceOverrides } from \"./Instancing\";\n\nconst initializeVertLUTCoords = `\n  g_vertexLUTIndex = decodeUInt32(a_pos);\n  g_vertexBaseCoords = compute_vert_coords(g_vertexLUTIndex);\n`;\n\nconst unquantizePosition = `\nvec4 unquantizePosition(vec3 pos, vec3 origin, vec3 scale) { return vec4(origin + scale * pos, 1.0); }\n`;\n\nconst unquantizeVertexPosition = `\nvec4 unquantizeVertexPosition(vec3 pos, vec3 origin, vec3 scale) { return unquantizePosition(pos, origin, scale); }\n`;\n\n// Need to read 2 rgba values to obtain 6 16-bit integers for position\nconst unquantizeVertexPositionFromLUTPrelude = `\nvec4 unquantizeVertexPosition(vec3 encodedIndex, vec3 origin, vec3 scale) {\n  vec2 tc = g_vertexBaseCoords;\n  vec4 enc1 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\n  tc.x += g_vert_stepX;\n  vec4 enc2 = floor(TEXTURE(u_vertLUT, tc) * 255.0 + 0.5);\n`;\nconst computeFeatureIndexCoords = `\n  tc.x += g_vert_stepX;\n  g_featureIndexCoords = tc;\n`;\nconst unquantizeVertexPositionFromLUTPostlude = `\n  vec3 qpos = vec3(decodeUInt16(enc1.xy), decodeUInt16(enc1.zw), decodeUInt16(enc2.xy));\n  g_vertexData2 = enc2.zw;\n  return unquantizePosition(qpos, origin, scale);\n}\n`;\n\nconst computeLineWeight = \"\\nfloat computeLineWeight() { return g_lineWeight; }\\n\";\nconst computeLineCode = \"\\nfloat computeLineCode() { return g_lineCode; }\\n\";\n\nconst scratchMVPMatrix = new Matrix4();\n\n/** @internal */\nexport function addModelViewProjectionMatrix(vert: VertexShaderBuilder): void {\n  if (vert.usesInstancedGeometry) {\n    addModelViewMatrix(vert);\n    addProjectionMatrix(vert);\n    vert.addGlobal(\"g_mvp\", VariableType.Mat4);\n    vert.addInitializer(\"g_mvp = u_proj * g_mv;\");\n  } else {\n    vert.addUniform(\"u_mvp\", VariableType.Mat4, (prog) => {\n      prog.addGraphicUniform(\"u_mvp\", (uniform, params) => {\n        const mvp = params.projectionMatrix.clone(scratchMVPMatrix);\n        mvp.multiplyBy(params.modelViewMatrix);\n        uniform.setMatrix4(mvp);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport function addProjectionMatrix(vert: VertexShaderBuilder): void {\n  vert.addUniform(\"u_proj\", VariableType.Mat4, (prog) => {\n    prog.addProgramUniform(\"u_proj\", (uniform, params) => {\n      uniform.setMatrix4(params.projectionMatrix);\n    });\n  });\n}\n\nconst scratchRTC = new Float32Array(3);\n\nconst computeInstancedModelMatrix = `\n  g_instancedModelMatrix = g_modelMatrixRTC;\n  g_instancedModelMatrix[3].xyz = u_instancedRTC;\n`;\n\n/** @internal */\nexport function addModelMatrix(vert: VertexShaderBuilder): void {\n  if (vert.usesInstancedGeometry) {\n    assert(undefined !== vert.find(\"g_modelMatrixRTC\")); // set up in VertexShaderBuilder constructor...\n    if (undefined === vert.find(\"g_instancedModelMatrix\")) {\n      vert.addUniform(\"u_instancedRTC\", VariableType.Vec3, (prog) => {\n        prog.addGraphicUniform(\"u_instancedRTC\", (uniform, params) => {\n          const rtc = params.geometry.asInstanced!.rtcCenter;\n          scratchRTC[0] = rtc.x;\n          scratchRTC[1] = rtc.y;\n          scratchRTC[2] = rtc.z;\n          uniform.setUniform3fv(scratchRTC);\n        });\n      });\n\n      vert.addGlobal(\"g_instancedModelMatrix\", VariableType.Mat4);\n      vert.addInitializer(computeInstancedModelMatrix);\n    }\n  } else if (undefined === vert.find(\"u_modelMatrix\")) {\n    vert.addUniform(\"u_modelMatrix\", VariableType.Mat4, (prog) => {\n      // ###TODO: We only need 3 rows, not 4...\n      prog.addGraphicUniform(\"u_modelMatrix\", (uniform, params) => {\n        uniform.setMatrix4(params.modelMatrix);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport function addModelViewMatrix(vert: VertexShaderBuilder): void {\n  if (vert.usesInstancedGeometry) {\n    vert.addUniform(\"u_instanced_modelView\", VariableType.Mat4, (prog) => {\n      prog.addGraphicUniform(\"u_instanced_modelView\", (uniform, params) => {\n        uniform.setMatrix4(params.modelViewMatrix);\n      });\n    });\n\n    vert.addGlobal(\"g_mv\", VariableType.Mat4);\n    vert.addInitializer(\"g_mv = u_instanced_modelView * g_modelMatrixRTC;\");\n  } else {\n    vert.addUniform(\"u_mv\", VariableType.Mat4, (prog) => {\n      // ###TODO: We only need 3 rows, not 4...\n      prog.addGraphicUniform(\"u_mv\", (uniform, params) => {\n        uniform.setMatrix4(params.modelViewMatrix);\n      });\n    });\n  }\n}\n\n/** @internal */\nexport function addNormalMatrix(vert: VertexShaderBuilder) {\n  vert.addGlobal(\"g_nmx\", VariableType.Mat3);\n  vert.addInitializer(\"g_nmx = mat3(MAT_MV);\");\n}\n\nconst scratchLutParams = new Float32Array(4);\nfunction addPositionFromLUT(vert: VertexShaderBuilder) {\n  vert.addGlobal(\"g_vertexLUTIndex\", VariableType.Float);\n  vert.addGlobal(\"g_vertexBaseCoords\", VariableType.Vec2);\n  vert.addGlobal(\"g_vertexData2\", VariableType.Vec2);\n\n  vert.addFunction(GLSLDecode.uint32);\n  vert.addFunction(GLSLDecode.uint16);\n  if (vert.usesInstancedGeometry) {\n    vert.addFunction(unquantizeVertexPositionFromLUTPrelude + unquantizeVertexPositionFromLUTPostlude);\n  } else {\n    vert.addGlobal(\"g_featureIndexCoords\", VariableType.Vec2);\n    vert.addFunction(unquantizeVertexPositionFromLUTPrelude + computeFeatureIndexCoords + unquantizeVertexPositionFromLUTPostlude);\n  }\n\n  vert.addUniform(\"u_vertLUT\", VariableType.Sampler2D, (prog) => {\n    prog.addGraphicUniform(\"u_vertLUT\", (uniform, params) => {\n      (params.geometry.asLUT!).lut.texture.bindSampler(uniform, TextureUnit.VertexLUT);\n    });\n  });\n\n  vert.addUniform(\"u_vertParams\", VariableType.Vec4, (prog) => {\n    prog.addGraphicUniform(\"u_vertParams\", (uniform, params) => {\n      assert(undefined !== params.geometry.asLUT);\n      const lut = params.geometry.asLUT!.lut;\n      const lutParams = scratchLutParams;\n      lutParams[0] = lut.texture.width;\n      lutParams[1] = lut.texture.height;\n      lutParams[2] = lut.numRgbaPerVertex;\n      lutParams[3] = lut.numVertices;\n      uniform.setUniform4fv(lutParams);\n    });\n  });\n\n  addLookupTable(vert, \"vert\", \"u_vertParams.z\");\n  vert.addInitializer(initializeVertLUTCoords);\n}\n\n/** @internal */\nexport function addPosition(vert: VertexShaderBuilder, fromLUT: boolean) {\n  vert.addFunction(unquantizePosition);\n\n  vert.addAttribute(\"a_pos\", VariableType.Vec3, (prog) => {\n    prog.addAttribute(\"a_pos\", (attr, params) => { params.geometry.bindVertexArray(attr); });\n  });\n  vert.addUniform(\"u_qScale\", VariableType.Vec3, (prog) => {\n    prog.addGraphicUniform(\"u_qScale\", (uniform, params) => {\n      uniform.setUniform3fv(params.geometry.qScale);\n    });\n  });\n  vert.addUniform(\"u_qOrigin\", VariableType.Vec3, (prog) => {\n    prog.addGraphicUniform(\"u_qOrigin\", (uniform, params) => {\n      uniform.setUniform3fv(params.geometry.qOrigin);\n    });\n  });\n\n  if (!fromLUT) {\n    vert.addFunction(unquantizeVertexPosition);\n  } else {\n    addPositionFromLUT(vert);\n  }\n}\n\n/** @internal */\nexport function addAlpha(vert: VertexShaderBuilder): void {\n  vert.addUniform(\"u_hasAlpha\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_hasAlpha\", (uniform, params) => {\n      uniform.setUniform1f(RenderPass.Translucent === params.geometry.getRenderPass(params.target) ? 1.0 : 0.0);\n    });\n  });\n}\n\n/** @internal */\nexport function addLineWeight(vert: VertexShaderBuilder): void {\n  vert.addUniform(\"u_lineWeight\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_lineWeight\", (attr, params) => {\n      attr.setUniform1f(params.geometry.getLineWeight(params.programParams));\n    });\n  });\n\n  vert.addGlobal(\"g_lineWeight\", VariableType.Float);\n  if (vert.usesInstancedGeometry) {\n    addInstanceOverrides(vert);\n    vert.addInitializer(\"g_lineWeight = mix(u_lineWeight, a_instanceOverrides.g, extractInstanceBit(kOvrBit_Weight));\");\n  } else {\n    vert.addInitializer(\"g_lineWeight = u_lineWeight;\");\n  }\n\n  vert.addFunction(computeLineWeight);\n}\n\n/** @internal */\nexport function replaceLineWeight(vert: VertexShaderBuilder, func: string): void {\n  vert.replaceFunction(computeLineWeight, func);\n}\n\n/** @internal */\nexport function addLineCode(vert: VertexShaderBuilder): void {\n  vert.addUniform(\"u_lineCode\", VariableType.Float, (prog) => {\n    prog.addGraphicUniform(\"u_lineCode\", (attr, params) => {\n      attr.setUniform1f(params.geometry.getLineCode(params.programParams));\n    });\n  });\n\n  vert.addGlobal(\"g_lineCode\", VariableType.Float);\n  if (vert.usesInstancedGeometry) {\n    addInstanceOverrides(vert);\n    vert.addInitializer(\"g_lineCode = mix(u_lineCode, a_instanceOverrides.b, extractInstanceBit(kOvrBit_LineCode));\");\n  } else {\n    vert.addInitializer(\"g_lineCode = u_lineCode;\");\n  }\n\n  vert.addFunction(computeLineCode);\n}\n\n/** @internal */\nexport function replaceLineCode(vert: VertexShaderBuilder, func: string): void {\n  vert.replaceFunction(computeLineCode, func);\n}\n\n/** @internal */\nexport namespace GLSLVertex {\n  // This vertex belongs to a triangle which should not be rendered. Produce a degenerate triangle.\n  // Also place it outside NDC range (for GL_POINTS)\n  const discardVertex = `\n{\n  gl_Position = vec4(2.0, 2.0, 2.0, 1.0);\n  return;\n}\n`;\n\n  export const earlyDiscard = `  if (checkForEarlyDiscard(rawPosition))` + discardVertex;\n  export const discard = `  if (checkForDiscard())` + discardVertex;\n  export const lateDiscard = `  if (checkForLateDiscard())` + discardVertex;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ShaderBuilder, VariableType, VertexShaderBuilder } from \"../ShaderBuilder\";\nimport { Matrix4 } from \"../Matrix\";\nimport { ViewRect } from \"../../../Viewport\";\nimport { addModelViewProjectionMatrix } from \"./Vertex\";\nimport { addRenderPass } from \"./RenderPass\";\n\n/** @internal */\nexport function addViewport(shader: ShaderBuilder) {\n  shader.addUniform(\"u_viewport\", VariableType.Vec4, (prog) => {\n    prog.addProgramUniform(\"u_viewport\", (uniform, params) => {\n      const rect = params.target.viewRect;\n      const vp: number[] = [rect.left, rect.bottom, rect.width, rect.height];\n      uniform.setUniform4fv(vp);\n    });\n  });\n}\n\nconst viewportMatrix = new Matrix4();\nconst prevViewRect = new ViewRect();\nconst nearDepthRange = 0.0;\nconst farDepthRange = 1.0;\n\nfunction computeViewportTransformation(viewRect: ViewRect): Matrix4 {\n  if (viewRect.equals(prevViewRect))\n    return viewportMatrix;\n\n  prevViewRect.setFrom(viewRect);\n\n  const x = viewRect.left;\n  const y = viewRect.top;\n  const width = viewRect.width;\n  const height = viewRect.height;\n\n  const halfWidth = width * 0.5;\n  const halfHeight = height * 0.5;\n  const halfDepth = (farDepthRange - nearDepthRange) * 0.5;\n\n  const column0Row0 = halfWidth;\n  const column1Row1 = halfHeight;\n  const column2Row2 = halfDepth;\n  const column3Row0 = x + halfWidth;\n  const column3Row1 = y + halfHeight;\n  const column3Row2 = nearDepthRange + halfDepth;\n  const column3Row3 = 1.0;\n\n  const mat = Matrix4.fromValues(\n    column0Row0, 0.0, 0.0, column3Row0,\n    0.0, column1Row1, 0.0, column3Row1,\n    0.0, 0.0, column2Row2, column3Row2,\n    0.0, 0.0, 0.0, column3Row3, viewportMatrix);\n\n  return mat;\n}\n\n/** @internal */\nexport function addViewportTransformation(shader: ShaderBuilder) {\n  shader.addUniform(\"u_viewportTransformation\", VariableType.Mat4, (prog) => {\n    prog.addProgramUniform(\"u_viewportTransformation\", (uniform, params) => {\n      uniform.setMatrix4(computeViewportTransformation(params.target.viewRect));\n    });\n  });\n}\n\nconst modelToWindowCoordinates = `\nvec4 modelToWindowCoordinates(vec4 position, vec4 next) {\n  if (kRenderPass_ViewOverlay == u_renderPass || kRenderPass_Background == u_renderPass) {\n    vec4 q = MAT_MVP * position;\n    q.xyz /= q.w;\n    q.xyz = (u_viewportTransformation * vec4(q.xyz, 1.0)).xyz;\n    return q;\n  }\n\n  // Negative values are in front of the camera (visible).\n  float s_maxZ = -u_frustum.x;            // use -near (front) plane for segment drop test since u_frustum's near & far are pos.\n  vec4  q = MAT_MV * position;              // eye coordinates.\n  vec4  n = MAT_MV * next;\n\n  if (q.z > s_maxZ) {\n    if (n.z > s_maxZ)\n      return vec4(0.0, 0.0,  1.0, 0.0);   // Entire segment behind eye.\n\n    float t = (s_maxZ - q.z) / (n.z - q.z);\n\n    q.x += t * (n.x - q.x);\n    q.y += t * (n.y - q.y);\n    q.z = s_maxZ;                       // q.z + (s_maxZ - q.z) * (s_maxZ - q.z) / n.z - q.z\n  }\n  q = u_proj * q;\n  q.xyz /= q.w;                           // normalized device coords\n  q.xyz = (u_viewportTransformation * vec4(q.xyz, 1.0)).xyz; // window coords\n  return q;\n  }\n`;\n\n/** @internal */\nexport function addModelToWindowCoordinates(vert: VertexShaderBuilder) {\n  addModelViewProjectionMatrix(vert);\n  addViewportTransformation(vert);\n  addRenderPass(vert);\n  vert.addFunction(modelToWindowCoordinates);\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module WebGL */\n\nimport { ProgramBuilder, VariableType, VertexShaderComponent } from \"../ShaderBuilder\";\n\n// Positions are in NDC [-1..1]. Compute UV params in [0..1]\nconst computeTexCoord = \"v_texCoord = (rawPosition.xy + 1.0) * 0.5;\";\nconst computePosition = \"return rawPos;\";\n\nfunction addTexture(prog: ProgramBuilder) {\n  prog.addInlineComputedVarying(\"v_texCoord\", VariableType.Vec2, computeTexCoord);\n}\n\n/** @internal */\nexport function createViewportQuadBuilder(textured: boolean): ProgramBuilder {\n  const prog = new ProgramBuilder();\n  prog.vert.set(VertexShaderComponent.ComputePosition, computePosition);\n  if (textured) {\n    addTexture(prog);\n  }\n\n  return prog;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\nexport * from \"./render/primitives/geometry/GeometryPrimitives\";\nexport * from \"./render/primitives/geometry/GeometryList\";\nexport * from \"./render/primitives/geometry/GeometryListBuilder\";\nexport * from \"./render/primitives/geometry/GeometryAccumulator\";\n\nexport * from \"./render/primitives/mesh/MeshBuilder\";\nexport * from \"./render/primitives/mesh/MeshBuilderMap\";\nexport * from \"./render/primitives/mesh/MeshPrimitives\";\n\nexport * from \"./render/primitives/ColorMap\";\nexport * from \"./render/primitives/DisplayParams\";\nexport * from \"./render/primitives/PointCloudPrimitive\";\nexport * from \"./render/primitives/Primitives\";\nexport * from \"./render/primitives/Strokes\";\nexport * from \"./render/primitives/Polyface\";\nexport * from \"./render/primitives/VertexKey\";\nexport * from \"./render/primitives/VertexTable\";\n\nexport * from \"./render/FeatureSymbology\";\nexport * from \"./render/GraphicBuilder\";\nexport * from \"./render/System\";\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\nimport { TileIO } from \"./TileIO\";\nimport { GltfTileIO } from \"./GltfTileIO\";\nimport { ElementAlignedBox3d, FeatureTable, Feature, BatchType } from \"@bentley/imodeljs-common\";\nimport { Id64String, utf8ToString } from \"@bentley/bentleyjs-core\";\nimport { RenderSystem } from \"../render/System\";\nimport { Mesh } from \"../render/primitives/mesh/MeshPrimitives\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { Transform } from \"@bentley/geometry-core\";\n\n/**\n * Provides facilities for deserializing Batched 3D Model (B3dm) tiles.\n * @internal\n */\nexport namespace B3dmTileIO {\n  /** @internal */\n  export class Header extends TileIO.Header {\n    public readonly length: number;\n    public readonly featureTableJsonLength: number;\n    public readonly featureTableBinaryLength: number;\n    public readonly batchTableJsonLength: number;\n    public readonly batchTableBinaryLength: number;\n    public readonly featureTableJson: any;\n    public get isValid(): boolean { return TileIO.Format.B3dm === this.format; }\n\n    public constructor(stream: TileIO.StreamBuffer) {\n      super(stream);\n      this.length = stream.nextUint32;\n      this.featureTableJsonLength = stream.nextUint32;\n      this.featureTableBinaryLength = stream.nextUint32;\n      this.batchTableJsonLength = stream.nextUint32;\n      this.batchTableBinaryLength = stream.nextUint32;\n\n      // Keep this legacy check in for now since a lot of tilesets are still using the old header.\n      // Legacy header #1: [batchLength] [batchTableByteLength]\n      // Legacy header #2: [batchTableJsonByteLength] [batchTableBinaryByteLength] [batchLength]\n      // Current header: [featureTableJsonByteLength] [featureTableBinaryByteLength] [batchTableJsonByteLength] [batchTableBinaryByteLength]\n      // If the header is in the first legacy format 'batchTableJsonByteLength' will be the start of the JSON string (a quotation mark) or the glTF magic.\n      // Accordingly its first byte will be either 0x22 or 0x67, and so the minimum uint32 expected is 0x22000000 = 570425344 = 570MB. It is unlikely that the feature table Json will exceed this length.\n      // The check for the second legacy format is similar, except it checks 'batchTableBinaryByteLength' instead\n      if (this.batchTableJsonLength >= 570425344) {\n        // First legacy check\n        stream.curPos = 20;\n        // batchLength = this.featureTableJsonLength;\n        this.batchTableJsonLength = this.featureTableBinaryLength;\n        this.batchTableBinaryLength = 0;\n        this.featureTableJsonLength = 0;\n        this.featureTableBinaryLength = 0;\n      } else if (this.batchTableBinaryLength >= 570425344) {\n        // Second legacy check\n        stream.curPos = 24;\n        this.batchTableJsonLength = this.featureTableJsonLength;\n        this.batchTableBinaryLength = this.featureTableBinaryLength;\n        this.featureTableJsonLength = 0;\n        this.featureTableBinaryLength = 0;\n      }\n      if (0 !== this.featureTableJsonLength) {\n        const sceneStrData = stream.nextBytes(this.featureTableJsonLength);\n        const sceneStr = utf8ToString(sceneStrData);\n        if (sceneStr) this.featureTableJson = JSON.parse(sceneStr);\n      }\n      stream.advance(this.featureTableBinaryLength);\n      stream.advance(this.batchTableJsonLength);\n      stream.advance(this.batchTableBinaryLength);\n\n      if (stream.isPastTheEnd)\n        this.invalidate();\n    }\n  }\n\n  /**\n   * Deserializes a B3DM tile.\n   * @internal\n   */\n  export class Reader extends GltfTileIO.Reader {\n    public static create(stream: TileIO.StreamBuffer, iModel: IModelConnection, modelId: Id64String, is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem, yAxisUp: boolean, isLeaf: boolean, transformToRoot?: Transform, isCanceled?: GltfTileIO.IsCanceled): Reader | undefined {\n      const header = new Header(stream);\n      if (!header.isValid)\n        return undefined;\n\n      if (header.featureTableJson && Array.isArray(header.featureTableJson.RTC_CENTER)) {\n        const returnToCenterTransform = Transform.createTranslationXYZ(header.featureTableJson.RTC_CENTER[0], header.featureTableJson.RTC_CENTER[1], header.featureTableJson.RTC_CENTER[2]);\n        transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(returnToCenterTransform) : returnToCenterTransform;\n      }\n\n      const props = GltfTileIO.ReaderProps.create(stream, yAxisUp);\n      return undefined !== props ? new Reader(props, iModel, modelId, is3d, system, range, isLeaf, transformToRoot, isCanceled) : undefined;\n    }\n    private constructor(props: GltfTileIO.ReaderProps, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, private _range: ElementAlignedBox3d, private _isLeaf: boolean, private _transformToRoot?: Transform, isCanceled?: GltfTileIO.IsCanceled) {\n      super(props, iModel, modelId, is3d, system, BatchType.Primary, isCanceled);\n    }\n    public async read(): Promise<GltfTileIO.ReaderResult> {\n\n      // TBD... Create an actual feature table if one exists.  For now we are only reading tiles from scalable mesh which have no features.\n      // NB: For reality models with no batch table, we want the model ID in the feature table\n      const featureTable: FeatureTable = new FeatureTable(1, this._modelId, this._type);\n      const feature = new Feature(this._modelId);\n      featureTable.insert(feature);\n\n      await this.loadTextures();\n      if (this._isCanceled)\n        return Promise.resolve({ readStatus: TileIO.ReadStatus.Canceled, isLeaf: this._isLeaf });\n\n      return Promise.resolve(this.readGltfAndCreateGraphics(this._isLeaf, featureTable, this._range, this._transformToRoot));\n    }\n    protected readFeatures(features: Mesh.Features, _json: any): boolean {\n      const feature = new Feature(this._modelId);\n\n      features.add(feature, 1);\n      return true;\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\nimport { TileIO } from \"./TileIO\";\n\n/**\n * Provides facilities for deserializing Composite (cmpt) tiles.\n * @internal\n */\nexport namespace CompositeTileIO {\n  /** @internal */\n  export class Header extends TileIO.Header {\n    public readonly length: number;\n    public readonly tileCount: number;\n    public readonly tilePosition: number;\n\n    public get isValid(): boolean { return TileIO.Format.Cmpt === this.format; }\n\n    public constructor(stream: TileIO.StreamBuffer) {\n      super(stream);\n      this.length = stream.nextUint32;\n      this.tileCount = stream.nextUint32;\n      this.tilePosition = stream.curPos;\n\n      if (stream.isPastTheEnd)\n        this.invalidate();\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\n\nimport { Tile } from \"./TileTree\";\nimport { TileIO } from \"./TileIO\";\nimport { DisplayParams } from \"../render/primitives/DisplayParams\";\nimport { Triangle } from \"../render/primitives/Primitives\";\nimport { Mesh, MeshList, MeshGraphicArgs } from \"../render/primitives/mesh/MeshPrimitives\";\nimport {\n  FeatureTable,\n  QPoint3d,\n  QPoint3dList,\n  QParams3d,\n  OctEncodedNormal,\n  MeshPolyline,\n  MeshPolylineList,\n  ElementAlignedBox3d,\n  TextureMapping,\n  ImageSource,\n  ImageSourceFormat,\n  RenderTexture,\n  BatchType,\n  ColorDef,\n  LinePixels,\n  FillFlags,\n} from \"@bentley/imodeljs-common\";\nimport { Id64String, assert, JsonUtils, utf8ToString } from \"@bentley/bentleyjs-core\";\nimport { Range3d, Point2d, Point3d, Vector3d, Transform, Matrix3d, Angle } from \"@bentley/geometry-core\";\nimport { InstancedGraphicParams, RenderSystem, RenderGraphic, GraphicBranch, PackedFeatureTable } from \"../render/System\";\nimport { imageElementFromImageSource, getImageSourceFormatForMimeType } from \"../ImageUtil\";\nimport { IModelConnection } from \"../IModelConnection\";\n\n// tslint:disable:no-const-enum\n\n/* -----------------------------------\n * To restore the use of web workers to decode jpeg, locate and uncomment the three sections by searching for \"webworker\".\n  import { WorkerOperation, WebWorkerManager } from \"../WebWorkerManager\";\n  ------------------------------------ */\n\n// Defer Draco for now.   import { DracoDecoder } from \"./DracoDecoder\";\n\n/** Provides facilities for deserializing tiles in the [glTF tile format](https://www.khronos.org/gltf/).\n * @internal\n */\nexport namespace GltfTileIO {\n  /** Known version of the [glTF format](https://www.khronos.org/gltf/).\n   * @internal\n   */\n  export const enum Versions {\n    Version1 = 1,\n    Version2 = 2,\n    CurrentVersion = Version1,\n    Gltf1SceneFormat = 0,\n  }\n\n  /** @internal */\n  export const enum V2ChunkTypes {\n    JSON = 0x4E4F534a,\n    Binary = 0x004E4942,\n  }\n\n  /** The result of [[GltfTileIO.Reader.read]].\n   * @internal\n   */\n  export interface ReaderResult extends Tile.Content {\n    readStatus: TileIO.ReadStatus;\n  }\n\n  /** Header preceding glTF tile data.\n   * @internal\n   */\n  export class Header extends TileIO.Header {\n    public readonly gltfLength: number;\n    public readonly scenePosition: number = 0;\n    public readonly sceneStrLength: number = 0;\n    public readonly binaryPosition: number = 0;\n    public get isValid(): boolean { return TileIO.Format.Gltf === this.format; }\n\n    public constructor(stream: TileIO.StreamBuffer) {\n      super(stream);\n      this.gltfLength = stream.nextUint32;\n      this.sceneStrLength = stream.nextUint32;\n      const value5 = stream.nextUint32;\n\n      // Early versions of the reality data tile publisher incorrectly put version 2 into header - handle these old tiles\n      // validating the chunk type.\n      if (this.version === Versions.Version2 && value5 === Versions.Gltf1SceneFormat)\n        this.version = Versions.Version1;\n\n      if (this.version === Versions.Version1) {\n        const gltfSceneFormat = value5;\n        if (Versions.Gltf1SceneFormat !== gltfSceneFormat) {\n          this.invalidate();\n          return;\n        }\n        this.scenePosition = stream.curPos;\n        this.binaryPosition = stream.curPos + this.sceneStrLength;\n      } else if (this.version === Versions.Version2) {\n        const sceneChunkType = value5;\n        this.scenePosition = stream.curPos;\n        stream.curPos = stream.curPos + this.sceneStrLength;\n        const binaryLength = stream.nextUint32;\n        const binaryChunkType = stream.nextUint32;\n        if (V2ChunkTypes.JSON !== sceneChunkType || V2ChunkTypes.Binary !== binaryChunkType || 0 === binaryLength) {\n          this.invalidate();\n          return;\n        }\n        this.binaryPosition = stream.curPos;\n      } else {\n        this.invalidate();\n      }\n    }\n  }\n\n  /** @internal */\n  export const enum MeshMode {\n    Lines = 1,\n    LineStrip = 3,\n    Triangles = 4,\n  }\n\n  /** @internal */\n  export const enum DataType {\n    // SignedByte = 0x1400,\n    UnsignedByte = 0x1401,\n    // SignedShort = 5122,\n    UnsignedShort = 5123,\n    UInt32 = 5125,\n    Float = 5126,\n    // Rgb = 6407,\n    // Rgba = 6408,\n    // IntVec2 = 0x8b53,\n    // IntVec3 = 0x8b54,\n    // FloatVec2 = 35664,\n    // FloatVec3 = 35665,\n    // FloatVec4 = 35666,\n    // FloatMat3 = 35675,\n    // FloatMat4 = 35676,\n    // Sampler2d = 35678,\n  }\n\n  /** @internal */\n  export const enum Constants {\n    CullFace = 2884,\n    DepthTest = 2929,\n    Nearest = 0x2600,\n    Linear = 9729,\n    LinearMipmapLinear = 9987,\n    ClampToEdge = 33071,\n    ArrayBuffer = 34962,\n    ElementArrayBuffer = 34963,\n    FragmentShader = 35632,\n    VertexShader = 35633,\n  }\n\n  /** @internal */\n  export type DataBuffer = Uint8Array | Uint16Array | Uint32Array | Float32Array;\n\n  /**\n   * A chunk of binary data exposed as a typed array.\n   * The count member indicates how many elements exist. This may be less than this.buffer.length due to padding added to the\n   * binary stream to ensure correct alignment.\n   * @internal\n   */\n  export class BufferData {\n    public readonly buffer: DataBuffer;\n    public readonly count: number;\n\n    public constructor(buffer: DataBuffer, count: number) {\n      this.buffer = buffer;\n      this.count = count;\n    }\n\n    /**\n     * Create a BufferData of the desired type. The actual type may differ from the desired type - for example, small 32-bit integers\n     * may be represented as 8-bit or 16-bit integers instead.\n     * If the actual data type is not convertible to the desired type, this function returns undefined.\n     */\n    public static create(bytes: Uint8Array, actualType: DataType, expectedType: DataType, count: number): BufferData | undefined {\n      if (expectedType !== actualType) {\n        // Some data is stored in smaller data types to save space if no values exceed the maximum of the smaller type.\n        switch (expectedType) {\n          case DataType.Float:\n          case DataType.UnsignedByte:\n            return undefined;\n          case DataType.UnsignedShort:\n            if (DataType.UnsignedByte !== actualType)\n              return undefined;\n            break;\n          case DataType.UInt32:\n            if (DataType.UnsignedByte !== actualType && DataType.UnsignedShort !== actualType)\n              return undefined;\n            break;\n        }\n      }\n\n      const data = this.createDataBuffer(bytes, actualType);\n      return undefined !== data ? new BufferData(data, count) : undefined;\n    }\n\n    private static createDataBuffer(bytes: Uint8Array, actualType: DataType): DataBuffer | undefined {\n      // NB: Endianness of typed array data is determined by the 'platform byte order'. Actual data is always little-endian.\n      // We are assuming little-endian platform. If we find a big-endian platform, we'll need to use a DataView instead.\n      switch (actualType) {\n        case DataType.UnsignedByte:\n          return bytes;\n        case DataType.UnsignedShort:\n          return new Uint16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2);\n        case DataType.UInt32:\n          return new Uint32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4);\n        case DataType.Float:\n          return new Float32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4);\n        default:\n          return undefined;\n      }\n    }\n  }\n\n  /**\n   * A view of a chunk of a tile's binary data containing an array of elements of a specific data type.\n   * The count member indicates how many elements exist; this may be smaller than this.data.length.\n   * The count member may also indicate the number of elements of a type containing more than one value of the\n   * underlying type. For example, a buffer of 4 32-bit floating point 'vec2' elements will have a count of 4,\n   * but its data member will contain 8 32-bit floating point values (2 per vec2).\n   * The accessor member may contain additional JSON data specific to a particular buffer.\n   * @internal\n   */\n  export class BufferView {\n    public readonly data: Uint8Array;\n    public readonly count: number;\n    public readonly type: DataType;\n    public readonly accessor: any;\n\n    public get byteLength(): number { return this.data.length; }\n\n    public constructor(data: Uint8Array, count: number, type: DataType, accessor: any) {\n      this.data = data;\n      this.count = count;\n      this.type = type;\n      this.accessor = accessor;\n    }\n\n    public toBufferData(desiredType: DataType): BufferData | undefined {\n      return BufferData.create(this.data, this.type, desiredType, this.count);\n    }\n  }\n\n  /** Data required for creating a Reader capable of deserializing [glTF tile data](https://www.khronos.org/gltf/).\n   * @internal\n   */\n  export class ReaderProps {\n    private constructor(public readonly buffer: TileIO.StreamBuffer,\n      public readonly binaryData: Uint8Array,\n      public readonly accessors: any,\n      public readonly bufferViews: any,\n      public readonly scene: any,\n      public readonly nodes: any,\n      public readonly meshes: any,\n      public readonly materials: any,\n      public readonly extensions: any,\n      public readonly samplers: any,\n      public readonly techniques: any,\n      public readonly yAxisUp: boolean) { }\n\n    /** Attempt to construct a new ReaderProps from the binary data beginning at the supplied stream's current read position. */\n    public static create(buffer: TileIO.StreamBuffer, yAxisUp: boolean = false): ReaderProps | undefined {\n      const header = new Header(buffer);\n      if (!header.isValid)\n        return undefined;\n\n      const binaryData = new Uint8Array(buffer.arrayBuffer, header.binaryPosition);\n      buffer.curPos = header.scenePosition;\n      const sceneStrData = buffer.nextBytes(header.sceneStrLength);\n      const sceneStr = utf8ToString(sceneStrData);\n      if (undefined === sceneStr)\n        return undefined;\n\n      try {\n        const sceneValue = JSON.parse(sceneStr);\n        const nodes = JsonUtils.asObject(sceneValue.nodes);\n        const meshes = JsonUtils.asObject(sceneValue.meshes);\n        const materialValues = JsonUtils.asObject(sceneValue.materials);\n        const accessors = JsonUtils.asObject(sceneValue.accessors);\n        const bufferViews = JsonUtils.asObject(sceneValue.bufferViews);\n        const extensions = JsonUtils.asObject(sceneValue.extensions);\n        const samplers = JsonUtils.asObject(sceneValue.samplers);\n        const techniques = JsonUtils.asObject(sceneValue.techniques);\n\n        if (undefined === meshes)\n          return undefined;\n\n        return new ReaderProps(buffer, binaryData, accessors, bufferViews, sceneValue, nodes, meshes, materialValues, extensions, samplers, techniques, yAxisUp);\n      } catch (e) {\n        return undefined;\n      }\n    }\n  }\n\n  /** A function that returns true if Reader.read() should abort because the tile data is no longer needed.\n   * @internal\n   */\n  export type IsCanceled = (reader: Reader) => boolean;\n\n  /* -----------------------------------\n     This is part of the webworker option.\n\n    // input is Uint8Array, the result is an ImageBitMap.\n    class ImageDecodeWorkerOperation extends WorkerOperation {\n      constructor(imageBytes: ArrayBuffer, imageMimeType: string) {\n        super(\"imageBytesToImageBitmap\", [imageBytes, imageMimeType], [imageBytes]);\n      }\n    }\n\n    declare var BUILD_SEMVER: string;\n  -------------------------------------- */\n\n  /** Deserializes [(glTF tile data](https://www.khronos.org/gltf/).\n   * @internal\n   */\n  export abstract class Reader {\n    protected readonly _buffer: TileIO.StreamBuffer;\n    protected readonly _scene: any;\n    protected readonly _accessors: any;\n    protected readonly _bufferViews: any;\n    protected readonly _meshes: any;\n    protected readonly _nodes: any;\n    protected readonly _batchData: any;\n    protected readonly _materialValues: any;\n    protected readonly _textures: any;\n    protected readonly _renderMaterials: any;  // Materials that may be deserialized and created directly\n    protected readonly _namedTextures: any;    // Textures that may be deserialized and created directly\n    protected readonly _images: any;\n    protected readonly _samplers: any;\n    protected readonly _techniques: any;\n    protected readonly _binaryData: Uint8Array;\n    protected readonly _iModel: IModelConnection;\n    protected readonly _is3d: boolean;\n    protected readonly _modelId: Id64String;\n    protected readonly _system: RenderSystem;\n    protected readonly _returnToCenter: number[] | undefined;\n    protected readonly _yAxisUp: boolean;\n    protected readonly _type: BatchType;\n    private readonly _canceled?: IsCanceled;\n\n    /* -----------------------------------\n    private static _webWorkerManager: WebWorkerManager;\n\n    private static get webWorkerManager() {\n      if (!Reader._webWorkerManager) {\n        Reader._webWorkerManager = new WebWorkerManager(\"v\" + BUILD_SEMVER + \"/frontend-webworker.js\", 4);\n      }\n      return Reader._webWorkerManager;\n    }\n    ------------------------------------- */\n\n    /** Asynchronously deserialize the tile data and return the result. */\n    public async abstract read(): Promise<ReaderResult>;\n\n    protected get _isCanceled(): boolean { return undefined !== this._canceled && this._canceled(this); }\n    protected get _isVolumeClassifier(): boolean { return BatchType.VolumeClassifier === this._type; }\n\n    protected readGltfAndCreateGraphics(isLeaf: boolean, featureTable: FeatureTable, contentRange: ElementAlignedBox3d, transformToRoot?: Transform, sizeMultiplier?: number, instances?: InstancedGraphicParams): GltfTileIO.ReaderResult {\n      if (this._isCanceled)\n        return { readStatus: TileIO.ReadStatus.Canceled, isLeaf, sizeMultiplier };\n\n      const childNodes = new Set<string>();\n      for (const key of Object.keys(this._nodes)) {\n        const node = this._nodes[key];\n        if (node.children)\n          for (const child of node.children)\n            childNodes.add(child.toString());\n      }\n\n      const renderGraphicList: RenderGraphic[] = [];\n      let readStatus: TileIO.ReadStatus = TileIO.ReadStatus.InvalidTileData;\n      for (const nodeKey of Object.keys(this._nodes))\n        if (!childNodes.has(nodeKey))\n          if (TileIO.ReadStatus.Success !== (readStatus = this.readNodeAndCreateGraphics(renderGraphicList, this._nodes[nodeKey], featureTable, undefined, instances)))\n            return { readStatus, isLeaf };\n\n      if (0 === renderGraphicList.length)\n        return { readStatus: TileIO.ReadStatus.InvalidTileData, isLeaf };\n\n      let renderGraphic: RenderGraphic | undefined;\n      if (1 === renderGraphicList.length)\n        renderGraphic = renderGraphicList[0];\n      else\n        renderGraphic = this._system.createGraphicList(renderGraphicList);\n\n      const range = contentRange.clone();\n      if (undefined !== this._returnToCenter) {\n        range.low.plusXYZ(-this._returnToCenter[0], -this._returnToCenter[1], -this._returnToCenter[2], range.low);\n        range.high.plusXYZ(-this._returnToCenter[0], -this._returnToCenter[1], -this._returnToCenter[2], range.high);\n      }\n\n      renderGraphic = this._system.createBatch(renderGraphic, PackedFeatureTable.pack(featureTable), range);\n      if (undefined !== this._returnToCenter || this._yAxisUp || undefined !== transformToRoot) {\n        const branch = new GraphicBranch();\n        branch.add(renderGraphic);\n        let transform = (undefined === this._returnToCenter) ? Transform.createIdentity() : Transform.createTranslationXYZ(this._returnToCenter[0], this._returnToCenter[1], this._returnToCenter[2]);\n        if (this._yAxisUp) transform = transform.multiplyTransformMatrix3d(Matrix3d.createRotationAroundVector(Vector3d.create(1.0, 0.0, 0.0), Angle.createRadians(Angle.piOver2Radians)) as Matrix3d);\n        if (undefined !== transformToRoot) transform = transformToRoot.multiplyTransformTransform(transform);\n        renderGraphic = this._system.createBranch(branch, transform);\n      }\n\n      return {\n        readStatus,\n        isLeaf,\n        sizeMultiplier,\n        contentRange,\n        graphic: renderGraphic,\n      };\n    }\n\n    private readNodeAndCreateGraphics(renderGraphicList: RenderGraphic[], node: any, featureTable: FeatureTable, parentTransform: Transform | undefined, instances?: InstancedGraphicParams): TileIO.ReadStatus {\n      if (undefined === node)\n        return TileIO.ReadStatus.InvalidTileData;\n\n      let thisTransform = parentTransform;\n      if (Array.isArray(node.matrix)) {\n        const jTrans = node.matrix;\n        const nodeTransform = Transform.createOriginAndMatrix(Point3d.create(jTrans[12], jTrans[13], jTrans[14]), Matrix3d.createRowValues(jTrans[0], jTrans[4], jTrans[8], jTrans[1], jTrans[5], jTrans[9], jTrans[2], jTrans[6], jTrans[10]));\n        thisTransform = thisTransform ? thisTransform.multiplyTransformTransform(nodeTransform) : nodeTransform;\n      }\n      const meshKey = node.meshes ? node.meshes : node.mesh;\n      if (undefined !== meshKey) {\n        const nodeMesh = this._meshes[meshKey];\n        if (nodeMesh) {\n          const meshGraphicArgs = new MeshGraphicArgs();\n          const geometryCollection = new TileIO.GeometryCollection(new MeshList(featureTable), true, false);\n          for (const primitive of nodeMesh.primitives) {\n            const geometry = this.readMeshPrimitive(primitive, featureTable);\n            if (undefined !== geometry)\n              geometryCollection.meshes.push(geometry);\n          }\n\n          let renderGraphic: RenderGraphic | undefined;\n          if (!geometryCollection.isEmpty) {\n            if (1 === geometryCollection.meshes.length) {\n              renderGraphic = geometryCollection.meshes[0].getGraphics(meshGraphicArgs, this._system, instances);\n            } else {\n              const thisList: RenderGraphic[] = [];\n              for (const mesh of geometryCollection.meshes) {\n                renderGraphic = mesh.getGraphics(meshGraphicArgs, this._system, instances);\n                if (undefined !== renderGraphic)\n                  thisList.push(renderGraphic!);\n              }\n              if (0 !== thisList.length)\n                renderGraphic = this._system.createGraphicList(thisList);\n            }\n            if (renderGraphic) {\n              if (thisTransform && !thisTransform.isIdentity) {\n                const branch = new GraphicBranch();\n                branch.add(renderGraphic);\n                renderGraphic = this._system.createBranch(branch, thisTransform);\n              }\n              renderGraphicList.push(renderGraphic);\n            }\n          }\n        }\n      }\n      if (node.children) {\n        for (const child of node.children)\n          this.readNodeAndCreateGraphics(renderGraphicList, this._nodes[child], featureTable, thisTransform, instances);\n      }\n      return TileIO.ReadStatus.Success;\n    }\n\n    public getBufferView(json: any, accessorName: string): BufferView | undefined {\n      try {\n        const accessorValue = JsonUtils.asString(json[accessorName]);\n        const accessor = 0 < accessorValue.length ? JsonUtils.asObject(this._accessors[accessorValue]) : undefined;\n        const bufferViewAccessorValue = undefined !== accessor ? JsonUtils.asString(accessor.bufferView) : \"\";\n        const bufferView = 0 < bufferViewAccessorValue.length ? JsonUtils.asObject(this._bufferViews[bufferViewAccessorValue]) : undefined;\n\n        if (undefined === accessor)\n          return undefined;\n\n        const type = accessor.componentType as DataType;\n        let dataSize = 0;\n        switch (type) {\n          case DataType.UnsignedByte:\n            dataSize = 1;\n            break;\n          case DataType.UnsignedShort:\n            dataSize = 2;\n            break;\n          case DataType.UInt32:\n          case DataType.Float:\n            dataSize = 4;\n            break;\n          default:\n            return undefined;\n        }\n        let componentCount = 1;\n        switch (accessor.type) {\n          case \"VEC3\":\n            componentCount = 3;\n            break;\n          case \"VEC2\":\n            componentCount = 2;\n            break;\n        }\n\n        const offset = ((bufferView && bufferView.byteOffset) ? bufferView.byteOffset : 0) + (accessor.byteOffset ? accessor.byteOffset : 0);\n        const length = componentCount * dataSize * accessor.count;\n        // If the data is misaligned (Scalable mesh tile publisher) use slice to copy -- else use subarray.\n        // assert(0 === offset % dataSize);\n        const bytes = (0 === (this._binaryData.byteOffset + offset) % dataSize) ? this._binaryData.subarray(offset, offset + length) : this._binaryData.slice(offset, offset + length);\n        return new BufferView(bytes, accessor.count as number, type, accessor);\n      } catch (e) {\n        return undefined;\n      }\n    }\n\n    public readBufferData32(json: any, accessorName: string): BufferData | undefined { return this.readBufferData(json, accessorName, DataType.UInt32); }\n    public readBufferData16(json: any, accessorName: string): BufferData | undefined { return this.readBufferData(json, accessorName, DataType.UnsignedShort); }\n    public readBufferData8(json: any, accessorName: string): BufferData | undefined { return this.readBufferData(json, accessorName, DataType.UnsignedByte); }\n    public readBufferDataFloat(json: any, accessorName: string): BufferData | undefined { return this.readBufferData(json, accessorName, DataType.Float); }\n\n    protected constructor(props: ReaderProps, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, type: BatchType = BatchType.Primary, isCanceled?: IsCanceled) {\n      this._buffer = props.buffer;\n      this._scene = props.scene;\n      this._binaryData = props.binaryData;\n      this._accessors = props.accessors;\n      this._bufferViews = props.bufferViews;\n      this._meshes = props.meshes;\n      this._nodes = props.nodes;\n      this._materialValues = props.materials;\n      this._samplers = props.samplers;\n      this._techniques = props.techniques;\n      this._yAxisUp = props.yAxisUp;\n      this._returnToCenter = this.extractReturnToCenter(props.extensions);\n      this._textures = props.scene.textures;\n      this._images = props.scene.images;\n\n      this._renderMaterials = props.scene.renderMaterials;\n      this._namedTextures = props.scene.namedTextures;\n\n      this._iModel = iModel;\n      this._modelId = modelId;\n      this._is3d = is3d;\n      this._system = system;\n      this._type = type;\n      this._canceled = isCanceled;\n    }\n\n    protected readBufferData(json: any, accessorName: string, type: DataType): BufferData | undefined {\n      const view = this.getBufferView(json, accessorName);\n      return undefined !== view ? view.toBufferData(type) : undefined;\n    }\n\n    protected readFeatureIndices(_json: any): number[] | undefined { return undefined; }\n\n    private colorFromJson(values: number[]): ColorDef { return ColorDef.from(values[0] * 255, values[1] * 255, values[2] * 255, (1.0 - values[3]) * 255); }\n\n    private colorFromMaterial(materialJson: any): ColorDef {\n      if (materialJson) {\n        if (materialJson.values && Array.isArray(materialJson.values.color))\n          return this.colorFromJson(materialJson.values.color);\n        else if (materialJson.pbrMetallicRoughness && Array.isArray(materialJson.pbrMetallicRoughness.baseColorFactor))\n          return this.colorFromJson(materialJson.pbrMetallicRoughness.baseColorFactor);\n        else if (materialJson.extensions && materialJson.extensions.KHR_techniques_webgl && materialJson.extensions.KHR_techniques_webgl.values && materialJson.extensions.KHR_techniques_webgl.values.u_color)\n          return this.colorFromJson(materialJson.extensions.KHR_techniques_webgl.values.u_color);\n      }\n      return ColorDef.white.clone();\n    }\n\n    protected createDisplayParams(materialJson: any, hasBakedLighting: boolean): DisplayParams | undefined {\n      let textureMapping: TextureMapping | undefined;\n\n      if (undefined !== materialJson) {\n        if (materialJson.values && materialJson.values.tex)\n          textureMapping = this.findTextureMapping(materialJson.values.tex);    // Bimiums shader value.\n        else if (materialJson.extensions && materialJson.extensions.KHR_techniques_webgl && materialJson.extensions.KHR_techniques_webgl.values && materialJson.extensions.KHR_techniques_webgl.values.u_tex)\n          textureMapping = this.findTextureMapping(materialJson.extensions.KHR_techniques_webgl.values.u_tex.index);    // Bimiums colorIndex.\n        else if (materialJson.diffuseTexture)\n          textureMapping = this.findTextureMapping(materialJson.diffuseTexture.index);        // TBD -- real map support with PBR\n        else if (materialJson.emissiveTexture)\n          textureMapping = this.findTextureMapping(materialJson.emissiveTexture.index);      // TBD -- real map support with PBR\n      }\n\n      const color = this.colorFromMaterial(materialJson);\n      return new DisplayParams(DisplayParams.Type.Mesh, color, color, 1, LinePixels.Solid, FillFlags.Always, undefined, undefined, hasBakedLighting, textureMapping);\n    }\n    protected extractReturnToCenter(extensions: any): number[] | undefined {\n      if (extensions === undefined) { return undefined; }\n      const cesiumRtc = JsonUtils.asObject(extensions.CESIUM_RTC);\n      if (cesiumRtc === undefined) return undefined;\n      const rtc = JsonUtils.asArray(cesiumRtc.center);\n      return (rtc[0] === 0.0 && rtc[1] === 0.0 && rtc[2] === 0.0) ? undefined : rtc;\n    }\n\n    protected readMeshPrimitive(primitive: any, featureTable?: FeatureTable): Mesh | undefined {\n      const materialName = JsonUtils.asString(primitive.material);\n      const hasBakedLighting = undefined === primitive.attributes.NORMAL;\n      const materialValue = 0 < materialName.length ? JsonUtils.asObject(this._materialValues[materialName]) : undefined;\n      const displayParams = undefined !== materialValue ? this.createDisplayParams(materialValue, hasBakedLighting) : undefined;\n      if (undefined === displayParams)\n        return undefined;\n\n      let primitiveType: number = -1;\n      const meshMode = JsonUtils.asInt(primitive.mode, GltfTileIO.MeshMode.Triangles);\n      switch (meshMode) {\n        case GltfTileIO.MeshMode.Lines:\n          primitiveType = Mesh.PrimitiveType.Polyline;\n          return undefined; // Needs work...\n          break;\n        case GltfTileIO.MeshMode.Triangles:\n          primitiveType = Mesh.PrimitiveType.Mesh;\n          break;\n        default:\n          assert(false);\n          return undefined;\n      }\n      const isPlanar = JsonUtils.asBool(primitive.isPlanar);\n\n      const isVolumeClassifier = this._isVolumeClassifier;\n      const mesh = Mesh.create({\n        displayParams,\n        features: undefined !== featureTable ? new Mesh.Features(featureTable) : undefined,\n        type: primitiveType,\n        range: Range3d.createNull(),\n        is2d: !this._is3d,\n        isPlanar,\n        hasBakedLighting,\n        isVolumeClassifier,\n      });\n      // We don't have real colormap - just load material color.  This will be used if non-Bentley\n      // tile or fit the color table is uniform. For a non-Bentley, non-Uniform, we'll set the\n      // uv parameters to pick the colors out of the color map texture.\n      mesh.colorMap.insert(displayParams.fillColor.tbgr);   // White...\n\n      const colorIndices = this.readBufferData16(primitive.attributes, \"_COLORINDEX\");\n      if (undefined !== colorIndices) {\n        let texStep;\n        if (materialValue.values !== undefined && Array.isArray(materialValue.values.texStep))\n          texStep = materialValue.values.texStep;\n        else if (materialValue.extensions && materialValue.extensions.KHR_techniques_webgl && materialValue.extensions.KHR_techniques_webgl.values && Array.isArray(materialValue.extensions.KHR_techniques_webgl.values.u_texStep))\n          texStep = materialValue.extensions.KHR_techniques_webgl.values.u_texStep;\n\n        if (texStep)\n          for (let i = 0; i < colorIndices.count; i++)\n            mesh.uvParams.push(new Point2d(texStep[1] + texStep[0] * colorIndices.buffer[i], .5));\n      }\n\n      if (undefined !== mesh.features && !this.readFeatures(mesh.features, primitive))\n        return undefined;\n      if (primitive.extensions && primitive.extensions.KHR_draco_mesh_compression) {\n        return undefined;     // Defer Draco support until moved to web worker.\n        /*\n        const dracoExtension = primitive.extensions.KHR_draco_mesh_compression;\n        const bufferView = this._bufferViews[dracoExtension.bufferView];\n        if (undefined === bufferView) return undefined;\n        const bufferData = this._binaryData.subarray(bufferView.byteOffset, bufferView.byteOffset + bufferView.byteLength);\n\n        return  DracoDecoder.readDracoMesh(mesh, primitive, bufferData); */\n      }\n      if (!this.readVertices(mesh.points, primitive))\n        return undefined;\n\n      switch (primitiveType) {\n        case Mesh.PrimitiveType.Mesh: {\n          if (!this.readMeshIndices(mesh, primitive))\n            return undefined;\n\n          if (!displayParams.ignoreLighting && !this.readNormals(mesh.normals, primitive.attributes, \"NORMAL\"))\n            return undefined;\n\n          if (0 === mesh.uvParams.length)\n            this.readUVParams(mesh.uvParams, primitive.attributes, \"TEXCOORD_0\");\n          break;\n        }\n\n        case Mesh.PrimitiveType.Polyline:\n        case Mesh.PrimitiveType.Point: {\n          if (undefined !== mesh.polylines && !this.readPolylines(mesh.polylines, primitive, \"indices\", Mesh.PrimitiveType.Point === primitiveType))\n            return undefined;\n          break;\n        }\n        default: {\n          assert(false, \"unhandled primitive type\");\n          return undefined;\n        }\n      }\n      if (displayParams.textureMapping && 0 === mesh.uvParams.length)\n        return undefined;\n\n      return mesh;\n    }\n\n    protected readVertices(positions: QPoint3dList, primitive: any): boolean {\n      const view = this.getBufferView(primitive.attributes, \"POSITION\");\n      if (undefined === view)\n        return false;\n\n      if (DataType.Float === view.type) {\n        const buffer = view.toBufferData(DataType.Float);\n        if (undefined === buffer)\n          return false;\n        const range = Range3d.createNull();\n        for (let i = 0; i < buffer.buffer.length;)\n          range.extendXYZ(buffer.buffer[i++], buffer.buffer[i++], buffer.buffer[i++]);\n\n        positions.reset(QParams3d.fromRange(range));\n        const scratchPoint = new Point3d();\n        for (let i = 0, j = 0; i < buffer.count; i++) {\n          scratchPoint.set(buffer.buffer[j++], buffer.buffer[j++], buffer.buffer[j++]);\n          positions.add(scratchPoint);\n        }\n      } else {\n        if (DataType.UnsignedShort !== view.type)\n          return false;\n\n        const extensions = JsonUtils.asObject(view.accessor.extensions);\n        const quantized = undefined !== extensions ? JsonUtils.asObject(extensions.WEB3D_quantized_attributes) : undefined;\n        if (undefined === quantized)\n          return false;\n\n        const rangeMin = JsonUtils.asArray(quantized.decodedMin);\n        const rangeMax = JsonUtils.asArray(quantized.decodedMax);\n        if (undefined === rangeMin || undefined === rangeMax)\n          return false;\n\n        const buffer = view.toBufferData(DataType.UnsignedShort);\n        if (undefined === buffer)\n          return false;\n\n        const qpt = QPoint3d.fromScalars(0, 0, 0);\n        positions.reset(QParams3d.fromRange(Range3d.create(Point3d.create(rangeMin[0], rangeMin[1], rangeMin[2]), Point3d.create(rangeMax[0], rangeMax[1], rangeMax[2]))));\n        for (let i = 0; i < view.count; i++) {\n          const index = i * 3; // 3 uint16 per QPoint3d...\n          qpt.setFromScalars(buffer.buffer[index], buffer.buffer[index + 1], buffer.buffer[index + 2]);\n          positions.push(qpt);\n        }\n      }\n\n      return true;\n    }\n\n    protected readIndices(json: any, accessorName: string): number[] | undefined {\n      const data = this.readBufferData32(json, accessorName);\n      if (undefined === data)\n        return undefined;\n\n      const indices = [];\n      for (let i = 0; i < data.count; i++)\n        indices.push(data.buffer[i]);\n\n      return indices;\n    }\n\n    protected readFeatures(features: Mesh.Features, json: any): boolean {\n      const indices = this.readFeatureIndices(json);\n      if (undefined === indices)\n        return false;\n\n      features.setIndices(indices);\n      return true;\n    }\n\n    protected readMeshIndices(mesh: Mesh, json: any): boolean {\n      const data = this.readBufferData32(json, \"indices\");\n      if (undefined === data)\n        return false;\n\n      assert(0 === data.count % 3);\n\n      const triangle = new Triangle(false);\n\n      for (let i = 0; i < data.count; i += 3) {\n        triangle.setIndices(data.buffer[i], data.buffer[i + 1], data.buffer[i + 2]);\n        mesh.addTriangle(triangle);\n      }\n\n      return true;\n    }\n\n    protected readNormals(normals: OctEncodedNormal[], json: any, accessorName: string): boolean {\n      const view = this.getBufferView(json, accessorName);\n      if (undefined === view)\n        return false;\n\n      switch (view.type) {\n        case DataType.Float: {\n          const data = view.toBufferData(DataType.Float);\n          if (undefined === data)\n            return false;\n\n          const scratchNormal = new Vector3d();\n          for (let i = 0, j = 0; i < data.count; i++) {\n            scratchNormal.set(data.buffer[j++], data.buffer[j++], data.buffer[j++]);\n            normals.push(OctEncodedNormal.fromVector(scratchNormal));\n          }\n          return true;\n        }\n\n        case DataType.UnsignedByte: {\n          const data = view.toBufferData(DataType.UnsignedByte);\n          if (undefined === data)\n            return false;\n\n          // ###TODO: we shouldn't have to allocate OctEncodedNormal objects...just use uint16s / numbers...\n          for (let i = 0; i < data.count; i++) {\n            // ###TODO? not clear why ray writes these as pairs of uint8...\n            const index = i * 2;\n            const normal = data.buffer[index] | (data.buffer[index + 1] << 8);\n            normals.push(new OctEncodedNormal(normal));\n          }\n          return true;\n        }\n        default:\n          return false;\n      }\n    }\n\n    protected readUVParams(params: Point2d[], json: any, accessorName: string): boolean {\n      const view = this.getBufferView(json, accessorName);\n      let data: any;\n\n      if (view === undefined) { return false; }\n      switch (view.type) {\n        case DataType.Float: {\n          data = this.readBufferDataFloat(json, accessorName);\n\n          for (let i = 0; i < data.count; i++) {\n            const index = 2 * i; // 2 float per param...\n            params.push(new Point2d(data.buffer[index], data.buffer[index + 1]));\n          }\n          break;\n        }\n\n        case DataType.UnsignedShort: {\n          // TBD.   Support quantized UVParams in shaders rather than expanding here.\n          const extensions = JsonUtils.asObject(view.accessor.extensions);\n          const quantized = undefined !== extensions ? JsonUtils.asObject(extensions.WEB3D_quantized_attributes) : undefined;\n          if (undefined === quantized)\n            return false;\n\n          const decodeMatrix = JsonUtils.asArray(quantized.decodeMatrix);\n          if (undefined === decodeMatrix) { return false; }\n\n          const qData = view.toBufferData(DataType.UnsignedShort);\n          if (undefined === qData) { return false; }\n\n          for (let i = 0; i < view.count; i++) {\n            const index = 2 * i; // 3 uint16 per QPoint3d...\n            params.push(new Point2d(qData.buffer[index] * decodeMatrix[0] + decodeMatrix[6], qData.buffer[index + 1] * decodeMatrix[4] + decodeMatrix[7]));\n          }\n          break;\n        }\n      }\n\n      return true;\n    }\n\n    protected readPolylines(polylines: MeshPolylineList, json: any, accessorName: string, disjoint: boolean): boolean {\n      const view = this.getBufferView(json, accessorName);\n      if (undefined === view)\n        return false;\n\n      const numIndices = new Uint32Array(1);\n      const niBytes = new Uint8Array(numIndices.buffer);\n      const index16 = new Uint16Array(1);\n      const i16Bytes = new Uint8Array(index16.buffer);\n      const index32 = new Uint32Array(1);\n      const i32Bytes = new Uint8Array(index32.buffer);\n\n      let ndx = 0;\n      for (let p = 0; p < view.count; ++p) {\n        for (let b = 0; b < 4; ++b)\n          niBytes[b] = view.data[ndx++];\n\n        if (!disjoint && numIndices[0] < 2)\n          continue;\n\n        const indices: number[] = new Array(numIndices[0]);\n\n        if (DataType.UnsignedShort === view.type) {\n          for (let i = 0; i < numIndices[0]; ++i) {\n            for (let b = 0; b < 2; ++b)\n              i16Bytes[b] = view.data[ndx++];\n            indices[i] = index16[0];\n          }\n          // Need to skip padding if we had an odd number of 16-bit indices.\n          if (0 !== numIndices[0] % 2)\n            ndx += 2;\n        } else if (DataType.UInt32 === view.type) {\n          for (let i = 0; i < numIndices[0]; ++i) {\n            for (let b = 0; b < 4; ++b)\n              i32Bytes[b] = view.data[ndx++];\n            indices[i] = index32[0];\n          }\n        }\n\n        polylines.push(new MeshPolyline(indices));\n      }\n\n      return true;\n    }\n\n    protected async loadTextures(): Promise<void> {\n      if (undefined === this._textures)\n        return Promise.resolve();\n\n      const transparentTextures: Set<string> = new Set<string>();\n      for (const name of Object.keys(this._materialValues)) {\n        const materialValue = this._materialValues[name];\n        let technique;\n        if (undefined !== materialValue.values &&\n          undefined !== materialValue.values.tex &&\n          undefined !== materialValue.technique &&\n          undefined !== (technique = this._techniques[materialValue.technique]) &&\n          undefined !== technique.states &&\n          Array.isArray(technique.states.enable)) {\n          for (const enable of technique.states.enable)\n            if (enable === 3042)\n              transparentTextures.add(materialValue.values.tex);\n        }\n      }\n\n      const promises = new Array<Promise<void>>();\n      for (const name of Object.keys(this._textures))\n        promises.push(this.loadTexture(name, transparentTextures.has(name)));\n\n      return promises.length > 0 ? Promise.all(promises).then((_) => undefined) : Promise.resolve();\n    }\n\n    protected async loadTextureImage(imageJson: any, samplerJson: any, isTransparent: boolean): Promise<RenderTexture | undefined> {\n      try {\n        const binaryImageJson = (imageJson.extensions && imageJson.extensions.KHR_binary_glTF) ? JsonUtils.asObject(imageJson.extensions.KHR_binary_glTF) : imageJson;\n        const bufferView = this._bufferViews[binaryImageJson.bufferView];\n        const mimeType = JsonUtils.asString(binaryImageJson.mimeType);\n        const format = getImageSourceFormatForMimeType(mimeType);\n        if (undefined === format)\n          return undefined;\n\n        let textureType = RenderTexture.Type.Normal;\n        if (undefined !== samplerJson &&\n          (undefined !== samplerJson.wrapS || undefined !== samplerJson.wrapS))\n          textureType = RenderTexture.Type.TileSection;\n        const textureParams = new RenderTexture.Params(undefined, textureType);\n        const offset = bufferView.byteOffset;\n\n        /* -----------------------------------\n            const jpegArray = this._binaryData.slice(offset, offset + bufferView.byteLength);\n            const jpegArrayBuffer = jpegArray.buffer;\n            const workerOp = new ImageDecodeWorkerOperation(jpegArrayBuffer, mimeType);\n            return Reader.webWorkerManager.queueOperation(workerOp)\n              .then((imageBitmap) => this._isCanceled ? undefined : this._system.createTextureFromImage(imageBitmap, isTransparent && ImageSourceFormat.Png === format, this._iModel, textureParams))\n              .catch((_) => undefined);\n          ------------------------------------- */\n\n        const bytes = this._binaryData.subarray(offset, offset + bufferView.byteLength);\n        const imageSource = new ImageSource(bytes, format);\n        return imageElementFromImageSource(imageSource)\n          .then((image) => this._isCanceled ? undefined : this._system.createTextureFromImage(image, isTransparent && ImageSourceFormat.Png === format, this._iModel, textureParams))\n          .catch((_) => undefined);\n      } catch (e) {\n        return undefined;\n      }\n    }\n\n    protected async loadTexture(textureId: string, isTransparent: boolean): Promise<void> {\n      const textureJson = JsonUtils.asObject(this._textures[textureId]);\n      if (undefined === textureJson)\n        return Promise.resolve();\n\n      return this.loadTextureImage(this._images[textureJson.source], undefined === this._samplers ? undefined : this._samplers[textureJson.sampler], isTransparent).then((texture) => {\n        textureJson.renderTexture = texture;\n      });\n    }\n\n    protected findTextureMapping(textureId: string): TextureMapping | undefined {\n      const textureJson = JsonUtils.asObject(this._textures[textureId]);\n      const texture = undefined !== textureJson ? textureJson.renderTexture as RenderTexture : undefined;\n      return undefined !== texture ? new TextureMapping(texture, new TextureMapping.Params()) : undefined;\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\nimport { TileIO } from \"./TileIO\";\nimport { GltfTileIO } from \"./GltfTileIO\";\nimport { ElementAlignedBox3d, FeatureTable, Feature, BatchType } from \"@bentley/imodeljs-common\";\nimport { Id64String, utf8ToString, JsonUtils } from \"@bentley/bentleyjs-core\";\nimport { InstancedGraphicParams, RenderSystem } from \"../render/System\";\nimport { Mesh } from \"../render/primitives/mesh/MeshPrimitives\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { Point3d, Vector3d, Matrix3d, AxisOrder } from \"@bentley/geometry-core\";\n\nfunction setTransform(transforms: Float32Array, index: number, rotation: Matrix3d, origin: Point3d): void {\n  const i = index * 12;\n  let rot = rotation.coffs;\n\n  const ignoreRotation = false;\n  if (ignoreRotation)\n    rot = new Float64Array([1, 0, 0, 0, 1, 0, 0, 0, 1]);\n\n  const ignoreOrigin = false;\n  if (ignoreOrigin)\n    origin.x = origin.y = origin.z = 0;\n\n  transforms[i + 0] = rot[0];\n  transforms[i + 1] = rot[1];\n  transforms[i + 2] = rot[2];\n  transforms[i + 3] = origin.x;\n\n  transforms[i + 4] = rot[3];\n  transforms[i + 5] = rot[4];\n  transforms[i + 6] = rot[5];\n  transforms[i + 7] = origin.y;\n\n  transforms[i + 8] = rot[6];\n  transforms[i + 9] = rot[7];\n  transforms[i + 10] = rot[8];\n  transforms[i + 11] = origin.z;\n}\n\n/**\n * Provides facilities for deserializing Batched 3D Model (B3dm) tiles.\n * @internal\n */\nexport namespace I3dmTileIO {\n  /** @internal */\n  export class Header extends TileIO.Header {\n    public readonly length: number;\n    public readonly featureTableJsonPosition: number;\n    public readonly featureTableJsonLength: number;\n    public readonly featureTableBinaryLength: number;\n    public readonly batchTableJsonLength: number;\n    public readonly batchTableBinaryLength: number;\n    public readonly gltfVersion: number;\n    public get isValid(): boolean { return TileIO.Format.I3dm === this.format; }\n\n    public constructor(stream: TileIO.StreamBuffer) {\n      super(stream);\n      this.length = stream.nextUint32;\n      this.featureTableJsonLength = stream.nextUint32;\n      this.featureTableBinaryLength = stream.nextUint32;\n      this.batchTableJsonLength = stream.nextUint32;\n      this.batchTableBinaryLength = stream.nextUint32;\n      this.gltfVersion = stream.nextUint32;\n      this.featureTableJsonPosition = stream.curPos;\n      stream.advance(this.featureTableJsonLength);\n      stream.advance(this.featureTableBinaryLength);\n      stream.advance(this.batchTableJsonLength);\n      stream.advance(this.batchTableBinaryLength);\n\n      if (stream.isPastTheEnd)\n        this.invalidate();\n    }\n  }\n\n  /**\n   * Deserializes a I3DM tile.\n   * @internal\n   */\n  export class Reader extends GltfTileIO.Reader {\n    public static create(stream: TileIO.StreamBuffer, iModel: IModelConnection, modelId: Id64String, is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem, yAxisUp: boolean, isLeaf: boolean, isCanceled?: GltfTileIO.IsCanceled): Reader | undefined {\n      const header = new Header(stream);\n      if (!header.isValid)\n        return undefined;\n\n      const props = GltfTileIO.ReaderProps.create(stream, yAxisUp);\n      stream.curPos = header.featureTableJsonPosition;\n      const featureStr = utf8ToString(stream.nextBytes(header.featureTableJsonLength));\n      if (undefined === featureStr)\n        return undefined;\n      const featureBinary = new Uint8Array(stream.arrayBuffer, header.featureTableJsonPosition + header.featureTableJsonLength, header.featureTableBinaryLength);\n      return undefined !== props ? new Reader(featureBinary, JSON.parse(featureStr), props, iModel, modelId, is3d, system, range, isLeaf, isCanceled) : undefined;\n    }\n\n    private constructor(private _featureBinary: Uint8Array, private _featureJson: any, props: GltfTileIO.ReaderProps, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, private _range: ElementAlignedBox3d, private _isLeaf: boolean, isCanceled?: GltfTileIO.IsCanceled) {\n      super(props, iModel, modelId, is3d, system, BatchType.Primary, isCanceled);\n    }\n\n    public async read(): Promise<GltfTileIO.ReaderResult> {\n      const skipI3dm = false; // for debugging\n      if (skipI3dm)\n        return Promise.resolve({ readStatus: TileIO.ReadStatus.Canceled, isLeaf: this._isLeaf });\n\n      // TBD... Create an actual feature table if one exists.  For now we are only reading tiles from scalable mesh which have no features.\n      // NB: For reality models with no batch table, we want the model ID in the feature table\n      const featureTable: FeatureTable = new FeatureTable(1, this._modelId, this._type);\n      const feature = new Feature(this._modelId);\n      featureTable.insert(feature);\n\n      await this.loadTextures();\n      if (this._isCanceled)\n        return Promise.resolve({ readStatus: TileIO.ReadStatus.Canceled, isLeaf: this._isLeaf });\n\n      const instances = this.readInstances();\n      if (undefined === instances)\n        return Promise.resolve({ readStatus: TileIO.ReadStatus.InvalidTileData, isLeaf: this._isLeaf });\n\n      return this.readGltfAndCreateGraphics(this._isLeaf, featureTable, this._range, undefined, undefined, instances);\n    }\n\n    protected readFeatures(features: Mesh.Features, _json: any): boolean {\n      const feature = new Feature(this._modelId);\n\n      features.add(feature, 1);\n      return true;\n    }\n\n    private readInstances(): InstancedGraphicParams | undefined {\n      const count = JsonUtils.asInt(this._featureJson.INSTANCES_LENGTH, 0);\n      if (count <= 0)\n        return undefined;\n\n      const json = this._featureJson;\n      const binary = this._featureBinary;\n\n      const positions = json.POSITION ? new Float32Array(binary.buffer, binary.byteOffset + json.POSITION.byteOffset, count * 3) : undefined;\n      const upNormals = json.NORMAL_UP ? new Float32Array(binary.buffer, binary.byteOffset + json.NORMAL_UP.byteOffset, count * 3) : undefined;\n      const rightNormals = json.NORMAL_RIGHT ? new Float32Array(binary.buffer, binary.byteOffset + json.NORMAL_RIGHT.byteOffset, count * 3) : undefined;\n      const scales = json.SCALE ? new Float32Array(binary.buffer, binary.byteOffset + json.SCALE.byteOffset, count) : undefined;\n      const nonUniformScales = json.SCALE_NON_UNIFORM ? new Float32Array(binary.buffer, binary.byteOffset + json.SCALE_NON_UNIFORM.byteOffset, count * 3) : undefined;\n\n      const matrix = Matrix3d.createIdentity();\n      const position = Point3d.createZero();\n      const upNormal = Vector3d.create(0, 0, 1);\n      const rightNormal = Vector3d.create(1, 0, 0);\n      const scale = Vector3d.create(1, 1, 1);\n\n      const transformCenter = this._range.center;\n      const transforms = new Float32Array(12 * count);\n      for (let i = 0; i < count; i++) {\n        const index = i * 3;\n        if (positions)\n          position.set(positions[index] - transformCenter.x, positions[index + 1] - transformCenter.y, positions[index + 2] - transformCenter.z);\n\n        if (upNormals || rightNormals) {\n          if (upNormals)\n            upNormal.set(upNormals[index], upNormals[index + 1], upNormals[index + 2]);\n\n          if (rightNormals)\n            rightNormal.set(rightNormals[index], rightNormals[index + 1], rightNormals[index + 2]);\n\n          if (scales)\n            scale.x = scale.y = scale.z = scales[i];\n\n          if (nonUniformScales) {\n            scale.x *= nonUniformScales[index + 0];\n            scale.y *= nonUniformScales[index + 1];\n            scale.z *= nonUniformScales[index + 2];\n          }\n\n          Matrix3d.createRigidFromColumns(rightNormal, upNormal, AxisOrder.XYZ, matrix);\n          if (scales || nonUniformScales)\n            matrix.scaleColumnsInPlace(scale.x, scale.y, scale.z);\n\n          setTransform(transforms, i, matrix, position);\n        }\n      }\n\n      // ###TODO_INSTANCING: Use actual feature IDs if feature table exists\n      const featureIds = undefined;\n      const symbologyOverrides = undefined;\n\n      return { count, transforms, symbologyOverrides, featureIds, transformCenter };\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Tile */\r\n\r\nimport {\r\n  assert,\r\n  Id64String,\r\n} from \"@bentley/bentleyjs-core\";\r\nimport {\r\n  BatchType,\r\n  TileProps,\r\n  ViewFlag,\r\n} from \"@bentley/imodeljs-common\";\r\nimport {\r\n  Tile,\r\n  TileLoader,\r\n  bisectRange2d,\r\n  bisectRange3d,\r\n} from \"./TileTree\";\r\nimport {\r\n  TileRequest,\r\n} from \"./TileRequest\";\r\nimport {\r\n  IModelApp,\r\n} from \"../IModelApp\";\r\nimport {\r\n  IModelConnection,\r\n} from \"../IModelConnection\";\r\n\r\n/** Contains facilities for deserializing tiles in iMdl format - Bentley's internal format for representing 3d tiles\r\n * generated by the backend from the contents of geometric models. iMdl shares some similarities with glTF, but a quite\r\n * different representation of geometry and materials.\r\n * @internal\r\n */\r\nexport namespace IModelTile {\r\n  /** Flags controlling how tile content is produced. The flags are part of the ContentId.\r\n   * @internal\r\n   */\r\n  const enum ContentFlags {\r\n    None = 0,\r\n    AllowInstancing = 1 << 0,\r\n    All = AllowInstancing,\r\n  }\r\n\r\n  /** Describes the components of a tile's content Id.\r\n   *\r\n   * The depth specifies how many subdivisions from the root tile are to be performed to reach the sub-volume of interest.\r\n   *\r\n   * The i, j, and k parameters specify how to subdivide the tile's volume. Each sub-division is performed along the longest axis of the\r\n   * volume. The volume is first sub-divided based on `i`, then the result sub-divided based on `j`, and finally that result sub-divided\r\n   * based on `k`.\r\n   *\r\n   * The multiplier is an integer - generally a power of two - multiplied by the screen size of a tile (512 pixels) used to\r\n   * produce a higher-resolution tile for the same volume.\r\n   * @internal\r\n   */\r\n  interface ContentIdSpec {\r\n    depth: number;\r\n    i: number;\r\n    j: number;\r\n    k: number;\r\n    multiplier: number;\r\n  }\r\n\r\n  /** Contains logic for working with tile content Ids according to a specific content Id scheme. Which scheme is used depends on\r\n   * the major version of the tile format.\r\n   * @internal\r\n   */\r\n  abstract class ContentIdProvider {\r\n    public get rootContentId(): string {\r\n      return this.computeId(0, 0, 0, 0, 1);\r\n    }\r\n\r\n    public idFromParentAndMultiplier(parentId: string, multiplier: number): string {\r\n      const lastSepPos = parentId.lastIndexOf(this._separator);\r\n      assert(-1 !== lastSepPos);\r\n      return parentId.substring(0, lastSepPos + 1) + multiplier.toString(16);\r\n    }\r\n\r\n    public specFromId(id: string): ContentIdSpec {\r\n      const parts = id.split(this._separator);\r\n      const len = parts.length;\r\n      assert(len >= 5);\r\n      return {\r\n        depth: parseInt(parts[len - 5], 16),\r\n        i: parseInt(parts[len - 4], 16),\r\n        j: parseInt(parts[len - 3], 16),\r\n        k: parseInt(parts[len - 2], 16),\r\n        multiplier: parseInt(parts[len - 1], 16),\r\n      };\r\n    }\r\n\r\n    public idFromSpec(spec: ContentIdSpec): string {\r\n      return this.computeId(spec.depth, spec.i, spec.j, spec.k, spec.multiplier);\r\n    }\r\n\r\n    protected join(depth: number, i: number, j: number, k: number, mult: number): string {\r\n      const sep = this._separator;\r\n      return depth.toString(16) + sep + i.toString(16) + sep + j.toString(16) + sep + k.toString(16) + sep + mult.toString(16);\r\n    }\r\n\r\n    protected abstract get _separator(): string;\r\n    protected abstract computeId(depth: number, i: number, j: number, k: number, mult: number): string;\r\n\r\n    /** formatVersion is the maximum major version supported by the back-end supplying the tile tree.\r\n     * Must ensure front-end does not request tiles of a format the back-end cannot supply, and back-end does\r\n     * not supply tiles of a format the front-end doesn't recognize.\r\n     */\r\n    public static create(allowInstancing: boolean, formatVersion?: number): ContentIdProvider {\r\n      const majorVersion = IModelApp.tileAdmin.getMaximumMajorTileFormatVersion(formatVersion);\r\n      assert(majorVersion > 0);\r\n      assert(Math.floor(majorVersion) === majorVersion);\r\n      switch (majorVersion) {\r\n        case 0:\r\n        case 1:\r\n          return new ContentIdV1Provider();\r\n        case 2:\r\n        case 3:\r\n          return new ContentIdV2Provider(majorVersion, allowInstancing);\r\n        default:\r\n          return new ContentIdV4Provider(allowInstancing);\r\n      }\r\n    }\r\n  }\r\n\r\n  /** The original (major version 1) tile format used a content Id scheme of the format\r\n   * `depth/i/j/k/multiplier`.\r\n   * @internal\r\n   */\r\n  class ContentIdV1Provider extends ContentIdProvider {\r\n    protected get _separator() { return \"/\"; }\r\n    protected computeId(depth: number, i: number, j: number, k: number, mult: number): string {\r\n      return this.join(depth, i, j, k, mult);\r\n    }\r\n  }\r\n\r\n  /** Tile formats 2 and 3 use a content Id scheme encoding styling flags and the major format version\r\n   * into the content Id, of the format `_majorVersion_flags_depth_i_j_k_multiplier`.\r\n   * @internal\r\n   */\r\n  class ContentIdV2Provider extends ContentIdProvider {\r\n    private readonly _prefix: string;\r\n\r\n    public constructor(majorVersion: number, allowInstancing: boolean) {\r\n      super();\r\n      const flags = (allowInstancing && IModelApp.tileAdmin.enableInstancing) ? ContentFlags.AllowInstancing : ContentFlags.None;\r\n      this._prefix = this._separator + majorVersion.toString(16) + this._separator + flags.toString(16) + this._separator;\r\n    }\r\n\r\n    protected get _separator() { return \"_\"; }\r\n    protected computeId(depth: number, i: number, j: number, k: number, mult: number): string {\r\n      return this._prefix + this.join(depth, i, j, k, mult);\r\n    }\r\n  }\r\n\r\n  /** Tile formats 4+ encode styling flags but not major format version. (The version is specified by the tile tree's Id).\r\n   * Format: `-flags-depth-i-j-k-multiplier`.\r\n   * @internal\r\n   */\r\n  class ContentIdV4Provider extends ContentIdProvider {\r\n    private readonly _prefix: string;\r\n\r\n    public constructor(allowInstancing: boolean) {\r\n      super();\r\n      const flags = (allowInstancing && IModelApp.tileAdmin.enableInstancing) ? ContentFlags.AllowInstancing : ContentFlags.None;\r\n      this._prefix = this._separator + flags.toString(16) + this._separator;\r\n    }\r\n\r\n    protected get _separator() { return \"-\"; }\r\n    protected computeId(depth: number, i: number, j: number, k: number, mult: number): string {\r\n      return this._prefix + this.join(depth, i, j, k, mult);\r\n    }\r\n  }\r\n\r\n  /** @internal */\r\n  export interface PrimaryTreeId {\r\n    type: BatchType.Primary;\r\n    edgesRequired: boolean;\r\n    animationId?: Id64String;\r\n  }\r\n\r\n  /** @internal */\r\n  export interface ClassifierTreeId {\r\n    type: BatchType.VolumeClassifier | BatchType.PlanarClassifier;\r\n    expansion: number;\r\n  }\r\n\r\n  /** Describes the Id of an iModel TileTree.\r\n   * @internal\r\n   */\r\n  export type TreeId = PrimaryTreeId | ClassifierTreeId;\r\n\r\n  /** @internal */\r\n  export function treeIdToString(modelId: Id64String, treeId: TreeId): string {\r\n    let idStr = \"\";\r\n    const admin = IModelApp.tileAdmin;\r\n    const version = admin.getMaximumMajorTileFormatVersion();\r\n    if (version >= 4) {\r\n      const useProjectExtents = admin.useProjectExtents || BatchType.VolumeClassifier === treeId.type;\r\n      const flags = useProjectExtents ? \"_1-\" : \"_0-\";\r\n      idStr = version.toString() + flags;\r\n    }\r\n\r\n    if (BatchType.Primary === treeId.type) {\r\n      if (undefined !== treeId.animationId)\r\n        idStr = idStr + \"A:\" + treeId.animationId + \"_\";\r\n\r\n      if (!treeId.edgesRequired) {\r\n        // Tell backend not to bother generating+returning edges - we would just discard them anyway\r\n        idStr = idStr + \"E:0_\";\r\n      }\r\n    } else {\r\n      const typeStr = BatchType.PlanarClassifier === treeId.type ? \"CP\" : \"C\";\r\n      idStr = idStr + typeStr + \":\" + treeId.expansion.toFixed(6) + \"_\";\r\n    }\r\n\r\n    return idStr + modelId;\r\n  }\r\n\r\n  /** @internal */\r\n  export class Loader extends TileLoader {\r\n    private _iModel: IModelConnection;\r\n    private _type: BatchType;\r\n    private _edgesRequired: boolean;\r\n    private readonly _contentIdProvider: ContentIdProvider;\r\n    protected get _batchType() { return this._type; }\r\n    protected get _loadEdges(): boolean { return this._edgesRequired; }\r\n\r\n    public constructor(iModel: IModelConnection, formatVersion: number | undefined, batchType: BatchType, edgesRequired: boolean, allowInstancing: boolean) {\r\n      super();\r\n      this._iModel = iModel;\r\n      this._type = batchType;\r\n      this._edgesRequired = edgesRequired;\r\n      this._contentIdProvider = ContentIdProvider.create(allowInstancing, formatVersion);\r\n    }\r\n\r\n    public get maxDepth(): number { return 32; }  // Can be removed when element tile selector is working.\r\n    public get priority(): Tile.LoadPriority { return (BatchType.VolumeClassifier === this._batchType || BatchType.PlanarClassifier === this._batchType) ? Tile.LoadPriority.Classifier : Tile.LoadPriority.Primary; }\r\n    public tileRequiresLoading(params: Tile.Params): boolean { return 0 !== params.maximumSize; }\r\n    public get rootContentId(): string { return this._contentIdProvider.rootContentId; }\r\n\r\n    protected static _viewFlagOverrides = new ViewFlag.Overrides();\r\n    public get viewFlagOverrides() { return Loader._viewFlagOverrides; }\r\n\r\n    public async getChildrenProps(parent: Tile): Promise<TileProps[]> {\r\n      const kids: TileProps[] = [];\r\n\r\n      // Leaf nodes have no children.\r\n      if (parent.isLeaf)\r\n        return kids;\r\n\r\n      // One child, same range as parent, higher-resolution.\r\n      if (parent.hasSizeMultiplier) {\r\n        const sizeMultiplier = parent.sizeMultiplier * 2;\r\n        const contentId = this._contentIdProvider.idFromParentAndMultiplier(parent.contentId, sizeMultiplier);\r\n        kids.push({\r\n          contentId,\r\n          range: parent.range,\r\n          contentRange: parent.contentRange,\r\n          sizeMultiplier,\r\n          isLeaf: false,\r\n          maximumSize: 512,\r\n        });\r\n\r\n        return kids;\r\n      }\r\n\r\n      // Sub-divide parent's range into 4 (for 2d trees) or 8 (for 3d trees) child tiles.\r\n      const parentSpec = this._contentIdProvider.specFromId(parent.contentId);\r\n      assert(parent.depth === parentSpec.depth);\r\n\r\n      const childSpec: ContentIdSpec = { ...parentSpec };\r\n      childSpec.depth = parent.depth + 1;\r\n\r\n      // This mask is a bitfield in which an 'on' bit indicates sub-volume containing no geometry.\r\n      // Don't bother creating children or requesting content for such empty volumes.\r\n      const admin = IModelApp.tileAdmin;\r\n      const emptyMask = parent.emptySubRangeMask;\r\n\r\n      // Spatial tree range == project extents; content range == model range.\r\n      // Trivially reject children whose ranges are entirely outside model range.\r\n      let treeContentRange = parent.root.contentRange;\r\n      if (undefined !== treeContentRange && treeContentRange.containsRange(parent.range)) {\r\n        // Parent is wholly within model range - don't bother testing child ranges against it.\r\n        treeContentRange = undefined;\r\n      }\r\n\r\n      const is2d = parent.root.is2d;\r\n      const bisectRange = is2d ? bisectRange2d : bisectRange3d;\r\n      for (let i = 0; i < 2; i++) {\r\n        for (let j = 0; j < 2; j++) {\r\n          for (let k = 0; k < (is2d ? 1 : 2); k++) {\r\n            const emptyBit = 1 << (i + j * 2 + k * 4);\r\n            if (0 !== (emptyMask & emptyBit)) {\r\n              // volume is known to contain no geometry.\r\n              admin.onTileElided();\r\n              continue;\r\n            }\r\n\r\n            const range = parent.range.clone();\r\n            bisectRange(range, 0 === i);\r\n            bisectRange(range, 0 === j);\r\n            if (!is2d)\r\n              bisectRange(range, 0 === k);\r\n\r\n            if (undefined !== treeContentRange && !range.intersectsRange(treeContentRange)) {\r\n              // volume is within project extents but entirely outside model range\r\n              admin.onTileElided();\r\n              continue;\r\n            }\r\n\r\n            childSpec.i = parentSpec.i * 2 + i;\r\n            childSpec.j = parentSpec.j * 2 + j;\r\n            childSpec.k = parentSpec.k * 2 + k;\r\n\r\n            const childId = this._contentIdProvider.idFromSpec(childSpec);\r\n            kids.push({ contentId: childId, range, maximumSize: 512 });\r\n          }\r\n        }\r\n      }\r\n\r\n      return kids;\r\n    }\r\n\r\n    public async requestTileContent(tile: Tile): Promise<TileRequest.Response> {\r\n      return this._iModel.tiles.getTileContent(tile.root.id, tile.contentId);\r\n    }\r\n\r\n    public adjustContentIdSizeMultiplier(contentId: string, sizeMultiplier: number): string {\r\n      return this._contentIdProvider.idFromParentAndMultiplier(contentId, sizeMultiplier);\r\n    }\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\n\nimport { TileIO } from \"./TileIO\";\nimport { GltfTileIO } from \"./GltfTileIO\";\nimport { DisplayParams } from \"../render/primitives/DisplayParams\";\nimport {\n  VertexTable,\n  VertexIndices,\n  PointStringParams,\n  TesselatedPolyline,\n  PolylineParams,\n  SurfaceParams,\n  SurfaceType,\n  isValidSurfaceType,\n  MeshParams,\n  SegmentEdgeParams,\n  SilhouetteParams,\n  EdgeParams,\n} from \"../render/primitives/VertexTable\";\nimport {\n  AuxChannelTable,\n  AuxChannelTableProps,\n} from \"../render/primitives/AuxChannelTable\";\nimport { Id64String, JsonUtils, assert } from \"@bentley/bentleyjs-core\";\nimport { InstancedGraphicParams, RenderSystem, RenderGraphic, PackedFeatureTable, GraphicBranch } from \"../render/System\";\nimport { imageElementFromImageSource } from \"../ImageUtil\";\nimport {\n  ElementAlignedBox3d,\n  FillFlags,\n  ColorDef,\n  LinePixels,\n  TextureMapping,\n  ImageSource,\n  ImageSourceFormat,\n  RenderTexture,\n  RenderMaterial,\n  Gradient,\n  QParams2d,\n  QParams3d,\n  PolylineTypeFlags,\n  BatchType,\n} from \"@bentley/imodeljs-common\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { Mesh } from \"../render/primitives/mesh/MeshPrimitives\";\nimport { Range2d, Point3d, Range3d, Transform } from \"@bentley/geometry-core\";\n\n// tslint:disable:no-const-enum\n\n/** Provides facilities for deserializing tiles in 'imodel' format. These tiles contain element geometry encoded into a format optimized for the imodeljs webgl renderer.\n * @internal\n */\nexport namespace IModelTileIO {\n  /** Flags describing the geometry contained within a tile.\n   * @internal\n   */\n  export const enum Flags {\n    /** No special flags */\n    None = 0,\n    /** The tile contains some curved geometry */\n    ContainsCurves = 1 << 0,\n    /** Some geometry within the tile range was omitted based on its size */\n    Incomplete = 1 << 2,\n  }\n\n  /** Describes the maximum major and minor version of the tile format supported by this front-end package.\n   * @internal\n   */\n  export const enum CurrentVersion {\n    /** The unsigned 16-bit major version number. If the major version specified in the tile header is greater than this value, then this\n     * front-end is not capable of reading the tile content. Otherwise, this front-end can read the tile content even if the header specifies a\n     * greater minor version than CurrentVersion.Minor, although some data may be skipped.\n     */\n    Major = 4,\n    /** The unsigned 16-bit minor version number. If the major version in the tile header is equal to CurrentVersion.Major, then this front-end can\n     * read the tile content even if the minor version in the tile header is greater than this value, although some data may be skipped.\n     */\n    Minor = 0,\n    /** The unsigned 32-bit version number derived from the 16-bit major and minor version numbers. */\n    Combined = (Major << 0x10) | Minor,\n  }\n\n  /** Header embedded at the beginning of the binary tile data describing its contents.\n   * @internal\n   */\n  export class Header extends TileIO.Header {\n    /** The size of this header in bytes. */\n    public readonly headerLength: number;\n    /** Flags describing the geometry contained within the tile */\n    public readonly flags: Flags;\n    /** A bounding box no larger than the tile's range, tightly enclosing the tile's geometry; or a null range if the tile is empty */\n    public readonly contentRange: ElementAlignedBox3d;\n    /** The chord tolerance in meters at which the tile's geometry was faceted */\n    public readonly tolerance: number;\n    /** The number of elements which contributed at least some geometry to the tile content */\n    public readonly numElementsIncluded: number;\n    /** The number of elements within the tile range which contributed no geometry to the tile content */\n    public readonly numElementsExcluded: number;\n    /** The total number of bytes in the binary tile data, including this header */\n    public readonly tileLength: number;\n    /** A bitfield wherein each set bit indicates an empty sub-volume. */\n    public readonly emptySubRanges: number;\n\n    public get versionMajor(): number { return this.version >>> 0x10; }\n    public get versionMinor(): number { return (this.version & 0xffff) >>> 0; }\n\n    public get isValid(): boolean { return TileIO.Format.IModel === this.format; }\n    public get isReadableVersion(): boolean { return this.versionMajor <= IModelTileIO.CurrentVersion.Major; }\n\n    /** Deserialize a header from the binary data at the stream's current position.\n     * If the binary data does not contain a valid header, the Header will be marked 'invalid'.\n     */\n    public constructor(stream: TileIO.StreamBuffer) {\n      super(stream);\n      this.headerLength = stream.nextUint32;\n      this.flags = stream.nextUint32;\n\n      // NB: Cannot use any of the static create*() functions because they all want to compute a range to contain the supplied points.\n      // (If contentRange is null, this will produce maximum range).\n      this.contentRange = new Range3d();\n      this.contentRange.low = stream.nextPoint3d64;\n      this.contentRange.high = stream.nextPoint3d64;\n\n      this.tolerance = stream.nextFloat64;\n      this.numElementsIncluded = stream.nextUint32;\n      this.numElementsExcluded = stream.nextUint32;\n      this.tileLength = stream.nextUint32;\n\n      // empty sub-volume bit field introduced in format v02.00\n      this.emptySubRanges = this.versionMajor >= 2 ? stream.nextUint32 : 0;\n\n      // Skip any unprocessed bytes in header\n      const remainingHeaderBytes = this.headerLength - stream.curPos;\n      assert(remainingHeaderBytes >= 0);\n      stream.advance(remainingHeaderBytes);\n\n      if (stream.isPastTheEnd)\n        this.invalidate();\n    }\n  }\n\n  /** @internal */\n  class FeatureTableHeader {\n    public static readFrom(stream: TileIO.StreamBuffer) {\n      const length = stream.nextUint32;\n      const maxFeatures = stream.nextUint32;\n      const count = stream.nextUint32;\n      return stream.isPastTheEnd ? undefined : new FeatureTableHeader(length, maxFeatures, count);\n    }\n\n    public static sizeInBytes = 12;\n\n    private constructor(public readonly length: number,\n      public readonly maxFeatures: number,\n      public readonly count: number) { }\n  }\n\n  const maxLeafTolerance = 1.0;\n  const minElementsPerTile = 100;\n\n  /** Deserializes an iModel tile.\n   * @internal\n   */\n  export class Reader extends GltfTileIO.Reader {\n    private readonly _sizeMultiplier?: number;\n    private readonly _loadEdges: boolean;\n\n    /** Attempt to initialize a Reader to deserialize iModel tile data beginning at the stream's current position. */\n    public static create(stream: TileIO.StreamBuffer, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, type: BatchType = BatchType.Primary, loadEdges: boolean = true, isCanceled?: GltfTileIO.IsCanceled, sizeMultiplier?: number): Reader | undefined {\n      const header = new Header(stream);\n      if (!header.isValid || !header.isReadableVersion)\n        return undefined;\n\n      // The feature table follows the iMdl header\n      if (!this.skipFeatureTable(stream))\n        return undefined;\n\n      // A glTF header follows the feature table\n      const props = GltfTileIO.ReaderProps.create(stream, false);\n      return undefined !== props ? new Reader(props, iModel, modelId, is3d, system, type, loadEdges, isCanceled, sizeMultiplier) : undefined;\n    }\n\n    /** Attempt to deserialize the tile data */\n    public async read(): Promise<GltfTileIO.ReaderResult> {\n      this._buffer.reset();\n      const header = new Header(this._buffer);\n      let isLeaf = true;\n      if (!header.isValid)\n        return { readStatus: TileIO.ReadStatus.InvalidHeader, isLeaf };\n      else if (!header.isReadableVersion)\n        return { readStatus: TileIO.ReadStatus.NewerMajorVersion, isLeaf };\n\n      const featureTable = this.readFeatureTable();\n      if (undefined === featureTable)\n        return { readStatus: TileIO.ReadStatus.InvalidFeatureTable, isLeaf };\n\n      // Textures must be loaded asynchronously first...\n      await this.loadNamedTextures();\n      if (this._isCanceled)\n        return Promise.resolve({ readStatus: TileIO.ReadStatus.Canceled, isLeaf });\n\n      // Determine subdivision based on header data\n      isLeaf = false;\n      let sizeMultiplier = this._sizeMultiplier;\n      const completeTile = 0 === (header.flags & IModelTileIO.Flags.Incomplete);\n      const emptyTile = completeTile && 0 === header.numElementsIncluded && 0 === header.numElementsExcluded;\n      if (emptyTile || this._isVolumeClassifier) {    // Classifier algorithm currently supports only a single tile.\n        isLeaf = true;\n      } else {\n        // Non-spatial (2d) models are of arbitrary scale and contain geometry like line work and especially text which\n        // can be adversely affected by quantization issues when zooming in closely.\n        const canSkipSubdivision = this._is3d && header.tolerance <= maxLeafTolerance;\n        if (canSkipSubdivision) {\n          if (completeTile && 0 === header.numElementsExcluded && header.numElementsIncluded <= minElementsPerTile) {\n            const containsCurves = 0 !== (header.flags & IModelTileIO.Flags.ContainsCurves);\n            if (!containsCurves)\n              isLeaf = true;\n            else if (undefined === sizeMultiplier)\n              sizeMultiplier = 1.0;\n          } else if (undefined === sizeMultiplier && header.numElementsIncluded + header.numElementsExcluded <= minElementsPerTile) {\n            sizeMultiplier = 1.0;\n          }\n        }\n      }\n\n      return Promise.resolve(this.finishRead(isLeaf, featureTable, header.contentRange, header.emptySubRanges, sizeMultiplier));\n    }\n\n    /** @internal */\n    protected extractReturnToCenter(_extensions: any): number[] | undefined { return undefined; }\n\n    /** @internal */\n    protected createDisplayParams(json: any): DisplayParams | undefined {\n      const type = JsonUtils.asInt(json.type, DisplayParams.Type.Mesh);\n      const lineColor = new ColorDef(JsonUtils.asInt(json.lineColor));\n      const fillColor = new ColorDef(JsonUtils.asInt(json.fillColor));\n      const width = JsonUtils.asInt(json.lineWidth);\n      const linePixels = JsonUtils.asInt(json.linePixels, LinePixels.Solid);\n      const fillFlags = JsonUtils.asInt(json.fillFlags, FillFlags.None);\n      const ignoreLighting = JsonUtils.asBool(json.ignoreLighting);\n\n      // Material will always contain its own texture if it has one\n      const materialKey = json.materialId;\n      const material = undefined !== materialKey ? this.materialFromJson(materialKey) : undefined;\n\n      // We will only attempt to include the texture if material is undefined\n      let textureMapping;\n      if (!material) {\n        const textureJson = json.texture;\n        textureMapping = undefined !== textureJson ? this.textureMappingFromJson(textureJson) : undefined;\n\n        if (undefined === textureMapping) {\n          // Look for a gradient. If defined, create a texture mapping. No reason to pass the Gradient.Symb to the DisplayParams once we have the texture.\n          const gradientProps = json.gradient as Gradient.SymbProps;\n          const gradient = undefined !== gradientProps ? Gradient.Symb.fromJSON(gradientProps) : undefined;\n          if (undefined !== gradient) {\n            const texture = this._system.getGradientTexture(gradient, this._iModel);\n            if (undefined !== texture) {\n              // ###TODO: would be better if DisplayParams created the TextureMapping - but that requires an IModelConnection and a RenderSystem...\n              textureMapping = new TextureMapping(texture, new TextureMapping.Params({ textureMat2x3: new TextureMapping.Trans2x3(0, 1, 0, 1, 0, 0) }));\n            }\n          }\n        }\n      }\n\n      return new DisplayParams(type, lineColor, fillColor, width, linePixels, fillFlags, material, undefined, ignoreLighting, textureMapping);\n    }\n\n    /** @internal */\n    protected colorDefFromMaterialJson(json: any): ColorDef | undefined {\n      return undefined !== json ? ColorDef.from(json[0] * 255 + 0.5, json[1] * 255 + 0.5, json[2] * 255 + 0.5) : undefined;\n    }\n\n    /** @internal */\n    protected materialFromJson(key: string): RenderMaterial | undefined {\n      if (this._renderMaterials === undefined || this._renderMaterials[key] === undefined)\n        return undefined;\n\n      let material = this._system.findMaterial(key, this._iModel);\n      if (!material) {\n        const materialJson = this._renderMaterials[key];\n\n        const materialParams = new RenderMaterial.Params(key);\n        materialParams.diffuseColor = this.colorDefFromMaterialJson(materialJson.diffuseColor);\n        if (materialJson.diffuse !== undefined)\n          materialParams.diffuse = JsonUtils.asDouble(materialJson.diffuse);\n        materialParams.specularColor = this.colorDefFromMaterialJson(materialJson.specularColor);\n        if (materialJson.specular !== undefined)\n          materialParams.specular = JsonUtils.asDouble(materialJson.specular);\n        materialParams.reflectColor = this.colorDefFromMaterialJson(materialJson.reflectColor);\n        if (materialJson.reflect !== undefined)\n          materialParams.reflect = JsonUtils.asDouble(materialJson.reflect);\n\n        if (materialJson.specularExponent !== undefined)\n          materialParams.specularExponent = materialJson.specularExponent;\n        if (materialJson.transparency !== undefined)\n          materialParams.transparency = materialJson.transparency;\n        materialParams.refract = JsonUtils.asDouble(materialJson.refract);\n        materialParams.shadows = JsonUtils.asBool(materialJson.shadows);\n        materialParams.ambient = JsonUtils.asDouble(materialJson.ambient);\n\n        if (undefined !== materialJson.textureMapping)\n          materialParams.textureMapping = this.textureMappingFromJson(materialJson.textureMapping.texture);\n\n        material = this._system.createMaterial(materialParams, this._iModel);\n      }\n\n      return material;\n    }\n\n    private textureMappingFromJson(json: any): TextureMapping | undefined {\n      if (undefined === json)\n        return undefined;\n\n      const name = JsonUtils.asString(json.name);\n      const namedTex = 0 !== name.length ? this._namedTextures[name] : undefined;\n      const texture = undefined !== namedTex ? namedTex.renderTexture as RenderTexture : undefined;\n      if (undefined === texture) {\n        assert(false, \"bad texture mapping json\");\n        return undefined;\n      }\n\n      const paramsJson = json.params;\n      const tf = paramsJson.transform;\n      const paramProps: TextureMapping.ParamProps = {\n        textureMat2x3: new TextureMapping.Trans2x3(tf[0][0], tf[0][1], tf[0][2], tf[1][0], tf[1][1], tf[1][2]),\n        textureWeight: JsonUtils.asDouble(paramsJson.weight, 1.0),\n        mapMode: JsonUtils.asInt(paramsJson.mode),\n        worldMapping: JsonUtils.asBool(paramsJson.worldMapping),\n      };\n\n      return new TextureMapping(texture, new TextureMapping.Params(paramProps));\n    }\n\n    private async loadNamedTextures(): Promise<void> {\n      if (undefined === this._namedTextures)\n        return Promise.resolve();\n\n      const promises = new Array<Promise<void>>();\n      for (const name of Object.keys(this._namedTextures))\n        promises.push(this.loadNamedTexture(name));\n\n      return promises.length > 0 ? Promise.all(promises).then((_) => undefined) : Promise.resolve();\n    }\n\n    private async loadNamedTexture(name: string): Promise<void> {\n      if (this._isCanceled)\n        return Promise.resolve();\n\n      const namedTex = this._namedTextures[name];\n      assert(undefined !== namedTex); // we got here by iterating the keys of this.namedTextures...\n      if (undefined === namedTex)\n        return Promise.resolve();\n\n      const texture = this._system.findTexture(name, this._iModel);\n      if (undefined !== texture) {\n        namedTex.renderTexture = texture;\n        return Promise.resolve();\n      }\n\n      return this.readNamedTexture(namedTex, name).then((result) => { namedTex.renderTexture = result; });\n    }\n\n    private async readNamedTexture(namedTex: any, name: string): Promise<RenderTexture | undefined> {\n      const bufferViewId = JsonUtils.asString(namedTex.bufferView);\n      const bufferViewJson = 0 !== bufferViewId.length ? this._bufferViews[bufferViewId] : undefined;\n      if (undefined === bufferViewJson)\n        return Promise.resolve(undefined);\n\n      const byteOffset = JsonUtils.asInt(bufferViewJson.byteOffset);\n      const byteLength = JsonUtils.asInt(bufferViewJson.byteLength);\n      if (0 === byteLength)\n        return Promise.resolve(undefined);\n\n      const bytes = this._binaryData.subarray(byteOffset, byteOffset + byteLength);\n      const format = namedTex.format;\n      const imageSource = new ImageSource(bytes, format);\n\n      return imageElementFromImageSource(imageSource).then((image) => {\n        if (this._isCanceled)\n          return undefined;\n\n        let textureType = RenderTexture.Type.Normal;\n        if (JsonUtils.asBool(namedTex.isGlyph))\n          textureType = RenderTexture.Type.Glyph;\n        else if (JsonUtils.asBool(namedTex.isTileSection))\n          textureType = RenderTexture.Type.TileSection;\n\n        const params = new RenderTexture.Params(namedTex.isGlyph ? undefined : name, textureType);\n        return this._system.createTextureFromImage(image, ImageSourceFormat.Png === format, this._iModel, params);\n      });\n    }\n\n    /** @internal */\n    protected readFeatureTable(): PackedFeatureTable | undefined {\n      const startPos = this._buffer.curPos;\n      const header = FeatureTableHeader.readFrom(this._buffer);\n      if (undefined === header || 0 !== header.length % 4)\n        return undefined;\n\n      // NB: We make a copy of the sub-array because we don't want to pin the entire data array in memory.\n      const numUint32s = (header.length - FeatureTableHeader.sizeInBytes) / 4;\n      const packedFeatureArray = new Uint32Array(this._buffer.nextUint32s(numUint32s));\n      if (this._buffer.isPastTheEnd)\n        return undefined;\n\n      let animNodesArray: Uint8Array | Uint16Array | Uint32Array | undefined;\n      const animationNodes = JsonUtils.asObject(this._scene.animationNodes);\n      if (undefined !== animationNodes) {\n        const bytesPerId = JsonUtils.asInt(animationNodes.bytesPerId);\n        const bufferViewId = JsonUtils.asString(animationNodes.bufferView);\n        const bufferViewJson = this._bufferViews[bufferViewId];\n        if (undefined !== bufferViewJson) {\n          const byteOffset = JsonUtils.asInt(bufferViewJson.byteOffset);\n          const byteLength = JsonUtils.asInt(bufferViewJson.byteLength);\n          const bytes = this._binaryData.subarray(byteOffset, byteOffset + byteLength);\n          switch (bytesPerId) {\n            case 1:\n              animNodesArray = new Uint8Array(bytes);\n              break;\n            case 2:\n              // NB: A *copy* of the subarray.\n              animNodesArray = Uint16Array.from(new Uint16Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 2));\n              break;\n            case 4:\n              // NB: A *copy* of the subarray.\n              animNodesArray = Uint32Array.from(new Uint32Array(bytes.buffer, bytes.byteOffset, bytes.byteLength / 4));\n              break;\n          }\n        }\n      }\n\n      this._buffer.curPos = startPos + header.length;\n\n      return new PackedFeatureTable(packedFeatureArray, this._modelId, header.count, header.maxFeatures, this._type, animNodesArray);\n    }\n\n    private constructor(props: GltfTileIO.ReaderProps, iModel: IModelConnection, modelId: Id64String, is3d: boolean, system: RenderSystem, type: BatchType, loadEdges: boolean, isCanceled?: GltfTileIO.IsCanceled, sizeMultiplier?: number) {\n      super(props, iModel, modelId, is3d, system, type, isCanceled);\n      this._sizeMultiplier = sizeMultiplier;\n      this._loadEdges = loadEdges;\n    }\n\n    private static skipFeatureTable(stream: TileIO.StreamBuffer): boolean {\n      const startPos = stream.curPos;\n      const header = FeatureTableHeader.readFrom(stream);\n      if (undefined !== header)\n        stream.curPos = startPos + header.length;\n\n      return undefined !== header;\n    }\n\n    private readMeshGraphic(primitive: any): RenderGraphic | undefined {\n      const materialName = JsonUtils.asString(primitive.material);\n      const materialValue = 0 < materialName.length ? JsonUtils.asObject(this._materialValues[materialName]) : undefined;\n      const displayParams = undefined !== materialValue ? this.createDisplayParams(materialValue) : undefined;\n      if (undefined === displayParams)\n        return undefined;\n\n      const vertices = this.readVertexTable(primitive);\n      if (undefined === vertices) {\n        assert(false, \"bad vertex table in tile data.\");\n        return undefined;\n      }\n\n      const isPlanar = JsonUtils.asBool(primitive.isPlanar);\n      const primitiveType = JsonUtils.asInt(primitive.type, Mesh.PrimitiveType.Mesh);\n      const instances = this.readInstances(primitive);\n      switch (primitiveType) {\n        case Mesh.PrimitiveType.Mesh:\n          return this.createMeshGraphic(primitive, displayParams, vertices, isPlanar, this.readAuxChannelTable(primitive), instances);\n        case Mesh.PrimitiveType.Polyline:\n          return this.createPolylineGraphic(primitive, displayParams, vertices, isPlanar, instances);\n        case Mesh.PrimitiveType.Point:\n          return this.createPointStringGraphic(primitive, displayParams, vertices, instances);\n      }\n\n      assert(false, \"unhandled primitive type\");\n      return undefined;\n    }\n\n    private findBuffer(bufferViewId: string): Uint8Array | undefined {\n      if (typeof bufferViewId !== \"string\" || 0 === bufferViewId.length)\n        return undefined;\n\n      const bufferViewJson = this._bufferViews[bufferViewId];\n      if (undefined === bufferViewJson)\n        return undefined;\n\n      const byteOffset = JsonUtils.asInt(bufferViewJson.byteOffset);\n      const byteLength = JsonUtils.asInt(bufferViewJson.byteLength);\n      if (0 === byteLength)\n        return undefined;\n\n      return this._binaryData.subarray(byteOffset, byteOffset + byteLength);\n    }\n\n    private readVertexTable(primitive: any): VertexTable | undefined {\n      const json = primitive.vertices;\n      if (undefined === json)\n        return undefined;\n\n      const bytes = this.findBuffer(JsonUtils.asString(json.bufferView));\n      if (undefined === bytes)\n        return undefined;\n\n      const uniformFeatureID = undefined !== json.featureID ? JsonUtils.asInt(json.featureID) : undefined;\n\n      const rangeMin = JsonUtils.asArray(json.params.decodedMin);\n      const rangeMax = JsonUtils.asArray(json.params.decodedMax);\n      if (undefined === rangeMin || undefined === rangeMax)\n        return undefined;\n\n      const qparams = QParams3d.fromRange(Range3d.create(Point3d.create(rangeMin[0], rangeMin[1], rangeMin[2]), Point3d.create(rangeMax[0], rangeMax[1], rangeMax[2])));\n\n      const uniformColor = undefined !== json.uniformColor ? ColorDef.fromJSON(json.uniformColor) : undefined;\n      let uvParams: QParams2d | undefined;\n      if (undefined !== primitive.surface && undefined !== primitive.surface.uvParams) {\n        const uvMin = JsonUtils.asArray(primitive.surface.uvParams.decodedMin);\n        const uvMax = JsonUtils.asArray(primitive.surface.uvParams.decodedMax);\n        if (undefined === uvMin || undefined === uvMax)\n          return undefined;\n\n        const uvRange = new Range2d(uvMin[0], uvMin[1], uvMax[0], uvMax[1]);\n        uvParams = QParams2d.fromRange(uvRange);\n      }\n\n      return new VertexTable({\n        data: bytes,\n        qparams,\n        width: json.width,\n        height: json.height,\n        hasTranslucency: json.hasTranslucency,\n        uniformColor,\n        featureIndexType: json.featureIndexType,\n        uniformFeatureID,\n        numVertices: json.count,\n        numRgbaPerVertex: json.numRgbaPerVertex,\n        uvParams,\n      });\n    }\n\n    private readAuxChannelTable(primitive: any): AuxChannelTable | undefined {\n      const json = primitive.auxChannels;\n      if (undefined === json)\n        return undefined;\n\n      const bytes = this.findBuffer(JsonUtils.asString(json.bufferView));\n      if (undefined === bytes)\n        return undefined;\n\n      const props: AuxChannelTableProps = {\n        data: bytes,\n        width: json.width,\n        height: json.height,\n        count: json.count,\n        numBytesPerVertex: json.numBytesPerVertex,\n        displacements: json.displacements,\n        normals: json.normals,\n        params: json.params,\n      };\n\n      return AuxChannelTable.fromJSON(props);\n    }\n\n    private readInstances(primitive: any): InstancedGraphicParams | undefined {\n      const json = primitive.instances;\n      if (undefined === json)\n        return undefined;\n\n      const count = JsonUtils.asInt(json.count, 0);\n      if (count <= 0)\n        return undefined;\n\n      const centerComponents = JsonUtils.asArray(json.transformCenter);\n      if (undefined === centerComponents || 3 !== centerComponents.length)\n        return undefined;\n\n      const transformCenter = Point3d.create(centerComponents[0], centerComponents[1], centerComponents[2]);\n\n      const featureIds = this.findBuffer(JsonUtils.asString(json.featureIds));\n      if (undefined === featureIds)\n        return undefined;\n\n      const transformBytes = this.findBuffer(JsonUtils.asString(json.transforms));\n      if (undefined === transformBytes)\n        return undefined;\n\n      // 1 transform = 3 rows of 4 floats = 12 floats per instance\n      const numFloats = transformBytes.byteLength / 4;\n      assert(Math.floor(numFloats) === numFloats);\n      assert(0 === numFloats % 12);\n\n      const transforms = new Float32Array(transformBytes.buffer, transformBytes.byteOffset, numFloats);\n\n      let symbologyOverrides: Uint8Array | undefined;\n      if (undefined !== json.symbologyOverrides)\n        symbologyOverrides = this.findBuffer(JsonUtils.asString(json.symbologyOverrides));\n\n      return { count, transforms, transformCenter, featureIds, symbologyOverrides };\n    }\n\n    private readVertexIndices(json: any): VertexIndices | undefined {\n      const bytes = this.findBuffer(json as string);\n      return undefined !== bytes ? new VertexIndices(bytes) : undefined;\n    }\n\n    private createPointStringGraphic(primitive: any, displayParams: DisplayParams, vertices: VertexTable, instances: InstancedGraphicParams | undefined): RenderGraphic | undefined {\n      const indices = this.readVertexIndices(primitive.indices);\n      if (undefined === indices)\n        return undefined;\n\n      const params = new PointStringParams(vertices, indices, displayParams.width);\n      return this._system.createPointString(params, instances);\n    }\n\n    private readTesselatedPolyline(json: any): TesselatedPolyline | undefined {\n      const indices = this.readVertexIndices(json.indices);\n      const prevIndices = this.readVertexIndices(json.prevIndices);\n      const nextIndicesAndParams = this.findBuffer(json.nextIndicesAndParams);\n\n      if (undefined === indices || undefined === prevIndices || undefined === nextIndicesAndParams)\n        return undefined;\n\n      return {\n        indices,\n        prevIndices,\n        nextIndicesAndParams,\n      };\n    }\n\n    private createPolylineGraphic(primitive: any, displayParams: DisplayParams, vertices: VertexTable, isPlanar: boolean, instances: InstancedGraphicParams | undefined): RenderGraphic | undefined {\n      const polyline = this.readTesselatedPolyline(primitive);\n      if (undefined === polyline)\n        return undefined;\n\n      let flags = PolylineTypeFlags.Normal;\n      if (DisplayParams.RegionEdgeType.Outline === displayParams.regionEdgeType)\n        flags = (undefined === displayParams.gradient || displayParams.gradient.isOutlined) ? PolylineTypeFlags.Edge : PolylineTypeFlags.Outline;\n\n      const params = new PolylineParams(vertices, polyline, displayParams.width, displayParams.linePixels, isPlanar, flags);\n      return this._system.createPolyline(params, instances);\n    }\n\n    private readSurface(mesh: any, displayParams: DisplayParams): SurfaceParams | undefined {\n      const surf = mesh.surface;\n      if (undefined === surf)\n        return undefined;\n\n      const indices = this.readVertexIndices(surf.indices);\n      if (undefined === indices)\n        return undefined;\n\n      const type = JsonUtils.asInt(surf.type, -1);\n      if (!isValidSurfaceType(type))\n        return undefined;\n\n      const texture = undefined !== displayParams.textureMapping ? displayParams.textureMapping.texture : undefined;\n\n      return {\n        type,\n        indices,\n        fillFlags: displayParams.fillFlags,\n        hasBakedLighting: false,\n        material: displayParams.material,\n        texture,\n      };\n    }\n\n    private readSegmentEdges(json: any): SegmentEdgeParams | undefined {\n      const indices = this.readVertexIndices(json.indices);\n      const endPointAndQuadIndices = this.findBuffer(json.endPointAndQuadIndices);\n      return undefined !== indices && undefined !== endPointAndQuadIndices ? { indices, endPointAndQuadIndices } : undefined;\n    }\n\n    private readSilhouettes(json: any): SilhouetteParams | undefined {\n      const segments = this.readSegmentEdges(json);\n      const normalPairs = this.findBuffer(json.normalPairs);\n      return undefined !== segments && undefined !== normalPairs ? { normalPairs, indices: segments.indices, endPointAndQuadIndices: segments.endPointAndQuadIndices } : undefined;\n    }\n\n    private readEdges(json: any, displayParams: DisplayParams): { succeeded: boolean, params?: EdgeParams } {\n      let segments: SegmentEdgeParams | undefined;\n      let silhouettes: SilhouetteParams | undefined;\n      let polylines: TesselatedPolyline | undefined;\n\n      let succeeded = false;\n      if (undefined !== json.segments && undefined === (segments = this.readSegmentEdges(json.segments)))\n        return { succeeded };\n\n      if (undefined !== json.silhouettes && undefined === (silhouettes = this.readSilhouettes(json.silhouettes)))\n        return { succeeded };\n\n      if (undefined !== json.polylines && undefined === (polylines = this.readTesselatedPolyline(json.polylines)))\n        return { succeeded };\n\n      succeeded = true;\n      let params: EdgeParams | undefined;\n      if (undefined !== segments || undefined !== silhouettes || undefined !== polylines) {\n        params = {\n          segments,\n          silhouettes,\n          polylines,\n          weight: displayParams.width,\n          linePixels: displayParams.linePixels,\n        };\n      }\n\n      return { succeeded, params };\n    }\n\n    private createMeshGraphic(primitive: any, displayParams: DisplayParams, vertices: VertexTable, isPlanar: boolean, auxChannels: AuxChannelTable | undefined, instances: InstancedGraphicParams | undefined): RenderGraphic | undefined {\n      const surface = this.readSurface(primitive, displayParams);\n      if (undefined === surface)\n        return undefined;\n\n      // ###TODO: Tile generator shouldn't bother producing edges for classification meshes in the first place...\n      let edgeParams: EdgeParams | undefined;\n      if (this._loadEdges && undefined !== primitive.edges && SurfaceType.VolumeClassifier !== surface.type) {\n        const edgeResult = this.readEdges(primitive.edges, displayParams);\n        if (!edgeResult.succeeded)\n          return undefined;\n        else\n          edgeParams = edgeResult.params;\n      }\n\n      const params = new MeshParams(vertices, surface, edgeParams, isPlanar, auxChannels);\n      return this._system.createMesh(params, instances);\n    }\n\n    private finishRead(isLeaf: boolean, featureTable: PackedFeatureTable, contentRange: ElementAlignedBox3d, emptySubRangeMask: number, sizeMultiplier?: number): GltfTileIO.ReaderResult {\n      const graphics: RenderGraphic[] = [];\n\n      if (undefined === this._nodes.Node_Root) {\n        // Unstructured -- prior to animation support....\n        for (const meshKey of Object.keys(this._meshes)) {\n          const meshValue = this._meshes[meshKey];\n          const primitives = JsonUtils.asArray(meshValue.primitives);\n          if (undefined === primitives)\n            continue;\n          for (const primitive of primitives) {\n            const graphic = this.readMeshGraphic(primitive);\n            if (undefined !== graphic)\n              graphics.push(graphic);\n          }\n        }\n      } else {\n        for (const nodeKey of Object.keys(this._nodes)) {\n          const meshValue = this._meshes[this._nodes[nodeKey]];\n          const primitives = JsonUtils.asArray(meshValue.primitives);\n          if (undefined === primitives)\n            continue;\n\n          if (\"Node_Root\" === nodeKey) {\n            for (const primitive of primitives) {\n              const graphic = this.readMeshGraphic(primitive);\n              if (undefined !== graphic)\n                graphics.push(graphic);\n            }\n          } else {\n            const branch = new GraphicBranch(true);\n            branch.animationId = this._modelId + \"_\" + nodeKey;\n            for (const primitive of primitives) {\n              const graphic = this.readMeshGraphic(primitive);\n              if (undefined !== graphic)\n                branch.add(graphic);\n            }\n            if (!branch.isEmpty)\n              graphics.push(this._system.createBranch(branch, Transform.createIdentity()));\n          }\n        }\n      }\n\n      let tileGraphic: RenderGraphic | undefined;\n      switch (graphics.length) {\n        case 0:\n          break;\n        case 1:\n          tileGraphic = graphics[0];\n          break;\n        default:\n          tileGraphic = this._system.createGraphicList(graphics);\n          break;\n      }\n\n      if (undefined !== tileGraphic)\n        tileGraphic = this._system.createBatch(tileGraphic, featureTable, contentRange);\n\n      return {\n        readStatus: TileIO.ReadStatus.Success,\n        isLeaf,\n        sizeMultiplier,\n        contentRange: contentRange.isNull ? undefined : contentRange,\n        graphic: tileGraphic,\n        emptySubRangeMask,\n      };\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\nimport { TileIO } from \"./TileIO\";\nimport { ElementAlignedBox3d, QParams3d, Quantization, Feature, FeatureTable, BatchType } from \"@bentley/imodeljs-common\";\nimport { Id64String, assert, utf8ToString } from \"@bentley/bentleyjs-core\";\nimport { RenderSystem, RenderGraphic, GraphicBranch, PackedFeatureTable } from \"../render/System\";\nimport { PointCloudArgs } from \"../render/primitives/PointCloudPrimitive\";\nimport { Mesh } from \"../render/primitives/mesh/MeshPrimitives\";\nimport { Transform, Point3d, Matrix3d, Angle, Vector3d } from \"@bentley/geometry-core\";\nimport { IModelConnection } from \"../IModelConnection\";\n\n/** Deserializes a Pnts tile.\n * @internal\n */\nexport namespace PntsTileIO {\n  /** @internal */\n  class Header extends TileIO.Header {\n    public readonly length: number;\n    public readonly featureTableJsonLength: number;\n    public readonly featureTableBinaryLength: number;\n    public readonly batchTableJsonLength: number;\n    public readonly batchTableBinaryLength: number;\n    public get isValid(): boolean { return TileIO.Format.Pnts === this.format; }\n\n    public constructor(stream: TileIO.StreamBuffer) {\n      super(stream);\n      this.length = stream.nextUint32;\n      this.featureTableJsonLength = stream.nextUint32;\n      this.featureTableBinaryLength = stream.nextUint32;\n      this.batchTableJsonLength = stream.nextUint32;\n      this.batchTableBinaryLength = stream.nextUint32;\n    }\n  }\n\n  /** Deserialize a point cloud tile and return it as a RenderGraphic.\n   * @internal\n   */\n  export function readPointCloud(stream: TileIO.StreamBuffer, iModel: IModelConnection, modelId: Id64String, _is3d: boolean, range: ElementAlignedBox3d, system: RenderSystem, yAxisUp: boolean): RenderGraphic | undefined {\n    const header: Header = new Header(stream);\n\n    if (!header.isValid)\n      return undefined;\n\n    const featureTableJsonOffset = stream.curPos;\n    const featureStrData = stream.nextBytes(header.featureTableJsonLength);\n    const featureStr = utf8ToString(featureStrData);\n    const featureValue = JSON.parse(featureStr as string);\n\n    if (undefined === featureValue) { }\n    if (undefined === featureValue.POSITION_QUANTIZED ||\n      undefined === featureValue.QUANTIZED_VOLUME_OFFSET ||\n      undefined === featureValue.QUANTIZED_VOLUME_SCALE ||\n      undefined === featureValue.POINTS_LENGTH ||\n      undefined === featureValue.POSITION_QUANTIZED) {\n      assert(false, \"quantized point cloud points not found\");\n      return undefined;\n    }\n\n    const qOrigin = new Point3d(featureValue.QUANTIZED_VOLUME_OFFSET[0], featureValue.QUANTIZED_VOLUME_OFFSET[1], featureValue.QUANTIZED_VOLUME_OFFSET[2]);\n    const qScale = new Point3d(Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[0]), Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[1]), Quantization.computeScale(featureValue.QUANTIZED_VOLUME_SCALE[2]));\n    const qParams = QParams3d.fromOriginAndScale(qOrigin, qScale);\n    const qPoints = new Uint16Array(stream.arrayBuffer, featureTableJsonOffset + header.featureTableJsonLength + featureValue.POSITION_QUANTIZED.byteOffset, 3 * featureValue.POINTS_LENGTH);\n    let colors: Uint8Array | undefined;\n\n    if (undefined !== featureValue.RGB) {\n      colors = new Uint8Array(stream.arrayBuffer, featureTableJsonOffset + header.featureTableJsonLength + featureValue.RGB.byteOffset, 3 * featureValue.POINTS_LENGTH);\n    } else {\n      colors = new Uint8Array(3 * featureValue.POINTS_LENGTH);\n      colors.fill(0xff, 0, colors.length);    // TBD... Default color?\n    }\n\n    // ###TODO? Do we expect a batch table? not currently handled...\n    const featureTable = new FeatureTable(1, modelId, BatchType.Primary);\n    const features = new Mesh.Features(featureTable);\n    features.add(new Feature(modelId), 1);\n\n    let renderGraphic = system.createPointCloud(new PointCloudArgs(qPoints, qParams, colors, features), iModel);\n    renderGraphic = system.createBatch(renderGraphic!, PackedFeatureTable.pack(featureTable), range);\n\n    if (yAxisUp) {\n      const branch = new GraphicBranch();\n      branch.add(renderGraphic!);\n      const transform = Transform.createOriginAndMatrix(undefined, Matrix3d.createRotationAroundVector(Vector3d.create(1.0, 0.0, 0.0), Angle.createRadians(Angle.piOver2Radians)) as Matrix3d);\n\n      renderGraphic = system.createBranch(branch, transform);\n    }\n\n    return renderGraphic;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\n\nimport { IModelError, TileTreeProps, TileProps, ViewFlag, ViewFlags, RenderMode, Cartographic } from \"@bentley/imodeljs-common\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { BentleyStatus, assert, Guid } from \"@bentley/bentleyjs-core\";\nimport { TransformProps, Range3dProps, Range3d, Transform, Point3d, Vector3d, Matrix3d } from \"@bentley/geometry-core\";\nimport { RealityDataServicesClient, AccessToken, getArrayBuffer, getJson, RealityData } from \"@bentley/imodeljs-clients\";\nimport { TileTree, TileTreeState, Tile, TileLoader } from \"./TileTree\";\nimport { TileRequest } from \"./TileRequest\";\nimport { IModelApp } from \"../IModelApp\";\nimport { AuthorizedFrontendRequestContext, FrontendRequestContext } from \"../FrontendRequestContext\";\n\nfunction getUrl(content: any) {\n  return content ? (content.url ? content.url : content.uri) : undefined;\n}\n\n/** @internal */\nexport class RealityModelTileUtils {\n  public static rangeFromBoundingVolume(boundingVolume: any): Range3d | undefined {\n    if (undefined === boundingVolume)\n      return undefined;\n    if (undefined !== boundingVolume.box) {\n      const box: number[] = boundingVolume.box;\n      const center = Point3d.create(box[0], box[1], box[2]);\n      const ux = Vector3d.create(box[3], box[4], box[5]);\n      const uy = Vector3d.create(box[6], box[7], box[8]);\n      const uz = Vector3d.create(box[9], box[10], box[11]);\n      const corners: Point3d[] = [];\n      for (let j = 0; j < 2; j++) {\n        for (let k = 0; k < 2; k++) {\n          for (let l = 0; l < 2; l++) {\n            corners.push(center.plus3Scaled(ux, (j ? -1.0 : 1.0), uy, (k ? -1.0 : 1.0), uz, (l ? -1.0 : 1.0)));\n          }\n        }\n      }\n      return Range3d.createArray(corners);\n    } else if (Array.isArray(boundingVolume.sphere)) {\n      const sphere: number[] = boundingVolume.sphere;\n      const center = Point3d.create(sphere[0], sphere[1], sphere[2]);\n      const radius = sphere[3];\n      return Range3d.createXYZXYZ(center.x - radius, center.y - radius, center.z - radius, center.x + radius, center.y + radius, center.z + radius);\n    } else if (Array.isArray(boundingVolume.region)) {\n      const ecefLow = (new Cartographic(boundingVolume.region[0], boundingVolume.region[1], boundingVolume.region[4])).toEcef();\n      const ecefHigh = (new Cartographic(boundingVolume.region[2], boundingVolume.region[3], boundingVolume.region[5])).toEcef();\n      return Range3d.create(ecefLow, ecefHigh);\n    } else return undefined;\n\n  }\n  public static maximumSizeFromGeometricTolerance(range: Range3d, geometricError: number): number {\n    const minToleranceRatio = 1.0;   // Nominally the error on screen size of a tile.  Increasing generally increases performance (fewer draw calls) at expense of higher load times.\n    return minToleranceRatio * range.diagonal().magnitude() / geometricError;\n  }\n  public static transformFromJson(jTrans: number[] | undefined): Transform {\n    return (jTrans === undefined) ? Transform.createIdentity() : Transform.createOriginAndMatrix(Point3d.create(jTrans[12], jTrans[13], jTrans[14]), Matrix3d.createRowValues(jTrans[0], jTrans[4], jTrans[8], jTrans[1], jTrans[5], jTrans[9], jTrans[2], jTrans[6], jTrans[10]));\n  }\n}\n\n/** @internal */\nclass RealityModelTileTreeProps implements TileTreeProps {\n  public id: string = \"\";\n  public rootTile: TileProps;\n  public location: TransformProps;\n  public tilesetJson: object;\n  public yAxisUp: boolean = false;\n  public maxTilesToSkip = 1;    // Skip only one level in HLOD tree -- This matches the BIM tiles.  If our tiles loaded faster we could increase this.\n  constructor(json: any, public client: RealityModelTileClient, tilesetTransform: Transform) {\n    this.tilesetJson = json.root;\n    this.rootTile = new RealityModelTileProps(json.root, \"\");\n    this.location = tilesetTransform.toJSON();\n    if (json.asset.gltfUpAxis === undefined || json.asset.gltfUpAxis === \"y\" || json.asset.gltfUpAxis === \"Y\")\n      this.yAxisUp = true;\n  }\n}\n\n/** @internal */\nclass RealityModelTileProps implements TileProps {\n  public readonly contentId: string;\n  public readonly range: Range3dProps;\n  public readonly contentRange?: Range3dProps;\n  public readonly maximumSize: number;\n  public readonly isLeaf: boolean;\n  public readonly transformToRoot?: TransformProps;\n  public geometry?: string | ArrayBuffer;\n  public hasContents: boolean;\n  constructor(json: any, thisId: string, transformToRoot?: Transform) {\n    this.contentId = thisId;\n    this.range = RealityModelTileUtils.rangeFromBoundingVolume(json.boundingVolume)!;\n    this.isLeaf = !Array.isArray(json.children) || 0 === json.children.length;\n    this.hasContents = undefined !== getUrl(json.content);\n    this.transformToRoot = transformToRoot;\n    if (this.hasContents) {\n      this.contentRange = RealityModelTileUtils.rangeFromBoundingVolume(json.content.boundingVolume);\n      this.maximumSize = RealityModelTileUtils.maximumSizeFromGeometricTolerance(Range3d.fromJSON(this.range), json.geometricError);\n    } else {\n      this.maximumSize = 0.0;\n    }\n  }\n}\n\n/** @internal */\nclass FindChildResult {\n  constructor(public id: string, public json: any, public transformToRoot?: Transform) { }\n}\n\n/** @internal */\nclass RealityModelTileLoader extends TileLoader {\n  constructor(private _tree: RealityModelTileTreeProps) { super(); }\n  public get maxDepth(): number { return 32; }  // Can be removed when element tile selector is working.\n  public get priority(): Tile.LoadPriority { return Tile.LoadPriority.Context; }\n  public tileRequiresLoading(params: Tile.Params): boolean { return 0.0 !== params.maximumSize; }\n  protected static _viewFlagOverrides = new ViewFlag.Overrides(ViewFlags.fromJSON({ renderMode: RenderMode.SmoothShade }));\n  public get viewFlagOverrides() { return RealityModelTileLoader._viewFlagOverrides; }\n  public async getChildrenProps(parent: Tile): Promise<TileProps[]> {\n    const props: RealityModelTileProps[] = [];\n\n    const thisId = parent.contentId;\n    const prefix = thisId.length ? thisId + \"_\" : \"\";\n    const findResult = await this.findTileInJson(this._tree.tilesetJson, thisId, \"\", undefined, true);\n    if (undefined !== findResult && Array.isArray(findResult.json.children)) {\n      for (let i = 0; i < findResult.json.children.length; i++) {\n        const childId = prefix + i;\n        const foundChild = await this.findTileInJson(this._tree.tilesetJson, childId, \"\", undefined, true);\n        if (undefined !== foundChild)\n          props.push(new RealityModelTileProps(foundChild.json, foundChild.id, foundChild.transformToRoot));\n      }\n    }\n\n    return props;\n  }\n\n  public async requestTileContent(tile: Tile): Promise<TileRequest.Response> {\n    const foundChild = await this.findTileInJson(this._tree.tilesetJson, tile.contentId, \"\");\n    if (undefined === foundChild)\n      return undefined;\n\n    return this._tree.client.getTileContent(getUrl(foundChild.json.content));\n  }\n  private addUrlPrefix(subTree: any, prefix: string) {\n    if (undefined === subTree)\n      return;\n    if (undefined !== subTree.content && undefined !== subTree.content.url)\n      subTree.content.url = prefix + subTree.content.url;\n\n    if (undefined !== subTree.children)\n      for (const child of subTree.children)\n        this.addUrlPrefix(child, prefix);\n  }\n\n  private async findTileInJson(tilesetJson: any, id: string, parentId: string, transformToRoot?: Transform, isRoot: boolean = false): Promise<FindChildResult | undefined> {\n    if (!isRoot && tilesetJson.transform) {   // Child tiles may have their own transform.\n      const thisTransform = RealityModelTileUtils.transformFromJson(tilesetJson.transform);\n      transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(thisTransform) : thisTransform;\n    }\n    if (id.length === 0)\n      return new FindChildResult(id, tilesetJson, transformToRoot);    // Root.\n    const separatorIndex = id.indexOf(\"_\");\n    const childId = (separatorIndex < 0) ? id : id.substring(0, separatorIndex);\n    const childIndex = parseInt(childId, 10);\n\n    if (isNaN(childIndex) || tilesetJson === undefined || tilesetJson.children === undefined || childIndex >= tilesetJson.children.length) {\n      assert(false, \"scalable mesh child not found.\");\n      return undefined;\n    }\n\n    let foundChild = tilesetJson.children[childIndex];\n    const thisParentId = parentId.length ? (parentId + \"_\" + childId) : childId;\n    if (foundChild.transform) {\n      const thisTransform = RealityModelTileUtils.transformFromJson(foundChild.transform);\n      transformToRoot = transformToRoot ? transformToRoot.multiplyTransformTransform(thisTransform) : thisTransform;\n    }\n    if (separatorIndex >= 0) { return this.findTileInJson(foundChild, id.substring(separatorIndex + 1), thisParentId, transformToRoot); }\n    const childUrl = getUrl(foundChild.content);\n    if (undefined !== childUrl && childUrl.endsWith(\"json\")) {    // A child may contain a subTree...\n      const subTree = await this._tree.client.getTileJson(childUrl);\n      const prefixIndex = childUrl.lastIndexOf(\"/\");\n      if (prefixIndex > 0)\n        this.addUrlPrefix(subTree.root, childUrl.substring(0, prefixIndex + 1));\n      foundChild = subTree.root;\n      tilesetJson.children[childIndex] = subTree.root;\n    }\n    return new FindChildResult(thisParentId, foundChild, transformToRoot);\n  }\n}\n\n/** @internal */\nexport class RealityModelTileTree {\n  public static loadRealityModelTileTree(url: string, tilesetToDb: any, tileTreeState: TileTreeState): void {\n\n    this.getTileTreeProps(url, tilesetToDb, tileTreeState.iModel).then((tileTreeProps: RealityModelTileTreeProps) => {\n      tileTreeState.setTileTree(tileTreeProps, new RealityModelTileLoader(tileTreeProps));\n      IModelApp.viewManager.onNewTilesReady();\n    }).catch((_err) => tileTreeState.loadStatus = TileTree.LoadStatus.NotFound);\n  }\n\n  private static async getAccessToken(): Promise<AccessToken | undefined> {\n    if (!IModelApp.authorizationClient || !IModelApp.authorizationClient.hasSignedIn)\n      return undefined; // Not signed in\n    let accessToken: AccessToken;\n    try {\n      accessToken = await IModelApp.authorizationClient.getAccessToken();\n    } catch (error) {\n      return undefined;\n    }\n    return accessToken;\n  }\n\n  private static async getTileTreeProps(url: string, tilesetToDbJson: any, iModel: IModelConnection): Promise<RealityModelTileTreeProps> {\n    if (!url)\n      throw new IModelError(BentleyStatus.ERROR, \"Unable to read reality data\");\n    const accessToken = await this.getAccessToken();\n    const tileClient = new RealityModelTileClient(url, accessToken);\n    const json = await tileClient.getRootDocument(url);\n    const ecefLocation = iModel.ecefLocation;\n    let rootTransform = ecefLocation ? ecefLocation.getTransform().inverse()! : Transform.createIdentity();\n    if (json.root.transform)\n      rootTransform = rootTransform.multiplyTransformTransform(RealityModelTileUtils.transformFromJson(json.root.transform));\n    else if (json.root.boundingVolume && Array.isArray(json.root.boundingVolume.region))\n      rootTransform = Transform.createTranslationXYZ(0, 0, (json.root.boundingVolume.region[4] + json.root.boundingVolume.region[5]) / 2.0).multiplyTransformTransform(rootTransform);\n\n    if (undefined !== tilesetToDbJson)\n      rootTransform = Transform.fromJSON(tilesetToDbJson).multiplyTransformTransform(rootTransform);\n\n    return new RealityModelTileTreeProps(json, tileClient, rootTransform);\n  }\n}\n\ninterface RDSClientProps {\n  projectId: string;\n  tilesId: string;\n}\n\n/**\n * ###TODO temporarly here for testing, needs to be moved to the clients repo\n * @internal\n * This class encapsulates access to a reality data wether it be from local access, http or RDS\n * The url provided at the creation is parsed to determine if this is a RDS (ProjectWise Context Share) reference.\n * If not then it is considered local (ex: C:\\temp\\TileRoot.json) or plain http access (http://someserver.com/data/TileRoot.json)\n * There is a one to one relationship between a reality data and the instances of present class.\n */\nexport class RealityModelTileClient {\n  public readonly rdsProps?: RDSClientProps; // For reality data stored on PW Context Share only. If undefined then Reality Data is not on Context Share.\n  private _realityData?: RealityData;        // For reality data stored on PW Context Share only.\n  private _baseUrl: string = \"\";             // For use by all Reality Data. For RD stored on PW Context Share, represents the portion from the root of the Azure Blob Container\n  private readonly _token?: AccessToken;     // Only used for accessing PW Context Share.\n  private static _client = new RealityDataServicesClient();  // WSG Client for accessing Reality Data on PW Context Share\n\n  // ###TODO we should be able to pass the projectId / tileId directly, instead of parsing the url\n  // But if the present can also be used by non PW Context Share stored data then the url is required and token is not. Possibly two classes inheriting from common interface.\n  constructor(url: string, accessToken?: AccessToken) {\n    this.rdsProps = this.parseUrl(url); // Note that returned is undefined if url does not refer to a PW Context Share reality data.\n    this._token = accessToken;\n  }\n\n  private async initializeRDSRealityData(requestContext: AuthorizedFrontendRequestContext): Promise<void> {\n    requestContext.enter();\n\n    if (undefined !== this.rdsProps) {\n      if (!this._realityData) {\n        // TODO Temporary fix ... the root document may not be located at the root. We need to set the base URL even for RD stored on server\n        // though this base URL is only the part relative to the root of the blob contining the data.\n        this._realityData = await RealityModelTileClient._client.getRealityData(requestContext, this.rdsProps.projectId, this.rdsProps.tilesId);\n        requestContext.enter();\n\n        // A reality data that has not root document set should not be considered.\n        const rootDocument: string = (this._realityData!.rootDocument ? this._realityData!.rootDocument as string : \"\");\n        this.setBaseUrl(rootDocument);\n      }\n    }\n  }\n\n  // ###TODO temporary means of extracting the tileId and projectId from the given url\n  // This is the method that determines if the url refers to Reality Data stored on PW Context Share. If not then undefined is returned.\n  private parseUrl(url: string): RDSClientProps | undefined {\n    const urlParts = url.split(\"/\").map((entry: string) => entry.replace(/%2D/g, \"-\"));\n    const tilesId = urlParts.find(Guid.isGuid);\n    let props: RDSClientProps | undefined;\n    if (undefined !== tilesId) {\n      let projectId = urlParts.find((val: string) => val.includes(\"--\"))!.split(\"--\")[1];\n\n      // ###TODO This is a temporary workaround for accessing the reality meshes with a test account\n      // The hardcoded project id corresponds to a project setup to yied access to the test account which is linked to the tileId\n      if (projectId === \"Server\")\n        projectId = \"fb1696c8-c074-4c76-a539-a5546e048cc6\";\n\n      props = { projectId, tilesId };\n    }\n    return props;\n  }\n\n  // This is to set the root url fromt he provided root document path.\n  // If the root document is stored on PW Context Share then the root document property of the Reality Data is provided,\n  // otherwise the full path to root document is given.\n  // The base URL contains the base URL from which tile relative path are constructed.\n  // The tile's path root will need to be reinserted for child tiles to return a 200\n  private setBaseUrl(url: string): void {\n    const urlParts = url.split(\"/\");\n    urlParts.pop();\n    if (urlParts.length === 0)\n      this._baseUrl = \"\";\n    else\n      this._baseUrl = urlParts.join(\"/\") + \"/\";\n  }\n\n  // ### TODO. Technically the url should not be required. If the reality data encapsulated is stored on PW Context Share then\n  // the relative path to root document is extracted from the reality data. Otherwise the full url to root document should have been provided at\n  // the construction of the instance.\n  public async getRootDocument(url: string): Promise<any> {\n    if (this.rdsProps && this._token) {\n      const authRequestContext = new AuthorizedFrontendRequestContext(this._token);\n      authRequestContext.enter();\n\n      await this.initializeRDSRealityData(authRequestContext); // Only needed for PW Context Share data ... return immediately otherwise.\n      authRequestContext.enter();\n\n      return this._realityData!.getRootDocumentJson(authRequestContext);\n    }\n\n    // The following is only if the reality data is not stored on PW Context Share.\n    this.setBaseUrl(url);\n    const requestContext = new FrontendRequestContext();\n    return getJson(requestContext, url);\n  }\n\n  /**\n   * Returns the tile content. The path to the tile is relative to the base url of present reality data whatever the type.\n   */\n  public async getTileContent(url: string): Promise<any> {\n    const requestContext = this._token ? new AuthorizedFrontendRequestContext(this._token) : new FrontendRequestContext();\n    requestContext.enter();\n\n    if (this.rdsProps && this._token) {\n      await this.initializeRDSRealityData(requestContext as AuthorizedFrontendRequestContext); // Only needed for PW Context Share data ... return immediately otherwise.\n      requestContext.enter();\n    }\n\n    let tileUrl: string = url;\n    if (undefined !== this._baseUrl) {\n      tileUrl = this._baseUrl + url;\n\n      if (undefined !== this.rdsProps && undefined !== this._token)\n        return this._realityData!.getTileContent(requestContext as AuthorizedFrontendRequestContext, tileUrl);\n\n      return getArrayBuffer(requestContext, tileUrl);\n    }\n    throw new IModelError(BentleyStatus.ERROR, \"Unable to determine reality data content url\");\n  }\n\n  /**\n   * Returns the tile content in json format. The path to the tile is relative to the base url of present reality data whatever the type.\n   */\n  public async getTileJson(url: string): Promise<any> {\n    const requestContext = this._token ? new AuthorizedFrontendRequestContext(this._token) : new FrontendRequestContext();\n    requestContext.enter();\n\n    if (this.rdsProps && this._token) {\n      await this.initializeRDSRealityData(requestContext as AuthorizedFrontendRequestContext); // Only needed for PW Context Share data ... return immediately otherwise.\n      requestContext.enter();\n    }\n\n    let tileUrl: string = url;\n    if (undefined !== this._baseUrl) {\n      tileUrl = this._baseUrl + url;\n\n      if (undefined !== this.rdsProps && undefined !== this._token)\n        return this._realityData!.getTileJson(requestContext as AuthorizedFrontendRequestContext, tileUrl);\n\n      return getJson(requestContext, tileUrl);\n    }\n    throw new IModelError(BentleyStatus.ERROR, \"Unable to determine reality data json url\");\n  }\n}\n","/*---------------------------------------------------------------------------------------------\r\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\r\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\r\n*--------------------------------------------------------------------------------------------*/\r\n/** @module Tile */\r\n\r\nimport { BeDuration, Dictionary, SortedArray, PriorityQueue, assert } from \"@bentley/bentleyjs-core\";\r\nimport { RpcOperation, RpcResponseCacheControl, IModelTileRpcInterface, TileTreeProps } from \"@bentley/imodeljs-common\";\r\nimport { IModelApp } from \"../IModelApp\";\r\nimport { IModelConnection } from \"../IModelConnection\";\r\nimport { IModelTileIO } from \"./IModelTileIO\";\r\nimport { Tile } from \"./TileTree\";\r\nimport { TileRequest } from \"./TileRequest\";\r\nimport { Viewport } from \"../Viewport\";\r\n\r\n/** Provides functionality associated with [[Tile]]s, mostly in the area of scheduling requests for tile content.\r\n * The TileAdmin tracks [[Viewport]]s which have requested tile content, maintaining a priority queue of pending requests and\r\n * a set of active requests. On each update it identifies previously-requested tiles whose content no viewport is interested in any longer and\r\n * cancels them. It then pulls pending requests off the queue and dispatches them into the active set until either the maximum number of\r\n * simultaneously-active requests is reached or the queue becomes empty.\r\n * @alpha\r\n */\r\nexport abstract class TileAdmin {\r\n  /** @internal */\r\n  public abstract get emptyViewportSet(): TileAdmin.ViewportSet;\r\n  /** Returns basic statistics about the TileAdmin's current state. */\r\n  public abstract get statistics(): TileAdmin.Statistics;\r\n  /** Resets the cumulative (per-session) statistics like totalCompletedRequests, totalEmptyTiles, etc. */\r\n  public abstract resetStatistics(): void;\r\n\r\n  /** Controls the maximum number of simultaneously-active requests allowed.\r\n   * If the maximum is reduced below the current size of the active set, no active requests will be canceled - but no more will be dispatched until the\r\n   * size of the active set falls below the new maximum.\r\n   * @see [[TileAdmin.Props.maxActiveRequests]]\r\n   * @note Browsers impose their own limitations on maximum number of total connections, and connections per-domain. These limitations are\r\n   * especially strict when using HTTP1.1 instead of HTTP2. Increasing the maximum above the default may significantly affect performance as well as\r\n   * bandwidth and memory consumption.\r\n   * @alpha\r\n   */\r\n  public abstract set maxActiveRequests(max: number);\r\n  public abstract get maxActiveRequests(): number;\r\n\r\n  /** @internal */\r\n  public abstract get enableInstancing(): boolean;\r\n\r\n  /** @internal */\r\n  public abstract get useProjectExtents(): boolean;\r\n  /** @internal */\r\n  public abstract get tileExpirationTime(): BeDuration;\r\n\r\n  /** Given a numeric combined major+minor tile format version (typically obtained from a request to the backend to query the maximum tile format version it supports),\r\n   * return the maximum *major* format version to be used to request tile content from the backend.\r\n   * @see [[TileAdmin.Props.maximumMajorTileFormatVersion]]\r\n   * @see [[IModelTileIO.CurrentVersion]]\r\n   * @see [TileTreeProps.formatVersion]($common)\r\n   * @internal\r\n   */\r\n  public abstract getMaximumMajorTileFormatVersion(formatVersion?: number): number;\r\n\r\n  /** Returns the union of the input set and the input viewport.\r\n   * @internal\r\n   */\r\n  public abstract getViewportSet(vp: Viewport, vps?: TileAdmin.ViewportSet): TileAdmin.ViewportSet;\r\n\r\n  /** Invoked from the [[ToolAdmin]] event loop to process any pending or active requests for tiles.\r\n   * @internal\r\n   */\r\n  public abstract process(): void;\r\n\r\n  /** Specifies the set of tiles currently requested for use by a viewport. This set replaces any previously specified for the same viewport.\r\n   * The requests are not actually processed until the next call to [[TileAdmin.process].\r\n   * This is typically invoked when the viewport recreates its scene, e.g. in response to camera movement.\r\n   * @internal\r\n   */\r\n  public abstract requestTiles(vp: Viewport, tiles: Set<Tile>): void;\r\n\r\n  /** Returns the number of pending and active requests associated with the specified viewport.\r\n   * @alpha\r\n   */\r\n  public abstract getNumRequestsForViewport(vp: Viewport): number;\r\n\r\n  /** Indicates that the TileAdmin should cease tracking the specified viewport, e.g. because it is about to be destroyed.\r\n   * Any requests which are of interest only to the specified viewport will be canceled.\r\n   * @internal\r\n   */\r\n  public abstract forgetViewport(vp: Viewport): void;\r\n\r\n  /** @internal */\r\n  public abstract onShutDown(): void;\r\n\r\n  /** @internal */\r\n  public abstract async requestTileTreeProps(iModel: IModelConnection, treeId: string): Promise<TileTreeProps>;\r\n\r\n  /** @internal */\r\n  public abstract async requestTileContent(iModel: IModelConnection, treeId: string, contentId: string): Promise<Uint8Array>;\r\n\r\n  /** Create a TileAdmin. Chiefly intended for use by subclasses of [[IModelApp]] to customize the behavior of the TileAdmin.\r\n   * @param props Options for customizing the behavior of the TileAdmin.\r\n   * @returns the TileAdmin\r\n   * @beta\r\n   */\r\n  public static create(props?: TileAdmin.Props): TileAdmin {\r\n    return new Admin(props);\r\n  }\r\n\r\n  /** @internal */\r\n  public abstract onTileCompleted(tile: Tile): void;\r\n  /** @internal */\r\n  public abstract onTileTimedOut(tile: Tile): void;\r\n  /** @internal */\r\n  public abstract onTileFailed(tile: Tile): void;\r\n  /** @internal */\r\n  public abstract onTileElided(): void;\r\n}\r\n\r\n/** @alpha */\r\nexport namespace TileAdmin {\r\n  /** Statistics regarding the current and cumulative state of the [[TileAdmin]]. Useful for monitoring performance and diagnosing problems.\r\n   * @alpha\r\n   */\r\n  export interface Statistics {\r\n    /** The number of requests in the queue which have not yet been dispatched. */\r\n    numPendingRequests: number;\r\n    /** The number of requests which have been dispatched but not yet completed. */\r\n    numActiveRequests: number;\r\n    /** The number of requests canceled during the most recent update. */\r\n    numCanceled: number;\r\n    /** The total number of completed requests during this session. */\r\n    totalCompletedRequests: number;\r\n    /** The total number of failed requests during this session. */\r\n    totalFailedRequests: number;\r\n    /** The total number of timed-out requests during this session. */\r\n    totalTimedOutRequests: number;\r\n    /** The total number of completed requests during this session which produced an empty tile. These tiles also contribute to totalCompletedRequests, but not to totalUndisplayableTiles. */\r\n    totalEmptyTiles: number;\r\n    /** The total number of completed requests during this session which produced an undisplayable tile. These tiles also contribute to totalCompletedRequests, but not to totalEmptyTiles. */\r\n    totalUndisplayableTiles: number;\r\n    /** The total number of tiles whose contents were not requested during this session because their volumes were determined to be empty. */\r\n    totalElidedTiles: number;\r\n  }\r\n\r\n  /** Describes configuration of a [[TileAdmin]].\r\n   * @see [[TileAdmin.create]]\r\n   * @alpha\r\n   */\r\n  export interface Props {\r\n    /** The maximum number of simultaneously-active requests. Any requests beyond this maximum are placed into a priority queue.\r\n     *\r\n     * Default value: 10\r\n     */\r\n    maxActiveRequests?: number;\r\n\r\n    /** If true, the [[TileAdmin]] will immediately dispatch all requests, bypassing the throttling imposed by maxActiveRequests.\r\n     * This is not recommended - it eliminates any ability to cancel requests for tiles which are no longer needed, and will swamp\r\n     * the network with requests.\r\n     *\r\n     * Default value: false\r\n     * @note If this is defined and true, `maxActiveRequests` is ignored.\r\n     */\r\n    disableThrottling?: boolean;\r\n\r\n    /** If true, tiles may represent repeated geometry as sets of instances. This can reduce tile size and tile generation time, and improve performance.\r\n     *\r\n     * Default value: true\r\n     */\r\n    enableInstancing?: boolean;\r\n\r\n    /** The interval in milliseconds at which a request for tile content will be retried until a response is received.\r\n     *\r\n     * Default value: 1000 (1 second)\r\n     */\r\n    retryInterval?: number;\r\n\r\n    /** If defined, specifies the maximum MAJOR tile format version to request. For example, if IModelTileIO.CurrentVersion.Major = 3, and maximumMajorTileFormatVersion = 2,\r\n     * requests for tile content will obtain tile content in some version 2.x of the format, never of some version 3.x.\r\n     * Note that the actual maximum major version is also dependent on the backend which fulfills the requests - if the backend only knows how to produce tiles of format version 1.5, for example,\r\n     * requests for tiles in format version 2.1 will still return content in format version 1.5.\r\n     * This can be used to feature-gate newer tile formats on a per-user basis.\r\n     *\r\n     * Default value: undefined\r\n     * @internal\r\n     */\r\n    maximumMajorTileFormatVersion?: number;\r\n\r\n    /** By default, the range of a spatial tile tree is based on the range of the model. If that range is small relative to the project extents, the \"low-resolution\" tiles\r\n     * will be much higher-resolution than is appropriate to draw when the view is fit to the project extents, This can cause poor display performance due to too much tiny geometry.\r\n     * Setting this option to `true` will instead base the range of the tree on the project extents.\r\n     *\r\n     * Default value: false\r\n     *\r\n     * @internal\r\n     */\r\n    useProjectExtents?: boolean;\r\n\r\n    /** The minimum number of seconds to keep a Tile in memory after it has become unused.\r\n     * Each tile has an expiration timer. Each time tiles are selected for drawing in a view, if we decide to draw a tile we reset its expiration timer.\r\n     * Otherwise, if its expiration timer has exceeded this minimum, we discard it along with all of its children. This allows us to free up memory for other tiles.\r\n     * If we later want to draw the same tile, we must re-request it (typically from some cache).\r\n     * Setting this value too small will cause excessive tile requests. Setting it too high will cause excessive memory consumption.\r\n     *\r\n     * Default value: 20 seconds.\r\n     * Minimum value: 5 seconds.\r\n     * Maximum value: 60 seconds.\r\n     *\r\n     * @alpha\r\n     */\r\n    tileExpirationTime?: number;\r\n  }\r\n\r\n  /** A set of [[Viewport]]s.\r\n   * ViewportSets are managed and cached by [[TileAdmin]] such that any number of [[TileRequest]]s associated with the same set of viewports will\r\n   * use the same ViewportSet object.\r\n   * @internal\r\n   */\r\n  export class ViewportSet extends SortedArray<Viewport> {\r\n    public constructor(vp?: Viewport) {\r\n      super((lhs, rhs) => lhs.viewportId - rhs.viewportId);\r\n      if (undefined !== vp)\r\n        this.insert(vp);\r\n    }\r\n\r\n    public clone(out?: ViewportSet): ViewportSet {\r\n      if (undefined === out)\r\n        out = new ViewportSet();\r\n      else\r\n        out.clear();\r\n\r\n      for (let i = 0; i < this.length; i++)\r\n        out._array.push(this._array[i]);\r\n\r\n      return out;\r\n    }\r\n  }\r\n}\r\n\r\nfunction compareTilePriorities(lhs: Tile, rhs: Tile): number {\r\n  let diff = lhs.loader.priority - rhs.loader.priority;\r\n  if (0 === diff) {\r\n    diff = lhs.loader.compareTilePriorities(lhs, rhs);\r\n  }\r\n\r\n  return diff;\r\n}\r\n\r\nclass Queue extends PriorityQueue<TileRequest> {\r\n  public constructor() {\r\n    super((lhs, rhs) => compareTilePriorities(lhs.tile, rhs.tile));\r\n  }\r\n\r\n  public has(request: TileRequest): boolean {\r\n    return this._array.indexOf(request) >= 0;\r\n  }\r\n}\r\n\r\nfunction compareViewportSets(lhs: TileAdmin.ViewportSet, rhs: TileAdmin.ViewportSet): number {\r\n  if (lhs === rhs)\r\n    return 0;\r\n\r\n  let diff = lhs.length - rhs.length;\r\n  if (0 === diff) {\r\n    for (let i = 0; i < lhs.length; i++) {\r\n      const lhvp = lhs.get(i)!;\r\n      const rhvp = rhs.get(i)!;\r\n      diff = lhvp.viewportId - rhvp.viewportId;\r\n      if (0 !== diff)\r\n        break;\r\n    }\r\n  }\r\n\r\n  return diff;\r\n}\r\n\r\n// The scheduler needs to know about all viewports which have tile requests.\r\n// Each request needs to know the set of viewports for which it has been requested.\r\n// We don't want to duplicate the latter per-Request - in addition to wasting memory, that would\r\n// also require us to traverse all requests whenever a viewport becomes un-tracked in order to remove it from their sets.\r\n// This class holds unique sets of viewports and doles them out to Requests.\r\nclass UniqueViewportSets extends SortedArray<TileAdmin.ViewportSet> {\r\n  public readonly emptySet = new TileAdmin.ViewportSet();\r\n  private readonly _scratchSet = new TileAdmin.ViewportSet();\r\n\r\n  public constructor() {\r\n    super((lhs, rhs) => compareViewportSets(lhs, rhs));\r\n    Object.freeze(this.emptySet);\r\n  }\r\n\r\n  public eraseAt(index: number): void {\r\n    assert(index < this.length && index >= 0);\r\n    this._array.splice(index, 1);\r\n  }\r\n\r\n  public getForViewport(vp: Viewport): TileAdmin.ViewportSet {\r\n    for (let i = 0; i < this.length; i++) {\r\n      const set = this._array[i];\r\n      if (1 === set.length && set.get(0)! === vp)\r\n        return set;\r\n    }\r\n\r\n    const newSet = new TileAdmin.ViewportSet(vp);\r\n    this.insert(newSet);\r\n    return newSet;\r\n  }\r\n\r\n  public getViewportSet(vp: Viewport, vps?: TileAdmin.ViewportSet): TileAdmin.ViewportSet {\r\n    if (undefined === vps || vps.isEmpty)\r\n      return this.getForViewport(vp);\r\n\r\n    // Use the scratch set for equality comparison - only allocate if no equivalent set already exists.\r\n    const toFind = vps.clone(this._scratchSet);\r\n    toFind.insert(vp);\r\n    const found = this.findEqual(toFind);\r\n    if (undefined !== found) {\r\n      toFind.clear();\r\n      return found;\r\n    }\r\n\r\n    const newSet = toFind.clone();\r\n    toFind.clear();\r\n    this.insert(newSet);\r\n    return newSet;\r\n  }\r\n\r\n  public clearAll(): void {\r\n    this.forEach((set) => set.clear());\r\n    this.clear();\r\n  }\r\n}\r\n\r\nclass RequestsPerViewport extends Dictionary<Viewport, Set<Tile>> {\r\n  public constructor() {\r\n    super((lhs, rhs) => lhs.viewportId - rhs.viewportId);\r\n  }\r\n}\r\n\r\nclass Admin extends TileAdmin {\r\n  private readonly _requestsPerViewport = new RequestsPerViewport();\r\n  private readonly _uniqueViewportSets = new UniqueViewportSets();\r\n  private _maxActiveRequests: number;\r\n  private readonly _throttle: boolean;\r\n  private readonly _retryInterval: number;\r\n  private readonly _enableInstancing: boolean;\r\n  private readonly _maxMajorVersion: number;\r\n  private readonly _useProjectExtents: boolean;\r\n  private readonly _removeIModelConnectionOnCloseListener: () => void;\r\n  private _activeRequests = new Set<TileRequest>();\r\n  private _swapActiveRequests = new Set<TileRequest>();\r\n  private _pendingRequests = new Queue();\r\n  private _swapPendingRequests = new Queue();\r\n  private _numCanceled = 0;\r\n  private _totalCompleted = 0;\r\n  private _totalFailed = 0;\r\n  private _totalTimedOut = 0;\r\n  private _totalEmpty = 0;\r\n  private _totalUndisplayable = 0;\r\n  private _totalElided = 0;\r\n  private _rpcInitialized = false;\r\n  private readonly _expirationTime: BeDuration;\r\n\r\n  public get emptyViewportSet(): TileAdmin.ViewportSet { return this._uniqueViewportSets.emptySet; }\r\n  public get statistics(): TileAdmin.Statistics {\r\n    return {\r\n      numPendingRequests: this._pendingRequests.length,\r\n      numActiveRequests: this._activeRequests.size,\r\n      numCanceled: this._numCanceled,\r\n      totalCompletedRequests: this._totalCompleted,\r\n      totalFailedRequests: this._totalFailed,\r\n      totalTimedOutRequests: this._totalTimedOut,\r\n      totalEmptyTiles: this._totalEmpty,\r\n      totalUndisplayableTiles: this._totalUndisplayable,\r\n      totalElidedTiles: this._totalElided,\r\n    };\r\n  }\r\n\r\n  public resetStatistics(): void {\r\n    this._totalCompleted = this._totalFailed = this._totalTimedOut = this._totalEmpty = this._totalUndisplayable = this._totalElided = 0;\r\n  }\r\n\r\n  public constructor(options?: TileAdmin.Props) {\r\n    super();\r\n\r\n    if (undefined === options)\r\n      options = {};\r\n\r\n    this._throttle = !options.disableThrottling;\r\n    this._maxActiveRequests = undefined !== options.maxActiveRequests ? options.maxActiveRequests : 10;\r\n    this._retryInterval = undefined !== options.retryInterval ? options.retryInterval : 1000;\r\n    this._enableInstancing = undefined !== options.enableInstancing ? options.enableInstancing : true;\r\n    this._maxMajorVersion = undefined !== options.maximumMajorTileFormatVersion ? options.maximumMajorTileFormatVersion : IModelTileIO.CurrentVersion.Major;\r\n\r\n    this._useProjectExtents = !!options.useProjectExtents;\r\n\r\n    let expiration = undefined !== options.tileExpirationTime ? options.tileExpirationTime : 20;\r\n    expiration = Math.max(expiration, 60);\r\n    expiration = Math.min(expiration, 5);\r\n    this._expirationTime = BeDuration.fromSeconds(expiration);\r\n\r\n    this._removeIModelConnectionOnCloseListener = IModelConnection.onClose.addListener((iModel) => this.onIModelClosed(iModel));\r\n  }\r\n\r\n  public get enableInstancing() { return this._enableInstancing && IModelApp.renderSystem.supportsInstancing; }\r\n  public get useProjectExtents() { return this._useProjectExtents; }\r\n  public get tileExpirationTime() { return this._expirationTime; }\r\n\r\n  public getMaximumMajorTileFormatVersion(formatVersion?: number): number {\r\n    // The input is from the backend, telling us precisely the maximum major+minor version it can produce.\r\n    // Ensure front-end does not request tiles of a newer major version than backend can supply or it can read; and also limit major version\r\n    // to that optionally configured by the app.\r\n    let majorVersion = this._maxMajorVersion;\r\n    if (undefined !== formatVersion)\r\n      majorVersion = Math.min((formatVersion >>> 0x10), majorVersion);\r\n\r\n    // Version number less than 1 is invalid - ignore\r\n    majorVersion = Math.max(majorVersion, 1);\r\n\r\n    // Version number greater than current known version ignored\r\n    majorVersion = Math.min(majorVersion, IModelTileIO.CurrentVersion.Major);\r\n\r\n    // Version numbers are integers - round down\r\n    return Math.max(Math.floor(majorVersion), 1);\r\n  }\r\n\r\n  public get maxActiveRequests() { return this._maxActiveRequests; }\r\n  public set maxActiveRequests(max: number) {\r\n    if (max > 0)\r\n      this._maxActiveRequests = max;\r\n  }\r\n\r\n  public process(): void {\r\n    this._numCanceled = 0;\r\n\r\n    // Mark all requests as being associated with no Viewports, indicating they are no longer needed.\r\n    this._uniqueViewportSets.clearAll();\r\n\r\n    // Process all requests, enqueueing on new queue.\r\n    const previouslyPending = this._pendingRequests;\r\n    this._pendingRequests = this._swapPendingRequests;\r\n    this._swapPendingRequests = previouslyPending;\r\n\r\n    const previouslyActive = this._activeRequests;\r\n    this._activeRequests = this._swapActiveRequests;\r\n\r\n    this._requestsPerViewport.forEach((key, value) => this.processRequests(key, value));\r\n\r\n    if (!this._throttle)\r\n      return;\r\n\r\n    // Cancel any previously pending requests which are no longer needed.\r\n    for (const queued of previouslyPending)\r\n      if (queued.viewports.isEmpty)\r\n        this.cancel(queued);\r\n\r\n    previouslyPending.clear();\r\n\r\n    // Cancel any active requests which are no longer needed.\r\n    for (const active of previouslyActive) {\r\n      if (active.viewports.isEmpty)\r\n        this.cancel(active);\r\n      else\r\n        this._activeRequests.add(active);\r\n    }\r\n\r\n    previouslyActive.clear();\r\n    this._swapActiveRequests = previouslyActive;\r\n\r\n    // Fill up the active requests from the queue.\r\n    while (this._activeRequests.size < this._maxActiveRequests) {\r\n      const request = this._pendingRequests.pop();\r\n      if (undefined === request)\r\n        break;\r\n      else\r\n        this.dispatch(request);\r\n    }\r\n  }\r\n\r\n  private processRequests(vp: Viewport, tiles: Set<Tile>): void {\r\n    for (const tile of tiles) {\r\n      if (undefined === tile.request) {\r\n        // ###TODO: This assertion triggers for AttachmentViewports used for rendering 3d sheet attachments.\r\n        // Determine why and fix.\r\n        // assert(tile.loadStatus === Tile.LoadStatus.NotLoaded);\r\n        if (Tile.LoadStatus.NotLoaded === tile.loadStatus) {\r\n          const request = new TileRequest(tile, vp);\r\n          tile.request = request;\r\n          if (this._throttle)\r\n            this._pendingRequests.push(request);\r\n          else\r\n            this.dispatch(request);\r\n        }\r\n      } else {\r\n        const req = tile.request;\r\n        assert(undefined !== req);\r\n        if (undefined !== req) {\r\n          // Request may already be dispatched (in this._activeRequests) - if so do not re-enqueue!\r\n          if (req.isQueued && 0 === req.viewports.length)\r\n            this._pendingRequests.push(req);\r\n\r\n          req.addViewport(vp);\r\n          assert(0 < req.viewports.length);\r\n        }\r\n      }\r\n    }\r\n  }\r\n\r\n  public getNumRequestsForViewport(vp: Viewport): number {\r\n    const requests = this._requestsPerViewport.get(vp);\r\n    return undefined !== requests ? requests.size : 0;\r\n  }\r\n\r\n  public requestTiles(vp: Viewport, tiles: Set<Tile>): void {\r\n    this._requestsPerViewport.set(vp, tiles);\r\n  }\r\n\r\n  public forgetViewport(vp: Viewport): void {\r\n    // NB: vp will be removed from ViewportSets in process() - but if we can establish that only this vp wants a given tile, cancel its request immediately.\r\n    const tiles = this._requestsPerViewport.get(vp);\r\n    if (undefined !== tiles) {\r\n      for (const tile of tiles) {\r\n        const request = tile.request;\r\n        if (undefined !== request && 1 === request.viewports.length)\r\n          request.cancel();\r\n      }\r\n\r\n      this._requestsPerViewport.delete(vp);\r\n    }\r\n  }\r\n\r\n  private onIModelClosed(iModel: IModelConnection): void {\r\n    this._requestsPerViewport.forEach((vp, _req) => {\r\n      if (vp.iModel === iModel)\r\n        this.forgetViewport(vp);\r\n    });\r\n  }\r\n\r\n  public onShutDown(): void {\r\n    this._removeIModelConnectionOnCloseListener();\r\n\r\n    for (const request of this._activeRequests)\r\n      request.cancel();\r\n\r\n    this._activeRequests.clear();\r\n\r\n    for (const queued of this._pendingRequests)\r\n      queued.cancel();\r\n\r\n    this._requestsPerViewport.clear();\r\n    this._uniqueViewportSets.clear();\r\n  }\r\n\r\n  private dispatch(req: TileRequest): void {\r\n    this._activeRequests.add(req);\r\n    req.dispatch().then(() => this.dropActiveRequest(req)) // tslint:disable-line no-floating-promises\r\n      .catch(() => this.dropActiveRequest(req));\r\n  }\r\n\r\n  private cancel(req: TileRequest) {\r\n    req.cancel();\r\n    ++this._numCanceled;\r\n  }\r\n\r\n  private dropActiveRequest(req: TileRequest) {\r\n    assert(this._activeRequests.has(req) || req.isCanceled);\r\n    this._activeRequests.delete(req);\r\n  }\r\n\r\n  public getViewportSet(vp: Viewport, vps?: TileAdmin.ViewportSet): TileAdmin.ViewportSet {\r\n    return this._uniqueViewportSets.getViewportSet(vp, vps);\r\n  }\r\n\r\n  public async requestTileTreeProps(iModel: IModelConnection, treeId: string): Promise<TileTreeProps> {\r\n    this.initializeRpc();\r\n    const intfc = IModelTileRpcInterface.getClient();\r\n    return intfc.requestTileTreeProps(iModel.iModelToken.toJSON(), treeId);\r\n  }\r\n\r\n  public async requestTileContent(iModel: IModelConnection, treeId: string, contentId: string): Promise<Uint8Array> {\r\n    this.initializeRpc();\r\n    const intfc = IModelTileRpcInterface.getClient();\r\n    return intfc.requestTileContent(iModel.iModelToken.toJSON(), treeId, contentId);\r\n  }\r\n\r\n  private initializeRpc(): void {\r\n    // Would prefer to do this in constructor - but nothing enforces that the app initializes the rpc interfaces before it creates the TileAdmin (via IModelApp.startup()) - so do it on first request instead.\r\n    if (this._rpcInitialized)\r\n      return;\r\n\r\n    this._rpcInitialized = true;\r\n    const retryInterval = this._retryInterval;\r\n    RpcOperation.lookup(IModelTileRpcInterface, \"requestTileTreeProps\").policy.retryInterval = () => retryInterval;\r\n\r\n    const policy = RpcOperation.lookup(IModelTileRpcInterface, \"requestTileContent\").policy;\r\n    policy.retryInterval = () => retryInterval;\r\n    policy.allowResponseCaching = () => RpcResponseCacheControl.Immutable;\r\n  }\r\n\r\n  public onTileFailed(_tile: Tile) { ++this._totalFailed; }\r\n  public onTileTimedOut(_tile: Tile) { ++this._totalTimedOut; }\r\n  public onTileElided() { ++this._totalElided; }\r\n  public onTileCompleted(tile: Tile) {\r\n    ++this._totalCompleted;\r\n    if (tile.isEmpty)\r\n      ++this._totalEmpty;\r\n    else if (!tile.isDisplayable)\r\n      ++this._totalUndisplayable;\r\n  }\r\n}\r\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\n\nimport { assert, Id64, Id64String } from \"@bentley/bentleyjs-core\";\nimport { Point3d } from \"@bentley/geometry-core\";\nimport { MeshList } from \"../render/primitives/mesh/MeshPrimitives\";\n\n// tslint:disable:no-const-enum\n\n/** Provides facilities for deserializing 3d tiles.\n * @internal\n */\nexport namespace TileIO {\n  /** Status codes for tile reading operations\n   * @internal\n   */\n  export const enum ReadStatus {\n    Success = 0,\n    InvalidTileData,\n    InvalidHeader,\n    InvalidBatchTable,\n    InvalidScene,\n    InvalidFeatureTable,\n    NewerMajorVersion,\n    Canceled,\n  }\n\n  /** Type codes for various tile formats. Often these are embedded as 'magic numbers' in a binary stream to indicate the format.\n   * @internal\n   */\n  export const enum Format {\n    Unknown = 0,\n    B3dm = 0x6d643362, // \"b3dm\"\n    Gltf = 0x46546c67, // \"glTF\"\n    Pnts = 0x73746e70,  // \"pnts\"\n    IModel = 0x6c644d69, // \"iMdl\"\n    Cmpt = 0x74706d63,  // cmpt\n    I3dm = 0x6d643369,  // i3dm\n  }\n\n  /** Given a magic number, return whether it identifies a known tile format. */\n  function isValidFormat(format: number) {\n    switch (format) {\n      case Format.Unknown:\n      case Format.B3dm:\n      case Format.Gltf:\n      case Format.IModel:\n      case Format.Pnts:\n      case Format.Cmpt:\n      case Format.I3dm:\n        return true;\n      default:\n        return false;\n    }\n  }\n\n  /** Given a magic number, attempt to convert it to a known tile Format. */\n  function formatFromNumber(formatNumber: number): Format {\n    const format = formatNumber as Format;\n    return isValidFormat(format) ? format : Format.Unknown;\n  }\n\n  /**\n   * Wraps a binary stream along with a current read position. The position can be adjusted by the caller.\n   * Methods and properties beginning with 'next' consume data at the current read position and advance it\n   * by the size of the data read.\n   * @internal\n   */\n  export class StreamBuffer {\n    private readonly _view: DataView;\n    private _curPos: number = 0;\n\n    public constructor(buffer: ArrayBuffer | SharedArrayBuffer) {\n      this._view = new DataView(buffer);\n    }\n\n    /** The number of bytes in this stream */\n    public get length(): number { return this._view.byteLength; }\n    /** Returns true if the current read position has been advanced past the end of the stream */\n    public get isPastTheEnd(): boolean { return this.curPos > this.length; }\n\n    /** Returns the current read position as an index into the stream of bytes */\n    public get curPos(): number { return this._curPos; }\n    /** Sets the current read position to the specified index into the stream of bytes */\n    public set curPos(pos: number) { this._curPos = pos; assert(!this.isPastTheEnd); }\n\n    /** Add the specified number of bytes to the current read position */\n    public advance(numBytes: number): boolean { this.curPos = (this.curPos + numBytes); return !this.isPastTheEnd; }\n    /** Subtracts the specified number of bytes from the current read position */\n    public rewind(numBytes: number): boolean { if (this.curPos - numBytes < 0) return false; this.curPos = this.curPos - numBytes; return true; }\n    /** Resets the current read position to the beginning of the stream */\n    public reset(): void { this.curPos = 0; }\n\n    /** Read a uint8 at the current read position and advance by 1 byte. */\n    public get nextUint8(): number { return this.read(1, (view) => view.getUint8(this.curPos)); }\n    /** Read a uint16 at the current read position and advance by 2 bytes. */\n    public get nextUint16(): number { return this.read(2, (view) => view.getUint16(this.curPos, true)); }\n    /** Read a uint32 at the current read position and advance by 4 bytes. */\n    public get nextUint32(): number { return this.read(4, (view) => view.getUint32(this.curPos, true)); }\n    /** Read a 32-bit floating point number at the current read position and advance by 4 bytes. */\n    public get nextFloat32(): number { return this.read(4, (view) => view.getFloat32(this.curPos, true)); }\n    /** Read a 64-bit floating point number at the current read position and advance by 8 bytes. */\n    public get nextFloat64(): number { return this.read(8, (view) => view.getFloat64(this.curPos, true)); }\n    /** Read 3 64-bit floating point numbers at the current read position, advance by 24 bytes, and return a Point3d constructed from the 3 numbers. */\n    public get nextPoint3d64(): Point3d { return new Point3d(this.nextFloat64, this.nextFloat64, this.nextFloat64); }\n    /** Read a uint64 at the current read position, advance by 8 bytes, and return the uint64 value as an Id64String. */\n    public get nextId64(): Id64String { return Id64.fromUint32Pair(this.nextUint32, this.nextUint32); }\n\n    /** Read the next numBytes bytes into a Uint8Array and advance by numBytes. */\n    public nextBytes(numBytes: number): Uint8Array {\n      const bytes = new Uint8Array(this.arrayBuffer, this.curPos, numBytes);\n      this.advance(numBytes);\n      return bytes;\n    }\n\n    public nextUint32s(numUint32s: number): Uint32Array {\n      const numBytes = numUint32s * 4;\n      const uint32s = new Uint32Array(this.arrayBuffer, this.curPos, numUint32s);\n      this.advance(numBytes);\n      return uint32s;\n    }\n\n    /** Returns the underlying array buffer */\n    public get arrayBuffer(): ArrayBuffer | SharedArrayBuffer { return this._view.buffer; }\n\n    private read(numBytes: number, read: (view: DataView) => number) {\n      const result = read(this._view);\n      this.advance(numBytes);\n      return result;\n    }\n  }\n\n  /**\n   * The base header preceding tile data, identifying the tile format and version of that format.\n   * Specific tile formats may define their own headers as sub-types of this Header, appending\n   * additional format-specific data.\n   * @internal\n   */\n  export abstract class Header {\n    private _format: Format;\n    public version: number;\n\n    /** Construct a Header from the binary data at the supplied stream's current read position */\n    public constructor(stream: StreamBuffer) {\n      this._format = formatFromNumber(stream.nextUint32);\n      this.version = stream.nextUint32;\n    }\n\n    public get format(): Format { return this._format; }\n\n    /** Returns whether the header represents valid data */\n    public abstract get isValid(): boolean;\n\n    /** Mark the header as representing invalid data */\n    protected invalidate(): void { this._format = Format.Unknown; }\n  }\n\n  /** @internal */\n  export class GeometryCollection {\n    public constructor(public readonly meshes: MeshList,\n      public readonly isComplete: boolean,\n      public readonly isCurved: boolean) { }\n\n    public get isEmpty(): boolean { return 0 === this.meshes.length; }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\n\nimport { assert, base64StringToUint8Array, IModelStatus } from \"@bentley/bentleyjs-core\";\nimport { ImageSource } from \"@bentley/imodeljs-common\";\nimport { Tile, TileTree, TileLoader } from \"./TileTree\";\nimport { TileAdmin } from \"./TileAdmin\";\nimport { Viewport } from \"../Viewport\";\nimport { IModelApp } from \"../IModelApp\";\n\n/** Represents a pending or active request to load the contents of a [[Tile]]. The request coordinates with a [[TileLoader]] to execute the request for tile content and\n * convert the result into a renderable graphic.\n * @internal\n */\nexport class TileRequest {\n  /** The requested tile. While the request is pending or active, `tile.request` points back to this TileRequest. */\n  public readonly tile: Tile;\n  /** Determines the order in which pending requests are pulled off the queue to become active. A tile with a lower value takes precedence over one with a higher value. */\n  /** The set of [[Viewport]]s that are awaiting the result of this request. When this becomes empty, the request is canceled because no viewport cares about it. */\n  public viewports: TileAdmin.ViewportSet;\n  private _state: TileRequest.State;\n\n  public constructor(tile: Tile, vp: Viewport) {\n    this._state = TileRequest.State.Queued;\n    this.tile = tile;\n    this.viewports = IModelApp.tileAdmin.getViewportSet(vp);\n  }\n\n  public get state(): TileRequest.State { return this._state; }\n  public get isQueued() { return TileRequest.State.Queued === this._state; }\n  public get isCanceled(): boolean { return this.viewports.isEmpty; } // ###TODO: check if IModelConnection closed etc.\n\n  public get tree(): TileTree { return this.tile.root; }\n  public get loader(): TileLoader { return this.tree.loader; }\n\n  public addViewport(vp: Viewport): void {\n    this.viewports = IModelApp.tileAdmin.getViewportSet(vp, this.viewports);\n  }\n\n  /** Transition the request from \"queued\" to \"active\", kicking off a series of asynchronous operations usually beginning with an http request, and -\n   * if the request is not subsequently canceled - resulting in either a successfully-loaded Tile, or a failed (\"not found\") Tile.\n   */\n  public async dispatch(): Promise<void> {\n    try {\n      if (this.isCanceled)\n        return Promise.resolve();\n\n      assert(this._state === TileRequest.State.Queued);\n      this._state = TileRequest.State.Dispatched;\n      const response = await this.loader.requestTileContent(this.tile);\n      if (this.isCanceled)\n        return Promise.resolve();\n\n      return this.handleResponse(response);\n    } catch (_err) {\n      if (_err.errorNumber && _err.errorNumber === IModelStatus.ServerTimeout) {\n        // Invalidate scene - if tile is re-selected, it will be re-requested.\n        this.notifyAndClear();\n        this._state = TileRequest.State.Failed;\n        IModelApp.tileAdmin.onTileTimedOut(this.tile);\n      } else {\n        // Unknown error - not retryable.\n        this.setFailed();\n      }\n\n      return Promise.resolve();\n    }\n  }\n\n  /** Cancels this request. This leaves the associated Tile's state untouched. */\n  public cancel(): void {\n    this.notifyAndClear();\n    this._state = TileRequest.State.Failed;\n  }\n\n  /** Invalidates the scene of each [[Viewport]] interested in this request - typically because the request succeeded, failed, or was canceled. */\n  private notify(): void {\n    this.viewports.forEach((vp) => vp.invalidateScene());\n  }\n\n  /** Invalidates the scene of each [[Viewport]] interested in this request and clears the set of interested viewports. */\n  private notifyAndClear(): void {\n    this.notify();\n    this.viewports = IModelApp.tileAdmin.emptyViewportSet;\n    this.tile.request = undefined;\n  }\n\n  private setFailed() {\n    this.notifyAndClear();\n    this._state = TileRequest.State.Failed;\n    this.tile.setNotFound();\n    IModelApp.tileAdmin.onTileFailed(this.tile);\n  }\n\n  /** Invoked when the raw tile content becomes available, to convert it into a tile graphic. */\n  private async handleResponse(response: TileRequest.Response): Promise<void> {\n    let data: TileRequest.ResponseData | undefined;\n    if (undefined !== response) {\n      if (typeof response === \"string\")\n        data = base64StringToUint8Array(response);\n      else if (response instanceof Uint8Array || response instanceof ImageSource)\n        data = response;\n      else if (response instanceof ArrayBuffer)\n        data = new Uint8Array(response);\n    }\n\n    if (undefined === data) {\n      this.setFailed();\n      return Promise.resolve();\n    }\n\n    this._state = TileRequest.State.Loading;\n\n    try {\n      const content = await this.loader.loadTileContent(this.tile, data);\n      if (this.isCanceled)\n        return Promise.resolve();\n\n      this._state = TileRequest.State.Completed;\n      this.tile.setContent(content);\n      this.notifyAndClear();\n      IModelApp.tileAdmin.onTileCompleted(this.tile);\n    } catch (_err) {\n      this.setFailed();\n    }\n\n    return Promise.resolve();\n  }\n}\n// tslint:disable:no-const-enum\n\n/** @internal */\nexport namespace TileRequest {\n  /** The type of a raw response to a request for tile content. Processed upon receipt into a [[TileRequest.Response]] type.\n   * @internal\n   */\n  export type Response = Uint8Array | ArrayBuffer | string | ImageSource | undefined;\n  /** The input to [[TileLoader.loadTileContent]], to be converted into a [[Tile.Content]].\n   * @internal\n   */\n  export type ResponseData = Uint8Array | ImageSource;\n\n  /** The states through which a TileRequest proceeds. During the first 3 states, the [[Tile]]'s `request` member is defined, and its [[Tile.LoadStatus]] is computed based on the state of its request.\n   * @internal\n   */\n  export const enum State {\n    /** Initial state. Request is pending but not yet dispatched. */\n    Queued,\n    /** Follows `Queued` when request begins to be actively processed. */\n    Dispatched,\n    /** Follows `Dispatched` when tile content is being converted into tile graphics. */\n    Loading,\n    /** Follows `Loading` when tile graphic has successfully been produced. */\n    Completed,\n    /** Follows any state in which an error prevents progression, or during which the request was canceled. */\n    Failed,\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\n\nimport {\n  assert,\n  BeDuration,\n  BeTimePoint,\n  dispose,\n  Id64,\n  Id64String,\n  IDisposable,\n  JsonUtils,\n} from \"@bentley/bentleyjs-core\";\nimport {\n  Arc3d,\n  ClipPlaneContainment,\n  ClipVector,\n  Point2d,\n  Point3d,\n  Range3d,\n  Transform,\n  Vector3d,\n  Matrix4d,\n  Point4d,\n} from \"@bentley/geometry-core\";\nimport {\n  BatchType,\n  BoundingSphere,\n  ColorDef,\n  ElementAlignedBox3d,\n  Frustum,\n  FrustumPlanes,\n  RenderMode,\n  TileProps,\n  TileTreeProps,\n  ViewFlag,\n  ViewFlags,\n} from \"@bentley/imodeljs-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { GraphicBranch, RenderClipVolume, RenderGraphic, RenderMemory, RenderPlanarClassifier } from \"../render/System\";\nimport { GraphicBuilder } from \"../render/GraphicBuilder\";\nimport { SceneContext } from \"../ViewContext\";\nimport { ViewFrustum } from \"../Viewport\";\nimport { B3dmTileIO } from \"./B3dmTileIO\";\nimport { CompositeTileIO } from \"./CompositeTileIO\";\nimport { GltfTileIO } from \"./GltfTileIO\";\nimport { I3dmTileIO } from \"./I3dmTileIO\";\nimport { IModelTileIO } from \"./IModelTileIO\";\nimport { PntsTileIO } from \"./PntsTileIO\";\nimport { TileIO } from \"./TileIO\";\nimport { TileRequest } from \"./TileRequest\";\n\nconst scratchRange2d = [new Point2d(), new Point2d(), new Point2d(), new Point2d()];\nfunction addRangeGraphic(builder: GraphicBuilder, range: Range3d, is2d: boolean): void {\n  if (!is2d) {\n    builder.addRangeBox(range);\n    return;\n  }\n\n  // 3d box is useless in 2d and will be clipped by near/far planes anyway\n  const pts = scratchRange2d;\n  pts[0].set(range.low.x, range.low.y);\n  pts[1].set(range.high.x, range.low.y);\n  pts[2].set(range.high.x, range.high.y);\n  pts[3].set(range.low.x, range.high.y);\n  builder.addLineString2d(pts, 0);\n}\n\n/** A 3d tile within a [[TileTree]].\n * @internal\n */\nexport class Tile implements IDisposable, RenderMemory.Consumer {\n  public readonly root: TileTree;\n  public readonly range: ElementAlignedBox3d;\n  public readonly parent: Tile | undefined;\n  public readonly depth: number;\n  public contentId: string;\n  public readonly center: Point3d;\n  public readonly radius: number;\n  public readonly transformToRoot?: Transform;\n  protected _maximumSize: number;\n  protected _isLeaf: boolean;\n  protected _childrenLastUsed: BeTimePoint;\n  protected _childrenLoadStatus: TileTree.LoadStatus;\n  protected _children?: Tile[];\n  protected _contentRange?: ElementAlignedBox3d;\n  protected _graphic?: RenderGraphic;\n  protected _rangeGraphic?: RenderGraphic;\n  protected _rangeGraphicType: Tile.DebugBoundingBoxes = Tile.DebugBoundingBoxes.None;\n  protected _sizeMultiplier?: number;\n  protected _request?: TileRequest;\n  protected _transformToRoot?: Transform;\n  protected _localRange?: ElementAlignedBox3d;\n  protected _localContentRange?: ElementAlignedBox3d;\n  protected _emptySubRangeMask?: number;\n  private _state: TileState;\n\n  public constructor(props: Tile.Params) {\n    this.root = props.root;\n    this.range = props.range;\n    this.parent = props.parent;\n    this.depth = undefined !== this.parent ? this.parent.depth + 1 : 0;\n    this._state = TileState.NotReady;\n    this.contentId = props.contentId;\n    this._maximumSize = props.maximumSize;\n    this._isLeaf = (true === props.isLeaf);\n    this._childrenLastUsed = BeTimePoint.now();\n    this._contentRange = props.contentRange;\n    this._sizeMultiplier = props.sizeMultiplier;\n    if (undefined !== (this.transformToRoot = props.transformToRoot)) {\n      this.transformToRoot.multiplyRange(props.range, this.range);\n      this._localRange = this.range;\n      if (undefined !== props.contentRange) {\n        this.transformToRoot.multiplyRange(props.contentRange, this._contentRange);\n        this._localContentRange = props.contentRange;\n      }\n    }\n    if (!this.root.loader.tileRequiresLoading(props)) {\n      this.setIsReady();    // If no contents, this node is for structure only and no content loading is required.\n    }\n\n    this.center = this.range.low.interpolate(0.5, this.range.high);\n    this.radius = 0.5 * this.range.low.distance(this.range.high);\n\n    this._childrenLoadStatus = this.hasChildren && this.depth < this.root.loader.maxDepth ? TileTree.LoadStatus.NotLoaded : TileTree.LoadStatus.Loaded;\n  }\n\n  public dispose() {\n    this._graphic = dispose(this._graphic);\n    this._rangeGraphic = dispose(this._rangeGraphic);\n    this._rangeGraphicType = Tile.DebugBoundingBoxes.None;\n\n    if (this._children)\n      for (const child of this._children)\n        dispose(child);\n\n    this._children = undefined;\n    this._state = TileState.Abandoned;\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    if (undefined !== this._graphic)\n      this._graphic.collectStatistics(stats);\n\n    if (undefined !== this._children)\n      for (const child of this._children)\n        child.collectStatistics(stats);\n  }\n\n  /* ###TODO\n  public cancelAllLoads(): void {\n    if (this.isLoading) {\n      this.loadStatus = Tile.LoadStatus.NotLoaded;\n      if (this._children !== undefined) {\n        for (const child of this._children)\n          child.cancelAllLoads();\n      }\n    }\n  }\n  */\n\n  public get loadStatus(): Tile.LoadStatus {\n    switch (this._state) {\n      case TileState.NotReady: {\n        if (undefined === this.request)\n          return Tile.LoadStatus.NotLoaded;\n        else if (TileRequest.State.Loading === this.request.state)\n          return Tile.LoadStatus.Loading;\n\n        assert(TileRequest.State.Completed !== this.request.state && TileRequest.State.Failed !== this.request.state); // this.request should be undefined in these cases...\n        return Tile.LoadStatus.Queued;\n      }\n      case TileState.Ready: {\n        assert(undefined === this.request);\n        return Tile.LoadStatus.Ready;\n      }\n      case TileState.NotFound: {\n        assert(undefined === this.request);\n        return Tile.LoadStatus.NotFound;\n      }\n      default: {\n        assert(TileState.Abandoned === this._state);\n        return Tile.LoadStatus.Abandoned;\n      }\n    }\n  }\n\n  public get isLoading(): boolean { return Tile.LoadStatus.Loading === this.loadStatus; }\n  public get isNotFound(): boolean { return Tile.LoadStatus.NotFound === this.loadStatus; }\n  public get isReady(): boolean { return Tile.LoadStatus.Ready === this.loadStatus; }\n\n  public setContent(content: Tile.Content): void {\n    const { graphic, isLeaf, contentRange, sizeMultiplier } = content;\n\n    this._graphic = graphic;\n\n    // NB: If this tile has no graphics, it may or may not have children - but we don't want to load the children until\n    // this tile is too coarse for view based on its size in pixels.\n    // That is different than an \"undisplayable\" tile (maximumSize=0) whose children should be loaded immediately.\n    if (undefined !== graphic && 0 === this._maximumSize)\n      this._maximumSize = 512;\n\n    if (undefined !== isLeaf && isLeaf !== this._isLeaf) {\n      this._isLeaf = isLeaf;\n      this.unloadChildren();\n    }\n\n    if (undefined !== sizeMultiplier && (undefined === this._sizeMultiplier || sizeMultiplier > this._sizeMultiplier)) {\n      this._sizeMultiplier = sizeMultiplier;\n      this.contentId = this.loader.adjustContentIdSizeMultiplier(this.contentId, sizeMultiplier);\n      if (undefined !== this._children && this._children.length > 1)\n        this.unloadChildren();\n    }\n\n    if (undefined !== contentRange)\n      this._contentRange = contentRange;\n\n    this._emptySubRangeMask = content.emptySubRangeMask;\n\n    this.setIsReady();\n  }\n\n  public setIsReady(): void { this._state = TileState.Ready; IModelApp.viewManager.onNewTilesReady(); }\n  public setNotFound(): void { this._state = TileState.NotFound; }\n  public setAbandoned(): void {\n    const children = this.children;\n    if (undefined !== children)\n      for (const child of children)\n        child.setAbandoned();\n\n    this._state = TileState.Abandoned;\n  }\n\n  public get maximumSize(): number { return this._maximumSize * this.sizeMultiplier; }\n  public get isEmpty(): boolean { return this.isReady && !this.hasGraphics && !this.hasChildren; }\n  public get hasChildren(): boolean { return !this.isLeaf; }\n  public get contentRange(): ElementAlignedBox3d {\n    if (undefined !== this._contentRange)\n      return this._contentRange;\n    else if (undefined === this.parent && undefined !== this.root.contentRange)\n      return this.root.contentRange;\n    else\n      return this.range;\n  }\n\n  public get isLeaf(): boolean { return this._isLeaf; }\n  public get isDisplayable(): boolean { return this.maximumSize > 0; }\n  public get isParentDisplayable(): boolean { return undefined !== this.parent && this.parent.isDisplayable; }\n  public get isUndisplayableRootTile(): boolean { return undefined === this.parent && !this.isDisplayable; }\n  public get emptySubRangeMask(): number { return undefined !== this._emptySubRangeMask ? this._emptySubRangeMask : 0; }\n\n  public get graphics(): RenderGraphic | undefined { return this._graphic; }\n  public get hasGraphics(): boolean { return undefined !== this.graphics; }\n  public get sizeMultiplier(): number { return undefined !== this._sizeMultiplier ? this._sizeMultiplier : 1.0; }\n  public get hasSizeMultiplier(): boolean { return undefined !== this._sizeMultiplier; }\n  public get children(): Tile[] | undefined { return this._children; }\n  public get iModel(): IModelConnection { return this.root.iModel; }\n  public get yAxisUp(): boolean { return this.root.yAxisUp; }\n  public get loader(): TileLoader { return this.root.loader; }\n\n  public get hasContentRange(): boolean { return undefined !== this._contentRange; }\n  public isRegionCulled(args: Tile.DrawArgs): boolean { return Tile._scratchRootSphere.init(this.center, this.radius), this.isCulled(this.range, args, Tile._scratchRootSphere); }\n  public isContentCulled(args: Tile.DrawArgs): boolean { return this.isCulled(this.contentRange, args); }\n\n  private getRangeGraphic(context: SceneContext): RenderGraphic | undefined {\n    const type = context.viewport.debugBoundingBoxes;\n    if (type === this._rangeGraphicType)\n      return this._rangeGraphic;\n\n    this._rangeGraphicType = type;\n    this._rangeGraphic = dispose(this._rangeGraphic);\n    if (Tile.DebugBoundingBoxes.None !== type) {\n      const builder = context.createSceneGraphicBuilder();\n      if (Tile.DebugBoundingBoxes.Both === type) {\n        builder.setSymbology(ColorDef.blue, ColorDef.blue, 1);\n        addRangeGraphic(builder, this.range, this.root.is2d);\n        if (this.hasContentRange) {\n          builder.setSymbology(ColorDef.red, ColorDef.red, 1);\n          addRangeGraphic(builder, this.contentRange, this.root.is2d);\n        }\n      } else if (Tile.DebugBoundingBoxes.ChildVolumes === type) {\n        const ranges = computeChildRanges(this);\n        for (const range of ranges) {\n          const color = range.isEmpty ? ColorDef.blue : ColorDef.green;\n          builder.setSymbology(color, color, 1);\n          addRangeGraphic(builder, range.range, this.root.is2d);\n        }\n      } else if (Tile.DebugBoundingBoxes.Sphere === type) {\n        builder.setSymbology(ColorDef.green, ColorDef.green, 1);\n\n        const x = new Vector3d(this.radius, 0, 0);\n        const y = new Vector3d(0, this.radius, 0);\n        const z = new Vector3d(0, 0, this.radius);\n        builder.addArc(Arc3d.create(this.center, x, y), false, false);\n        builder.addArc(Arc3d.create(this.center, x, z), false, false);\n        builder.addArc(Arc3d.create(this.center, y, z), false, false);\n      } else {\n        const color = this.hasSizeMultiplier ? ColorDef.red : (this.isLeaf ? ColorDef.blue : ColorDef.green);\n        builder.setSymbology(color, color, 1);\n        const range = Tile.DebugBoundingBoxes.Content === type ? this.contentRange : this.range;\n        addRangeGraphic(builder, range, this.root.is2d);\n      }\n\n      this._rangeGraphic = builder.finish();\n    }\n\n    return this._rangeGraphic;\n  }\n\n  /** Returns the range of this tile's contents in world coordinates. */\n  public computeWorldContentRange(): ElementAlignedBox3d {\n    const range = new Range3d();\n    if (!this.contentRange.isNull)\n      this.root.location.multiplyRange(this.contentRange, range);\n\n    return range;\n  }\n\n  public computeVisibility(args: Tile.DrawArgs): Tile.Visibility {\n    const forcedDepth = this.root.debugForcedDepth;\n    if (undefined !== forcedDepth) {\n      if (this.depth === forcedDepth)\n        return Tile.Visibility.Visible;\n      else\n        return Tile.Visibility.TooCoarse;\n    }\n\n    // NB: We test for region culling before isDisplayable - otherwise we will never unload children of undisplayed tiles when\n    // they are outside frustum\n    if (this.isEmpty || this.isRegionCulled(args))\n      return Tile.Visibility.OutsideFrustum;\n\n    // some nodes are merely for structure and don't have any geometry\n    if (!this.isDisplayable)\n      return Tile.Visibility.TooCoarse;\n\n    const hasContentRange = this.hasContentRange;\n    if (!this.hasChildren) {\n      if (hasContentRange && this.isContentCulled(args))\n        return Tile.Visibility.OutsideFrustum;\n      else\n        return Tile.Visibility.Visible; // it's a leaf node\n    }\n\n    const radius = args.getTileRadius(this); // use a sphere to test pixel size. We don't know the orientation of the image within the bounding box.\n    const center = args.getTileCenter(this);\n\n    const pixelSizeAtPt = args.getPixelSizeAtPoint(center);\n    const pixelSize = 0 !== pixelSizeAtPt ? radius / pixelSizeAtPt : 1.0e-3;\n\n    if (pixelSize > this.maximumSize * args.tileSizeModifier)\n      return Tile.Visibility.TooCoarse;\n    else if (hasContentRange && this.isContentCulled(args))\n      return Tile.Visibility.OutsideFrustum;\n    else\n      return Tile.Visibility.Visible;\n  }\n\n  public selectTiles(selected: Tile[], args: Tile.DrawArgs, numSkipped: number = 0): Tile.SelectParent {\n    const vis = this.computeVisibility(args);\n    if (Tile.Visibility.OutsideFrustum === vis) {\n      this.unloadChildren(args.purgeOlderThan);\n      return Tile.SelectParent.No;\n    }\n    if (Tile.Visibility.Visible === vis) {\n      // This tile is of appropriate resolution to draw. If need loading or refinement, enqueue.\n      if (!this.isReady) {\n        args.insertMissing(this);\n      }\n\n      if (this.hasGraphics) {\n        // It can be drawn - select it\n        ++args.context.viewport.numReadyTiles;\n        selected.push(this);\n        this.unloadChildren(args.purgeOlderThan);\n      } else if (!this.isReady) {\n        // It can't be drawn. If direct children are drawable, draw them in this tile's place; otherwise draw the parent.\n        // Do not load/request the children for this purpose.\n        const initialSize = selected.length;\n        const kids = this.children;\n        if (undefined === kids)\n          return Tile.SelectParent.Yes;\n\n        for (const kid of kids) {\n          if (Tile.Visibility.OutsideFrustum !== kid.computeVisibility(args)) {\n            if (!kid.hasGraphics) {\n              selected.length = initialSize;\n              return Tile.SelectParent.Yes;\n            } else {\n              selected.push(kid);\n            }\n          }\n        }\n\n        this._childrenLastUsed = args.now;\n      }\n\n      // We're drawing either this tile, or its direct children.\n      return Tile.SelectParent.No;\n    }\n\n    // This tile is too coarse to draw. Try to draw something more appropriate.\n    // If it is not ready to draw, we may want to skip loading in favor of loading its descendants.\n    let canSkipThisTile = this.isReady || this.isParentDisplayable;\n    if (canSkipThisTile && this.isDisplayable) { // skipping an undisplayable tile doesn't count toward the maximum\n      // Some tiles do not sub-divide - they only facet the same geometry to a higher resolution. We can skip directly to the correct resolution.\n      const isNotReady = !this.isReady && !this.hasGraphics && !this.hasSizeMultiplier;\n      if (isNotReady) {\n        if (numSkipped >= this.root.maxTilesToSkip)\n          canSkipThisTile = false;\n        else\n          numSkipped += 1;\n      }\n    }\n\n    const childrenLoadStatus = this.loadChildren(); // NB: asynchronous\n    const children = canSkipThisTile ? this.children : undefined;\n    if (canSkipThisTile && TileTree.LoadStatus.Loading === childrenLoadStatus)\n      args.markChildrenLoading();\n\n    if (undefined !== children) {\n      // If we are the root tile and we are not displayable, then we want to draw *any* currently available children in our place, or else we would draw nothing.\n      // Otherwise, if we want to draw children in our place, we should wait for *all* of them to load, or else we would show missing chunks where not-yet-loaded children belong.\n      const isUndisplayableRootTile = this.isUndisplayableRootTile;\n      this._childrenLastUsed = args.now;\n      let drawChildren = true;\n      const initialSize = selected.length;\n      for (const child of children) {\n        // NB: We must continue iterating children so that they can be requested if missing.\n        if (Tile.SelectParent.Yes === child.selectTiles(selected, args, numSkipped)) {\n          if (child.loadStatus === Tile.LoadStatus.NotFound) {\n            // At least one child we want to draw failed to load. e.g., we reached max depth of map tile tree. Draw parent instead.\n            drawChildren = canSkipThisTile = false;\n          } else {\n            // At least one child we want to draw is not yet loaded. Wait for it to load before drawing it and its siblings, unless we have nothing to draw in their place.\n            drawChildren = isUndisplayableRootTile;\n          }\n        }\n      }\n\n      if (drawChildren)\n        return Tile.SelectParent.No;\n\n      // Some types of tiles (like maps) allow the ready children to be drawn on top of the parent while other children are not yet loaded.\n      if (this.root.loader.parentsAndChildrenExclusive)\n        selected.length = initialSize;\n    }\n\n    if (this.isReady) {\n      if (this.hasGraphics) {\n        selected.push(this);\n        if (!canSkipThisTile) {\n          // This tile is too coarse, but we require loading it before we can start loading higher-res children.\n          ++args.context.viewport.numReadyTiles;\n        }\n      }\n\n      return Tile.SelectParent.No;\n    }\n\n    // This tile is not ready to be drawn. Request it *only* if we cannot skip it.\n    if (!canSkipThisTile)\n      args.insertMissing(this);\n\n    return this.isParentDisplayable ? Tile.SelectParent.Yes : Tile.SelectParent.No;\n  }\n\n  public drawGraphics(args: Tile.DrawArgs): void {\n    if (undefined !== this.graphics) {\n      args.graphics.add(this.graphics);\n      const rangeGraphics = this.getRangeGraphic(args.context);\n      if (undefined !== rangeGraphics)\n        args.graphics.add(rangeGraphics);\n    }\n  }\n\n  protected unloadChildren(olderThan?: BeTimePoint): void {\n    const children = this.children;\n    if (undefined === children) {\n      return;\n    }\n\n    if (undefined !== olderThan && (this.isUndisplayableRootTile || this._childrenLastUsed.milliseconds > olderThan.milliseconds)) {\n      // this node has been used recently, or should never be unloaded based on expiration time. Keep it, but potentially unload its grandchildren.\n      for (const child of children)\n        child.unloadChildren(olderThan);\n    } else {\n      for (const child of children) {\n        child.setAbandoned();\n        child.dispose();\n      }\n\n      this._children = undefined;\n      this._childrenLoadStatus = TileTree.LoadStatus.NotLoaded;\n    }\n  }\n\n  private static _scratchWorldFrustum = new Frustum();\n  private static _scratchRootFrustum = new Frustum();\n  private static _scratchWorldSphere = new BoundingSphere();\n  private static _scratchRootSphere = new BoundingSphere();\n  private isCulled(range: ElementAlignedBox3d, args: Tile.DrawArgs, sphere?: BoundingSphere) {\n    const box = Frustum.fromRange(range, Tile._scratchRootFrustum);\n    const worldBox = box.transformBy(args.location, Tile._scratchWorldFrustum);\n    const worldSphere = sphere ? sphere.transformBy(args.location, Tile._scratchWorldSphere) : undefined;\n\n    // Test against frustum.\n    if (FrustumPlanes.Containment.Outside === args.frustumPlanes.computeFrustumContainment(worldBox, worldSphere))\n      return true;\n\n    // Test against TileTree's own clip volume, if any.\n    if (undefined !== args.clip && ClipPlaneContainment.StronglyOutside === args.clip.classifyPointContainment(box.points))\n      return true;\n\n    // Test against view clip, if any (will be undefined if TileTree does not want view clip applied to it).\n    if (undefined !== args.viewClip && ClipPlaneContainment.StronglyOutside === args.viewClip.classifyPointContainment(worldBox.points))\n      return true;\n\n    return false;\n  }\n\n  private loadChildren(): TileTree.LoadStatus {\n    if (TileTree.LoadStatus.NotLoaded === this._childrenLoadStatus) {\n      this._childrenLoadStatus = TileTree.LoadStatus.Loading;\n      this.root.loader.getChildrenProps(this).then((props: TileProps[]) => {\n        this._children = [];\n        this._childrenLoadStatus = TileTree.LoadStatus.Loaded;\n        if (undefined !== props) {\n          // If this tile is undisplayable, update its content range based on children's content ranges.\n          const parentRange = this.hasContentRange ? undefined : new Range3d();\n          for (const prop of props) {\n            const child = new Tile(Tile.paramsFromJSON(prop, this.root, this));\n\n            // stick the corners on the Tile (used only by WebMercator Tiles)\n            if ((prop as any).corners)\n              (child as any).corners = (prop as any).corners;\n\n            this._children.push(child);\n            if (undefined !== parentRange && !child.isEmpty)\n              parentRange.extendRange(child.contentRange);\n          }\n\n          if (undefined !== parentRange)\n            this._contentRange = parentRange;\n        }\n\n        if (0 === this._children.length) {\n          this._children = undefined;\n          this._isLeaf = true;\n        } else {\n          IModelApp.viewManager.onNewTilesReady();\n        }\n      }).catch((_err) => {\n        this._childrenLoadStatus = TileTree.LoadStatus.NotFound;\n        this._children = undefined;\n        this._isLeaf = true;\n      });\n    }\n\n    return this._childrenLoadStatus;\n  }\n\n  public debugDump(): string {\n    let str = \"  \".repeat(this.depth);\n    str += this.contentId;\n    if (undefined !== this._children) {\n      str += \" \" + this._children.length + \"\\n\";\n      for (const child of this._children)\n        str += child.debugDump();\n    } else {\n      str += \"\\n\";\n    }\n\n    return str;\n  }\n\n  public get request(): TileRequest | undefined { return this._request; }\n  public set request(request: TileRequest | undefined) {\n    assert(undefined === request || undefined === this.request);\n    this._request = request;\n  }\n}\n\n// tslint:disable:no-const-enum\n\n/** @internal */\nexport namespace Tile {\n  /**\n   * Describes the current status of a Tile. Tiles are loaded by making asynchronous requests to the backend.\n   * @internal\n   */\n  export const enum LoadStatus {\n    NotLoaded = 0, // No attempt to load the tile has been made, or the tile has since been unloaded. It currently has no graphics.\n    Queued = 1, // A request has been made to load the tile from the backend, and a response is pending.\n    Loading = 2, // A response has been received and the tile's graphics and other data are being loaded on the frontend.\n    Ready = 3, // The tile has been loaded, and if the tile is displayable it has graphics.\n    NotFound = 4, // The tile was requested, and the response from the backend indicated the tile could not be found.\n    Abandoned = 5, // A request was made to the backend, then later cancelled as it was determined that the tile is no longer needed on the frontend.\n  }\n\n  /**\n   * Describes the visibility of a tile based on its size and a view frustum.\n   * @internal\n   */\n  export const enum Visibility {\n    OutsideFrustum, // this tile is entirely outside of the viewing frustum\n    TooCoarse, // this tile is too coarse to be drawn\n    Visible, // this tile is of the correct size to be drawn\n  }\n\n  /**\n   * Returned by Tile.selectTiles() to indicate whether a parent tile should be drawn in place of a child tile.\n   * @internal\n   */\n  export const enum SelectParent {\n    No,\n    Yes,\n  }\n\n  /**\n   * Loosely describes the \"importance\" of a tile. Requests for tiles of more \"importance\" are prioritized for loading.\n   * @note A lower LoadPriority value indicates higher importance.\n   * @internal\n   */\n  export const enum LoadPriority {\n    /** Typically, tiles generated from the contents of geometric models. */\n    Primary = 0,\n    /** Typically, context reality models. */\n    Context = 1,\n    /** Supplementary tiles used to classify the contents of geometric or reality models. */\n    Classifier = 2,\n    /** Typically, map tiles. */\n    Background = 3,\n  }\n\n  /**\n   * Options for displaying tile bounding boxes for debugging purposes.\n   *\n   * Bounding boxes are color-coded based on refinement strategy:\n   *  - Blue: A leaf tile (has no child tiles).\n   *  - Green: An ordinary tile (sub-divides into 4 or 8 child tiles).\n   *  - Red: A tile which refines to a single higher-resolution child occupying the same volume.\n   * @see [[Viewport.debugBoundingBoxes]]\n   * @internal\n   */\n  export const enum DebugBoundingBoxes {\n    /** Display no bounding boxes */\n    None = 0,\n    /** Display boxes representing the tile's full volume. */\n    Volume,\n    /** Display boxes representing the range of the tile's contents, which may be tighter than (but never larger than) the tile's full volume. */\n    Content,\n    /** Display both volume and content boxes. */\n    Both,\n    /** Display boxes for direct children, where blue boxes indicate empty volumes. */\n    ChildVolumes,\n    /** Display bounding sphere. */\n    Sphere,\n  }\n\n  /**\n   * Arguments used when selecting and drawing tiles\n   * @internal\n   */\n  export class DrawArgs {\n    public readonly location: Transform;\n    public readonly root: TileTree;\n    public clipVolume?: RenderClipVolume;\n    public readonly context: SceneContext;\n    public viewFrustum?: ViewFrustum;\n    public readonly graphics: GraphicBranch = new GraphicBranch();\n    public readonly now: BeTimePoint;\n    public readonly purgeOlderThan: BeTimePoint;\n    private readonly _frustumPlanes?: FrustumPlanes;\n    public planarClassifier?: RenderPlanarClassifier;\n    public readonly viewClip?: ClipVector;\n\n    public getPixelSizeAtPoint(inPoint?: Point3d): number {\n      return this.viewFrustum !== undefined ? this.viewFrustum.getPixelSizeAtPoint(inPoint) : this.context.getPixelSizeAtPoint();\n    }\n\n    public get frustumPlanes(): FrustumPlanes {\n      return this._frustumPlanes !== undefined ? this._frustumPlanes : this.context.frustumPlanes;\n    }\n\n    public constructor(context: SceneContext, location: Transform, root: TileTree, now: BeTimePoint, purgeOlderThan: BeTimePoint, clip?: RenderClipVolume) {\n      this.location = location;\n      this.root = root;\n      this.clipVolume = clip;\n      this.context = context;\n      this.now = now;\n      this.purgeOlderThan = purgeOlderThan;\n      this.graphics.setViewFlagOverrides(root.viewFlagOverrides);\n      this.viewFrustum = context.viewFrustum;\n      if (this.viewFrustum !== undefined)\n        this._frustumPlanes = new FrustumPlanes(this.viewFrustum.getFrustum());\n\n      this.planarClassifier = context.getPlanarClassifierForModel(root.modelId);\n\n      // NB: Culling is currently feature-gated - ignore view clip if feature not enabled.\n      if (IModelApp.renderSystem.options.cullAgainstActiveVolume && context.viewFlags.clipVolume && false !== root.viewFlagOverrides.clipVolumeOverride)\n        this.viewClip = context.viewport.view.getViewClip();\n    }\n\n    public get tileSizeModifier(): number { return 1.0; } // ###TODO? may adjust for performance, or device pixel density, etc\n    public getTileCenter(tile: Tile): Point3d { return this.location.multiplyPoint3d(tile.center); }\n\n    private static _scratchRange = new Range3d();\n    public getTileRadius(tile: Tile): number {\n      let range: Range3d = tile.range.clone(DrawArgs._scratchRange);\n      range = this.location.multiplyRange(range, range);\n      return 0.5 * (tile.root.is3d ? range.low.distance(range.high) : range.low.distanceXY(range.high));\n    }\n\n    public get clip(): ClipVector | undefined { return undefined !== this.clipVolume ? this.clipVolume.clipVector : undefined; }\n\n    public drawGraphics(): void {\n      if (this.graphics.isEmpty)\n        return;\n\n      const branch = this.context.createGraphicBranch(this.graphics, this.location, this.clipVolume, this.planarClassifier);\n\n      this.context.outputGraphic(branch);\n    }\n\n    public insertMissing(tile: Tile): void {\n      this.context.insertMissingTile(tile);\n    }\n\n    public markChildrenLoading(): void { this.context.hasMissingTiles = true; }\n  }\n\n  /**\n   * Parameters used to construct a Tile.\n   * @internal\n   */\n  export interface Params {\n    readonly root: TileTree;\n    readonly contentId: string;\n    readonly range: ElementAlignedBox3d;\n    readonly maximumSize: number;\n    readonly isLeaf?: boolean;\n    readonly parent?: Tile;\n    readonly contentRange?: ElementAlignedBox3d;\n    readonly transformToRoot?: Transform;\n    readonly sizeMultiplier?: number;\n  }\n\n  /** @internal */\n  export function paramsFromJSON(props: TileProps, root: TileTree, parent?: Tile): Params {\n    const contentRange = undefined !== props.contentRange ? Range3d.fromJSON<ElementAlignedBox3d>(props.contentRange) : undefined;\n    const transformToRoot = undefined !== props.transformToRoot ? Transform.fromJSON(props.transformToRoot) : undefined;\n    return {\n      root,\n      contentId: props.contentId,\n      range: Range3d.fromJSON(props.range),\n      maximumSize: props.maximumSize,\n      isLeaf: props.isLeaf,\n      parent,\n      contentRange,\n      transformToRoot,\n      sizeMultiplier: props.sizeMultiplier,\n    };\n  }\n\n  /**\n   * Describes the contents of a Tile.\n   * @internal\n   */\n  export interface Content {\n    /** Graphical representation of the tile's geometry. */\n    graphic?: RenderGraphic;\n    /** Bounding box tightly enclosing the tile's geometry. */\n    contentRange?: ElementAlignedBox3d;\n    /** True if this tile requires no subdivision or refinement. */\n    isLeaf?: boolean;\n    /** If this tile was produced by refinement, the multiplier applied to its screen size. */\n    sizeMultiplier?: number;\n    /** A bitfield describing empty sub-volumes of this tile's volume. */\n    emptySubRangeMask?: number;\n  }\n}\n\n// Tile.LoadStatus is computed from the combination of Tile._state and, if Tile.request is defined, Tile.request.state.\nconst enum TileState {\n  NotReady = Tile.LoadStatus.NotLoaded, // Tile requires loading, but no request has yet completed.\n  Ready = Tile.LoadStatus.Ready, // request completed successfully, or no loading was required.\n  NotFound = Tile.LoadStatus.NotFound, // request failed.\n  Abandoned = Tile.LoadStatus.Abandoned, // tile was abandoned.\n}\n\n/** A hierarchical level-of-detail tree of 3d [[Tile]]s to be rendered in a [[Viewport]].\n * @internal\n */\nexport class TileTree implements IDisposable, RenderMemory.Consumer {\n  public readonly iModel: IModelConnection;\n  public readonly is3d: boolean;\n  public readonly location: Transform;\n  public readonly id: string;\n  public readonly modelId: Id64String;\n  public readonly viewFlagOverrides: ViewFlag.Overrides;\n  public readonly maxTilesToSkip: number;\n  public expirationTime: BeDuration;\n  public clipVolume?: RenderClipVolume;\n  protected _rootTile: Tile;\n  public readonly loader: TileLoader;\n  public readonly yAxisUp: boolean;\n  // If defined, tight range around the contents of the entire tile tree. This is always no more than the root tile's range, and often much smaller.\n  public readonly contentRange?: ElementAlignedBox3d;\n\n  public constructor(props: TileTree.Params) {\n    this.iModel = props.iModel;\n    this.is3d = props.is3d;\n    this.id = props.id;\n    this.modelId = Id64.fromJSON(props.modelId);\n    this.location = props.location;\n    this.expirationTime = IModelApp.tileAdmin.tileExpirationTime;\n\n    if (undefined !== props.clipVector)\n      this.clipVolume = IModelApp.renderSystem.createClipVolume(props.clipVector);\n\n    this.maxTilesToSkip = JsonUtils.asInt(props.maxTilesToSkip, 100);\n    this.loader = props.loader;\n    this._rootTile = new Tile(Tile.paramsFromJSON(props.rootTile, this)); // causes TileTree to no longer be disposed (assuming the Tile loaded a graphic and/or its children)\n    this.viewFlagOverrides = this.loader.viewFlagOverrides;\n    this.yAxisUp = props.yAxisUp ? props.yAxisUp : false;\n    this.contentRange = props.contentRange;\n  }\n\n  public get rootTile(): Tile { return this._rootTile; }\n  public get clipVector(): ClipVector | undefined { return undefined !== this.clipVolume ? this.clipVolume.clipVector : undefined; }\n\n  public dispose() {\n    dispose(this._rootTile);\n    this.clipVolume = dispose(this.clipVolume);\n  }\n\n  public collectStatistics(stats: RenderMemory.Statistics): void {\n    this._rootTile.collectStatistics(stats);\n    if (undefined !== this.clipVolume)\n      this.clipVolume.collectStatistics(stats);\n  }\n\n  public get is2d(): boolean { return !this.is3d; }\n  public get range(): ElementAlignedBox3d { return this._rootTile !== undefined ? this._rootTile.range : new Range3d(); }\n\n  public selectTilesForScene(context: SceneContext): Tile[] { return this.selectTiles(this.createDrawArgs(context)); }\n  public selectTiles(args: Tile.DrawArgs): Tile[] {\n    const selected: Tile[] = [];\n    if (undefined !== this._rootTile)\n      this._rootTile.selectTiles(selected, args);\n\n    return this.loader.processSelectedTiles(selected, args);\n  }\n\n  public drawScene(context: SceneContext): void { this.draw(this.createDrawArgs(context)); }\n  public draw(args: Tile.DrawArgs): void {\n    const selectedTiles = this.selectTiles(args);\n    for (const selectedTile of selectedTiles)\n      selectedTile.drawGraphics(args);\n\n    args.drawGraphics();\n    args.context.viewport.numSelectedTiles += selectedTiles.length;\n  }\n\n  public createDrawArgs(context: SceneContext): Tile.DrawArgs {\n    const now = BeTimePoint.now();\n    const purgeOlderThan = now.minus(this.expirationTime);\n    return new Tile.DrawArgs(context, this.location.clone(), this, now, purgeOlderThan, this.clipVolume);\n  }\n\n  public debugForcedDepth?: number; // For debugging purposes - force selection of tiles of specified depth.\n  private static _scratchFrustum = new Frustum();\n  private static _scratchPoint4d = Point4d.createZero();\n  private extendRangeForTile(range: Range3d, tile: Tile, matrix: Matrix4d, treeTransform: Transform, frustumPlanes?: FrustumPlanes) {\n    const box = Frustum.fromRange(tile.range, TileTree._scratchFrustum);\n    box.transformBy(treeTransform, box);\n    if (frustumPlanes !== undefined && FrustumPlanes.Containment.Outside === frustumPlanes.computeFrustumContainment(box))\n      return;\n    if (tile.children === undefined) {\n      for (const boxPoint of box.points) {\n        matrix.multiplyPoint3d(boxPoint, 1, TileTree._scratchPoint4d);\n        if (TileTree._scratchPoint4d.w > .0001)\n          range.extendXYZW(TileTree._scratchPoint4d.x, TileTree._scratchPoint4d.y, TileTree._scratchPoint4d.z, TileTree._scratchPoint4d.w);\n      }\n    } else {\n      for (const child of tile.children)\n        this.extendRangeForTile(range, child, matrix, treeTransform, frustumPlanes);\n    }\n  }\n\n  /* extend range to include transformed range of this tile tree */\n  public accumlateTransformedRange(range: Range3d, matrix: Matrix4d, frustumPlanes?: FrustumPlanes) {\n    this.extendRangeForTile(range, this.rootTile, matrix, this.location, frustumPlanes);\n  }\n}\n\nconst defaultViewFlagOverrides = new ViewFlag.Overrides(ViewFlags.fromJSON({\n  renderMode: RenderMode.SmoothShade,\n  noCameraLights: true,\n  noSourceLights: true,\n  noSolarLight: true,\n}));\n\n/** Serves as a \"handler\" for a specific type of [[TileTree]]. Its primary responsibilities involve loading tile content.\n * @internal\n */\nexport abstract class TileLoader {\n  public abstract async getChildrenProps(parent: Tile): Promise<TileProps[]>;\n  public abstract async requestTileContent(tile: Tile): Promise<TileRequest.Response>;\n  public abstract get maxDepth(): number;\n  public abstract get priority(): Tile.LoadPriority;\n  protected get _batchType(): BatchType { return BatchType.Primary; }\n  protected get _loadEdges(): boolean { return true; }\n  public abstract tileRequiresLoading(params: Tile.Params): boolean;\n  /** Given two tiles of the same [[Tile.LoadPriority]], determine which should be prioritized.\n   * A negative value indicates lhs should load first, positive indicates rhs should load first, and zero indicates no distinction in priority.\n   */\n  public compareTilePriorities(lhs: Tile, rhs: Tile): number { return lhs.depth - rhs.depth; }\n  public get parentsAndChildrenExclusive(): boolean { return true; }\n\n  public processSelectedTiles(selected: Tile[], _args: Tile.DrawArgs): Tile[] { return selected; }\n\n  // NB: The isCanceled arg is chiefly for tests...in usual case it just returns false if the tile is no longer in 'loading' state.\n  public async loadTileContent(tile: Tile, data: TileRequest.ResponseData, isCanceled?: () => boolean): Promise<Tile.Content> {\n    assert(data instanceof Uint8Array);\n    const blob = data as Uint8Array;\n    const streamBuffer: TileIO.StreamBuffer = new TileIO.StreamBuffer(blob.buffer);\n    return this.loadTileContentFromStream(tile, streamBuffer, isCanceled);\n  }\n  public async loadTileContentFromStream(tile: Tile, streamBuffer: TileIO.StreamBuffer, isCanceled?: () => boolean): Promise<Tile.Content> {\n\n    const position = streamBuffer.curPos;\n    const format = streamBuffer.nextUint32;\n    streamBuffer.curPos = position;\n\n    if (undefined === isCanceled)\n      isCanceled = () => !tile.isLoading;\n\n    let reader: GltfTileIO.Reader | undefined;\n    switch (format) {\n      case TileIO.Format.Pnts:\n        return { graphic: PntsTileIO.readPointCloud(streamBuffer, tile.root.iModel, tile.root.modelId, tile.root.is3d, tile.range, IModelApp.renderSystem, tile.yAxisUp) };\n\n      case TileIO.Format.B3dm:\n        reader = B3dmTileIO.Reader.create(streamBuffer, tile.root.iModel, tile.root.modelId, tile.root.is3d, tile.range, IModelApp.renderSystem, tile.yAxisUp, tile.isLeaf, tile.transformToRoot, isCanceled);\n        break;\n      case TileIO.Format.IModel:\n        reader = IModelTileIO.Reader.create(streamBuffer, tile.root.iModel, tile.root.modelId, tile.root.is3d, IModelApp.renderSystem, this._batchType, this._loadEdges, isCanceled, tile.hasSizeMultiplier ? tile.sizeMultiplier : undefined);\n        break;\n      case TileIO.Format.I3dm:\n        reader = I3dmTileIO.Reader.create(streamBuffer, tile.root.iModel, tile.root.modelId, tile.root.is3d, tile.range, IModelApp.renderSystem, tile.yAxisUp, tile.isLeaf, isCanceled);\n        break;\n      case TileIO.Format.Cmpt:\n        const header = new CompositeTileIO.Header(streamBuffer);\n        if (!header.isValid) return {};\n        const branch = new GraphicBranch();\n        for (let i = 0; i < header.tileCount; i++) {\n          const tilePosition = streamBuffer.curPos;\n          streamBuffer.advance(8);    // Skip magic and version.\n          const tileBytes = streamBuffer.nextUint32;\n          streamBuffer.curPos = tilePosition;\n          const result = await this.loadTileContentFromStream(tile, streamBuffer, isCanceled);\n          if (result.graphic)\n            branch.add(result.graphic);\n          streamBuffer.curPos = tilePosition + tileBytes;\n        }\n        return { graphic: branch.isEmpty ? undefined : IModelApp.renderSystem.createBranch(branch, Transform.createIdentity()), isLeaf: tile.isLeaf, sizeMultiplier: tile.sizeMultiplier };\n\n      default:\n        assert(false, \"unknown tile format \" + format);\n        break;\n    }\n\n    let content: Tile.Content = {};\n    if (undefined !== reader) {\n      try {\n        content = await reader.read();\n      } catch (_err) {\n        // Failure to load should prevent us from trying to load children\n        content.isLeaf = true;\n      }\n    }\n\n    return content;\n  }\n\n  public get viewFlagOverrides(): ViewFlag.Overrides { return defaultViewFlagOverrides; }\n  public adjustContentIdSizeMultiplier(contentId: string, _sizeMultiplier: number): string { return contentId; }\n}\n\n/** A hierarchical level-of-detail tree of 3d [[Tile]]s to be rendered in a [[Viewport]].\n * @internal\n */\nexport namespace TileTree {\n  /**\n   * Parameters used to construct a TileTree\n   * @internal\n   */\n  export interface Params {\n    readonly id: string;\n    readonly rootTile: TileProps;\n    readonly iModel: IModelConnection;\n    readonly is3d: boolean;\n    readonly loader: TileLoader;\n    readonly location: Transform;\n    readonly modelId: Id64String;\n    readonly maxTilesToSkip?: number;\n    readonly yAxisUp?: boolean;\n    readonly isBackgroundMap?: boolean;\n    readonly clipVector?: ClipVector;\n    readonly contentRange?: ElementAlignedBox3d;\n  }\n\n  /** Create TileTree.Params from JSON and context.\n   * @internal\n   */\n  export function paramsFromJSON(props: TileTreeProps, iModel: IModelConnection, is3d: boolean, loader: TileLoader, modelId: Id64String): Params {\n    const contentRange = undefined !== props.contentRange ? Range3d.fromJSON<ElementAlignedBox3d>(props.contentRange) : undefined;\n    return {\n      id: props.id,\n      rootTile: props.rootTile,\n      iModel,\n      is3d,\n      loader,\n      location: Transform.fromJSON(props.location),\n      modelId,\n      maxTilesToSkip: props.maxTilesToSkip,\n      yAxisUp: props.yAxisUp,\n      isBackgroundMap: props.isBackgroundMap,\n      contentRange,\n    };\n  }\n\n  /** @internal */\n  export enum LoadStatus {\n    NotLoaded,\n    Loading,\n    Loaded,\n    NotFound,\n  }\n}\n\n/** @internal */\nexport class TileTreeState {\n  public tileTree?: TileTree;\n  public loadStatus: TileTree.LoadStatus = TileTree.LoadStatus.NotLoaded;\n  public edgesOmitted: boolean = false;\n  public classifierExpansion: number = 0;\n  public animationId?: Id64String;\n  public get iModel() { return this._iModel; }\n  public get modelId() { return this._modelId; }\n\n  constructor(private _iModel: IModelConnection, private _is3d: boolean, private _modelId: Id64String) { }\n  public setTileTree(props: TileTreeProps, loader: TileLoader) {\n    const tileTree = new TileTree(TileTree.paramsFromJSON(props, this._iModel, this._is3d, loader, this._modelId));\n    if (tileTree.rootTile.contentRange.isNull) {\n      // No elements within model's range - don't create a TileTree for this model.\n      assert(tileTree.rootTile.isLeaf);\n      this.loadStatus = TileTree.LoadStatus.NotFound;\n    } else {\n      this.tileTree = tileTree;\n      this.loadStatus = TileTree.LoadStatus.Loaded;\n    }\n\n  }\n  public clearTileTree() {\n    this.tileTree = dispose(this.tileTree);\n    this.loadStatus = TileTree.LoadStatus.NotLoaded;\n  }\n}\n\n/** @internal */\nexport function bisectRange3d(range: Range3d, takeUpper: boolean): void {\n  const diag = range.diagonal();\n  const pt = takeUpper ? range.high : range.low;\n  if (diag.x > diag.y && diag.x > diag.z)\n    pt.x = (range.low.x + range.high.x) / 2.0;\n  else if (diag.y > diag.z)\n    pt.y = (range.low.y + range.high.y) / 2.0;\n  else\n    pt.z = (range.low.z + range.high.z) / 2.0;\n}\n\n/** @internal */\nexport function bisectRange2d(range: Range3d, takeUpper: boolean): void {\n  const diag = range.diagonal();\n  const pt = takeUpper ? range.high : range.low;\n  if (diag.x > diag.y)\n    pt.x = (range.low.x + range.high.x) / 2.0;\n  else\n    pt.y = (range.low.y + range.high.y) / 2.0;\n}\n\n/**\n * Given a Tile, compute the ranges which would result from sub-dividing its range a la IModelTile.getChildrenProps().\n * This function exists strictly for debugging purposes.\n */\nfunction computeChildRanges(tile: Tile): Array<{ range: Range3d, isEmpty: boolean }> {\n  const emptyMask = tile.emptySubRangeMask;\n  const is2d = tile.root.is2d;\n  const bisectRange = is2d ? bisectRange2d : bisectRange3d;\n\n  const ranges: Array<{ range: Range3d, isEmpty: boolean }> = [];\n  for (let i = 0; i < 2; i++) {\n    for (let j = 0; j < 2; j++) {\n      for (let k = 0; k < (is2d ? 1 : 2); k++) {\n        const emptyBit = 1 << (i + j * 2 + k * 4);\n        const isEmpty = 0 !== (emptyMask & emptyBit);\n\n        const range = tile.range.clone();\n        bisectRange(range, 0 === i);\n        bisectRange(range, 0 === j);\n        if (!is2d)\n          bisectRange(range, 0 === k);\n\n        ranges.push({ range, isEmpty });\n      }\n    }\n  }\n\n  return ranges;\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tile */\n\nimport {\n  assert,\n  BentleyError,\n  ClientRequestContext,\n  compareNumbers,\n  IModelStatus,\n  JsonUtils,\n  SortedArray,\n} from \"@bentley/bentleyjs-core\";\nimport {\n  TileTreeProps, TileProps, Cartographic, ImageSource, ImageSourceFormat, RenderTexture, EcefLocation,\n  BackgroundMapType, BackgroundMapProps, GeoCoordStatus,\n} from \"@bentley/imodeljs-common\";\nimport { Range3dProps, Range3d, TransformProps, Transform, Point3d, Point2d, Range2d, Vector3d, Angle, Plane3dByOriginAndUnitNormal, XYAndZ, XYZProps } from \"@bentley/geometry-core\";\nimport { TileLoader, TileTree, Tile } from \"./TileTree\";\nimport { TileRequest } from \"./TileRequest\";\nimport { request, Response, RequestOptions } from \"@bentley/imodeljs-clients\";\nimport { imageElementFromImageSource } from \"../ImageUtil\";\nimport { IModelApp } from \"../IModelApp\";\nimport { RenderSystem } from \"../render/System\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { DecorateContext } from \"../ViewContext\";\nimport { ScreenViewport, Viewport } from \"../Viewport\";\nimport { MessageBoxType, MessageBoxIconType } from \"../NotificationManager\";\nimport { GeoConverter } from \"../GeoServices\";\nimport { TiledGraphicsProvider } from \"../TiledGraphicsProvider\";\n\n// this interface is implemented in two ways:\n// LinearTransformChildCreator is used when the range of the iModel is small, such as a building, when an approximation will work.\n// GeoTransformChildCreator is used when the range is larger, as in a map. Then you must calculate the iModel coordinates more precisely from the lat/longs of the tile corners.\ninterface ChildCreator {\n  getChildren(quadId: QuadId): Promise<WebMapTileProps[]>;\n  onTilesSelected(): void;\n}\n\n// this is the simple version that is appropriate when the iModel covers a small area.\nclass LinearTransformChildCreator implements ChildCreator {\n  public mercatorToDb: Transform;\n\n  constructor(_iModel: IModelConnection, groundBias: number) {\n    // calculate mercatorToDb.\n    const ecefLocation: EcefLocation = _iModel.ecefLocation!;\n    const dbToEcef = ecefLocation.getTransform();\n\n    const projectCenter = Point3d.create(_iModel.projectExtents.center.x, _iModel.projectExtents.center.y, groundBias);\n    const projectEast = Point3d.create(projectCenter.x + 1.0, projectCenter.y, groundBias);\n    const projectNorth = Point3d.create(projectCenter.x, projectCenter.y + 1.0, groundBias);\n\n    const mercatorOrigin = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectCenter));\n    const mercatorX = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectEast));\n    const mercatorY = this.ecefToPixelFraction(dbToEcef.multiplyPoint3d(projectNorth));\n\n    const deltaX = Vector3d.createStartEnd(mercatorOrigin, mercatorX);\n    const deltaY = Vector3d.createStartEnd(mercatorOrigin, mercatorY);\n\n    const dbToMercator = Transform.createOriginAndMatrixColumns(mercatorOrigin, deltaX, deltaY, Vector3d.create(0.0, 0.0, 1.0)).multiplyTransformTransform(Transform.createTranslationXYZ(-projectCenter.x, -projectCenter.y, -groundBias));\n    this.mercatorToDb = dbToMercator.inverse() as Transform;\n  }\n\n  // gets longitude in a number between 0 and 1, corresponding to the coordinate system of the tiles.\n  private longitudeToPixelFraction (longitude: number) {\n    return (longitude + Angle.piRadians) / Angle.pi2Radians;\n  }\n\n  // gets latitude in a number between 0 and 1, corresponding to the coordinate system of the tiles.\n  private latitudeToPixelFraction(latitude: number) {\n    const sinLatitude = Math.sin(latitude);\n    return (0.5 - Math.log((1.0 + sinLatitude) / (1.0 - sinLatitude)) / (4.0 * Angle.piRadians));   // https://msdn.microsoft.com/en-us/library/bb259689.aspx\n  }\n\n  // gets the longitude and latitude into a point with coordinates between 0 and 1\n  private ecefToPixelFraction(point: Point3d) {\n    const cartoGraphic = Cartographic.fromEcef(point)!;\n    return Point3d.create(this.longitudeToPixelFraction(cartoGraphic.longitude), this.latitudeToPixelFraction(cartoGraphic.latitude), 0.0);\n  }\n\n  // gets the corners of the tile in a number between 0 and 1.\n  private getTileCorners(level: number, column: number, row: number): Point3d[] {\n    const nTiles = (1 << level);\n    const scale = 1.0 / nTiles;\n\n    const corners: Point3d[] = [];             //    ----x----->\n    corners.push(Point3d.create(scale * column, scale * row, 0.0));   //  | [0]     [1]\n    corners.push(Point3d.create(scale * (column + 1), scale * row, 0.0));   //  y\n    corners.push(Point3d.create(scale * column, scale * (row + 1), 0.0));   //  | [2]     [3]\n    corners.push(Point3d.create(scale * (column + 1), scale * (row + 1), 0.0));   //  v\n    return corners;\n  }\n\n  // Note: although there are only nine unique points, we don't bother with the optimization used in the\n  // GeoTransformChildCreator because the calculation for each point is fast.\n  public async getChildren(quadId: QuadId): Promise<WebMapTileProps[]> {\n    const level = quadId.level + 1;\n    const column = quadId.column * 2;\n    const row = quadId.row * 2;\n\n    const tileProps: WebMapTileProps[] = [];\n    for (let i = 0; i < 2; i++) {\n      for (let j = 0; j < 2; j++) {\n        // get them as LatLong\n        const corners: Point3d[] = this.getTileCorners(level, column + i, row + j);\n\n        // use the linear transform to get them into iModel Coordinates.\n        this.mercatorToDb.multiplyPoint3dArrayInPlace(corners);\n\n        const childId: string = level + \"_\" + (column + i) + \"_\" + (row + j);\n        tileProps.push(new WebMapTileProps(childId, level, corners));\n      }\n    }\n    return Promise.resolve(tileProps);\n  }\n\n  public onTilesSelected() { }\n}\n\nfunction compareXYZ(lhs: XYAndZ, rhs: XYAndZ): number {\n  let cmp = compareNumbers(lhs.x, rhs.x);\n  if (0 === cmp) {\n    cmp = compareNumbers(lhs.y, rhs.y);\n    if (0 === cmp)\n      cmp = compareNumbers(lhs.z, rhs.z);\n  }\n\n  return cmp;\n}\n\n// this is the simple version that is appropriate when the iModel covers a small area.\nclass GeoTransformChildCreator implements ChildCreator {\n  // we are creating four children, so 16 corners, but only nine are unique:\n  //   0       1       2\n  //   +-------+-------+\n  //   |      4|       |\n  //  3+-------+-------+5\n  //   |       |       |\n  //   +-------+-------+\n  //   6       7       8\n  // (Also, we probably already have 0,2,6, and 8 in the cache.)\n  private static _cornerList: number[][][] = [[[0, 1, 3, 4], [3, 4, 6, 7]], [[1, 2, 4, 5], [4, 5, 7, 8]]];\n  private static _uniquePointPixels: number[][] = [[0, 0], [128, 0], [256, 0], [0, 128], [128, 128], [256, 128], [0, 256], [128, 256], [256, 256]];\n\n  private _converter: GeoConverter;\n  private _groundBias: number;\n  private _linearChildCreator: LinearTransformChildCreator;\n  // An array of points which need to be converted from geocoords to cartesian coords for loading of child tiles.\n  // This is initialized by the first call to getChildrenProps() requiring geopoint conversion during selectTiles(), and reset to undefined after selectTiles() completes.\n  private _request?: SortedArray<XYAndZ>;\n  // A deferred Promise dispatched once tile selection completes, resolving when all geocoord conversion is complete.\n  private _promise?: Promise<void>;\n\n  constructor(_iModel: IModelConnection, groundBias: number) {\n    this._converter = _iModel.geoServices.getConverter(\"WGS84\");\n    this._groundBias = groundBias;\n\n    // a geographic transform doesn't work well outside a reasonable range, so use the linearChildCreator for the large-range tiles.\n    this._linearChildCreator = new LinearTransformChildCreator(_iModel, groundBias);\n  }\n\n  public async getChildren(parentQuad: QuadId): Promise<WebMapTileProps[]> {\n    const parentLevel = parentQuad.level;\n    const parentColumn = parentQuad.column;\n    const parentRow = parentQuad.row;\n\n    // calculate the lat/long of the nine unique points:\n    if (parentLevel < 6)\n      return this._linearChildCreator.getChildren(parentQuad);\n\n    const requestProps = new Array<XYZProps>(9);\n\n    // we are passed the child level, and the top left corner column and row.\n    const mapSize = 256 << parentLevel;\n    const left = 256 * parentColumn;\n    const top = 256 * parentRow;\n    for (let iPoint = 0; iPoint < GeoTransformChildCreator._uniquePointPixels.length; ++iPoint) {\n      const x = ((left + GeoTransformChildCreator._uniquePointPixels[iPoint][0]) / mapSize) - .5;\n      const y = 0.5 - ((top + GeoTransformChildCreator._uniquePointPixels[iPoint][1]) / mapSize);\n      requestProps[iPoint] = [\n        360.0 * x,\n        90.0 - 360.0 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI,\n        this._groundBias,\n      ];\n    }\n\n    let cached = this._converter.getCachedIModelCoordinatesFromGeoCoordinates(requestProps);\n    if (undefined !== cached.missing) {\n      // Batch our missing points in with any others which may be needed during tile selection.\n      // This promise will request the points needed by all tiles simultaneously and resolve when they are all available in the cache.\n      await this.getPromise(cached.missing);\n\n      // The points we need should all now be available in the cache.\n      // ###TODO this is lazy - use the cached results from above; only query the converter for missing points\n      cached = this._converter.getCachedIModelCoordinatesFromGeoCoordinates(requestProps);\n      assert(undefined === cached.missing);\n    }\n\n    const iModelCoords = cached.result;\n\n    // get the tileProps now that we have their geoCoords.\n    const tileProps: WebMapTileProps[] = [];\n    const level = parentLevel + 1;\n    const column = parentColumn * 2;\n    const row = parentRow * 2;\n    for (let iCol = 0; iCol < 2; ++iCol) {\n      for (let iRow = 0; iRow < 2; ++iRow) {\n        const corners: Point3d[] = new Array<Point3d>(4);\n        for (let iPoint = 0; iPoint < 4; ++iPoint) {\n          const pointNum = GeoTransformChildCreator._cornerList[iCol][iRow][iPoint];\n          const iModelCoord = iModelCoords[pointNum]!;\n          assert(undefined !== iModelCoord);\n          corners[iPoint] = Point3d.fromJSON(iModelCoord.p);\n        }\n\n        const childId: string = level + \"_\" + (column + iCol) + \"_\" + (row + iRow);\n        tileProps.push(new WebMapTileProps(childId, level, corners));\n      }\n    }\n\n    return tileProps;\n  }\n\n  private async getPromise(geoPoints: XYZProps[]): Promise<void> {\n    if (undefined === this._promise) {\n      assert(undefined === this._request);\n      const req = new SortedArray<XYAndZ>(compareXYZ);\n      this._request = req;\n      this._promise = Promise.resolve().then(async () => {\n        // NB: At this point this._request and this._promise are undefined, or possibly pointing to different objects.\n        await this._converter.getIModelCoordinatesFromGeoCoordinates(req.extractArray());\n      });\n    }\n\n    assert(undefined !== this._request);\n    for (const point of geoPoints)\n      this._request!.insert(Point3d.fromJSON(point));\n\n    return this._promise;\n  }\n\n  public onTilesSelected(): void {\n    if (undefined === this._promise)\n      return;\n\n    assert(undefined !== this._request);\n    this._promise = undefined;\n    this._request = undefined;\n  }\n}\n\nclass QuadId {\n  public level: number;\n  public column: number;\n  public row: number;\n  public get isValid() { return this.level >= 0; }\n\n  public constructor(stringId: string) {\n    const idParts = stringId.split(\"_\");\n    if (3 !== idParts.length) {\n      assert(false, \"Invalid quadtree ID\");\n      this.level = this.row = this.column = -1;\n      return;\n    }\n\n    this.level = parseInt(idParts[0], 10);\n    this.column = parseInt(idParts[1], 10);\n    this.row = parseInt(idParts[2], 10);\n  }\n\n  // get the lat long for pixels within this quadId.\n  private pixelXYToLatLong(pixelX: number, pixelY: number): Point2d {\n    const mapSize = 256 << this.level;\n    const left = 256 * this.column;\n    const top = 256 * this.row;\n    const x = ((left + pixelX) / mapSize) - .5;\n    const y = 0.5 - ((top + pixelY) / mapSize);\n    const outPoint: Point2d = new Point2d(360.0 * x, 90.0 - 360.0 * Math.atan(Math.exp(-y * 2 * Math.PI)) / Math.PI);\n    return outPoint;\n  }\n\n  // Not used in display - used only to tell whether this tile overlaps the range provided by a tile provider for attribution.\n  public getLatLongRange(): Range2d {\n    const lowerLeft = this.pixelXYToLatLong(0, 256);\n    const upperRight = this.pixelXYToLatLong(256, 0);\n    const range: Range2d = new Range2d();\n    range.low = lowerLeft;\n    range.high = upperRight;\n    return range;\n  }\n}\n\nclass WebMapTileTreeProps implements TileTreeProps {\n  /** The unique identifier of this TileTree within the iModel */\n  public id: string = \"\";\n  /** Metadata describing the tree's root Tile. */\n  public rootTile: TileProps;\n  /** Transform tile coordinates to iModel world coordinates. */\n  public location: TransformProps;\n  public yAxisUp = true;\n  public isBackgroundMap = true;\n  public maxTilesToSkip = 4;\n  public constructor(groundBias: number) {\n    const corners: Point3d[] = [];\n    corners[0] = new Point3d(-10000000, -10000000, groundBias);\n    corners[1] = new Point3d(-10000000, 10000000, groundBias);\n    corners[2] = new Point3d(10000000, -10000000, groundBias);\n    corners[3] = new Point3d(10000000, 10000000, groundBias);\n\n    this.rootTile = new WebMapTileProps(\"0_0_0\", 0, corners);\n    this.location = Transform.createIdentity();\n  }\n}\n\nclass WebMapTileProps implements TileProps {\n  public readonly contentId: string;\n  public readonly range: Range3dProps;\n  public readonly contentRange?: Range3dProps;  // not used for WebMap tiles.\n  public readonly maximumSize: number;\n  public readonly sizeMultiplier: number = 1.0;\n  public readonly isLeaf: boolean = false;\n  public readonly corners: Point3d[];\n\n  constructor(thisId: string, level: number, corners: Point3d[]) {\n    this.corners = corners;\n    this.range = Range3d.createArray(corners);\n    this.contentId = thisId;\n    this.maximumSize = (0 === level) ? 0.0 : 256;\n  }\n}\n\nclass WebMapTileLoader extends TileLoader {\n  private _providerInitializing?: Promise<void>;\n  private _providerInitialized: boolean = false;\n  private _childTileCreator: ChildCreator;\n\n  constructor(private _imageryProvider: ImageryProvider, private _iModel: IModelConnection, groundBias: number, gcsConverterAvailable: boolean) {\n    super();\n    const useLinearTransform: boolean = !gcsConverterAvailable || WebMapTileLoader.selectLinearChildCreator(_iModel);\n    if (useLinearTransform) {\n      this._childTileCreator = new LinearTransformChildCreator(_iModel, groundBias);\n    } else {\n      this._childTileCreator = new GeoTransformChildCreator(_iModel, groundBias);\n    }\n  }\n\n  private static selectLinearChildCreator(_iModel: IModelConnection) {\n    const linearRangeSquared: number = _iModel.projectExtents.diagonal().magnitudeSquared();\n    return linearRangeSquared < 1000.0 * 1000.00;  // if the range is greater than a kilometer, use the more exact but slower GCS method of generating the WebMap tile corners.\n  }\n\n  public tileRequiresLoading(params: Tile.Params): boolean {\n    return 0.0 !== params.maximumSize;\n  }\n\n  public async getChildrenProps(parent: Tile): Promise<TileProps[]> {\n    const quadId = new QuadId(parent.contentId);\n    return this._childTileCreator.getChildren(quadId);\n  }\n\n  public async requestTileContent(tile: Tile): Promise<TileRequest.Response> {\n    if (!this._providerInitialized) {\n      if (undefined === this._providerInitializing)\n        this._providerInitializing = this._imageryProvider.initialize();\n\n      await this._providerInitializing;\n      this._providerInitialized = true;\n      this._providerInitializing = undefined;\n    }\n\n    const quadId = new QuadId(tile.contentId);\n    return this._imageryProvider.loadTile(quadId.row, quadId.column, quadId.level);\n  }\n\n  public async loadTileContent(tile: Tile, data: TileRequest.ResponseData, isCanceled?: () => boolean): Promise<Tile.Content> {\n    if (undefined === isCanceled)\n      isCanceled = () => !tile.isLoading;\n\n    assert(data instanceof ImageSource);\n    const content: Tile.Content = {};\n    const system = IModelApp.renderSystem;\n    const texture = await this.loadTextureImage(data as ImageSource, this._iModel, system, isCanceled);\n    if (undefined !== texture) {\n      // we put the corners property on WebMapTiles\n      const corners = (tile as any).corners;\n      content.graphic = system.createTile(texture, corners);\n    }\n\n    return content;\n  }\n\n  private async loadTextureImage(imageSource: ImageSource, iModel: IModelConnection, system: RenderSystem, isCanceled: () => boolean): Promise<RenderTexture | undefined> {\n    try {\n      const textureParams = new RenderTexture.Params(undefined, RenderTexture.Type.TileSection);\n      return imageElementFromImageSource(imageSource)\n        .then((image) => isCanceled() ? undefined : system.createTextureFromImage(image, ImageSourceFormat.Png === imageSource.format, iModel, textureParams))\n        .catch((_) => undefined);\n    } catch (e) {\n      return undefined;\n    }\n  }\n\n  public get maxDepth(): number { return this._providerInitialized ? this._imageryProvider.maximumZoomLevel : 32; }\n  public get parentsAndChildrenExclusive(): boolean { return false; }\n  public get priority(): Tile.LoadPriority { return Tile.LoadPriority.Background; }\n  public processSelectedTiles(selected: Tile[], _args: Tile.DrawArgs): Tile[] {\n    // Dispatch any requests for child tiles props (geo-coordination)\n    this._childTileCreator.onTilesSelected();\n\n    // Ensure lo-res tiles drawn before (therefore behind) hi-res tiles.\n    // NB: Array.sort() sorts in-place and returns the input array - we're not making a copy.\n    return selected.sort((lhs, rhs) => lhs.depth - rhs.depth);\n  }\n  public compareTilePriorities(lhs: Tile, rhs: Tile): number {\n    // The default implementation prioritizes lower-resolution tiles. For maps, we want tiles closest to the camera to load first.\n    // When the camera is ON, those will be the higher-resolution tiles - so invert the default behavior.\n    // ###TODO: Compute actual distance from camera when camera is OFF.\n    // NB: We never load higher-res children until the first displayable lowest-res tile is available - so we always have *something* to draw while awaiting hi-res tiles.\n    return rhs.depth - lhs.depth;\n  }\n}\n\n/** @internal */\n// Represents the service that is providing map tiles for Web Mercator models (background maps).\nexport abstract class ImageryProvider {\n  public mapType: BackgroundMapType;\n  protected _requestContext = new ClientRequestContext(\"\");\n\n  constructor(mapType: BackgroundMapType) {\n    this.mapType = mapType;\n  }\n\n  public abstract get tileWidth(): number;\n  public abstract get tileHeight(): number;\n  public abstract get minimumZoomLevel(): number;\n  public abstract get maximumZoomLevel(): number;\n  public abstract constructUrl(row: number, column: number, zoomLevel: number): string;\n  public abstract getCopyrightMessage(tileProvider: BaseTiledMapProvider, viewport: ScreenViewport): HTMLElement | undefined;\n  public abstract getCopyrightImage(tileProvider: BaseTiledMapProvider): HTMLImageElement | undefined;\n\n  // initialize the subclass of ImageryProvider\n  public abstract async initialize(): Promise<void>;\n\n  // returns true if the tile data matches the tile data of a \"missing tile\". See BingImageryProvider.initialize.\n  public matchesMissingTile(_tileData: Uint8Array): boolean {\n    return false;\n  }\n\n  // returns a Uint8Array with the contents of the tile.\n  public async loadTile(row: number, column: number, zoomLevel: number): Promise<ImageSource | undefined> {\n    let tileUrl: string = this.constructUrl(row, column, zoomLevel);\n\n    if (!tileUrl.includes(\"https\"))\n      tileUrl = tileUrl.replace(\"http\", \"https\");\n\n    const tileRequestOptions: RequestOptions = { method: \"GET\", responseType: \"arraybuffer\" };\n    try {\n      const tileResponse: Response = await request(this._requestContext, tileUrl, tileRequestOptions);\n      const byteArray: Uint8Array = new Uint8Array(tileResponse.body);\n      if (!byteArray || (byteArray.length === 0))\n        return undefined;\n      if (this.matchesMissingTile(byteArray))\n        return undefined;\n      let imageFormat: ImageSourceFormat;\n      switch (tileResponse.header[\"content-type\"]) {\n        case \"image/jpeg\":\n          imageFormat = ImageSourceFormat.Jpeg;\n          break;\n        case \"image/png\":\n          imageFormat = ImageSourceFormat.Png;\n          break;\n        default:\n          assert(false, \"Unknown image type\");\n          return undefined;\n      }\n\n      return new ImageSource(byteArray, imageFormat);\n    } catch (error) {\n      return undefined;\n    }\n  }\n}\n\n/** @internal */\n// this class provides a method for converting the tile row, column, and zoom level to the EPSG3857 cartesian coordinates that some\n// tile servers require. The getEPSG3857Extent method is usually used in the constructUrl method.\nexport abstract class ImageryProviderEPSG3857 extends ImageryProvider {\n\n  // calculates the projected x cartesian coordinate in EPSG:3857from the longitude in EPSG:4326 (WGS84)\n  public getEPSG3857X(longitude: number): number {\n    return longitude * 20037508.34 / 180.0;\n  }\n\n  // calculates the projected y cartesian coordinate in EPSG:3857from the latitude in EPSG:4326 (WGS84)\n  public getEPSG3857Y(latitude: number): number {\n    const y = Math.log(Math.tan((90.0 + latitude) * Math.PI / 360.0)) / (Math.PI / 180.0);\n    return y * 20037508.34 / 180.0;\n  }\n\n  // Map tile providers like Bing and Mapbox allow the URL to be constructed directory from the zoomlevel and tile coordinates.\n  // However, WMS-based servers take a bounding box instead. This method can help get that bounding box from a tile.\n  public getEPSG3857Extent(row: number, column: number, zoomLevel: number): { left: number, right: number, top: number, bottom: number } {\n    const mapSize = 256 << zoomLevel;\n    const leftGrid = 256 * column;\n    const topGrid = 256 * row;\n\n    const longitudeLeft = 360 * ((leftGrid / mapSize) - 0.5);\n    const y0 = 0.5 - ((topGrid + 256) / mapSize);\n    const latitudeBottom = 90.0 - 360.0 * Math.atan(Math.exp(-y0 * 2 * Math.PI)) / Math.PI;\n\n    const longitudeRight = 360 * (((leftGrid + 256) / mapSize) - 0.5);\n    const y1 = 0.5 - (topGrid / mapSize);\n    const latitudeTop = 90.0 - 360.0 * Math.atan(Math.exp(-y1 * 2 * Math.PI)) / Math.PI;\n\n    const left = this.getEPSG3857X(longitudeLeft);\n    const right = this.getEPSG3857X(longitudeRight);\n    const bottom = this.getEPSG3857Y(latitudeBottom);\n    const top = this.getEPSG3857Y(latitudeTop);\n\n    return { left, right, bottom, top };\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Classes for the Bing Imagery Provider\n// ------------------------------------------------------------------------------\n\n// Represents one range of geography and tile zoom levels for a bing data provider\nclass Coverage {\n  constructor(private _lowerLeftLongitude: number,\n    private _lowerLeftLatitude: number,\n    private _upperRightLongitude: number,\n    private _upperRightLatitude: number,\n    private _minimumZoomLevel: number,\n    private _maximumZoomLevel: number) { }\n\n  public overlaps(quadId: QuadId): boolean {\n    const range: Range2d = quadId.getLatLongRange();\n    if (quadId.level < this._minimumZoomLevel)\n      return false;\n    if (quadId.level > this._maximumZoomLevel)\n      return false;\n    if (range.low.x > this._upperRightLongitude)\n      return false;\n    if (range.low.y > this._upperRightLatitude)\n      return false;\n    if (range.high.x < this._lowerLeftLongitude)\n      return false;\n    if (range.high.y < this._lowerLeftLatitude)\n      return false;\n\n    return true;\n  }\n}\n\n// Represents the copyright message and an array of coverage data for one of bing's data providers (HERE for example).\nclass BingAttribution {\n  constructor(public copyrightMessage: string, private _coverages: Coverage[]) { }\n\n  public matchesTile(tile: Tile): boolean {\n    const quadId = new QuadId(tile.contentId);\n    for (const coverage of this._coverages) {\n      if (coverage.overlaps(quadId))\n        return true;\n    }\n    return false;\n  }\n}\n\n// Our ImageryProvider for Bing Maps.\nclass BingImageryProvider extends ImageryProvider {\n  private _urlTemplate?: string;\n  private _urlSubdomains?: string[];\n  private _logoUrl?: string;\n  private _zoomMin: number;\n  private _zoomMax: number;\n  private _tileHeight: number;\n  private _tileWidth: number;\n  private _attributions?: BingAttribution[]; // array of Bing's data providers.\n  private _missingTileData?: Uint8Array;\n  private _logoImage?: HTMLImageElement;\n\n  constructor(mapType: BackgroundMapType) {\n    super(mapType);\n    this._zoomMin = this._zoomMax = 0;\n    this._tileHeight = this._tileWidth = 0;\n  }\n\n  public get tileWidth(): number { return this._tileWidth; }\n  public get tileHeight(): number { return this._tileHeight; }\n  public get minimumZoomLevel(): number { return this._zoomMin; }\n  public get maximumZoomLevel(): number { return this._zoomMax; }\n\n  private tileXYToQuadKey(tileX: number, tileY: number, zoomLevel: number) {\n    // from C# example in bing documentation https://msdn.microsoft.com/en-us/library/bb259689.aspx\n    let quadKey: string = \"\";\n\n    // Root tile is not displayable. Returns 0 for _GetMaximumSize(). Should not end up here.\n    assert(0 !== zoomLevel);\n\n    for (let i: number = zoomLevel; i > 0; i--) {\n      let digit: number = 0x30; // '0'\n      const mask: number = 1 << (i - 1);\n      if ((tileX & mask) !== 0) {\n        digit++;\n      }\n      if ((tileY & mask) !== 0) {\n        digit++;\n        digit++;\n      }\n      quadKey = quadKey.concat(String.fromCharCode(digit));\n    }\n    return quadKey;\n  }\n\n  // construct the Url from the desired Tile\n  public constructUrl(row: number, column: number, zoomLevel: number): string {\n    // From the tile, get a \"quadKey\" the Microsoft way.\n    const quadKey: string = this.tileXYToQuadKey(column, row, zoomLevel);\n    const subdomain: string = this._urlSubdomains![(row + column) % this._urlSubdomains!.length];\n\n    // from the template url, construct the tile url.\n    let url: string = this._urlTemplate!.replace(\"{subdomain}\", subdomain);\n    url = url.replace(\"{quadkey}\", quadKey);\n\n    return url;\n  }\n\n  // gets the attributions that match the tile set.\n  private getMatchingAttributions(tiles: Tile[]): BingAttribution[] {\n    const matchingAttributions: BingAttribution[] = new Array<BingAttribution>();\n    if (!this._attributions)\n      return matchingAttributions;\n\n    const unmatchedSet: BingAttribution[] = this._attributions.slice();\n    for (const tile of tiles) {\n      // compare to the set of Bing attributions that we have not yet matched.\n      for (let iAttr = 0; iAttr < unmatchedSet.length; iAttr++) {\n        const attribution = unmatchedSet[iAttr];\n        if (attribution && attribution.matchesTile(tile)) {\n          matchingAttributions.push(attribution);\n          delete unmatchedSet[iAttr];\n        }\n      }\n    }\n    return matchingAttributions;\n  }\n\n  private showAttributions(tileProvider: BaseTiledMapProvider, viewport: ScreenViewport) {\n    // our \"this\" is the BingImageryProvider for which we want to show the data provider attribution.\n    // We need to get the tiles that are used in the view.\n    const tiles: Tile[] = tileProvider.getTilesForView(viewport);\n    const matchingAttributions: BingAttribution[] = this.getMatchingAttributions(tiles);\n    let dataString: string = IModelApp.i18n.translate(\"iModelJs:BackgroundMap.BingDataAttribution\");\n    for (const match of matchingAttributions) {\n      dataString = dataString.concat(\"<li>\", match.copyrightMessage, \"</li>\");\n    }\n    IModelApp.notifications.openMessageBox(MessageBoxType.LargeOk, dataString, MessageBoxIconType.Information); // tslint:disable-line:no-floating-promises\n  }\n\n  public getCopyrightImage(_tileProvider: BaseTiledMapProvider): HTMLImageElement | undefined { return this._logoImage; }\n\n  public getCopyrightMessage(tileProvider: BaseTiledMapProvider, viewport: ScreenViewport): HTMLElement | undefined {\n    const copyrightElement: HTMLSpanElement = document.createElement(\"span\");\n    copyrightElement.className = \"bgmap-copyright\";\n    copyrightElement.onclick = this.showAttributions.bind(this, tileProvider, viewport);\n    copyrightElement.innerText = IModelApp.i18n.translate(\"iModelJs:BackgroundMap.BingDataClickTarget\");\n    copyrightElement.style.textDecoration = \"underline\";\n    copyrightElement.style.cursor = \"pointer\";\n    return copyrightElement;\n  }\n\n  public matchesMissingTile(tileData: Uint8Array): boolean {\n    if (!this._missingTileData)\n      return false;\n    if (tileData.length !== this._missingTileData.length)\n      return false;\n    for (let i: number = 0; i < tileData.length; i += 10) {\n      if (this._missingTileData[i] !== tileData[i]) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  // initializes the BingImageryProvider by reading the templateUrl, logo image, and attribution list.\n  public async initialize(): Promise<void> {\n    // get the template url\n    // NEEDSWORK - should get bing key from server.\n    const bingKey = \"AtaeI3QDNG7Bpv1L53cSfDBgBKXIgLq3q-xmn_Y2UyzvF-68rdVxwAuje49syGZt\";\n\n    let imagerySet = \"Road\";\n    if (BackgroundMapType.Aerial === this.mapType)\n      imagerySet = \"Aerial\";\n    else if (BackgroundMapType.Hybrid === this.mapType)\n      imagerySet = \"AerialWithLabels\";\n\n    let bingRequestUrl: string = \"https://dev.virtualearth.net/REST/v1/Imagery/Metadata/{imagerySet}?o=json&incl=ImageryProviders&key={bingKey}\";\n    bingRequestUrl = bingRequestUrl.replace(\"{imagerySet}\", imagerySet);\n    bingRequestUrl = bingRequestUrl.replace(\"{bingKey}\", bingKey);\n    const requestOptions: RequestOptions = {\n      method: \"GET\",\n    };\n    try {\n      const response: Response = await request(this._requestContext, bingRequestUrl, requestOptions);\n      const bingResponseProps: any = response.body;\n      this._logoUrl = bingResponseProps.brandLogoUri;\n\n      const thisResourceSetProps = bingResponseProps.resourceSets[0];\n      const thisResourceProps = thisResourceSetProps.resources[0];\n      this._zoomMin = thisResourceProps.zoomMin;\n      this._zoomMax = thisResourceProps.zoomMax;\n      this._tileHeight = thisResourceProps.imageHeight;\n      this._tileWidth = thisResourceProps.imageWidth;\n      this._urlTemplate = thisResourceProps.imageUrl.replace(\"{culture}\", \"en-US\"); // NEEDSWORK - get locale from somewhere.\n      this._urlSubdomains = thisResourceProps.imageUrlSubdomains;\n      // read the list of Bing's data suppliers and the range of data they provide. Used in calculation of copyright message.\n      this.readAttributions(thisResourceProps.imageryProviders);\n\n      // read the Bing logo data, used in getCopyrightImage\n      if (undefined !== this._logoUrl && 0 < this._logoUrl.length) {\n        this._logoImage = new Image();\n        if (!this._logoUrl.includes(\"https\"))\n          this._logoUrl = this._logoUrl.replace(\"http\", \"https\");\n        this._logoImage.src = this._logoUrl;\n      }\n\n      // Bing sometimes provides tiles that have nothing but a stupid camera icon in the middle of them when you ask\n      // for tiles at zoom levels where they don't have data. Their application stops you from zooming in when that's the\n      // case, but we can't stop - the user might want to look at design data a closer zoom. So we intentionally load such\n      // a tile, and then compare other tiles to it, rejecting them if they match.\n      this.loadTile(0, 0, this._zoomMax - 1).then((tileData: ImageSource | undefined) => { // tslint:disable-line:no-floating-promises\n        if (tileData !== undefined) this._missingTileData = tileData.data as Uint8Array;\n      });\n    } catch (error) {\n      throw new BentleyError(IModelStatus.BadModel, \"Error in Bing Server communications\");\n    }\n  }\n\n  // reads the list of Bing data providers and the map range for which they each provide data.\n  private readAttributions(attributionProps: any) {\n    for (const thisAttributionProps of attributionProps) {\n      const copyrightMessage: string = thisAttributionProps.attribution;\n      const coverages: Coverage[] = new Array<Coverage>();\n      for (const thisCoverageProps of thisAttributionProps.coverageAreas) {\n        const thisCoverage = new Coverage(thisCoverageProps.bbox[0], thisCoverageProps.bbox[1], thisCoverageProps.bbox[2], thisCoverageProps.bbox[3],\n          thisCoverageProps.zoomMin, thisCoverageProps.zoomMax);\n        coverages.push(thisCoverage);\n      }\n      const thisAttribution: BingAttribution = new BingAttribution(copyrightMessage, coverages);\n      if (!this._attributions)\n        this._attributions = new Array<BingAttribution>();\n      this._attributions.push(thisAttribution);\n    }\n  }\n}\n\n// ------------------------------------------------------------------------------\n// Classes for the Mapbox Imagery Provider\n// ------------------------------------------------------------------------------\nclass MapBoxImageryProvider extends ImageryProvider {\n  private _zoomMin: number;\n  private _zoomMax: number;\n  private _baseUrl: string;\n\n  constructor(mapType: BackgroundMapType) {\n    super(mapType);\n    this._zoomMin = 1; this._zoomMax = 20;\n    switch (mapType) {\n      case BackgroundMapType.Street:\n        this._baseUrl = \"https://api.mapbox.com/v4/mapbox.streets/\";\n        break;\n\n      case BackgroundMapType.Aerial:\n        this._baseUrl = \"https://api.mapbox.com/v4/mapbox.satellite/\";\n        break;\n\n      case BackgroundMapType.Hybrid:\n        this._baseUrl = \"https://api.mapbox.com/v4/mapbox.streets-satellite/\";\n        break;\n\n      default:\n        this._baseUrl = \"\";\n        assert(false);\n    }\n  }\n\n  public get tileWidth(): number { return 256; }\n  public get tileHeight(): number { return 256; }\n  public get minimumZoomLevel(): number { return this._zoomMin; }\n  public get maximumZoomLevel(): number { return this._zoomMax; }\n\n  // construct the Url from the desired Tile\n  public constructUrl(row: number, column: number, zoomLevel: number): string {\n\n    // from the template url, construct the tile url.\n    let url: string = this._baseUrl.concat(zoomLevel.toString());\n    url = url.concat(\"/\").concat(column.toString()).concat(\"/\").concat(row.toString());\n    url = url.concat(\".jpg80?access_token=pk%2EeyJ1IjoibWFwYm94YmVudGxleSIsImEiOiJjaWZvN2xpcW00ZWN2czZrcXdreGg2eTJ0In0%2Ef7c9GAxz6j10kZvL%5F2DBHg\");\n\n    return url;\n  }\n\n  public getCopyrightImage(_tileProvider: BaseTiledMapProvider): HTMLImageElement | undefined { return undefined; }\n\n  public getCopyrightMessage(_tileProvider: BackgroundMapProvider, _viewport: ScreenViewport): HTMLElement | undefined {\n    const copyrightElement: HTMLSpanElement = document.createElement(\"span\");\n    copyrightElement.innerText = IModelApp.i18n.translate(\"IModelJs:BackgroundMap.MapBoxCopyright\");\n    copyrightElement.className = \"bgmap-copyright\";\n    return copyrightElement;\n  }\n\n  // no initialization needed for MapBoxImageryProvider.\n  public async initialize(): Promise<void> { }\n}\n\nconst enum GcsConverterStatus { Uninitialized, Pending, NotAvailable, Available }\n\n/** Methods and properties common to both BackgroundMapProviders and OverlayMapProviders\n * @internal\n */\nexport class BaseTiledMapProvider {\n  protected _iModel: IModelConnection;\n  protected _tileTree?: TileTree;\n  protected _imageryProvider?: ImageryProvider;\n  protected _groundBias: number;\n  private _loadStatus: TileTree.LoadStatus = TileTree.LoadStatus.NotLoaded;\n  private _gcsConverterStatus: GcsConverterStatus = GcsConverterStatus.Uninitialized;\n\n  constructor(iModel: IModelConnection, groundBias: number) {\n    this._groundBias = groundBias;\n    this._iModel = iModel;\n  }\n\n  public setTileTree(props: TileTreeProps, loader: TileLoader) {\n    this._tileTree = new TileTree(TileTree.paramsFromJSON(props, this._iModel, true, loader, \"\"));\n    this._loadStatus = TileTree.LoadStatus.Loaded;\n  }\n\n  public getPlane(): Plane3dByOriginAndUnitNormal {\n    return Plane3dByOriginAndUnitNormal.createXYPlane(new Point3d(0.0, 0.0, this._groundBias));  // TBD.... use this.groundBias when clone problem is sorted for Point3d\n  }\n\n  public getTilesForView(viewport: ScreenViewport): Tile[] {\n    let displayTiles: Tile[] = [];\n    if (this._tileTree) {\n      const sceneContext = viewport.createSceneContext();\n      sceneContext.extendedFrustumPlane = this.getPlane();\n      displayTiles = this._tileTree.selectTilesForScene(sceneContext);\n    }\n    return displayTiles;\n  }\n\n  private testGcsConverter() {\n    this._gcsConverterStatus = GcsConverterStatus.Pending;\n    const converter = this._iModel.geoServices.getConverter(\"WGS84\");\n    const requestProps = new Array<XYZProps>(1);\n    requestProps[0] = { x: 0, y: 0, z: 0 };\n    converter.getIModelCoordinatesFromGeoCoordinates(requestProps).then((responseProps) => {\n      this._gcsConverterStatus = (responseProps.iModelCoords.length !== 1 || responseProps.iModelCoords[0].s === GeoCoordStatus.NoGCSDefined) ? GcsConverterStatus.NotAvailable : GcsConverterStatus.Available;\n      IModelApp.viewManager.onNewTilesReady();\n    }).catch((_) => {\n      this._gcsConverterStatus = GcsConverterStatus.NotAvailable;\n      IModelApp.viewManager.onNewTilesReady();\n    });\n  }\n\n  protected loadTileTree(): TileTree.LoadStatus {\n    if (TileTree.LoadStatus.NotLoaded !== this._loadStatus)\n      return this._loadStatus;\n\n    if (this._iModel.ecefLocation === undefined) {\n      return this._loadStatus;\n    }\n    if (GcsConverterStatus.Uninitialized === this._gcsConverterStatus)\n      this.testGcsConverter();\n\n    if (GcsConverterStatus.Pending === this._gcsConverterStatus)\n      return this._loadStatus;\n\n    const loader = new WebMapTileLoader(this._imageryProvider!, this._iModel, this._groundBias, this._gcsConverterStatus === GcsConverterStatus.Available);\n    const tileTreeProps = new WebMapTileTreeProps(this._groundBias);\n    this.setTileTree(tileTreeProps, loader);\n    return this._loadStatus;\n  }\n\n  public decorate(context: DecorateContext) {\n    if (!this._imageryProvider)\n      return;\n\n    const copyrightImage = this._imageryProvider.getCopyrightImage(this);\n    if (copyrightImage && 0 !== copyrightImage.naturalWidth && 0 !== copyrightImage.naturalHeight) {\n      const position = new Point2d(0, (context.viewport.viewRect.height - copyrightImage.height));\n      const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n        ctx.drawImage(copyrightImage, 0, 0, copyrightImage.width, copyrightImage.height);\n      };\n      context.addCanvasDecoration({ position, drawDecoration });\n    }\n\n    const copyrightMessage = this._imageryProvider.getCopyrightMessage(this, context.screenViewport);\n    if (copyrightMessage) {\n      const decorationDiv = context.decorationDiv;\n      decorationDiv.appendChild(copyrightMessage);\n      const boundingRect = copyrightMessage.getBoundingClientRect();\n      const style = copyrightMessage.style;\n      style.display = \"block\";\n      style.position = \"absolute\";\n      style.left = (decorationDiv.clientWidth - (boundingRect.width + 15)) + \"px\";\n      style.top = (decorationDiv.clientHeight - (boundingRect.height + 5)) + \"px\";\n      style.color = \"silver\";\n      style.backgroundColor = \"transparent\";\n      style.pointerEvents = \"initial\";\n    }\n  }\n}\n\n/** This class is the specialization of BasedTiledMapProvider used for Background Maps. In that case, the ImageryProvider is constructed\n * internally using the BackgroundMapProps persisted to the iModel.\n * @internal\n */\nexport class BackgroundMapProvider extends BaseTiledMapProvider implements TiledGraphicsProvider.Provider {\n  public providerName: string;\n  public mapType: BackgroundMapType;\n\n  // constructs the BackgroundMapProvider from the props persisted in the iModel.\n  public constructor(json: BackgroundMapProps, iModel: IModelConnection) {\n    super(iModel, JsonUtils.asDouble(json.groundBias, 0.0));\n    this.providerName = JsonUtils.asString(json.providerName, \"BingProvider\");\n    this.mapType = json.providerData ? JsonUtils.asInt(json.providerData.mapType, BackgroundMapType.Hybrid) : BackgroundMapType.Hybrid;\n\n    // JSON may specify MapType.None (0) which is not defined in enum and is not meaningful.\n    // (May also specify any other arbitrary meaningless integer value).\n    // If so, use default\n    switch (this.mapType) {\n      case BackgroundMapType.Street:\n      case BackgroundMapType.Aerial:\n      case BackgroundMapType.Hybrid:\n        break;\n      default:\n        this.mapType = BackgroundMapType.Hybrid;\n        break;\n    }\n\n    // get the map provider.\n    if (\"BingProvider\" === this.providerName) {\n      this._imageryProvider = new BingImageryProvider(this.mapType);\n    } else if (\"MapBoxProvider\" === this.providerName) {\n      this._imageryProvider = new MapBoxImageryProvider(this.mapType);\n    }\n    if (this._imageryProvider === undefined)\n      throw new BentleyError(IModelStatus.BadModel, \"WebMap provider invalid\");\n  }\n\n  public getTileTree(viewport: Viewport): TiledGraphicsProvider.Tree | undefined {\n    if (!viewport.viewFlags.backgroundMap || undefined === viewport.displayStyle.backgroundMapPlane)\n      return undefined;\n\n    this.loadTileTree();\n    return (undefined === this._tileTree) ? undefined : { tileTree: this._tileTree, plane: this.getPlane() };\n  }\n\n  public equalsProps(props: BackgroundMapProps): boolean {\n    const providerName = JsonUtils.asString(props.providerName, \"BingProvider\");\n    const groundBias = JsonUtils.asDouble(props.groundBias, 0.0);\n    const mapType = undefined !== props.providerData ? JsonUtils.asInt(props.providerData.mapType, BackgroundMapType.Hybrid) : BackgroundMapType.Hybrid;\n\n    return providerName === this.providerName && groundBias === this._groundBias && mapType === this.mapType;\n  }\n}\n\n/** @internal */\n// this class is the specialization of BasedTiledMapProvider used for Overlay layers. In this case the\n// creator of the Overlay must specify the ImageryProvider.\nexport class OverlayMapProvider extends BaseTiledMapProvider implements TiledGraphicsProvider.Provider {\n\n  public constructor(imageryProvider: ImageryProvider, groundBias: number, iModel: IModelConnection) {\n    super(iModel, groundBias);\n    this._imageryProvider = imageryProvider;\n  }\n\n  public getTileTree(_viewport: Viewport): TiledGraphicsProvider.Tree | undefined {\n    this.loadTileTree();\n    return (undefined === this._tileTree) ? undefined : { tileTree: this._tileTree, plane: this.getPlane() };\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { AccuDraw, AccuDrawFlags, RotationMode, ContextMode, LockedStates, ThreeAxes, ItemField, KeyinStatus, CompassMode } from \"../AccuDraw\";\nimport { TentativeOrAccuSnap, AccuSnap } from \"../AccuSnap\";\nimport { BeButtonEvent, InputCollector, EventHandled, CoordinateLockOverrides } from \"./Tool\";\nimport { DecorateContext } from \"../ViewContext\";\nimport { Vector3d, Point3d, Matrix3d, Geometry, Transform } from \"@bentley/geometry-core\";\nimport { Viewport } from \"../Viewport\";\nimport { AuxCoordSystemState, ACSDisplayOptions } from \"../AuxCoordSys\";\nimport { BentleyStatus } from \"@bentley/bentleyjs-core\";\nimport { SnapDetail, SnapMode } from \"../HitDetail\";\nimport { IModelApp } from \"../IModelApp\";\n\nfunction normalizedDifference(point1: Point3d, point2: Point3d, out: Vector3d): number { return point2.vectorTo(point1).normalizeWithLength(out).mag; }\nfunction normalizedCrossProduct(vec1: Vector3d, vec2: Vector3d, out: Vector3d): number { return vec1.crossProduct(vec2, out).normalizeWithLength(out).mag; }\n/**\n * A shortcut may require no user input (immediate) or it may install a tool to collect the needed input. AccuDrawShortcuts are how users control AccuDraw.\n * A tool implementor should not use this class to setup AccuDraw, instead use AccuDrawHintBuilder to provide hints.\n * @alpha\n */\nexport class AccuDrawShortcuts {\n  public static rotateAxesByPoint(isSnapped: boolean, aboutCurrentZ: boolean): boolean {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return false;\n\n    const vp = accudraw.currentView;\n    if (!vp)\n      return false;\n\n    const point = accudraw.point;\n    if (!vp.view.is3d())\n      point.z = 0.0;\n\n    if (aboutCurrentZ)\n      accudraw.hardConstructionPlane(point, point, accudraw.planePt, accudraw.axes.z, vp, isSnapped);\n    else\n      accudraw.softConstructionPlane(point, point, accudraw.planePt, accudraw.axes.z, vp, isSnapped);\n\n    // Snap point and compass origin coincide...\n    const xVec = new Vector3d();\n    if (normalizedDifference(point, accudraw.planePt, xVec) < Geometry.smallAngleRadians)\n      return false;\n\n    accudraw.axes.x.setFrom(xVec);\n\n    if (RotationMode.Context !== accudraw.rotationMode)\n      accudraw.setRotationMode(RotationMode.Context);\n\n    accudraw.flags.contextRotMode = ContextMode.XAxis;\n    accudraw.flags.lockedRotation = false;\n\n    accudraw.updateRotation();\n\n    // Always want index line to display for x-Axis...changing rotation clears this...so it flashes...\n    accudraw.indexed |= LockedStates.X_BM;\n    return true;\n  }\n\n  public static updateACSByPoints(acs: AuxCoordSystemState, vp: Viewport, points: Point3d[], isDynamics: boolean): boolean {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return false;\n\n    let accept = false;\n    const vec = [new Vector3d(), new Vector3d(), new Vector3d()];\n    acs.setOrigin(points[0]);\n    switch (points.length) {\n      case 1:\n        acs.setRotation(vp.rotation);\n        if (!isDynamics) {\n          accudraw.published.origin.setFrom(points[0]);\n          accudraw.published.flags = AccuDrawFlags.SetOrigin;\n          accudraw.flags.fixedOrg = true;\n        }\n        break;\n\n      case 2:\n        if (normalizedDifference(points[1], points[0], vec[0]) < 0.00001) {\n          accept = true;\n          break;\n        }\n\n        if (vp.view.is3d()) {\n          if (normalizedCrossProduct(accudraw.axes.y, vec[0], vec[1]) < 0.00001) {\n            vec[2].set(0.0, 0.0, 1.0);\n\n            if (normalizedCrossProduct(vec[2], vec[0], vec[1]) < 0.00001) {\n              vec[2].set(0.0, 1.0, 0.0);\n              normalizedCrossProduct(vec[2], vec[0], vec[1]);\n            }\n          }\n\n          normalizedCrossProduct(vec[0], vec[1], vec[2]);\n          acs.setRotation(Matrix3d.createRows(vec[0], vec[1], vec[2]));\n\n          if (!isDynamics) {\n            accudraw.published.origin.setFrom(points[0]);\n            accudraw.published.flags = AccuDrawFlags.SetOrigin | AccuDrawFlags.SetNormal;\n            accudraw.published.vector.setFrom(vec[0]);\n          }\n          break;\n        }\n\n        vec[2].set(0.0, 0.0, 1.0);\n        normalizedCrossProduct(vec[2], vec[0], vec[1]);\n        acs.setRotation(Matrix3d.createRows(vec[0], vec[1], vec[2]));\n        accept = true;\n        break;\n\n      case 3:\n        if (normalizedDifference(points[1], points[0], vec[0]) < 0.00001 ||\n          normalizedDifference(points[2], points[0], vec[1]) < 0.00001 ||\n          normalizedCrossProduct(vec[0], vec[1], vec[2]) < 0.00001) {\n          accept = true;\n          break;\n        }\n\n        normalizedCrossProduct(vec[2], vec[0], vec[1]);\n        acs.setRotation(Matrix3d.createRows(vec[0], vec[1], vec[2]));\n        accept = true;\n        break;\n    }\n\n    return accept;\n  }\n\n  public static processPendingHints() { IModelApp.accuDraw.processHints(); }\n\n  public static requestInputFocus() {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    accudraw.grabInputFocus();\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  // Helper method for GUI implementation...\n  public static async itemFieldNavigate(index: ItemField, str: string, forward: boolean): Promise<void> {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    if (accudraw.getFieldLock(index))\n      accudraw.saveCoordinate(index, accudraw.getValueByIndex(index));\n\n    if (!accudraw.isActive && KeyinStatus.Partial === accudraw.getKeyinStatus(index)) {\n      await accudraw.processFieldInput(index, str, true);\n    } else {\n      accudraw.setKeyinStatus(index, KeyinStatus.Dynamic);\n      accudraw.onFieldValueChange(index);\n    }\n\n    const vp = accudraw.currentView;\n    const is3d = vp ? vp.view.is3d() : false;\n    const isPolar = (CompassMode.Polar === accudraw.compassMode);\n    switch (index) {\n      case ItemField.DIST_Item:\n        index = ((is3d && !forward) ? ItemField.Z_Item : ItemField.ANGLE_Item);\n        break;\n\n      case ItemField.ANGLE_Item:\n        index = ((is3d && forward) ? ItemField.Z_Item : ItemField.DIST_Item);\n        break;\n\n      case ItemField.X_Item:\n        index = ((is3d && !forward) ? ItemField.Z_Item : ItemField.Y_Item);\n        break;\n\n      case ItemField.Y_Item:\n        index = ((is3d && forward) ? ItemField.Z_Item : ItemField.X_Item);\n        break;\n\n      case ItemField.Z_Item:\n        index = (forward ? (isPolar ? ItemField.DIST_Item : ItemField.X_Item) : (isPolar ? ItemField.ANGLE_Item : ItemField.Y_Item));\n        break;\n    }\n\n    accudraw.setKeyinStatus(index, KeyinStatus.Partial);\n    accudraw.setFocusItem(index);\n    accudraw.dontMoveFocus = true;\n  }\n\n  public static itemFieldNewInput(index: ItemField): void { IModelApp.accuDraw.setKeyinStatus(index, KeyinStatus.Partial); }\n\n  public static async itemFieldAcceptInput(index: ItemField, str: string): Promise<void> {\n    const accudraw = IModelApp.accuDraw;\n    await accudraw.processFieldInput(index, str, true);\n    accudraw.setKeyinStatus(index, KeyinStatus.Dynamic);\n\n    if (accudraw.getFieldLock(index))\n      accudraw.saveCoordinate(index, accudraw.getValueByIndex(index));\n\n    const vp = accudraw.currentView;\n    if (accudraw.isActive) {\n      if (!vp)\n        return;\n\n      if (CompassMode.Polar === accudraw.compassMode)\n        accudraw.fixPointPolar(vp);\n      else\n        accudraw.fixPointRectangular(vp);\n\n      accudraw.flags.dialogNeedsUpdate = true;\n      return;\n    }\n\n    const is3d = vp ? vp.view.is3d() : false;\n    const isPolar = (CompassMode.Polar === accudraw.compassMode);\n    switch (index) {\n      case ItemField.DIST_Item:\n        index = ItemField.ANGLE_Item;\n        break;\n\n      case ItemField.ANGLE_Item:\n        index = (is3d ? ItemField.Z_Item : ItemField.DIST_Item);\n        break;\n\n      case ItemField.X_Item:\n        index = ItemField.Y_Item;\n        break;\n\n      case ItemField.Y_Item:\n        index = (is3d ? ItemField.Z_Item : ItemField.X_Item);\n        break;\n\n      case ItemField.Z_Item:\n        index = (isPolar ? ItemField.DIST_Item : ItemField.X_Item);\n        break;\n    }\n    accudraw.setFocusItem(index);\n  }\n\n  public static itemFieldLockToggle(index: ItemField): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    if (accudraw.getFieldLock(index)) {\n      switch (index) {\n        case ItemField.DIST_Item:\n          accudraw.distanceLock(true, false);\n          break;\n\n        case ItemField.ANGLE_Item:\n          accudraw.angleLock();\n          break;\n\n        case ItemField.X_Item:\n          accudraw.clearTentative();\n          accudraw.locked |= LockedStates.X_BM;\n          break;\n\n        case ItemField.Y_Item:\n          accudraw.clearTentative();\n          accudraw.locked |= LockedStates.Y_BM;\n          break;\n\n        case ItemField.Z_Item:\n          accudraw.clearTentative();\n          break;\n      }\n\n      return;\n    }\n\n    switch (index) {\n      case ItemField.DIST_Item:\n        accudraw.locked &= ~LockedStates.DIST_BM;\n        break;\n\n      case ItemField.ANGLE_Item:\n        accudraw.locked &= ~LockedStates.ANGLE_BM;\n        break;\n\n      case ItemField.X_Item:\n        accudraw.locked &= ~LockedStates.X_BM;\n        break;\n\n      case ItemField.Y_Item:\n        accudraw.locked &= ~LockedStates.Y_BM;\n        break;\n\n      case ItemField.Z_Item:\n        break;\n    }\n\n    accudraw.dontMoveFocus = false;\n    accudraw.clearTentative();\n  }\n\n  public static itemRotationModeChange(rotation: RotationMode): void {\n    const accudraw = IModelApp.accuDraw;\n    const vp = accudraw.currentView;\n    const is3d = vp ? vp.view.is3d() : true;\n\n    if (!is3d && (RotationMode.Front === rotation || RotationMode.Side === rotation))\n      accudraw.setRotationMode(RotationMode.Top);\n\n    accudraw.flags.baseRotation = rotation;\n    accudraw.updateRotation(true);\n  }\n\n  // Shortcut implementations for GUI entry points...\n  public static setOrigin(explicitOrigin?: Point3d): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    if (explicitOrigin) {\n      accudraw.published.origin.setFrom(explicitOrigin);\n      accudraw.flags.haveValidOrigin = true;\n    } else if (accudraw.isInactive || accudraw.isDeactivated) {\n      // If AccuSnap is active use adjusted snap point, otherwise use last data point...\n      const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n      if (undefined !== snap) {\n        accudraw.published.origin.setFrom(snap.isPointAdjusted ? snap.adjustedPoint : snap.getPoint());\n        accudraw.flags.haveValidOrigin = true;\n      } else {\n        const ev = new BeButtonEvent();\n        IModelApp.toolAdmin.fillEventFromLastDataButton(ev);\n\n        if (ev.viewport) {\n          accudraw.published.origin.setFrom(ev.point);\n          accudraw.flags.haveValidOrigin = true;\n        } else {\n          // NOTE: If current point isn't valid setDefaultOrigin will be called...\n          accudraw.published.origin.setFrom(accudraw.point);\n        }\n      }\n    } else {\n      accudraw.published.origin.setFrom(accudraw.point);\n      accudraw.flags.haveValidOrigin = true;\n      accudraw.setLastPoint(accudraw.published.origin);\n    }\n\n    accudraw.clearTentative();\n    const vp = accudraw.currentView;\n\n    // NOTE: _AdjustPoint should have been called to have setup currentView...\n    if (vp && !vp.view.is3d())\n      accudraw.published.origin.z = 0.0;\n\n    accudraw.origin.setFrom(accudraw.published.origin);\n    accudraw.point.setFrom(accudraw.published.origin);\n    accudraw.planePt.setFrom(accudraw.published.origin);\n    accudraw.published.flags |= AccuDrawFlags.SetOrigin;\n    accudraw.activate();\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static changeCompassMode(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    let axisLockStatus = accudraw.locked & LockedStates.XY_BM;\n\n    if (axisLockStatus) {\n      if (CompassMode.Rectangular === accudraw.compassMode) {\n        if (axisLockStatus & LockedStates.X_BM && accudraw.delta.x !== 0.0)\n          axisLockStatus &= ~LockedStates.X_BM;\n\n        if (axisLockStatus & LockedStates.Y_BM && accudraw.delta.y !== 0.0)\n          axisLockStatus &= ~LockedStates.Y_BM;\n      }\n    }\n\n    accudraw.changeCompassMode(true);\n    if (axisLockStatus) {\n      if (CompassMode.Rectangular === accudraw.compassMode) {\n        accudraw.delta.x = accudraw.delta.y = 0.0;\n\n        if (axisLockStatus & LockedStates.X_BM)\n          accudraw.setFieldLock(ItemField.X_Item, true);\n        else if (axisLockStatus & LockedStates.Y_BM)\n          accudraw.setFieldLock(ItemField.Y_Item, true);\n      } else {\n        accudraw.setFieldLock(ItemField.ANGLE_Item, true);\n      }\n      accudraw.locked = axisLockStatus;\n    }\n    accudraw.flags.baseMode = accudraw.compassMode;\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static lockSmart(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    const accuSnap = IModelApp.accuSnap;\n\n    // Don't want AccuSnap to influence axis or Z...\n    if (accuSnap.isHot) {\n      accuSnap.clear();\n\n      const vp = accudraw.currentView;\n      if (vp) {\n        if (CompassMode.Polar === accudraw.compassMode)\n          accudraw.fixPointPolar(vp);\n        else\n          accudraw.fixPointRectangular(vp);\n      }\n    }\n\n    if (CompassMode.Polar === accudraw.compassMode) {\n      const isSnapped = accudraw.clearTentative();\n      if (accudraw.locked & LockedStates.ANGLE_BM) { // angle locked (unlock it)\n        accudraw.setFieldLock(ItemField.ANGLE_Item, false);\n        accudraw.locked &= ~LockedStates.ANGLE_BM;\n      } else if (accudraw.getFieldLock(ItemField.DIST_Item)) { // distance locked (unlock it)\n        accudraw.setFieldLock(ItemField.DIST_Item, false);\n        accudraw.locked &= ~LockedStates.DIST_BM;\n      } else if (isSnapped) {\n        accudraw.doLockAngle(isSnapped);\n      } else if (accudraw.indexed & LockedStates.ANGLE_BM) { // angle indexed (lock it)\n        accudraw.angleLock();\n      } else {\n        if (Math.abs(accudraw.vector.dotProduct(accudraw.axes.x)) > Math.abs(accudraw.vector.dotProduct(accudraw.axes.y)))\n          accudraw.indexed |= LockedStates.Y_BM;\n        else\n          accudraw.indexed |= LockedStates.X_BM;\n        accudraw.angleLock();\n      }\n      accudraw.refreshDecorationsAndDynamics();\n      return;\n    }\n\n    if (accudraw.locked) { // if locked, unlock\n      accudraw.clearTentative();\n      accudraw.locked &= ~LockedStates.XY_BM;\n      accudraw.setFieldLock(ItemField.X_Item, false);\n      accudraw.setFieldLock(ItemField.Y_Item, false);\n      if (accudraw.getFieldLock(ItemField.Z_Item) && accudraw.delta.z === 0.0 && !accudraw.stickyZLock)\n        accudraw.setFieldLock(ItemField.Z_Item, false);\n    } else { // lock to nearest axis\n      if (accudraw.clearTentative()) {\n        if (Math.abs(accudraw.delta.x) >= Geometry.smallAngleRadians && Math.abs(accudraw.delta.y) >= Geometry.smallAngleRadians) {\n          accudraw.doLockAngle(false);\n          return;\n        }\n      }\n\n      const vp = accudraw.currentView;\n      if (Math.abs(accudraw.delta.x) > Math.abs(accudraw.delta.y)) {\n        accudraw.delta.y = 0.0;\n        accudraw.onFieldValueChange(ItemField.Y_Item);\n        accudraw.locked |= LockedStates.Y_BM;\n        accudraw.locked &= ~LockedStates.X_BM;\n        accudraw.setFieldLock(ItemField.X_Item, false);\n        accudraw.setFieldLock(ItemField.Y_Item, true);\n        accudraw.setFieldLock(ItemField.Z_Item, vp ? vp.view.is3d() : false);\n      } else {\n        accudraw.delta.x = 0.0;\n        accudraw.onFieldValueChange(ItemField.X_Item);\n        accudraw.locked |= LockedStates.X_BM;\n        accudraw.locked &= ~LockedStates.Y_BM;\n        accudraw.setFieldLock(ItemField.Y_Item, false);\n        accudraw.setFieldLock(ItemField.X_Item, true);\n        accudraw.setFieldLock(ItemField.Z_Item, vp ? vp.view.is3d() : false);\n      }\n\n      if (!accudraw.flags.lockedRotation) {\n        accudraw.flags.lockedRotation = true;\n        accudraw.flags.contextRotMode = ContextMode.Locked;\n        accudraw.setRotationMode(RotationMode.Context);\n      }\n    }\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static lockX(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    accudraw.clearTentative();\n\n    if (CompassMode.Rectangular !== accudraw.compassMode) {\n      const vp = accudraw.currentView;\n      if (!vp)\n        return;\n\n      accudraw.fixPointRectangular(vp);\n      accudraw.changeCompassMode(true);\n    }\n\n    if (accudraw.getFieldLock(ItemField.X_Item)) {\n      accudraw.setFieldLock(ItemField.X_Item, false);\n      accudraw.locked = accudraw.locked & ~LockedStates.X_BM;\n    } else {\n      accudraw.saveCoordinate(ItemField.X_Item, accudraw.delta.x);\n      accudraw.setFieldLock(ItemField.X_Item, true);\n      accudraw.locked = accudraw.locked | LockedStates.X_BM;\n    }\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static lockY(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    accudraw.clearTentative();\n\n    if (CompassMode.Rectangular !== accudraw.compassMode) {\n      const vp = accudraw.currentView;\n      if (!vp)\n        return;\n\n      accudraw.fixPointRectangular(vp);\n      accudraw.changeCompassMode(true);\n    }\n\n    if (accudraw.getFieldLock(ItemField.Y_Item)) {\n      accudraw.setFieldLock(ItemField.Y_Item, false);\n      accudraw.locked = accudraw.locked & ~LockedStates.Y_BM;\n    } else {\n      accudraw.saveCoordinate(ItemField.Y_Item, accudraw.delta.y);\n      accudraw.setFieldLock(ItemField.Y_Item, true);\n      accudraw.locked = accudraw.locked | LockedStates.Y_BM;\n    }\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static lockZ(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    const vp = accudraw.currentView;\n    if (!vp || !vp.view.is3d())\n      return;\n\n    const isSnapped = accudraw.clearTentative();\n\n    if (accudraw.getFieldLock(ItemField.Z_Item)) {\n      accudraw.setFieldLock(ItemField.Z_Item, false);\n    } else {\n      // Move focus to Z field...\n      if (!isSnapped && accudraw.autoFocusFields) {\n        accudraw.setFocusItem(ItemField.Z_Item);\n        accudraw.dontMoveFocus = true;\n      }\n      accudraw.setFieldLock(ItemField.Z_Item, true);\n    }\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static lockDistance(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    const isSnapped = accudraw.clearTentative();\n\n    if (CompassMode.Polar !== accudraw.compassMode) {\n      const vp = accudraw.currentView;\n      if (!vp)\n        return;\n\n      accudraw.locked = 0;\n      accudraw.fixPointPolar(vp);\n      accudraw.changeCompassMode(true);\n    }\n\n    if (accudraw.getFieldLock(ItemField.DIST_Item)) {\n      accudraw.setFieldLock(ItemField.DIST_Item, false);\n      accudraw.locked &= ~LockedStates.DIST_BM;\n\n      accudraw.setKeyinStatus(ItemField.DIST_Item, KeyinStatus.Dynamic); // Need to clear partial status if locked by entering distance since focus stays in distance field...\n    } else {\n      // Move focus to distance field...\n      if (!isSnapped && accudraw.autoFocusFields)\n        accudraw.setFocusItem(ItemField.DIST_Item);\n      accudraw.distanceLock(true, true);\n    }\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static lockAngle(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n    accudraw.doLockAngle(accudraw.clearTentative());\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public lockIndex(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    if (accudraw.flags.indexLocked) {\n      if (accudraw.locked)\n        AccuDrawShortcuts.lockSmart();\n\n      accudraw.flags.indexLocked = false;\n    } else {\n      if (CompassMode.Polar === accudraw.compassMode) {\n        if (accudraw.indexed & LockedStates.XY_BM) {\n          accudraw.setFieldLock(ItemField.ANGLE_Item, true);\n          accudraw.angleLock();\n        }\n\n        if (accudraw.indexed & LockedStates.DIST_BM)\n          AccuDrawShortcuts.lockDistance();\n      } else {\n        if (accudraw.indexed & LockedStates.X_BM) {\n          AccuDrawShortcuts.lockX();\n\n          if (accudraw.indexed & LockedStates.DIST_BM)\n            AccuDrawShortcuts.lockY();\n        }\n\n        if (accudraw.indexed & LockedStates.Y_BM) {\n          AccuDrawShortcuts.lockY();\n\n          if (accudraw.indexed & LockedStates.DIST_BM)\n            AccuDrawShortcuts.lockX();\n        }\n\n        if (accudraw.indexed & LockedStates.DIST_BM && !(accudraw.indexed & LockedStates.XY_BM)) {\n          if (accudraw.locked & LockedStates.X_BM)\n            AccuDrawShortcuts.lockY();\n          else\n            AccuDrawShortcuts.lockX();\n        }\n      }\n\n      accudraw.flags.indexLocked = true;\n    }\n\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static setStandardRotation(rotation: RotationMode): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    if (RotationMode.Context === rotation) {\n      const axes = accudraw.baseAxes.clone();\n      accudraw.accountForAuxRotationPlane(axes, accudraw.flags.auxRotationPlane);\n      accudraw.setContextRotation(axes.toMatrix3d(), false, true);\n      accudraw.refreshDecorationsAndDynamics();\n      return;\n    } else {\n      accudraw.flags.baseRotation = rotation;\n      accudraw.setRotationMode(rotation);\n    }\n    accudraw.updateRotation(true);\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static alignView(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    const vp = accudraw.currentView;\n    if (!vp)\n      return;\n\n    const newMatrix = accudraw.getRotation();\n    if (newMatrix.isExactEqual(vp.rotation))\n      return;\n\n    const targetMatrix = newMatrix.multiplyMatrixMatrix(vp.rotation);\n    const rotateTransform = Transform.createFixedPointAndMatrix(vp.view.getTargetPoint(), targetMatrix);\n    const startFrustum = vp.getFrustum();\n    const newFrustum = startFrustum.clone();\n    newFrustum.multiply(rotateTransform);\n\n    vp.animateFrustumChange(startFrustum, newFrustum);\n    vp.view.setupFromFrustum(newFrustum);\n    vp.synchWithView(true);\n\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static rotateToBase(): void { this.setStandardRotation(IModelApp.accuDraw.flags.baseRotation); }\n\n  public static rotateToACS(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n    // NOTE: Match current ACS orientation..reset auxRotationPlane to top!\n    accudraw.flags.auxRotationPlane = RotationMode.Top;\n    this.setStandardRotation(RotationMode.ACS);\n  }\n\n  public static rotateCycle(updateCurrentACS: boolean): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    const vp = accudraw.currentView;\n    if (!vp || !vp.view.is3d())\n      return;\n\n    let rotation: RotationMode;\n    switch (accudraw.rotationMode) {\n      case RotationMode.View:\n      case RotationMode.Side:\n        rotation = RotationMode.Top;\n        break;\n\n      case RotationMode.Top:\n        rotation = RotationMode.Front;\n        break;\n\n      case RotationMode.Front:\n        rotation = RotationMode.Side;\n        break;\n\n      case RotationMode.Context:\n        if (!updateCurrentACS) {\n          rotation = RotationMode.Context;\n\n          if (rotation !== accudraw.flags.baseRotation) {\n            accudraw.baseAxes.setFrom(accudraw.axes);\n            accudraw.flags.auxRotationPlane = RotationMode.Top;\n            accudraw.flags.baseRotation = rotation;\n          } else {\n            const axes = accudraw.baseAxes.clone();\n            accudraw.accountForAuxRotationPlane(axes, accudraw.flags.auxRotationPlane);\n            if (!accudraw.axes.equals(axes))\n              accudraw.changeBaseRotationMode(rotation);\n          }\n\n          switch (accudraw.flags.auxRotationPlane) {\n            case RotationMode.Front:\n              accudraw.flags.auxRotationPlane = RotationMode.Side;\n              break;\n\n            case RotationMode.Side:\n              accudraw.flags.auxRotationPlane = RotationMode.Top;\n              break;\n\n            case RotationMode.Top:\n              accudraw.flags.auxRotationPlane = RotationMode.Front;\n              break;\n          }\n          break;\n        }\n\n        // copy it to an ACS\n        accudraw.updateRotation();\n        accudraw.flags.auxRotationPlane = RotationMode.Top;\n\n        const currentACS = vp.view.auxiliaryCoordinateSystem;\n        const acs = currentACS.clone();\n\n        acs.setRotation(accudraw.getRotation());\n        AccuDraw.updateAuxCoordinateSystem(acs, vp);\n\n      /* falls through */\n\n      case RotationMode.ACS:\n        rotation = RotationMode.ACS;\n        switch (accudraw.flags.auxRotationPlane) {\n          case RotationMode.Front:\n            accudraw.flags.auxRotationPlane = RotationMode.Side;\n            break;\n          case RotationMode.Side:\n            accudraw.flags.auxRotationPlane = RotationMode.Top;\n            break;\n          case RotationMode.Top:\n            accudraw.flags.auxRotationPlane = RotationMode.Front;\n            break;\n        }\n        break;\n\n      default:\n        return;\n    }\n\n    this.setStandardRotation(rotation);\n  }\n\n  public static rotate90(axis: number): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    const newRotation = new ThreeAxes();\n\n    accudraw.locked = accudraw.indexed = 0;\n    accudraw.unlockAllFields();\n\n    switch (axis) {\n      case 0:\n        newRotation.x.setFrom(accudraw.axes.x);\n        newRotation.z.setFrom(accudraw.axes.y);\n        newRotation.z.crossProduct(newRotation.x, newRotation.y);\n        break;\n\n      case 1:\n        newRotation.x.setFrom(accudraw.axes.z);\n        newRotation.y.setFrom(accudraw.axes.y);\n        newRotation.x.crossProduct(newRotation.y, newRotation.z);\n        break;\n\n      case 2:\n        newRotation.x.setFrom(accudraw.axes.y);\n        newRotation.z.setFrom(accudraw.axes.z);\n        newRotation.z.crossProduct(newRotation.x, newRotation.y);\n        break;\n    }\n\n    accudraw.setContextRotation(newRotation.toMatrix3d(), true, true);\n    accudraw.refreshDecorationsAndDynamics();\n  }\n\n  public static rotateAxes(aboutCurrentZ: boolean): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isActive)\n      return; // Require compass to already be active for this shortcut...\n\n    if (aboutCurrentZ)\n      accudraw.changeBaseRotationMode(RotationMode.Context); // Establish current orientation as base; base Z is used when defining compass rotation by x axis...\n\n    if (accudraw.clearTentative() || IModelApp.accuSnap.isHot ||\n      (CompassMode.Polar === accudraw.compassMode && accudraw.getFieldLock(ItemField.ANGLE_Item)) ||\n      (CompassMode.Polar !== accudraw.compassMode && accudraw.getFieldLock(ItemField.X_Item) && accudraw.getFieldLock(ItemField.Y_Item))) {\n      if (AccuDrawShortcuts.rotateAxesByPoint(true, aboutCurrentZ)) {\n        AccuDrawShortcuts.itemFieldUnlockAll();\n        accudraw.refreshDecorationsAndDynamics();\n        return;\n      }\n    }\n    AccuDrawTool.installTool(new RotateAxesTool(aboutCurrentZ));\n  }\n\n  public static rotateToElement(updateCurrentACS: boolean): void {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return;\n\n    const moveOrigin = !accudraw.isActive; // Leave current origin if AccuDraw is already enabled...\n    AccuDrawTool.installTool(new RotateElementTool(moveOrigin, updateCurrentACS, false));\n  }\n\n  public static defineACSByElement(): void {\n    AccuDrawTool.installTool(new RotateElementTool(true, true, true));\n  }\n\n  public static defineACSByPoints() {\n    const accudraw = IModelApp.accuDraw;\n    if (accudraw.isEnabled)\n      AccuDrawTool.installTool(new DefineACSByPointsTool());\n  }\n\n  public static getACS(acsName: string | undefined, useOrigin: boolean, useRotation: boolean): BentleyStatus {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return BentleyStatus.ERROR;\n\n    const vp = accudraw.currentView;\n    if (!vp)\n      return BentleyStatus.ERROR;\n\n    let currRotation = 0, currBaseRotation = 0;\n    const axes = new ThreeAxes();\n\n    if (!useRotation) {\n      // Save current rotation, event listener on ACS change will orient AccuDraw to ACS...\n      currRotation = accudraw.rotationMode;\n      currBaseRotation = accudraw.flags.baseRotation;\n      axes.setFrom(accudraw.axes);\n    }\n\n    if (acsName && \"\" !== acsName) {\n      //   // See if this ACS already exists...\n      //   DgnCode acsCode = AuxCoordSystem:: CreateCode(vp -> GetViewControllerR().GetViewDefinition(), acsName);\n      //   DgnElementId acsId = vp -> GetViewController().GetDgnDb().Elements().QueryElementIdByCode(acsCode);\n\n      //   if (!acsId.IsValid())\n      //     return ERROR;\n\n      //   AuxCoordSystemCPtr auxElm = vp -> GetViewController().GetDgnDb().Elements().Get<AuxCoordSystem>(acsId);\n\n      //   if (!auxElm.IsValid())\n      //     return ERROR;\n\n      //   AuxCoordSystemPtr acsPtr = auxElm -> MakeCopy<AuxCoordSystem>();\n\n      //   if (!acsPtr.IsValid())\n      //     return ERROR;\n\n      //   AuxCoordSystemCR oldACS = vp -> GetViewController().GetAuxCoordinateSystem();\n\n      //   if (!useOrigin)\n      //     acsPtr -> SetOrigin(oldACS.GetOrigin());\n\n      //   if (!useRotation)\n      //     acsPtr -> SetRotation(oldACS.GetRotation());\n\n      //   AccuDraw:: UpdateAuxCoordinateSystem(* acsPtr, * vp);\n    }\n\n    const currentACS = vp.view.auxiliaryCoordinateSystem;\n\n    if (useOrigin) {\n      accudraw.origin.setFrom(currentACS.getOrigin());\n      accudraw.point.setFrom(accudraw.origin);\n      accudraw.planePt.setFrom(accudraw.origin);\n    }\n\n    if (useRotation) {\n      accudraw.flags.auxRotationPlane = RotationMode.Top;\n      this.setStandardRotation(RotationMode.ACS);\n    } else {\n      this.itemFieldUnlockAll();\n\n      accudraw.setRotationMode(currRotation);\n      accudraw.flags.baseRotation = currBaseRotation;\n      accudraw.axes.setFrom(axes);\n\n      if (RotationMode.ACS === accudraw.flags.baseRotation) {\n        const acs = currentACS.clone();\n\n        const rMatrix = accudraw.getRotation();\n        acs.setRotation(rMatrix);\n\n        AccuDraw.updateAuxCoordinateSystem(acs, vp);\n      }\n\n      accudraw.published.flags &= ~AccuDrawFlags.OrientACS;\n    }\n\n    return BentleyStatus.SUCCESS;\n  }\n\n  public static writeACS(_acsName: string): BentleyStatus {\n    const accudraw = IModelApp.accuDraw;\n    if (!accudraw.isEnabled)\n      return BentleyStatus.ERROR;\n\n    const vp = accudraw.currentView;\n    if (!vp)\n      return BentleyStatus.ERROR;\n\n    // const origin = accudraw.origin;\n    // const rMatrix = accudraw.getRotation();\n    // AuxCoordSystemPtr acsPtr = AuxCoordSystem:: CreateFrom(vp -> GetViewController().GetAuxCoordinateSystem());\n    // acsPtr -> SetOrigin(origin);\n    // acsPtr -> SetRotation(rMatrix);\n    // acsPtr -> SetType(CompassMode.Polar == accudraw.getCompassMode() ? ACSType :: Cylindrical : ACSType:: Rectangular);\n    // acsPtr -> SetCode(AuxCoordSystem:: CreateCode(vp -> GetViewControllerR().GetViewDefinition(), nullptr != acsName ? acsName : \"\"));\n    // acsPtr -> SetDescription(\"\");\n\n    // if (acsName && '\\0' != acsName[0]) {\n    //   DgnDbStatus status;\n    //   acsPtr -> Insert(& status);\n\n    //   if (DgnDbStatus:: Success != status)\n    //   return BentleyStatus.ERROR;\n    // }\n\n    // AccuDraw:: UpdateAuxCoordinateSystem(* acsPtr, * vp);\n\n    // accudraw.flags.baseRotation = RotationMode.ACS;\n    // accudraw.SetRotationMode(RotationMode.ACS);\n\n    return BentleyStatus.SUCCESS;\n  }\n\n  public static itemFieldUnlockAll(): void {\n    const accudraw = IModelApp.accuDraw;\n    if (accudraw.isEnabled)\n      accudraw.unlockAllFields();\n  }\n\n  /** @internal Temporary keyboard shortcuts. */\n  public static processShortcutKey(keyEvent: KeyboardEvent): boolean {\n    switch (keyEvent.key.toLowerCase()) {\n      case \"enter\":\n        AccuDrawShortcuts.lockSmart();\n        return true;\n      case \"x\":\n        AccuDrawShortcuts.lockX();\n        return true;\n      case \"y\":\n        AccuDrawShortcuts.lockY();\n        return true;\n      case \"z\":\n        AccuDrawShortcuts.lockZ();\n        return true;\n      case \"a\":\n        AccuDrawShortcuts.lockAngle();\n        return true;\n      case \"d\":\n        AccuDrawShortcuts.lockDistance();\n        return true;\n      case \"m\":\n        AccuDrawShortcuts.changeCompassMode();\n        return true;\n      case \"t\":\n        AccuDrawShortcuts.setStandardRotation(RotationMode.Top);\n        return true;\n      case \"f\":\n        AccuDrawShortcuts.setStandardRotation(RotationMode.Front);\n        return true;\n      case \"s\":\n        AccuDrawShortcuts.setStandardRotation(RotationMode.Side);\n        return true;\n      case \"v\":\n        AccuDrawShortcuts.setStandardRotation(RotationMode.View);\n        return true;\n      case \"o\":\n        AccuDrawShortcuts.setOrigin();\n        return true;\n      case \"c\":\n        AccuDrawShortcuts.rotateCycle(false);\n        return true;\n      case \"q\":\n        AccuDrawShortcuts.rotateAxes(true);\n        return true;\n      case \"e\":\n        AccuDrawShortcuts.rotateToElement(false);\n        return true;\n      case \"r\":\n        AccuDrawShortcuts.defineACSByPoints();\n        return true;\n      default:\n        return false;\n    }\n  }\n}\n\nclass AccuDrawShortcutsTool extends InputCollector {\n  public static toolId = \"View.AccuDraw\";\n  private _cancel: boolean;\n  private _shortcut: AccuDrawTool;\n\n  public constructor(shortcut: AccuDrawTool) { super(); this._shortcut = shortcut; this._cancel = true; }\n  public onPostInstall(): void { super.onPostInstall(); this.initLocateElements(false, true, undefined, CoordinateLockOverrides.None); this._shortcut.doManipulationStart(); } // NOTE: InputCollector inherits suspended primitive's state, set everything...\n  public onCleanup(): void { this._shortcut.doManipulationStop(this._cancel); }\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> { if (await this._shortcut.doManipulation(ev, false)) { this._cancel = false; this.exitTool(); } return EventHandled.No; }\n  public async onMouseMotion(ev: BeButtonEvent): Promise<void> { this._shortcut.doManipulation(ev, true); } // tslint:disable-line:no-floating-promises\n  public decorate(context: DecorateContext) { this._shortcut.onDecorate(context); }\n  public exitTool() { super.exitTool(); AccuDrawShortcuts.requestInputFocus(); } // re-grab focus when auto-focus tool setting set...\n}\n\n/** @internal */\nexport abstract class AccuDrawTool {\n  public doManipulationStart() {\n    if (this.activateAccuDrawOnStart())\n      IModelApp.accuDraw.activate();\n\n    this.doManipulation(undefined, true); // tslint:disable-line:no-floating-promises\n  }\n\n  public doManipulationStop(cancel: boolean) {\n    if (!cancel)\n      IModelApp.accuDraw.savedStateInputCollector.ignoreFlags = this.onManipulationComplete();\n  }\n\n  public activateAccuDrawOnStart() { return true; }\n  public abstract async doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): Promise<boolean>;\n  public onManipulationComplete(): AccuDrawFlags { return 0; }\n  public onDecorate(_context: DecorateContext) { }\n  public static installTool(shortcut: AccuDrawTool): boolean { return new AccuDrawShortcutsTool(shortcut).run(); }\n  public static outputPrompt(messageKey: string) { IModelApp.notifications.outputPromptByKey(\"AccuDraw.Prompt.\" + messageKey); }\n}\n\nclass RotateAxesTool extends AccuDrawTool {\n  constructor(private _aboutCurrentZ: boolean) { super(); }\n  public onManipulationComplete(): AccuDrawFlags { return AccuDrawFlags.SetRMatrix; }\n  public doManipulationStart(): void {\n    super.doManipulationStart();\n    AccuDrawTool.outputPrompt(\"DefineXAxis\");\n  }\n  public async doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): Promise<boolean> {\n    const vp = ev ? ev.viewport : IModelApp.accuDraw.currentView;\n    if (!vp)\n      return true;\n    AccuDrawShortcuts.rotateAxesByPoint(TentativeOrAccuSnap.isHot, this._aboutCurrentZ);\n    vp.invalidateDecorations();\n    if (!isMotion)\n      AccuDrawShortcuts.itemFieldUnlockAll();\n    return true;\n  }\n}\n\nclass RotateElementTool extends AccuDrawTool {\n  constructor(private _moveOrigin: boolean, private _updateCurrentACS: boolean, private _updateDynamicACS: boolean) { super(); }\n  public activateAccuDrawOnStart(): boolean { return !this._updateDynamicACS; }\n\n  public onManipulationComplete(): AccuDrawFlags {\n    let ignoreFlags = AccuDrawFlags.SetRMatrix;\n\n    if (this._moveOrigin)\n      ignoreFlags |= AccuDrawFlags.SetOrigin;\n\n    if (!this._updateDynamicACS)\n      ignoreFlags |= AccuDrawFlags.Disable; // If AccuDraw wasn't active when the shortcut started, let it remain active for suspended tool when shortcut completes...\n\n    return ignoreFlags;\n  }\n\n  public doManipulationStart(): void {\n    super.doManipulationStart();\n    AccuDrawTool.outputPrompt(\"DefineElem\");\n    const accuSnap = IModelApp.accuSnap;\n    if (!accuSnap.isSnapEnabledByUser)\n      accuSnap.enableLocate(true); // If user doesn't want AccuSnap, tool can work with just auto-locate...\n  }\n\n  public updateOrientation(snap: SnapDetail, vp: Viewport): boolean {\n    const accudraw = IModelApp.accuDraw;\n    const rMatrix = AccuDraw.getSnapRotation(snap, vp);\n    if (undefined === rMatrix)\n      return false;\n\n    const origin = this._moveOrigin ? snap.snapPoint : accudraw.origin;\n    accudraw.setContext(AccuDrawFlags.AlwaysSetOrigin | AccuDrawFlags.SetRMatrix, origin, rMatrix);\n\n    return true;\n  }\n\n  public async doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): Promise<boolean> {\n    const vp = ev ? ev.viewport : IModelApp.accuDraw.currentView;\n    if (!vp)\n      return true;\n\n    let snapDetail = TentativeOrAccuSnap.getCurrentSnap(false);\n\n    if (undefined === snapDetail) {\n      const accuSnap = IModelApp.accuSnap;\n      const hitDetail = accuSnap.currHit;\n\n      // Turn hit into nearest snap when shortcut was started without AccuSnap being user enabled...\n      if (undefined !== hitDetail)\n        snapDetail = await AccuSnap.requestSnap(hitDetail, [SnapMode.Nearest], IModelApp.locateManager.apertureInches, 1);\n    }\n\n    if (undefined !== snapDetail && !this.updateOrientation(snapDetail, vp))\n      return true;\n\n    if (this._updateDynamicACS)\n      IModelApp.viewManager.invalidateDecorationsAllViews();\n    else if (undefined === ev)\n      AccuDrawShortcuts.processPendingHints();\n\n    if (isMotion)\n      return true;\n\n    const accudraw = IModelApp.accuDraw;\n    if (this._updateCurrentACS) {\n      AccuDrawShortcuts.processPendingHints();\n\n      const currentACS = vp.view.auxiliaryCoordinateSystem;\n      const acs = currentACS.clone();\n\n      acs.setOrigin(accudraw.origin);\n      acs.setRotation(accudraw.getRotation());\n\n      AccuDraw.updateAuxCoordinateSystem(acs, vp);\n    } else {\n      accudraw.changeBaseRotationMode(RotationMode.Context); // Hold temporary rotation for tool duration when not updating ACS...\n    }\n\n    return true;\n  }\n\n  public onDecorate(context: DecorateContext): void {\n    if (!this._updateDynamicACS)\n      return;\n\n    const accudraw = IModelApp.accuDraw;\n    const origin = accudraw.origin;\n    const rMatrix = accudraw.getRotation();\n    const acs = context.viewport!.view.auxiliaryCoordinateSystem.clone();\n    acs.setOrigin(origin);\n    acs.setRotation(rMatrix);\n    acs.display(context, ACSDisplayOptions.Active | ACSDisplayOptions.Dynamics);\n  }\n}\n\nclass DefineACSByPointsTool extends AccuDrawTool {\n  private readonly _points: Point3d[] = [];\n  private _acs?: AuxCoordSystemState;\n\n  public activateAccuDrawOnStart(): boolean { return false; }\n  public onManipulationComplete(): AccuDrawFlags { return AccuDrawFlags.SetRMatrix; }\n\n  public doManipulationStart(): void {\n    super.doManipulationStart();\n\n    const tentativePoint = IModelApp.tentativePoint;\n    if (!tentativePoint.isActive) {\n      AccuDrawTool.outputPrompt(\"DefineOrigin\");\n      return;\n    }\n\n    const origin = tentativePoint.getPoint().clone();\n    AccuDrawTool.outputPrompt(\"DefineXAxis\");\n    IModelApp.accuDraw.setContext(AccuDrawFlags.SetOrigin | AccuDrawFlags.FixedOrigin, origin);\n    this._points.push(origin);\n    tentativePoint.clear(true);\n  }\n\n  public async doManipulation(ev: BeButtonEvent | undefined, isMotion: boolean): Promise<boolean> {\n    if (!ev || !ev.viewport)\n      return true;\n\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n    if (isMotion)\n      return false;\n\n    IModelApp.accuDraw.activate();\n    this._points.push(ev.point.clone());\n\n    const vp = ev.viewport;\n    if (!this._acs)\n      this._acs = vp.view.auxiliaryCoordinateSystem.clone();\n\n    if (AccuDrawShortcuts.updateACSByPoints(this._acs, vp, this._points, false)) {\n      AccuDraw.updateAuxCoordinateSystem(this._acs, vp);\n      AccuDrawShortcuts.rotateToACS();\n      return true;\n    }\n\n    AccuDrawTool.outputPrompt(1 === this._points.length ? \"DefineXAxis\" : \"DefineYDir\");\n    return false;\n  }\n\n  public onDecorate(context: DecorateContext): void {\n    const tmpPoints: Point3d[] = [];\n    this._points.forEach((pt) => tmpPoints.push(pt));\n\n    const ev = new BeButtonEvent();\n    IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n    tmpPoints.push(ev.point);\n\n    const vp = context.viewport!;\n    if (!this._acs)\n      this._acs = vp.view.auxiliaryCoordinateSystem.clone();\n\n    AccuDrawShortcuts.updateACSByPoints(this._acs, vp, tmpPoints, true);\n    this._acs.display(context, ACSDisplayOptions.Active | ACSDisplayOptions.Dynamics);\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { Range3d, ClipVector, ClipShape, ClipPrimitive, ClipPlane, ConvexClipPlaneSet, Plane3dByOriginAndUnitNormal, Vector3d, Point3d, Transform, Matrix3d, ClipMaskXYZRangePlanes, Range1d, PolygonOps, Geometry, Ray3d, ClipUtilities, Loop, Path, GeometryQuery, LineString3d } from \"@bentley/geometry-core\";\nimport { Placement2d, Placement3d, Placement2dProps, ColorDef, LinePixels, IModelError } from \"@bentley/imodeljs-common\";\nimport { IModelApp } from \"../IModelApp\";\nimport { BeButtonEvent, EventHandled, CoordinateLockOverrides } from \"./Tool\";\nimport { LocateResponse } from \"../ElementLocateManager\";\nimport { Id64Arg, Id64, BeEvent, GuidString, Guid, IModelStatus } from \"@bentley/bentleyjs-core\";\nimport { Viewport, ScreenViewport } from \"../Viewport\";\nimport { TentativeOrAccuSnap } from \"../AccuSnap\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { DecorateContext } from \"../ViewContext\";\nimport { EditManipulator } from \"./EditManipulator\";\nimport { AccuDrawHintBuilder, AccuDraw } from \"../AccuDraw\";\nimport { StandardViewId } from \"../StandardView\";\nimport { GraphicType } from \"../rendering\";\nimport { HitDetail } from \"../HitDetail\";\nimport { PropertyDescription } from \"../properties/Description\";\nimport { ToolSettingsValue, ToolSettingsPropertyRecord, ToolSettingsPropertySyncItem } from \"../properties/ToolSettingsValue\";\nimport { PrimitiveValue } from \"../properties/Value\";\nimport { AccuDrawShortcuts } from \"./AccuDrawTool\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { AuthorizedFrontendRequestContext } from \"../imodeljs-frontend\";\nimport { SettingsResult, SettingsStatus, SettingsMapResult } from \"@bentley/imodeljs-clients\";\n\n/** @alpha The orientation to use to define the view clip volume */\nexport enum ClipOrientation {\n  Top,\n  Front,\n  Left,\n  Bottom,\n  Back,\n  Right,\n  View,\n  Face,\n}\n\n/** @alpha An object that can react to a view's clip being changed by tools or modify handles. */\nexport interface ViewClipEventHandler {\n  selectOnCreate(): boolean; // Add newly created clip geometry to selection set and show modify controls.\n  clearOnDeselect(): boolean; // Stop displaying clip geometry when clip is removed from the selection set.\n  onNewClip(viewport: Viewport): void; // Called by tools that set or replace the existing view clip with a new clip.\n  onNewClipPlane(viewport: Viewport): void; // Called by tools that add a single plane to the view clip. When there is more than one plane, the new plane is always last.\n  onModifyClip(viewport: Viewport): void; // Called by tools after modifying the view clip.\n  onClearClip(viewport: Viewport): void; // Called when the view clip is cleared from the view.\n  onActivateClip(viewport: Viewport, interactive: boolean): void; // Called when the view clip is changed to a saved clip.\n  onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean; // Called when user right clicks on clip geometry or clip modify handle. Return true if event handled.\n}\n\n/** @alpha A tool to define a clip volume for a view */\nexport class ViewClipTool extends PrimitiveTool {\n  constructor(protected _clipEventHandler?: ViewClipEventHandler) { super(); }\n\n  protected static _orientationName = \"enumAsOrientation\";\n  protected static enumAsOrientationMessage(str: string) { return IModelApp.i18n.translate(\"CoreTools:tools.ViewClip.Settings.Orientation.\" + str); }\n  protected static _getEnumAsOrientationDescription = (): PropertyDescription => {\n    return {\n      name: ViewClipTool._orientationName,\n      displayLabel: IModelApp.i18n.translate(\"CoreTools:tools.ViewClip.Settings.Orientation.Label\"),\n      typename: \"enum\",\n      enum: {\n        choices: [\n          { label: ViewClipTool.enumAsOrientationMessage(\"Top\"), value: ClipOrientation.Top },\n          { label: ViewClipTool.enumAsOrientationMessage(\"Front\"), value: ClipOrientation.Front },\n          { label: ViewClipTool.enumAsOrientationMessage(\"Left\"), value: ClipOrientation.Left },\n          { label: ViewClipTool.enumAsOrientationMessage(\"Bottom\"), value: ClipOrientation.Bottom },\n          { label: ViewClipTool.enumAsOrientationMessage(\"Back\"), value: ClipOrientation.Back },\n          { label: ViewClipTool.enumAsOrientationMessage(\"Right\"), value: ClipOrientation.Right },\n          { label: ViewClipTool.enumAsOrientationMessage(\"View\"), value: ClipOrientation.View },\n          { label: ViewClipTool.enumAsOrientationMessage(\"Face\"), value: ClipOrientation.Face },\n        ],\n      },\n    };\n  }\n\n  public requireWriteableTarget(): boolean { return false; }\n  public isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.allow3dManipulations()); }\n\n  public onPostInstall(): void { super.onPostInstall(); this.setupAndPromptForNextAction(); }\n  public onUnsuspend(): void { this.showPrompt(); }\n  public onRestartTool(): void { this.exitTool(); }\n\n  protected outputPrompt(prompt: string) { IModelApp.notifications.outputPromptByKey(\"CoreTools:tools.ViewClip.\" + prompt); }\n  protected showPrompt(): void { }\n  protected setupAndPromptForNextAction(): void { this.showPrompt(); }\n\n  public async onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled> { this.onReinitialize(); return EventHandled.No; }\n\n  public static getPlaneInwardNormal(orientation: ClipOrientation, viewport: Viewport): Vector3d | undefined {\n    const matrix = ViewClipTool.getClipOrientation(orientation, viewport);\n    if (undefined === matrix)\n      return undefined;\n    return matrix.getColumn(2).negate();\n  }\n\n  public static getClipOrientation(orientation: ClipOrientation, viewport: Viewport): Matrix3d | undefined {\n    switch (orientation) {\n      case ClipOrientation.Top:\n        return AccuDraw.getStandardRotation(StandardViewId.Top, viewport, viewport.isContextRotationRequired).inverse();\n      case ClipOrientation.Front:\n        return AccuDraw.getStandardRotation(StandardViewId.Front, viewport, viewport.isContextRotationRequired).inverse();\n      case ClipOrientation.Left:\n        return AccuDraw.getStandardRotation(StandardViewId.Left, viewport, viewport.isContextRotationRequired).inverse();\n      case ClipOrientation.Bottom:\n        return AccuDraw.getStandardRotation(StandardViewId.Bottom, viewport, viewport.isContextRotationRequired).inverse();\n      case ClipOrientation.Back:\n        return AccuDraw.getStandardRotation(StandardViewId.Back, viewport, viewport.isContextRotationRequired).inverse();\n      case ClipOrientation.Right:\n        return AccuDraw.getStandardRotation(StandardViewId.Right, viewport, viewport.isContextRotationRequired).inverse();\n      case ClipOrientation.View:\n        return viewport.view.getRotation().inverse();\n      case ClipOrientation.Face:\n        const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n        if (undefined === snap || undefined === snap.normal)\n          return undefined;\n        const normal = Vector3d.createZero();\n        const boresite = EditManipulator.HandleUtils.getBoresite(snap.hitPoint, viewport);\n        if (snap.normal.dotProduct(boresite.direction) < 0.0)\n          normal.setFrom(snap.normal);\n        else\n          snap.normal.negate(normal);\n        return Matrix3d.createRigidHeadsUp(normal);\n    }\n    return undefined;\n  }\n\n  public static enableClipVolume(viewport: Viewport): boolean {\n    if (viewport.viewFlags.clipVolume)\n      return false;\n    const viewFlags = viewport.viewFlags.clone();\n    viewFlags.clipVolume = true;\n    viewport.viewFlags = viewFlags;\n    return true;\n  }\n\n  public static setViewClip(viewport: Viewport, clip?: ClipVector): boolean {\n    viewport.view.setViewClip(clip);\n    viewport.setupFromView();\n    return true;\n  }\n\n  public static doClipToConvexClipPlaneSet(viewport: Viewport, planes: ConvexClipPlaneSet): boolean {\n    const prim = ClipPrimitive.createCapture(planes);\n    const clip = ClipVector.createEmpty();\n    clip.appendReference(prim);\n    return this.setViewClip(viewport, clip);\n  }\n\n  public static doClipToPlane(viewport: Viewport, origin: Point3d, normal: Vector3d, clearExistingPlanes: boolean): boolean {\n    const plane = Plane3dByOriginAndUnitNormal.create(origin, normal);\n    if (undefined === plane)\n      return false;\n    let planeSet: ConvexClipPlaneSet | undefined;\n    if (!clearExistingPlanes) {\n      const existingClip = viewport.view.getViewClip();\n      if (undefined !== existingClip && 1 === existingClip.clips.length) {\n        const existingPrim = existingClip.clips[0];\n        if (!(existingPrim instanceof ClipShape)) {\n          const existingPlaneSets = existingPrim.fetchClipPlanesRef();\n          if (undefined !== existingPlaneSets && 1 === existingPlaneSets.convexSets.length)\n            planeSet = existingPlaneSets.convexSets[0];\n        }\n      }\n    }\n    if (undefined === planeSet)\n      planeSet = ConvexClipPlaneSet.createEmpty();\n    planeSet.addPlaneToConvexSet(ClipPlane.createPlane(plane));\n    return this.doClipToConvexClipPlaneSet(viewport, planeSet);\n  }\n\n  public static doClipToShape(viewport: Viewport, xyPoints: Point3d[], transform?: Transform, zLow?: number, zHigh?: number): boolean {\n    const clip = ClipVector.createEmpty();\n    clip.appendShape(xyPoints, zLow, zHigh, transform);\n    return this.setViewClip(viewport, clip);\n  }\n\n  public static doClipToRange(viewport: Viewport, range: Range3d, transform?: Transform): boolean {\n    if (range.isNull || range.isAlmostZeroX || range.isAlmostZeroY)\n      return false;\n    const clip = ClipVector.createEmpty();\n    const block = ClipShape.createBlock(range, range.isAlmostZeroZ ? ClipMaskXYZRangePlanes.XAndY : ClipMaskXYZRangePlanes.All, false, false, transform);\n    clip.appendReference(block);\n    return this.setViewClip(viewport, clip);\n  }\n\n  public static doClipClear(viewport: Viewport): boolean {\n    if (!ViewClipTool.hasClip(viewport))\n      return false;\n    return this.setViewClip(viewport);\n  }\n\n  public static getClipRayTransformed(origin: Point3d, direction: Vector3d, transform?: Transform): Ray3d {\n    const facePt = origin.clone();\n    const faceDir = direction.clone();\n\n    if (undefined !== transform) {\n      transform.multiplyPoint3d(facePt, facePt);\n      transform.multiplyVector(faceDir, faceDir);\n      faceDir.normalizeInPlace();\n    }\n\n    return Ray3d.createCapture(facePt, faceDir);\n  }\n\n  public static getOffsetValueTransformed(offset: number, transform?: Transform) {\n    if (undefined === transform)\n      return offset;\n    const lengthVec = Vector3d.create(offset);\n    transform.multiplyVector(lengthVec, lengthVec);\n    const localOffset = lengthVec.magnitude();\n    return (offset < 0 ? -localOffset : localOffset);\n  }\n\n  public static drawClipShape(context: DecorateContext, shape: ClipShape, extents: Range1d, color: ColorDef, weight: number, id?: string): void {\n    const shapePtsLo = ViewClipTool.getClipShapePoints(shape, extents.low);\n    const shapePtsHi = ViewClipTool.getClipShapePoints(shape, extents.high);\n    const builder = context.createGraphicBuilder(GraphicType.WorldDecoration, shape.transformFromClip, id); // Use WorldDecoration not WorldOverlay to make sure handles have priority...\n    builder.setSymbology(color, ColorDef.black, weight);\n    for (let i: number = 0; i < shapePtsLo.length; i++)\n      builder.addLineString([shapePtsLo[i].clone(), shapePtsHi[i].clone()]);\n    builder.addLineString(shapePtsLo);\n    builder.addLineString(shapePtsHi);\n    context.addDecorationFromBuilder(builder);\n  }\n\n  public static getClipShapePoints(shape: ClipShape, z: number): Point3d[] {\n    const points: Point3d[] = [];\n    for (const pt of shape.polygon)\n      points.push(Point3d.create(pt.x, pt.y, z));\n    return points;\n  }\n\n  public static getClipShapeExtents(shape: ClipShape, viewRange: Range3d): Range1d {\n    let zLow = shape.zLow;\n    let zHigh = shape.zHigh;\n    if (undefined === zLow || undefined === zHigh) {\n      const zVec = Vector3d.unitZ();\n      const origin = shape.polygon[0];\n      const corners = viewRange.corners();\n      if (undefined !== shape.transformToClip)\n        shape.transformToClip.multiplyPoint3dArrayInPlace(corners);\n      for (const corner of corners) {\n        const delta = Vector3d.createStartEnd(origin, corner);\n        const projection = delta.dotProduct(zVec);\n        if (undefined === shape.zLow && (undefined === zLow || projection < zLow))\n          zLow = projection;\n        if (undefined === shape.zHigh && (undefined === zHigh || projection > zHigh))\n          zHigh = projection;\n      }\n    }\n    return Range1d.createXX(zLow!, zHigh!);\n  }\n\n  public static isSingleClipShape(clip: ClipVector): ClipShape | undefined {\n    if (1 !== clip.clips.length)\n      return undefined;\n    const prim = clip.clips[0];\n    if (!(prim instanceof ClipShape))\n      return undefined;\n    if (!prim.isValidPolygon)\n      return undefined;\n    return prim;\n  }\n\n  public static drawClipPlanesLoops(context: DecorateContext, loops: GeometryQuery[], color: ColorDef, weight: number, dashed?: boolean, fill?: ColorDef, id?: string): void {\n    if (loops.length < 1)\n      return;\n    const builderEdge = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined, id); // Use WorldDecoration not WorldOverlay to make sure handles have priority...\n    builderEdge.setSymbology(color, ColorDef.black, weight, dashed ? LinePixels.Code2 : undefined);\n    for (const geom of loops) {\n      if (!(geom instanceof Loop))\n        continue;\n      builderEdge.addPath(Path.createArray(geom.children));\n    }\n    context.addDecorationFromBuilder(builderEdge);\n    if (undefined === fill)\n      return;\n    const builderFace = context.createGraphicBuilder(GraphicType.WorldDecoration, undefined);\n    builderFace.setSymbology(fill, fill, 0);\n    for (const geom of loops) {\n      if (!(geom instanceof Loop))\n        continue;\n      builderFace.addLoop(geom);\n    }\n    context.addDecorationFromBuilder(builderFace);\n  }\n\n  public static isSingleConvexClipPlaneSet(clip: ClipVector): ConvexClipPlaneSet | undefined {\n    if (1 !== clip.clips.length)\n      return undefined;\n    const prim = clip.clips[0];\n    if (prim instanceof ClipShape)\n      return undefined;\n    const planeSets = prim.fetchClipPlanesRef();\n    return (undefined !== planeSets && 1 === planeSets.convexSets.length) ? planeSets.convexSets[0] : undefined;\n  }\n\n  public static isSingleClipPlane(clip: ClipVector): ClipPlane | undefined {\n    const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);\n    if (undefined === clipPlanes || 1 !== clipPlanes.planes.length)\n      return undefined;\n    return clipPlanes.planes[0];\n  }\n\n  public static areClipsEqual(clipA: ClipVector, clipB: ClipVector): boolean {\n    if (clipA === clipB)\n      return true;\n    if (clipA.clips.length !== clipB.clips.length)\n      return false;\n    for (let iPrim = 0; iPrim < clipA.clips.length; iPrim++) {\n      const primA = clipA.clips[iPrim];\n      const primB = clipB.clips[iPrim];\n      const planesA = primA.fetchClipPlanesRef();\n      const planesB = primB.fetchClipPlanesRef();\n      if (undefined !== planesA && undefined !== planesB) {\n        if (planesA.convexSets.length !== planesB.convexSets.length)\n          return false;\n        for (let iPlane = 0; iPlane < planesA.convexSets.length; iPlane++) {\n          const planeSetA = planesA.convexSets[iPlane];\n          const planeSetB = planesB.convexSets[iPlane];\n          if (planeSetA.planes.length !== planeSetB.planes.length)\n            return false;\n          for (let iClipPlane = 0; iClipPlane < planeSetA.planes.length; iClipPlane++) {\n            const planeA = planeSetA.planes[iClipPlane];\n            const planeB = planeSetB.planes[iClipPlane];\n            if (!planeA.isAlmostEqual(planeB))\n              return false;\n          }\n        }\n      } else if (undefined === planesA && undefined === planesB) {\n        continue;\n      } else {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  public static hasClip(viewport: Viewport) {\n    return (undefined !== viewport.view.getViewClip());\n  }\n}\n\n/** @alpha A tool to remove a clip volume for a view */\nexport class ViewClipClearTool extends ViewClipTool {\n  public static toolId = \"ViewClip.Clear\";\n  public isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && ViewClipTool.hasClip(vp)); }\n\n  protected showPrompt(): void { this.outputPrompt(\"Clear.Prompts.FirstPoint\"); }\n\n  protected doClipClear(viewport: Viewport): boolean {\n    if (!ViewClipTool.doClipClear(viewport))\n      return false;\n    if (undefined !== this._clipEventHandler)\n      this._clipEventHandler.onClearClip(viewport);\n    this.onReinitialize();\n    return true;\n  }\n\n  public onPostInstall(): void {\n    super.onPostInstall();\n    if (undefined !== this.targetView)\n      this.doClipClear(this.targetView);\n  }\n\n  public async onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled> {\n    if (undefined === this.targetView)\n      return EventHandled.No;\n    return this.doClipClear(this.targetView) ? EventHandled.Yes : EventHandled.No;\n  }\n}\n\n/** @alpha A tool to define a clip volume for a view by specifying a plane */\nexport class ViewClipByPlaneTool extends ViewClipTool {\n  public static toolId = \"ViewClip.ByPlane\";\n  private _orientationValue = new ToolSettingsValue(ClipOrientation.Face);\n  constructor(clipEventHandler?: ViewClipEventHandler, protected _clearExistingPlanes: boolean = false) { super(clipEventHandler); }\n\n  public get orientation(): ClipOrientation { return this._orientationValue.value as ClipOrientation; }\n  public set orientation(option: ClipOrientation) { this._orientationValue.value = option; }\n\n  public supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined {\n    IModelApp.toolAdmin.toolSettingsState.initializeToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });\n    const toolSettings = new Array<ToolSettingsPropertyRecord>();\n    toolSettings.push(new ToolSettingsPropertyRecord(this._orientationValue.clone() as PrimitiveValue, ViewClipTool._getEnumAsOrientationDescription(), { rowPriority: 0, columnIndex: 2 }));\n    return toolSettings;\n  }\n\n  public applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean {\n    if (updatedValue.propertyName === ViewClipTool._orientationName) {\n      if (this._orientationValue.update(updatedValue.value)) {\n        IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });\n        return true;\n      }\n    }\n    return false;\n  }\n\n  protected showPrompt(): void { this.outputPrompt(\"ByPlane.Prompts.FirstPoint\"); }\n\n  protected setupAndPromptForNextAction(): void {\n    super.setupAndPromptForNextAction();\n    IModelApp.accuSnap.enableSnap(true);\n  }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    if (undefined === this.targetView)\n      return EventHandled.No;\n    const normal = ViewClipTool.getPlaneInwardNormal(this.orientation, this.targetView);\n    if (undefined === normal)\n      return EventHandled.No;\n    ViewClipTool.enableClipVolume(this.targetView);\n    if (!ViewClipTool.doClipToPlane(this.targetView, ev.point, normal, this._clearExistingPlanes))\n      return EventHandled.No;\n    if (undefined !== this._clipEventHandler)\n      this._clipEventHandler.onNewClipPlane(this.targetView);\n    this.onReinitialize();\n    return EventHandled.Yes;\n  }\n}\n\n/** @alpha A tool to define a clip volume for a view by specifying a shape */\nexport class ViewClipByShapeTool extends ViewClipTool {\n  public static toolId = \"ViewClip.ByShape\";\n  private _orientationValue = new ToolSettingsValue(ClipOrientation.Top);\n  protected readonly _points: Point3d[] = [];\n  protected _matrix?: Matrix3d;\n  protected _zLow?: number;\n  protected _zHigh?: number;\n\n  public get orientation(): ClipOrientation { return this._orientationValue.value as ClipOrientation; }\n  public set orientation(option: ClipOrientation) { this._orientationValue.value = option; }\n\n  public supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined {\n    IModelApp.toolAdmin.toolSettingsState.initializeToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });\n    const toolSettings = new Array<ToolSettingsPropertyRecord>();\n    toolSettings.push(new ToolSettingsPropertyRecord(this._orientationValue.clone() as PrimitiveValue, ViewClipTool._getEnumAsOrientationDescription(), { rowPriority: 0, columnIndex: 2 }));\n    return toolSettings;\n  }\n\n  public applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean {\n    if (updatedValue.propertyName === ViewClipTool._orientationName) {\n      if (!this._orientationValue.update(updatedValue.value))\n        return false;\n      this._points.length = 0;\n      this._matrix = undefined;\n      AccuDrawHintBuilder.deactivate();\n      this.setupAndPromptForNextAction();\n      IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: ViewClipTool._orientationName, value: this._orientationValue });\n      return true;\n    }\n    return false;\n  }\n\n  protected showPrompt(): void {\n    switch (this._points.length) {\n      case 0:\n        this.outputPrompt(\"ByShape.Prompts.FirstPoint\");\n        break;\n      case 1:\n        this.outputPrompt(\"ByShape.Prompts.SecondPoint\");\n        break;\n      case 2:\n        this.outputPrompt(\"ByShape.Prompts.ThirdPoint\");\n        break;\n      default:\n        this.outputPrompt(\"ByShape.Prompts.NextPoint\");\n        break;\n    }\n  }\n\n  protected setupAndPromptForNextAction(): void {\n    super.setupAndPromptForNextAction();\n    IModelApp.accuSnap.enableSnap(true);\n    if (0 === this._points.length)\n      return;\n\n    const hints = new AccuDrawHintBuilder();\n    hints.setOrigin(this._points[this._points.length - 1]);\n    if (1 === this._points.length) {\n      hints.setRotation(this._matrix!.inverse()!);\n      hints.setModeRectangular();\n    }\n    hints.setLockZ = true;\n    hints.sendHints();\n  }\n\n  protected getClipPoints(ev: BeButtonEvent): Point3d[] {\n    const points: Point3d[] = [];\n    if (undefined === this.targetView || this._points.length < 1)\n      return points;\n    for (const pt of this._points)\n      points.push(pt.clone());\n\n    const normal = this._matrix!.getColumn(2);\n    let currentPt = EditManipulator.HandleUtils.projectPointToPlaneInView(ev.point, points[0], normal, ev.viewport!, true);\n    if (undefined === currentPt)\n      currentPt = ev.point.clone();\n    if (2 === points.length && !ev.isControlKey) {\n      const xDir = Vector3d.createStartEnd(points[0], points[1]);\n      const xLen = xDir.magnitude(); xDir.normalizeInPlace();\n      const yDir = xDir.crossProduct(normal); yDir.normalizeInPlace();\n      const cornerPt = EditManipulator.HandleUtils.projectPointToLineInView(currentPt, points[1], yDir, ev.viewport!, true);\n      if (undefined !== cornerPt) {\n        points.push(cornerPt);\n        cornerPt.plusScaled(xDir, -xLen, currentPt);\n      }\n    }\n    points.push(currentPt);\n    if (points.length > 2)\n      points.push(points[0].clone());\n\n    return points;\n  }\n\n  public isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean {\n    return (this._points.length > 0 ? true : super.isValidLocation(ev, isButtonEvent));\n  }\n\n  public decorate(context: DecorateContext): void {\n    if (context.viewport !== this.targetView)\n      return;\n\n    const ev = new BeButtonEvent();\n    IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n    const points = this.getClipPoints(ev);\n    if (points.length < 2)\n      return;\n\n    const builderAccVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n    const builderAccHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n    const colorAccVis = ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);\n    const colorAccHid = colorAccVis.clone(); colorAccHid.setAlpha(100);\n    const fillAccVis = context.viewport.hilite.color.clone(); fillAccVis.setAlpha(25);\n\n    builderAccVis.setSymbology(colorAccVis, fillAccVis, 3);\n    builderAccHid.setSymbology(colorAccHid, fillAccVis, 1);\n\n    if (points.length > 2)\n      builderAccHid.addShape(points);\n\n    builderAccVis.addLineString(points);\n    builderAccHid.addLineString(points);\n\n    context.addDecorationFromBuilder(builderAccVis);\n    context.addDecorationFromBuilder(builderAccHid);\n  }\n\n  public decorateSuspended(context: DecorateContext): void { this.decorate(context); }\n  public async onMouseMotion(ev: BeButtonEvent): Promise<void> { if (this._points.length > 0 && undefined !== ev.viewport) ev.viewport.invalidateDecorations(); }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    if (undefined === this.targetView)\n      return EventHandled.No;\n\n    if (this._points.length > 1 && !ev.isControlKey) {\n      const points = this.getClipPoints(ev);\n      if (points.length < 3)\n        return EventHandled.No;\n\n      const transform = Transform.createOriginAndMatrix(points[0], this._matrix);\n      transform.multiplyInversePoint3dArrayInPlace(points);\n      ViewClipTool.enableClipVolume(this.targetView);\n      if (!ViewClipTool.doClipToShape(this.targetView, points, transform, this._zLow, this._zHigh))\n        return EventHandled.No;\n      if (undefined !== this._clipEventHandler)\n        this._clipEventHandler.onNewClip(this.targetView);\n      this.onReinitialize();\n      return EventHandled.Yes;\n    }\n\n    if (undefined === this._matrix && undefined === (this._matrix = ViewClipTool.getClipOrientation(this.orientation, this.targetView)))\n      return EventHandled.No;\n\n    const currPt = ev.point.clone();\n    if (this._points.length > 0) {\n      const planePt = EditManipulator.HandleUtils.projectPointToPlaneInView(currPt, this._points[0], this._matrix!.getColumn(2), ev.viewport!, true);\n      if (undefined !== planePt)\n        currPt.setFrom(planePt);\n    }\n\n    this._points.push(currPt);\n    this.setupAndPromptForNextAction();\n    return EventHandled.No;\n  }\n\n  public async onUndoPreviousStep(): Promise<boolean> {\n    if (0 === this._points.length)\n      return false;\n\n    this._points.pop();\n    if (0 === this._points.length)\n      this.onReinitialize();\n    else\n      this.setupAndPromptForNextAction();\n    return true;\n  }\n\n  public async onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled> {\n    if (EventHandled.Yes === await super.onKeyTransition(wentDown, keyEvent))\n      return EventHandled.Yes;\n    return (wentDown && AccuDrawShortcuts.processShortcutKey(keyEvent)) ? EventHandled.Yes : EventHandled.No;\n  }\n}\n\n/** @alpha A tool to define a clip volume for a view by specifying range corners */\nexport class ViewClipByRangeTool extends ViewClipTool {\n  public static toolId = \"ViewClip.ByRange\";\n  protected _corner?: Point3d;\n\n  protected showPrompt(): void { this.outputPrompt(undefined === this._corner ? \"ByRange.Prompts.FirstPoint\" : \"ByRange.Prompts.NextPoint\"); }\n\n  protected setupAndPromptForNextAction(): void {\n    super.setupAndPromptForNextAction();\n    IModelApp.accuSnap.enableSnap(true);\n  }\n\n  protected getClipRange(range: Range3d, transform: Transform, ev: BeButtonEvent): boolean {\n    if (undefined === this.targetView || undefined === this._corner)\n      return false;\n    // Creating clip aligned with ACS when ACS context lock is enabled...\n    const matrix = ViewClipTool.getClipOrientation(ClipOrientation.Top, this.targetView);\n    Transform.createOriginAndMatrix(this._corner, matrix, transform);\n    const pt1 = transform.multiplyInversePoint3d(this._corner);\n    const pt2 = transform.multiplyInversePoint3d(ev.point);\n    if (undefined === pt1 || undefined === pt2)\n      return false;\n    range.setFrom(Range3d.create(pt1, pt2));\n    return true;\n  }\n\n  public decorate(context: DecorateContext): void {\n    if (context.viewport !== this.targetView || undefined === this._corner)\n      return;\n\n    const ev = new BeButtonEvent();\n    IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n    const range = Range3d.create();\n    const transform = Transform.createIdentity();\n    if (!this.getClipRange(range, transform, ev))\n      return;\n\n    const builderAccVis = context.createGraphicBuilder(GraphicType.WorldDecoration, transform);\n    const builderAccHid = context.createGraphicBuilder(GraphicType.WorldOverlay, transform);\n    const colorAccVis = ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);\n    const colorAccHid = colorAccVis.clone(); colorAccHid.setAlpha(100);\n\n    builderAccVis.setSymbology(colorAccVis, ColorDef.black, 3);\n    builderAccHid.setSymbology(colorAccHid, ColorDef.black, 1);\n\n    builderAccVis.addRangeBox(range);\n    builderAccHid.addRangeBox(range);\n\n    context.addDecorationFromBuilder(builderAccVis);\n    context.addDecorationFromBuilder(builderAccHid);\n  }\n\n  public decorateSuspended(context: DecorateContext): void { this.decorate(context); }\n  public async onMouseMotion(ev: BeButtonEvent): Promise<void> { if (undefined !== this._corner && undefined !== ev.viewport) ev.viewport.invalidateDecorations(); }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    if (undefined === this.targetView)\n      return EventHandled.No;\n\n    if (undefined !== this._corner) {\n      const range = Range3d.create();\n      const transform = Transform.createIdentity();\n      if (!this.getClipRange(range, transform, ev))\n        return EventHandled.No;\n      ViewClipTool.enableClipVolume(this.targetView);\n      if (!ViewClipTool.doClipToRange(this.targetView, range, transform))\n        return EventHandled.No;\n      if (undefined !== this._clipEventHandler)\n        this._clipEventHandler.onNewClip(this.targetView);\n      this.onReinitialize();\n      return EventHandled.Yes;\n    }\n\n    this._corner = ev.point.clone();\n    this.setupAndPromptForNextAction();\n    return EventHandled.No;\n  }\n\n  public async onUndoPreviousStep(): Promise<boolean> {\n    if (undefined === this._corner)\n      return false;\n    this.onReinitialize();\n    return true;\n  }\n}\n\n/** @alpha A tool to define a clip volume for a view by element(s) */\nexport class ViewClipByElementTool extends ViewClipTool {\n  public static toolId = \"ViewClip.ByElement\";\n  constructor(clipEventHandler?: ViewClipEventHandler, protected _alwaysUseRange: boolean = false) { super(clipEventHandler); }\n\n  protected showPrompt(): void { this.outputPrompt(\"ByElement.Prompts.FirstPoint\"); }\n\n  public onPostInstall(): void {\n    super.onPostInstall();\n    if (undefined !== this.targetView && this.targetView.iModel.selectionSet.isActive) {\n      let useSelection = true;\n      this.targetView.iModel.selectionSet.elements.forEach((val) => { if (Id64.isInvalid(val) || Id64.isTransient(val)) useSelection = false; });\n      if (useSelection) {\n        this.doClipToSelectedElements(this.targetView); // tslint:disable-line:no-floating-promises\n        return;\n      }\n    }\n    this.initLocateElements(true, false, \"default\", CoordinateLockOverrides.All);\n  }\n\n  public async doClipToSelectedElements(viewport: Viewport): Promise<boolean> {\n    if (await this.doClipToElements(viewport, viewport.iModel.selectionSet.elements, this._alwaysUseRange))\n      return true;\n    this.exitTool();\n    return false;\n  }\n\n  protected async doClipToElements(viewport: Viewport, ids: Id64Arg, alwaysUseRange: boolean = false): Promise<boolean> {\n    try {\n      const elementProps = await viewport.iModel.elements.getProps(ids);\n      if (0 === elementProps.length)\n        return false;\n      const range = new Range3d();\n      const transform = Transform.createIdentity();\n      for (const props of elementProps) {\n        if (undefined === props.placement)\n          continue;\n        const hasAngle = (arg: any): arg is Placement2dProps => arg.angle !== undefined;\n        const placement = hasAngle(props.placement) ? Placement2d.fromJSON(props.placement) : Placement3d.fromJSON(props.placement);\n        if (!alwaysUseRange && 1 === elementProps.length) {\n          range.setFrom(placement instanceof Placement2d ? Range3d.createRange2d(placement.bbox, 0) : placement.bbox);\n          transform.setFrom(placement.transform); // Use ElementAlignedBox for single selection...\n        } else {\n          range.extendRange(placement.calculateRange());\n        }\n      }\n      ViewClipTool.enableClipVolume(viewport);\n      if (!ViewClipTool.doClipToRange(viewport, range, transform))\n        return false;\n      if (undefined !== this._clipEventHandler)\n        this._clipEventHandler.onNewClip(viewport);\n      this.onReinitialize();\n      return true;\n    } catch {\n      return false;\n    }\n  }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    if (undefined === this.targetView)\n      return EventHandled.No;\n    const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n    if (undefined === hit || !hit.isElementHit)\n      return EventHandled.No;\n    return await this.doClipToElements(this.targetView, hit.sourceId, this._alwaysUseRange) ? EventHandled.Yes : EventHandled.No;\n  }\n}\n\n/** @alpha Interactive tool base class to modify a view's clip */\nexport abstract class ViewClipModifyTool extends EditManipulator.HandleTool {\n  protected _anchorIndex: number;\n  protected _ids: string[];\n  protected _controls: ViewClipControlArrow[];\n  protected _clipView: Viewport;\n  protected _clip: ClipVector;\n  protected _viewRange: Range3d;\n  protected _restoreClip: boolean = true;\n  protected _currentDistance: number = 0.0;\n\n  public constructor(manipulator: EditManipulator.HandleProvider, clip: ClipVector, vp: Viewport, hitId: string, ids: string[], controls: ViewClipControlArrow[]) {\n    super(manipulator);\n    this._anchorIndex = ids.indexOf(hitId);\n    this._ids = ids;\n    this._controls = controls;\n    this._clipView = vp;\n    this._clip = clip;\n    this._viewRange = vp.computeViewRange();\n  }\n\n  protected init(): void {\n    this.receivedDownEvent = true;\n    this.initLocateElements(false, false, undefined, CoordinateLockOverrides.All); // Disable locate/snap/locks for control modification; overrides state inherited from suspended primitive...\n    AccuDrawHintBuilder.deactivate();\n  }\n\n  protected abstract updateViewClip(ev: BeButtonEvent, isAccept: boolean): boolean;\n  protected abstract drawViewClip(context: DecorateContext): void;\n\n  protected getOffsetValue(ev: BeButtonEvent, transformFromClip?: Transform): number | undefined {\n    if (-1 === this._anchorIndex || undefined === ev.viewport || ev.viewport !== this._clipView)\n      return undefined;\n\n    // NOTE: Use AccuDraw z instead of view z if AccuDraw is explicitly enabled...\n    const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[this._anchorIndex].origin, this._controls[this._anchorIndex].direction, transformFromClip);\n    const projectedPt = EditManipulator.HandleUtils.projectPointToLineInView(ev.point, anchorRay.origin, anchorRay.direction, ev.viewport, true);\n    if (undefined === projectedPt)\n      return undefined;\n\n    const offsetVec = Vector3d.createStartEnd(anchorRay.origin, projectedPt);\n    let offset = offsetVec.normalizeWithLength(offsetVec).mag;\n    if (offset < Geometry.smallMetricDistance)\n      return undefined;\n    if (offsetVec.dotProduct(anchorRay.direction) < 0.0)\n      offset *= -1.0;\n\n    this._currentDistance = offset;\n    return offset;\n  }\n\n  protected drawAnchorOffset(context: DecorateContext, color: ColorDef, weight: number, transformFromClip?: Transform): void {\n    if (-1 === this._anchorIndex || Math.abs(this._currentDistance) < Geometry.smallMetricDistance)\n      return;\n\n    const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[this._anchorIndex].origin, this._controls[this._anchorIndex].direction, transformFromClip);\n    anchorRay.direction.scaleToLength(this._currentDistance, anchorRay.direction);\n    const pt1 = anchorRay.fractionToPoint(0.0);\n    const pt2 = anchorRay.fractionToPoint(1.0);\n    const builder = context.createGraphicBuilder(GraphicType.ViewOverlay);\n\n    context.viewport.worldToView(pt1, pt1); pt1.z = 0.0;\n    context.viewport.worldToView(pt2, pt2); pt2.z = 0.0;\n\n    builder.setSymbology(color, ColorDef.black, weight, LinePixels.Code5);\n    builder.addLineString([pt1, pt2]);\n    builder.setSymbology(color, ColorDef.black, weight + 7);\n    builder.addPointString([pt1, pt2]);\n\n    context.addDecorationFromBuilder(builder);\n  }\n\n  public decorate(context: DecorateContext): void {\n    if (-1 === this._anchorIndex || context.viewport !== this._clipView)\n      return;\n    this.drawViewClip(context);\n  }\n\n  public async onMouseMotion(ev: BeButtonEvent): Promise<void> {\n    if (!this.updateViewClip(ev, false))\n      return;\n    this._clipView.invalidateDecorations();\n  }\n\n  protected accept(ev: BeButtonEvent): boolean {\n    if (!this.updateViewClip(ev, true))\n      return false;\n    this._restoreClip = false;\n    return true;\n  }\n\n  public onCleanup(): void {\n    if (this._restoreClip && ViewClipTool.hasClip(this._clipView))\n      ViewClipTool.setViewClip(this._clipView, this._clip);\n  }\n}\n\n/** @alpha Interactive tool to modify a view's clip defined by a ClipShape */\nexport class ViewClipShapeModifyTool extends ViewClipModifyTool {\n  protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean {\n    const clipShape = ViewClipTool.isSingleClipShape(this._clip);\n    if (undefined === clipShape)\n      return false;\n\n    const offset = this.getOffsetValue(ev, clipShape.transformFromClip);\n    if (undefined === offset)\n      return false;\n\n    const offsetAll = ev.isShiftKey;\n    const localOffset = ViewClipTool.getOffsetValueTransformed(offset, clipShape.transformToClip);\n    const shapePts = ViewClipTool.getClipShapePoints(clipShape, 0.0);\n    const adjustedPts: Point3d[] = [];\n    for (let i = 0; i < shapePts.length; i++) {\n      const prevFace = (0 === i ? shapePts.length - 2 : i - 1);\n      const nextFace = (shapePts.length - 1 === i ? 0 : i);\n      const prevSelected = offsetAll || (prevFace === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[prevFace]));\n      const nextSelected = offsetAll || (nextFace === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[nextFace]));\n      if (prevSelected && nextSelected) {\n        const prevPt = shapePts[i].plusScaled(this._controls[prevFace].direction, localOffset);\n        const nextPt = shapePts[i].plusScaled(this._controls[nextFace].direction, localOffset);\n        const prevRay = Ray3d.create(prevPt, Vector3d.createStartEnd(shapePts[i === 0 ? shapePts.length - 2 : i - 1], shapePts[i]));\n        const nextPlane = Plane3dByOriginAndUnitNormal.create(nextPt, this._controls[nextFace].direction);\n        if (undefined === nextPlane || undefined === prevRay.intersectionWithPlane(nextPlane, prevPt))\n          return false;\n        adjustedPts[i] = prevPt;\n      } else if (prevSelected) {\n        adjustedPts[i] = shapePts[i].plusScaled(this._controls[prevFace].direction, localOffset);\n      } else if (nextSelected) {\n        adjustedPts[i] = shapePts[i].plusScaled(this._controls[nextFace].direction, localOffset);\n      } else {\n        adjustedPts[i] = shapePts[i];\n      }\n    }\n\n    let zLow = clipShape.zLow;\n    let zHigh = clipShape.zHigh;\n    const zLowIndex = this._controls.length - 2;\n    const zHighIndex = this._controls.length - 1;\n    const zLowSelected = offsetAll || (zLowIndex === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[zLowIndex]));\n    const zHighSelected = offsetAll || (zHighIndex === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[zHighIndex]));\n\n    if (zLowSelected || zHighSelected) {\n      const clipExtents = ViewClipTool.getClipShapeExtents(clipShape, this._viewRange);\n      if (zLowSelected)\n        zLow = clipExtents.low - localOffset;\n      if (zHighSelected)\n        zHigh = clipExtents.high + localOffset;\n      const realZLow = (undefined === zLow ? clipExtents.low : zLow);\n      const realZHigh = (undefined === zHigh ? clipExtents.high : zHigh);\n      if (realZLow > realZHigh) { zLow = realZHigh; zHigh = realZLow; }\n    }\n\n    return ViewClipTool.doClipToShape(this._clipView, adjustedPts, clipShape.transformFromClip, zLow, zHigh);\n  }\n\n  protected drawViewClip(context: DecorateContext): void {\n    const clip = this._clipView.view.getViewClip();\n    if (undefined === clip)\n      return;\n    const clipShape = ViewClipTool.isSingleClipShape(clip);\n    if (undefined === clipShape)\n      return;\n    const clipExtents = ViewClipTool.getClipShapeExtents(clipShape, this._viewRange);\n    const color = ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);\n    ViewClipTool.drawClipShape(context, clipShape, clipExtents, color, 1);\n    this.drawAnchorOffset(context, color, 1, clipShape.transformFromClip);\n  }\n}\n\n/** @alpha Interactive tool to modify a view's clip defined by a ConvexClipPlaneSet */\nexport class ViewClipPlanesModifyTool extends ViewClipModifyTool {\n  protected updateViewClip(ev: BeButtonEvent, _isAccept: boolean): boolean {\n    const offset = this.getOffsetValue(ev);\n    if (undefined === offset)\n      return false;\n\n    const offsetAll = ev.isShiftKey;\n    const planeSet = ConvexClipPlaneSet.createEmpty();\n    for (let i: number = 0; i < this._controls.length; i++) {\n      const selected = offsetAll || (i === this._anchorIndex || this.manipulator.iModel.selectionSet.has(this._ids[i]));\n      const origin = this._controls[i].origin.clone();\n      const direction = this._controls[i].direction;\n      if (selected)\n        origin.plusScaled(direction, offset, origin);\n      planeSet.addPlaneToConvexSet(ClipPlane.createNormalAndPoint(direction.negate(), origin));\n    }\n\n    return ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet);\n  }\n\n  protected drawViewClip(context: DecorateContext): void {\n    const clip = this._clipView.view.getViewClip();\n    if (undefined === clip)\n      return;\n    const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);\n    if (undefined === clipPlanes)\n      return;\n    const clipPlanesLoops = ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(clipPlanes, this._viewRange, true, false, true);\n    if (undefined === clipPlanesLoops)\n      return;\n    const color = ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);\n    ViewClipTool.drawClipPlanesLoops(context, clipPlanesLoops, color, 1);\n    this.drawAnchorOffset(context, color, 1);\n  }\n}\n\n/** @alpha Modify handle data to modify a view's clip */\nexport class ViewClipControlArrow {\n  public origin: Point3d;\n  public direction: Vector3d;\n  public sizeInches: number;\n  public fill?: ColorDef;\n  public outline?: ColorDef;\n  public name?: string;\n\n  public constructor(origin: Point3d, direction: Vector3d, sizeInches: number, fill?: ColorDef, outline?: ColorDef, name?: string) {\n    this.origin = origin;\n    this.direction = direction;\n    this.sizeInches = sizeInches;\n    this.fill = fill;\n    this.outline = outline;\n    this.name = name;\n  }\n}\n\n/** @alpha Controls to modify a view's clip */\nexport class ViewClipDecoration extends EditManipulator.HandleProvider {\n  private static _decorator?: ViewClipDecoration;\n  protected _clip?: ClipVector;\n  protected _clipId?: string;\n  protected _clipShape?: ClipShape;\n  protected _clipShapeExtents?: Range1d;\n  protected _clipPlanes?: ConvexClipPlaneSet;\n  protected _clipPlanesLoops?: GeometryQuery[];\n  protected _clipPlanesLoopsNoncontributing?: GeometryQuery[];\n  protected _controlIds: string[] = [];\n  protected _controls: ViewClipControlArrow[] = [];\n  protected _suspendDecorator = false;\n  protected _removeViewCloseListener?: () => void;\n\n  public constructor(protected _clipView: Viewport, protected _clipEventHandler?: ViewClipEventHandler) {\n    super(_clipView.iModel);\n    if (!this.getClipData())\n      return;\n    this._clipId = this.iModel.transientIds.next;\n    this.updateDecorationListener(true);\n    this._removeViewCloseListener = IModelApp.viewManager.onViewClose.addListener(this.onViewClose, this);\n    if (undefined !== this._clipEventHandler && this._clipEventHandler.selectOnCreate())\n      this.iModel.selectionSet.replace(this._clipId);\n  }\n\n  public get clipId(): string | undefined { return this._clipId; }\n  public get clipShape(): ClipShape | undefined { return this._clipShape; }\n  public get clipPlaneSet(): ConvexClipPlaneSet | undefined { return this._clipPlanes; }\n  public getControlIndex(id: string): number { return this._controlIds.indexOf(id); }\n\n  protected stop(): void {\n    const selectedId = (undefined !== this._clipId && this.iModel.selectionSet.has(this._clipId)) ? this._clipId : undefined;\n    this._clipId = undefined; // Invalidate id so that decorator will be dropped...\n    super.stop();\n    if (undefined !== selectedId)\n      this.iModel.selectionSet.remove(selectedId); // Don't leave decorator id in selection set...\n    if (undefined !== this._removeViewCloseListener) {\n      this._removeViewCloseListener();\n      this._removeViewCloseListener = undefined;\n    }\n  }\n\n  public onViewClose(vp: ScreenViewport): void {\n    if (this._clipView === vp)\n      ViewClipDecoration.clear();\n  }\n\n  private getClipData(): boolean {\n    this._clip = this._clipShape = this._clipShapeExtents = this._clipPlanes = this._clipPlanesLoops = this._clipPlanesLoopsNoncontributing = undefined;\n    const clip = this._clipView.view.getViewClip();\n    if (undefined === clip)\n      return false;\n    const clipShape = ViewClipTool.isSingleClipShape(clip);\n    if (undefined !== clipShape) {\n      this._clipShapeExtents = ViewClipTool.getClipShapeExtents(clipShape, this._clipView.computeViewRange());\n      this._clipShape = clipShape;\n    } else {\n      const clipPlanes = ViewClipTool.isSingleConvexClipPlaneSet(clip);\n      if (undefined === clipPlanes || clipPlanes.planes.length > 12)\n        return false;\n      const clipPlanesLoops = ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(clipPlanes, this._clipView.computeViewRange(), true, false, true);\n      if (undefined !== clipPlanesLoops && clipPlanesLoops.length > clipPlanes.planes.length)\n        return false;\n      this._clipPlanesLoops = clipPlanesLoops;\n      this._clipPlanes = clipPlanes;\n    }\n    this._clip = clip;\n    return true;\n  }\n\n  private ensureNumControls(numReqControls: number): void {\n    const numCurrent = this._controlIds.length;\n    if (numCurrent < numReqControls) {\n      const transientIds = this.iModel.transientIds;\n      for (let i: number = numCurrent; i < numReqControls; i++)\n        this._controlIds[i] = transientIds.next;\n    } else if (numCurrent > numReqControls) {\n      this._controlIds.length = numReqControls;\n    }\n  }\n\n  private createClipShapeControls(): boolean {\n    if (undefined === this._clipShape)\n      return false;\n\n    const shapePtsLo = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents!.low);\n    const shapePtsHi = ViewClipTool.getClipShapePoints(this._clipShape, this._clipShapeExtents!.high);\n    const shapeArea = PolygonOps.centroidAreaNormal(shapePtsLo);\n    if (undefined === shapeArea)\n      return false;\n\n    const numControls = shapePtsLo.length + 1; // Number of edge midpoints plus zLow and zHigh...\n    this.ensureNumControls(numControls);\n\n    for (let i: number = 0; i < numControls - 2; i++) {\n      const midPtLo = shapePtsLo[i].interpolate(0.5, shapePtsLo[i + 1]);\n      const midPtHi = shapePtsHi[i].interpolate(0.5, shapePtsHi[i + 1]);\n      const faceCenter = midPtLo.interpolate(0.5, midPtHi);\n      const edgeTangent = Vector3d.createStartEnd(shapePtsLo[i], shapePtsLo[i + 1]);\n      const faceNormal = edgeTangent.crossProduct(shapeArea.direction); faceNormal.normalizeInPlace();\n      this._controls[i] = new ViewClipControlArrow(faceCenter, faceNormal, shapePtsLo.length > 5 ? 0.5 : 0.75);\n    }\n\n    const zFillColor = ColorDef.from(150, 150, 250);\n    this._controls[numControls - 2] = new ViewClipControlArrow(shapeArea.origin, Vector3d.unitZ(-1.0), 0.75, zFillColor, undefined, \"zLow\");\n    this._controls[numControls - 1] = new ViewClipControlArrow(shapeArea.origin.plusScaled(Vector3d.unitZ(), shapePtsLo[0].distance(shapePtsHi[0])), Vector3d.unitZ(), 0.75, zFillColor, undefined, \"zHigh\");\n\n    return true;\n  }\n\n  private getLoopCentroidAreaNormal(geom: GeometryQuery): Ray3d | undefined {\n    if (!(geom instanceof Loop) || geom.children.length > 1)\n      return undefined;\n    const child = geom.getChild(0);\n    if (!(child instanceof LineString3d))\n      return undefined;\n    return PolygonOps.centroidAreaNormal(child.points);\n  }\n\n  private createClipPlanesControls(): boolean {\n    if (undefined === this._clipPlanes)\n      return false;\n\n    const loopData: Ray3d[] = [];\n    if (undefined !== this._clipPlanesLoops) {\n      for (const geom of this._clipPlanesLoops) {\n        const loopArea = this.getLoopCentroidAreaNormal(geom);\n        if (undefined !== loopArea)\n          loopData.push(loopArea);\n      }\n    }\n\n    const numControls = this._clipPlanes.planes.length;\n    this.ensureNumControls(numControls);\n\n    let viewRange;\n    let iLoop: number = 0;\n    for (let i: number = 0; i < this._clipPlanes.planes.length; i++) {\n      const plane = this._clipPlanes.planes[i].getPlane3d();\n      if (iLoop < loopData.length) {\n        if (Math.abs(loopData[iLoop].direction.dotProduct(plane.getNormalRef())) > 0.9999 && plane.isPointInPlane(loopData[iLoop].origin)) {\n          const outwardNormal = loopData[iLoop].direction.negate();\n          this._controls[i] = new ViewClipControlArrow(loopData[iLoop].origin, outwardNormal, 0.75);\n          iLoop++;\n          continue;\n        }\n      }\n\n      if (undefined === viewRange)\n        viewRange = this._clipView.computeViewRange();\n\n      const defaultOrigin = plane.projectPointToPlane(viewRange.center);\n      const defaultOutwardNormal = plane.getNormalRef().negate();\n      const expandedRange = viewRange.clone(); expandedRange.extend(defaultOrigin);\n      const nonContribLoops = ClipUtilities.loopsOfConvexClipPlaneIntersectionWithRange(ConvexClipPlaneSet.createPlanes([this._clipPlanes.planes[i]]), expandedRange, true, false, true);\n      const nonContribColor = ColorDef.from(250, 100, 100);\n\n      if (undefined !== nonContribLoops && nonContribLoops.length > 0) {\n        if (undefined === this._clipPlanesLoopsNoncontributing)\n          this._clipPlanesLoopsNoncontributing = nonContribLoops;\n        else\n          this._clipPlanesLoopsNoncontributing = this._clipPlanesLoopsNoncontributing.concat(nonContribLoops);\n        const loopArea = this.getLoopCentroidAreaNormal(nonContribLoops[0]);\n        if (undefined !== loopArea) {\n          const outwardNormal = loopArea.direction.negate();\n          this._controls[i] = new ViewClipControlArrow(loopArea.origin, outwardNormal, 0.5, nonContribColor);\n          continue;\n        }\n      }\n\n      this._controls[i] = new ViewClipControlArrow(defaultOrigin, defaultOutwardNormal, 0.5, nonContribColor); // Just show arrow for right-click menu options...\n    }\n\n    return true;\n  }\n\n  protected async createControls(): Promise<boolean> {\n    // Always update to current view clip to handle post-modify, etc.\n    if (undefined === this._clipId || !this.getClipData())\n      return false;\n\n    // Show controls if only range box and it's controls are selected, selection set doesn't include any other elements...\n    let showControls = false;\n    if (this.iModel.selectionSet.size <= this._controlIds.length + 1 && this.iModel.selectionSet.has(this._clipId)) {\n      showControls = true;\n      if (this.iModel.selectionSet.size > 1) {\n        this.iModel.selectionSet.elements.forEach((val) => {\n          if (this._clipId !== val && !this._controlIds.includes(val))\n            showControls = false;\n        });\n      }\n    }\n\n    if (!showControls) {\n      if (undefined !== this._clipEventHandler && this._clipEventHandler.clearOnDeselect())\n        ViewClipDecoration.clear();\n      return false;\n    }\n\n    if (undefined !== this._clipShape)\n      return this.createClipShapeControls();\n    else if (undefined !== this._clipPlanes)\n      return this.createClipPlanesControls();\n\n    return false;\n  }\n\n  protected clearControls(): void {\n    this.iModel.selectionSet.remove(this._controlIds); // Remove any selected controls as they won't continue to be displayed...\n    super.clearControls();\n  }\n\n  protected modifyControls(hit: HitDetail, _ev: BeButtonEvent): boolean {\n    if (undefined === this._clip || hit.sourceId === this._clipId)\n      return false;\n    const saveQualifiers = IModelApp.toolAdmin.currentInputState.qualifiers;\n    if (undefined !== this._clipShape) {\n      const clipShapeModifyTool = new ViewClipShapeModifyTool(this, this._clip, this._clipView, hit.sourceId, this._controlIds, this._controls);\n      this._suspendDecorator = clipShapeModifyTool.run();\n    } else if (undefined !== this._clipPlanes) {\n      const clipPlanesModifyTool = new ViewClipPlanesModifyTool(this, this._clip, this._clipView, hit.sourceId, this._controlIds, this._controls);\n      this._suspendDecorator = clipPlanesModifyTool.run();\n    }\n    if (this._suspendDecorator)\n      IModelApp.toolAdmin.currentInputState.qualifiers = saveQualifiers; // onInstallTool cleared qualifiers, preserve for \"modify all\" behavior when shift was held and drag started...\n    return this._suspendDecorator;\n  }\n\n  public doClipPlaneNegate(index: number): boolean {\n    if (undefined === this._clipPlanes)\n      return false;\n\n    if (index < 0 || index >= this._clipPlanes.planes.length)\n      return false;\n\n    const planeSet = ConvexClipPlaneSet.createEmpty();\n    for (let i: number = 0; i < this._clipPlanes.planes.length; i++) {\n      const plane = (i === index ? this._clipPlanes.planes[i].cloneNegated() : this._clipPlanes.planes[i]);\n      planeSet.addPlaneToConvexSet(plane);\n    }\n\n    if (!ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet))\n      return false;\n\n    this.onManipulatorEvent(EditManipulator.EventType.Accept);\n    return true;\n  }\n\n  public doClipPlaneClear(index: number): boolean {\n    if (undefined === this._clipPlanes)\n      return false;\n\n    if (index < 0 || index >= this._clipPlanes.planes.length)\n      return false;\n\n    if (1 === this._clipPlanes.planes.length) {\n      if (!ViewClipTool.doClipClear(this._clipView))\n        return false;\n      if (undefined !== this._clipEventHandler)\n        this._clipEventHandler.onClearClip(this._clipView);\n      ViewClipDecoration.clear();\n      return true;\n    }\n\n    const planeSet = ConvexClipPlaneSet.createEmpty();\n    for (let i: number = 0; i < this._clipPlanes.planes.length; i++) {\n      if (i === index)\n        continue;\n      const plane = this._clipPlanes.planes[i];\n      planeSet.addPlaneToConvexSet(plane);\n    }\n\n    if (!ViewClipTool.doClipToConvexClipPlaneSet(this._clipView, planeSet))\n      return false;\n\n    this.onManipulatorEvent(EditManipulator.EventType.Accept);\n    return true;\n  }\n\n  public doClipPlaneOrientView(index: number): boolean {\n    if (index < 0 || index >= this._controlIds.length)\n      return false;\n\n    const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[index].origin, this._controls[index].direction, undefined !== this._clipShape ? this._clipShape.transformFromClip : undefined);\n    const matrix = Matrix3d.createRigidHeadsUp(anchorRay.direction);\n    const targetMatrix = matrix.multiplyMatrixMatrix(this._clipView.rotation);\n    const rotateTransform = Transform.createFixedPointAndMatrix(anchorRay.origin, targetMatrix);\n    const startFrustum = this._clipView.getFrustum();\n    const newFrustum = startFrustum.clone();\n    newFrustum.multiply(rotateTransform);\n    this._clipView.animateFrustumChange(startFrustum, newFrustum);\n    this._clipView.view.setupFromFrustum(newFrustum);\n    this._clipView.synchWithView(true);\n    return true;\n  }\n\n  private getWorldUpPlane(viewport: Viewport): Plane3dByOriginAndUnitNormal | undefined {\n    const matrix = AccuDraw.getStandardRotation(StandardViewId.Top, viewport, viewport.isContextRotationRequired).inverse();\n    if (undefined === matrix)\n      return undefined;\n    const worldUp = matrix.getColumn(2);\n    const planePt = (viewport.isContextRotationRequired ? viewport.getAuxCoordOrigin() : (viewport.view.isSpatialView ? viewport.view.iModel.globalOrigin : Point3d.createZero()));\n    return Plane3dByOriginAndUnitNormal.create(planePt, worldUp);\n  }\n\n  private isAlignedToWorldUpPlane(plane: Plane3dByOriginAndUnitNormal, transformFromClip?: Transform): boolean {\n    const normal = (undefined !== transformFromClip ? transformFromClip.multiplyVector(Vector3d.unitZ()) : Vector3d.unitZ());\n    return plane.getNormalRef().isParallelTo(normal, true);\n  }\n\n  public isClipShapeAlignedWithWorldUp(extents?: Range1d): boolean {\n    if (undefined === this._clipShape)\n      return false;\n\n    const plane = this.getWorldUpPlane(this._clipView);\n    if (undefined === plane || !this.isAlignedToWorldUpPlane(plane, this._clipShape.transformFromClip))\n      return false;\n\n    if (undefined === extents)\n      return true;\n\n    const zLow = Point3d.create(0.0, 0.0, this._clipShapeExtents!.low);\n    const zHigh = Point3d.create(0.0, 0.0, this._clipShapeExtents!.high);\n\n    if (undefined !== this._clipShape.transformFromClip) {\n      this._clipShape.transformFromClip.multiplyPoint3d(zLow, zLow);\n      this._clipShape.transformFromClip.multiplyPoint3d(zHigh, zHigh);\n    }\n\n    const lowDir = Vector3d.createStartEnd(plane.projectPointToPlane(zLow), zLow);\n    const highDir = Vector3d.createStartEnd(plane.projectPointToPlane(zHigh), zHigh);\n    let zLowWorld = lowDir.magnitude();\n    let zHighWorld = highDir.magnitude();\n\n    if (lowDir.dotProduct(plane.getNormalRef()) < 0.0)\n      zLowWorld = -zLowWorld;\n    if (highDir.dotProduct(plane.getNormalRef()) < 0.0)\n      zHighWorld = -zHighWorld;\n\n    Range1d.createXX(zLowWorld, zHighWorld, extents);\n    return true;\n  }\n\n  public doClipShapeSetZExtents(extents: Range1d): boolean {\n    if (extents.low > extents.high)\n      return false;\n    if (undefined === this._clipShape)\n      return false;\n    const plane = this.getWorldUpPlane(this._clipView);\n    if (undefined === plane || !this.isAlignedToWorldUpPlane(plane, this._clipShape.transformFromClip))\n      return false;\n\n    const zLow = plane.getOriginRef().plusScaled(plane.getNormalRef(), extents.low);\n    const zHigh = plane.getOriginRef().plusScaled(plane.getNormalRef(), extents.high);\n\n    if (undefined !== this._clipShape.transformToClip) {\n      this._clipShape.transformToClip.multiplyPoint3d(zLow, zLow);\n      this._clipShape.transformToClip.multiplyPoint3d(zHigh, zHigh);\n    }\n\n    const reversed = (zLow.z > zHigh.z);\n    const shape = ClipShape.createFrom(this._clipShape);\n    shape.initSecondaryProps(shape.isMask, reversed ? zHigh.z : zLow.z, reversed ? zLow.z : zHigh.z, this._clipShape.transformFromClip);\n\n    const clip = ClipVector.createEmpty();\n    clip.appendReference(shape);\n\n    if (!ViewClipTool.setViewClip(this._clipView, clip))\n      return false;\n\n    this.onManipulatorEvent(EditManipulator.EventType.Accept);\n    return true;\n  }\n\n  protected async onRightClick(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled> {\n    if (undefined === this._clipEventHandler)\n      return EventHandled.No;\n    return (this._clipEventHandler.onRightClick(hit, ev) ? EventHandled.Yes : EventHandled.No);\n  }\n\n  protected async onTouchTap(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled> { return (hit.sourceId === this._clipId ? EventHandled.No : super.onTouchTap(hit, ev)); }\n\n  public onManipulatorEvent(eventType: EditManipulator.EventType): void {\n    this._suspendDecorator = false;\n    super.onManipulatorEvent(eventType);\n    if (EditManipulator.EventType.Accept === eventType && undefined !== this._clipEventHandler)\n      this._clipEventHandler.onModifyClip(this._clipView);\n  }\n\n  public testDecorationHit(id: string): boolean { return (id === this._clipId || this._controlIds.includes(id)); }\n  public async getDecorationToolTip(hit: HitDetail): Promise<HTMLElement | string> { return (hit.sourceId === this._clipId ? \"View Clip\" : \"Modify View Clip\"); }\n  protected updateDecorationListener(_add: boolean): void { super.updateDecorationListener(undefined !== this._clipId); } // Decorator isn't just for resize controls...\n\n  public decorate(context: DecorateContext): void {\n    if (this._suspendDecorator)\n      return;\n\n    if (undefined === this._clipId || undefined === this._clip)\n      return;\n\n    const vp = context.viewport;\n    if (this._clipView !== vp)\n      return;\n\n    if (undefined !== this._clipShape) {\n      ViewClipTool.drawClipShape(context, this._clipShape, this._clipShapeExtents!, ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor), 3, this._clipId);\n    } else if (undefined !== this._clipPlanes) {\n      if (undefined !== this._clipPlanesLoops)\n        ViewClipTool.drawClipPlanesLoops(context, this._clipPlanesLoops, ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor), 3, false, ColorDef.from(0, 255, 255, 225).adjustForContrast(context.viewport.view.backgroundColor), this._clipId);\n      if (undefined !== this._clipPlanesLoopsNoncontributing)\n        ViewClipTool.drawClipPlanesLoops(context, this._clipPlanesLoopsNoncontributing, ColorDef.red.adjustForContrast(context.viewport.view.backgroundColor), 1, true);\n    }\n\n    if (!this._isActive)\n      return;\n\n    const outlineColor = ColorDef.from(0, 0, 0, 50).adjustForContrast(vp.view.backgroundColor);\n    const fillVisColor = ColorDef.from(150, 250, 200, 225).adjustForContrast(vp.view.backgroundColor);\n    const fillHidColor = fillVisColor.clone(); fillHidColor.setAlpha(200);\n    const fillSelColor = fillVisColor.invert(); fillSelColor.setAlpha(75);\n    const shapePts = EditManipulator.HandleUtils.getArrowShape(0.0, 0.15, 0.55, 1.0, 0.3, 0.5, 0.1);\n\n    for (let iFace = 0; iFace < this._controlIds.length; iFace++) {\n      const sizeInches = this._controls[iFace].sizeInches;\n      if (0.0 === sizeInches)\n        continue;\n\n      const anchorRay = ViewClipTool.getClipRayTransformed(this._controls[iFace].origin, this._controls[iFace].direction, undefined !== this._clipShape ? this._clipShape.transformFromClip : undefined);\n      const transform = EditManipulator.HandleUtils.getArrowTransform(vp, anchorRay.origin, anchorRay.direction, sizeInches);\n      if (undefined === transform)\n        continue;\n\n      const visPts: Point3d[] = []; for (const pt of shapePts) visPts.push(pt.clone()); // deep copy because we're using a builder transform w/addLineString...\n      const hidPts: Point3d[] = []; for (const pt of shapePts) hidPts.push(pt.clone());\n      const arrowVisBuilder = context.createGraphicBuilder(GraphicType.WorldOverlay, transform, this._controlIds[iFace]);\n      const arrowHidBuilder = context.createGraphicBuilder(GraphicType.WorldDecoration, transform);\n      const isSelected = this.iModel.selectionSet.has(this._controlIds[iFace]);\n\n      let outlineColorOvr = this._controls[iFace].outline;\n      if (undefined !== outlineColorOvr) {\n        outlineColorOvr = outlineColorOvr.adjustForContrast(vp.view.backgroundColor);\n        outlineColorOvr.setAlpha(outlineColor.getAlpha());\n      } else {\n        outlineColorOvr = outlineColor;\n      }\n\n      let fillVisColorOvr = this._controls[iFace].fill;\n      let fillHidColorOvr = fillHidColor;\n      let fillSelColorOvr = fillSelColor;\n      if (undefined !== fillVisColorOvr) {\n        fillVisColorOvr = fillVisColorOvr.adjustForContrast(vp.view.backgroundColor);\n        fillVisColorOvr.setAlpha(fillVisColor.getAlpha());\n        fillHidColorOvr = fillVisColorOvr.clone(); fillHidColorOvr.setAlpha(fillHidColor.getAlpha());\n        fillSelColorOvr = fillVisColorOvr.invert(); fillSelColorOvr.setAlpha(fillSelColor.getAlpha());\n      } else {\n        fillVisColorOvr = fillVisColor;\n      }\n\n      arrowVisBuilder.setSymbology(outlineColorOvr, outlineColorOvr, isSelected ? 4 : 2);\n      arrowVisBuilder.addLineString(visPts);\n      arrowVisBuilder.setBlankingFill(isSelected ? fillSelColorOvr : fillVisColorOvr);\n      arrowVisBuilder.addShape(visPts);\n      context.addDecorationFromBuilder(arrowVisBuilder);\n\n      arrowHidBuilder.setSymbology(fillHidColorOvr, fillHidColorOvr, 1);\n      arrowHidBuilder.addShape(hidPts);\n      context.addDecorationFromBuilder(arrowHidBuilder);\n    }\n  }\n\n  public static get(vp: Viewport): ViewClipDecoration | undefined {\n    if (undefined === ViewClipDecoration._decorator || vp !== ViewClipDecoration._decorator._clipView)\n      return undefined;\n    return ViewClipDecoration._decorator;\n  }\n\n  public static create(vp: Viewport, clipEventHandler?: ViewClipEventHandler): string | undefined {\n    if (undefined !== ViewClipDecoration._decorator)\n      ViewClipDecoration.clear();\n    if (!ViewClipTool.hasClip(vp))\n      return undefined;\n    ViewClipDecoration._decorator = new ViewClipDecoration(vp, clipEventHandler);\n    return ViewClipDecoration._decorator.clipId;\n  }\n\n  public static clear(): void {\n    if (undefined === ViewClipDecoration._decorator)\n      return;\n    ViewClipDecoration._decorator.stop();\n    ViewClipDecoration._decorator = undefined;\n  }\n\n  public static toggle(vp: Viewport, clipEventHandler?: ViewClipEventHandler): string | undefined {\n    let clipId: string | undefined;\n    if (undefined === ViewClipDecoration._decorator)\n      clipId = ViewClipDecoration.create(vp, clipEventHandler);\n    else\n      ViewClipDecoration.clear();\n    IModelApp.toolAdmin.startDefaultTool();\n    return clipId;\n  }\n}\n\n/** @alpha */\nexport enum ActiveClipStatus { None, Unsaved, Saved, Modified }\n\n/** @alpha */\nexport interface SavedClipEntry { id: GuidString; name?: string; shared: boolean; }\n\n/** @internal */\nexport interface SavedClipProps { clip: ClipVector; name?: string; }\n\n/** @internal */\nexport interface SavedClipCache { clip?: ClipVector; name?: string; shared: boolean; modified: boolean; }\n\n/** @alpha Support for saving clip information as user or project settings */\nexport class ViewClipSettingsProvider {\n  private _activeClips = new Map<number, GuidString>(); // Map of viewportId to saved clip id...\n  private _cachedClips = new Map<GuidString, SavedClipCache>(); // Map of clip id to clip data + status\n  public namespace = \"imodeljs-NamedClipVectors\";\n  public appSpecific = false;\n\n  constructor(protected _clipEventHandler?: ViewClipEventHandler) { }\n\n  protected async getRequestContext() { return AuthorizedFrontendRequestContext.create(); }\n  protected getProjectId(iModel: IModelConnection): string | undefined { return iModel.iModelToken.contextId; }\n  protected getiModelId(iModel: IModelConnection): string | undefined { return iModel.iModelToken.iModelId; }\n\n  /** @internal */\n  protected async getAllSettings(iModel: IModelConnection, shared: boolean): Promise<SettingsMapResult> {\n    const projectId = this.getProjectId(iModel);\n    const modelId = this.getiModelId(iModel);\n    if (undefined === projectId || undefined === modelId)\n      throw new IModelError(IModelStatus.MissingId, \"Required project id and model id are not specified\");\n    const requestContext = await this.getRequestContext();\n    if (shared)\n      return IModelApp.settings.getSharedSettingsByNamespace(requestContext, this.namespace, this.appSpecific, projectId, modelId);\n    return IModelApp.settings.getUserSettingsByNamespace(requestContext, this.namespace, this.appSpecific, projectId, modelId);\n  }\n\n  /** @internal */\n  protected async getSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsResult> {\n    const projectId = this.getProjectId(iModel);\n    const modelId = this.getiModelId(iModel);\n    if (undefined === projectId || undefined === modelId)\n      throw new IModelError(IModelStatus.MissingId, \"Required project id and model id are not specified\");\n    const requestContext = await this.getRequestContext();\n    if (shared)\n      return IModelApp.settings.getSharedSetting(requestContext, this.namespace, existingId, this.appSpecific, projectId, modelId);\n    return IModelApp.settings.getUserSetting(requestContext, this.namespace, existingId, this.appSpecific, projectId, modelId);\n  }\n\n  /** @internal */\n  protected async saveSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, settings: SavedClipProps): Promise<SettingsResult> {\n    const projectId = this.getProjectId(iModel);\n    const modelId = this.getiModelId(iModel);\n    if (undefined === projectId || undefined === modelId)\n      throw new IModelError(IModelStatus.MissingId, \"Required project id and model id are not specified\");\n    const requestContext = await this.getRequestContext();\n    if (shared)\n      return IModelApp.settings.saveSharedSetting(requestContext, settings, this.namespace, existingId, this.appSpecific, projectId, modelId);\n    return IModelApp.settings.saveUserSetting(requestContext, settings, this.namespace, existingId, this.appSpecific, projectId, modelId);\n  }\n\n  /** @internal */\n  protected async deleteSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsResult> {\n    const projectId = this.getProjectId(iModel);\n    const modelId = this.getiModelId(iModel);\n    if (undefined === projectId || undefined === modelId)\n      throw new IModelError(IModelStatus.MissingId, \"Required project id and model id are not specified\");\n    const requestContext = await this.getRequestContext();\n    if (shared)\n      return IModelApp.settings.deleteSharedSetting(requestContext, this.namespace, existingId, this.appSpecific, projectId, modelId);\n    return IModelApp.settings.deleteUserSetting(requestContext, this.namespace, existingId, this.appSpecific, projectId, modelId);\n  }\n\n  /** @internal */\n  protected async getCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SavedClipCache> {\n    const existing = this._cachedClips.get(existingId);\n    if (undefined !== existing && shared === existing.shared)\n      return existing;\n    const cacheEntry: SavedClipCache = (undefined === existing ? { shared, modified: false } : existing);\n    this._cachedClips.set(existingId, cacheEntry); // Insert invalid entry to avoid repeated failures...\n    try {\n      const result = await this.getSetting(iModel, shared, existingId);\n      if (SettingsStatus.Success === result.status) {\n        cacheEntry.clip = ClipVector.fromJSON(result.setting.clip);\n        cacheEntry.name = result.setting.name;\n        cacheEntry.shared = shared;\n        return cacheEntry;\n      }\n      return cacheEntry;\n    } catch (error) {\n      return cacheEntry;\n    }\n  }\n\n  /** @internal */\n  protected async newCachedSetting(iModel: IModelConnection, shared: boolean, newId: GuidString, settings: SavedClipProps): Promise<SettingsStatus> {\n    try {\n      const result = await this.saveSetting(iModel, shared, newId, settings);\n      if (SettingsStatus.Success === result.status)\n        this._cachedClips.set(newId, { clip: settings.clip, name: settings.name, shared, modified: false });\n      return result.status;\n    } catch (error) {\n      return SettingsStatus.AuthorizationError;\n    }\n  }\n\n  /** @internal */\n  protected async updateCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, settings: SavedClipProps): Promise<SettingsStatus> {\n    const existing = await this.getCachedSetting(iModel, shared, existingId);\n    if (undefined === existing.clip)\n      return SettingsStatus.SettingNotFound;\n    try {\n      if (undefined === settings.name)\n        settings.name = existing.name; // Preserve name when called to update clip...\n      const result = await this.saveSetting(iModel, existing.shared, existingId, settings);\n      if (SettingsStatus.Success === result.status)\n        this._cachedClips.set(existingId, { clip: settings.clip, name: settings.name, shared: existing.shared, modified: false });\n      return result.status;\n    } catch (error) {\n      return SettingsStatus.AuthorizationError;\n    }\n  }\n\n  /** @internal */\n  protected async deleteCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsStatus> {\n    try {\n      const result = await this.deleteSetting(iModel, shared, existingId);\n      if (SettingsStatus.Success === result.status)\n        this._cachedClips.delete(existingId);\n      return result.status;\n    } catch (error) {\n      return SettingsStatus.AuthorizationError;\n    }\n  }\n\n  /** @internal */\n  protected async renameCachedSetting(iModel: IModelConnection, shared: boolean, existingId: GuidString, name: string): Promise<SettingsStatus> {\n    const existing = await this.getCachedSetting(iModel, shared, existingId);\n    if (undefined === existing.clip)\n      return SettingsStatus.SettingNotFound;\n    else if (name === existing.name)\n      return SettingsStatus.Success;\n    try {\n      const result = await this.saveSetting(iModel, existing.shared, existingId, { clip: existing.clip, name });\n      if (SettingsStatus.Success === result.status)\n        this._cachedClips.set(existingId, { clip: existing.clip, name, shared: existing.shared, modified: false });\n      return result.status;\n    } catch (error) {\n      return SettingsStatus.AuthorizationError;\n    }\n  }\n\n  /** @internal */\n  protected async shareCachedSetting(iModel: IModelConnection, existingId: GuidString, newShared: boolean): Promise<SettingsStatus> {\n    const existing = await this.getCachedSetting(iModel, !newShared, existingId);\n    if (undefined === existing.clip)\n      return SettingsStatus.SettingNotFound;\n    else if (existing.shared === newShared)\n      return SettingsStatus.Success;\n    try {\n      const status = await this.newCachedSetting(iModel, newShared, existingId, { clip: existing.clip, name: existing.name });\n      if (SettingsStatus.Success === status)\n        await this.deleteSetting(iModel, !newShared, existingId);\n      return status;\n    } catch (error) {\n      return SettingsStatus.AuthorizationError;\n    }\n  }\n\n  /** @internal */\n  protected validateActiveClipId(viewport: Viewport): void {\n    const activeId = this.getActiveClipId(viewport);\n    if (undefined !== activeId) {\n      const current = viewport.view.getViewClip();\n      const active = this._cachedClips.get(activeId);\n      if (undefined === current || undefined === active || undefined === active.clip || !ViewClipTool.areClipsEqual(current, active.clip))\n        return this.clearActiveClipId(viewport);\n    }\n    this.purgeActiveClipIdCache();\n  }\n\n  /** @internal */\n  protected purgeActiveClipIdCache(): void {\n    if (this._cachedClips.size <= this._activeClips.size)\n      return;\n    const usedCache = new Map<GuidString, SavedClipCache>(); // Purge cache entries not currently being referenced by a view...\n    this._activeClips.forEach((usedId) => { const usedEntry = this._cachedClips.get(usedId); if (undefined !== usedEntry) usedCache.set(usedId, usedEntry); });\n    this._cachedClips = usedCache;\n  }\n\n  public getActiveClipId(viewport: Viewport): GuidString | undefined {\n    return this._activeClips.get(viewport.viewportId);\n  }\n\n  /** @internal */\n  public setActiveClipId(viewport: Viewport, existingId: GuidString): void {\n    this._activeClips.set(viewport.viewportId, existingId);\n    this.purgeActiveClipIdCache();\n  }\n\n  /** @internal */\n  public clearActiveClipId(viewport: Viewport): void {\n    this._activeClips.delete(viewport.viewportId);\n    this.purgeActiveClipIdCache();\n  }\n\n  /** @internal */\n  public clearActiveClipIdAllViews(): void {\n    this._activeClips.clear();\n    this._cachedClips.clear();\n  }\n\n  /** @internal */\n  public modifiedActiveClip(viewport: Viewport): boolean {\n    const activeId = this.getActiveClipId(viewport);\n    if (undefined === activeId)\n      return false;\n    const clip = viewport.view.getViewClip();\n    if (undefined === clip)\n      return false; // Expected onClearClip...\n    const existing = this._cachedClips.get(activeId);\n    if (undefined === existing)\n      return false;\n    existing.modified = true; // Mark cache as changed from saved state. User must choose to update, create new, or discard the changes...\n    existing.clip = clip;\n    return true;\n  }\n\n  public async getSettings(settings: SavedClipEntry[], iModel: IModelConnection, shared?: boolean): Promise<SettingsStatus> {\n    let userStatus = SettingsStatus.Success;\n    let sharedStatus = SettingsStatus.Success;\n    if (undefined === shared || !shared) {\n      try {\n        const userResult = await this.getAllSettings(iModel, false);\n        if (SettingsStatus.Success === userResult.status && undefined !== userResult.settingsMap) {\n          for (const [key, value] of userResult.settingsMap) {\n            settings.push({ id: key, name: value.name, shared: false });\n          }\n        }\n        userStatus = userResult.status;\n      } catch (error) {\n        userStatus = SettingsStatus.AuthorizationError;\n      }\n    }\n    if (undefined === shared || shared) {\n      try {\n        const sharedResult = await this.getAllSettings(iModel, true);\n        if (SettingsStatus.Success === sharedResult.status && undefined !== sharedResult.settingsMap) {\n          for (const [key, value] of sharedResult.settingsMap) {\n            settings.push({ id: key, name: value.name, shared: true });\n          }\n        }\n        sharedStatus = sharedResult.status;\n      } catch (error) {\n        sharedStatus = SettingsStatus.AuthorizationError;\n      }\n    }\n    if (userStatus === sharedStatus)\n      return userStatus;\n    else if (SettingsStatus.SettingNotFound === userStatus)\n      return sharedStatus;\n    else if (SettingsStatus.SettingNotFound === sharedStatus)\n      return userStatus;\n    else if (SettingsStatus.Success === userStatus)\n      return sharedStatus;\n    else if (SettingsStatus.Success === sharedStatus)\n      return userStatus;\n    return userStatus;\n  }\n\n  public async getClip(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<ClipVector | undefined> {\n    const existing = await this.getCachedSetting(iModel, shared, existingId);\n    if (undefined === existing.clip || !existing.clip.isValid)\n      return undefined;\n    return existing.clip;\n  }\n\n  public async newClip(iModel: IModelConnection, shared: boolean, clip: ClipVector, name?: string): Promise<GuidString | undefined> {\n    const newId = Guid.createValue();\n    if (SettingsStatus.Success === await this.newCachedSetting(iModel, shared, newId, { clip, name }))\n      return newId;\n    return undefined;\n  }\n\n  public async copyClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, copyShared: boolean, name?: string): Promise<GuidString | undefined> {\n    const existingClip = await this.getClip(iModel, shared, existingId);\n    if (undefined === existingClip)\n      return undefined;\n    return this.newClip(iModel, copyShared, existingClip, name);\n  }\n\n  public async replaceClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, clip: ClipVector): Promise<SettingsStatus> {\n    return this.updateCachedSetting(iModel, shared, existingId, { clip }); // NOTE: Current name will be preserved when passing undefined...\n  }\n\n  public async deleteClip(iModel: IModelConnection, shared: boolean, existingId: GuidString): Promise<SettingsStatus> {\n    return this.deleteCachedSetting(iModel, shared, existingId);\n  }\n\n  public async renameClip(iModel: IModelConnection, shared: boolean, existingId: GuidString, name: string): Promise<SettingsStatus> {\n    return this.renameCachedSetting(iModel, shared, existingId, name);\n  }\n\n  public async shareClip(iModel: IModelConnection, existingId: GuidString, newShare: boolean): Promise<SettingsStatus> {\n    return this.shareCachedSetting(iModel, existingId, newShare);\n  }\n\n  public async saveActiveClip(viewport: Viewport, shared: boolean, name?: string): Promise<GuidString | undefined> {\n    const clip = viewport.view.getViewClip();\n    if (undefined === clip)\n      return undefined;\n    const activeId = this.getActiveClipId(viewport);\n    if (undefined === activeId) {\n      const newId = await this.newClip(viewport.iModel, shared, clip, name);\n      if (undefined !== newId)\n        this.setActiveClipId(viewport, newId);\n      return newId;\n    } else {\n      const active = this._cachedClips.get(activeId);\n      if (undefined === active || !active.modified)\n        return activeId;\n      if (active.shared !== shared)\n        return undefined;\n      const status = await this.replaceClip(viewport.iModel, active.shared, activeId, clip);\n      return (SettingsStatus.Success === status ? activeId : undefined);\n    }\n  }\n\n  public async activateSavedClip(viewport: Viewport, id: GuidString, shared: boolean, interactive: boolean = true): Promise<SettingsStatus> {\n    const activeId = this.getActiveClipId(viewport);\n    if (id === activeId)\n      return SettingsStatus.Success; // Already active...\n    let existingClip = await this.getClip(viewport.iModel, shared, id);\n    if (undefined === existingClip) {\n      // NOTE: For non-interactive call to apply a saved view, shared flag should be based on saved view's setting...\n      //       A shared saved view should never reference a user's saved clip.\n      //       A user's saved view can reference a saved clip (or a user's saved clip that was later changed to shared).\n      //       The saved view is not required to store the shared flag for the save clip.\n      if (interactive || shared)\n        return SettingsStatus.SettingNotFound;\n      existingClip = await this.getClip(viewport.iModel, true, id);\n      if (undefined === existingClip)\n        return SettingsStatus.SettingNotFound;\n    }\n    if (!ViewClipTool.setViewClip(viewport, existingClip))\n      return SettingsStatus.UnknownError;\n    this.setActiveClipId(viewport, id);\n    if (undefined !== this._clipEventHandler)\n      this._clipEventHandler.onActivateClip(viewport, interactive);\n    return SettingsStatus.Success;\n  }\n\n  public async activateSavedClipPlanes(viewport: Viewport, ids: GuidString[], shared: boolean[]): Promise<SettingsStatus> {\n    if (ids.length < 2 || ids.length !== shared.length)\n      return SettingsStatus.UnknownError;\n    const planeSet = ConvexClipPlaneSet.createEmpty();\n    for (let iPlane = 0; iPlane < ids.length; iPlane++) {\n      const existingClip = await this.getClip(viewport.iModel, shared[iPlane], ids[iPlane]);\n      if (undefined === existingClip)\n        return SettingsStatus.SettingNotFound;\n      const plane = ViewClipTool.isSingleClipPlane(existingClip);\n      if (undefined === plane)\n        return SettingsStatus.UnknownError;\n      planeSet.addPlaneToConvexSet(plane);\n    }\n    if (!ViewClipTool.doClipToConvexClipPlaneSet(viewport, planeSet))\n      return SettingsStatus.UnknownError;\n    this.clearActiveClipId(viewport);\n    if (undefined !== this._clipEventHandler)\n      this._clipEventHandler.onActivateClip(viewport, true);\n    return SettingsStatus.Success;\n  }\n\n  public async areSavedClipPlanes(iModel: IModelConnection, ids: GuidString[], shared: boolean[]): Promise<boolean> {\n    if (ids.length !== shared.length)\n      return false;\n    for (let iPlane = 0; iPlane < ids.length; iPlane++) {\n      const existingClip = await this.getClip(iModel, shared[iPlane], ids[iPlane]);\n      if (undefined === existingClip)\n        return false;\n      const plane = ViewClipTool.isSingleClipPlane(existingClip);\n      if (undefined === plane)\n        return false;\n    }\n    return true;\n  }\n\n  public getActiveClipStatus(viewport: Viewport): ActiveClipStatus {\n    this.validateActiveClipId(viewport);\n    if (undefined === viewport.view.getViewClip())\n      return ActiveClipStatus.None;\n    const activeId = this.getActiveClipId(viewport);\n    if (undefined === activeId)\n      return ActiveClipStatus.Unsaved;\n    const active = this._cachedClips.get(activeId);\n    if (undefined === active)\n      return ActiveClipStatus.Unsaved;\n    return (active.modified ? ActiveClipStatus.Modified : ActiveClipStatus.Saved);\n  }\n}\n\n/** @alpha Event types for ViewClipDecorationProvider.onActiveClipChanged */\nexport enum ClipEventType { New, NewPlane, Modify, Clear, Activate }\n\n/** @alpha An implementation of ViewClipEventHandler that responds to new clips by presenting clip modification handles */\nexport class ViewClipDecorationProvider implements ViewClipEventHandler {\n  private static _provider?: ViewClipDecorationProvider;\n  protected _settings?: ViewClipSettingsProvider;\n  public selectDecorationOnCreate = true;\n  public clearDecorationOnDeselect = true;\n\n  /** Called when the active clip for a view is changed */\n  public readonly onActiveClipChanged = new BeEvent<(viewport: Viewport, eventType: ClipEventType, provider: ViewClipDecorationProvider) => void>();\n\n  /** Called on a right click over the clip geometry or clip modify handle. ViewClipDecoration provides methods for the following possible menu actions:\n   * For ClipPlanes (undefined !== clipPlaneSet): Flip (doClipPlaneNegate), Clear (doClipPlaneClear), and Orient View (doClipPlaneOrientView)\n   * For ClipShapes (undefined === clipPlaneSet): Orient View (doClipPlaneOrientView) and input fields to set world zLow/zHigh (doClipShapeSetZExtents provided isClipShapeAlignedWithWorldUp returns true)\n   */\n  public readonly onActiveClipRightClick = new BeEvent<(hit: HitDetail, ev: BeButtonEvent, provider: ViewClipDecorationProvider) => void>();\n\n  /** Call to check if named clip settings have been enabled. Can use before calling settings.getActiveClipId to avoid creating settings */\n  public get hasSettings(): boolean { return (undefined !== this._settings); }\n\n  /** Call to allow saving the active clip as a setting or to set the active clip from a previously saved setting */\n  public get settings(): ViewClipSettingsProvider { if (undefined === this._settings) this._settings = new ViewClipSettingsProvider(this); return this._settings; }\n\n  public selectOnCreate(): boolean { return this.selectDecorationOnCreate; }\n  public clearOnDeselect(): boolean { return this.clearDecorationOnDeselect; }\n\n  public onNewClip(viewport: Viewport): void {\n    ViewClipDecoration.create(viewport, this);\n    if (undefined !== this._settings)\n      this._settings.clearActiveClipId(viewport);\n    this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.New, this);\n  }\n\n  public onNewClipPlane(viewport: Viewport): void {\n    ViewClipDecoration.create(viewport, this);\n    if (undefined !== this._settings)\n      this._settings.clearActiveClipId(viewport);\n    this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.NewPlane, this);\n  }\n\n  public onModifyClip(viewport: Viewport): void {\n    if (undefined !== this._settings)\n      this._settings.modifiedActiveClip(viewport);\n    this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.Modify, this);\n  }\n\n  public onClearClip(viewport: Viewport): void {\n    ViewClipDecoration.clear();\n    if (undefined !== this._settings)\n      this._settings.clearActiveClipId(viewport);\n    this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.Clear, this);\n  }\n\n  public onActivateClip(viewport: Viewport, interactive: boolean): void {\n    if (interactive)\n      ViewClipDecoration.create(viewport, this);\n    else\n      ViewClipDecoration.clear();\n    this.onActiveClipChanged.raiseEvent(viewport, ClipEventType.Activate, this);\n  }\n\n  public onRightClick(hit: HitDetail, ev: BeButtonEvent): boolean {\n    const decoration = (undefined !== ev.viewport ? ViewClipDecoration.get(ev.viewport) : undefined);\n    if (undefined === decoration)\n      return false;\n    if (0 === this.onActiveClipRightClick.numberOfListeners)\n      return decoration.doClipPlaneNegate(decoration.getControlIndex(hit.sourceId));\n    this.onActiveClipRightClick.raiseEvent(hit, ev, this);\n    return true;\n  }\n\n  public showDecoration(vp: Viewport): void { ViewClipDecoration.create(vp, this); }\n  public hideDecoration(): void { ViewClipDecoration.clear(); }\n  public toggleDecoration(vp: Viewport): void { ViewClipDecoration.toggle(vp, this); }\n\n  public static create(): ViewClipDecorationProvider {\n    if (undefined === ViewClipDecorationProvider._provider) {\n      ViewClipDecoration.clear();\n      ViewClipDecorationProvider._provider = new ViewClipDecorationProvider();\n    }\n    return ViewClipDecorationProvider._provider;\n  }\n\n  public static clear(): void {\n    if (undefined === ViewClipDecorationProvider._provider)\n      return;\n    ViewClipDecoration.clear();\n    ViewClipDecorationProvider._provider = undefined;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { BeButtonEvent, InputCollector, BeButton, EventHandled, BeTouchEvent, InputSource, Tool, CoordinateLockOverrides } from \"./Tool\";\nimport { DecorateContext } from \"../ViewContext\";\nimport { IModelApp } from \"../IModelApp\";\nimport { ManipulatorToolEvent } from \"./ToolAdmin\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { SelectionSetEvent } from \"../SelectionSet\";\nimport { HitDetail } from \"../HitDetail\";\nimport { Viewport } from \"../Viewport\";\nimport { Point3d, Vector3d, Transform, Matrix3d, AxisOrder, Geometry, Ray3d, Plane3dByOriginAndUnitNormal } from \"@bentley/geometry-core\";\n\n/** A manipulator maintains a set of controls used to modify element(s) or pickable decorations.\n * Interactive modification is handled by installing an InputCollector tool.\n * @alpha\n */\nexport namespace EditManipulator {\n  export enum EventType { Synch, Cancel, Accept }\n\n  export abstract class HandleTool extends InputCollector {\n    public static toolId = \"Select.Manipulator\";\n    public static hidden = true;\n    public constructor(public manipulator: HandleProvider) { super(); }\n\n    /** Setup tool for press, hold, drag or click+click modification.\n     * By default a geometry manipulator (ex. move linestring vertices) should honor all locks and support AccuSnap.\n     * @note We set this.receivedDownEvent to get up events for this tool instance when it's installed from a down event like onModelStartDrag.\n     */\n    protected init(): void {\n      this.receivedDownEvent = true;\n      this.initLocateElements(false, true, undefined, CoordinateLockOverrides.None); // InputCollector inherits state of suspended primitive, set everything...\n    }\n\n    protected cancel(_ev: BeButtonEvent): boolean { return true; }\n    protected abstract accept(_ev: BeButtonEvent): boolean;\n\n    public onPostInstall(): void { super.onPostInstall(); this.init(); }\n    public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> { if (!this.accept(ev)) return EventHandled.No; this.exitTool(); this.manipulator.onManipulatorEvent(EventType.Accept); return EventHandled.Yes; }\n    public async onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled> { if (!this.cancel(ev)) return EventHandled.No; this.exitTool(); this.manipulator.onManipulatorEvent(EventType.Cancel); return EventHandled.Yes; }\n    public async onTouchMove(ev: BeTouchEvent): Promise<void> { return IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }\n    public async onTouchComplete(ev: BeTouchEvent): Promise<void> { return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }\n    public async onTouchCancel(ev: BeTouchEvent): Promise<void> { return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, BeButton.Reset); }\n  }\n\n  export abstract class HandleProvider {\n    protected _isActive = false;\n    protected _removeManipulatorToolListener?: () => void;\n    protected _removeSelectionListener?: () => void;\n    protected _removeDecorationListener?: () => void;\n\n    public constructor(public iModel: IModelConnection) { this._removeManipulatorToolListener = IModelApp.toolAdmin.manipulatorToolEvent.addListener(this.onManipulatorToolEvent, this); }\n\n    protected stop(): void {\n      if (this._removeSelectionListener) {\n        this._removeSelectionListener();\n        this._removeSelectionListener = undefined;\n      }\n      if (this._removeManipulatorToolListener) {\n        this._removeManipulatorToolListener();\n        this._removeManipulatorToolListener = undefined;\n      }\n      this.clearControls();\n    }\n\n    public onManipulatorToolEvent(_tool: Tool, event: ManipulatorToolEvent): void {\n      switch (event) {\n        case ManipulatorToolEvent.Start: {\n          if (this._removeSelectionListener)\n            break;\n          this._removeSelectionListener = this.iModel.selectionSet.onChanged.addListener(this.onSelectionChanged, this);\n          if (this.iModel.selectionSet.isActive)\n            this.onManipulatorEvent(EventType.Synch); // Give opportunity to add controls when tool is started with an existing selection...\n          break;\n        }\n        case ManipulatorToolEvent.Stop: {\n          if (!this._removeSelectionListener)\n            break;\n          this._removeSelectionListener();\n          this._removeSelectionListener = undefined;\n          this.clearControls();\n        }\n      }\n    }\n\n    public onSelectionChanged(ev: SelectionSetEvent): void {\n      if (this.iModel === ev.set.iModel)\n        this.onManipulatorEvent(EventType.Synch);\n    }\n\n    protected updateDecorationListener(add: boolean): void {\n      if (this._removeDecorationListener) {\n        if (!add) {\n          this._removeDecorationListener();\n          this._removeDecorationListener = undefined;\n        }\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n      } else if (add) {\n        if (!this._removeDecorationListener)\n          this._removeDecorationListener = IModelApp.viewManager.addDecorator(this);\n        IModelApp.viewManager.invalidateDecorationsAllViews();\n      }\n    }\n\n    public decorate(_context: DecorateContext): void { }\n\n    /** Provider is responsible for checking if modification by controls is valid.\n     * May still wish to present controls for \"transient\" geometry in non-read/write applications, etc.\n     */\n    protected abstract async createControls(): Promise<boolean>;\n\n    protected async updateControls(): Promise<void> {\n      const created = await this.createControls();\n      if (this._isActive && !created)\n        this.clearControls();\n      else\n        this.updateDecorationListener(this._isActive = created);\n    }\n\n    protected clearControls(): void {\n      this.updateDecorationListener(this._isActive = false);\n    }\n\n    /** run tool to handle interactive drag/click modification. */\n    protected abstract modifyControls(_hit: HitDetail, _ev: BeButtonEvent): boolean;\n\n    public onManipulatorEvent(_eventType: EventType): void { this.updateControls(); } // tslint:disable-line:no-floating-promises\n    protected async onDoubleClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n    protected async onRightClick(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n    protected async onTouchTap(_hit: HitDetail, _ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.Yes; }\n\n    public async onDecorationButtonEvent(hit: HitDetail, ev: BeButtonEvent): Promise<EventHandled> {\n      if (!this._isActive)\n        return EventHandled.No;\n\n      if (ev.isDoubleClick)\n        return this.onDoubleClick(hit, ev);\n\n      if (BeButton.Reset === ev.button && !ev.isDown && !ev.isDragging)\n        return this.onRightClick(hit, ev);\n\n      if (BeButton.Data !== ev.button)\n        return EventHandled.No;\n\n      if (ev.isControlKey)\n        return EventHandled.No; // Support ctrl+click to select multiple controls (ex. linestring vertices)...\n\n      if (InputSource.Touch === ev.inputSource && !ev.isDragging)\n        return this.onTouchTap(hit, ev); // Default is to select controls on touch drag only, ignore tap on control...\n\n      if (ev.isDown && !ev.isDragging)\n        return EventHandled.No; // Select controls on up event or down event only after drag started...\n\n      if (!this.modifyControls(hit, ev))\n        return EventHandled.No;\n\n      // In case InputCollector was installed for handle modification, don't wait for motion to show dynamic frame adjusted for AccuDraw hints...\n      IModelApp.accuDraw.refreshDecorationsAndDynamics();\n\n      return EventHandled.Yes;\n    }\n  }\n\n  export class HandleUtils {\n    public static getBoresite(origin: Point3d, vp: Viewport, checkAccuDraw: boolean = false, checkACS: boolean = false): Ray3d {\n      if (checkAccuDraw && IModelApp.accuDraw.isActive)\n        return Ray3d.create(origin, IModelApp.accuDraw.getRotation().getRow(2).negate());\n\n      if (checkACS && vp.isContextRotationRequired)\n        return Ray3d.create(origin, vp.getAuxCoordRotation().getRow(2).negate());\n\n      const eyePoint = vp.worldToViewMap.transform1.columnZ();\n      const direction = Vector3d.createFrom(eyePoint);\n      const aa = Geometry.conditionalDivideFraction(1, eyePoint.w);\n      if (aa !== undefined) {\n        const xyzEye = direction.scale(aa);\n        direction.setFrom(origin.vectorTo(xyzEye));\n      }\n      direction.scaleToLength(-1.0, direction);\n      return Ray3d.create(origin, direction);\n    }\n\n    public static projectPointToPlaneInView(spacePt: Point3d, planePt: Point3d, planeNormal: Vector3d, vp: Viewport, checkAccuDraw: boolean = false, checkACS: boolean = false): Point3d | undefined {\n      const plane = Plane3dByOriginAndUnitNormal.create(planePt, planeNormal);\n      if (undefined === plane)\n        return undefined;\n      const rayToEye = EditManipulator.HandleUtils.getBoresite(spacePt, vp, checkAccuDraw, checkACS);\n      const projectedPt = Point3d.createZero();\n      if (undefined === rayToEye.intersectionWithPlane(plane, projectedPt))\n        return undefined;\n      return projectedPt;\n    }\n\n    public static projectPointToLineInView(spacePt: Point3d, linePt: Point3d, lineDirection: Vector3d, vp: Viewport, checkAccuDraw: boolean = false, checkACS: boolean = false): Point3d | undefined {\n      const lineRay = Ray3d.create(linePt, lineDirection);\n      const rayToEye = EditManipulator.HandleUtils.getBoresite(spacePt, vp, checkAccuDraw, checkACS);\n      if (rayToEye.direction.isParallelTo(lineRay.direction, true))\n        return lineRay.projectPointToRay(spacePt);\n      const matrix = Matrix3d.createRigidFromColumns(lineRay.direction, rayToEye.direction, AxisOrder.XZY);\n      if (undefined === matrix)\n        return undefined;\n      const plane = Plane3dByOriginAndUnitNormal.create(linePt, matrix.columnZ());\n      if (undefined === plane)\n        return undefined;\n      const projectedPt = Point3d.createZero();\n      if (undefined === rayToEye.intersectionWithPlane(plane, projectedPt))\n        return undefined;\n      return lineRay.projectPointToRay(projectedPt);\n    }\n\n    /** Get a transform to orient arrow shape to view direction. If arrow direction is close to perpendicular to view direction will return undefined. */\n    public static getArrowTransform(vp: Viewport, base: Point3d, direction: Vector3d, sizeInches: number): Transform | undefined {\n      const boresite = EditManipulator.HandleUtils.getBoresite(base, vp);\n      if (Math.abs(direction.dotProduct(boresite.direction)) >= 0.9)\n        return undefined;\n\n      const pixelSize = vp.pixelsFromInches(sizeInches);\n      const scale = vp.viewFrustum.getPixelSizeAtPoint(base) * pixelSize;\n      const matrix = Matrix3d.createRigidFromColumns(direction, boresite.direction, AxisOrder.XZY);\n      if (undefined === matrix)\n        return undefined;\n\n      matrix.scaleColumnsInPlace(scale, scale, scale);\n      return Transform.createRefs(base.clone(), matrix);\n    }\n\n    /** Return array of shape points representing a unit arrow in xy plane pointing in positive x direction. */\n    public static getArrowShape(baseStart: number = 0.0, baseWidth: number = 0.15, tipStart: number = 0.55, tipEnd: number = 1.0, tipWidth: number = 0.3, flangeStart: number = tipStart, flangeWidth: number = baseWidth): Point3d[] {\n      const shapePts: Point3d[] = [];\n      shapePts[0] = Point3d.create(tipEnd, 0.0);\n      shapePts[1] = Point3d.create(flangeStart, tipWidth);\n      shapePts[2] = Point3d.create(tipStart, flangeWidth);\n      shapePts[3] = Point3d.create(baseStart, baseWidth);\n      shapePts[4] = Point3d.create(baseStart, -baseWidth);\n      shapePts[5] = Point3d.create(tipStart, -flangeWidth);\n      shapePts[6] = Point3d.create(flangeStart, -tipWidth);\n      shapePts[7] = shapePts[0].clone();\n      return shapePts;\n    }\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { Id64String, Id64, Id64Arg } from \"@bentley/bentleyjs-core\";\nimport { IModelConnection } from \"../IModelConnection\";\n\n/** The requested source for the elements to modify.\n * @internal Do we really want to propagate the *Elem* abbreviation?\n */\nexport enum ElemSource {\n  /** Populate ElementAgenda from a locate */\n  Pick,\n  /**  Populate ElementAgenda from active fence */\n  Fence,\n  /**  Populate ElementAgenda from active selection set */\n  SelectionSet,\n}\n\n/** The method that will be used to update the tool's ElementAgenda.\n * @internal Do we really want to propagate the *Elem* abbreviation?\n */\nexport enum ElemMethod {\n  /** Entries will be added to ElementAgenda */\n  Add,\n  /** Entries currently in the ElementAgenda are removed, entries not currently in the ElementAgenda are added. */\n  Invert,\n}\n\n/** Should the active fence be used, required, or ignored as a possible ElemSource.\n * @internal\n */\nexport enum UsesFence {\n  /** Active Fence is allowed as ElemSource */\n  Check,\n  /** Active Fence is required as ElemSource */\n  Required,\n  /** Active Fence is not supported as ElemSource */\n  None,\n}\n\n/** Should the active selection set be used, required, or ignored as a possible ElemSource.\n * @internal\n */\nexport enum UsesSelection {\n  /** Active Selection Set is allowed as ElemSource */\n  Check,\n  /** Active Selection Set is required as ElemSource */\n  Required,\n  /** Active Selection Set is not supported as ElemSource */\n  None,\n}\n\n/** Should ElemSource::Pick allow a drag select to identify elements.\n * @internal\n */\nexport enum UsesDragSelect {\n  /** Drag selection using shape inside/overlap */\n  Box,\n  /** Drag selection using crossing line */\n  Line,\n  /** Tool does not support drag selection for ElemSource.Pick */\n  None,\n}\n\n/** Helps determine the action ModifyAgenda will take on the agenda elements after calling doFenceClip.\n * @internal\n */\nexport enum ClipResult {\n  /** Tool does not support fence clip */\n  NotSupported,\n  /** Valid entries in ElementAgenda are new elements, no elemRef but correct modelRef. */\n  NewElements,\n  /** Valid entries in ElementAgenda reference original elemRef and modelRef. */\n  OriginalElements,\n}\n\n/** ElemSource specific failures.\n * @internal\n */\nexport enum ErrorNums {\n  /** No fence is currently active */\n  NoFence,\n  /** No acceptable element(s) inside fence */\n  NoFenceElems,\n  /** No acceptable element(s) outside fence */\n  NoFenceElemsOutside,\n  /** No acceptable element(s) in selection set */\n  NoSSElems,\n  /** Located element rejected by tool filters */\n  NotSupportedElmType,\n}\n\n/** @internal */\nexport enum HilitedState {\n  /**  this agenda is in an indeterminate state wrt hilite */\n  Unknown = 0,\n  /**  all of the entries in this agenda were hilited by a call to ElementAgenda.hilite */\n  Yes = 1,\n  /**  all of the entries in this agenda were un-hilited by a call to ElementAgenda.clearHilite */\n  No = 2,\n}\n\n/** @internal */\nexport enum ModifyElementSource {\n  /** The source for the element is unknown - not caused by a modification command. */\n  Unknown = 0,\n  /** The element is selected by the user. */\n  Selected = 1,\n  /** The element is processed because it is in the selection set. */\n  SelectionSet = 2,\n  /** The element is processed because it is passes the fence criteria. */\n  Fence = 3,\n  /** The element is processed because it belongs to the group of the selected element (for _FilterAgendaEntries only) */\n  Group = 4,\n  /** The element is selected by the user by drag selection or multi-selection using ctrl. */\n  DragSelect = 5,\n}\n\n/** @internal */\nexport interface GroupMark {\n  start: number;\n  source: ModifyElementSource;\n}\n\n/** @internal */\nexport class ElementAgenda {\n  public readonly elements: string[] = [];\n  public readonly groupMarks: GroupMark[] = [];\n  /** Whether elements are flagged as hilited when added to the agenda. */\n  public hiliteOnAdd = true;\n  public hilitedState = HilitedState.Unknown;\n  public constructor(public iModel: IModelConnection) { }\n\n  /**\n   * Get the source for this ElementAgenda, if applicable. The \"source\" is merely an indication of what the collection of elements\n   * in this agenda means. When the source is ModifyElementSource.SelectionSet, the attempt will be made to keep the Selection\n   * Set current with changes to the agenda.\n   */\n  public getSource() { return this.groupMarks.length === 0 ? ModifyElementSource.Unknown : this.groupMarks[this.groupMarks.length - 1].source; }\n\n  /** Set the source for this ElementAgenda. */\n  public setSource(val: ModifyElementSource) { if (this.groupMarks.length > 0) this.groupMarks[this.groupMarks.length - 1].source = val; }\n\n  public get isEmpty() { return this.length === 0; }\n  public get count() { return this.length; }\n  public get length() { return this.elements.length; }\n\n  /** Calls ClearHilite and empties this ElementAgenda. */\n  public clear() { this.clearHilite(); this.elements.length = 0; this.groupMarks.length = 0; }\n\n  /** clear hilite on any currently hilited entries */\n  private clearHilite() {\n    if (HilitedState.No === this.hilitedState)\n      return;\n\n    this.setEntriesHiliteState(false); // make sure all entries have their hilite flag off\n    this.hilitedState = HilitedState.No;\n  }\n\n  private setEntriesHiliteState(onOff: boolean, groupStart = 0, groupEnd = 0) {\n    const group = (0 === groupEnd) ? this.elements : this.elements.filter((_id, index) => index >= groupStart && index < groupEnd);\n    this.iModel.hilited.setHilite(group, onOff);\n  }\n\n  /** Calls ClearHilite and removes the last group of elements added to this ElementAgenda. */\n  public popGroup() {\n    if (this.groupMarks.length <= 1) {\n      this.clear();\n      return;\n    }\n    const group = this.groupMarks.pop()!;\n    if (HilitedState.No !== this.hilitedState)\n      this.setEntriesHiliteState(false, group.start, this.length); // make sure removed entries aren't left hilited...\n    this.elements.splice(group.start);\n  }\n\n  /** Mark all entries in this agenda as being hilited. */\n  public hilite() {\n    if (HilitedState.Yes === this.hilitedState)\n      return;\n\n    this.setEntriesHiliteState(this.hiliteOnAdd); // make sure all entries have their hilite flag on.\n    this.hilitedState = HilitedState.Yes;\n  }\n\n  public has(id: string) { return this.elements.some((entry) => id === entry); }\n\n  /** Return true if elementId is already in this ElementAgenda. */\n  public find(id: Id64String) { return this.has(id); }\n\n  /** Add elements to this ElementAgenda. */\n  public add(arg: Id64Arg) {\n    const groupStart = this.length;\n    Id64.forEach(arg, (id) => {\n      if (!this.has(id))\n        this.elements.push(id);\n    });\n\n    if (groupStart === this.length)\n      return false;\n\n    this.groupMarks.push({ start: groupStart, source: ModifyElementSource.Unknown });\n    if (HilitedState.No !== this.hilitedState)\n      this.setEntriesHiliteState(this.hiliteOnAdd, groupStart, this.length);\n\n    return true;\n  }\n\n  private removeOne(id: string) {\n    let pos = -1;\n    const elements = this.elements;\n    const groupMarks = this.groupMarks;\n\n    elements.some((entry, index) => { if (id !== entry) return false; pos = index; return true; });\n    if (pos === -1)\n      return false;\n\n    if (1 === elements.length || (1 === groupMarks.length && ModifyElementSource.DragSelect !== groupMarks[groupMarks.length - 1].source)) {\n      this.clear();\n      return true;\n    }\n\n    const groupIndex = pos;\n    let groupStart = 0, groupEnd = 0;\n    let markToErase = 0;\n    let removeSingleEntry = false;\n\n    for (let iMark = 0; iMark < groupMarks.length; ++iMark) {\n      if (0 === groupEnd) {\n        if (iMark + 1 === groupMarks.length) {\n          markToErase = iMark;\n          removeSingleEntry = (ModifyElementSource.DragSelect === groupMarks[iMark].source);\n          groupStart = groupMarks[iMark].start;\n          groupEnd = elements.length;\n        } else if (groupMarks[iMark].start <= groupIndex && groupMarks[iMark + 1].start > groupIndex) {\n          markToErase = iMark;\n          removeSingleEntry = (ModifyElementSource.DragSelect === groupMarks[iMark].source);\n          groupStart = groupMarks[iMark].start;\n          groupEnd = groupMarks[iMark + 1].start;\n        }\n\n        continue;\n      }\n\n      if (removeSingleEntry)\n        groupMarks[iMark].start -= 1; // Only removing single entry, not entire group...\n      else\n        groupMarks[iMark].start -= (groupEnd - groupStart); // Adjust indices...\n    }\n\n    if (removeSingleEntry) { // Only remove single entry...\n      if (HilitedState.No !== this.hilitedState)\n        this.setEntriesHiliteState(false, groupIndex, groupIndex + 1); // make sure removed entry isn't left hilited...\n\n      elements.splice(groupIndex, 1);\n\n      if (groupEnd === groupStart + 1)\n        groupMarks.splice(markToErase, 1);\n\n      return true;\n    }\n\n    if (HilitedState.No !== this.hilitedState)\n      this.setEntriesHiliteState(false, groupStart, groupEnd); // make sure removed entries aren't left hilited...\n\n    elements.splice(groupStart, groupEnd - groupStart);\n    groupMarks.splice(markToErase, 1);\n    return true;\n  }\n\n  public remove(arg: Id64Arg) {\n    if (0 === this.length)\n      return false;\n\n    if (0 === Id64.sizeOf(arg))\n      return false;\n\n    const needClearHilite = (HilitedState.No !== this.hilitedState);\n\n    if (needClearHilite)\n      this.clearHilite(); // Avoid making multiple draws to unhilite entries as they are removed...\n\n    Id64.forEach(arg, (elId) => this.removeOne(elId)); // NOTE: Removes group associated with this element, not just a single entry...\n\n    if (needClearHilite)\n      this.hilite();\n\n    return true;\n  }\n\n  /** Add elements not currently in the ElementAgenda and remove elements currently in the ElementAgenda. */\n  public invert(arg: Id64Arg) {\n    if (0 === this.length)\n      return this.add(arg);\n\n    if (0 === Id64.sizeOf(arg))\n      return false;\n\n    const adds: string[] = [];\n    const removes: string[] = [];\n    Id64.forEach(arg, (id) => { if (this.has(id)) removes.push(id); else adds.push(id); });\n    if (adds.length === 0 && removes.length === 0)\n      return false;\n\n    const needClearHilite = (HilitedState.No !== this.hilitedState);\n\n    if (needClearHilite)\n      this.clearHilite(); // Avoid making multiple draws to unhilite/hilite entries as they are removed/added...\n\n    removes.forEach((id) => this.removeOne(id));\n\n    if (adds.length > 0) {\n      const groupStart = this.length;\n      adds.forEach((id) => this.elements.push(id));\n      this.groupMarks.push({ start: groupStart, source: ModifyElementSource.Unknown });\n\n      if (HilitedState.No !== this.hilitedState)\n        this.setEntriesHiliteState(this.hiliteOnAdd, groupStart, this.length); // make sure added entries are hilited (when not also removing)...\n    }\n\n    if (needClearHilite)\n      this.hilite();\n\n    return true;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { ScreenViewport } from \"../Viewport\";\nimport { IModelApp } from \"../IModelApp\";\n\n/**\n * An EventController maps user input events from the canvas of a Viewport to the ToolAdmin so that tools can process them.\n * Viewports are assigned an EventController when they are registered with ViewManager.addViewport and they are destroyed with ViewManager.dropViewport.\n * @public\n */\nexport class EventController {\n  private readonly _removals: VoidFunction[] = [];\n\n  constructor(public vp: ScreenViewport) {\n    const element = vp.parentDiv;\n    if (element === undefined)\n      return;\n\n    this.addDomListeners([\"mousedown\", \"mouseup\", \"mousemove\", \"mouseenter\", \"mouseleave\", \"wheel\", \"touchstart\", \"touchend\", \"touchcancel\", \"touchmove\"], element);\n\n    element.oncontextmenu = () => false;\n    (element as any).onselectstart = () => false; // TODO: onselectstart is experimental. This cast should be removed once it becomes official.\n  }\n\n  public destroy() {\n    this._removals.forEach((remove) => remove());\n    this._removals.length = 0;\n  }\n\n  /**\n   * Call element.addEventListener for each type of DOM event supplied. Creates a listener that will forward the HTML event to ToolAdmin.addEvent.\n   * Records the listener in the [[removals]] member so they are removed when this EventController is destroyed.\n   * @param domType An array of DOM event types to pass to element.addEventListener\n   * @param element The HTML element to which the listeners are added\n   */\n  private addDomListeners(domType: string[], element: HTMLElement) {\n    const vp = this.vp;\n    const { toolAdmin } = IModelApp;\n    const listener = (ev: Event) => { ev.preventDefault(); toolAdmin.addEvent(ev, vp); };\n    domType.forEach((type) => {\n      element.addEventListener(type, listener, false);\n      this._removals.push(() => { element.removeEventListener(type, listener, false); });\n    });\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { BeButton, BeButtonEvent, BeWheelEvent, InteractiveTool, EventHandled, BeTouchEvent } from \"./Tool\";\nimport { ViewManip, ViewHandleType, FitViewTool, DefaultViewTouchTool } from \"./ViewTool\";\nimport { IModelApp } from \"../IModelApp\";\n\n/**\n * The default \"idle\" tool. If no tool is active, or the active tool does not respond to a given\n * event, input events are forwarded to the idle tool. The default idle tool converts middle mouse button events\n * and touch gestures into view navigation operations like pan, zoom, rotate, and fit.\n *\n * Controls are as follows:\n * - Mouse/keyboard:\n *   - mmb: pan\n *   - shift-mmb: rotate\n *   - wheel: zoom in/out\n *   - double-mmb: fit view\n * - Touch:\n *   - single-finger drag: rotate\n *   - two-finger drag: pan\n *   - pinch: zoom in/out\n *   - double-tap: fit view\n *\n * Touch inputs can be combined e.g. drag two fingers while moving them closer together => pan + zoom in\n * @public\n */\nexport class IdleTool extends InteractiveTool {\n  public static toolId = \"Idle\";\n  public static hidden = true;\n\n  public async onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled> {\n    if (!ev.viewport)\n      return EventHandled.No;\n\n    let toolId: string;\n    let handleId: ViewHandleType;\n\n    switch (ev.button) {\n      case BeButton.Middle:\n        if (ev.isControlKey) {\n          toolId = ev.viewport.view.allow3dManipulations() ? \"View.Look\" : \"View.Scroll\";\n          handleId = ev.viewport.view.allow3dManipulations() ? ViewHandleType.Look : ViewHandleType.Scroll;\n        } else if (ev.isShiftKey) {\n          toolId = \"View.Rotate\";\n          handleId = ViewHandleType.Rotate;\n        } else {\n          toolId = \"View.Pan\";\n          handleId = ViewHandleType.Pan;\n        }\n        break;\n\n      case BeButton.Data:\n        // When no active tool is present install rotate view tool on drag of data button\n        if (undefined !== IModelApp.toolAdmin.activeTool)\n          return EventHandled.No;\n        toolId = \"View.Rotate\";\n        handleId = ViewHandleType.Rotate;\n        break;\n\n      default:\n        // When no active tool is present install pan view tool on drag of reset button\n        if (undefined !== IModelApp.toolAdmin.activeTool)\n          return EventHandled.No;\n        toolId = \"View.Pan\";\n        handleId = ViewHandleType.Pan;\n        break;\n    }\n\n    const currTool = IModelApp.toolAdmin.viewTool;\n    if (currTool) {\n      if (currTool instanceof ViewManip)\n        return currTool.startHandleDrag(ev, handleId); // See if current view tool can drag using this handle, leave it active regardless...\n      return EventHandled.No;\n    }\n    const viewTool = IModelApp.tools.create(toolId, ev.viewport, true, true) as ViewManip | undefined;\n    if (viewTool && viewTool.run())\n      return viewTool.startHandleDrag(ev);\n    return EventHandled.Yes;\n  }\n\n  public async onMiddleButtonUp(ev: BeButtonEvent): Promise<EventHandled> {\n    if (!ev.viewport)\n      return EventHandled.No;\n\n    if (ev.isDoubleClick) {\n      const viewTool = new FitViewTool(ev.viewport, true);\n      return viewTool.run() ? EventHandled.Yes : EventHandled.No;\n    }\n\n    if (ev.isControlKey || ev.isShiftKey)\n      return EventHandled.No;\n\n    IModelApp.tentativePoint.process(ev);\n    return EventHandled.Yes;\n  }\n\n  public async onMouseWheel(ev: BeWheelEvent) { return IModelApp.toolAdmin.processWheelEvent(ev, true); }\n\n  public async onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled> {\n    const tool = new DefaultViewTouchTool(startEv, ev);\n    return tool.run() ? EventHandled.Yes : EventHandled.No;\n  }\n\n  public async onTouchTap(ev: BeTouchEvent): Promise<EventHandled> {\n    if (ev.isSingleTap) {\n      // Send data down/up for single finger tap.\n      IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev, BeButton.Data); // tslint:disable-line:no-floating-promises\n      return EventHandled.Yes;\n    } else if (ev.isTwoFingerTap) {\n      // Send reset down/up for two finger tap.\n      IModelApp.toolAdmin.convertTouchTapToButtonDownAndUp(ev, BeButton.Reset); // tslint:disable-line:no-floating-promises\n      return EventHandled.Yes;\n    } else if (ev.isDoubleTap) {\n      // Fit view on single finger double tap.\n      const tool = new FitViewTool(ev.viewport!, true);\n      return tool.run() ? EventHandled.Yes : EventHandled.No;\n    }\n    return EventHandled.No;\n  }\n\n  public exitTool(): void { }\n  public run() { return true; }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Measure */\n\nimport { CanvasDecoration, GraphicType } from \"../rendering\";\nimport { Point3d, XYAndZ, XAndY, Vector3d, Matrix3d, PointString3d, AxisOrder, Point2d, IModelJson, Plane3dByOriginAndUnitNormal } from \"@bentley/geometry-core\";\nimport { Viewport } from \"../Viewport\";\nimport { DecorateContext } from \"../ViewContext\";\nimport { Marker } from \"../Marker\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { IModelApp } from \"../IModelApp\";\nimport { HitDetail, HitGeomType } from \"../HitDetail\";\nimport { GeometryStreamProps, ColorDef } from \"@bentley/imodeljs-common\";\nimport { QuantityType } from \"../QuantityFormatter\";\nimport { BeButtonEvent, EventHandled } from \"./Tool\";\nimport { NotifyMessageDetails, OutputMessagePriority, OutputMessageType } from \"../NotificationManager\";\nimport { AccuDrawShortcuts } from \"./AccuDrawTool\";\nimport { AccuDrawHintBuilder } from \"../AccuDraw\";\n\n/** @alpha */\nclass MeasureLabel implements CanvasDecoration {\n  public worldLocation = new Point3d();\n  public position = new Point3d();\n  public label: string;\n\n  constructor(worldLocation: XYAndZ, label: string) {\n    this.worldLocation.setFrom(worldLocation);\n    this.label = label;\n  }\n\n  public drawDecoration(ctx: CanvasRenderingContext2D): void {\n    ctx.font = \"16px san-serif\";\n    const labelHeight = ctx.measureText(\"M\").width; // Close enough for border padding...\n    const labelWidth = ctx.measureText(this.label).width + labelHeight;\n\n    ctx.lineWidth = 1;\n    ctx.strokeStyle = \"white\";\n    ctx.fillStyle = \"rgba(0,0,0,.4)\";\n    ctx.shadowColor = \"black\";\n    ctx.shadowBlur = 10;\n    ctx.fillRect(-(labelWidth / 2), -labelHeight, labelWidth, labelHeight * 2);\n    ctx.strokeRect(-(labelWidth / 2), -labelHeight, labelWidth, labelHeight * 2);\n\n    ctx.fillStyle = \"white\";\n    ctx.shadowBlur = 0;\n    ctx.textAlign = \"center\";\n    ctx.textBaseline = \"middle\";\n    ctx.fillText(this.label, 0, 0);\n  }\n\n  public setPosition(vp: Viewport): boolean {\n    vp.worldToView(this.worldLocation, this.position);\n    this.position.y -= Math.floor(vp.pixelsFromInches(0.44)) + 0.5; // Offset from snap location...\n    return vp.viewRect.containsPoint(this.position);\n  }\n\n  public addDecoration(context: DecorateContext) {\n    if (this.setPosition(context.viewport))\n      context.addCanvasDecoration(this);\n  }\n}\n\n/** @alpha */\nclass MeasureMarker extends Marker {\n  public isSelected: boolean = false;\n  constructor(label: string, title: HTMLElement, worldLocation: XYAndZ, size: XAndY) {\n    super(worldLocation, size);\n\n    const markerDrawFunc = (ctx: CanvasRenderingContext2D) => {\n      ctx.beginPath();\n      ctx.arc(0, 0, this.size.x * 0.5, 0, 2 * Math.PI);\n      ctx.lineWidth = 2;\n      ctx.strokeStyle = \"black\";\n      const hilite = this.isSelected && this._hiliteColor ? this._hiliteColor.colors : undefined;\n      ctx.fillStyle = undefined !== hilite ? \"rgba(\" + (hilite.r | 0) + \",\" + (hilite.g | 0) + \",\" + (hilite.b | 0) + \", 0.5)\" : \"rgba(255,255,255,.5)\";\n      ctx.fill();\n      ctx.stroke();\n    };\n\n    this.drawFunc = markerDrawFunc;\n    this.title = title;\n    this.label = label;\n    this.labelFont = \"18px san-serif\";\n    this.labelColor = \"black\";\n  }\n}\n\n/** @alpha */\nexport class MeasureDistanceTool extends PrimitiveTool {\n  public static toolId = \"Measure.Distance\";\n  protected readonly _locationData = new Array<{ point: Point3d, refAxes: Matrix3d }>();\n  protected readonly _acceptedSegments = new Array<{ distance: number, slope: number, start: Point3d, end: Point3d, delta: Vector3d, refAxes: Matrix3d, marker: MeasureMarker }>();\n  protected _totalDistance: number = 0.0;\n  protected _totalDistanceMarker?: MeasureLabel;\n  protected _snapGeomId?: string;\n\n  public isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.isSpatialView()); }\n  public requireWriteableTarget(): boolean { return false; }\n  public onPostInstall() { super.onPostInstall(); this.setupAndPromptForNextAction(); }\n\n  public onUnsuspend(): void { this.showPrompt(); }\n  protected showPrompt(): void { IModelApp.notifications.outputPromptByKey(0 === this._locationData.length ? \"CoreTools:tools.Measure.Distance.Prompts.FirstPoint\" : \"CoreTools:tools.Measure.Distance.Prompts.NextPoint\"); }\n\n  protected setupAndPromptForNextAction(): void {\n    IModelApp.accuSnap.enableSnap(true);\n    const hints = new AccuDrawHintBuilder();\n    hints.enableSmartRotation = true;\n    hints.setModeRectangular();\n    hints.sendHints(false);\n    IModelApp.toolAdmin.setCursor(0 === this._locationData.length ? IModelApp.viewManager.crossHairCursor : IModelApp.viewManager.dynamicsCursor);\n    this.showPrompt();\n  }\n\n  public testDecorationHit(id: string): boolean { return id === this._snapGeomId; }\n\n  protected getSnapPoints(): Point3d[] | undefined {\n    if (this._acceptedSegments.length < 1 && this._locationData.length < 2)\n      return undefined;\n\n    const snapPoints: Point3d[] = [];\n    for (const seg of this._acceptedSegments) {\n      if (0 === snapPoints.length || !seg.start.isAlmostEqual(snapPoints[snapPoints.length - 1]))\n        snapPoints.push(seg.start);\n      if (!seg.end.isAlmostEqual(snapPoints[0]))\n        snapPoints.push(seg.end);\n    }\n\n    if (this._locationData.length > 1)\n      for (const loc of this._locationData)\n        snapPoints.push(loc.point);\n    return snapPoints;\n  }\n\n  public getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined {\n    const snapPoints = this.getSnapPoints();\n    if (undefined === snapPoints)\n      return undefined;\n    const geomData = IModelJson.Writer.toIModelJson(PointString3d.create(snapPoints));\n    return (undefined === geomData ? undefined : [geomData]);\n  }\n\n  protected displayDynamicDistance(context: DecorateContext, points: Point3d[]): void {\n    let totalDistance = 0.0;\n    for (let i = 0; i < points.length - 1; i++)\n      totalDistance += points[i].distance(points[i + 1]);\n    if (0.0 === totalDistance)\n      return;\n\n    const formatterSpec = IModelApp.quantityFormatter.findFormatterSpecByQuantityType(QuantityType.Length);\n    if (undefined === formatterSpec)\n      return;\n    const formattedTotalDistance = IModelApp.quantityFormatter.formatQuantity(totalDistance, formatterSpec);\n    const distDyn = new MeasureLabel(points[points.length - 1], formattedTotalDistance);\n    distDyn.addDecoration(context);\n  }\n\n  protected displayDelta(context: DecorateContext, seg: any): void {\n    const xVec = new Vector3d(seg.delta.x, 0.0, 0.0);\n    const yVec = new Vector3d(0.0, seg.delta.y, 0.0);\n    const zVec = new Vector3d(0.0, 0.0, seg.delta.z);\n\n    seg.refAxes.multiplyVectorInPlace(xVec);\n    seg.refAxes.multiplyVectorInPlace(yVec);\n    seg.refAxes.multiplyVectorInPlace(zVec);\n\n    const builderAxes = context.createGraphicBuilder(GraphicType.WorldOverlay);\n    let basePt = seg.start.clone();\n\n    if (xVec.magnitude() > 1.0e-5) {\n      const segPoints: Point3d[] = [];\n      segPoints.push(basePt); basePt = basePt.plus(xVec);\n      segPoints.push(basePt);\n      const colorX = ColorDef.red.adjustForContrast(context.viewport.view.backgroundColor);\n      builderAxes.setSymbology(colorX, ColorDef.black, 5);\n      builderAxes.addLineString(segPoints);\n    }\n\n    if (yVec.magnitude() > 1.0e-5) {\n      const segPoints: Point3d[] = [];\n      segPoints.push(basePt); basePt = basePt.plus(yVec);\n      segPoints.push(basePt);\n      const colorY = ColorDef.green.adjustForContrast(context.viewport.view.backgroundColor);\n      builderAxes.setSymbology(colorY, ColorDef.black, 5);\n      builderAxes.addLineString(segPoints);\n    }\n\n    if (zVec.magnitude() > 1.0e-5) {\n      const segPoints: Point3d[] = [];\n      segPoints.push(basePt); basePt = basePt.plus(zVec);\n      segPoints.push(basePt);\n      const colorZ = ColorDef.blue.adjustForContrast(context.viewport.view.backgroundColor);\n      builderAxes.setSymbology(colorZ, ColorDef.black, 5);\n      builderAxes.addLineString(segPoints);\n    }\n\n    const segGlow = context.viewport.hilite.color.clone(); segGlow.setAlpha(50);\n    builderAxes.setSymbology(segGlow, ColorDef.black, 8);\n    builderAxes.addLineString([seg.start, seg.end]);\n\n    context.addDecorationFromBuilder(builderAxes);\n  }\n\n  public decorate(context: DecorateContext): void {\n    if (!context.viewport.view.isSpatialView())\n      return;\n\n    if (this._locationData.length > 0) {\n      const ev = new BeButtonEvent();\n      IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n      const tmpPoints: Point3d[] = [];\n      for (const loc of this._locationData)\n        tmpPoints.push(loc.point); // Deep copy not necessary...\n      tmpPoints.push(ev.point);\n\n      const builderDynVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n      const colorDynVis = context.viewport.hilite.color;\n\n      builderDynVis.setSymbology(colorDynVis, ColorDef.black, 3);\n      builderDynVis.addLineString(tmpPoints);\n\n      context.addDecorationFromBuilder(builderDynVis);\n\n      const builderDynHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n      const colorDynHid = colorDynVis.clone(); colorDynHid.setAlpha(100);\n\n      builderDynHid.setSymbology(colorDynHid, ColorDef.black, 1);\n      builderDynHid.addLineString(tmpPoints);\n\n      context.addDecorationFromBuilder(builderDynHid);\n      this.displayDynamicDistance(context, tmpPoints);\n    }\n\n    if (this._acceptedSegments.length > 0) {\n      const builderAccVis = context.createGraphicBuilder(GraphicType.WorldDecoration);\n      const builderAccHid = context.createGraphicBuilder(GraphicType.WorldOverlay);\n      const colorAccVis = ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);\n      const colorAccHid = colorAccVis.clone(); colorAccHid.setAlpha(100);\n\n      builderAccVis.setSymbology(colorAccVis, ColorDef.black, 3);\n      builderAccHid.setSymbology(colorAccHid, ColorDef.black, 1);\n\n      for (const seg of this._acceptedSegments) {\n        builderAccVis.addLineString([seg.start, seg.end]);\n        builderAccHid.addLineString([seg.start, seg.end]);\n        seg.marker.addDecoration(context);\n        if (seg.marker.isSelected)\n          this.displayDelta(context, seg);\n      }\n\n      context.addDecorationFromBuilder(builderAccVis);\n      context.addDecorationFromBuilder(builderAccHid);\n    }\n\n    if (undefined !== this._totalDistanceMarker)\n      this._totalDistanceMarker.addDecoration(context);\n\n    const snapPoints = this.getSnapPoints();\n    if (undefined === snapPoints)\n      return;\n\n    if (undefined === this._snapGeomId)\n      this._snapGeomId = this.iModel.transientIds.next;\n\n    const builderSnapPts = context.createGraphicBuilder(GraphicType.WorldOverlay, undefined, this._snapGeomId);\n    const colorAccPts = ColorDef.white.adjustForContrast(context.viewport.view.backgroundColor);\n\n    builderSnapPts.setSymbology(colorAccPts, ColorDef.black, 7);\n    builderSnapPts.addPointString(snapPoints);\n\n    context.addDecorationFromBuilder(builderSnapPts);\n  }\n\n  public decorateSuspended(context: DecorateContext): void { this.decorate(context); }\n\n  public async onMouseMotion(ev: BeButtonEvent): Promise<void> { if (this._locationData.length > 0 && undefined !== ev.viewport) ev.viewport.invalidateDecorations(); }\n\n  protected reportMeasurements(): void {\n    if (undefined === this._totalDistanceMarker)\n      return;\n    const briefMsg = IModelApp.i18n.translateKeys(this._acceptedSegments.length > 1 ? \"%{CoreTools:tools.Measure.Labels.CumulativeDistance}: \" : \"%{CoreTools:tools.Measure.Labels.Distance}: \") + this._totalDistanceMarker.label;\n    const msgDetail = new NotifyMessageDetails(OutputMessagePriority.Info, briefMsg, undefined, OutputMessageType.InputField);\n    IModelApp.notifications.outputMessage(msgDetail);\n  }\n\n  protected async updateTotals(): Promise<void> {\n    this._totalDistance = 0.0;\n    this._totalDistanceMarker = undefined;\n    for (const seg of this._acceptedSegments)\n      this._totalDistance += seg.distance;\n    if (0.0 === this._totalDistance)\n      return;\n\n    const formatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length);\n    if (undefined === formatterSpec)\n      return;\n\n    const formattedTotalDistance = IModelApp.quantityFormatter.formatQuantity(this._totalDistance, formatterSpec);\n    this._totalDistanceMarker = new MeasureLabel(this._acceptedSegments[this._acceptedSegments.length - 1].end, formattedTotalDistance);\n    this.reportMeasurements();\n  }\n\n  protected async getMarkerToolTip(distance: number, slope: number, start: Point3d, end: Point3d, delta?: Vector3d): Promise<HTMLElement> {\n    const toolTip = document.createElement(\"div\");\n\n    const distanceFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Length);\n    if (undefined === distanceFormatterSpec)\n      return toolTip;\n\n    let toolTipHtml = \"\";\n    const formattedDistance = IModelApp.quantityFormatter.formatQuantity(distance, distanceFormatterSpec);\n    toolTipHtml += IModelApp.i18n.translateKeys(\"<b>%{CoreTools:tools.Measure.Labels.Distance}:</b> \") + formattedDistance + \"<br>\";\n\n    const angleFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Angle);\n    if (undefined !== angleFormatterSpec) {\n      const formattedSlope = IModelApp.quantityFormatter.formatQuantity(slope, angleFormatterSpec);\n      toolTipHtml += IModelApp.i18n.translateKeys(\"<b>%{CoreTools:tools.Measure.Labels.Slope}:</b> \") + formattedSlope + \"<br>\";\n    }\n\n    const coordFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Coordinate);\n    if (undefined !== coordFormatterSpec) {\n      let startAdjusted = start;\n      let endAdjusted = end;\n      if (undefined !== this.targetView && this.targetView.view.isSpatialView()) {\n        const globalOrigin = this.iModel.globalOrigin;\n        startAdjusted = startAdjusted.minus(globalOrigin);\n        endAdjusted = endAdjusted.minus(globalOrigin);\n      }\n\n      const formattedStartX = IModelApp.quantityFormatter.formatQuantity(startAdjusted.x, coordFormatterSpec);\n      const formattedStartY = IModelApp.quantityFormatter.formatQuantity(startAdjusted.y, coordFormatterSpec);\n      const formattedStartZ = IModelApp.quantityFormatter.formatQuantity(startAdjusted.z, coordFormatterSpec);\n      toolTipHtml += IModelApp.i18n.translateKeys(\"<b>%{CoreTools:tools.Measure.Labels.StartCoord}:</b> \") + formattedStartX + \", \" + formattedStartY + \", \" + formattedStartZ + \"<br>\";\n\n      const formattedEndX = IModelApp.quantityFormatter.formatQuantity(endAdjusted.x, coordFormatterSpec);\n      const formattedEndY = IModelApp.quantityFormatter.formatQuantity(endAdjusted.y, coordFormatterSpec);\n      const formattedEndZ = IModelApp.quantityFormatter.formatQuantity(endAdjusted.z, coordFormatterSpec);\n      toolTipHtml += IModelApp.i18n.translateKeys(\"<b>%{CoreTools:tools.Measure.Labels.EndCoord}:</b> \") + formattedEndX + \", \" + formattedEndY + \", \" + formattedEndZ + \"<br>\";\n    }\n\n    if (undefined !== delta) {\n      const formattedDeltaX = IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.x), distanceFormatterSpec);\n      const formattedDeltaY = IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.y), distanceFormatterSpec);\n      const formattedDeltaZ = IModelApp.quantityFormatter.formatQuantity(Math.abs(delta.z), distanceFormatterSpec);\n      toolTipHtml += IModelApp.i18n.translateKeys(\"<b>%{CoreTools:tools.Measure.Labels.Delta}:</b> \") + formattedDeltaX + \", \" + formattedDeltaY + \", \" + formattedDeltaZ + \"<br>\";\n    }\n\n    toolTip.innerHTML = toolTipHtml;\n    return toolTip;\n  }\n\n  protected async updateSelectedMarkerToolTip(seg: any, ev: BeButtonEvent): Promise<void> {\n    seg.marker.title = await this.getMarkerToolTip(seg.distance, seg.slope, seg.start, seg.end, seg.marker.isSelected ? seg.delta : undefined);\n    if (undefined === ev.viewport || !IModelApp.notifications.isToolTipOpen)\n      return;\n    IModelApp.notifications.clearToolTip();\n    ev.viewport.openToolTip(seg.marker.title, ev.viewPoint);\n  }\n\n  protected async acceptNewSegments(): Promise<void> {\n    if (this._locationData.length > 1) {\n      for (let i = 0; i <= this._locationData.length - 2; i++) {\n        const start = this._locationData[i].point;\n        const end = this._locationData[i + 1].point;\n        const distance = start.distance(end);\n        const xyDist = start.distanceXY(end);\n        const zDist = end.z - start.z;\n        const slope = (0.0 === xyDist ? Math.PI : Math.atan(zDist / xyDist));\n        const delta = Vector3d.createStartEnd(start, end);\n        const refAxes = this._locationData[i].refAxes;\n        refAxes.multiplyTransposeVectorInPlace(delta);\n\n        const toolTip = await this.getMarkerToolTip(distance, slope, start, end);\n        const marker = new MeasureMarker((this._acceptedSegments.length + 1).toString(), toolTip, start.interpolate(0.5, end), Point2d.create(25, 25));\n\n        const segMarkerButtonFunc = (ev: BeButtonEvent) => {\n          if (ev.isDown)\n            return true;\n\n          let selectedMarker: MeasureMarker | undefined;\n          for (const seg of this._acceptedSegments) {\n            if (!seg.marker.pick(ev.viewPoint))\n              continue;\n            selectedMarker = (seg.marker.isSelected ? undefined : seg.marker);\n            break;\n          }\n\n          for (const seg of this._acceptedSegments) {\n            const wasSelected = seg.marker.isSelected;\n            seg.marker.isSelected = (seg.marker === selectedMarker);\n            if (wasSelected !== seg.marker.isSelected)\n              this.updateSelectedMarkerToolTip(seg, ev); // tslint:disable-line:no-floating-promises\n          }\n\n          if (undefined !== ev.viewport)\n            ev.viewport.invalidateDecorations();\n          return true;\n        };\n\n        marker.onMouseButton = segMarkerButtonFunc;\n        this._acceptedSegments.push({ distance, slope, start, end, delta, refAxes, marker });\n      }\n    }\n    this._locationData.length = 0;\n    await this.updateTotals();\n  }\n\n  protected getReferenceAxes(vp?: Viewport): Matrix3d {\n    const refAxes = Matrix3d.createIdentity();\n    if (undefined !== vp && vp.isContextRotationRequired)\n      vp.getAuxCoordRotation(refAxes);\n    return refAxes;\n  }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    const point = ev.point.clone();\n    const refAxes = this.getReferenceAxes(ev.viewport);\n    const zDir = refAxes.columnZ();\n    const normal = refAxes.columnZ();\n    const tangent = refAxes.columnX();\n    const snap = IModelApp.accuSnap.getCurrSnapDetail();\n\n    // Report xyz delta relative to world up. The surface normal and edge tangent help determine the rotation about z...\n    if (undefined !== snap) {\n      if (undefined !== snap.primitive) {\n        const locDetail = snap.primitive.closestPoint(point, false);\n        if (undefined !== locDetail && (HitGeomType.Segment === snap.geomType || snap.primitive.isInPlane(Plane3dByOriginAndUnitNormal.create(point, undefined !== snap.normal ? snap.normal : normal)!))) {\n          const locRay = snap.primitive.fractionToPointAndUnitTangent(locDetail.fraction);\n          tangent.setFrom(locRay.direction);\n          if (undefined !== snap.normal)\n            normal.setFrom(snap.normal);\n        }\n      } else if (undefined !== snap.normal) {\n        normal.setFrom(snap.normal);\n      }\n    }\n\n    if (!normal.isParallelTo(zDir, true)) {\n      const yDir = zDir.unitCrossProduct(normal);\n      if (undefined !== yDir) {\n        yDir.unitCrossProduct(zDir, normal);\n        Matrix3d.createColumnsInAxisOrder(AxisOrder.ZXY, normal, yDir, zDir, refAxes);\n      }\n    } else if (!tangent.isParallelTo(zDir, true)) {\n      const yDir = zDir.unitCrossProduct(tangent);\n      if (undefined !== yDir) {\n        yDir.unitCrossProduct(zDir, tangent);\n        Matrix3d.createColumnsInAxisOrder(AxisOrder.XYZ, tangent, yDir, zDir, refAxes);\n      }\n    }\n\n    this._locationData.push({ point, refAxes });\n\n    if (this._locationData.length > 1 && !ev.isControlKey)\n      await this.acceptNewSegments();\n    this.setupAndPromptForNextAction();\n    if (undefined !== ev.viewport)\n      ev.viewport.invalidateDecorations();\n    return EventHandled.No;\n  }\n\n  public async onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled> {\n    if (0 === this._locationData.length) {\n      this.onReinitialize();\n      return EventHandled.No;\n    }\n    await this.acceptNewSegments();\n    this.setupAndPromptForNextAction();\n    if (undefined !== ev.viewport)\n      ev.viewport.invalidateDecorations();\n    return EventHandled.No;\n  }\n\n  public async onUndoPreviousStep(): Promise<boolean> {\n    if (0 === this._locationData.length && 0 === this._acceptedSegments.length)\n      return false;\n\n    if (0 !== this._locationData.length) {\n      this._locationData.pop();\n    } else if (0 !== this._acceptedSegments.length) {\n      this._acceptedSegments.pop();\n    }\n\n    if (0 === this._locationData.length && 0 === this._acceptedSegments.length) {\n      this.onReinitialize();\n    } else {\n      await this.updateTotals();\n      this.setupAndPromptForNextAction();\n    }\n    return true;\n  }\n\n  public async onKeyTransition(wentDown: boolean, keyEvent: KeyboardEvent): Promise<EventHandled> {\n    if (EventHandled.Yes === await super.onKeyTransition(wentDown, keyEvent))\n      return EventHandled.Yes;\n    return (wentDown && AccuDrawShortcuts.processShortcutKey(keyEvent)) ? EventHandled.Yes : EventHandled.No;\n  }\n\n  public onRestartTool(): void {\n    const tool = new MeasureDistanceTool();\n    if (!tool.run())\n      this.exitTool();\n  }\n}\n\n/** @alpha */\nexport class MeasureLocationTool extends PrimitiveTool {\n  public static toolId = \"Measure.Location\";\n  protected readonly _acceptedLocations: MeasureMarker[] = [];\n\n  public isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean { return (super.isCompatibleViewport(vp, isSelectedViewChange) && undefined !== vp && vp.view.isSpatialView()); }\n  public requireWriteableTarget(): boolean { return false; }\n  public onPostInstall() { super.onPostInstall(); this.setupAndPromptForNextAction(); }\n\n  public onUnsuspend(): void { this.showPrompt(); }\n  protected showPrompt(): void { IModelApp.notifications.outputPromptByKey(\"CoreTools:tools.Measure.Location.Prompts.EnterPoint\"); }\n\n  protected setupAndPromptForNextAction(): void {\n    IModelApp.accuSnap.enableSnap(true);\n    this.showPrompt();\n  }\n\n  protected async getMarkerToolTip(point: Point3d): Promise<HTMLElement> {\n    const toolTip = document.createElement(\"div\");\n\n    let toolTipHtml = \"\";\n    const coordFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.Coordinate);\n    if (undefined !== coordFormatterSpec) {\n      let pointAdjusted = point;\n      if (undefined !== this.targetView && this.targetView.view.isSpatialView()) {\n        const globalOrigin = this.iModel.globalOrigin;\n        pointAdjusted = pointAdjusted.minus(globalOrigin);\n      }\n      const formattedPointX = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.x, coordFormatterSpec);\n      const formattedPointY = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.y, coordFormatterSpec);\n      const formattedPointZ = IModelApp.quantityFormatter.formatQuantity(pointAdjusted.z, coordFormatterSpec);\n      if (undefined !== formattedPointX && undefined !== formattedPointY && undefined !== formattedPointZ)\n        toolTipHtml += IModelApp.i18n.translateKeys(\"<b>%{CoreTools:tools.Measure.Labels.Coordinate}:</b> \") + formattedPointX + \", \" + formattedPointY + \", \" + formattedPointZ + \"<br>\";\n    }\n\n    if (undefined !== this.targetView && this.targetView.view.isSpatialView()) {\n      const latLongFormatterSpec = await IModelApp.quantityFormatter.getFormatterSpecByQuantityType(QuantityType.LatLong);\n      if (undefined !== latLongFormatterSpec && undefined !== coordFormatterSpec) {\n        try {\n          const cartographic = await this.iModel.spatialToCartographic(point);\n          const formattedLat = IModelApp.quantityFormatter.formatQuantity(Math.abs(cartographic.latitude), latLongFormatterSpec);\n          const formattedLong = IModelApp.quantityFormatter.formatQuantity(Math.abs(cartographic.longitude), latLongFormatterSpec);\n          const formattedHeight = IModelApp.quantityFormatter.formatQuantity(cartographic.height, coordFormatterSpec);\n          const latDir = IModelApp.i18n.translateKeys(cartographic.latitude < 0 ? \"%{CoreTools:tools.Measure.Labels.S}\" : \"%{CoreTools:tools.Measure.Labels.N}\");\n          const longDir = IModelApp.i18n.translateKeys(cartographic.longitude < 0 ? \"%{CoreTools:tools.Measure.Labels.W}\" : \"%{CoreTools:tools.Measure.Labels.E}\");\n          toolTipHtml += IModelApp.i18n.translateKeys(\"<b>%{CoreTools:tools.Measure.Labels.LatLong}:</b> \") + formattedLat + latDir + \", \" + formattedLong + longDir + \"<br>\";\n          toolTipHtml += IModelApp.i18n.translateKeys(\"<b>%{CoreTools:tools.Measure.Labels.Altitude}:</b> \") + formattedHeight + \"<br>\";\n        } catch { }\n      }\n    }\n\n    toolTip.innerHTML = toolTipHtml;\n    return toolTip;\n  }\n\n  public decorate(context: DecorateContext): void { if (!context.viewport.view.isSpatialView()) return; this._acceptedLocations.forEach((marker) => marker.addDecoration(context)); }\n  public decorateSuspended(context: DecorateContext): void { this.decorate(context); }\n\n  protected reportMeasurements(): void { }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    const point = ev.point.clone();\n    const toolTip = await this.getMarkerToolTip(point);\n    const marker = new MeasureMarker((this._acceptedLocations.length + 1).toString(), toolTip, point, Point2d.create(25, 25));\n\n    const noOpButtonFunc = (_ev: BeButtonEvent) => true;\n    marker.onMouseButton = noOpButtonFunc;\n\n    this._acceptedLocations.push(marker);\n    this.reportMeasurements();\n    this.setupAndPromptForNextAction();\n    if (undefined !== ev.viewport)\n      ev.viewport.invalidateDecorations();\n    return EventHandled.No;\n  }\n\n  public async onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled> {\n    this.onReinitialize();\n    return EventHandled.No;\n  }\n\n  public async onUndoPreviousStep(): Promise<boolean> {\n    if (0 === this._acceptedLocations.length)\n      return false;\n\n    this._acceptedLocations.pop();\n    if (0 === this._acceptedLocations.length) {\n      this.onReinitialize();\n    } else {\n      this.reportMeasurements();\n      this.setupAndPromptForNextAction();\n    }\n    return true;\n  }\n\n  public onRestartTool(): void {\n    const tool = new MeasureLocationTool();\n    if (!tool.run())\n      this.exitTool();\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { Tool } from \"./Tool\";\nimport { PluginAdmin } from \"../Plugin\";\nimport { IModelApp } from \"../IModelApp\";\n\n/** An Immediate Tool that starts the process of loading an iModelJs plugin. */\nexport class PluginTool extends Tool {\n  public static toolId = \"Plugin\";\n  public run(args: any[]): boolean {\n    if (args && args.length > 0 && args[0]) {\n      PluginAdmin.loadPlugin(args[0], args.slice(1))\n        .then(() => { })\n        .catch((_err) => { IModelApp.notifications.outputMessage(IModelApp.i18n.translate(\"PluginErrors.UnableToLoad\", { pluginName: args[0] })); });\n    }\n    return true;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { BeButtonEvent, InteractiveTool, BeButton, CoordinateLockOverrides } from \"./Tool\";\nimport { Viewport } from \"../Viewport\";\nimport { IModelConnection } from \"../IModelConnection\";\nimport { IModelApp } from \"../IModelApp\";\nimport { AccuDrawShortcuts } from \"./AccuDrawTool\";\nimport { NotifyMessageDetails, OutputMessagePriority } from \"../NotificationManager\";\n\n/** The PrimitiveTool class can be used to implement tools to create or modify geometric elements.\n * @see [Writing a PrimitiveTool]($docs/learning/frontend/primitivetools.md)\n * @public\n */\nexport abstract class PrimitiveTool extends InteractiveTool {\n  public targetView?: Viewport;\n  public targetModelId?: string;\n  public targetIsLocked: boolean = false; // If target model is known, set this to true in constructor and override getTargetModel.\n\n  /** Get the iModel the tool is operating against. */\n  public get iModel(): IModelConnection { return this.targetView!.view!.iModel; }\n\n  /**\n   * Establish this tool as the active PrimitiveTool.\n   * @return true if this tool was installed (though it may have exited too)\n   */\n  public run(): boolean {\n    const { toolAdmin, viewManager } = IModelApp;\n    if (!this.isCompatibleViewport(viewManager.selectedView, false) || !toolAdmin.onInstallTool(this))\n      return false;\n\n    toolAdmin.startPrimitiveTool(this);\n    toolAdmin.onPostInstallTool(this);\n    return true;\n  }\n\n  /**\n   * Determine whether the supplied Viewport is compatible with this tool.\n   * @param vp the Viewport to check\n   */\n  public isCompatibleViewport(vp: Viewport | undefined, isSelectedViewChange: boolean): boolean {\n    if (undefined === vp)\n      return false; // No views are open...\n\n    const view = vp.view;\n    const iModel = view.iModel;\n    if (this.requireWriteableTarget() && iModel.isReadonly)\n      return false; // Tool can't be used when iModel is read only.\n\n    if (undefined === this.targetView)\n      this.targetView = vp; // Update target to newly selected view.\n\n    if (!this.targetIsLocked) {\n      if (isSelectedViewChange)\n        this.targetView = vp; // Update target to newly selected view.\n      return true; // Any type of model/view is still ok and target is still free to change.\n    }\n\n    if (iModel !== this.iModel)\n      return false; // Once a ViewState has been established, only accept viewport showing the same iModel.\n\n    if (this.targetModelId && !view.viewsModel(this.targetModelId))\n      return false; // Only allow view where target is being viewed.\n\n    return true;\n  }\n\n  /**\n   * Checks that the adjusted point from the supplied button event is within the project extents for spatial views. The range of physical geometry\n   * should always be fully inside the project extents. Only checking the adjusted point won't absolutely guarantee that a tool doesn't create/move geometry\n   * outside the project extents, but it will be sufficient to handle most cases and provide good feedback to the user.\n   * @return true if ev is acceptable.\n   */\n  public isValidLocation(ev: BeButtonEvent, isButtonEvent: boolean): boolean {\n    const vp = ev.viewport;\n    if (undefined === vp)\n      return false;\n\n    if (isButtonEvent && BeButton.Data !== ev.button)\n      return true;\n\n    const view = vp.view;\n    if (!view.isSpatialView())\n      return true;\n\n    // NOTE: If points aren't being adjusted then the tool shouldn't be creating geometry currently (ex. locating elements) and we shouldn't filter point...\n    if (0 !== (IModelApp.toolAdmin.toolState.coordLockOvr & CoordinateLockOverrides.ACS))\n      return true;\n\n    // We know the tool isn't doing a locate, we don't know what it will do with this point. Minimize erroneous filtering by restricting the check to when AccuSnap is tool enable (not user enabled)...\n    if (!IModelApp.accuSnap.isSnapEnabled)\n      return true;\n\n    const extents = view.iModel.projectExtents;\n    if (extents.containsPoint(ev.point))\n      return true;\n\n    if (isButtonEvent && ev.isDown)\n      IModelApp.notifications.outputMessage(new NotifyMessageDetails(OutputMessagePriority.Error, IModelApp.i18n.translate(\"CoreTools:tools.ElementSet.Error.ProjectExtents\")));\n\n    return false;\n  }\n\n  /** Called on data button down event to lock the tool to its current target model. */\n  public autoLockTarget(): void { if (undefined === this.targetView) return; this.targetIsLocked = true; }\n\n  /**  Returns the prompt based on the tool's current state. */\n  public getPrompt(): string { return \"\"; }\n\n  /** Called from isCompatibleViewport to check for a read only iModel, which is not a valid target for tools that create or modify elements. */\n  public requireWriteableTarget(): boolean { return true; }\n\n  /**\n   * Called when active view changes. Tool may choose to restart or exit based on current view type.\n   * @param _previous The previously active view.\n   * @param current The new active view.\n   */\n  public onSelectedViewportChanged(_previous: Viewport | undefined, current: Viewport | undefined): void {\n    if (this.isCompatibleViewport(current, true))\n      return;\n    this.onRestartTool();\n  }\n\n  /**\n   * Called when an external event may invalidate the current tool's state.\n   * Examples are undo, which may invalidate any references to elements, or an incompatible active view change.\n   * The active tool is expected to call installTool with a new instance, or exitTool to start the default tool.\n   */\n  public abstract onRestartTool(): void;\n\n  /**\n   * Called to reset tool to initial state. PrimitiveTool implements this method to call onRestartTool.\n   */\n  public onReinitialize(): void { this.onRestartTool(); }\n\n  public exitTool(): void { IModelApp.toolAdmin.startDefaultTool(); }\n\n  /**\n   * Called to reverse to a previous tool state (ex. undo last data button).\n   * @return false to instead reverse the most recent transaction.\n   */\n  public async onUndoPreviousStep(): Promise<boolean> { return false; }\n\n  /** @internal */\n  public async undoPreviousStep(): Promise<boolean> {\n    if (!await this.onUndoPreviousStep())\n      return false;\n\n    AccuDrawShortcuts.processPendingHints(); // Process any hints the active tool setup in _OnUndoPreviousStep now...\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n    IModelApp.toolAdmin.updateDynamics();\n\n    return true;\n  }\n\n  /**\n   * Called to reinstate to a previous tool state (ex. redo last data button).\n   * @return false to instead reinstate the most recent transaction.\n   */\n  public async onRedoPreviousStep(): Promise<boolean> { return false; }\n\n  /** @internal */\n  public async redoPreviousStep(): Promise<boolean> {\n    if (!await this.onRedoPreviousStep())\n      return false;\n\n    AccuDrawShortcuts.processPendingHints(); // Process any hints the active tool setup in _OnUndoPreviousStep now...\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n    IModelApp.toolAdmin.updateDynamics();\n\n    return true;\n  }\n  /**\n   * Tools need to call SaveChanges to commit any elements they have added/changes they have made.\n   * This helper method supplies the tool name for the undo string to iModel.saveChanges.\n   */\n  public async saveChanges(): Promise<void> { return this.iModel.saveChanges(this.toolId); }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module SelectionSet */\n\nimport { Id64, Id64Arg } from \"@bentley/bentleyjs-core\";\nimport { Point2d, Point3d, Range2d } from \"@bentley/geometry-core\";\nimport { ColorDef } from \"@bentley/imodeljs-common\";\nimport { LocateFilterStatus, LocateResponse } from \"../ElementLocateManager\";\nimport { HitDetail } from \"../HitDetail\";\nimport { IModelApp } from \"../IModelApp\";\nimport { PropertyDescription } from \"../properties/Description\";\nimport { PropertyEditorParamTypes } from \"../properties/EditorParams\";\nimport { ToolSettingsPropertyRecord, ToolSettingsPropertySyncItem, ToolSettingsValue } from \"../properties/ToolSettingsValue\";\nimport { PrimitiveValue } from \"../properties/Value\";\nimport { Pixel } from \"../rendering\";\nimport { DecorateContext } from \"../ViewContext\";\nimport { ViewRect } from \"../Viewport\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { BeButton, BeButtonEvent, BeModifierKeys, BeTouchEvent, EventHandled, InputSource, CoordinateLockOverrides } from \"./Tool\";\nimport { ManipulatorToolEvent } from \"./ToolAdmin\";\n\n// cSpell:ignore buttongroup\n\n/** The method for choosing elements with the [[SelectionTool]]\n * @public\n */\nexport enum SelectionMethod {\n  /** Identify element(s) by picking for drag selection (inside/overlap for drag box selection determined by point direction and shift key) */\n  Pick,\n  /** Identify elements by overlap with crossing line */\n  Line,\n  /** Identify elements by box selection (inside/overlap for box selection determined by point direction and shift key) */\n  Box,\n}\n\n/** The mode for choosing elements with the [[SelectionTool]]\n * @public\n */\nexport enum SelectionMode {\n  /** Identified elements replace the current selection set (use control key to add or remove) */\n  Replace,\n  /** Identified elements are added to the current selection set */\n  Add,\n  /** Identified elements are removed from the current selection set */\n  Remove,\n}\n\n/** The processing method to use to update the current selection.\n * @public\n */\nexport enum SelectionProcessing {\n  /** Add element to selection. */\n  AddElementToSelection,\n  /** Remove element from selection. */\n  RemoveElementFromSelection,\n  /** If element is in selection remove it, else add it. */\n  InvertElementInSelection,\n  /** Replace current selection with element. */\n  ReplaceSelectionWithElement,\n}\n\n/** Tool for picking a set of elements of interest, selected by the user.\n * @public\n */\nexport class SelectionTool extends PrimitiveTool {\n  public static hidden = false;\n  public static toolId = \"Select\";\n  protected _isSelectByPoints = false;\n  protected _isSuspended = false;\n  protected readonly _points: Point3d[] = [];\n  private _selectionMethodValue = new ToolSettingsValue(SelectionMethod.Pick);\n  private _selectionModeValue = new ToolSettingsValue(SelectionMode.Replace);\n\n  public requireWriteableTarget(): boolean { return false; }\n  public autoLockTarget(): void { } // NOTE: For selecting elements we only care about iModel, so don't lock target model automatically.\n\n  protected wantSelectionClearOnMiss(_ev: BeButtonEvent): boolean { return SelectionMode.Replace === this.selectionMode; }\n  protected wantEditManipulators(): boolean { return SelectionMethod.Pick === this.selectionMethod; }\n  protected wantPickableDecorations(): boolean { return this.wantEditManipulators(); } // Allow pickable decorations selection to be independent of manipulators...\n  protected wantToolSettings(): boolean { return false; }\n\n  public get selectionMethod(): SelectionMethod { return this._selectionMethodValue.value as SelectionMethod; }\n  public set selectionMethod(method: SelectionMethod) { this._selectionMethodValue.value = method; }\n  public get selectionMode(): SelectionMode { return this._selectionModeValue.value as SelectionMode; }\n  public set selectionMode(mode: SelectionMode) { this._selectionModeValue.value = mode; }\n\n  private static methodsMessage(str: string) { return IModelApp.i18n.translate(\"CoreTools:tools.ElementSet.SelectionMethods.\" + str); }\n  private static _methodsName = \"selectionMethods\";\n  /* The property descriptions used to generate ToolSettings UI. */\n  private static _getMethodsDescription(): PropertyDescription {\n    return {\n      name: SelectionTool._methodsName,\n      displayLabel: IModelApp.i18n.translate(\"CoreTools:tools.ElementSet.Prompts.Mode\"),\n      typename: \"enum\",\n      editor: {\n        name: \"enum-buttongroup\",\n        params: [\n          {\n            type: PropertyEditorParamTypes.ButtonGroupData,\n            buttons: [\n              { iconClass: \"icon icon-select-single\" },\n              { iconClass: \"icon icon-select-line\" },\n              { iconClass: \"icon icon-select-box\" },\n            ],\n          },\n        ],\n      },\n      enum: {\n        choices: [\n          { label: SelectionTool.methodsMessage(\"Pick\"), value: SelectionMethod.Pick },\n          { label: SelectionTool.methodsMessage(\"Line\"), value: SelectionMethod.Line },\n          { label: SelectionTool.methodsMessage(\"Box\"), value: SelectionMethod.Box },\n        ],\n      },\n    };\n  }\n\n  private static modesMessage(str: string) { return IModelApp.i18n.translate(\"CoreTools:tools.ElementSet.SelectionModes.\" + str); }\n  private static _modesName = \"selectionModes\";\n  /* The property descriptions used to generate ToolSettings UI. */\n  private static _getModesDescription(): PropertyDescription {\n    return {\n      name: SelectionTool._modesName,\n      displayLabel: \"\",\n      typename: \"enum\",\n      editor: {\n        name: \"enum-buttongroup\",\n        params: [\n          {\n            type: PropertyEditorParamTypes.ButtonGroupData,\n            buttons: [\n              { iconClass: \"icon icon-replace\" },\n              { iconClass: \"icon icon-select-plus\" },\n              {\n                iconClass: \"icon icon-select-minus\",\n                isEnabledFunction: () => { const tool = IModelApp.toolAdmin.activeTool; return tool instanceof PrimitiveTool ? tool.iModel.selectionSet.isActive : false; },\n              },\n            ],\n          },\n          {\n            type: PropertyEditorParamTypes.SuppressEditorLabel,\n            suppressLabelPlaceholder: true,\n          },\n        ],\n      },\n      enum: {\n        choices: [\n          { label: SelectionTool.modesMessage(\"Replace\"), value: SelectionMode.Replace },\n          { label: SelectionTool.modesMessage(\"Add\"), value: SelectionMode.Add },\n          { label: SelectionTool.modesMessage(\"Remove\"), value: SelectionMode.Remove },\n        ],\n      },\n    };\n  }\n\n  protected showPrompt(mode: SelectionMode, method: SelectionMethod): void {\n    let msg = \"IdentifyElement\";\n    switch (mode) {\n      case SelectionMode.Replace:\n        switch (method) {\n          case SelectionMethod.Line:\n            msg = \"IdentifyLine\";\n            break;\n          case SelectionMethod.Box:\n            msg = \"IdentifyBox\";\n            break;\n        }\n        break;\n      case SelectionMode.Add:\n        switch (method) {\n          case SelectionMethod.Pick:\n            msg = \"IdentifyElementAdd\";\n            break;\n          case SelectionMethod.Line:\n            msg = \"IdentifyLineAdd\";\n            break;\n          case SelectionMethod.Box:\n            msg = \"IdentifyBoxAdd\";\n            break;\n        }\n        break;\n      case SelectionMode.Remove:\n        switch (method) {\n          case SelectionMethod.Pick:\n            msg = \"IdentifyElementRemove\";\n            break;\n          case SelectionMethod.Line:\n            msg = \"IdentifyLineRemove\";\n            break;\n          case SelectionMethod.Box:\n            msg = \"IdentifyBoxRemove\";\n            break;\n        }\n        break;\n    }\n\n    IModelApp.notifications.outputPromptByKey(\"CoreTools:tools.ElementSet.Prompts.\" + msg);\n  }\n\n  protected initSelectTool(): void {\n    const method = this.selectionMethod;\n    const mode = this.selectionMode;\n    const enableLocate = SelectionMethod.Pick === method;\n\n    this._isSelectByPoints = false;\n    this._points.length = 0;\n\n    this.initLocateElements(enableLocate, false, enableLocate ? \"default\" : IModelApp.viewManager.crossHairCursor, CoordinateLockOverrides.All);\n    IModelApp.locateManager.options.allowDecorations = true; // Always locate to display tool tip even if we reject for adding to selection set...\n    this.showPrompt(mode, method);\n  }\n\n  public updateSelection(elementId: Id64Arg, process: SelectionProcessing): boolean {\n    let returnValue = false;\n    switch (process) {\n      case SelectionProcessing.AddElementToSelection:\n        returnValue = this.iModel.selectionSet.add(elementId);\n        break;\n      case SelectionProcessing.RemoveElementFromSelection:\n        returnValue = this.iModel.selectionSet.remove(elementId);\n        break;\n      case SelectionProcessing.InvertElementInSelection: // (if element is in selection remove it else add it.)\n        returnValue = this.iModel.selectionSet.invert(elementId);\n        break;\n      case SelectionProcessing.ReplaceSelectionWithElement:\n        this.iModel.selectionSet.replace(elementId);\n        returnValue = true;\n        break;\n      default:\n        return false;\n    }\n    // always force UI to sync display of options since the select option of Remove should only be enabled if the selection set has elements.\n    if (returnValue)\n      this.syncSelectionMode();\n    return returnValue;\n  }\n\n  public async processSelection(elementId: Id64Arg, process: SelectionProcessing): Promise<boolean> { return this.updateSelection(elementId, process); }\n\n  protected useOverlapSelection(ev: BeButtonEvent): boolean {\n    if (undefined === ev.viewport)\n      return false;\n    const pt1 = ev.viewport.worldToView(this._points[0]);\n    const pt2 = ev.viewport.worldToView(ev.point);\n    const overlapMode = (pt1.x > pt2.x);\n    return (ev.isShiftKey ? !overlapMode : overlapMode); // Shift inverts inside/overlap selection...\n  }\n\n  private selectByPointsDecorate(context: DecorateContext): void {\n    if (!this._isSelectByPoints)\n      return;\n\n    const ev = new BeButtonEvent();\n    IModelApp.toolAdmin.fillEventFromCursorLocation(ev);\n    if (undefined === ev.viewport)\n      return;\n\n    const vp = context.viewport!;\n    const bestContrastIsBlack = (ColorDef.black === vp.getContrastToBackgroundColor());\n    const crossingLine = (SelectionMethod.Line === this.selectionMethod || (SelectionMethod.Pick === this.selectionMethod && BeButton.Reset === ev.button));\n    const overlapSelection = (crossingLine || this.useOverlapSelection(ev));\n\n    const position = vp.worldToView(this._points[0]); position.x = Math.floor(position.x) + 0.5; position.y = Math.floor(position.y) + 0.5;\n    const position2 = vp.worldToView(ev.point); position2.x = Math.floor(position2.x) + 0.5; position2.y = Math.floor(position2.y) + 0.5;\n    const offset = position2.minus(position);\n\n    const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n      ctx.strokeStyle = bestContrastIsBlack ? \"black\" : \"white\";\n      ctx.lineWidth = 1;\n      if (overlapSelection) ctx.setLineDash([5, 5]);\n      if (crossingLine) {\n        ctx.beginPath();\n        ctx.moveTo(0, 0);\n        ctx.lineTo(offset.x, offset.y);\n        ctx.stroke();\n      } else {\n        ctx.strokeRect(0, 0, offset.x, offset.y);\n        ctx.fillStyle = bestContrastIsBlack ? \"rgba(0,0,0,.06)\" : \"rgba(255,255,255,.06)\";\n        ctx.fillRect(0, 0, offset.x, offset.y);\n      }\n    };\n    context.addCanvasDecoration({ position, drawDecoration });\n  }\n\n  protected selectByPointsProcess(origin: Point3d, corner: Point3d, ev: BeButtonEvent, method: SelectionMethod, overlap: boolean) {\n    const vp = ev.viewport;\n    if (!vp)\n      return;\n    const pts: Point2d[] = [];\n    pts[0] = new Point2d(Math.floor(origin.x + 0.5), Math.floor(origin.y + 0.5));\n    pts[1] = new Point2d(Math.floor(corner.x + 0.5), Math.floor(corner.y + 0.5));\n    const range = Range2d.createArray(pts);\n\n    const rect = new ViewRect();\n    rect.initFromRange(range);\n    vp.readPixels(rect, Pixel.Selector.Feature, (pixels) => {\n      if (undefined === pixels)\n        return;\n\n      let contents = new Set<string>();\n      const testPoint = Point2d.createZero();\n\n      if (SelectionMethod.Box === method) {\n        const outline = overlap ? undefined : new Set<string>();\n        const offset = range.clone();\n        offset.expandInPlace(-2);\n        for (testPoint.x = range.low.x; testPoint.x <= range.high.x; ++testPoint.x) {\n          for (testPoint.y = range.low.y; testPoint.y <= range.high.y; ++testPoint.y) {\n            const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n            if (undefined === pixel || undefined === pixel.elementId || Id64.isInvalid(pixel.elementId))\n              continue; // no geometry at this location...\n            if (undefined !== outline && !offset.containsPoint(testPoint))\n              outline.add(pixel.elementId.toString());\n            else\n              contents.add(pixel.elementId.toString());\n          }\n        }\n        if (undefined !== outline && 0 !== outline.size) {\n          const inside = new Set<string>();\n          contents.forEach((id) => { if (!outline.has(id)) inside.add(id); });\n          contents = inside;\n        }\n      } else {\n        const closePoint = Point2d.createZero();\n        for (testPoint.x = range.low.x; testPoint.x <= range.high.x; ++testPoint.x) {\n          for (testPoint.y = range.low.y; testPoint.y <= range.high.y; ++testPoint.y) {\n            const pixel = pixels.getPixel(testPoint.x, testPoint.y);\n            if (undefined === pixel || undefined === pixel.elementId || Id64.isInvalid(pixel.elementId))\n              continue; // no geometry at this location...\n            const fraction = testPoint.fractionOfProjectionToLine(pts[0], pts[1], 0.0);\n            pts[0].interpolate(fraction, pts[1], closePoint);\n            if (closePoint.distance(testPoint) < 1.5)\n              contents.add(pixel.elementId.toString());\n          }\n        }\n      }\n\n      if (!this.wantPickableDecorations())\n        contents.forEach((id) => { if (Id64.isTransient(id)) contents.delete(id); });\n\n      if (0 === contents.size) {\n        if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev)) {\n          this.iModel.selectionSet.emptyAll();\n          this.syncSelectionMode();\n        }\n        return;\n      }\n\n      switch (this.selectionMode) {\n        case SelectionMode.Replace:\n          if (!ev.isControlKey)\n            this.processSelection(contents, SelectionProcessing.ReplaceSelectionWithElement); // tslint:disable-line:no-floating-promises\n          else\n            this.processSelection(contents, SelectionProcessing.InvertElementInSelection); // tslint:disable-line:no-floating-promises\n          break;\n        case SelectionMode.Add:\n          this.processSelection(contents, SelectionProcessing.AddElementToSelection); // tslint:disable-line:no-floating-promises\n          break;\n        case SelectionMode.Remove:\n          this.processSelection(contents, SelectionProcessing.RemoveElementFromSelection); // tslint:disable-line:no-floating-promises\n          break;\n      }\n    }, true);\n  }\n\n  protected selectByPointsStart(ev: BeButtonEvent): boolean {\n    if (BeButton.Data !== ev.button && BeButton.Reset !== ev.button)\n      return false;\n    this._points.length = 0;\n    this._points.push(ev.point.clone());\n    this._isSelectByPoints = true;\n    IModelApp.accuSnap.enableLocate(false);\n    IModelApp.toolAdmin.setLocateCircleOn(false);\n    return true;\n  }\n\n  protected selectByPointsEnd(ev: BeButtonEvent): boolean {\n    if (!this._isSelectByPoints)\n      return false;\n\n    const vp = ev.viewport;\n    if (vp === undefined) {\n      this.initSelectTool();\n      return false;\n    }\n\n    const origin = vp.worldToView(this._points[0]);\n    const corner = vp.worldToView(ev.point);\n    if (SelectionMethod.Line === this.selectionMethod || (SelectionMethod.Pick === this.selectionMethod && BeButton.Reset === ev.button))\n      this.selectByPointsProcess(origin, corner, ev, SelectionMethod.Line, true);\n    else\n      this.selectByPointsProcess(origin, corner, ev, SelectionMethod.Box, this.useOverlapSelection(ev));\n\n    this.initSelectTool();\n    vp.invalidateDecorations();\n    return true;\n  }\n\n  public async onMouseMotion(ev: BeButtonEvent): Promise<void> {\n    if (undefined !== ev.viewport && this._isSelectByPoints)\n      ev.viewport.invalidateDecorations();\n  }\n\n  public async selectDecoration(ev: BeButtonEvent, currHit?: HitDetail): Promise<EventHandled> {\n    if (undefined === currHit)\n      currHit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n\n    if (undefined !== currHit && !currHit.isElementHit)\n      return IModelApp.viewManager.onDecorationButtonEvent(currHit, ev);\n\n    return EventHandled.No;\n  }\n\n  public async onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled> {\n    IModelApp.accuSnap.clear(); // Need to test hit at start drag location, not current AccuSnap...\n    if (EventHandled.Yes === await this.selectDecoration(ev))\n      return EventHandled.Yes;\n    if (InputSource.Touch === ev.inputSource && SelectionMethod.Pick === this.selectionMethod)\n      return EventHandled.No; // Require method change for line/box selection...allow IdleTool to handle touch move...\n    return this.selectByPointsStart(ev) ? EventHandled.Yes : EventHandled.No;\n  }\n\n  public async onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled> {\n    return this.selectByPointsEnd(ev) ? EventHandled.Yes : EventHandled.No;\n  }\n\n  public async onDataButtonUp(ev: BeButtonEvent): Promise<EventHandled> {\n    if (undefined === ev.viewport)\n      return EventHandled.No;\n\n    if (this.selectByPointsEnd(ev))\n      return EventHandled.Yes;\n\n    if (SelectionMethod.Pick !== this.selectionMethod) {\n      if (!ev.isControlKey && this.wantSelectionClearOnMiss(ev)) {\n        this.iModel.selectionSet.emptyAll();\n        this.syncSelectionMode();\n      }\n      if (InputSource.Touch !== ev.inputSource)\n        this.selectByPointsStart(ev); // Require touch move and not tap to start crossing line/box selection...\n      return EventHandled.Yes;\n    }\n\n    const hit = await IModelApp.locateManager.doLocate(new LocateResponse(), true, ev.point, ev.viewport, ev.inputSource);\n    if (hit !== undefined) {\n      if (EventHandled.Yes === await this.selectDecoration(ev, hit))\n        return EventHandled.Yes;\n\n      switch (this.selectionMode) {\n        case SelectionMode.Replace:\n          this.processSelection(hit.sourceId, ev.isControlKey ? SelectionProcessing.InvertElementInSelection : SelectionProcessing.ReplaceSelectionWithElement); // tslint:disable-line:no-floating-promises\n          break;\n\n        case SelectionMode.Add:\n          this.processSelection(hit.sourceId, SelectionProcessing.AddElementToSelection); // tslint:disable-line:no-floating-promises\n          break;\n\n        case SelectionMode.Remove:\n          this.processSelection(hit.sourceId, SelectionProcessing.RemoveElementFromSelection); // tslint:disable-line:no-floating-promises\n          break;\n      }\n      return EventHandled.Yes;\n    }\n\n    if (!ev.isControlKey && 0 !== this.iModel.selectionSet.size && this.wantSelectionClearOnMiss(ev)) {\n      this.iModel.selectionSet.emptyAll();\n      this.syncSelectionMode();\n    }\n\n    return EventHandled.Yes;\n  }\n\n  public async onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled> {\n    if (this._isSelectByPoints) {\n      if (undefined !== ev.viewport)\n        ev.viewport.invalidateDecorations();\n      this.initSelectTool();\n      return EventHandled.Yes;\n    }\n\n    // Check for overlapping hits...\n    const lastHit = SelectionMode.Remove === this.selectionMode ? undefined : IModelApp.locateManager.currHit;\n    if (lastHit && this.iModel.selectionSet.has(lastHit.sourceId)) {\n      const autoHit = IModelApp.accuSnap.currHit;\n\n      // Play nice w/auto-locate, only remove previous hit if not currently auto-locating or over previous hit\n      if (undefined === autoHit || autoHit.isSameHit(lastHit)) {\n        const response = new LocateResponse();\n        const nextHit = await IModelApp.locateManager.doLocate(response, false, ev.point, ev.viewport, ev.inputSource);\n\n        // remove element(s) previously selected if in replace mode, or if we have a next element in add mode\n        if (SelectionMode.Replace === this.selectionMode || undefined !== nextHit)\n          this.processSelection(lastHit.sourceId, SelectionProcessing.RemoveElementFromSelection); // tslint:disable-line:no-floating-promises\n\n        // add element(s) located via reset button\n        if (undefined !== nextHit)\n          this.processSelection(nextHit.sourceId, SelectionProcessing.AddElementToSelection); // tslint:disable-line:no-floating-promises\n        return EventHandled.Yes;\n      }\n    }\n\n    if (EventHandled.Yes === await this.selectDecoration(ev, IModelApp.accuSnap.currHit))\n      return EventHandled.Yes;\n\n    IModelApp.accuSnap.resetButton(); // tslint:disable-line:no-floating-promises\n    return EventHandled.Yes;\n  }\n\n  public onSuspend(): void { this._isSuspended = true; if (this.wantEditManipulators()) IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ManipulatorToolEvent.Suspend); }\n  public onUnsuspend(): void { this._isSuspended = false; if (this.wantEditManipulators()) IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ManipulatorToolEvent.Unsuspend); this.showPrompt(this.selectionMode, this.selectionMethod); } // TODO: Tool assistance...\n\n  public async onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled> {\n    if (startEv.isSingleTouch && !this._isSelectByPoints)\n      await IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev);\n    return (this._isSuspended || this._isSelectByPoints) ? EventHandled.Yes : EventHandled.No;\n  }\n\n  public async onTouchMove(ev: BeTouchEvent): Promise<void> { if (this._isSelectByPoints) return IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }\n  public async onTouchComplete(ev: BeTouchEvent): Promise<void> { if (this._isSelectByPoints) return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }\n  public async onTouchCancel(ev: BeTouchEvent): Promise<void> { if (this._isSelectByPoints) return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, BeButton.Reset); }\n\n  public decorate(context: DecorateContext): void { this.selectByPointsDecorate(context); }\n\n  public async onModifierKeyTransition(_wentDown: boolean, modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled> {\n    return (modifier === BeModifierKeys.Shift && this._isSelectByPoints) ? EventHandled.Yes : EventHandled.No;\n  }\n\n  public async filterHit(hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus> {\n    if (!this.wantPickableDecorations() && !hit.isElementHit)\n      return LocateFilterStatus.Reject;\n\n    const mode = this.selectionMode;\n    if (SelectionMode.Replace === mode)\n      return LocateFilterStatus.Accept;\n\n    const isSelected = this.iModel.selectionSet.has(hit.sourceId);\n    return ((SelectionMode.Add === mode ? !isSelected : isSelected) ? LocateFilterStatus.Accept : LocateFilterStatus.Reject);\n  }\n\n  public onRestartTool(): void { this.exitTool(); }\n\n  public onCleanup(): void {\n    if (this.wantEditManipulators())\n      IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ManipulatorToolEvent.Stop);\n  }\n\n  public onPostInstall(): void {\n    super.onPostInstall();\n    if (!this.targetView)\n      return;\n    if (this.wantEditManipulators())\n      IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, ManipulatorToolEvent.Start);\n    this.initSelectTool();\n  }\n\n  public static startTool(): boolean { return new SelectionTool().run(); }\n\n  private syncSelectionMode(): void {\n    if (SelectionMode.Remove === this.selectionMode && !this.iModel.selectionSet.isActive) {\n      // No selection active resetting selection mode since there is nothing to Remove\n      this.selectionMode = SelectionMode.Replace;\n      this.initSelectTool();\n    }\n    if (this.wantToolSettings()) {\n      const syncMode: ToolSettingsPropertySyncItem = { value: this._selectionModeValue.clone(), propertyName: SelectionTool._modesName };\n      IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, syncMode);\n      this.syncToolSettingsProperties([syncMode]);\n    }\n  }\n\n  /** Used to supply DefaultToolSettingProvider with a list of properties to use to generate ToolSettings.  If undefined then no ToolSettings will be displayed\n   * @beta\n   */\n  public supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined {\n    if (!this.wantToolSettings())\n      return undefined;\n\n    // load latest values from session\n    IModelApp.toolAdmin.toolSettingsState.initializeToolSettingProperties(this.toolId, [\n      { propertyName: SelectionTool._methodsName, value: this._selectionMethodValue },\n      { propertyName: SelectionTool._modesName, value: this._selectionModeValue },\n    ]);\n\n    // Make sure a mode of SelectionMode.Remove is valid\n    if (SelectionMode.Remove === this.selectionMode && !this.iModel.selectionSet.isActive) {\n      this.selectionMode = SelectionMode.Replace;\n    }\n\n    const toolSettings = new Array<ToolSettingsPropertyRecord>();\n    // generate 3 columns - label will be placed in column 0 and button group editors in columns 1 and 2.\n    toolSettings.push(new ToolSettingsPropertyRecord(this._selectionMethodValue.clone() as PrimitiveValue, SelectionTool._getMethodsDescription(), { rowPriority: 0, columnIndex: 1 }));\n    toolSettings.push(new ToolSettingsPropertyRecord(this._selectionModeValue.clone() as PrimitiveValue, SelectionTool._getModesDescription(), { rowPriority: 0, columnIndex: 2 }));\n    return toolSettings;\n  }\n\n  /** Used to send changes from UI back to Tool\n   * @beta\n   */\n  public applyToolSettingPropertyChange(updatedValue: ToolSettingsPropertySyncItem): boolean {\n    let changed = false;\n    if (updatedValue.propertyName === SelectionTool._methodsName) {\n      const saveWantManipulators = this.wantEditManipulators();\n      if (this._selectionMethodValue.update(updatedValue.value)) {\n        const currWantManipulators = this.wantEditManipulators();\n        if (this.wantToolSettings())\n          IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: SelectionTool._methodsName, value: this._selectionMethodValue });\n        if (saveWantManipulators !== currWantManipulators)\n          IModelApp.toolAdmin.manipulatorToolEvent.raiseEvent(this, currWantManipulators ? ManipulatorToolEvent.Start : ManipulatorToolEvent.Stop);\n        changed = true;\n      }\n    }\n    if (updatedValue.propertyName === SelectionTool._modesName) {\n      if (this._selectionModeValue.update(updatedValue.value)) {\n        if (this.wantToolSettings())\n          IModelApp.toolAdmin.toolSettingsState.saveToolSettingProperty(this.toolId, { propertyName: SelectionTool._modesName, value: this._selectionModeValue });\n        changed = true;\n      }\n    }\n    if (changed)\n      this.initSelectTool();\n    return true; // return true if change is valid\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { BeDuration } from \"@bentley/bentleyjs-core\";\nimport { Point2d, Point3d, PolygonOps, Angle, Constant } from \"@bentley/geometry-core\";\nimport { GeometryStreamProps, IModelError } from \"@bentley/imodeljs-common\";\nimport { I18NNamespace } from \"@bentley/imodeljs-i18n\";\nimport { LocateFilterStatus, LocateResponse } from \"../ElementLocateManager\";\nimport { FuzzySearch, FuzzySearchResults } from \"../FuzzySearch\";\nimport { HitDetail } from \"../HitDetail\";\nimport { IModelApp } from \"../IModelApp\";\nimport { ToolSettingsPropertyRecord, ToolSettingsPropertySyncItem } from \"../properties/ToolSettingsValue\";\nimport { DecorateContext, DynamicsContext } from \"../ViewContext\";\nimport { ScreenViewport, Viewport } from \"../Viewport\";\n\n/** Settings that control the behavior of built-in tools. Applications may modify these values.\n * @public\n */\nexport class ToolSettings {\n  /** Duration of animations of viewing operations. */\n  public static animationTime = BeDuration.fromMilliseconds(260);\n  /** Two tap must be within this period to be a double tap. */\n  public static doubleTapTimeout = BeDuration.fromMilliseconds(250);\n  /** Two clicks must be within this period to be a double click. */\n  public static doubleClickTimeout = BeDuration.fromMilliseconds(500);\n  /** Number of screen inches of movement allowed between clicks to still qualify as a double-click.  */\n  public static doubleClickToleranceInches = 0.05;\n  /** Duration without movement before a no-motion event is generated. */\n  public static noMotionTimeout = BeDuration.fromMilliseconds(10);\n  /** If true, view rotation tool keeps the up vector (worldZ) aligned with screenY. */\n  public static preserveWorldUp = true;\n  /** Delay with a touch on the surface before a move operation begins. */\n  public static touchMoveDelay = BeDuration.fromMilliseconds(50);\n  /** Delay with the mouse down before a drag operation begins. */\n  public static startDragDelay = BeDuration.fromMilliseconds(110);\n  /** Distance in screen inches a touch point must move before being considered motion. */\n  public static touchMoveDistanceInches = 0.15;\n  /** Distance in screen inches the cursor must move before a drag operation begins. */\n  public static startDragDistanceInches = 0.15;\n  /** Radius in screen inches to search for elements that anchor viewing operations. */\n  public static viewToolPickRadiusInches = 0.20;\n  /** Camera angle enforced for walk tool. */\n  public static walkCameraAngle = Angle.createDegrees(75.6);\n  /** Whether the walk tool enforces worldZ be aligned with screenY */\n  public static walkEnforceZUp = false;\n  /** Speed, in meters per second, for the walk tool. */\n  public static walkVelocity = 3.5;\n  /** Scale factor applied for wheel events with \"per-line\" modifier. */\n  public static wheelLineFactor = 40;\n  /** Scale factor applied for wheel events with \"per-page\" modifier. */\n  public static wheelPageFactor = 120;\n  /** When the zoom-with-wheel tool (with camera enabled) gets closer than this distance to an obstacle, it \"bumps\" through. */\n  public static wheelZoomBumpDistance = Constant.oneCentimeter;\n  /** Scale factor for zooming with mouse wheel. */\n  public static wheelZoomRatio = 1.75;\n}\n\n/** @public */\nexport type ToolType = typeof Tool;\n\n/** @public */\nexport type ToolList = ToolType[];\n\n/** @public */\nexport enum BeButton { Data = 0, Reset = 1, Middle = 2 }\n\n/** @public */\nexport enum CoordinateLockOverrides {\n  None = 0,\n  ACS = 1 << 1,\n  Grid = 1 << 2,     // also overrides unit lock\n  All = 0xffff,\n}\n\n/** The *source* that generated an event.\n * @public\n */\nexport enum InputSource {\n  /** Source not defined */\n  Unknown = 0,\n  /** From a mouse or other pointing device */\n  Mouse = 1,\n  /** From a touch screen */\n  Touch = 2,\n}\n\n/** The *source* that generated a coordinate.\n * @public\n */\nexport enum CoordSource {\n  /** Event was created by an action from the user */\n  User = 0,\n  /** Event was created by a program or by a precision keyin */\n  Precision = 1,\n  /** Event was created by a tentative point */\n  TentativePoint = 2,\n  /** Event was created by snapping to an element */\n  ElemSnap = 3,\n}\n\n/** Numeric mask for a set of modifier keys (control, shift, and alt).\n * @public\n */\nexport enum BeModifierKeys { None = 0, Control = 1 << 0, Shift = 1 << 1, Alt = 1 << 2 }\n\n/** @public */\nexport class BeButtonState {\n  private readonly _downUorPt: Point3d = new Point3d();\n  private readonly _downRawPt: Point3d = new Point3d();\n  public downTime: number = 0;\n  public isDown: boolean = false;\n  public isDoubleClick: boolean = false;\n  public isDragging: boolean = false;\n  public inputSource: InputSource = InputSource.Unknown;\n\n  public get downRawPt() { return this._downRawPt; }\n  public set downRawPt(pt: Point3d) { this._downRawPt.setFrom(pt); }\n  public get downUorPt() { return this._downUorPt; }\n  public set downUorPt(pt: Point3d) { this._downUorPt.setFrom(pt); }\n\n  public init(downUorPt: Point3d, downRawPt: Point3d, downTime: number, isDown: boolean, isDoubleClick: boolean, isDragging: boolean, source: InputSource) {\n    this.downUorPt = downUorPt;\n    this.downRawPt = downRawPt;\n    this.downTime = downTime;\n    this.isDown = isDown;\n    this.isDoubleClick = isDoubleClick;\n    this.isDragging = isDragging;\n    this.inputSource = source;\n  }\n}\n\n/** Properties for constructing a BeButtonEvent\n * @public\n */\nexport interface BeButtonEventProps {\n  /** The point for this event, in world coordinates.\n   * @note these coordinates may have been *adjusted* for some reason (e.g. snapping, locks, etc.) from the [[rawPoint]].\n   */\n  point?: Point3d;\n  /** The *raw* (unadjusted) point for this event, in world coordinates. */\n  rawPoint?: Point3d;\n  /** The point, in screen coordinates for this event.\n   * @note generally the z value is not useful, but some 3d pointing devices do supply it.\n   */\n  viewPoint?: Point3d;\n  /** The [[ScreenViewport]] for the BeButtonEvent. If undefined, this event is invalid. */\n  viewport?: ScreenViewport;\n  /** How the coordinate values were generated (either from an action by the user or from a program.) */\n  coordsFrom?: CoordSource;\n  keyModifiers?: BeModifierKeys;\n  /** The mouse button for this event. */\n  button?: BeButton;\n  /** If true, this event was generated from a mouse-down transition, false from a button-up transition. */\n  isDown?: boolean;\n  /** If true, this is the second down in a rapid double-click of the same button. */\n  isDoubleClick?: boolean;\n  /** If true, this event was created by pressing, holding, and then moving a mouse button. */\n  isDragging?: boolean;\n  /** Whether this event came from a pointing device (e.g. mouse) or a touch device. */\n  inputSource?: InputSource;\n}\n\n/** Object sent to Tools that holds information about button/touch/wheel events.\n * @public\n */\nexport class BeButtonEvent implements BeButtonEventProps {\n  private readonly _point: Point3d = new Point3d();\n  private readonly _rawPoint: Point3d = new Point3d();\n  private readonly _viewPoint: Point3d = new Point3d();\n  /** The [[ScreenViewport]] from which this BeButtonEvent was generated. If undefined, this event is invalid. */\n  public viewport?: ScreenViewport;\n  /** How the coordinate values were generated (either from an action by the user or from a program.) */\n  public coordsFrom = CoordSource.User;\n  /** The keyboard modifiers that were pressed when the event was generated. */\n  public keyModifiers = BeModifierKeys.None;\n  /** If true, this event was generated from a mouse-down transition, false from a button-up transition. */\n  public isDown = false;\n  /** If true, this is the second down in a rapid double-click of the same button. */\n  public isDoubleClick = false;\n  /** If true, this event was created by pressing, holding, and then moving a mouse button. */\n  public isDragging = false;\n  /** The mouse button that created this event. */\n  public button = BeButton.Data;\n  /** Whether this event came from a pointing device (e.g. mouse) or a touch device. */\n  public inputSource = InputSource.Unknown;\n\n  public constructor(props?: BeButtonEventProps) { if (props) this.init(props); }\n\n  /** Determine whether this BeButtonEvent has valid data.\n   * @note BeButtonEvents may be constructed as \"blank\", and are not considered to hold valid data unless the [[viewport]] member is defined.\n   */\n  public get isValid(): boolean { return this.viewport !== undefined; }\n  /** The point for this event, in world coordinates.\n   * @note these coordinates may have been *adjusted* for some reason (e.g. snapping, locks, etc.) from the [[rawPoint]].\n   */\n  public get point() { return this._point; }\n  public set point(pt: Point3d) { this._point.setFrom(pt); }\n  /** The *raw* (unadjusted) point for this event, in world coordinates. */\n  public get rawPoint() { return this._rawPoint; }\n  public set rawPoint(pt: Point3d) { this._rawPoint.setFrom(pt); }\n  /** The point, in screen coordinates for this event.\n   * @note generally the z value is not useful, but some 3d pointing devices do supply it.\n   */\n  public get viewPoint() { return this._viewPoint; }\n  public set viewPoint(pt: Point3d) { this._viewPoint.setFrom(pt); }\n\n  /** Mark this BeButtonEvent as invalid. Can only become valid again by calling [[init]] */\n  public invalidate() { this.viewport = undefined; }\n\n  /** Initialize the values of this BeButtonEvent. */\n  public init(props: BeButtonEventProps) {\n    if (undefined !== props.point) this.point = props.point;\n    if (undefined !== props.rawPoint) this.rawPoint = props.rawPoint;\n    if (undefined !== props.viewPoint) this.viewPoint = props.viewPoint;\n    if (undefined !== props.viewport) this.viewport = props.viewport;\n    if (undefined !== props.coordsFrom) this.coordsFrom = props.coordsFrom;\n    if (undefined !== props.keyModifiers) this.keyModifiers = props.keyModifiers;\n    if (undefined !== props.isDown) this.isDown = props.isDown;\n    if (undefined !== props.isDoubleClick) this.isDoubleClick = props.isDoubleClick;\n    if (undefined !== props.isDragging) this.isDragging = props.isDragging;\n    if (undefined !== props.button) this.button = props.button;\n    if (undefined !== props.inputSource) this.inputSource = props.inputSource;\n  }\n\n  /** Determine whether the control key was pressed  */\n  public get isControlKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Control); }\n  /** Determine whether the shift key was pressed  */\n  public get isShiftKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Shift); }\n  /** Determine whether the alt key was pressed  */\n  public get isAltKey() { return 0 !== (this.keyModifiers & BeModifierKeys.Alt); }\n\n  /** Copy the values from another BeButtonEvent into this BeButtonEvent */\n  public setFrom(src: BeButtonEvent): this {\n    this.point = src.point;\n    this.rawPoint = src.rawPoint;\n    this.viewPoint = src.viewPoint;\n    this.viewport = src.viewport;\n    this.coordsFrom = src.coordsFrom;\n    this.keyModifiers = src.keyModifiers;\n    this.isDown = src.isDown;\n    this.isDoubleClick = src.isDoubleClick;\n    this.isDragging = src.isDragging;\n    this.button = src.button;\n    this.inputSource = src.inputSource;\n    return this;\n  }\n  /** Make a copy of this BeButtonEvent. */\n  public clone(): this { return new (this.constructor as typeof BeButtonEvent)(this) as this; }\n}\n\n/** Properties for initializing a BeTouchEvent\n * @public\n */\nexport interface BeTouchEventProps extends BeButtonEventProps {\n  touchEvent: TouchEvent;\n}\n\n/** A ButtonEvent generated by touch input.\n * @public\n */\nexport class BeTouchEvent extends BeButtonEvent implements BeTouchEventProps {\n  public tapCount: number = 0;\n  public touchEvent: TouchEvent;\n  public get touchCount(): number { return this.touchEvent.targetTouches.length; }\n  public get isSingleTouch(): boolean { return 1 === this.touchCount; }\n  public get isTwoFingerTouch(): boolean { return 2 === this.touchCount; }\n  public get isSingleTap(): boolean { return 1 === this.tapCount && 1 === this.touchCount; }\n  public get isDoubleTap(): boolean { return 2 === this.tapCount && 1 === this.touchCount; }\n  public get isTwoFingerTap(): boolean { return 1 === this.tapCount && 2 === this.touchCount; }\n  public constructor(props: BeTouchEventProps) {\n    super(props);\n    this.touchEvent = props.touchEvent;\n  }\n\n  public setFrom(src: BeTouchEvent): this {\n    super.setFrom(src);\n    this.touchEvent = src.touchEvent;\n    this.tapCount = src.tapCount;\n    return this;\n  }\n  public static getTouchPosition(touch: Touch, vp: ScreenViewport): Point2d {\n    const rect = vp.getClientRect();\n    return Point2d.createFrom({ x: touch.clientX - rect.left, y: touch.clientY - rect.top });\n  }\n  public static getTouchListCentroid(list: TouchList, vp: ScreenViewport): Point2d | undefined {\n    switch (list.length) {\n      case 0: {\n        return undefined;\n      }\n      case 1: {\n        return this.getTouchPosition(list[0], vp);\n      }\n      case 2: {\n        return this.getTouchPosition(list[0], vp).interpolate(0.5, this.getTouchPosition(list[1], vp));\n      }\n      default: {\n        const points: Point2d[] = [];\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < list.length; i++) {\n          points.push(this.getTouchPosition(list[i], vp));\n        }\n        const centroid = Point2d.createZero();\n        PolygonOps.centroidAndAreaXY(points, centroid);\n        return centroid;\n      }\n    }\n  }\n  public static findTouchById(list: TouchList, id: number): Touch | undefined {\n    // tslint:disable-next-line:prefer-for-of\n    for (let i = 0; i < list.length; i++) {\n      if (id === list[i].identifier)\n        return list[i];\n    }\n    return undefined;\n  }\n}\n\n/** Properties for constructing a BeWheelEvent\n * @public\n */\nexport interface BeWheelEventProps extends BeButtonEventProps {\n  wheelDelta?: number;\n}\n/** A BeButtonEvent generated by movement of a mouse wheel.\n * @note wheel events include mouse location.\n * @public\n */\nexport class BeWheelEvent extends BeButtonEvent implements BeWheelEventProps {\n  public wheelDelta: number = 0;\n  public constructor(props?: BeWheelEventProps) {\n    super(props);\n    if (props && props.wheelDelta !== undefined) this.wheelDelta = props.wheelDelta;\n  }\n  public setFrom(src: BeWheelEvent): this {\n    super.setFrom(src);\n    this.wheelDelta = src.wheelDelta;\n    return this;\n  }\n}\n\n/** Base Tool class for writing an immediate tool that executes it's assigned task immediately without further input.\n * @see [[InteractiveTool]] for a base Tool class to handle user input events from a Viewport.\n * @see [Tools]($docs/learning/frontend/tools.md)\n * @public\n */\nexport class Tool {\n  /** If true, this Tool will not appear in the list from [[ToolRegistry.getToolList]]. This should be overridden in subclasses to hide them. */\n  public static hidden = false;\n  /** The unique string that identifies this tool. This must be overridden in every subclass. */\n  public static toolId = \"\";\n  /** The [I18NNamespace]($i18n) that provides localized strings for this Tool. Subclasses should override this. */\n  public static namespace: I18NNamespace;\n  public constructor(..._args: any[]) { }\n\n  private static _keyin?: string;\n  private static _flyover?: string;\n  private static _description?: string;\n  private static get _localizeBase() { return this.namespace.name + \":tools.\" + this.toolId; }\n  private static get _keyinKey() { return this._localizeBase + \".keyin\"; }\n  private static get _flyoverKey() { return this._localizeBase + \".flyover\"; }\n  private static get _descriptionKey() { return this._localizeBase + \".description\"; }\n\n  /**\n   * Register this Tool class with the ToolRegistry.\n   * @param namespace optional namespace to supply to ToolRegistry.register. If undefined, use namespace from superclass.\n   */\n  public static register(namespace?: I18NNamespace) { IModelApp.tools.register(this, namespace); }\n\n  /**\n   * Get the localized keyin string for this Tool class. This returns the value of \"tools.\" + this.toolId + \".keyin\" from the\n   * .json file for the current locale of its registered Namespace (e.g. \"en/MyApp.json\")\n   */\n  public static get keyin(): string { return this._keyin ? this._keyin : (this._keyin = IModelApp.i18n && IModelApp.i18n.translate(this._keyinKey)); }\n\n  /**\n   * Get the localized flyover for this Tool class. This returns the value of \"tools.\" + this.toolId + \".flyover\" from the\n   * .json file for the current locale of its registered Namespace (e.g. \"en/MyApp.json\"). If that key is not in the localization namespace,\n   * the keyin property is returned.\n   */\n  public static get flyover(): string { return this._flyover ? this._flyover : (this._flyover = IModelApp.i18n && IModelApp.i18n.translate([this._flyoverKey, this._keyinKey])); }\n\n  /**\n   * Get the localized description for this Tool class. This returns the value of \"tools.\" + this.toolId + \".description\" from the\n   * .json file for the current locale of its registered Namespace (e.g. \"en/MyApp.json\"). If that key is not in the localization namespace,\n   * the flyover property is returned.\n   */\n  public static get description(): string { return this._description ? this._description : (this._description = IModelApp.i18n && IModelApp.i18n.translate([this._descriptionKey, this._flyoverKey, this._keyinKey])); }\n\n  /**\n   * Get the toolId string for this Tool class. This string is used to identify the Tool in the ToolRegistry and is used to localize\n   * the keyin, description, etc. from the current locale.\n   */\n  public get toolId(): string { return (this.constructor as ToolType).toolId; }\n\n  /** Get the localized keyin string from this Tool's class */\n  public get keyin(): string { return (this.constructor as ToolType).keyin; }\n\n  /** Get the localized flyover string from this Tool's class */\n  public get flyover(): string { return (this.constructor as ToolType).flyover; }\n\n  /** Get the localized description string from this Tool's class */\n  public get description(): string { return (this.constructor as ToolType).description; }\n\n  /**\n   * Run this instance of a Tool. Subclasses should override to perform some action.\n   * @returns `true` if the tool executed successfully.\n   */\n  public run(..._arg: any[]): boolean { return true; }\n}\n\n/** @public */\nexport enum EventHandled { No = 0, Yes = 1 }\n\n/** A Tool that may be installed, via [[ToolAdmin]], to handle user input. The ToolAdmin manages the currently installed ViewingTool, PrimitiveTool,\n * InputCollector, and IdleTool. Each must derive from this class and there may only be one of each type installed at a time.\n * @public\n */\nexport abstract class InteractiveTool extends Tool {\n\n  /** Used to avoid sending tools up events for which they did not receive the down event. */\n  public receivedDownEvent = false;\n\n  /** Override to execute additional logic when tool is installed. Return false to prevent this tool from becoming active */\n  public onInstall(): boolean { return true; }\n\n  /** Override to execute additional logic after tool becomes active */\n  public onPostInstall(): void { }\n\n  public abstract exitTool(): void;\n\n  /** Override Call to reset tool to initial state */\n  public onReinitialize(): void { }\n\n  /** Invoked when the tool becomes no longer active, to perform additional cleanup logic */\n  public onCleanup(): void { }\n\n  /** Notification of a ViewTool or InputCollector starting and this tool is being suspended.\n   * @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.\n   */\n  public onSuspend(): void { }\n\n  /** Notification of a ViewTool or InputCollector exiting and this tool is being unsuspended.\n   *  @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.\n   */\n  public onUnsuspend(): void { }\n\n  /** Called to support operations on pickable decorations, like snapping. */\n  public testDecorationHit(_id: string): boolean { return false; }\n\n  /** Called to allow snapping to pickable decoration geometry.\n   * @note Snap geometry can be different from decoration geometry (ex. center point of a + symbol). Valid decoration geometry for snapping should be \"stable\" and not change based on the current cursor location.\n   */\n  public getDecorationGeometry(_hit: HitDetail): GeometryStreamProps | undefined { return undefined; }\n\n  /**\n   * Called to allow an active tool to display non-element decorations in overlay mode.\n   * This method is NOT called while the tool is suspended by a viewing tool or input collector.\n   */\n  public decorate(_context: DecorateContext): void { }\n\n  /**\n   * Called to allow a suspended tool to display non-element decorations in overlay mode.\n   * This method is ONLY called when the tool is suspended by a viewing tool or input collector.\n   * @note Applies only to PrimitiveTool and InputCollector, a ViewTool can't be suspended.\n   */\n  public decorateSuspended(_context: DecorateContext): void { }\n\n  /** Invoked when the reset button is pressed.\n   * @return No by default. Sub-classes may ascribe special meaning to this status.\n   * @note To support right-press menus, a tool should put its reset event processing in onResetButtonUp instead of onResetButtonDown.\n   */\n  public async onResetButtonDown(_ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n  /** Invoked when the reset button is released.\n   * @return No by default. Sub-classes may ascribe special meaning to this status.\n   */\n  public async onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  /** Invoked when the data button is pressed.\n   * @return No by default. Sub-classes may ascribe special meaning to this status.\n   */\n  public async onDataButtonDown(_ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n  /** Invoked when the data button is released.\n   * @return No by default. Sub-classes may ascribe special meaning to this status.\n   */\n  public async onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  /** Invoked when the middle mouse button is pressed.\n   * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n   */\n  public async onMiddleButtonDown(_ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  /** Invoked when the middle mouse button is released.\n   * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n   */\n  public async onMiddleButtonUp(_ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  /** Invoked when the cursor is moving */\n  public async onMouseMotion(_ev: BeButtonEvent): Promise<void> { }\n\n  /** Invoked when the cursor is not moving */\n  public async onMouseNoMotion(_ev: BeButtonEvent): Promise<void> { }\n\n  /** Invoked when the cursor was previously moving, and has stopped moving. */\n  public async onMouseMotionStopped(_ev: BeButtonEvent): Promise<void> { }\n\n  /** Invoked when the cursor begins moving while a button is depressed.\n   * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n   */\n  public async onMouseStartDrag(_ev: BeButtonEvent): Promise<EventHandled> { return EventHandled.No; }\n  /** Invoked when the button is released after onMouseStartDrag.\n   * @note default placement tool behavior is to treat press, drag, and release of data button the same as click, click by calling onDataButtonDown.\n   * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n   */\n  public async onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled> { if (BeButton.Data !== ev.button) return EventHandled.No; if (ev.isDown) return this.onDataButtonDown(ev); const downEv = ev.clone(); downEv.isDown = true; return this.onDataButtonDown(downEv); }\n\n  /** Invoked when the mouse wheel moves.\n   * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n   */\n  public async onMouseWheel(_ev: BeWheelEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  /** Called when Control, Shift, or Alt modifier keys are pressed or released.\n   * @param _wentDown up or down key event\n   * @param _modifier The modifier key mask\n   * @param _event The event that caused this call\n   * @return Yes to refresh view decorations or update dynamics.\n   */\n  public async onModifierKeyTransition(_wentDown: boolean, _modifier: BeModifierKeys, _event: KeyboardEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  /** Called when any key is pressed or released.\n   * @param _wentDown up or down key event\n   * @param _keyEvent The KeyboardEvent\n   * @return Yes to prevent further processing of this event\n   * @see [[onModifierKeyTransition]]\n   */\n  public async onKeyTransition(_wentDown: boolean, _keyEvent: KeyboardEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  /** Called when user adds a touch point by placing a finger or stylus on the surface. */\n  public async onTouchStart(_ev: BeTouchEvent): Promise<void> { }\n  /** Called when user removes a touch point by lifting a finger or stylus from the surface. */\n  public async onTouchEnd(_ev: BeTouchEvent): Promise<void> { }\n  /** Called when the last touch point is removed from the surface completing the current gesture. This is a convenience event sent following onTouchEnd when no target touch points remain on the surface. */\n  public async onTouchComplete(_ev: BeTouchEvent): Promise<void> { }\n  /** Called when a touch point is interrupted in some way and needs to be dropped from the list of target touches. */\n  public async onTouchCancel(_ev: BeTouchEvent): Promise<void> { }\n  /** Called when a touch point moves along the surface. */\n  public async onTouchMove(_ev: BeTouchEvent): Promise<void> { }\n\n  /** Called after at least one touch point has moved for an appreciable time and distance along the surface to not be considered a tap.\n   * @param _ev The event that caused this call\n   * @param _startEv The event from the last call to onTouchStart\n   * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n   */\n  public async onTouchMoveStart(_ev: BeTouchEvent, _startEv: BeTouchEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  /** Called when touch point(s) are added and removed from a surface within a small time window without any touch point moving.\n   * @param _ev The event that caused this call\n   * @return Yes if event completely handled by tool and event should not be passed on to the IdleTool.\n   * @note A double or triple tap event will not be preceded by a single tap event.\n   */\n  public async onTouchTap(_ev: BeTouchEvent): Promise<EventHandled> { return EventHandled.No; }\n\n  public isCompatibleViewport(_vp: Viewport, _isSelectedViewChange: boolean): boolean { return true; }\n  public isValidLocation(_ev: BeButtonEvent, _isButtonEvent: boolean): boolean { return true; }\n\n  /**\n   * Called when active view changes. Tool may choose to restart or exit based on current view type.\n   * @param previous The previously active view.\n   * @param current The new active view.\n   */\n  public onSelectedViewportChanged(_previous: Viewport | undefined, _current: Viewport | undefined): void { }\n\n  /**\n   * Invoked before the locate tooltip is displayed to retrieve the information about the located element. Allows the tool to override the toolTip.\n   * @param hit The HitDetail whose info is needed.\n   * @return A Promise for the HTMLElement or string to describe the hit.\n   * @note If you override this method, you may decide whether to call your superclass' implementation or not (it is not required).\n   */\n  public async getToolTip(_hit: HitDetail): Promise<HTMLElement | string> { return _hit.getToolTip(); }\n\n  /** Fill the supplied button event from the current cursor location.   */\n  public getCurrentButtonEvent(ev: BeButtonEvent): void { IModelApp.toolAdmin.fillEventFromCursorLocation(ev); }\n\n  /** Call to find out if dynamics are currently active. */\n  public get isDynamicsStarted(): boolean { return IModelApp.viewManager.inDynamicsMode; }\n\n  /** Call to initialize dynamics mode. While dynamics are active onDynamicFrame will be called. Dynamics are typically only used by a PrimitiveTool that creates or modifies geometric elements. */\n  public beginDynamics(): void { IModelApp.toolAdmin.beginDynamics(); }\n\n  /** Call to terminate dynamics mode. */\n  public endDynamics(): void { IModelApp.toolAdmin.endDynamics(); }\n\n  /** Called to allow Tool to display dynamic elements. */\n  public onDynamicFrame(_ev: BeButtonEvent, _context: DynamicsContext): void { }\n\n  /** Invoked to allow tools to filter which elements can be located.\n   * @return Reject if hit is unacceptable for this tool (fill out response with explanation, if it is defined)\n   */\n  public async filterHit(_hit: HitDetail, _out?: LocateResponse): Promise<LocateFilterStatus> { return LocateFilterStatus.Accept; }\n\n  /** Helper method to keep the view cursor, display of locate circle, and coordinate lock overrides consistent with [[AccuSnap.isLocateEnabled]] and [[AccuSnap.isSnapEnabled]].\n   * @param enableLocate Value to pass to [[AccuSnap.enableLocate]]. Tools that locate elements should always pass true to give the user feedback regarding the element at the current cursor location.\n   * @param enableSnap Optional value to pass to [[AccuSnap.enableSnap]]. Tools that don't care about the element pick location should not pass true. Default is false.\n   * @note User must also have snapping enabled [[AccuSnap.isSnapEnabledByUser]], otherwise [[TentativePoint]] is used to snap.\n   * @param cursor Optional tool specific cursor override. Default is either cross or dynamics cursor depending on whether dynamics are currently active.\n   * @param coordLockOvr Optional tool specific coordinate lock overrides. A tool that only identifies elements and does not use [[BeButtonEvent.point]] can set ToolState.coordLockOvr to CoordinateLockOverrides.ACS\n   * or CoordinateLockOverrides.All, otherwise locate is affected by the input point being first projected to the ACS plane. A tool that will use [[BeButtonEvent.point]], especially those that call [[AccuSnap.enableSnap]]\n   * should honor all locks and leave ToolState.coordLockOvr set to CoordinateLockOverrides.None, the default for ViewTool and PrimitiveTool.\n   */\n  public changeLocateState(enableLocate: boolean, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void {\n    if (undefined !== cursor) {\n      IModelApp.toolAdmin.setCursor(cursor);\n      IModelApp.toolAdmin.setLocateCircleOn(enableLocate);\n      IModelApp.viewManager.invalidateDecorationsAllViews();\n    } else {\n      IModelApp.toolAdmin.setLocateCursor(enableLocate);\n    }\n\n    IModelApp.accuSnap.enableLocate(enableLocate);\n    if (undefined !== enableSnap)\n      IModelApp.accuSnap.enableSnap(enableSnap);\n    else\n      IModelApp.accuSnap.enableSnap(false);\n\n    if (undefined !== coordLockOvr) {\n      IModelApp.toolAdmin.toolState.coordLockOvr = coordLockOvr;\n    } else {\n      if (enableLocate && !IModelApp.accuSnap.isSnapEnabled)\n        IModelApp.toolAdmin.toolState.coordLockOvr |= CoordinateLockOverrides.ACS;\n      else\n        IModelApp.toolAdmin.toolState.coordLockOvr &= ~CoordinateLockOverrides.ACS;\n    }\n  }\n\n  /** Helper method for tools that need to locate existing elements.\n   * Initializes [[ElementLocateManager]], changes the view cursor to locate, enables display of the locate circle, and sets the appropriate coordinate lock overrides.\n   * @see [[changeLocateState]]\n   */\n  public initLocateElements(enableLocate: boolean = true, enableSnap?: boolean, cursor?: string, coordLockOvr?: CoordinateLockOverrides): void {\n    IModelApp.locateManager.initToolLocate();\n    this.changeLocateState(enableLocate, enableSnap, cursor, coordLockOvr);\n  }\n\n  /** Used to supply list of properties that can be used to generate ToolSettings. If undefined is returned then no ToolSettings will be displayed\n   * @beta\n   */\n  public supplyToolSettingsProperties(): ToolSettingsPropertyRecord[] | undefined { return undefined; }\n\n  /** Used to receive property changes from UI. Return false if there was an error applying updatedValue.\n   * @beta\n   */\n  public applyToolSettingPropertyChange(_updatedValue: ToolSettingsPropertySyncItem): boolean { return true; }\n\n  /** Called by tool to synchronize the UI with property changes made by tool. This is typically used to provide user feedback during tool dynamics.\n   * If the syncData contains a quantity value and if the displayValue is not defined, the displayValue will be generated in the UI layer before displaying the value.\n   * @beta\n   */\n  public syncToolSettingsProperties(syncData: ToolSettingsPropertySyncItem[]) {\n    IModelApp.toolAdmin.syncToolSettingsProperties(this.toolId, syncData);\n  }\n}\n\n/** The InputCollector class can be used to implement a command for gathering input (ex. get a distance by snapping to 2 points) without affecting the state of the active primitive tool.\n * @public\n */\nexport abstract class InputCollector extends InteractiveTool {\n  public run(): boolean {\n    const toolAdmin = IModelApp.toolAdmin;\n    // An input collector can only suspend a primitive tool, don't install if a viewing tool is active...\n    if (undefined !== toolAdmin.viewTool || !toolAdmin.onInstallTool(this))\n      return false;\n\n    toolAdmin.startInputCollector(this);\n    toolAdmin.onPostInstallTool(this);\n    return true;\n  }\n\n  public exitTool(): void { IModelApp.toolAdmin.exitInputCollector(); }\n  public async onResetButtonUp(_ev: BeButtonEvent): Promise<EventHandled> { this.exitTool(); return EventHandled.Yes; }\n}\n\n/** The ToolRegistry holds a mapping between toolIds and their corresponding Tool class. This provides the mechanism to\n * find Tools by their toolId, and also a way to iterate over the set of Tools available.\n * @public\n */\nexport class ToolRegistry {\n  public readonly tools = new Map<string, ToolType>();\n  private _keyinList?: ToolList;\n\n  /**\n   * Un-register a previously registered Tool class.\n   * @param toolId the toolId of a previously registered tool to unRegister.\n   */\n  public unRegister(toolId: string) { this.tools.delete(toolId); this._keyinList = undefined; }\n\n  /**\n   * Register a Tool class. This establishes a connection between the toolId of the class and the class itself.\n   * @param toolClass the subclass of Tool to register.\n   * @param namespace the namespace for the localized strings for this tool. If undefined, use namespace from superclass.\n   */\n  public register(toolClass: ToolType, namespace?: I18NNamespace) {\n    if (namespace) // namespace is optional because it can come from superclass\n      toolClass.namespace = namespace;\n\n    if (toolClass.toolId.length === 0)\n      return; // must be an abstract class, ignore it\n\n    if (!toolClass.namespace)\n      throw new IModelError(-1, \"Tools must have a namespace\");\n\n    this.tools.set(toolClass.toolId, toolClass);\n    this._keyinList = undefined;  // throw away the current keyinList so we'll produce a new one next time we're asked.\n  }\n\n  /**\n   * Register all the Tool classes found in a module.\n   * @param modelObj the module to search for subclasses of Tool.\n   */\n  public registerModule(moduleObj: any, namespace?: I18NNamespace) {\n    for (const thisMember in moduleObj) {\n      if (!thisMember)\n        continue;\n\n      const thisTool = moduleObj[thisMember];\n      if (thisTool.prototype instanceof Tool) {\n        this.register(thisTool, namespace);\n      }\n    }\n  }\n\n  /** Look up a tool by toolId */\n  public find(toolId: string): ToolType | undefined { return this.tools.get(toolId); }\n\n  /**\n   * Look up a tool by toolId and, if found, create an instance with the supplied arguments.\n   * @param toolId the toolId of the tool\n   * @param args arguments to pass to the constructor.\n   * @returns an instance of the registered Tool class, or undefined if toolId is not registered.\n   */\n  public create(toolId: string, ...args: any[]): Tool | undefined {\n    const toolClass = this.find(toolId);\n    return toolClass ? new toolClass(...args) : undefined;\n  }\n\n  /**\n   * Look up a tool by toolId and, if found, create an instance with the supplied arguments and run it.\n   * @param toolId toolId of the immediate tool\n   * @param args arguments to pass to the constructor, and to run.\n   * @return true if the tool was found and successfully run.\n   */\n  public run(toolId: string, ...args: any[]): boolean {\n    const tool = this.create(toolId, ...args);\n    return tool !== undefined && tool.run(...args);\n  }\n\n  /** Get a list of Tools currently registered, excluding hidden tools */\n  public getToolList(): ToolList {\n    if (this._keyinList === undefined) {\n      this._keyinList = [];\n      this.tools.forEach((thisTool) => { if (!thisTool.hidden) this._keyinList!.push(thisTool); });\n    }\n    return this._keyinList;\n  }\n\n  /**\n   * Find a tool by its localized keyin using a FuzzySearch\n   * @param keyin the localized keyin string of the Tool.\n   * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.\n   * @internal\n   */\n  public findPartialMatches(keyin: string): FuzzySearchResults<ToolType> {\n    return new FuzzySearch<ToolType>().search(this.getToolList(), [\"keyin\"], keyin);\n  }\n\n  /**\n   * Find a tool by its localized keyin. If found (via exact match), execute the tool with the supplied arguments.\n   * @param keyin the localized keyin string of the Tool to run.\n   * @param args the arguments for the tool. Note: these argument are passed to both the constructor and the tools' run method.\n   * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.\n   * @internal\n   */\n  public executeExactMatch(keyin: string, ...args: any[]): boolean {\n    const foundClass = this.findExactMatch(keyin);\n    return foundClass ? new foundClass(...args).run(...args) : false;\n  }\n\n  /**\n   * Find a tool by its localized keyin.\n   * @param keyin the localized keyin string of the Tool.\n   * @returns the Tool class, if an exact match is found, otherwise returns undefined.\n   * @note Make sure the i18n resources are all loaded (e.g. `await IModelApp.i81n.waitForAllRead()`) before calling this method.\n   * @internal\n   */\n  public findExactMatch(keyin: string): ToolType | undefined { return this.getToolList().find((thisTool) => thisTool.keyin === keyin); }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { BeDuration, BeEvent } from \"@bentley/bentleyjs-core\";\nimport { Matrix3d, Point2d, Point3d, Transform, Vector3d, XAndY } from \"@bentley/geometry-core\";\nimport { GeometryStreamProps, NpcCenter } from \"@bentley/imodeljs-common\";\nimport { AccuSnap, TentativeOrAccuSnap } from \"../AccuSnap\";\nimport { LocateOptions } from \"../ElementLocateManager\";\nimport { HitDetail } from \"../HitDetail\";\nimport { IModelApp } from \"../IModelApp\";\nimport { ToolSettingsPropertySyncItem, ToolSettingsPropertyItem, ToolSettingsValue } from \"../properties/ToolSettingsValue\";\nimport { CanvasDecoration } from \"../render/System\";\nimport { IconSprites } from \"../Sprites\";\nimport { DecorateContext, DynamicsContext } from \"../ViewContext\";\nimport { linePlaneIntersect, ScreenViewport, Viewport } from \"../Viewport\";\nimport { ViewState3d, ViewStatus } from \"../ViewState\";\nimport { IdleTool } from \"./IdleTool\";\nimport { PrimitiveTool } from \"./PrimitiveTool\";\nimport { BeButton, BeButtonEvent, BeButtonState, BeModifierKeys, BeTouchEvent, BeWheelEvent, CoordSource, EventHandled, InputCollector, InputSource, InteractiveTool, Tool, CoordinateLockOverrides, ToolSettings } from \"./Tool\";\nimport { ViewTool } from \"./ViewTool\";\n\n/** @public */\nexport enum StartOrResume { Start = 1, Resume = 2 }\n\n/** @alpha */\nexport enum ManipulatorToolEvent { Start = 1, Stop = 2, Suspend = 3, Unsuspend = 4 }\n\nconst enum MouseButton { Left = 0, Middle = 1, Right = 2 }\n\n/** Class that assists in maintaining the state of tool settings properties for the current session\n *  @internal\n */\nexport class ToolSettingsState {\n\n  /** Initialize single tool settings value\n   * @internal\n   */\n  public initializeToolSettingProperty(toolId: string, item: ToolSettingsPropertyItem): void {\n    if (item) {\n      const key = `${toolId}:${item.propertyName}`;\n      const savedValue = window.sessionStorage.getItem(key);\n      if (savedValue) {\n        const readValue = JSON.parse(savedValue) as ToolSettingsValue;\n        // set the primitive value to the saved value - note: tool settings only support primitive values.\n        item.value.value = readValue.value;\n        if (readValue.hasDisplayValue)\n          item.value.displayValue = readValue.displayValue;\n      }\n    }\n  }\n\n  /** Initialize an array of tool settings values\n   *  @internal\n   */\n  public initializeToolSettingProperties(toolId: string, tsProps: ToolSettingsPropertyItem[]): void {\n    if (tsProps && tsProps.length) {\n      tsProps.forEach((item: ToolSettingsPropertyItem) => {\n        this.initializeToolSettingProperty(toolId, item);\n      });\n    }\n  }\n\n  /** Save single tool settings value\n   * @internal\n   */\n  public saveToolSettingProperty(toolId: string, item: ToolSettingsPropertyItem): void {\n    if (item) {\n      const key = `${toolId}:${item.propertyName}`;\n      const objectAsString = JSON.stringify(item.value);\n      window.sessionStorage.setItem(key, objectAsString);\n    }\n  }\n\n  /** Save an array of tool settings values\n   * @internal\n   */\n  public saveToolSettingProperties(toolId: string, tsProps: ToolSettingsPropertyItem[]): void {\n    if (tsProps && tsProps.length) {\n      tsProps.forEach((item: ToolSettingsPropertyItem) => {\n        this.saveToolSettingProperty(toolId, item);\n      });\n    }\n  }\n}\n\n/** @internal */\nexport class ToolState {\n  public coordLockOvr = CoordinateLockOverrides.None;\n  public locateCircleOn = false;\n  public setFrom(other: ToolState) { this.coordLockOvr = other.coordLockOvr; this.locateCircleOn = other.locateCircleOn; }\n  public clone(): ToolState { const val = new ToolState(); val.setFrom(this); return val; }\n}\n\n/** @internal */\nexport class SuspendedToolState {\n  private readonly _toolState: ToolState;\n  private readonly _accuSnapState: AccuSnap.ToolState;\n  private readonly _locateOptions: LocateOptions;\n  private readonly _viewCursor?: string;\n  private _inDynamics: boolean;\n  private _shuttingDown = false;\n\n  constructor() {\n    const { toolAdmin, viewManager, accuSnap, locateManager } = IModelApp;\n    toolAdmin.setIncompatibleViewportCursor(true); // Don't save this\n    this._toolState = toolAdmin.toolState.clone();\n    this._accuSnapState = accuSnap.toolState.clone();\n    this._locateOptions = locateManager.options.clone();\n    this._viewCursor = viewManager.cursor;\n    this._inDynamics = viewManager.inDynamicsMode;\n    if (this._inDynamics)\n      viewManager.endDynamicsMode();\n  }\n\n  public stop() {\n    if (this._shuttingDown)\n      return;\n\n    const { toolAdmin, viewManager, accuSnap, locateManager } = IModelApp;\n    toolAdmin.setIncompatibleViewportCursor(true); // Don't restore this\n    toolAdmin.toolState.setFrom(this._toolState);\n    accuSnap.toolState.setFrom(this._accuSnapState);\n    locateManager.options.setFrom(this._locateOptions);\n    viewManager.setViewCursor(this._viewCursor);\n    if (this._inDynamics)\n      viewManager.beginDynamicsMode();\n    else\n      viewManager.endDynamicsMode();\n  }\n}\n\n/** @internal */\nexport class CurrentInputState {\n  private _rawPoint: Point3d = new Point3d();\n  private _uorPoint: Point3d = new Point3d();\n  private _viewPoint: Point3d = new Point3d();\n  public qualifiers = BeModifierKeys.None;\n  public motionTime = 0;\n  public viewport?: ScreenViewport;\n  public button: BeButtonState[] = [new BeButtonState(), new BeButtonState(), new BeButtonState()];\n  public lastButton: BeButton = BeButton.Data;\n  public inputSource: InputSource = InputSource.Unknown;\n  public lastMotion = new Point2d();\n  public lastWheelEvent?: BeWheelEvent;\n  public lastTouchStart?: BeTouchEvent;\n  public touchTapTimer?: number;\n  public touchTapCount?: number;\n\n  public get rawPoint() { return this._rawPoint; }\n  public set rawPoint(pt: Point3d) { this._rawPoint.setFrom(pt); }\n  public get uorPoint() { return this._uorPoint; }\n  public set uorPoint(pt: Point3d) { this._uorPoint.setFrom(pt); }\n  public get viewPoint() { return this._viewPoint; }\n  public set viewPoint(pt: Point3d) { this._viewPoint.setFrom(pt); }\n  public get wasMotion() { return 0 !== this.motionTime; }\n  public get isShiftDown() { return 0 !== (this.qualifiers & BeModifierKeys.Shift); }\n  public get isControlDown() { return 0 !== (this.qualifiers & BeModifierKeys.Control); }\n  public get isAltDown() { return 0 !== (this.qualifiers & BeModifierKeys.Alt); }\n\n  public isDragging(button: BeButton) { return this.button[button].isDragging; }\n  public onStartDrag(button: BeButton) { this.button[button].isDragging = true; }\n  public onInstallTool() { this.clearKeyQualifiers(); if (undefined !== this.lastWheelEvent) this.lastWheelEvent.invalidate(); this.lastTouchStart = this.touchTapTimer = this.touchTapCount = undefined; }\n  public clearKeyQualifiers() { this.qualifiers = BeModifierKeys.None; }\n  public clearViewport(vp: Viewport) { if (vp === this.viewport) this.viewport = undefined; }\n  private isAnyDragging() { return this.button.some((button) => button.isDragging); }\n  private setKeyQualifier(qual: BeModifierKeys, down: boolean) { this.qualifiers = down ? (this.qualifiers | qual) : (this.qualifiers & (~qual)); }\n\n  public setKeyQualifiers(ev: MouseEvent | KeyboardEvent | TouchEvent): void {\n    this.setKeyQualifier(BeModifierKeys.Shift, ev.shiftKey);\n    this.setKeyQualifier(BeModifierKeys.Control, ev.ctrlKey);\n    this.setKeyQualifier(BeModifierKeys.Alt, ev.altKey);\n  }\n\n  public onMotion(pt2d: XAndY) {\n    this.motionTime = Date.now();\n    this.lastMotion.x = pt2d.x;\n    this.lastMotion.y = pt2d.y;\n  }\n\n  public get hasMotionStopped(): boolean {\n    const result = this.hasEventInputStopped(this.motionTime, ToolSettings.noMotionTimeout);\n    if (result.stopped)\n      this.motionTime = result.eventTimer;\n    return result.stopped;\n  }\n\n  private hasEventInputStopped(timer: number, eventTimeout: BeDuration) {\n    let isStopped = false;\n    if (0 !== timer && ((Date.now() - timer) >= eventTimeout.milliseconds)) {\n      isStopped = true;\n      timer = 0;\n    }\n    return { eventTimer: timer, stopped: isStopped };\n  }\n\n  public changeButtonToDownPoint(ev: BeButtonEvent) {\n    ev.point = this.button[ev.button].downUorPt;\n    ev.rawPoint = this.button[ev.button].downRawPt;\n\n    if (ev.viewport)\n      ev.viewPoint = ev.viewport.worldToView(ev.rawPoint);\n  }\n\n  public updateDownPoint(ev: BeButtonEvent) { this.button[ev.button].downUorPt = ev.point; }\n\n  public onButtonDown(button: BeButton) {\n    const viewPt = this.viewport!.worldToView(this.button[button].downRawPt);\n    const center = this.viewport!.npcToView(NpcCenter);\n    viewPt.z = center.z;\n\n    const now = Date.now();\n    const isDoubleClick = ((now - this.button[button].downTime) < ToolSettings.doubleClickTimeout.milliseconds) && (viewPt.distance(this.viewPoint) < this.viewport!.pixelsFromInches(ToolSettings.doubleClickToleranceInches));\n\n    this.button[button].init(this.uorPoint, this.rawPoint, now, true, isDoubleClick, false, this.inputSource);\n    this.lastButton = button;\n  }\n\n  public onButtonUp(button: BeButton) {\n    this.button[button].isDown = false;\n    this.button[button].isDragging = false;\n    this.lastButton = button;\n  }\n\n  public toEvent(ev: BeButtonEvent, useSnap: boolean) {\n    let coordsFrom = CoordSource.User;\n    const point = this.uorPoint.clone();\n    let viewport = this.viewport;\n\n    if (useSnap) {\n      const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n      if (snap) {\n        coordsFrom = snap.isHot ? CoordSource.ElemSnap : CoordSource.User;\n        point.setFrom(snap.isPointAdjusted ? snap.adjustedPoint : snap.getPoint()); // NOTE: adjustedPoint can be set by adjustSnapPoint even when not hot...\n        viewport = snap.viewport;\n      } else if (IModelApp.tentativePoint.isActive) {\n        coordsFrom = CoordSource.TentativePoint;\n        point.setFrom(IModelApp.tentativePoint.getPoint());\n        viewport = IModelApp.tentativePoint.viewport;\n      }\n    }\n\n    const buttonState = this.button[this.lastButton];\n    ev.init({\n      point, rawPoint: this.rawPoint, viewPoint: this.viewPoint, viewport, coordsFrom,\n      keyModifiers: this.qualifiers, button: this.lastButton, isDown: buttonState.isDown,\n      isDoubleClick: buttonState.isDoubleClick, isDragging: buttonState.isDragging,\n      inputSource: this.inputSource,\n    });\n  }\n\n  public adjustLastDataPoint(ev: BeButtonEvent) {\n    const state = this.button[BeButton.Data];\n    state.downUorPt = ev.point;\n    state.downRawPt = ev.point;\n    this.viewport = ev.viewport;\n  }\n\n  public toEventFromLastDataPoint(ev: BeButtonEvent) {\n    const state = this.button[BeButton.Data];\n    const point = state.downUorPt;\n    const rawPoint = state.downRawPt;\n    const viewPoint = this.viewport!.worldToView(rawPoint);\n    ev.init({\n      point, rawPoint, viewPoint, viewport: this.viewport!, coordsFrom: CoordSource.User,\n      keyModifiers: this.qualifiers, button: BeButton.Data, isDown: state.isDown,\n      isDoubleClick: state.isDoubleClick, isDragging: state.isDragging, inputSource: state.inputSource,\n    });\n  }\n\n  public fromPoint(vp: ScreenViewport, pt: XAndY, source: InputSource) {\n    this.viewport = vp;\n    this._viewPoint.x = pt.x;\n    this._viewPoint.y = pt.y;\n    this._viewPoint.z = vp.npcToView(NpcCenter).z;\n    vp.viewToWorld(this._viewPoint, this._rawPoint);\n    this._uorPoint = this._rawPoint.clone();\n    this.inputSource = source;\n  }\n\n  public fromButton(vp: ScreenViewport, pt: XAndY, source: InputSource, applyLocks: boolean) {\n    this.fromPoint(vp, pt, source);\n\n    // NOTE: Using the hit point on the element is preferable to ignoring a snap that is not \"hot\" completely\n    if (TentativeOrAccuSnap.getCurrentSnap(false)) {\n      if (applyLocks)\n        IModelApp.toolAdmin.adjustSnapPoint();\n      return;\n    }\n    IModelApp.toolAdmin.adjustPoint(this._uorPoint, vp, true, applyLocks);\n  }\n\n  public isStartDrag(button: BeButton): boolean {\n    // First make sure we aren't already dragging any button\n    if (this.isAnyDragging())\n      return false;\n\n    const state = this.button[button];\n    if (!state.isDown)\n      return false;\n\n    if ((Date.now() - state.downTime) <= ToolSettings.startDragDelay.milliseconds)\n      return false;\n\n    const viewPt = this.viewport!.worldToView(state.downRawPt);\n    const deltaX = Math.abs(this._viewPoint.x - viewPt.x);\n    const deltaY = Math.abs(this._viewPoint.y - viewPt.y);\n\n    return ((deltaX + deltaY) > this.viewport!.pixelsFromInches(ToolSettings.startDragDistanceInches));\n  }\n}\n\n/** A ToolEvent combines an HTML Event and a Viewport. It is stored in a queue for processing by the ToolAdmin.eventLoop. */\ninterface ToolEvent {\n  ev: Event;\n  vp?: ScreenViewport; // Viewport is optional - keyboard events aren't associated with a Viewport.\n}\n\n/** Controls operation of Tools. Administers the current view, primitive, and idle tools. Forwards events to the appropriate tool.\n * @public\n */\nexport class ToolAdmin {\n  public markupView?: ScreenViewport;\n  /** @internal */\n  public readonly currentInputState = new CurrentInputState();\n  /** @internal */\n  public readonly toolState = new ToolState();\n  /** @internal */\n  public readonly toolSettingsState = new ToolSettingsState();\n  private _canvasDecoration?: CanvasDecoration;\n  private _suspendedByViewTool?: SuspendedToolState;\n  private _suspendedByInputCollector?: SuspendedToolState;\n  private _viewTool?: ViewTool;\n  private _primitiveTool?: PrimitiveTool;\n  private _idleTool?: IdleTool;\n  private _inputCollector?: InputCollector;\n  private _saveCursor?: string;\n  private _saveLocateCircle = false;\n  private _modifierKeyWentDown = false;\n  private _defaultToolId = \"Select\";\n  private _defaultToolArgs?: any[];\n  private _modifierKey = BeModifierKeys.None;\n  /** Return the name of the [[PrimitiveTool]] to use as the default tool, if any.\n   * @see [[startDefaultTool]]\n   * @internal\n   */\n  public get defaultToolId(): string { return this._defaultToolId; }\n  /** Set the name of the [[PrimitiveTool]] to use as the default tool, if any.\n   * @see [[startDefaultTool]]\n   * @internal\n   */\n  public set defaultToolId(toolId: string) { this._defaultToolId = toolId; }\n  /** Return the default arguments to pass in when starting the default tool, if any.\n   * @see [[startDefaultTool]]\n   * @internal\n   */\n  public get defaultToolArgs(): any[] | undefined { return this._defaultToolArgs; }\n\n  /** Set the default arguments to pass in when starting the default tool, if any.\n   * @see [[startDefaultTool]]\n   * @internal\n   */\n  public set defaultToolArgs(args: any[] | undefined) { this._defaultToolArgs = args; }\n  /** Apply operations such as transform, copy or delete to all members of an assembly. */\n  public assemblyLock = false;\n  /** If Grid Lock is on, project data points to grid. */\n  public gridLock = false;\n  /** If ACS Snap Lock is on, project snap points to the ACS plane. */\n  public acsPlaneSnapLock = false;\n  /** If ACS Plane Lock is on, standard view rotations are relative to the ACS instead of global. */\n  public acsContextLock = false;\n\n  private static _wantEventLoop = false;\n  private static readonly _removals: VoidFunction[] = [];\n\n  // Workaround for Edge Bug.\n  private static _keysCurrentlyDown = new Set<string>(); // The (small) set of keys that are currently pressed.\n\n  /** Handler that wants to process synching latest tool setting properties with UI.\n   *  @internal\n   */\n  private _toolSettingsChangeHandler: ((toolId: string, syncProperties: ToolSettingsPropertySyncItem[]) => void) | undefined = undefined;\n\n  /** @internal */\n  /** Set by object that will be provide UI for tool settings properties. */\n  public set toolSettingsChangeHandler(handler: ((toolId: string, syncProperties: ToolSettingsPropertySyncItem[]) => void) | undefined) {\n    this._toolSettingsChangeHandler = handler;\n  }\n\n  /** @internal */\n  public get toolSettingsChangeHandler() { return this._toolSettingsChangeHandler; }\n\n  /** Handler for keyboard events. */\n  private static _keyEventHandler = (ev: KeyboardEvent) => {\n    if (ev.repeat) // we don't want repeated keyboard events. If we keep them they interfere with replacing mouse motion events, since they come as a stream.\n      return;\n\n    // Workaround for Edge Bug. Edge doesn't correctly set the \"repeat\" flag for keyboard events. We therefore have to implement it\n    // ourselves. Keep the test above since it will be faster for other browsers. We can delete this entire block of code when Edge works correctly.\n    if (ev.type === \"keydown\") {\n      if (ToolAdmin._keysCurrentlyDown.has(ev.code)) // if we've already received a keydown for this key, its a repeat. Skip it\n        return;\n      ToolAdmin._keysCurrentlyDown.add(ev.code);\n    } else {\n      ToolAdmin._keysCurrentlyDown.delete(ev.code);\n    }\n\n    IModelApp.toolAdmin.addEvent(ev);\n  }\n\n  /** @internal */\n  public onInitialized() {\n    if (typeof document === \"undefined\")\n      return;    // if document isn't defined, we're probably running in a test environment. At any rate, we can't have interactive tools.\n\n    this._idleTool = IModelApp.tools.create(\"Idle\") as IdleTool;\n\n    [\"keydown\", \"keyup\"].forEach((type) => {\n      document.addEventListener(type, ToolAdmin._keyEventHandler as EventListener, false);\n      ToolAdmin._removals.push(() => { document.removeEventListener(type, ToolAdmin._keyEventHandler as EventListener, false); });\n    });\n\n    // the list of currently down keys can get out of sync if a key goes down and then we lose focus. Clear the list every time we get focus.\n    window.onfocus = () => { ToolAdmin._keysCurrentlyDown.clear(); };\n    ToolAdmin._removals.push(() => { window.onfocus = null; });\n  }\n\n  /** @internal */\n  public startEventLoop() {\n    if (!ToolAdmin._wantEventLoop) {\n      ToolAdmin._wantEventLoop = true;\n      requestAnimationFrame(ToolAdmin.eventLoop);\n    }\n  }\n\n  /** @internal */\n  public onShutDown() {\n    this._idleTool = undefined;\n    IconSprites.emptyAll(); // clear cache of icon sprites\n    ToolAdmin._wantEventLoop = false;\n    ToolAdmin._removals.forEach((remove) => remove());\n    ToolAdmin._removals.length = 0;\n  }\n\n  /** Get the ScreenViewport where the cursor is currently, if any. */\n  public get cursorView(): ScreenViewport | undefined { return this.currentInputState.viewport; }\n\n  /** A first-in-first-out queue of ToolEvents. */\n  private readonly _toolEvents: ToolEvent[] = [];\n  private tryReplace(event: ToolEvent): boolean {\n    if (this._toolEvents.length < 1)\n      return false;\n    const last = this._toolEvents[this._toolEvents.length - 1];\n    if ((last.ev.type !== \"mousemove\" && last.ev.type !== \"touchmove\") || last.ev.type !== event.ev.type)\n      return false; // only mousemove and touchmove can replace previous\n    last.ev = event.ev; // sequential moves are not important. Replace the previous one with this one.\n    last.vp = event.vp;\n    return true;\n  }\n\n  /** Called from HTML event listeners. Events are processed in the order they're received in ToolAdmin.eventLoop\n   * @internal\n   */\n  public addEvent(ev: Event, vp?: ScreenViewport): void {\n    const event = { ev, vp };\n    if (!this.tryReplace(event)) // see if this event replaces the last event in the queue\n      this._toolEvents.push(event); // otherwise put it at the end of the queue.\n  }\n\n  private getMousePosition(event: ToolEvent): XAndY {\n    const ev = event.ev as MouseEvent;\n    const rect = event.vp!.getClientRect();\n    return { x: ev.clientX - rect.left, y: ev.clientY - rect.top };\n  }\n\n  private getMouseButton(button: number) {\n    switch (button) {\n      case MouseButton.Middle: return BeButton.Middle;\n      case MouseButton.Right: return BeButton.Reset;\n      default: return BeButton.Data;\n    }\n  }\n\n  private async onMouseButton(event: ToolEvent, isDown: boolean): Promise<any> {\n    const ev = event.ev as MouseEvent;\n    const vp = event.vp!;\n    const pos = this.getMousePosition(event);\n    const button = this.getMouseButton(ev.button);\n\n    this.currentInputState.setKeyQualifiers(ev);\n    return isDown ? this.onButtonDown(vp, pos, button, InputSource.Mouse) : this.onButtonUp(vp, pos, button, InputSource.Mouse);\n  }\n\n  private async onWheel(event: ToolEvent): Promise<EventHandled> {\n    const ev = event.ev as WheelEvent;\n    const vp = event.vp!;\n    if (this.filterViewport(vp))\n      return EventHandled.Yes;\n    const current = this.currentInputState;\n    current.setKeyQualifiers(ev);\n\n    if (ev.deltaY === 0)\n      return EventHandled.No;\n\n    let delta: number;\n    switch (ev.deltaMode) {\n      case ev.DOM_DELTA_LINE:\n        delta = -ev.deltaY * ToolSettings.wheelLineFactor; // 40\n        break;\n      case ev.DOM_DELTA_PAGE:\n        delta = -ev.deltaY * ToolSettings.wheelPageFactor; // 120;\n        break;\n      default: // DOM_DELTA_PIXEL:\n        delta = -ev.deltaY;\n        break;\n    }\n\n    const pt2d = this.getMousePosition(event);\n\n    vp.removeAnimator();\n    current.fromButton(vp, pt2d, InputSource.Mouse, true);\n    const wheelEvent = new BeWheelEvent();\n    wheelEvent.wheelDelta = delta;\n    current.toEvent(wheelEvent, true);\n\n    const overlayHit = this.pickCanvasDecoration(wheelEvent);\n    if (undefined !== overlayHit && undefined !== overlayHit.onWheel && overlayHit.onWheel(wheelEvent))\n      return EventHandled.Yes;\n\n    const tool = this.activeTool;\n    if (undefined === tool || EventHandled.Yes !== await tool.onMouseWheel(wheelEvent) && vp !== this.markupView)\n      return this.idleTool.onMouseWheel(wheelEvent);\n    return EventHandled.Yes;\n  }\n\n  private async onTouch(event: ToolEvent): Promise<void> {\n    const touchEvent = event.ev as TouchEvent;\n    const vp = event.vp!;\n    if (this.filterViewport(vp))\n      return;\n\n    vp.removeAnimator();\n    const ev = new BeTouchEvent({ touchEvent });\n    const current = this.currentInputState;\n    const pos = BeTouchEvent.getTouchListCentroid(0 !== touchEvent.targetTouches.length ? touchEvent.targetTouches : touchEvent.changedTouches, vp);\n\n    switch (touchEvent.type) {\n      case \"touchstart\":\n      case \"touchend\":\n        current.setKeyQualifiers(touchEvent);\n        break;\n    }\n\n    current.fromButton(vp, undefined !== pos ? pos : Point2d.createZero(), InputSource.Touch, true);\n    current.toEvent(ev, false);\n    const tool = this.activeTool;\n\n    switch (touchEvent.type) {\n      case \"touchstart\": {\n        current.lastTouchStart = ev;\n        IModelApp.accuSnap.onTouchStart(ev);\n        if (undefined !== tool)\n          tool.onTouchStart(ev); // tslint:disable-line:no-floating-promises\n        return;\n      }\n\n      case \"touchend\": {\n        IModelApp.accuSnap.onTouchEnd(ev);\n        if (undefined !== tool) {\n          await tool.onTouchEnd(ev);\n          if (0 === ev.touchCount)\n            await tool.onTouchComplete(ev);\n        }\n\n        if (undefined === current.lastTouchStart)\n          return;\n\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < ev.touchEvent.changedTouches.length; i++) {\n          const currTouch = ev.touchEvent.changedTouches[i];\n          const startTouch = BeTouchEvent.findTouchById(current.lastTouchStart.touchEvent.targetTouches, currTouch.identifier);\n\n          if (undefined !== startTouch) {\n            const currPt = BeTouchEvent.getTouchPosition(currTouch, vp);\n            const startPt = BeTouchEvent.getTouchPosition(startTouch, vp);\n\n            if (currPt.distance(startPt) < vp.pixelsFromInches(ToolSettings.touchMoveDistanceInches))\n              continue; // Hasn't moved appreciably....\n          }\n\n          current.lastTouchStart = undefined; // Not a tap...\n          return;\n        }\n\n        if (0 !== ev.touchCount || undefined === current.lastTouchStart)\n          return;\n\n        // All fingers off, defer processing tap until we've waited long enough to detect double tap...\n        if (undefined === current.touchTapTimer) {\n          current.touchTapTimer = Date.now();\n          current.touchTapCount = 1;\n        } else if (undefined !== current.touchTapCount) {\n          current.touchTapCount++;\n        }\n        return;\n      }\n\n      case \"touchcancel\": {\n        current.lastTouchStart = undefined;\n        IModelApp.accuSnap.onTouchCancel(ev);\n        if (undefined !== tool)\n          tool.onTouchCancel(ev); // tslint:disable-line:no-floating-promises\n        return;\n      }\n\n      case \"touchmove\": {\n        if (!IModelApp.accuSnap.onTouchMove(ev) && undefined !== tool)\n          tool.onTouchMove(ev); // tslint:disable-line:no-floating-promises\n\n        if (undefined === current.lastTouchStart)\n          return;\n\n        if (ev.touchEvent.timeStamp - current.lastTouchStart.touchEvent.timeStamp < ToolSettings.touchMoveDelay.milliseconds)\n          return;\n\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < ev.touchEvent.changedTouches.length; i++) {\n          const currTouch = ev.touchEvent.changedTouches[i];\n          const startTouch = BeTouchEvent.findTouchById(current.lastTouchStart.touchEvent.targetTouches, currTouch.identifier);\n\n          if (undefined === startTouch)\n            continue;\n\n          const currPt = BeTouchEvent.getTouchPosition(currTouch, vp);\n          const startPt = BeTouchEvent.getTouchPosition(startTouch, vp);\n\n          if (currPt.distance(startPt) < vp.pixelsFromInches(ToolSettings.touchMoveDistanceInches))\n            continue; // Hasn't moved appreciably....\n\n          const touchStart = current.lastTouchStart;\n          current.lastTouchStart = undefined;\n\n          if (IModelApp.accuSnap.onTouchMoveStart(ev, touchStart))\n            return;\n\n          if (undefined === tool || EventHandled.Yes !== await tool.onTouchMoveStart(ev, touchStart))\n            this.idleTool.onTouchMoveStart(ev, touchStart); // tslint:disable-line:no-floating-promises\n          return;\n        }\n        return;\n      }\n    }\n  }\n\n  /** Process the next event in the event queue, if any. */\n  private async processNextEvent(): Promise<any> {\n    const event = this._toolEvents.shift(); // pull first event from the queue\n    if (undefined === event)\n      return; // nothing in queue\n\n    switch (event.ev.type) {\n      case \"mousedown\": return this.onMouseButton(event, true);\n      case \"mouseup\": return this.onMouseButton(event, false);\n      case \"mousemove\": return this.onMouseMove(event);\n      case \"mouseenter\": return this.onMouseEnter(event.vp!);\n      case \"mouseleave\": return this.onMouseLeave(event.vp!);\n      case \"wheel\": return this.onWheel(event);\n      case \"keydown\": return this.onKeyTransition(event, true);\n      case \"keyup\": return this.onKeyTransition(event, false);\n      case \"touchstart\": return this.onTouch(event);\n      case \"touchend\": return this.onTouch(event);\n      case \"touchcancel\": return this.onTouch(event);\n      case \"touchmove\": return this.onTouch(event);\n    }\n  }\n\n  private _processingEvent = false;\n  /**\n   * Process a single event, plus timer events. Don't start work on new events if the previous one has not finished.\n   */\n  private async processEvent(): Promise<void> {\n    if (this._processingEvent)\n      return; // we're still working on the previous event.\n\n    try {\n      this._processingEvent = true; // we can't allow any further event processing until the current event completes.\n      await this.onTimerEvent();     // timer events are also suspended by asynchronous tool events. That's necessary since they can be asynchronous too.\n      await this.processNextEvent();\n    } catch (error) {\n      throw error; // enable this in debug only.\n    } finally {\n      this._processingEvent = false; // this event is now finished. Allow processing next time through.\n    }\n  }\n\n  /** The main event processing loop for Tools (and rendering). */\n  private static eventLoop(): void {\n    if (!ToolAdmin._wantEventLoop) // flag turned on at startup\n      return;\n\n    IModelApp.toolAdmin.processEvent(); // tslint:disable-line:no-floating-promises\n\n    IModelApp.viewManager.renderLoop();\n    IModelApp.tileAdmin.process();\n\n    requestAnimationFrame(ToolAdmin.eventLoop);\n  }\n\n  /** The idleTool handles events that are not otherwise processed. */\n  public get idleTool(): IdleTool { return this._idleTool!; }\n\n  /** Return true to filter (ignore) events to the given viewport */\n  protected filterViewport(vp: Viewport) {\n    if (undefined === vp)\n      return true;\n    const tool = this.activeTool;\n    return (undefined !== tool ? !tool.isCompatibleViewport(vp, false) : false);\n  }\n\n  /** @internal */\n  public onInstallTool(tool: InteractiveTool) { this.currentInputState.onInstallTool(); return tool.onInstall(); }\n  /** @internal */\n  public onPostInstallTool(tool: InteractiveTool) { tool.onPostInstall(); }\n\n  public get viewTool(): ViewTool | undefined { return this._viewTool; }\n  public get primitiveTool(): PrimitiveTool | undefined { return this._primitiveTool; }\n\n  /** The currently active InteractiveTool. May be ViewTool, InputCollector, PrimitiveTool, undefined - in that priority order. */\n  public get activeTool(): InteractiveTool | undefined {\n    return this._viewTool ? this._viewTool : (this._inputCollector ? this._inputCollector : this._primitiveTool); // NOTE: Viewing tools suspend input collectors as well as primitives\n  }\n\n  /** The current tool. May be ViewTool, InputCollector, PrimitiveTool, or IdleTool - in that priority order. */\n  public get currentTool(): InteractiveTool { return this.activeTool ? this.activeTool : this.idleTool; }\n\n  /** Ask the current tool to provide tooltip contents for the supplied HitDetail. */\n  public async getToolTip(hit: HitDetail): Promise<HTMLElement | string> { return this.currentTool.getToolTip(hit); }\n\n  /**\n   * Event raised whenever the active tool changes. This includes PrimitiveTool, ViewTool, and InputCollector.\n   * @param newTool The newly activated tool\n   */\n  public readonly activeToolChanged = new BeEvent<(tool: Tool, start: StartOrResume) => void>();\n\n  /**\n   * Event raised by tools that support edit manipulators like the SelectTool.\n   * @param tool The current tool\n   * @alpha\n   */\n  public readonly manipulatorToolEvent = new BeEvent<(tool: Tool, event: ManipulatorToolEvent) => void>();\n\n  private async onMouseEnter(vp: ScreenViewport): Promise<void> { this.currentInputState.viewport = vp; }\n\n  /** @internal */\n  public async onMouseLeave(vp: ScreenViewport): Promise<void> {\n    IModelApp.accuSnap.clear();\n    this.currentInputState.clearViewport(vp);\n    this.setCanvasDecoration(vp);\n    vp.invalidateDecorations(); // stop drawing locate circle...\n  }\n\n  /** @internal */\n  public updateDynamics(ev?: BeButtonEvent, useLastData?: boolean, adjustPoint?: boolean): void {\n    if (!IModelApp.viewManager.inDynamicsMode || undefined === this.activeTool)\n      return;\n\n    if (undefined === ev) {\n      ev = new BeButtonEvent();\n\n      if (useLastData)\n        this.fillEventFromLastDataButton(ev);\n      else\n        this.fillEventFromCursorLocation(ev);\n\n      if (adjustPoint && undefined !== ev.viewport)\n        this.adjustPoint(ev.point, ev.viewport);\n    }\n\n    if (undefined === ev.viewport)\n      return;\n\n    const context = new DynamicsContext(ev.viewport);\n    this.activeTool.onDynamicFrame(ev, context);\n    context.changeDynamics();\n  }\n\n  /** This is invoked on a timer to update  input state and forward events to tools.\n   * @internal\n   */\n  private async onTimerEvent(): Promise<void> {\n    const tool = this.activeTool;\n    const current = this.currentInputState;\n\n    if (undefined !== current.touchTapTimer) {\n      const now = Date.now();\n      if ((now - current.touchTapTimer) >= ToolSettings.doubleTapTimeout.milliseconds) {\n        const touchEv = current.lastTouchStart;\n        const numTouches = (undefined !== current.lastTouchStart ? current.lastTouchStart.touchCount : 0);\n        const numTaps = (undefined !== current.touchTapCount ? current.touchTapCount : 0);\n\n        current.touchTapTimer = current.touchTapCount = current.lastTouchStart = undefined;\n\n        if (undefined !== touchEv && numTouches > 0 && numTaps > 0) {\n          touchEv.tapCount = numTaps;\n          const overlayHit = this.pickCanvasDecoration(touchEv);\n          if (undefined !== overlayHit && undefined !== overlayHit.onMouseButton && overlayHit.onMouseButton(touchEv))\n            return;\n          if (await IModelApp.accuSnap.onTouchTap(touchEv))\n            return;\n          if ((undefined !== tool && EventHandled.Yes === await tool.onTouchTap(touchEv)) || EventHandled.Yes === await this.idleTool.onTouchTap(touchEv))\n            return;\n        }\n      }\n    }\n\n    const ev = new BeButtonEvent();\n    current.toEvent(ev, true);\n\n    const wasMotion = current.wasMotion;\n    if (!wasMotion) {\n      if (tool)\n        await tool.onMouseNoMotion(ev);\n\n      if (InputSource.Mouse === current.inputSource && this.currentInputState.viewport) {\n        await IModelApp.accuSnap.onNoMotion(ev);\n      }\n    }\n\n    if (current.hasMotionStopped) {\n      if (tool)\n        await tool.onMouseMotionStopped(ev);\n      if (InputSource.Mouse === current.inputSource) {\n        IModelApp.accuSnap.onMotionStopped(ev);\n      }\n    }\n  }\n\n  public async sendEndDragEvent(ev: BeButtonEvent): Promise<any> {\n    let tool = this.activeTool;\n\n    if (undefined !== tool) {\n      if (!tool.isValidLocation(ev, true))\n        tool = undefined;\n      else if (tool.receivedDownEvent)\n        tool.receivedDownEvent = false;\n      else\n        tool = undefined;\n    }\n\n    // Don't send tool end drag event if it didn't get the start drag event\n    if (undefined === tool || EventHandled.Yes !== await tool.onMouseEndDrag(ev))\n      return this.idleTool.onMouseEndDrag(ev);\n  }\n\n  private setCanvasDecoration(vp: ScreenViewport, dec?: CanvasDecoration, ev?: BeButtonEvent) {\n    if (dec === this._canvasDecoration)\n      return;\n\n    if (this._canvasDecoration && this._canvasDecoration.onMouseLeave)\n      this._canvasDecoration.onMouseLeave();\n    this._canvasDecoration = dec;\n    if (ev && dec && dec.onMouseEnter) dec.onMouseEnter(ev);\n\n    vp.canvas.style.cursor = dec ? (dec.decorationCursor ? dec.decorationCursor : \"pointer\") : IModelApp.viewManager.cursor;\n    vp.invalidateDecorations();\n  }\n\n  private pickCanvasDecoration(ev: BeButtonEvent) {\n    const vp = ev.viewport!;\n    const decoration = (undefined === this.viewTool) ? vp.pickCanvasDecoration(ev.viewPoint) : undefined;\n    this.setCanvasDecoration(vp, decoration, ev);\n    return decoration;\n  }\n\n  private async onMotion(vp: ScreenViewport, pt2d: XAndY, inputSource: InputSource, forceStartDrag: boolean = false): Promise<any> {\n    const current = this.currentInputState;\n    current.onMotion(pt2d);\n\n    if (this.filterViewport(vp)) {\n      this.setIncompatibleViewportCursor(false);\n      return;\n    }\n\n    const ev = new BeButtonEvent();\n    current.fromPoint(vp, pt2d, inputSource);\n    current.toEvent(ev, false);\n\n    const overlayHit = this.pickCanvasDecoration(ev);\n    if (undefined !== overlayHit) {\n      if (overlayHit.onMouseMove)\n        overlayHit.onMouseMove(ev);\n      return;   // we're inside a pickable decoration, don't send event to tool\n    }\n\n    await IModelApp.accuSnap.onMotion(ev); // wait for AccuSnap before calling fromButton\n\n    current.fromButton(vp, pt2d, inputSource, true);\n    current.toEvent(ev, true);\n\n    IModelApp.accuDraw.onMotion(ev);\n\n    const tool = this.activeTool;\n    const isValidLocation = (undefined !== tool ? tool.isValidLocation(ev, false) : true);\n    this.setIncompatibleViewportCursor(isValidLocation);\n\n    if (forceStartDrag || current.isStartDrag(ev.button)) {\n      current.onStartDrag(ev.button);\n      current.changeButtonToDownPoint(ev);\n      ev.isDragging = true;\n\n      if (undefined !== tool && isValidLocation)\n        tool.receivedDownEvent = true;\n\n      // Pass start drag event to idle tool if active tool doesn't explicitly handle it\n      if (undefined === tool || !isValidLocation || EventHandled.Yes !== await tool.onMouseStartDrag(ev))\n        return this.idleTool.onMouseStartDrag(ev);\n      return;\n    }\n\n    if (tool) {\n      tool.onMouseMotion(ev); // tslint:disable-line:no-floating-promises\n      this.updateDynamics(ev);\n    }\n\n    if (this.isLocateCircleOn)\n      vp.invalidateDecorations();\n  }\n\n  private async onMouseMove(event: ToolEvent): Promise<any> {\n    const vp = event.vp!;\n    const pos = this.getMousePosition(event);\n\n    // Sometimes the mouse goes down in a view, but we lose focus while its down so we never receive the up event.\n    // That makes it look like the motion is a drag. Fix that by clearing the \"isDown\" based on the buttons member of the MouseEvent.\n    const buttonMask = (event.ev as MouseEvent).buttons;\n    if (!(buttonMask & 1))\n      this.currentInputState.button[BeButton.Data].isDown = false;\n\n    return this.onMotion(vp, pos, InputSource.Mouse);\n  }\n\n  public adjustPointToACS(pointActive: Point3d, vp: Viewport, perpendicular: boolean): void {\n    // The \"I don't want ACS lock\" flag can be set by tools to override the default behavior\n    if (0 !== (this.toolState.coordLockOvr & CoordinateLockOverrides.ACS))\n      return;\n\n    let viewZRoot: Vector3d;\n\n    // Lock to the construction plane\n    if (vp.view.is3d() && vp.view.isCameraOn)\n      viewZRoot = vp.view.camera.eye.vectorTo(pointActive);\n    else\n      viewZRoot = vp.rotation.getRow(2);\n\n    const auxOriginRoot = vp.getAuxCoordOrigin();\n    const auxRMatrixRoot = vp.getAuxCoordRotation();\n    let auxNormalRoot = auxRMatrixRoot.getRow(2);\n\n    // If ACS xy plane is perpendicular to view and not snapping, project to closest xz or yz plane instead\n    if (auxNormalRoot.isPerpendicularTo(viewZRoot) && !TentativeOrAccuSnap.isHot) {\n      const auxXRoot = auxRMatrixRoot.getRow(0);\n      const auxYRoot = auxRMatrixRoot.getRow(1);\n      auxNormalRoot = (Math.abs(auxXRoot.dotProduct(viewZRoot)) > Math.abs(auxYRoot.dotProduct(viewZRoot))) ? auxXRoot : auxYRoot;\n    }\n    linePlaneIntersect(pointActive, pointActive, viewZRoot, auxOriginRoot, auxNormalRoot, perpendicular);\n  }\n\n  public adjustPointToGrid(pointActive: Point3d, vp: Viewport) {\n    // The \"I don't want grid lock\" flag can be set by tools to override the default behavior\n    if (!this.gridLock || 0 !== (this.toolState.coordLockOvr & CoordinateLockOverrides.Grid))\n      return;\n    vp.pointToGrid(pointActive);\n  }\n\n  public adjustPoint(pointActive: Point3d, vp: ScreenViewport, projectToACS: boolean = true, applyLocks: boolean = true): void {\n    if (Math.abs(pointActive.z) < 1.0e-7)\n      pointActive.z = 0.0; // remove Z fuzz introduced by active depth when near 0\n\n    let handled = false;\n\n    if (applyLocks && !(IModelApp.tentativePoint.isActive || IModelApp.accuSnap.isHot))\n      handled = IModelApp.accuDraw.adjustPoint(pointActive, vp, false);\n\n    // NOTE: We don't need to support axis lock, it is worthless if you have AccuDraw\n    if (!handled && vp.isPointAdjustmentRequired) {\n      if (applyLocks)\n        this.adjustPointToGrid(pointActive, vp);\n\n      if (projectToACS)\n        this.adjustPointToACS(pointActive, vp, false);\n    } else if (applyLocks) {\n      const savePoint = pointActive.clone();\n\n      this.adjustPointToGrid(pointActive, vp);\n\n      // if grid lock changes point, resend point to accudraw\n      if (handled && !pointActive.isExactEqual(savePoint))\n        IModelApp.accuDraw.adjustPoint(pointActive, vp, false);\n    }\n\n    if (Math.abs(pointActive.z) < 1.0e-7)\n      pointActive.z = 0.0;\n  }\n\n  public adjustSnapPoint(perpendicular: boolean = true): void {\n    const snap = TentativeOrAccuSnap.getCurrentSnap(false);\n    if (!snap)\n      return;\n\n    const vp = snap.viewport;\n    const isHot = snap.isHot;\n    const point = snap.getPoint().clone();\n    const savePt = point.clone();\n\n    if (!isHot) // Want point adjusted to grid for a hit that isn't hot\n      this.adjustPointToGrid(point, vp);\n\n    if (!IModelApp.accuDraw.adjustPoint(point, vp, isHot)) {\n      if (vp.isSnapAdjustmentRequired)\n        this.adjustPointToACS(point, vp, perpendicular || IModelApp.accuDraw.isActive);\n    }\n\n    if (!point.isExactEqual(savePt))\n      snap.adjustedPoint.setFrom(point);\n  }\n\n  /** @internal */\n  public async sendButtonEvent(ev: BeButtonEvent): Promise<any> {\n    const overlayHit = this.pickCanvasDecoration(ev);\n    if (undefined !== overlayHit && undefined !== overlayHit.onMouseButton && overlayHit.onMouseButton(ev))\n      return;\n    if (IModelApp.accuSnap.onPreButtonEvent(ev))\n      return;\n\n    const activeTool = this.activeTool;\n    let tool = activeTool;\n\n    if (undefined !== tool) {\n      if (!tool.isValidLocation(ev, true))\n        tool = undefined;\n      else if (ev.isDown)\n        tool.receivedDownEvent = true;\n      else if (tool.receivedDownEvent)\n        tool.receivedDownEvent = false;\n      else\n        tool = undefined;\n    }\n\n    if (IModelApp.accuDraw.onPreButtonEvent(ev))\n      return;\n\n    switch (ev.button) {\n      case BeButton.Data: {\n        if (undefined === tool) {\n          if (undefined !== activeTool)\n            break;\n          tool = this.idleTool; // Pass data button event to idle tool when no active tool present\n        }\n\n        if (ev.isDown) {\n          await tool.onDataButtonDown(ev);\n        } else {\n          await tool.onDataButtonUp(ev);\n          break;\n        }\n\n        // Lock tool to target model of this view on first data button\n        if (tool instanceof PrimitiveTool)\n          tool.autoLockTarget();\n\n        // Update tool dynamics. Use last data button location which was potentially adjusted by onDataButtonDown and not current event\n        this.updateDynamics(undefined, true);\n        break;\n      }\n\n      case BeButton.Reset: {\n        if (undefined === tool) {\n          if (undefined !== activeTool)\n            break;\n          tool = this.idleTool; // Pass reset button event to idle tool when no active tool present\n        }\n\n        if (ev.isDown)\n          await tool.onResetButtonDown(ev);\n        else\n          await tool.onResetButtonUp(ev);\n        break;\n      }\n\n      case BeButton.Middle: {\n        // Pass middle button event to idle tool when active tool doesn't explicitly handle it\n        if (ev.isDown) {\n          if (undefined === tool || EventHandled.Yes !== await tool.onMiddleButtonDown(ev))\n            await this.idleTool.onMiddleButtonDown(ev);\n        } else {\n          if (undefined === tool || EventHandled.Yes !== await tool.onMiddleButtonUp(ev))\n            await this.idleTool.onMiddleButtonUp(ev);\n        }\n        break;\n      }\n    }\n\n    IModelApp.tentativePoint.onButtonEvent(ev);\n    IModelApp.accuDraw.onPostButtonEvent(ev);\n  }\n\n  private async onButtonDown(vp: ScreenViewport, pt2d: XAndY, button: BeButton, inputSource: InputSource): Promise<any> {\n    const filtered = this.filterViewport(vp);\n    if (undefined === this._viewTool && button === BeButton.Data)\n      IModelApp.viewManager.setSelectedView(vp);\n    if (filtered)\n      return;\n\n    vp.removeAnimator();\n    const ev = new BeButtonEvent();\n    const current = this.currentInputState;\n    current.fromButton(vp, pt2d, inputSource, true);\n    current.onButtonDown(button);\n    current.toEvent(ev, true);\n    current.updateDownPoint(ev);\n\n    return this.sendButtonEvent(ev);\n  }\n\n  private async onButtonUp(vp: ScreenViewport, pt2d: XAndY, button: BeButton, inputSource: InputSource): Promise<any> {\n    if (this.filterViewport(vp))\n      return;\n\n    const ev = new BeButtonEvent();\n    const current = this.currentInputState;\n    const wasDragging = current.isDragging(button);\n    current.fromButton(vp, pt2d, inputSource, true);\n    current.onButtonUp(button);\n    current.toEvent(ev, true);\n\n    if (wasDragging)\n      return this.sendEndDragEvent(ev);\n\n    current.changeButtonToDownPoint(ev);\n    return this.sendButtonEvent(ev);\n  }\n\n  /** Called when any *modifier* (Shift, Alt, or Control) key is pressed or released. */\n  private async onModifierKeyTransition(wentDown: boolean, modifier: BeModifierKeys, event: KeyboardEvent): Promise<void> {\n    if (wentDown === this._modifierKeyWentDown && modifier === this._modifierKey)\n      return;\n\n    const activeTool = this.activeTool;\n    const changed = activeTool ? await activeTool.onModifierKeyTransition(wentDown, modifier, event) : EventHandled.No;\n\n    this._modifierKey = modifier;\n    this._modifierKeyWentDown = wentDown;\n\n    if (changed === EventHandled.Yes) {\n      IModelApp.viewManager.invalidateDecorationsAllViews();\n      this.updateDynamics();\n    }\n  }\n\n  private static getModifierKey(event: KeyboardEvent): BeModifierKeys {\n    switch (event.key) {\n      case \"Alt\": return BeModifierKeys.Alt;\n      case \"Shift\": return BeModifierKeys.Shift;\n      case \"Control\": return BeModifierKeys.Control;\n    }\n    return BeModifierKeys.None;\n  }\n\n  /** Event for every key down and up transition. */\n  private async onKeyTransition(event: ToolEvent, wentDown: boolean): Promise<any> {\n    const activeTool = this.activeTool;\n    if (!activeTool)\n      return;\n\n    const keyEvent = event.ev as KeyboardEvent;\n    this.currentInputState.setKeyQualifiers(keyEvent);\n\n    const modifierKey = ToolAdmin.getModifierKey(keyEvent);\n\n    if (BeModifierKeys.None !== modifierKey)\n      return this.onModifierKeyTransition(wentDown, modifierKey, keyEvent);\n\n    if (wentDown && keyEvent.ctrlKey) {\n      switch (keyEvent.key) {\n        case \"z\":\n        case \"Z\":\n          return this.doUndoOperation();\n        case \"y\":\n        case \"Y\":\n          return this.doRedoOperation();\n      }\n    }\n\n    return activeTool.onKeyTransition(wentDown, keyEvent);\n  }\n\n  /** Called to undo previous data button for primitive tools or undo last write operation. */\n  public async doUndoOperation(): Promise<boolean> {\n    const activeTool = this.activeTool;\n    if (activeTool instanceof PrimitiveTool) {\n      // ### TODO Add method so UI can be showing string to inform user that undo of last data point is available...\n      if (await activeTool.undoPreviousStep())\n        return true;\n    }\n    // ### TODO Request TxnManager undo and restart this.primitiveTool...\n    return false;\n  }\n\n  /** Called to redo previous data button for primitive tools or undo last write operation. */\n  public async doRedoOperation(): Promise<boolean> {\n    const activeTool = this.activeTool;\n    if (activeTool instanceof PrimitiveTool) {\n      // ### TODO Add method so UI can be showing string to inform user that undo of last data point is available...\n      if (await activeTool.redoPreviousStep())\n        return true;\n    }\n    // ### TODO Request TxnManager undo and restart this.primitiveTool...\n    return false;\n  }\n\n  private onUnsuspendTool() {\n    const tool = this.activeTool;\n    if (tool === undefined)\n      return;\n    tool.onUnsuspend();\n    this.activeToolChanged.raiseEvent(tool, StartOrResume.Resume);\n  }\n\n  /** @internal */\n  public setInputCollector(newTool?: InputCollector) {\n    if (undefined !== this._inputCollector) {\n      this._inputCollector.onCleanup();\n      this._inputCollector = undefined;\n    }\n    this._inputCollector = newTool;\n  }\n\n  /** @internal */\n  public exitInputCollector() {\n    if (undefined === this._inputCollector)\n      return;\n    let unsuspend = false;\n    if (this._suspendedByInputCollector) {\n      this._suspendedByInputCollector.stop();\n      this._suspendedByInputCollector = undefined;\n      unsuspend = true;\n    }\n\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n    this.setInputCollector(undefined);\n    if (unsuspend)\n      this.onUnsuspendTool();\n\n    IModelApp.accuDraw.onInputCollectorExit();\n    this.updateDynamics();\n  }\n\n  /** @internal */\n  public startInputCollector(newTool: InputCollector): void {\n    IModelApp.notifications.outputPrompt(\"\");\n    IModelApp.accuDraw.onInputCollectorInstall();\n\n    if (undefined !== this._inputCollector) {\n      this.setInputCollector(undefined);\n    } else {\n      const tool = this.activeTool;\n      if (tool)\n        tool.onSuspend();\n      this._suspendedByInputCollector = new SuspendedToolState();\n    }\n\n    IModelApp.viewManager.endDynamicsMode();\n    this.activeToolChanged.raiseEvent(newTool, StartOrResume.Start);\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n\n    this.setInputCollector(newTool);\n  }\n\n  /** @internal */\n  public setViewTool(newTool?: ViewTool) {\n    if (undefined !== this._viewTool) {\n      this._viewTool.onCleanup();\n      this._viewTool = undefined;\n    }\n    this._viewTool = newTool;\n  }\n\n  /** @internal */\n  public exitViewTool() {\n    if (undefined === this._viewTool)\n      return;\n    let unsuspend = false;\n    if (undefined !== this._suspendedByViewTool) {\n      this._suspendedByViewTool.stop(); // Restore state of suspended tool\n      this._suspendedByViewTool = undefined;\n      unsuspend = true;\n    }\n\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n    this.setViewTool(undefined);\n    if (unsuspend)\n      this.onUnsuspendTool();\n\n    IModelApp.accuDraw.onViewToolExit();\n    this.updateDynamics();\n  }\n\n  /** @internal */\n  public startViewTool(newTool: ViewTool) {\n\n    IModelApp.notifications.outputPrompt(\"\");\n    IModelApp.accuDraw.onViewToolInstall();\n\n    if (undefined !== this._viewTool) {\n      this.setViewTool(undefined);\n    } else {\n      const tool = this.activeTool;\n      if (tool)\n        tool.onSuspend();\n      this._suspendedByViewTool = new SuspendedToolState();\n    }\n\n    IModelApp.viewManager.endDynamicsMode();\n    this.activeToolChanged.raiseEvent(newTool, StartOrResume.Start);\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n\n    this.toolState.coordLockOvr = CoordinateLockOverrides.All;\n    this.toolState.locateCircleOn = false;\n\n    IModelApp.accuSnap.onStartTool();\n\n    this.setCursor(IModelApp.viewManager.crossHairCursor);\n    this.setViewTool(newTool);\n  }\n\n  /** @internal */\n  public setPrimitiveTool(newTool?: PrimitiveTool) {\n    if (undefined !== this._primitiveTool) {\n      this._primitiveTool.onCleanup();\n      this._primitiveTool = undefined;\n    }\n    this._primitiveTool = newTool;\n  }\n\n  /** @internal */\n  public startPrimitiveTool(newTool?: PrimitiveTool) {\n    IModelApp.notifications.outputPrompt(\"\");\n    this.exitViewTool();\n\n    if (undefined !== this._primitiveTool)\n      this.setPrimitiveTool(undefined);\n\n    // clear the primitive tool first so following call does not trigger the refreshing of the ToolSetting for the previous primitive tool\n    this.exitInputCollector();\n\n    IModelApp.viewManager.endDynamicsMode();\n    this.activeToolChanged.raiseEvent(undefined !== newTool ? newTool : this.idleTool, StartOrResume.Start);\n    this.setIncompatibleViewportCursor(true); // Don't restore this\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n\n    this.toolState.coordLockOvr = CoordinateLockOverrides.None;\n    this.toolState.locateCircleOn = false;\n\n    IModelApp.accuDraw.onPrimitiveToolInstall();\n    IModelApp.accuSnap.onStartTool();\n\n    if (undefined === newTool)\n      return;\n\n    this.setCursor(IModelApp.viewManager.crossHairCursor);\n    this.setPrimitiveTool(newTool);\n  }\n\n  /** Method used by interactive tools to send updated values to UI components, typically showing tool settings.\n   * @beta\n   */\n  public syncToolSettingsProperties(toolId: string, syncProperties: ToolSettingsPropertySyncItem[]): void {\n    if (this.toolSettingsChangeHandler)\n      this.toolSettingsChangeHandler(toolId, syncProperties);\n  }\n\n  /**\n   * Starts the default tool, if any. Generally invoked automatically when other tools exit, so shouldn't be called directly.\n   * @note The default tool is expected to be a subclass of [[PrimitiveTool]]. A call to startDefaultTool is required to terminate\n   * an active [[ViewTool]] or [[InputCollector]] and replace or clear the current [[PrimitiveTool]].\n   * @internal\n   */\n  public startDefaultTool() {\n    if (!IModelApp.tools.run(this.defaultToolId, this.defaultToolArgs))\n      this.startPrimitiveTool(undefined);\n  }\n\n  public setCursor(cursor: string | undefined): void {\n    if (undefined === this._saveCursor)\n      IModelApp.viewManager.setViewCursor(cursor);\n    else\n      this._saveCursor = cursor;\n  }\n\n  /** @internal */\n  public testDecorationHit(id: string): boolean { return this.currentTool.testDecorationHit(id); }\n\n  /** @internal */\n  public getDecorationGeometry(hit: HitDetail): GeometryStreamProps | undefined { return this.currentTool.getDecorationGeometry(hit); }\n\n  /** @internal */\n  public decorate(context: DecorateContext): void {\n    const tool = this.activeTool;\n    if (undefined !== tool) {\n      tool.decorate(context);\n\n      if (undefined !== this._inputCollector && tool !== this._inputCollector)\n        this._inputCollector.decorateSuspended(context);\n\n      if (undefined !== this._primitiveTool && tool !== this._primitiveTool)\n        this._primitiveTool.decorateSuspended(context);\n    }\n\n    const viewport = this.currentInputState.viewport;\n    if (viewport !== context.viewport)\n      return;\n\n    const ev = new BeButtonEvent();\n    this.fillEventFromCursorLocation(ev);\n\n    const hit = IModelApp.accuDraw.isActive ? undefined : IModelApp.accuSnap.currHit; // NOTE: Show surface normal until AccuDraw becomes active\n    viewport.drawLocateCursor(context, ev.point, viewport.pixelsFromInches(IModelApp.locateManager.apertureInches), this.isLocateCircleOn, hit);\n  }\n\n  public get isLocateCircleOn(): boolean { return this.toolState.locateCircleOn && this.currentInputState.inputSource === InputSource.Mouse && this._canvasDecoration === undefined; }\n\n  /** @internal */\n  public beginDynamics(): void {\n    IModelApp.accuDraw.onBeginDynamics();\n    IModelApp.viewManager.beginDynamicsMode();\n    this.setCursor(IModelApp.viewManager.dynamicsCursor);\n  }\n\n  /** @internal */\n  public endDynamics(): void {\n    IModelApp.accuDraw.onEndDynamics();\n    IModelApp.viewManager.endDynamicsMode();\n    this.setCursor(IModelApp.viewManager.crossHairCursor);\n  }\n\n  /** @internal */\n  public fillEventFromCursorLocation(ev: BeButtonEvent) { this.currentInputState.toEvent(ev, true); }\n  /** @internal */\n  public fillEventFromLastDataButton(ev: BeButtonEvent) { this.currentInputState.toEventFromLastDataPoint(ev); }\n  /** @internal */\n  public setAdjustedDataPoint(ev: BeButtonEvent) { this.currentInputState.adjustLastDataPoint(ev); }\n\n  /** Can be called by tools that wish to emulate mouse button down/up events for onTouchTap. */\n  public async convertTouchTapToButtonDownAndUp(ev: BeTouchEvent, button: BeButton = BeButton.Data): Promise<void> {\n    const pt2d = ev.viewPoint;\n    await this.onButtonDown(ev.viewport!, pt2d, button, InputSource.Touch);\n    return this.onButtonUp(ev.viewport!, pt2d, button, InputSource.Touch);\n  }\n\n  /** Can be called by tools that wish to emulate moving the mouse with a button depressed for onTouchMoveStart.\n   * @note Calls the tool's onMouseStartDrag method from onMotion.\n   */\n  public async convertTouchMoveStartToButtonDownAndMotion(startEv: BeTouchEvent, ev: BeTouchEvent, button: BeButton = BeButton.Data): Promise<void> {\n    await this.onButtonDown(startEv.viewport!, startEv.viewPoint, button, InputSource.Touch);\n    return this.onMotion(ev.viewport!, ev.viewPoint, InputSource.Touch, true);\n  }\n\n  /** Can be called by tools that wish to emulate pressing the mouse button for onTouchStart or onTouchMoveStart. */\n  public async convertTouchStartToButtonDown(ev: BeTouchEvent, button: BeButton = BeButton.Data): Promise<void> {\n    return this.onButtonDown(ev.viewport!, ev.viewPoint, button, InputSource.Touch);\n  }\n\n  /** Can be called by tools that wish to emulate releasing the mouse button for onTouchEnd or onTouchComplete.\n   * @note Calls the tool's onMouseEndDrag method if convertTouchMoveStartToButtonDownAndMotion was called for onTouchMoveStart.\n   */\n  public async convertTouchEndToButtonUp(ev: BeTouchEvent, button: BeButton = BeButton.Data): Promise<void> {\n    return this.onButtonUp(ev.viewport!, ev.viewPoint, button, InputSource.Touch);\n  }\n\n  /** Can be called by tools that wish to emulate a mouse motion event for onTouchMove. */\n  public async convertTouchMoveToMotion(ev: BeTouchEvent): Promise<void> {\n    return this.onMotion(ev.viewport!, ev.viewPoint, InputSource.Touch);\n  }\n\n  /** @internal */\n  public setIncompatibleViewportCursor(restore: boolean) {\n    if (restore) {\n      if (undefined === this._saveCursor)\n        return;\n\n      this.toolState.locateCircleOn = this._saveLocateCircle;\n      IModelApp.viewManager.setViewCursor(this._saveCursor);\n      this._saveCursor = undefined;\n      return;\n    }\n\n    if (undefined !== this._saveCursor)\n      return;\n\n    this._saveLocateCircle = this.toolState.locateCircleOn;\n    this._saveCursor = IModelApp.viewManager.cursor;\n    this.toolState.locateCircleOn = false;\n    IModelApp.viewManager.setViewCursor(\"not-allowed\");\n  }\n\n  /** Performs default handling of mouse wheel event (zoom in/out) */\n  public async processWheelEvent(ev: BeWheelEvent, doUpdate: boolean): Promise<EventHandled> {\n    await WheelEventProcessor.process(ev, doUpdate);\n    this.updateDynamics(ev);\n    IModelApp.viewManager.invalidateDecorationsAllViews();\n    return EventHandled.Yes;\n  }\n\n  /** @internal */\n  public onSelectedViewportChanged(previous: ScreenViewport | undefined, current: ScreenViewport | undefined): void {\n    IModelApp.accuDraw.onSelectedViewportChanged(previous, current);\n\n    if (undefined === current) {\n      this.callOnCleanup();\n      return;\n    }\n\n    if (undefined !== this._viewTool)\n      this._viewTool.onSelectedViewportChanged(previous, current);\n\n    if (undefined !== this._inputCollector)\n      this._inputCollector.onSelectedViewportChanged(previous, current);\n\n    if (undefined !== this._primitiveTool)\n      this._primitiveTool.onSelectedViewportChanged(previous, current);\n  }\n\n  public setLocateCircleOn(locateOn: boolean): void {\n    if (undefined === this._saveCursor)\n      this.toolState.locateCircleOn = locateOn;\n    else\n      this._saveLocateCircle = locateOn;\n  }\n\n  public setLocateCursor(enableLocate: boolean): void {\n    const { viewManager } = IModelApp;\n    this.setCursor(viewManager.inDynamicsMode ? IModelApp.viewManager.dynamicsCursor : IModelApp.viewManager.crossHairCursor);\n    this.setLocateCircleOn(enableLocate);\n    viewManager.invalidateDecorationsAllViews();\n  }\n\n  /** @internal */\n  public callOnCleanup(): void {\n    this.exitViewTool();\n    this.exitInputCollector();\n    if (undefined !== this._primitiveTool)\n      this._primitiveTool.onCleanup();\n  }\n}\n\n/**\n * Default processor to handle wheel events.\n * @internal\n */\nexport class WheelEventProcessor {\n  public static async process(ev: BeWheelEvent, doUpdate: boolean): Promise<void> {\n    const vp = ev.viewport;\n    if (undefined === vp)\n      return;\n\n    await this.doZoom(ev);\n\n    if (doUpdate) {\n      vp.synchWithView(true);\n\n      // AccuSnap hit won't be invalidated without cursor motion (closes info window, etc.).\n      IModelApp.accuSnap.clear();\n    }\n  }\n\n  private static async doZoom(ev: BeWheelEvent): Promise<ViewStatus> {\n    const vp = ev.viewport;\n    if (undefined === vp)\n      return ViewStatus.InvalidViewport;\n\n    let zoomRatio = ToolSettings.wheelZoomRatio;\n    if (zoomRatio < 1)\n      zoomRatio = 1;\n    if (ev.wheelDelta > 0)\n      zoomRatio = 1 / zoomRatio;\n\n    let isSnapOrPrecision = false;\n    const target = Point3d.create();\n    if (IModelApp.tentativePoint.isActive) {\n      // Always use Tentative location, adjusted point, not cross\n      isSnapOrPrecision = true;\n      target.setFrom(IModelApp.tentativePoint.getPoint());\n    } else {\n      // Never use AccuSnap location as initial zoom clears snap causing zoom center to \"jump\"\n      isSnapOrPrecision = CoordSource.Precision === ev.coordsFrom;\n      target.setFrom(isSnapOrPrecision ? ev.point : ev.rawPoint);\n    }\n\n    let status: ViewStatus;\n    if (vp.view.is3d() && vp.isCameraOn) {\n      let lastEventWasValid: boolean = false;\n      if (!isSnapOrPrecision) {\n        const targetNpc = vp.worldToNpc(target);\n        const newTarget = new Point3d();\n        const lastEvent = IModelApp.toolAdmin.currentInputState.lastWheelEvent;\n        if (lastEvent && lastEvent.viewport && lastEvent.viewport.view.equals(vp.view) && lastEvent.viewPoint.distanceSquaredXY(ev.viewPoint) < 10) {\n          vp.worldToNpc(lastEvent.point, newTarget);\n          targetNpc.z = newTarget.z;\n          lastEventWasValid = true;\n        } else if (undefined !== vp.pickNearestVisibleGeometry(target, vp.pixelsFromInches(ToolSettings.viewToolPickRadiusInches), true, newTarget)) {\n          vp.worldToNpc(newTarget, newTarget);\n          targetNpc.z = newTarget.z;\n        } else {\n          vp.view.getTargetPoint(newTarget);\n          vp.worldToNpc(newTarget, newTarget);\n          targetNpc.z = newTarget.z;\n        }\n        vp.npcToWorld(targetNpc, target);\n      }\n\n      const cameraView: ViewState3d = vp.view;\n      const transform = Transform.createFixedPointAndMatrix(target, Matrix3d.createScale(zoomRatio, zoomRatio, zoomRatio));\n      const oldCameraPos = cameraView.getEyePoint();\n      const newCameraPos = transform.multiplyPoint3d(oldCameraPos);\n      const offset = Vector3d.createStartEnd(oldCameraPos, newCameraPos);\n\n      // when you're too close to an object, the wheel zoom operation will stop. We set a \"bump distance\" so you can blast through obstacles.\n      if (!isSnapOrPrecision && offset.magnitude() < ToolSettings.wheelZoomBumpDistance) {\n        offset.scaleToLength(ToolSettings.wheelZoomBumpDistance / 3.0, offset); // move 1/3 of the bump distance, just to get to the other side.\n        lastEventWasValid = false;\n        target.addInPlace(offset);\n      }\n\n      const viewTarget = cameraView.getTargetPoint().clone();\n      viewTarget.addInPlace(offset);\n      newCameraPos.setFrom(oldCameraPos.plus(offset));\n\n      if (!lastEventWasValid) {\n        const thisEvent = ev.clone();\n        thisEvent.point.setFrom(target);\n        IModelApp.toolAdmin.currentInputState.lastWheelEvent = thisEvent;\n      }\n\n      status = cameraView.lookAt(newCameraPos, viewTarget, cameraView.getYVector());\n      vp.synchWithView(false);\n    } else {\n      const targetNpc = vp.worldToNpc(target);\n      const trans = Transform.createFixedPointAndMatrix(targetNpc, Matrix3d.createScale(zoomRatio, zoomRatio, 1));\n      const viewCenter = Point3d.create(.5, .5, .5);\n\n      trans.multiplyPoint3d(viewCenter, viewCenter);\n      vp.npcToWorld(viewCenter, viewCenter);\n      vp.zoom(viewCenter, zoomRatio, { saveInUndo: false, animateFrustumChange: false });\n      status = ViewStatus.Success;\n    }\n\n    // if we scrolled out, we may have invalidated the current AccuSnap path\n    await IModelApp.accuSnap.reEvaluate();\n    return status;\n  }\n}\n","/*---------------------------------------------------------------------------------------------\n* Copyright (c) 2019 Bentley Systems, Incorporated. All rights reserved.\n* Licensed under the MIT License. See LICENSE.md in the project root for license terms.\n*--------------------------------------------------------------------------------------------*/\n/** @module Tools */\n\nimport { Angle, Matrix3d, Point2d, Point3d, Range3d, Transform, Vector2d, Vector3d, YawPitchRollAngles, ClipUtilities } from \"@bentley/geometry-core\";\nimport { ColorDef, Frustum, Npc, NpcCenter } from \"@bentley/imodeljs-common\";\nimport { TentativeOrAccuSnap } from \"../AccuSnap\";\nimport { IModelApp } from \"../IModelApp\";\nimport { GraphicType } from \"../rendering\";\nimport { DecorateContext } from \"../ViewContext\";\nimport { CoordSystem, ScreenViewport, Viewport, ViewRect } from \"../Viewport\";\nimport { MarginPercent, ViewState3d, ViewStatus } from \"../ViewState\";\nimport { BeButton, BeButtonEvent, BeTouchEvent, BeWheelEvent, CoordSource, EventHandled, InputSource, InteractiveTool, ToolSettings } from \"./Tool\";\nimport { AccuDraw } from \"../AccuDraw\";\nimport { StandardViewId } from \"../StandardView\";\n\n/** @internal */\nconst enum ViewHandleWeight {\n  Thin = 1,\n  Normal = 2,\n  Bold = 3,\n  VeryBold = 4,\n  FatDot = 8,\n}\n\n/** @internal */\nexport const enum ViewHandleType {  // tslint:disable-line:no-const-enum\n  EXTERIOR = 0x00000001,\n  None = 0,\n  Rotate = 1,\n  TargetCenter = 1 << 1,\n  Pan = 1 << 2,\n  Scroll = 1 << 3,\n  Zoom = 1 << 4,\n  Walk = 1 << 5,\n  Fly = 1 << 6,\n  Look = 1 << 7,\n}\n\n/** @internal */\nconst enum ViewManipPriority {\n  Low = 1,\n  Normal = 10,\n  Medium = 100,\n  High = 1000,\n}\n\n/** @internal */\nconst enum OrientationResult {\n  Success = 0,\n  NoEvent = 1,\n  Disabled = 2,\n  RejectedByController = 3,\n}\n\nconst enum NavigateMode { Pan = 0, Look = 1, Travel = 2 }\n\n/** An InteractiveTool that manipulates a view.\n * @public\n */\nexport abstract class ViewTool extends InteractiveTool {\n  public inDynamicUpdate = false;\n  public beginDynamicUpdate() { this.inDynamicUpdate = true; }\n  public endDynamicUpdate() { this.inDynamicUpdate = false; }\n  public run(): boolean {\n    const toolAdmin = IModelApp.toolAdmin;\n    if (undefined !== this.viewport && this.viewport === toolAdmin.markupView) {\n      IModelApp.notifications.outputPromptByKey(\"Viewing.NotDuringMarkup\");\n      return false;\n    }\n\n    if (!toolAdmin.onInstallTool(this))\n      return false;\n\n    toolAdmin.startViewTool(this);\n    toolAdmin.onPostInstallTool(this);\n    return true;\n  }\n\n  public constructor(public viewport?: ScreenViewport) { super(); }\n  public async onResetButtonUp(_ev: BeButtonEvent) { this.exitTool(); return EventHandled.Yes; }\n\n  /** Do not override. */\n  public exitTool(): void { IModelApp.toolAdmin.exitViewTool(); }\n  public static showPrompt(prompt: string) { IModelApp.notifications.outputPromptByKey(\"CoreTools:tools.View.\" + prompt); }\n\n}\n\n/** @internal */\nexport abstract class ViewingToolHandle {\n  constructor(public viewTool: ViewManip) { }\n  public onReinitialize(): void { }\n  public focusOut(): void { }\n  public noMotion(_ev: BeButtonEvent): boolean { return false; }\n  public motion(_ev: BeButtonEvent): boolean { return false; }\n  public checkOneShot(): boolean { return true; }\n  public getHandleCursor(): string { return \"default\"; }\n  public abstract doManipulation(ev: BeButtonEvent, inDynamics: boolean): boolean;\n  public abstract firstPoint(ev: BeButtonEvent): boolean;\n  public abstract testHandleForHit(ptScreen: Point3d, out: { distance: number, priority: ViewManipPriority }): boolean;\n  public abstract get handleType(): ViewHandleType;\n  public focusIn(): void { IModelApp.toolAdmin.setCursor(this.getHandleCursor()); }\n  public drawHandle(_context: DecorateContext, _hasFocus: boolean): void { }\n}\n\n/** @internal */\nexport class ViewHandleArray {\n  public handles: ViewingToolHandle[] = [];\n  public focus = -1;\n  public focusDrag = false;\n  public hitHandleIndex = 0;\n  public viewport?: Viewport;\n  constructor(public viewTool: ViewManip) { }\n\n  public empty() {\n    this.focus = -1;\n    this.focusDrag = false;\n    this.hitHandleIndex = -1; // setting to -1 will result in onReinitialize getting called before testHit which sets the hit index\n    this.handles.length = 0;\n  }\n\n  public get count(): number { return this.handles.length; }\n  public get hitHandle(): ViewingToolHandle | undefined { return this.getByIndex(this.hitHandleIndex); }\n  public get focusHandle(): ViewingToolHandle | undefined { return this.getByIndex(this.focus); }\n  public add(handle: ViewingToolHandle): void { this.handles.push(handle); }\n  public getByIndex(index: number): ViewingToolHandle | undefined { return (index >= 0 && index < this.count) ? this.handles[index] : undefined; }\n  public focusHitHandle(): void { this.setFocus(this.hitHandleIndex); }\n\n  public testHit(ptScreen: Point3d, forced = ViewHandleType.None): boolean {\n    this.hitHandleIndex = -1;\n    const data = { distance: 0.0, priority: ViewManipPriority.Normal };\n    let minDistance = 0.0;\n    let minDistValid = false;\n    let highestPriority = ViewManipPriority.Low;\n    let nearestHitHandle: ViewingToolHandle | undefined;\n\n    for (let i = 0; i < this.count; i++) {\n      data.priority = ViewManipPriority.Normal;\n      const handle = this.handles[i];\n\n      if (forced) {\n        if (handle.handleType === forced) {\n          this.hitHandleIndex = i;\n          return true;\n        }\n      } else if (handle.testHandleForHit(ptScreen, data)) {\n        if (data.priority >= highestPriority) {\n          if (data.priority > highestPriority)\n            minDistValid = false;\n\n          highestPriority = data.priority;\n\n          if (!minDistValid || (data.distance < minDistance)) {\n            minDistValid = true;\n            minDistance = data.distance;\n            nearestHitHandle = handle;\n            this.hitHandleIndex = i;\n          }\n        }\n      }\n    }\n    return undefined !== nearestHitHandle;\n  }\n\n  public drawHandles(context: DecorateContext): void {\n    if (0 === this.count)\n      return;\n\n    // all handle objects must draw themselves\n    for (let i = 0; i < this.count; ++i) {\n      if (i !== this.hitHandleIndex) {\n        const handle = this.handles[i];\n        handle.drawHandle(context, this.focus === i);\n      }\n    }\n\n    // draw the hit handle last\n    if (-1 !== this.hitHandleIndex) {\n      const handle = this.handles[this.hitHandleIndex];\n      handle.drawHandle(context, this.focus === this.hitHandleIndex);\n    }\n  }\n\n  public setFocus(index: number): void {\n    if (this.focus === index && (this.focusDrag === this.viewTool.inHandleModify))\n      return;\n\n    let focusHandle: ViewingToolHandle | undefined;\n    if (this.focus >= 0) {\n      focusHandle = this.getByIndex(this.focus);\n      if (focusHandle)\n        focusHandle.focusOut();\n    }\n\n    if (index >= 0) {\n      focusHandle = this.getByIndex(index);\n      if (focusHandle)\n        focusHandle.focusIn();\n    }\n\n    this.focus = index;\n    this.focusDrag = this.viewTool.inHandleModify;\n\n    if (undefined !== this.viewport)\n      this.viewport.invalidateDecorations();\n  }\n\n  public onReinitialize() { this.handles.forEach((handle) => handle.onReinitialize()); }\n  public motion(ev: BeButtonEvent) { this.handles.forEach((handle) => handle.motion(ev)); }\n\n  /** determine whether a handle of a specific type exists */\n  public hasHandle(handleType: ViewHandleType): boolean { return this.handles.some((handle) => handle.handleType === handleType); }\n}\n\n/** Base class for tools that manipulate the frustum of a Viewport.\n * @public\n */\nexport abstract class ViewManip extends ViewTool {\n  /** @internal */\n  public viewHandles: ViewHandleArray;\n  public frustumValid = false;\n  public readonly targetCenterWorld = new Point3d();\n  public inHandleModify = false;\n  public isDragging = false;\n  public stoppedOverHandle = false;\n  public targetCenterValid = false;\n  public targetCenterLocked = false;\n  public nPts = 0;\n  /** @internal */\n  protected _forcedHandle = ViewHandleType.None;\n\n  constructor(viewport: ScreenViewport | undefined, public handleMask: number, public oneShot: boolean, public isDraggingRequired: boolean = false) {\n    super(viewport);\n    this.viewHandles = new ViewHandleArray(this);\n    this.changeViewport(viewport);\n  }\n\n  public decorate(context: DecorateContext): void { this.viewHandles.drawHandles(context); }\n\n  public onReinitialize(): void {\n    if (undefined !== this.viewport) {\n      this.viewport.synchWithView(true); // make sure we store any changes in view undo buffer.\n      this.viewHandles.setFocus(-1);\n    }\n\n    this.nPts = 0;\n    this.inHandleModify = false;\n    this.inDynamicUpdate = false;\n    this.frustumValid = false;\n\n    this.viewHandles.onReinitialize();\n  }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    // Tool was started in \"drag required\" mode, don't advance tool state and wait to see if we get the start drag event.\n    if (0 === this.nPts && this.isDraggingRequired && !this.isDragging || undefined === ev.viewport)\n      return EventHandled.No;\n\n    switch (this.nPts) {\n      case 0:\n        this.changeViewport(ev.viewport);\n        if (this.processFirstPoint(ev))\n          this.nPts = 1;\n        break;\n      case 1:\n        this.nPts = 2;\n        break;\n    }\n\n    if (this.nPts > 1) {\n      this.inDynamicUpdate = false;\n      if (this.processPoint(ev, false) && this.oneShot)\n        this.exitTool();\n      else\n        this.onReinitialize();\n    }\n\n    return EventHandled.Yes;\n  }\n\n  public async onDataButtonUp(_ev: BeButtonEvent): Promise<EventHandled> {\n    if (this.nPts <= 1 && this.isDraggingRequired && !this.isDragging && this.oneShot)\n      this.exitTool();\n\n    return EventHandled.No;\n  }\n\n  public async onMouseWheel(inputEv: BeWheelEvent): Promise<EventHandled> {\n    const ev = inputEv.clone();\n\n    // If rotate is active, the mouse wheel should about the target center when it's displayed...\n    if ((this.handleMask & ViewHandleType.Rotate) && (this.targetCenterLocked || this.inHandleModify)) {\n      ev.point = this.targetCenterWorld;\n      ev.coordsFrom = CoordSource.Precision; // don't want raw point used...\n    }\n\n    IModelApp.toolAdmin.processWheelEvent(ev, false); // tslint:disable-line:no-floating-promises\n    return EventHandled.Yes;\n  }\n\n  /** @internal */\n  public async startHandleDrag(ev: BeButtonEvent, forcedHandle?: ViewHandleType): Promise<EventHandled> {\n    if (this.inHandleModify)\n      return EventHandled.No; // If already changing the view reject the request...\n\n    if (undefined !== forcedHandle) {\n      if (!this.viewHandles.hasHandle(forcedHandle))\n        return EventHandled.No; // If requested handle isn't present reject the request...\n      this._forcedHandle = forcedHandle;\n    }\n\n    this.receivedDownEvent = true; // Request up events even though we may not have gotten the down event...\n    this.isDragging = true;\n\n    if (0 === this.nPts)\n      this.onDataButtonDown(ev); // tslint:disable-line:no-floating-promises\n\n    return EventHandled.Yes;\n  }\n\n  public async onMouseStartDrag(ev: BeButtonEvent): Promise<EventHandled> {\n    switch (ev.button) {\n      case BeButton.Reset:\n        return EventHandled.No;\n      case BeButton.Middle:\n        if (!this.viewHandles.hasHandle(ViewHandleType.Walk) && !this.viewHandles.hasHandle(ViewHandleType.Fly)) // Allow middle drag to override IdleTool for walk/fly...\n          return EventHandled.No;\n    }\n    return this.startHandleDrag(ev);\n  }\n\n  public async onMouseEndDrag(ev: BeButtonEvent): Promise<EventHandled> {\n    // NOTE: To support startHandleDrag being called by IdleTool for middle button drag, check inHandleModify and not the button type...\n    if (!this.inHandleModify)\n      return EventHandled.No;\n\n    this.isDragging = false;\n\n    if (0 === this.nPts)\n      return EventHandled.Yes;\n\n    return this.onDataButtonDown(ev);\n  }\n\n  public async onMouseMotion(ev: BeButtonEvent) {\n    this.stoppedOverHandle = false;\n    if (0 === this.nPts && this.viewHandles.testHit(ev.viewPoint))\n      this.viewHandles.focusHitHandle();\n\n    if (0 !== this.nPts)\n      this.processPoint(ev, true);\n\n    this.viewHandles.motion(ev);\n  }\n\n  public async onMouseMotionStopped(ev: BeButtonEvent) {\n    if (ev.viewport !== this.viewport)\n      return;\n\n    if (0 === this.nPts) {\n      if (this.viewHandles.testHit(ev.viewPoint)) {\n        this.stoppedOverHandle = true;\n        this.viewHandles.focusHitHandle();\n      } else if (this.stoppedOverHandle) {\n        this.stoppedOverHandle = false;\n        this.viewport!.invalidateDecorations();\n      }\n    }\n  }\n\n  public async onMouseNoMotion(ev: BeButtonEvent) {\n    if (0 === this.nPts || !ev.viewport)\n      return;\n\n    const hitHandle = this.viewHandles.hitHandle;\n    if (hitHandle)\n      hitHandle.noMotion(ev);\n  }\n\n  public async onTouchTap(ev: BeTouchEvent): Promise<EventHandled> { return ev.isSingleTap ? EventHandled.Yes : EventHandled.No; } // Prevent IdleTool from converting single tap into data button down/up...\n  public async onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled> { if (!this.inHandleModify && startEv.isSingleTouch) await IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev); return this.inHandleModify ? EventHandled.Yes : EventHandled.No; }\n  public async onTouchMove(ev: BeTouchEvent): Promise<void> { if (this.inHandleModify) return IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }\n  public async onTouchComplete(ev: BeTouchEvent): Promise<void> { if (this.inHandleModify) return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }\n  public async onTouchCancel(ev: BeTouchEvent): Promise<void> { if (this.inHandleModify) return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, BeButton.Reset); }\n\n  public onPostInstall(): void {\n    super.onPostInstall();\n    this.onReinitialize(); // Call onReinitialize now that tool is installed.\n  }\n\n  public onCleanup(): void {\n    let restorePrevious = false;\n\n    if (this.inDynamicUpdate) {\n      this.endDynamicUpdate();\n      restorePrevious = true;\n    }\n\n    const vp = this.viewport;\n    if (undefined !== vp) {\n      vp.synchWithView(true);\n\n      if (restorePrevious)\n        vp.doUndo(ToolSettings.animationTime);\n\n      vp.invalidateDecorations();\n    }\n    this.viewHandles.empty();\n  }\n\n  public updateTargetCenter(): void {\n    const vp = this.viewport;\n    if (!vp)\n      return;\n\n    if (this.targetCenterValid) {\n      if (this.inHandleModify)\n        return;\n      if (IModelApp.tentativePoint.isActive) {\n        this.setTargetCenterWorld(IModelApp.tentativePoint.getPoint(), true, false);\n        IModelApp.tentativePoint.clear(true); // Clear tentative, there won't be a datapoint to accept...\n      }\n      return;\n    }\n\n    if (IModelApp.tentativePoint.isActive)\n      return this.setTargetCenterWorld(IModelApp.tentativePoint.getPoint(), true, false);\n\n    if (TentativeOrAccuSnap.isHot)\n      return this.setTargetCenterWorld(TentativeOrAccuSnap.getCurrentPoint(), true, false);\n\n    if (vp.viewCmdTargetCenter && this.isPointVisible(vp.viewCmdTargetCenter))\n      return this.setTargetCenterWorld(vp.viewCmdTargetCenter, true, true);\n\n    if (!vp.view.allow3dManipulations()) {\n      const defaultPoint = vp.npcToWorld(NpcCenter); defaultPoint.z = 0.0;\n      return this.setTargetCenterWorld(defaultPoint, false, false);\n    }\n\n    const visiblePoint = vp.pickNearestVisibleGeometry(vp.npcToWorld(NpcCenter), vp.pixelsFromInches(ToolSettings.viewToolPickRadiusInches));\n    this.setTargetCenterWorld(undefined !== visiblePoint ? visiblePoint : vp.view.getTargetPoint(), false, false);\n  }\n\n  public processFirstPoint(ev: BeButtonEvent) {\n    const forcedHandle = this._forcedHandle;\n    this._forcedHandle = ViewHandleType.None;\n    this.frustumValid = false;\n\n    if (this.viewHandles.testHit(ev.viewPoint, forcedHandle)) {\n      this.inHandleModify = true;\n      this.viewHandles.focusHitHandle();\n      const handle = this.viewHandles.hitHandle;\n      if (undefined !== handle && !handle.firstPoint(ev))\n        return false;\n    }\n\n    return true;\n  }\n\n  public processPoint(ev: BeButtonEvent, inDynamics: boolean) {\n    const hitHandle = this.viewHandles.hitHandle;\n    if (undefined === hitHandle)\n      return true;\n\n    const doUpdate = hitHandle.doManipulation(ev, inDynamics);\n    return inDynamics || (doUpdate && hitHandle.checkOneShot());\n  }\n\n  public lensAngleMatches(angle: Angle, tolerance: number) {\n    const cameraView = this.viewport!.view;\n    return !cameraView.is3d() ? false : Math.abs(cameraView.calcLensAngle().radians - angle.radians) < tolerance;\n  }\n\n  public get isZUp() {\n    const view = this.viewport!.view;\n    const viewX = view.getXVector();\n    const viewY = view.getXVector();\n    const zVec = Vector3d.unitZ();\n    return (Math.abs(zVec.dotProduct(viewY)) > 0.99 && Math.abs(zVec.dotProduct(viewX)) < 0.01);\n  }\n\n  public static getFocusPlaneNpc(vp: Viewport): number {\n    const pt = vp.view.getTargetPoint();\n    if (pt.z < 0.0 || pt.z > 1.0) {\n      pt.set(0.5, 0.5, 0.0);\n      const pt2 = new Point3d(0.5, 0.5, 1.0);\n      vp.npcToWorld(pt, pt);\n      vp.npcToWorld(pt2, pt2);\n      pt.interpolate(0.5, pt2, pt);\n      vp.worldToNpc(pt, pt);\n    }\n\n    return pt.z;\n  }\n\n  /**\n   * Set the target point for viewing operations.\n   * @param pt the new target point in world coordinates\n   * @param lockTarget consider the target point locked for this tool instance\n   * @param saveTarget save this target point for use between tool instances\n   */\n  public setTargetCenterWorld(pt: Point3d, lockTarget: boolean, saveTarget: boolean) {\n    this.targetCenterWorld.setFrom(pt);\n    this.targetCenterValid = true;\n    this.targetCenterLocked = lockTarget;\n\n    if (!this.viewport)\n      return;\n\n    if (!this.viewport.view.allow3dManipulations())\n      this.targetCenterWorld.z = 0.0;\n\n    this.viewport.viewCmdTargetCenter = (saveTarget ? pt : undefined);\n  }\n\n  /** Determine whether the supplied point is visible in this Viewport. */\n  public isPointVisible(testPt: Point3d): boolean {\n    const vp = this.viewport;\n    if (!vp)\n      return false;\n    const testPtView = vp.worldToView(testPt);\n    const frustum = vp.getFrustum(CoordSystem.View, false);\n\n    const screenRange = Point3d.create(\n      frustum.points[Npc._000].distance(frustum.points[Npc._100]),\n      frustum.points[Npc._000].distance(frustum.points[Npc._010]),\n      frustum.points[Npc._000].distance(frustum.points[Npc._001]));\n\n    return (!((testPtView.x < 0 || testPtView.x > screenRange.x) || (testPtView.y < 0 || testPtView.y > screenRange.y)));\n  }\n\n  protected static _useViewAlignedVolume: boolean = false;\n  public static fitView(viewport: ScreenViewport, doAnimate: boolean, marginPercent?: MarginPercent) {\n    const range = viewport.computeViewRange();\n    const aspect = viewport.viewRect.aspect;\n    const before = viewport.getFrustum();\n\n    const clip = (viewport.viewFlags.clipVolume ? viewport.view.getViewClip() : undefined);\n    if (undefined !== clip) {\n      const clipRange = ClipUtilities.rangeOfClipperIntersectionWithRange(clip, range);\n      if (!clipRange.isNull)\n        range.setFrom(clipRange);\n    }\n\n    if (this._useViewAlignedVolume)\n      viewport.view.lookAtViewAlignedVolume(range, aspect, marginPercent);\n    else\n      viewport.view.lookAtVolume(range, aspect, marginPercent);\n\n    viewport.synchWithView(false);\n    const after = viewport.getFrustum();\n    viewport.view.setupFromFrustum(after);\n    viewport.synchWithView(true);\n    viewport.viewCmdTargetCenter = undefined;\n\n    if (doAnimate)\n      viewport.animateFrustumChange(before, after);\n  }\n\n  public static async zoomToAlwaysDrawnExclusive(viewport: ScreenViewport, doAnimate: boolean, marginPercent?: MarginPercent): Promise<boolean> {\n    if (!viewport.isAlwaysDrawnExclusive || undefined === viewport.alwaysDrawn || 0 === viewport.alwaysDrawn.size)\n      return false;\n    await viewport.zoomToElements(viewport.alwaysDrawn, { animateFrustumChange: doAnimate, marginPercent });\n    return true;\n  }\n\n  public setCameraLensAngle(lensAngle: Angle, retainEyePoint: boolean): ViewStatus {\n    const vp = this.viewport;\n    if (!vp)\n      return ViewStatus.InvalidViewport;\n\n    const view = vp.view;\n    if (!view || !view.is3d() || !view.allow3dManipulations())\n      return ViewStatus.InvalidViewport;\n\n    const result = (retainEyePoint && view.isCameraOn) ?\n      view.lookAtUsingLensAngle(view.getEyePoint(), view.getTargetPoint(), view.getYVector(), lensAngle) :\n      vp.turnCameraOn(lensAngle);\n\n    if (result !== ViewStatus.Success)\n      return result;\n\n    vp.synchWithView(false);\n\n    if (!this.targetCenterLocked) {\n      this.targetCenterValid = false;\n      this.updateTargetCenter(); // Update default rotate point for when the camera needed to be turned on...\n    }\n\n    return ViewStatus.Success;\n  }\n\n  public enforceZUp(pivotPoint: Point3d) {\n    const vp = this.viewport;\n    if (!vp || this.isZUp)\n      return false;\n\n    const view = vp.view;\n    const viewY = view.getYVector();\n    const rotMatrix = Matrix3d.createRotationVectorToVector(viewY, Vector3d.unitZ());\n    if (!rotMatrix)\n      return false;\n\n    const transform = Transform.createFixedPointAndMatrix(pivotPoint, rotMatrix);\n    const frust = vp.getWorldFrustum();\n    frust.multiply(transform);\n    vp.setupViewFromFrustum(frust);\n    return true;\n  }\n\n  public changeViewport(vp?: ScreenViewport): void {\n    if (vp === this.viewport && 0 !== this.viewHandles.count) // If viewport isn't really changing do nothing...\n      return;\n\n    if (this.viewport) {\n      this.viewport.invalidateDecorations(); // Remove decorations from current viewport...\n      this.viewHandles.empty();\n    }\n\n    this.viewport = vp;\n    if (this.viewport === undefined)\n      return;\n\n    this.viewHandles.viewport = vp;\n    this.targetCenterValid = false;\n    this.updateTargetCenter();\n\n    if (this.handleMask & ViewHandleType.Rotate)\n      this.viewHandles.add(new ViewRotate(this));\n\n    if (this.handleMask & ViewHandleType.TargetCenter)\n      this.viewHandles.add(new ViewTargetCenter(this));\n\n    if (this.handleMask & ViewHandleType.Pan)\n      this.viewHandles.add(new ViewPan(this));\n\n    if (this.handleMask & ViewHandleType.Scroll)\n      this.viewHandles.add(new ViewScroll(this));\n\n    if (this.handleMask & ViewHandleType.Zoom)\n      this.viewHandles.add(new ViewZoom(this));\n\n    if (this.handleMask & ViewHandleType.Walk)\n      this.viewHandles.add(new ViewWalk(this));\n\n    if (this.handleMask & ViewHandleType.Fly)\n      this.viewHandles.add(new ViewFly(this));\n\n    if (this.handleMask & ViewHandleType.Look)\n      this.viewHandles.add(new ViewLook(this));\n  }\n}\n\n/** ViewingToolHandle for modifying the view's target point for operations like rotate */\nclass ViewTargetCenter extends ViewingToolHandle {\n  public get handleType() { return ViewHandleType.TargetCenter; }\n  public checkOneShot(): boolean { return false; } // Don't exit tool after moving target in single-shot mode...\n\n  public firstPoint(ev: BeButtonEvent) {\n    if (!ev.viewport)\n      return false;\n    IModelApp.accuSnap.enableSnap(true);\n    return true;\n  }\n\n  public testHandleForHit(ptScreen: Point3d, out: { distance: number, priority: ViewManipPriority }): boolean {\n    if (this.viewTool.isDraggingRequired)\n      return false; // Target center handle is not movable in this mode, but it's still nice to display the point we're rotating about...\n\n    const targetPt = this.viewTool.viewport!.worldToView(this.viewTool.targetCenterWorld);\n    const distance = targetPt.distanceXY(ptScreen);\n    const locateThreshold = this.viewTool.viewport!.pixelsFromInches(0.15);\n\n    if (distance > locateThreshold)\n      return false;\n\n    out.distance = distance;\n    out.priority = ViewManipPriority.High;\n    return true;\n  }\n\n  public drawHandle(context: DecorateContext, hasFocus: boolean): void {\n    if (context.viewport !== this.viewTool.viewport)\n      return;\n\n    if (!this.viewTool.targetCenterLocked && !this.viewTool.inHandleModify)\n      return; // Don't display default target center, will be updated to use pick point on element...\n\n    let sizeInches = 0.2;\n    if (!hasFocus && this.viewTool.inHandleModify) {\n      const hitHandle = this.viewTool.viewHandles.hitHandle;\n      if (undefined !== hitHandle && ViewHandleType.Rotate !== hitHandle.handleType)\n        return; // Only display when modifying another handle if that handle is rotate (not pan)...\n      sizeInches = 0.1; // Display small target when dragging...\n    }\n\n    const crossSize = Math.floor(context.viewport.pixelsFromInches(sizeInches)) + 0.5;\n    const outlineSize = crossSize + 1;\n    const position = this.viewTool.viewport!.worldToView(this.viewTool.targetCenterWorld); position.x = Math.floor(position.x) + 0.5; position.y = Math.floor(position.y) + 0.5;\n    const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n      ctx.beginPath();\n      ctx.strokeStyle = \"rgba(0,0,0,.5)\";\n      ctx.lineWidth = hasFocus ? 5 : 3;\n      ctx.moveTo(-outlineSize, 0);\n      ctx.lineTo(outlineSize, 0);\n      ctx.moveTo(0, -outlineSize);\n      ctx.lineTo(0, outlineSize);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.strokeStyle = \"white\";\n      ctx.lineWidth = hasFocus ? 3 : 1;\n      ctx.shadowColor = \"black\";\n      ctx.shadowBlur = hasFocus ? 7 : 5;\n      ctx.moveTo(-crossSize, 0);\n      ctx.lineTo(crossSize, 0);\n      ctx.moveTo(0, -crossSize);\n      ctx.lineTo(0, crossSize);\n      ctx.stroke();\n    };\n    context.addCanvasDecoration({ position, drawDecoration });\n  }\n\n  public doManipulation(ev: BeButtonEvent, inDynamics: boolean) {\n    if (ev.viewport !== this.viewTool.viewport)\n      return false;\n\n    this.viewTool.setTargetCenterWorld(ev.point, !inDynamics, InputSource.Touch === ev.inputSource ? false : !inDynamics);\n    ev.viewport!.invalidateDecorations();\n\n    if (!inDynamics)\n      IModelApp.accuSnap.enableSnap(false);\n\n    return false; // false means don't do screen update\n  }\n}\n\n/** ViewingToolHandle for performing the \"pan view\" operation */\nclass ViewPan extends ViewingToolHandle {\n  private _anchorPt: Point3d = new Point3d();\n  private _lastPtNpc: Point3d = new Point3d();\n  public get handleType() { return ViewHandleType.Pan; }\n  public getHandleCursor() { return this.viewTool.inHandleModify ? IModelApp.viewManager.grabbingCursor : IModelApp.viewManager.grabCursor; }\n\n  public doManipulation(ev: BeButtonEvent, _inDynamics: boolean) {\n    const vp = ev.viewport!;\n    const newPtWorld = ev.point.clone();\n    const thisPtNpc = vp.worldToNpc(newPtWorld);\n    const firstPtNpc = vp.worldToNpc(this._anchorPt);\n\n    thisPtNpc.z = firstPtNpc.z;\n\n    if (this._lastPtNpc.isAlmostEqual(thisPtNpc, 1.0e-10))\n      return true;\n\n    vp.npcToWorld(thisPtNpc, newPtWorld);\n    this._lastPtNpc.setFrom(thisPtNpc);\n    return this.doPan(newPtWorld);\n  }\n\n  public firstPoint(ev: BeButtonEvent) {\n    const vp = ev.viewport!;\n    this._anchorPt.setFrom(ev.rawPoint);\n\n    // if the camera is on, we need to find the element under the starting point to get the z\n    if (vp.isCameraOn) {\n      const visiblePoint = vp.pickNearestVisibleGeometry(this._anchorPt, vp.pixelsFromInches(ToolSettings.viewToolPickRadiusInches));\n      if (undefined !== visiblePoint) {\n        this._anchorPt.setFrom(visiblePoint);\n      } else {\n        const firstPtNpc = vp.worldToNpc(this._anchorPt);\n        firstPtNpc.z = ViewManip.getFocusPlaneNpc(vp);\n        this._anchorPt = vp.npcToWorld(firstPtNpc, this._anchorPt);\n      }\n    }\n\n    this.viewTool.beginDynamicUpdate();\n    ViewTool.showPrompt(\"Pan.Prompts.NextPoint\");\n    return true;\n  }\n\n  public onReinitialize() {\n    const vha = this.viewTool.viewHandles.hitHandle;\n    if (vha === this) {\n      IModelApp.toolAdmin.setCursor(this.getHandleCursor());\n    }\n  }\n\n  public testHandleForHit(_ptScreen: Point3d, out: { distance: number, priority: ViewManipPriority }): boolean {\n    out.distance = 0.0;\n    out.priority = ViewManipPriority.Low;\n    return true;\n  }\n\n  public doPan(newPtWorld: Point3d) {\n    const vp = this.viewTool.viewport!;\n    const view = vp.view;\n    const dist = newPtWorld.vectorTo(this._anchorPt);\n\n    if (view.is3d()) {\n      if (ViewStatus.Success !== view.moveCameraWorld(dist))\n        return false;\n    } else {\n      view.setOrigin(view.getOrigin().plus(dist));\n    }\n\n    vp.synchWithView(false);\n    return true;\n  }\n}\n\n/** ViewingToolHandle for performing the \"rotate view\" operation */\nclass ViewRotate extends ViewingToolHandle {\n  private _lastPtNpc = new Point3d();\n  private _firstPtNpc = new Point3d();\n  private _frustum = new Frustum();\n  private _activeFrustum = new Frustum();\n  public get handleType() { return ViewHandleType.Rotate; }\n  public getHandleCursor() { return \"move\"; }\n\n  public testHandleForHit(ptScreen: Point3d, out: { distance: number, priority: ViewManipPriority }): boolean {\n    const targetPt = this.viewTool.viewport!.worldToView(this.viewTool.targetCenterWorld);\n    out.distance = targetPt.distanceXY(ptScreen);\n    out.priority = ViewManipPriority.Normal;\n    return true;\n  }\n\n  public firstPoint(ev: BeButtonEvent) {\n    const tool = this.viewTool;\n    const vp = ev.viewport!;\n\n    if (!tool.targetCenterLocked && vp.view.allow3dManipulations()) {\n      const visiblePoint = vp.pickNearestVisibleGeometry(ev.rawPoint, vp.pixelsFromInches(ToolSettings.viewToolPickRadiusInches));\n      if (undefined !== visiblePoint)\n        tool.setTargetCenterWorld(visiblePoint, false, false);\n    }\n\n    const pickPt = ev.rawPoint.clone();\n    const pickPtOrig = pickPt.clone();\n\n    vp.worldToNpc(pickPtOrig, this._firstPtNpc);\n    this._lastPtNpc.setFrom(this._firstPtNpc);\n\n    vp.getWorldFrustum(this._activeFrustum);\n    this._frustum.setFrom(this._activeFrustum);\n\n    tool.beginDynamicUpdate();\n    ViewTool.showPrompt(\"Rotate.Prompts.NextPoint\");\n    return true;\n  }\n\n  public doManipulation(ev: BeButtonEvent, _inDynamics: boolean): boolean {\n    const tool = this.viewTool;\n    const viewport = tool.viewport!;\n    const ptNpc = viewport.worldToNpc(ev.point);\n    if (this._lastPtNpc.isAlmostEqual(ptNpc, 1.0e-10)) // no movement since last point\n      return true;\n\n    if (this._firstPtNpc.isAlmostEqual(ptNpc, 1.0e-2)) // too close to anchor pt\n      ptNpc.setFrom(this._firstPtNpc);\n\n    this._lastPtNpc.setFrom(ptNpc);\n    const currentFrustum = viewport.getWorldFrustum();\n    const frustumChange = !currentFrustum.equals(this._activeFrustum);\n    if (frustumChange)\n      this._frustum.setFrom(currentFrustum);\n    else if (!viewport.setupViewFromFrustum(this._frustum))\n      return false;\n\n    const currPt = viewport.npcToView(ptNpc);\n    if (frustumChange)\n      this._firstPtNpc.setFrom(ptNpc);\n\n    let radians: Angle;\n    let worldAxis: Vector3d;\n    const worldPt = tool.targetCenterWorld;\n    if (!viewport.view.allow3dManipulations()) {\n      const centerPt = viewport.worldToView(worldPt);\n      const firstPt = viewport.npcToView(this._firstPtNpc);\n      const vector0 = Vector2d.createStartEnd(centerPt, firstPt);\n      const vector1 = Vector2d.createStartEnd(centerPt, currPt);\n      radians = vector0.angleTo(vector1);\n      worldAxis = Vector3d.unitZ();\n    } else {\n      const viewRect = viewport.viewRect;\n      const xExtent = viewRect.width;\n      const yExtent = viewRect.height;\n\n      viewport.npcToView(ptNpc, currPt);\n      const firstPt = viewport.npcToView(this._firstPtNpc);\n\n      const xDelta = (currPt.x - firstPt.x);\n      const yDelta = (currPt.y - firstPt.y);\n\n      // Movement in screen x == rotation about drawing Z (preserve up) or rotation about screen  Y...\n      const xAxis = ToolSettings.preserveWorldUp ? Vector3d.unitZ() : viewport.rotation.getRow(1);\n\n      // Movement in screen y == rotation about screen X...\n      const yAxis = viewport.rotation.getRow(0);\n\n      const xRMatrix = xDelta ? Matrix3d.createRotationAroundVector(xAxis, Angle.createRadians(Math.PI / (xExtent / xDelta)))! : Matrix3d.createIdentity();\n      const yRMatrix = yDelta ? Matrix3d.createRotationAroundVector(yAxis, Angle.createRadians(Math.PI / (yExtent / yDelta)))! : Matrix3d.createIdentity();\n      const worldRMatrix = yRMatrix.multiplyMatrixMatrix(xRMatrix);\n      const result = worldRMatrix.getAxisAndAngleOfRotation();\n      radians = Angle.createRadians(-result.angle.radians);\n      worldAxis = result.axis;\n    }\n\n    this.rotateViewWorld(worldPt, worldAxis, radians);\n    viewport.getWorldFrustum(this._activeFrustum);\n\n    return true;\n  }\n\n  private rotateViewWorld(worldOrigin: Point3d, worldAxisVector: Vector3d, primaryAngle: Angle) {\n    const worldMatrix = Matrix3d.createRotationAroundVector(worldAxisVector, primaryAngle);\n    if (!worldMatrix)\n      return;\n    const worldTransform = Transform.createFixedPointAndMatrix(worldOrigin, worldMatrix!);\n    const frustum = this._frustum.transformBy(worldTransform);\n    this.viewTool.viewport!.setupViewFromFrustum(frustum);\n  }\n}\n\n/** ViewingToolHandle for performing the \"look view\" operation */\nclass ViewLook extends ViewingToolHandle {\n  private _eyePoint = new Point3d();\n  private _firstPtView = new Point3d();\n  private _rotation = new Matrix3d();\n  private _frustum = new Frustum();\n  public get handleType() { return ViewHandleType.Look; }\n  public getHandleCursor(): string { return IModelApp.viewManager.crossHairCursor; }\n\n  public testHandleForHit(_ptScreen: Point3d, out: { distance: number, priority: ViewManipPriority }): boolean {\n    out.distance = 0.0;\n    out.priority = ViewManipPriority.Low;\n    return true;\n  }\n\n  public firstPoint(ev: BeButtonEvent) {\n    const tool = this.viewTool;\n    const vp = ev.viewport!;\n    const view = vp.view;\n    if (!view || !view.is3d() || !view.allow3dManipulations())\n      return false;\n\n    this._firstPtView.setFrom(ev.viewPoint);\n    this._eyePoint.setFrom(view.getEyePoint());\n    this._rotation.setFrom(vp.rotation);\n\n    vp.getWorldFrustum(this._frustum);\n    tool.beginDynamicUpdate();\n    ViewTool.showPrompt(\"Look.Prompts.NextPoint\");\n    return true;\n  }\n\n  public doManipulation(ev: BeButtonEvent, _inDynamics: boolean): boolean {\n    const tool = this.viewTool;\n    const viewport = tool.viewport!;\n\n    if (ev.viewport !== viewport)\n      return false;\n\n    const worldTransform = this.getLookTransform(viewport, this._firstPtView, ev.viewPoint);\n    const frustum = this._frustum.transformBy(worldTransform);\n    this.viewTool.viewport!.setupViewFromFrustum(frustum);\n\n    return true;\n  }\n\n  private getLookTransform(vp: Viewport, firstPt: Point3d, currPt: Point3d): Transform {\n    const viewRect = vp.viewRect;\n    const xExtent = viewRect.width;\n    const yExtent = viewRect.height;\n    const xDelta = (currPt.x - firstPt.x);\n    const yDelta = (currPt.y - firstPt.y);\n    const xAngle = -(xDelta / xExtent) * Math.PI;\n    const yAngle = -(yDelta / yExtent) * Math.PI;\n\n    const inverseRotation = this._rotation.inverse();\n    const horizontalRotation = Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createRadians(xAngle));\n    const verticalRotation = Matrix3d.createRotationAroundVector(Vector3d.unitX(), Angle.createRadians(yAngle));\n\n    if (undefined === inverseRotation || undefined === horizontalRotation || undefined === verticalRotation)\n      return Transform.createIdentity();\n\n    verticalRotation.multiplyMatrixMatrix(this._rotation, verticalRotation);\n    inverseRotation.multiplyMatrixMatrix(verticalRotation, verticalRotation);\n\n    const newRotation = horizontalRotation.multiplyMatrixMatrix(verticalRotation);\n    const transform = Transform.createFixedPointAndMatrix(this._eyePoint, newRotation);\n    return transform;\n  }\n}\n\n/** ViewingToolHandle for performing the \"scroll view\" operation */\nclass ViewScroll extends ViewingToolHandle {\n  private _anchorPtView = new Point3d();\n  private _lastPtView = new Point3d();\n  public get handleType() { return ViewHandleType.Scroll; }\n  public getHandleCursor(): string { return IModelApp.viewManager.crossHairCursor; }\n\n  public testHandleForHit(_ptScreen: Point3d, out: { distance: number, priority: ViewManipPriority }): boolean {\n    out.distance = 0.0;\n    out.priority = ViewManipPriority.Low;\n    return true;\n  }\n\n  public drawHandle(context: DecorateContext, _hasFocus: boolean): void {\n    if (context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)\n      return;\n\n    const radius = Math.floor(context.viewport.pixelsFromInches(0.15)) + 0.5;\n    const position = this._anchorPtView.clone(); position.x = Math.floor(position.x) + 0.5; position.y = Math.floor(position.y) + 0.5;\n    const position2 = this._lastPtView.clone(); position2.x = Math.floor(position2.x) + 0.5; position2.y = Math.floor(position2.y) + 0.5;\n    const offset = position2.minus(position);\n    const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n      ctx.beginPath();\n      ctx.strokeStyle = \"green\";\n      ctx.lineWidth = 2;\n      ctx.moveTo(0, 0);\n      ctx.lineTo(offset.x, offset.y);\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.strokeStyle = \"rgba(0,0,0,.5)\";\n      ctx.lineWidth = 1;\n      ctx.fillStyle = \"rgba(255,255,255,.5)\";\n      ctx.arc(0, 0, radius, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      let vec = Vector2d.createStartEnd(position, position2);\n      if (undefined === vec) vec = Vector2d.unitX(); else vec.normalize(vec);\n\n      const slashPts = [new Point2d(), new Point2d()];\n      slashPts[0].plusScaled(vec, radius, slashPts[0]);\n      slashPts[1].plusScaled(vec, -radius, slashPts[1]);\n\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = 2;\n      ctx.moveTo(slashPts[0].x, slashPts[0].y);\n      ctx.lineTo(slashPts[1].x, slashPts[1].y);\n      ctx.stroke();\n    };\n    context.addCanvasDecoration({ position, drawDecoration }, true);\n  }\n\n  public firstPoint(ev: BeButtonEvent) {\n    const tool = this.viewTool;\n    this._anchorPtView.setFrom(ev.viewPoint);\n    this._lastPtView.setFrom(ev.viewPoint);\n    tool.beginDynamicUpdate();\n    ViewTool.showPrompt(\"Scroll.Prompts.NextPoint\");\n    return true;\n  }\n\n  public doManipulation(ev: BeButtonEvent, _inDynamics: boolean): boolean {\n    const tool = this.viewTool;\n    const viewport = tool.viewport!;\n\n    if (ev.viewport !== viewport)\n      return false;\n\n    return this.doScroll(ev);\n  }\n\n  public noMotion(ev: BeButtonEvent): boolean {\n    if (ev.viewport !== this.viewTool.viewport)\n      return false;\n\n    this.doScroll(ev);\n    return false;\n  }\n\n  public doScroll(ev: BeButtonEvent): boolean {\n    this._lastPtView.setFrom(ev.viewPoint);\n    // if we're resting near the anchor point, don't bother with this\n    if ((Math.abs(this._anchorPtView.x - this._lastPtView.x) < 5.0) && Math.abs(this._anchorPtView.y - this._lastPtView.y) < 5.0)\n      return false;\n\n    const scrollFactor = (-1.0 / 8.5);\n    const dist = this._anchorPtView.minus(this._lastPtView); dist.z = 0.0;\n    const viewport = ev.viewport!;\n    const view = viewport.view;\n\n    if (view.is3d() && view.isCameraOn) {\n      const points: Point3d[] = new Array<Point3d>(2);\n      points[0] = this._anchorPtView.clone();\n      points[1] = points[0].plusScaled(dist, scrollFactor);\n\n      viewport.viewToNpcArray(points);\n      points[0].z = points[1].z = ViewManip.getFocusPlaneNpc(viewport); // use the focal plane for z coordinates\n      viewport.npcToWorldArray(points);\n\n      const offset = points[1].minus(points[0]);\n      const offsetTransform = Transform.createTranslation(offset);\n\n      const frustum = viewport.getWorldFrustum();\n      frustum.transformBy(offsetTransform, frustum);\n      viewport.setupViewFromFrustum(frustum);\n    } else {\n      const iDist = Point2d.create(Math.floor(dist.x * scrollFactor), Math.floor(dist.y * scrollFactor));\n      viewport.scroll(iDist, { saveInUndo: false, animateFrustumChange: false });\n    }\n\n    return true;\n  }\n}\n\n/** ViewingToolHandle for performing the \"zoom view\" operation */\nclass ViewZoom extends ViewingToolHandle {\n  private _anchorPtView = new Point3d();\n  private _anchorPtNpc = new Point3d();\n  private _lastPtView = new Point3d();\n  private _lastZoomRatio = 1.0;\n  public get handleType() { return ViewHandleType.Zoom; }\n  public getHandleCursor() { return IModelApp.viewManager.crossHairCursor; }\n\n  public testHandleForHit(_ptScreen: Point3d, out: { distance: number, priority: ViewManipPriority }): boolean {\n    out.distance = 0.0;\n    out.priority = ViewManipPriority.Low;\n    return true;\n  }\n\n  public drawHandle(context: DecorateContext, _hasFocus: boolean): void {\n    if (context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)\n      return;\n\n    const radius = Math.floor(context.viewport.pixelsFromInches(0.15)) + 0.5;\n    const crossRadius = radius * 0.6;\n    const position = this._anchorPtView.clone(); position.x = Math.floor(position.x) + 0.5; position.y = Math.floor(position.y) + 0.5;\n    const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n      ctx.beginPath();\n      ctx.strokeStyle = \"rgba(0,0,0,.5)\";\n      ctx.lineWidth = 1;\n      ctx.fillStyle = \"rgba(255,255,255,.5)\";\n      ctx.arc(0, 0, radius, 0, 2 * Math.PI);\n      ctx.fill();\n      ctx.stroke();\n\n      ctx.beginPath();\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = 2;\n      ctx.moveTo(-crossRadius, 0);\n      ctx.lineTo(crossRadius, 0);\n      if (this._lastZoomRatio < 1.0) {\n        ctx.moveTo(0, -crossRadius);\n        ctx.lineTo(0, crossRadius);\n      }\n      ctx.stroke();\n    };\n    context.addCanvasDecoration({ position, drawDecoration }, true);\n  }\n\n  public firstPoint(ev: BeButtonEvent) {\n    const tool = this.viewTool;\n    const viewport = tool.viewport!;\n    const view = viewport.view;\n    if (view.is3d() && view.isCameraOn) {\n      const visiblePoint = viewport.pickNearestVisibleGeometry(CoordSource.User === ev.coordsFrom ? ev.rawPoint : ev.point, viewport.pixelsFromInches(ToolSettings.viewToolPickRadiusInches));\n      if (undefined !== visiblePoint) {\n        this._anchorPtView.setFrom(visiblePoint);\n        viewport.worldToView(this._anchorPtView, this._anchorPtView);\n        this._lastPtView.setFrom(this._anchorPtView);\n        tool.viewport!.viewToNpc(this._anchorPtView, this._anchorPtNpc);\n        tool.beginDynamicUpdate();\n        ViewTool.showPrompt(\"Zoom.Prompts.NextPoint\");\n        return true;\n      }\n    }\n\n    if (CoordSource.User === ev.coordsFrom)\n      this._anchorPtView.setFrom(ev.viewPoint);\n    else\n      viewport.worldToView(ev.point, this._anchorPtView);\n    this._lastPtView.setFrom(this._anchorPtView);\n    tool.viewport!.viewToNpc(this._anchorPtView, this._anchorPtNpc);\n    tool.beginDynamicUpdate();\n    ViewTool.showPrompt(\"Zoom.Prompts.NextPoint\");\n    return true;\n  }\n\n  public doManipulation(ev: BeButtonEvent, _inDynamics: boolean): boolean {\n    if (ev.viewport !== this.viewTool.viewport)\n      return false;\n\n    return this.doZoom(ev);\n  }\n\n  public noMotion(ev: BeButtonEvent): boolean {\n    if (ev.viewport !== this.viewTool.viewport)\n      return false;\n\n    this.doZoom(ev);\n    return false;\n  }\n\n  public doZoom(ev: BeButtonEvent): boolean {\n    this._lastPtView.setFrom(ev.viewPoint);\n    // if we're resting near the anchor point, don't bother with this\n    if ((Math.abs(this._anchorPtView.x - this._lastPtView.x) < 5.0) && Math.abs(this._anchorPtView.y - this._lastPtView.y) < 5.0)\n      return false;\n\n    const viewport = ev.viewport!;\n    const view = viewport.view;\n\n    const thisPtNpc = viewport.viewToNpc(this._lastPtView);\n    const dist = this._anchorPtNpc.minus(thisPtNpc); dist.z = 0.0;\n    const zoomFactor = 0.35;\n    let zoomRatio = 1.0 + (dist.magnitude() * zoomFactor);\n\n    if (dist.y < 0)\n      zoomRatio = 1.0 / zoomRatio;\n\n    this._lastZoomRatio = zoomRatio;\n\n    if (view.is3d() && view.isCameraOn) {\n      const anchorPtWorld = viewport.npcToWorld(this._anchorPtNpc);\n\n      const transform = Transform.createFixedPointAndMatrix(anchorPtWorld, Matrix3d.createScale(zoomRatio, zoomRatio, zoomRatio));\n      const oldEyePoint = view.getEyePoint();\n      const newEyePoint = transform.multiplyPoint3d(oldEyePoint);\n      const cameraOffset = newEyePoint.minus(oldEyePoint);\n      const cameraOffsetTransform = Transform.createTranslation(cameraOffset);\n      const frustum = viewport.getWorldFrustum();\n      frustum.transformBy(cameraOffsetTransform, frustum);\n      viewport.setupViewFromFrustum(frustum);\n    } else {\n      const transform = Transform.createFixedPointAndMatrix(this._anchorPtNpc, Matrix3d.createScale(zoomRatio, zoomRatio, 1.0));\n      const frustum = viewport.getFrustum(CoordSystem.Npc, true);\n      frustum.transformBy(transform, frustum);\n      viewport.npcToWorldArray(frustum.points);\n      viewport.setupViewFromFrustum(frustum);\n    }\n    return true;\n  }\n}\n\n/** @internal */\nclass NavigateMotion {\n  public deltaTime = 0;\n  public transform = Transform.createIdentity();\n  constructor(public viewport: Viewport) { }\n\n  public init(elapsedMilliseconds: number) {\n    this.deltaTime = elapsedMilliseconds * 0.001;\n    this.transform.setIdentity();\n  }\n\n  public getViewUp(result?: Vector3d) { return this.viewport.rotation.getRow(1, result); }\n\n  public getViewDirection(result?: Vector3d): Vector3d {\n    const forward = this.viewport.rotation.getRow(2, result);\n    forward.scale(-1, forward); // positive z is out of the screen, but we want direction into the screen\n    return forward;\n  }\n\n  public takeElevator(distance: number): void {\n    const trans = Point3d.create(0, 0, distance * this.deltaTime);\n    Transform.createTranslation(trans, this.transform);\n  }\n\n  public modifyPitchAngleToPreventInversion(pitchAngle: number): number {\n    const angleLimit = Angle.degreesToRadians(85);\n    const angleTolerance = Angle.degreesToRadians(0.01);\n\n    if (0.0 === pitchAngle)\n      return 0.0;\n\n    const viewUp = this.getViewUp();\n    const viewDir = this.getViewDirection();\n    const worldUp = Vector3d.unitZ();\n\n    let viewAngle = worldUp.angleTo(viewUp).radians;\n    if (viewDir.z < 0)\n      viewAngle *= -1;\n\n    let newAngle = pitchAngle + viewAngle;\n    if (Math.abs(newAngle) < angleLimit)\n      return pitchAngle; // not close to the limit\n    if ((pitchAngle > 0) !== (viewAngle > 0) && (Math.abs(pitchAngle) < Math.PI / 2))\n      return pitchAngle; // tilting away from the limit\n    if (Math.abs(viewAngle) >= (angleLimit - angleTolerance))\n      return 0.0; // at the limit already\n\n    const difference = Math.abs(newAngle) - angleLimit;\n    newAngle = (pitchAngle > 0) ? pitchAngle - difference : pitchAngle + difference;\n    return newAngle; // almost at the limit, but still can go a little bit closer\n  }\n\n  public generateRotationTransform(yawRate: number, pitchRate: number, result?: Transform): Transform {\n    const vp = this.viewport;\n    const view = vp.view as ViewState3d;\n    const viewRot = vp.rotation;\n    const invViewRot = viewRot.inverse()!;\n    const pitchAngle = Angle.createRadians(this.modifyPitchAngleToPreventInversion(pitchRate * this.deltaTime));\n    const pitchMatrix = Matrix3d.createRotationAroundVector(Vector3d.unitX(), pitchAngle)!;\n    const pitchTimesView = pitchMatrix.multiplyMatrixMatrix(viewRot);\n    const inverseViewTimesPitchTimesView = invViewRot.multiplyMatrixMatrix(pitchTimesView);\n    const yawMatrix = Matrix3d.createRotationAroundVector(Vector3d.unitZ(), Angle.createRadians(yawRate * this.deltaTime))!;\n    const yawTimesInverseViewTimesPitchTimesView = yawMatrix.multiplyMatrixMatrix(inverseViewTimesPitchTimesView);\n    return Transform.createFixedPointAndMatrix(view.getEyePoint(), yawTimesInverseViewTimesPitchTimesView, result);\n  }\n\n  public generateTranslationTransform(velocity: Vector3d, isConstrainedToXY: boolean, result?: Transform) {\n    const points: Point3d[] = new Array<Point3d>(3);\n    points[0] = new Point3d(0, 0, 0);\n    points[1] = new Point3d(1, 0, 0);\n    points[2] = new Point3d(0, 1, 0);\n    if (this.viewport.isCameraOn) {\n      this.viewport.viewToNpcArray(points);\n      points[0].z = points[1].z = points[2].z = ViewManip.getFocusPlaneNpc(this.viewport); // use the focal plane for z coordinates\n      this.viewport.npcToViewArray(points);\n    }\n    this.viewport.viewToWorldArray(points);\n    const xDir = Vector3d.createStartEnd(points[0], points[1]);\n    xDir.normalizeInPlace();\n    const yDir = Vector3d.createStartEnd(points[0], points[2]);\n    yDir.normalizeInPlace();\n\n    const zDir = this.getViewDirection();\n\n    if (isConstrainedToXY) {\n      const up = Vector3d.unitZ();\n      const cross = up.crossProduct(zDir);\n      cross.crossProduct(up, zDir);\n      zDir.normalizeInPlace();\n    }\n\n    xDir.scale(velocity.x * this.deltaTime, xDir);\n    yDir.scale(velocity.y * this.deltaTime, yDir);\n    zDir.scale(velocity.z * this.deltaTime, zDir);\n\n    xDir.plus(yDir, xDir).plus(zDir, xDir);\n    return Transform.createTranslation(xDir, result);\n  }\n\n  protected moveAndLook(linearVelocity: Vector3d, angularVelocityX: number, angularVelocityY: number, isConstrainedToXY: boolean): void {\n    const rotateTrans = this.generateRotationTransform(angularVelocityX, angularVelocityY);\n    const dollyTrans = this.generateTranslationTransform(linearVelocity, isConstrainedToXY);\n    this.transform.setMultiplyTransformTransform(rotateTrans, dollyTrans);\n  }\n\n  public pan(horizontalVelocity: number, verticalVelocity: number): void {\n    const travel = new Vector3d(horizontalVelocity, verticalVelocity, 0);\n    this.moveAndLook(travel, 0, 0, false);\n  }\n\n  public travel(yawRate: number, pitchRate: number, forwardVelocity: number, isConstrainedToXY: boolean): void {\n    const travel = new Vector3d(0, 0, forwardVelocity);\n    this.moveAndLook(travel, yawRate, pitchRate, isConstrainedToXY);\n  }\n\n  public look(yawRate: number, pitchRate: number): void { this.generateRotationTransform(yawRate, pitchRate, this.transform); }\n\n  /** reset pitch of view to zero */\n  public resetToLevel(): void {\n    const view = this.viewport.view;\n    if (!view.is3d() || !view.isCameraOn)\n      return;\n    const angles = YawPitchRollAngles.createFromMatrix3d(this.viewport.rotation)!;\n    angles.pitch.setRadians(0); // reset pitch to zero\n    Transform.createFixedPointAndMatrix(view.getEyePoint(), angles.toMatrix3d(), this.transform);\n  }\n}\n\n/** ViewingToolHandle for performing the \"walk and fly view\" operations */\nabstract class ViewNavigate extends ViewingToolHandle {\n  private _anchorPtView = new Point3d();\n  private _lastPtView = new Point3d();\n  private _initialized = false;\n  private _lastMotionTime = 0;\n  private _orientationValid = false;\n  private _orientationTime = 0;\n  private _orientationZ = new Vector3d();\n  protected abstract getNavigateMotion(elapsedTime: number): NavigateMotion | undefined;\n\n  constructor(viewManip: ViewManip) { super(viewManip); }\n\n  private static _angleLimit = 0.075;\n  private static _timeLimit = 500;\n  private haveStaticOrientation(zVec: Vector3d, currentTime: number): boolean {\n    if (!this._orientationValid || zVec.angleTo(this._orientationZ).radians > ViewNavigate._angleLimit || this._orientationZ.isAlmostZero) {\n      this._orientationValid = true;\n      this._orientationTime = currentTime;\n      this._orientationZ = zVec;\n      return false;\n    }\n    return (currentTime - this._orientationTime) > ViewNavigate._timeLimit;\n  }\n\n  private tryOrientationEvent(_forward: Vector3d, _ev: BeButtonEvent): { eventsEnabled: boolean, result: OrientationResult } {\n    return { eventsEnabled: false, result: OrientationResult.NoEvent };\n  }\n\n  private getElapsedTime(currentTime: number): number {\n    let elapsedTime = currentTime - this._lastMotionTime;\n    if (0 === this._lastMotionTime || elapsedTime < 0 || elapsedTime > 1000)\n      elapsedTime = 100;\n    return elapsedTime;\n  }\n\n  public getMaxLinearVelocity() { return ToolSettings.walkVelocity; }\n  public getMaxAngularVelocity() { return Math.PI / 4; }\n  public testHandleForHit(_ptScreen: Point3d, out: { distance: number, priority: ViewManipPriority }): boolean {\n    out.distance = 0.0;\n    out.priority = ViewManipPriority.Low;\n    return true;\n  }\n\n  public getInputVector(result?: Vector3d): Vector3d {\n    const inputDeadZone = 5.0;\n    const input = this._anchorPtView.vectorTo(this._lastPtView, result);\n    const viewRect = this.viewTool.viewport!.viewRect;\n\n    if (Math.abs(input.x) < inputDeadZone)\n      input.x = 0;\n    else\n      input.x = 2 * input.x / viewRect.width;\n\n    if (Math.abs(input.y) < inputDeadZone)\n      input.y = 0;\n    else\n      input.y = 2 * input.y / viewRect.height;\n\n    input.x = Math.min(input.x, 1);\n    input.y = Math.min(input.y, 1);\n    return input;\n  }\n\n  public getCenterPoint(result: Point3d): Point3d {\n    const center = result ? result : new Point3d();\n    center.setZero();\n\n    const rect = this.viewTool.viewport!.viewRect;\n    const width = rect.width;\n    const height = rect.height;\n\n    if (width > 0)\n      center.x = width / 2;\n\n    if (height > 0)\n      center.y = height / 2;\n\n    return center;\n  }\n\n  public getNavigateMode(): NavigateMode {\n    const state = IModelApp.toolAdmin.currentInputState;\n    if (state.isShiftDown || !this.viewTool.viewport!.isCameraOn)\n      return NavigateMode.Pan;\n    return state.isControlDown ? NavigateMode.Look : NavigateMode.Travel;\n  }\n\n  public doNavigate(ev: BeButtonEvent): boolean {\n    const currentTime = Date.now();\n    const forward = new Vector3d();\n    const orientationEvent = this.tryOrientationEvent(forward, ev);\n    const orientationResult = orientationEvent.result;\n    const elapsedTime = this.getElapsedTime(currentTime);\n\n    this._lastMotionTime = currentTime;\n    const vp = this.viewTool.viewport!;\n    const motion = this.getNavigateMotion(elapsedTime);\n\n    let haveNavigateEvent: boolean = !!motion;\n    if (haveNavigateEvent) {\n      const frust = vp.getWorldFrustum();\n      frust.multiply(motion!.transform);\n      if (!vp.setupViewFromFrustum(frust)) {\n        haveNavigateEvent = false;\n        if (OrientationResult.NoEvent === orientationResult)\n          return false;\n      }\n      return true;\n    }\n\n    switch (orientationResult) {\n      case OrientationResult.Disabled:\n      case OrientationResult.NoEvent:\n        return true;\n      case OrientationResult.RejectedByController:\n      case OrientationResult.Success:\n        return this.haveStaticOrientation(forward, currentTime);\n      default:\n        return false;\n    }\n  }\n\n  public doManipulation(ev: BeButtonEvent, inDynamics: boolean): boolean {\n    if (!inDynamics)\n      return true;\n    else if (ev.viewport !== this.viewTool.viewport)\n      return false;\n\n    this._lastPtView.setFrom(ev.viewPoint);\n    return this.doNavigate(ev);\n  }\n\n  public noMotion(ev: BeButtonEvent): boolean {\n    if (ev.viewport !== this.viewTool.viewport)\n      return false;\n\n    this.doNavigate(ev);\n    return false;\n  }\n\n  public onReinitialize(): void {\n    if (this._initialized)\n      return;\n\n    this._initialized = true;\n    const tool = this.viewTool;\n    const vp = tool.viewport!;\n    const view = vp.view;\n    if (!view.allow3dManipulations())\n      return;\n\n    const startFrust = vp.getWorldFrustum();\n    const walkAngle = ToolSettings.walkCameraAngle;\n    if (!tool.lensAngleMatches(walkAngle, Angle.degreesToRadians(10)) || !tool.isZUp) {\n      //  This turns on the camera if its not already on. It also assures the camera is centered. Obviously this is required if\n      //  the camera is not on or the lens angle is not what we want. We also want to do it if Z will be\n      //  adjusted because EnforceZUp swivels the camera around what GetTargetPoint returns. If the FocusDistance is not set to something\n      //  reasonable the target point may be far beyond anything relevant.\n      tool.setCameraLensAngle(walkAngle, tool.lensAngleMatches(walkAngle, Angle.degreesToRadians(45.)));\n    }\n\n    if (ToolSettings.walkEnforceZUp)\n      this.viewTool.enforceZUp(view.getTargetPoint());\n\n    const endFrust = vp.getWorldFrustum();\n    if (!startFrust.equals(endFrust))\n      vp.animateFrustumChange(startFrust, endFrust);\n\n    this.getCenterPoint(this._anchorPtView);\n  }\n\n  public onCleanup(): void {\n  }\n\n  public firstPoint(ev: BeButtonEvent): boolean {\n    // NB: In desktop apps we want to center the cursor in the view.\n    // The browser doesn't support that, and it is more useful to be able to place the anchor point freely anyway.\n    this.viewTool.beginDynamicUpdate();\n    this._lastPtView.setFrom(ev.viewPoint);\n    this._anchorPtView.setFrom(this._lastPtView);\n    return true;\n  }\n\n  public getHandleCursor() { return IModelApp.viewManager.crossHairCursor; }\n\n  public drawHandle(context: DecorateContext, _hasFocus: boolean): void {\n    if (context.viewport !== this.viewTool.viewport || !this.viewTool.inDynamicUpdate)\n      return;\n    const position = this._anchorPtView.clone(); position.x = Math.floor(position.x) + 0.5; position.y = Math.floor(position.y) + 0.5;\n    const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n      ctx.strokeStyle = \"black\";\n      ctx.lineWidth = 1;\n      ctx.strokeRect(-2, -2, 5, 5);\n      ctx.fillStyle = \"white\";\n      ctx.fillRect(-1, -1, 3, 3);\n    };\n    context.addCanvasDecoration({ position, drawDecoration });\n  }\n}\n\n/** ViewingToolHandle for performing the \"walk view\" operation */\nclass ViewWalk extends ViewNavigate {\n  private _navigateMotion: NavigateMotion;\n\n  constructor(viewManip: ViewManip) {\n    super(viewManip);\n    this._navigateMotion = new NavigateMotion(this.viewTool.viewport!);\n  }\n  public get handleType(): ViewHandleType { return ViewHandleType.Walk; }\n  public firstPoint(ev: BeButtonEvent): boolean { ViewTool.showPrompt(\"Walk.Prompts.NextPoint\"); return super.firstPoint(ev); }\n\n  protected getNavigateMotion(elapsedTime: number): NavigateMotion | undefined {\n    const input = this.getInputVector();\n    if (0 === input.x && 0 === input.y)\n      return undefined;\n\n    const motion = this._navigateMotion;\n    motion.init(elapsedTime);\n\n    switch (this.getNavigateMode()) {\n      case NavigateMode.Pan:\n        input.scale(this.getMaxLinearVelocity(), input);\n        motion.pan(input.x, input.y);\n        break;\n      case NavigateMode.Look:\n        input.scale(-this.getMaxAngularVelocity(), input);\n        motion.look(input.x, input.y);\n        break;\n      case NavigateMode.Travel:\n        motion.travel(-input.x * this.getMaxAngularVelocity(), 0, -input.y * this.getMaxLinearVelocity(), true);\n        break;\n    }\n\n    return motion;\n  }\n}\n\n/** ViewingToolHandle for performing the \"fly view\" operation */\nclass ViewFly extends ViewNavigate {\n  private _navigateMotion: NavigateMotion;\n\n  constructor(viewManip: ViewManip) {\n    super(viewManip);\n    this._navigateMotion = new NavigateMotion(this.viewTool.viewport!);\n  }\n  public get handleType(): ViewHandleType { return ViewHandleType.Fly; }\n  public firstPoint(ev: BeButtonEvent): boolean { ViewTool.showPrompt(\"Fly.Prompts.NextPoint\"); return super.firstPoint(ev); }\n\n  protected getNavigateMotion(elapsedTime: number): NavigateMotion | undefined {\n    const input = this.getInputVector();\n    const motion = this._navigateMotion;\n    motion.init(elapsedTime);\n\n    switch (this.getNavigateMode()) {\n      case NavigateMode.Pan:\n        if (0 === input.x && 0 === input.y)\n          return undefined;\n        input.scale(this.getMaxLinearVelocity(), input);\n        motion.pan(input.x, input.y);\n        break;\n      case NavigateMode.Look:\n        if (0 === input.x && 0 === input.y)\n          return undefined;\n        input.scale(-this.getMaxAngularVelocity(), input);\n        motion.look(input.x, input.y);\n        break;\n      case NavigateMode.Travel:\n        input.scale(-this.getMaxAngularVelocity() * 2.0, input);\n        motion.travel(input.x, input.y, this.getMaxLinearVelocity(), false);\n        break;\n    }\n\n    return motion;\n  }\n}\n\n/** The tool that performs a Pan view operation\n * @public\n */\nexport class PanViewTool extends ViewManip {\n  public static toolId = \"View.Pan\";\n  constructor(vp: ScreenViewport | undefined, oneShot = false, isDraggingRequired = false) {\n    super(vp, ViewHandleType.Pan, oneShot, isDraggingRequired);\n  }\n  public onReinitialize(): void { super.onReinitialize(); ViewTool.showPrompt(\"Pan.Prompts.FirstPoint\"); }\n}\n\n/** A tool that performs a Rotate view operation\n * @public\n */\nexport class RotateViewTool extends ViewManip {\n  public static toolId = \"View.Rotate\";\n  constructor(vp: ScreenViewport, oneShot = false, isDraggingRequired = false) {\n    super(vp, ViewHandleType.Rotate | ViewHandleType.Pan | ViewHandleType.TargetCenter, oneShot, isDraggingRequired);\n  }\n  public onReinitialize(): void { super.onReinitialize(); ViewTool.showPrompt(\"Rotate.Prompts.FirstPoint\"); }\n}\n\n/** A tool that performs the look operation\n * @public\n */\nexport class LookViewTool extends ViewManip {\n  public static toolId = \"View.Look\";\n  constructor(vp: ScreenViewport, oneShot = false, isDraggingRequired = false) {\n    super(vp, ViewHandleType.Look, oneShot, isDraggingRequired);\n  }\n  public onReinitialize(): void { super.onReinitialize(); ViewTool.showPrompt(\"Look.Prompts.FirstPoint\"); }\n}\n\n/** A tool that performs the scroll operation\n * @public\n */\nexport class ScrollViewTool extends ViewManip {\n  public static toolId = \"View.Scroll\";\n  constructor(vp: ScreenViewport, oneShot = false, isDraggingRequired = false) {\n    super(vp, ViewHandleType.Scroll, oneShot, isDraggingRequired);\n  }\n  public onReinitialize(): void { super.onReinitialize(); ViewTool.showPrompt(\"Scroll.Prompts.FirstPoint\"); }\n}\n\n/** A tool that performs the zoom operation\n * @public\n */\nexport class ZoomViewTool extends ViewManip {\n  public static toolId = \"View.Zoom\";\n  constructor(vp: ScreenViewport, oneShot = false, isDraggingRequired = false) {\n    super(vp, ViewHandleType.Zoom, oneShot, isDraggingRequired);\n  }\n  public onReinitialize(): void { super.onReinitialize(); ViewTool.showPrompt(\"Zoom.Prompts.FirstPoint\"); }\n}\n\n/** A tool that performs the walk operation\n * @public\n */\nexport class WalkViewTool extends ViewManip {\n  public static toolId = \"View.Walk\";\n  constructor(vp: ScreenViewport, oneShot = false, isDraggingRequired = false) {\n    super(vp, ViewHandleType.Walk, oneShot, isDraggingRequired);\n  }\n  public onReinitialize(): void { super.onReinitialize(); ViewTool.showPrompt(\"Walk.Prompts.FirstPoint\"); }\n}\n\n/** A tool that performs the fly operation\n * @public\n */\nexport class FlyViewTool extends ViewManip {\n  public static toolId = \"View.Fly\";\n  constructor(vp: ScreenViewport, oneShot = false, isDraggingRequired = false) {\n    super(vp, ViewHandleType.Fly, oneShot, isDraggingRequired);\n  }\n  public onReinitialize(): void { super.onReinitialize(); ViewTool.showPrompt(\"Fly.Prompts.FirstPoint\"); }\n}\n\n/** A tool that performs a fit view\n * @public\n */\nexport class FitViewTool extends ViewTool {\n  public static toolId = \"View.Fit\";\n  public oneShot: boolean;\n  public doAnimate: boolean;\n  public isolatedOnly: boolean;\n  constructor(viewport: ScreenViewport, oneShot: boolean, doAnimate = true, isolatedOnly = true) {\n    super(viewport);\n    this.viewport = viewport;\n    this.oneShot = oneShot;\n    this.doAnimate = doAnimate;\n    this.isolatedOnly = isolatedOnly;\n  }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    if (ev.viewport)\n      return await this.doFit(ev.viewport, this.oneShot, this.doAnimate, this.isolatedOnly) ? EventHandled.Yes : EventHandled.No;\n\n    return EventHandled.No;\n  }\n\n  public onPostInstall() {\n    super.onPostInstall();\n    if (undefined === this.viewport || !this.oneShot)\n      ViewTool.showPrompt(\"Fit.Prompts.FirstPoint\");\n\n    if (this.viewport)\n      this.doFit(this.viewport, this.oneShot, this.doAnimate, this.isolatedOnly); // tslint:disable-line:no-floating-promises\n  }\n\n  public async doFit(viewport: ScreenViewport, oneShot: boolean, doAnimate = true, isolatedOnly = true): Promise<boolean> {\n    if (!isolatedOnly || !await ViewManip.zoomToAlwaysDrawnExclusive(viewport, doAnimate))\n      ViewManip.fitView(viewport, doAnimate);\n    if (oneShot)\n      this.exitTool();\n    return oneShot;\n  }\n}\n\n/** A tool that rotates the view to one of the standard views.\n * @public\n */\nexport class StandardViewTool extends ViewTool {\n  public static toolId = \"View.Standard\";\n  constructor(viewport: ScreenViewport, private _standardViewId: StandardViewId) { super(viewport); }\n\n  public onPostInstall() {\n    super.onPostInstall();\n    if (this.viewport) {\n      const id = this._standardViewId;\n      const vp = this.viewport;\n      const rMatrix = AccuDraw.getStandardRotation(id, vp, vp.isContextRotationRequired);\n      const inverse = rMatrix.inverse();\n      if (undefined !== inverse) {\n        const targetMatrix = inverse.multiplyMatrixMatrix(vp.rotation);\n        const rotateTransform = Transform.createFixedPointAndMatrix(vp.view.getTargetPoint(), targetMatrix);\n        const startFrustum = vp.getFrustum();\n        const newFrustum = startFrustum.clone();\n        newFrustum.multiply(rotateTransform);\n        vp.animateFrustumChange(startFrustum, newFrustum);\n        vp.view.setupFromFrustum(newFrustum);\n        vp.synchWithView(true);\n      }\n    }\n    this.exitTool();\n  }\n}\n\n/** A tool that performs a Window-area view operation\n * @public\n */\nexport class WindowAreaTool extends ViewTool {\n  public static toolId = \"View.WindowArea\";\n  private _haveFirstPoint: boolean = false;\n  private _firstPtWorld: Point3d = Point3d.create();\n  private _secondPtWorld: Point3d = Point3d.create();\n  private _lastPtView?: Point3d;\n  private _corners = [new Point3d(), new Point3d()];\n  private _shapePts = [new Point3d(), new Point3d(), new Point3d(), new Point3d(), new Point3d()];\n  private _fillColor = ColorDef.from(0, 0, 255, 200);\n\n  public onPostInstall() { super.onPostInstall(); ViewTool.showPrompt(\"WindowArea.Prompts.FirstPoint\"); }\n  public onReinitialize() { this._haveFirstPoint = false; this._firstPtWorld.setZero(); this._secondPtWorld.setZero(); ViewTool.showPrompt(\"WindowArea.Prompts.FirstPoint\"); }\n  public async onResetButtonUp(ev: BeButtonEvent): Promise<EventHandled> { if (this._haveFirstPoint) { this.onReinitialize(); return EventHandled.Yes; } return super.onResetButtonUp(ev); }\n\n  public async onDataButtonDown(ev: BeButtonEvent): Promise<EventHandled> {\n    if (undefined === ev.viewport) {\n      return EventHandled.Yes;\n    } else if (undefined === this.viewport) {\n      this.viewport = ev.viewport;\n    } else if (this.viewport.view.iModel !== ev.viewport.view.iModel) {\n      if (this._haveFirstPoint)\n        return EventHandled.Yes;\n      this.viewport = ev.viewport;\n      this._lastPtView = ev.viewPoint;\n      IModelApp.viewManager.invalidateDecorationsAllViews();\n      return EventHandled.Yes;\n    }\n\n    if (this._haveFirstPoint) {\n      this._secondPtWorld.setFrom(ev.point);\n      this.doManipulation(ev, false);\n      this.onReinitialize();\n      this.viewport!.invalidateDecorations();\n    } else {\n      this._firstPtWorld.setFrom(ev.point);\n      this._secondPtWorld.setFrom(this._firstPtWorld);\n      this._haveFirstPoint = true;\n      this._lastPtView = ev.viewPoint;\n      ViewTool.showPrompt(\"WindowArea.Prompts.NextPoint\");\n    }\n\n    return EventHandled.Yes;\n  }\n\n  public async onMouseMotion(ev: BeButtonEvent) { this.doManipulation(ev, true); }\n  public async onTouchTap(ev: BeTouchEvent): Promise<EventHandled> { return ev.isSingleTap ? EventHandled.Yes : EventHandled.No; } // Prevent IdleTool from converting single tap into data button down/up...\n  public async onTouchMoveStart(ev: BeTouchEvent, startEv: BeTouchEvent): Promise<EventHandled> { if (!this._haveFirstPoint && startEv.isSingleTouch) await IModelApp.toolAdmin.convertTouchMoveStartToButtonDownAndMotion(startEv, ev); return this._haveFirstPoint ? EventHandled.Yes : EventHandled.No; }\n  public async onTouchMove(ev: BeTouchEvent): Promise<void> { if (this._haveFirstPoint) return IModelApp.toolAdmin.convertTouchMoveToMotion(ev); }\n  public async onTouchComplete(ev: BeTouchEvent): Promise<void> { if (this._haveFirstPoint) return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev); }\n  public async onTouchCancel(ev: BeTouchEvent): Promise<void> { if (this._haveFirstPoint) return IModelApp.toolAdmin.convertTouchEndToButtonUp(ev, BeButton.Reset); }\n\n  private computeWindowCorners(): Point3d[] | undefined {\n    const vp = this.viewport!;\n    const corners = this._corners;\n\n    corners[0].setFrom(this._firstPtWorld);\n    corners[1].setFrom(this._secondPtWorld);\n    vp.worldToViewArray(corners);\n\n    const delta = corners[1].minus(corners[0]);\n    if (delta.magnitudeXY() < vp.pixelsFromInches(ToolSettings.startDragDistanceInches))\n      return undefined;\n\n    const currentDelta = vp.viewDelta;\n    if (currentDelta.x === 0 || delta.x === 0)\n      return undefined;\n\n    const viewAspect = currentDelta.y / currentDelta.x;\n    const aspectRatio = Math.abs(delta.y / delta.x);\n\n    let halfDeltaX;\n    let halfDeltaY;\n    if (aspectRatio < viewAspect) {\n      halfDeltaX = Math.abs(delta.x) / 2.0;\n      halfDeltaY = halfDeltaX * viewAspect;\n    } else {\n      halfDeltaY = Math.abs(delta.y) / 2.0;\n      halfDeltaX = halfDeltaY / viewAspect;\n    }\n\n    const center = corners[0].plusScaled(delta, 0.5);\n    corners[0].x = center.x - halfDeltaX;\n    corners[0].y = center.y - halfDeltaY;\n    corners[1].x = center.x + halfDeltaX;\n    corners[1].y = center.y + halfDeltaY;\n    return corners;\n  }\n\n  public decorate(context: DecorateContext): void {\n    if (undefined === this.viewport || this.viewport.view.iModel !== context.viewport!.view.iModel)\n      return;\n    const vp = this.viewport;\n    const color = vp.getContrastToBackgroundColor();\n    if (this._haveFirstPoint) {\n      const corners = this.computeWindowCorners();\n      if (undefined === corners)\n        return;\n\n      this._shapePts[0].x = this._shapePts[3].x = corners[0].x;\n      this._shapePts[1].x = this._shapePts[2].x = corners[1].x;\n      this._shapePts[0].y = this._shapePts[1].y = corners[0].y;\n      this._shapePts[2].y = this._shapePts[3].y = corners[1].y;\n      this._shapePts[0].z = this._shapePts[1].z = this._shapePts[2].z = this._shapePts[3].z = corners[0].z;\n      this._shapePts[4].setFrom(this._shapePts[0]);\n      vp.viewToWorldArray(this._shapePts);\n\n      const builder = context.createGraphicBuilder(GraphicType.WorldOverlay);\n\n      builder.setBlankingFill(this._fillColor);\n      builder.addShape(this._shapePts);\n\n      builder.setSymbology(color, color, ViewHandleWeight.Thin);\n      builder.addLineString(this._shapePts);\n\n      builder.setSymbology(color, color, ViewHandleWeight.FatDot);\n      builder.addPointString([this._firstPtWorld]);\n\n      context.addDecorationFromBuilder(builder);\n      return;\n    }\n\n    if (undefined === this._lastPtView)\n      return;\n\n    const cursorPt = this._lastPtView.clone(); cursorPt.x = Math.floor(cursorPt.x) + 0.5; cursorPt.y = Math.floor(cursorPt.y) + 0.5;\n    const viewRect = vp.viewRect;\n\n    const drawDecoration = (ctx: CanvasRenderingContext2D) => {\n      ctx.beginPath();\n      ctx.strokeStyle = (ColorDef.black === color ? \"black\" : \"white\");\n      ctx.lineWidth = 1;\n      ctx.moveTo(viewRect.left, cursorPt.y);\n      ctx.lineTo(viewRect.right, cursorPt.y);\n      ctx.moveTo(cursorPt.x, viewRect.top);\n      ctx.lineTo(cursorPt.x, viewRect.bottom);\n      ctx.stroke();\n    };\n    context.addCanvasDecoration({ drawDecoration });\n  }\n\n  private doManipulation(ev: BeButtonEvent, inDynamics: boolean): void {\n    this._secondPtWorld.setFrom(ev.point);\n    if (inDynamics) {\n      if (undefined !== this.viewport && undefined !== ev.viewport && this.viewport.view.iModel !== ev.viewport.view.iModel) {\n        this._lastPtView = undefined;\n        return;\n      }\n      this._lastPtView = ev.viewPoint;\n      IModelApp.viewManager.invalidateDecorationsAllViews();\n      return;\n    }\n\n    const corners = this.computeWindowCorners();\n    if (!corners)\n      return;\n\n    let delta: Vector3d;\n    const vp = this.viewport!;\n    const startFrust = vp.getWorldFrustum();\n    vp.viewToWorldArray(corners);\n\n    if (vp.view.is3d() && vp.view.isCameraOn) {\n      const cameraView = vp.view as ViewState3d;\n\n      const windowArray: Point3d[] = [corners[0].clone(), corners[1].clone()];\n      vp.worldToViewArray(windowArray);\n\n      const windowRange = new ViewRect(windowArray[0].x, windowArray[0].y, windowArray[1].x, windowArray[1].y);\n\n      let npcZValues = vp.determineVisibleDepthRange(windowRange);\n      if (!npcZValues)\n        npcZValues = { minimum: 0, maximum: ViewManip.getFocusPlaneNpc(vp) };\n\n      const lensAngle = cameraView.getLensAngle();\n\n      vp.worldToNpcArray(corners);\n      corners[0].z = corners[1].z = npcZValues.maximum;\n\n      vp.npcToWorldArray(corners);  // Put corners back in world at correct depth\n      const viewPts: Point3d[] = [corners[0].clone(), corners[1].clone()];\n      vp.rotation.multiplyVectorArrayInPlace(viewPts);  // rotate to view orientation to get extents\n\n      const range = Range3d.createArray(viewPts);\n      delta = Vector3d.createStartEnd(range.low, range.high);\n\n      const focusDist = Math.max(delta.x, delta.y) / (2.0 * Math.tan(lensAngle.radians / 2));\n\n      const newTarget = corners[0].interpolate(.5, corners[1]);\n      const newEye = newTarget.plusScaled(cameraView.getZVector(), focusDist);\n\n      if (cameraView.lookAtUsingLensAngle(newEye, newTarget, cameraView.getYVector(), lensAngle, focusDist) !== ViewStatus.Success)\n        return;\n    } else {\n      vp.rotation.multiplyVectorArrayInPlace(corners);\n\n      const range = Range3d.createArray(corners);\n      delta = Vector3d.createStartEnd(range.low, range.high);\n      // get the view extents\n      delta.z = vp.view.getExtents().z;\n\n      // make sure its not too big or too small\n      vp.view.validateViewDelta(delta, true);\n\n      vp.view.setExtents(delta);\n\n      const originVec = vp.rotation.multiplyTransposeXYZ(range.low.x, range.low.y, range.low.z);\n      vp.view.setOrigin(Point3d.createFrom(originVec));\n    }\n\n    vp.synchWithView(true);\n    vp.animateFrustumChange(startFrust, vp.getFrustum());\n  }\n}\n\n/** @internal */\nexport class DefaultViewTouchTool extends ViewManip {\n  public static toolId = \"\"; // touch tools installed by IdleTool are never registered\n  private _lastPtView = new Point3d();\n  private _startPtWorld = new Point3d();\n  private _startPtView = new Point3d();\n  private _startDirection = new Vector2d();\n  private _startDistance = 0.0;\n  private _startTouchCount = 0;\n  private _frustum = new Frustum();\n\n  constructor(startEv: BeTouchEvent, _ev: BeTouchEvent) {\n    super(startEv.viewport!, 0, true, false);\n    this.onStart(startEv);\n  }\n\n  public onStart(ev: BeTouchEvent): void {\n    const vp = this.viewport!;\n    vp.getWorldFrustum(this._frustum);\n    const visiblePoint = vp.pickNearestVisibleGeometry(ev.rawPoint, vp.pixelsFromInches(ToolSettings.viewToolPickRadiusInches));\n    if (undefined !== visiblePoint) {\n      this._startPtWorld.setFrom(visiblePoint);\n      vp.worldToView(this._startPtWorld, this._startPtView);\n    } else {\n      this._startPtView.setFrom(ev.viewPoint);\n      this._startPtView.z = vp.worldToView(vp.view.getTargetPoint()).z;\n      vp.viewToWorld(this._startPtView, this._startPtWorld);\n    }\n    this._lastPtView.setFrom(this._startPtView);\n    this._startTouchCount = ev.touchCount;\n    this._startDirection = (2 <= ev.touchCount ? Vector2d.createStartEnd(BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp), BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp)) : Vector2d.createZero());\n    this._startDistance = (2 === ev.touchCount ? this._startDirection.magnitude() : 0.0);\n  }\n\n  private computeZoomRatio(ev: BeTouchEvent): number {\n    if (0.0 === this._startDistance)\n      return 1.0;\n\n    const vp = this.viewport!;\n    const distance = (2 === ev.touchCount ? BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp).distance(BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp)) : 0.0);\n\n    if (0.0 === distance)\n      return 1.0;\n\n    if (Math.abs(this._startDistance - distance) < this.viewport!.pixelsFromInches(0.2))\n      return 1.0;\n\n    let zoomRatio = this._startDistance / distance;\n    if (zoomRatio < 0.1)\n      zoomRatio = 0.1;\n    else if (zoomRatio > 10.0)\n      zoomRatio = 10.0;\n\n    return zoomRatio;\n  }\n\n  private computeRotation(ev: BeTouchEvent): Angle {\n    if (ev.touchCount < 2)\n      return Angle.createDegrees(0.0);\n\n    const vp = this.viewport!;\n    const direction = Vector2d.createStartEnd(BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[0], vp), BeTouchEvent.getTouchPosition(ev.touchEvent.targetTouches[1], vp));\n    const rotation = this._startDirection.angleTo(direction);\n\n    if (Math.abs(rotation.radians) < Angle.createDegrees(5.0).radians)\n      return Angle.createDegrees(0.0);\n\n    const angularDistance = Math.abs(direction.magnitude() / 2.0 * Math.sin(Math.abs(rotation.radians)));\n    const zoomDistance = Math.abs(direction.magnitude() - this._startDirection.magnitude());\n    const panDistance = this._startPtView.distanceXY(this._lastPtView);\n\n    // NOTE: The * 0.75 below is because it's easy to confuse an attempted rotate for an attempted pan, and this tries to balance that without having a false positive in the opposite direction.\n    if (Math.abs(rotation.radians) > Angle.createDegrees(18.0).radians || (angularDistance > zoomDistance && angularDistance > panDistance * 0.75))\n      return rotation;\n\n    return Angle.createDegrees(0.0);\n  }\n\n  private handle2dPan(_ev: BeTouchEvent): void {\n    const vp = this.viewport!;\n    const screenDist = Point2d.create(this._startPtView.x - this._lastPtView.x, this._startPtView.y - this._lastPtView.y);\n    vp.scroll(screenDist, { saveInUndo: false, animateFrustumChange: false });\n  }\n\n  private handle2dRotateZoom(ev: BeTouchEvent): void {\n    const vp = this.viewport!;\n    const rotation = this.computeRotation(ev);\n    const zoomRatio = this.computeZoomRatio(ev);\n    const targetWorld = vp.viewToWorld(this._lastPtView);\n    const translateTransform = Transform.createTranslation(this._startPtWorld.minus(targetWorld));\n    const rotationTransform = Transform.createFixedPointAndMatrix(targetWorld, Matrix3d.createRotationAroundVector(vp.view.getZVector(), rotation)!);\n    const scaleTransform = Transform.createScaleAboutPoint(this._startPtWorld, zoomRatio);\n    const transform = translateTransform.multiplyTransformTransform(rotationTransform);\n\n    scaleTransform.multiplyTransformTransform(transform, transform);\n    const frustum = this._frustum.transformBy(transform);\n    vp.setupViewFromFrustum(frustum);\n  }\n\n  private handle3dRotate(_ev: BeTouchEvent): void {\n    const vp = this.viewport!;\n    const viewRect = vp.viewRect;\n    const xExtent = viewRect.width;\n    const yExtent = viewRect.height;\n    const xDelta = this._lastPtView.x - this._startPtView.x;\n    const yDelta = this._lastPtView.y - this._startPtView.y;\n\n    const xAxis = ToolSettings.preserveWorldUp ? Vector3d.unitZ() : vp.rotation.getRow(1);\n    const yAxis = vp.rotation.getRow(0);\n    const xRMatrix = (0.0 !== xDelta) ? Matrix3d.createRotationAroundVector(xAxis, Angle.createRadians(Math.PI / (xExtent / xDelta)))! : Matrix3d.identity;\n    const yRMatrix = (0.0 !== yDelta) ? Matrix3d.createRotationAroundVector(yAxis, Angle.createRadians(Math.PI / (yExtent / yDelta)))! : Matrix3d.identity;\n    const worldRMatrix = yRMatrix.multiplyMatrixMatrix(xRMatrix);\n\n    const result = worldRMatrix.getAxisAndAngleOfRotation();\n    const radians = Angle.createRadians(-result.angle.radians);\n    const worldAxis = result.axis;\n\n    const rotationMatrix = Matrix3d.createRotationAroundVector(worldAxis, radians);\n    if (!rotationMatrix)\n      return;\n\n    const worldTransform = Transform.createFixedPointAndMatrix(this._startPtWorld, rotationMatrix);\n    const frustum = this._frustum.transformBy(worldTransform);\n    vp.setupViewFromFrustum(frustum);\n  }\n\n  private handle3dPanZoom(ev: BeTouchEvent): void {\n    const vp = this.viewport!;\n    const zoomRatio = this.computeZoomRatio(ev);\n\n    if (vp.isCameraOn) {\n      const targetWorld = vp.viewToWorld(this._lastPtView);\n      const preTrans = Transform.createTranslationXYZ(-targetWorld.x, -targetWorld.y, -targetWorld.z);\n      const postTrans = Transform.createTranslation(this._startPtWorld);\n\n      preTrans.origin.scaleInPlace(zoomRatio);\n      preTrans.matrix.scale(zoomRatio, preTrans.matrix);\n      const cameraTransform = postTrans.multiplyTransformTransform(preTrans);\n\n      const view = vp.view as ViewState3d;\n      const oldEyePoint = view.getEyePoint();\n      const newEyePoint = cameraTransform.multiplyPoint3d(oldEyePoint);\n      const cameraOffset = newEyePoint.minus(oldEyePoint);\n      const cameraOffsetTransform = Transform.createTranslation(cameraOffset);\n\n      const frustum = this._frustum.transformBy(cameraOffsetTransform);\n      vp.setupViewFromFrustum(frustum);\n      return;\n    }\n\n    const targetNpc = vp.viewToNpc(this._lastPtView);\n    const transform = Transform.createFixedPointAndMatrix(targetNpc, Matrix3d.createScale(zoomRatio, zoomRatio, 1.0));\n    const viewCenter = Point3d.create(.5, .5, .5);\n    const startPtNpc = vp.viewToNpc(this._startPtView);\n    const shift = startPtNpc.minus(targetNpc); shift.z = 0.0;\n    const offset = Transform.createTranslation(shift);\n\n    offset.multiplyTransformTransform(transform, transform);\n    transform.multiplyPoint3d(viewCenter, viewCenter);\n    vp.npcToWorld(viewCenter, viewCenter);\n    vp.zoom(viewCenter, zoomRatio, { saveInUndo: false, animateFrustumChange: false });\n  }\n\n  private handleEvent(ev: BeTouchEvent): void {\n    if (undefined === this.viewport)\n      return;\n\n    if (this._startTouchCount !== ev.touchCount) {\n      this.onStart(ev);\n      return;\n    }\n\n    const smallDistance = this.viewport.pixelsFromInches(0.05);\n    if (this._lastPtView.isAlmostEqualXY(ev.viewPoint, smallDistance))\n      return;\n\n    if (this._startPtView.isAlmostEqualXY(ev.viewPoint, smallDistance)) {\n      this._lastPtView.setFrom(this._startPtView);\n    } else {\n      this._lastPtView.setFrom(ev.viewPoint); this._lastPtView.z = this._startPtView.z;\n    }\n\n    if (!this.viewport.setupViewFromFrustum(this._frustum))\n      return;\n\n    if (this.viewport.view.allow3dManipulations()) {\n      if (ev.isSingleTouch)\n        return this.handle3dRotate(ev);\n\n      return this.handle3dPanZoom(ev);\n    }\n\n    if (ev.isSingleTouch)\n      return this.handle2dPan(ev);\n\n    return this.handle2dRotateZoom(ev);\n  }\n\n  public async onTouchMove(ev: BeTouchEvent): Promise<void> { this.handleEvent(ev); }\n  public async onTouchComplete(_ev: BeTouchEvent): Promise<void> { this.exitTool(); }\n  public async onTouchCancel(_ev: BeTouchEvent): Promise<void> { this.exitTool(); }\n\n  public async onDataButtonDown(_ev: BeButtonEvent) { return EventHandled.Yes; }\n  public async onDataButtonUp(_ev: BeButtonEvent) { return EventHandled.Yes; }\n\n}\n\n/** A tool that performs view undo operation. An application could also just call Viewport.doUndo directly, creating a ViewTool isn't required.\n * @public\n */\nexport class ViewUndoTool extends ViewTool {\n  public static toolId = \"View.Undo\";\n\n  public onPostInstall() {\n    if (this.viewport)\n      this.viewport.doUndo(ToolSettings.animationTime);\n    this.exitTool();\n  }\n}\n\n/** A tool that performs view redo operation. An application could also just call Viewport.doRedo directly, creating a ViewTool isn't required.\n * @public\n */\nexport class ViewRedoTool extends ViewTool {\n  public static toolId = \"View.Redo\";\n\n  public onPostInstall() {\n    if (this.viewport)\n      this.viewport.doRedo(ToolSettings.animationTime);\n    this.exitTool();\n  }\n}\n\n/** A tool that toggles the camera on/off in a spatial view\n * @public\n */\nexport class ViewToggleCameraTool extends ViewTool {\n  public static toolId = \"View.ToggleCamera\";\n\n  public onInstall(): boolean { return (undefined !== this.viewport && this.viewport.view.allow3dManipulations()); }\n\n  public onPostInstall(): void {\n    if (this.viewport) {\n      const vp = this.viewport;\n      if (vp.isCameraOn)\n        (vp.view as ViewState3d).turnCameraOff();\n      else\n        vp.turnCameraOn();\n\n      const startFrustum = vp.getFrustum();\n      vp.synchWithView(true);\n      vp.animateFrustumChange(startFrustum, vp.getFrustum());\n    }\n    this.exitTool();\n  }\n}\n","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_bentleyjs_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_geometry_core__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_clients__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_common__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_i18n__;","module.exports = __WEBPACK_EXTERNAL_MODULE__bentley_imodeljs_quantity__;"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;AC9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACvLA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC18CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AADA;AACA;AATA;AAWA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAlBA;AAoBA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAHA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAXA;AAaA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAmBA;AAlBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AAwBA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0yFA;AAvyFA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAxyFA;AA9FA;AAy4FA;;;;;;;;AAQA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA+CA;AA9CA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAtEA;;;;;;;;;;;;;;AC9lGA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;;AAEA;AACA;AASA;AARA;AACA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArIA;AAuIA;;;AAGA;AACA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA+xBA;AAzxBA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3zBA;AA6zBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AA5BA;AA8BA;AACA;AACA;AAAA;AACA;AACA;AACA;AAOA;AANA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AARA;AASA;;;;;;;;;;;;;;ACphCA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA9OA;AAgPA;;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AA8BA;;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtCA;AAwCA;;AAEA;AACA;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;AClXA;;;AAGA;AACA;AACA;AACA;AAIA;;;;;;;;AAQA;AACA;AAIA;AACA;AAFA;AAGA;AACA;AACA;AAPA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;;AAAA;AACA;AA1DA;;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzJA;;;;;;;;;;;;;;;ACXA;AAeA;;;AAGA;AACA;AAUA;AACA;AAAA;AACA;AAVA;;;AAGA;AACA;AACA;AACA;AAMA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AApEA;;;;;;;;;;;;;;;ACxBA;;;AAGA;AACA;AACA;AAkBA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AASA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AA5LA;AA8LA;;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAXA;AAoBA;;;;;;AAMA;AACA;AAIA;AAHA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAnCA;AAqCA;;;;;;AAMA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAFA;AAIA;;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhBA;AAiBA;AAEA;;;AAGA;AACA;AAgBA;AACA;AACA;AAjBA;AACA;AASA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAjDA;AAmDA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AArCA;AAuCA;;;;;AAKA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AArGA;AAuGA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AA5FA;;;;;;;;;;;;;;AC7jBA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AAhBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AA2BA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AAJA;AAWA;AACA;AAAA;AAEA;AA0HA;AAvHA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA5HA;AA8HA;AACA;AAAA;AAGA;AACA;AA8GA;AA5GA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAlHA;;;;;;;;;;;;;;ACrNA;;;AAGA;AACA;;AAGA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAmBA;;AAEA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7dA;;;;;;;;;;;;;;ACpCA;;;AAGA;AACA;;AAEA;AACA;AAGA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;;;;AAIA;AACA;AAEA;AACA;AAWA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AA1DA;AA4DA;;AAEA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;;;;;;;;;;;;;;AC5EA;;;AAGA;AACA;;AAEA;;;;AAIA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;ACzBA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;;AAKA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AA1BA;AA4BA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;;;;;;;;;;;;;;ACrDA;;;AAGA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlGA;AAqHA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAmBA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AATA;AACA;AACA;AAQA;;;;;;;;;;;;;;;ACpMA;AAgBA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAvBA;AAyBA;;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAVA;;;;;;;;;;;;;;;ACjOA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;;;;;;;;;;;AAWA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvDA;AAyDA;;;AAGA;AACA;AAgBA;;;;;AAKA;AACA;AACA;AADA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArJA;AAuJA;AACA;AACA;AACA;AADA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA7BA;AA+BA;;;AAGA;AACA;AAAA;AACA;AACA;AA0IA;AAzIA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AA5IA;;;;;;;;;;;;;;ACtVA;;;AAGA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiDA;;;;;;;;AAQA;AACA;AAmBA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvOA;AAuBA;AACA;AA8CA;AACA;AAxEA;;;;;;;;;;;;;;ACrGA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AA2GA;AACA;AAnFA;AACA;AAqCA;;AAEA;AACA;AAkJA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApFA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAUA;;AAEA;AACA;AACA;AACA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AA6BA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;AAcA;AACA;;;AACA;AAAA;AACA;AACA;;;;;;;;;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;;AAKA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1fA;AACA;AAeA;;AAEA;AACA;AApDA;AA8hBA;AACA;AAYA;AACA;AAIA;AACA;AAAA;AAJA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAhFA;AAkFA;AACA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAtBA;AAwBA;AACA;AAGA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAhDA;AAkDA;AACA;AACA;AACA;AAAA;AAAA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvFA;AAyFA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AALA;AAMA;;;;;;;;;;;;;;AC30BA;;;AAGA;AACA;;AAEA;AACA;AASA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;;;AAIA;AACA;AACA;AACA;AACA;AAHA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;;;;AAKA;AACA;AACA;AACA;AAFA;AAIA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAPA;;;;;;;;;;;;;;ACtJA;;;AAGA;AACA;;AAEA;AACA;AAGA;AAmBA;;;;AAIA;AACA;AA0EA;;;AAGA;AACA;AA1EA;AACA;AACA;AACA;AASA;AACA;AA8DA;AACA;AACA;AACA;AAzCA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAYA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAxMA;AA0MA;;;AAGA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AARA;AAUA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA8DA;AArDA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAvEA;;;;;;;;;;;;;;AC9PA;;;AAGA;AACA;;AAEA;AACA;AAGA;AAEA;;;AAGA;AACA;AAMA;AACA;AAHA;AACA;AAGA;AACA;AACA;AATA;AACA;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AA/DA;;;;;;;;;;;;;;AChBA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AA7CA;AA+EA;;;AAGA;AACA;AAAA;;AAKA;AACA;AACA;AACA;AAkHA;AAzHA;AACA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1HA;AA4HA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AArBA;AAuBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;;AAEA;AACA;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;;ACnTA;;;AAGA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AA3BA;AA6BA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAPA;;;;;;;;;;;;;;;AChEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;;AAEA;AACA;AAOA;;;;;;AAMA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAbA;AAIA;AASA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAnCA;AAqCA;;AAEA;AACA;AAGA;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AARA;AAQA;AAEA;AACA;AAEA;AACA;AACA;AAhBA;AAkBA;;;;AAIA;AACA;AAAA;AACA;AAgFA;AA9EA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;;;AAKA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;;AAKA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAjFA;;;;;;;;;;;;;;;ACpLA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;;;;;AAKA;AACA;AACA;;;;;;;;;;AAUA;AACA;AAAA;AAAA;AACA;AAEA;;;AAGA;AACA;AACA;AAQA;AA5BA;AA8BA;AACA;AAKA;AAAA;AAAA;AAJA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAIA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAvJA;AACA;AAFA;;;;;;;;;;;;;;;ACvFA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAHA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA8SA;AA5SA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtTA;;;;;;;;;;;;;;AC1SA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AAAA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;;;AAKA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;;;;;;;;;;;;AC1EA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAPA;AAQA;AAEA;AACA;AAFA;AAGA;AACA;AACA;AANA;AAOA;AAEA;AACA;AACA;AACA;AACA;AANA;AAQA;AAEA;AACA;AACA;AACA;AACA;AANA;AAOA;AAEA;AACA;AACA;AACA;AACA;AANA;AAOA;AASA;AADA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA7KA;AA+KA;AAKA;AAHA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApDA;AAsDA;AAKA;AAJA;AAIA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAnDA;AAoDA;;;;;;;;;;;;;;;ACrVA;;;AAGA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAqDA;;AAEA;AACA;AAIA;AACA;AAHA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAOA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAVA;AAYA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AA9CA;AAgDA;;;;AAIA;AACA;AAWA;AAAA;AAVA;AAOA;AACA;AAEA;AARA;;AAEA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtIA;AAwIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;;AChXA;;;AAGA;AACA;;AAEA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;;;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AA/EA;AAiFA;AACA;AAAA;AACA;AACA;AAAA;;AACA;AACA;AAEA;AA2EA;AAxEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA/EA;AAwGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAYA;AACA;AACA;;AAbA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA7BA;AA+BA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AACA;AAWA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AA7QA;AACA;AAFA;AAiRA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AACA;AACA;AACA;AAsBA;AA5BA;AA8BA;AACA;AAMA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/EA;AAiFA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AATA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAQA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AArGA;AAuGA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAtHA;AACA;AAFA;AA0HA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAZA;AAcA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAzBA;AA2BA;AACA;AAIA;AAHA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA5DA;AA6DA;AAEA;;AAEA;AACA;AAUA;AACA;AAkBA;AAjBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhIA;;;;;;;;;;;;;;;AC1hCA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAPA;;;;;;;;;;;;;;;ACjNA;;;AAGA;AACA;AACA;AAIA;AACA;AACA;AAEA;;;;AAIA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AA0BA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AALA;AAOA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AALA;AAOA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AALA;AAMA;;;;;;;;;;;;;;ACzJA;;;AAGA;AACA;;AAEA;AAEA;AAKA;;;;;;;;;;;;;AAaA;AACA;AAYA;;AAEA;AACA;AAZA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AAdA;AACA;AACA;AACA;AAYA;AAtBA;AAwBA;;;AAGA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAfA;AADA;AAmBA;;;;;AAKA;AACA;AAAA;AAIA;;AAEA;AACA;AAiDA;AAhDA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAxDA;;;;;;;;;;;;;;;AChFA;;;AAGA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAnCA;;;;;;;;;;;;;;ACvDA;;;AAGA;;;;;;;;;AAEA;AAOA;AAkBA;AAEA;;AAEA;AACA;AAKA;AAJA;AACA;AAGA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAlFA;AAoFA;;AAEA;AACA;AASA;AASA;AAPA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;AAEA;;AACA;AACA;AAEA;AACA;;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAlDA;AAsDA;AAIA;AACA;AACA;AACA;AACA;AARA;AAUA;;;;;AAKA;AACA;AAAA;AAKA;AAmGA;AAjGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxGA;AAyGA;;;;;;;;;;;;;;AClTA;;;AAGA;AACA;;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAIA;AACA;AACA;AA0OA;AA7OA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAjPA;;;;;;;;;;;;;;;ACZA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAGA;AANA;;;;;;;;;;;;;;;ACDA;AACA;AAAA;AAiBA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAOA;;;;;;;;;;;;;;AC1CA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;;AAEA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AA1CA;AA4CA;;;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAZA;AAcA;;AAEA;AACA;AAKA;AACA;AACA;AADA;AAEA;AACA;AANA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAIA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AApaA;AAsaA;;;;AAIA;AACA;AAWA;AACA;AAXA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxDA;;;;;;;;;;;;;;;AClgBA;;;AAGA;AACA;AACA;AAEA;AAEA;AACA;AAiDA;;;;;;;AAOA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAkBA;;;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;AAIA;AACA;AAoPA;AAtSA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAsCA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA/SA;;;;;;;;;;;;;;ACnEA;;;AAGA;AACA;;AAEA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAqBA;AACA;AAGA;AAHA;AAKA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAiDA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAEA;;AAEA;AACA;AAMA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtyBA;AAwyBA;;;AAGA;AACA;AAiBA;AACA;AALA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AACA;AAaA;AACA;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;;;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAxgBA;AA0gBA;;;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApGA;AAsGA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAPA;AASA;;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/EA;AAiFA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAzBA;;;;;;;;;;;;;;AC5pDA;;;AAGA;AACA;;AAEA;AACA;AAIA;AAMA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAgBA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;AAtBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AAgCA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA3CA;AA6CA;;;;AAIA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxIA;AAqJA;;AAEA;AACA;AAAA;AACA;;AAEA;AACA;AAEA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAMA;;;;;AAKA;AACA;AAAA;AAAA;AAAA;AAAA;AAXA;AAYA;AACA;AAVA;AAYA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAqBA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA9BA;AAkEA;;AAEA;AACA;AAiOA;AA9NA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAQA;AA8LA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAzTA;AA+BA;AACA;AACA;AASA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6FA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AACA;;;;AAIA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAlcA;AACA;AARA;AA4cA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;;;;AAMA;AACA;AAAA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAIA;AACA;AAJA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA;AAEA;AAqaA;AACA;AAraA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AASA;;AAEA;AACA;AACA;;AAEA;AACA;AAWA;;;;;;AAMA;AACA;AAEA;;;;;;;AAOA;AACA;AAMA;AACA;AAGA;AAGA;AAGA;AAqBA;AACA;AAaA;AACA;AAyjCA;;AAEA;AACA;AAhzBA;AACA;AACA;AA5WA;AACA;AA2DA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AA90CA;;AAEA;AACA;AAqBA;AACA;AACA;AA3GA;AAk6CA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AACA;AAyEA;AACA;AACA;AAxEA;AACA;AACA;AACA;AAsEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAxEA;;;;;;;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuBA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArUA;AAuUA;;;;AAIA;AACA;AAAA;AACA;AACA;AAqBA;AApBA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvBA;AAyBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAlBA;AAoBA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAjBA;;;;;;;;;;;;;;ACv8FA;;;AAGA;;;;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AAEA;;;;AAIA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;AAGA;AACA;;;;AAIA;AACA;;;AAGA;AACA;;;AAGA;;;;;;;;;;;;;;ACtJA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAKA;AACA;AACA;AADA;AA+JA;AACA;AAwFA;AACA;AACA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAhTA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;;;;;;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA6DA;AAzTA;;;;;;;;;;;;;;;AClEA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuKA;;;AAGA;;;;;;;;;;;;;;;AC3KA;;;;AAIA;AACA;AAYA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AArBA;;;;;;;;;;;;;;AC5BA;;;AAGA;AACA;;AAIA;AACA;AAEA;;AAEA;AACA;AAKA;AAJA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAjCA;AA+CA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AARA;AASA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AARA;AAUA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;;;;;;;;;;;;;;AC1FA;;;AAGA;AACA;;AAKA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAiBA;;;AAGA;AACA;AAwFA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5FA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAyBA;;AAjGA;AACA;AAfA;AAkHA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AACA;AAiWA;;AAEA;AACA;AAnWA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AA0TA;AACA;AACA;;AAEA;AACA;AACA;AA9TA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAMA;AAIA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AA7RA;AA3GA;AA0YA;;;;;;;;;;;;;;AC9jBA;;;AAGA;AACA;;AAIA;AAUA;AAUA;;;;;;;AAOA;AACA;AAAA;AACA;;;;;;;AAOA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;;;;;;;;;;AAUA;AACA;AACA;;;;;;;;AAQA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;AAkBA;AACA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAkFA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AA9JA;;;;;;;;;;;;;;AC3GA;;;AAGA;;AAEA;AACA;AAcA;AAEA;AAIA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AALA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AACA;AALA;AAOA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AATA;AAWA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAJA;AAMA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AANA;AAQA;AACA;AAKA;AAJA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAnBA;AAwBA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAZA;AADA;AAeA;;;;;;;;;;;;;;AClKA;;;AAGA;AACA;;AAEA;AACA;AACA;AAMA;AACA;AAIA;AAGA;AAEA;AAOA;AAEA;;AAEA;AACA;AAAA;AACA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAWA;AATA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAdA;AA8BA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AA9BA;AA4CA;AACA;AAKA;AAJA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArDA;AA2DA;AAEA;;AAEA;AACA;AAoBA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA3DA;AA6DA;;;;;;AAMA;AACA;AAKA;AALA;AAmBA;;;;AAIA;AACA;AAIA;AACA;AACA;AAUA;AAhBA;AAiBA;;AAEA;AACA;AAQA;AARA;AAUA;;AAEA;AACA;AAEA;AAFA;AAeA;;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAFA;AA6DA;;AAEA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArCA;AAuCA;;;;;;AAMA;AACA;AAaA;;AAEA;AACA;AAfA;AACA;AAGA;AAWA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA3CA;AA6CA;;;AAGA;AACA;AAAA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AApBA;AA4EA;AAUA;;;;AAIA;AACA;AASA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAzKA;AA2KA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAUA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAKA;AACA;AACA;AAEA;AAGA;AACA;AA5CA;AAsGA;;;;;AAKA;AACA;AAOA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;AACA;AAOA;;;;AAIA;AACA;AAEA;;;;;;AAMA;AACA;AAcA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AAUA;;;;AAIA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAtPA;AAkSA;;AAEA;AACA;AAIA;AACA;AALA;;;;;;;;;;;;;;ACloCA;;;AAGA;AACA;;AAeA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AATA;AA+BA;;;;;;;AAOA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtDA;;;;;;;;;;;;;;ACpFA;;;AAGA;AACA;;AAEA;AACA;AAEA;AACA;AAGA;AAAA;AAFA;AAEA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;;AAJA;AApCA;;;;;;;;;;;;;;ACVA;;;AAGA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAaA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;AAxJA;AADA;AA4JA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;ACjMA;;;AAGA;AACA;;AAEA;AAGA;AACA;AAMA;AAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AAZA;;;;;;;;;;;;;;ACVA;;;AAGA;AACA;;AAKA;AACA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AArBA;AAuBA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AClCA;;;AAGA;AACA;;AAEA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAsBA;AACA;AAKA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AAKA;AAJA;AACA;AAGA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAzBA;AA2BA;AACA;AAAA;AACA;AACA;AAoCA;AAlCA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtCA;AAwCA;AACA;AAGA;AAFA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AArDA;AAuDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;;;;;;;;;;;;;;ACpLA;;;AAGA;AACA;;AAKA;AACA;AAEA;AACA;AAHA;AAKA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAtBA;AAwBA;AACA;AAAA;AAAA;AAAA;;;;;;;;;;;;;;AC5CA;;;AAGA;AACA;;AAEA;AAYA;AACA;AAOA;AALA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA1DA;AA4DA;AACA;AACA;AAEA;AACA;AACA;AACA;AANA;;;;;;;;;;;;;;AChFA;;;AAGA;AACA;;AAEA;AACA;AACA;AAoBA;AAEA;AAEA;;;;AAIA;AACA;AAGA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA9BA;AAqCA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AA8BA;;;;;;;AAOA;AACA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AA7EA;AA+EA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAlCA;AA+DA;AAOA;AANA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAWA;AAPA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAwCA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAlCA;AAoCA;;;;AAIA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA/BA;AAiCA;AACA;AAAA;AAEA;AAoEA;AA/DA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAtEA;AA0EA;;;;;;;AAOA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AAIA;AACA;AAHA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC56BA;;;AAGA;AACA;;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAeA;AAVA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAXA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA9JA;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;;AAEA;AACA;AAGA;AACA;AAAA;AACA;AAyBA;AAvBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA1BA;;;;;;;;;;;;;;ACXA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AALA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAzHA;AA2HA;AACA;AAAA;;AACA;AAiCA;AA/BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAlCA;;;;;;;;;;;;;;ACrJA;;;AAGA;AACA;;AAEA;AACA;AAYA;AACA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAxDA;AA0DA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3CA;AA6CA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvBA;AAyBA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvBA;AAyBA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAhCA;AAkCA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAvBA;;;;;;;;;;;;;;AC3NA;;;AAGA;AACA;;AAEA;AACA;AASA;AACA;AASA;AACA;AAGA;AACA;AAQA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AAMA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA3NA;AA8OA;AACA;AASA;AAPA;AAOA;AAAA;AANA;AACA;AACA;AACA;AACA;AACA;AAEA;AAVA;AAyBA;AACA;AAKA;AAFA;AAGA;AACA;AACA;AACA;AACA;AAVA;;;;;;;;;;;;;;ACxSA;;;AAGA;AACA;;AAEA;AAIA;AACA;AACA;AAIA;AAEA;AACA;AAYA;AACA;AAHA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA3IA;AA6IA;AACA;AACA;AAOA;AANA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AArCA;AAsCA;;;;;;;;;;;;;;ACxMA;;;AAGA;AACA;;AAEA;AACA;AACA;AAuBA;AACA;AAEA;AAGA;;AAEA;AACA;AAUA;AATA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA9DA;AAgEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAUA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;;AAEA;AACA;AAAA;AACA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AAgEA;AA9DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AA9EA;AAgFA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAHA;AAKA;AACA;AAgBA;AAbA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AApGA;AAsGA;AACA;AAOA;AAMA;AAJA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAjDA;AA6DA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;;;;;ACpYA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAKA;;;;AAIA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtCA;AAwCA;;;;;;;AAOA;AACA;AAGA;AAFA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAtCA;AAwCA;;;;;;;;;;;;;;AAcA;AACA;AAAA;AACA;AAqGA;AAlGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAtGA;;;;;;;;;;;;;;AC1HA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAKA;AAMA;;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAhHA;AAkHA;;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAjBA;AAmBA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA3BA;AA6BA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAtBA;AAwBA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAZA;AAcA;;AAEA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAlBA;AAoBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AALA;AAMA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAzCA;AA2CA;;AAEA;AACA;AAKA;AAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AALA;AAMA;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAnBA;AAqBA;;AAEA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAXA;AAaA;;AAEA;AACA;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhGA;AAkGA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAjBA;AAmBA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAlBA;AAoBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AApCA;AAsCA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAhBA;AAiBA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA3BA;;;;;;;;;;;;;;ACxtBA;;;AAGA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;;AAEA;AACA;AAwEA;AAvEA;AACA;AAKA;AACA;AAiEA;AACA;AACA;AACA;AAlEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAUA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAxEA;AA0EA;;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAlKA;;;;;;;;;;;;;;ACzQA;;;AAGA;AACA;;AAGA;AACA;AAGA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AA1BA;;;;;;;;;;;;;;ACdA;;;AAGA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAMA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AA5BA;AACA;AACA;AACA;AAJA;;;;;;;;;;;;;;ACZA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AASA;AAGA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAuBA;AArBA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AA3BA;AA6BA;AAEA;AACA;AAAA;AAGA;AACA;AA8CA;AA5CA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAlDA;AAwEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA9BA;AAgCA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA3BA;AAkCA;;AAEA;AACA;AAyCA;AAvCA;AACA;AAIA;AACA;AACA;AACA;AAgCA;AACA;AACA;AACA;AACA;AACA;AACA;AAnCA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAWA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA/cA;;;;;;;;;;;;;;AC3QA;;;AAGA;AACA;;AAEA;AACA;AAGA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAiBA;AAbA;AAcA;AACA;AAbA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AA5CA;;;;;;;;;;;;;;ACxDA;;;AAGA;AACA;;AAEA;AACA;AACA;AAkBA;AACA;AAIA;AACA;AALA;AAOA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAxCA;AAmDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;;;;;;;;;;;;;;ACpGA;;;AAGA;AACA;;AAEA;AAKA;AAEA;AACA;AA2CA;AAxCA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAIA;AA7CA;;;;;;;;;;;;;;ACdA;;;AAGA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAaA;AAZA;AAYA;AATA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AApCA;AAsCA;AACA;AAaA;AAZA;AAYA;AATA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAhCA;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AA0BA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAnBA;AAqBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;;;;;;;;;;;;;;AC3KA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AAcA;AACA;AAgBA;AAdA;AACA;AACA;AAaA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAzCA;AAEA;AACA;AACA;AACA;AACA;AACA;AAoCA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAlHA;AAyHA;AACA;AAAA;AACA;AACA;AAmDA;AAjDA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AArDA;;;;;;;;;;;;;;ACnJA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;AC3OA;;;AAGA;AACA;;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAsMA;AAnMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA4LA;AACA;AA3LA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAhPA;AAkPA;AACA;AAEA;AACA;AACA;AACA;AALA;AAOA;AACA;AAOA;AACA;AAJA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAxEA;AA0EA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA1BA;AA4BA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAeA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA1BA;;;;;;;;;;;;;;AClZA;;;AAGA;AACA;;AAEA;AACA;AAGA;AAMA;;;;AAIA;AACA;AAIA;AACA;AAHA;AAIA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA/DA;AAiEA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAjBA;AAmBA;;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AArBA;AAuBA;;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA3BA;AAyCA;;AAEA;AACA;AAKA;AAHA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAzFA;;;;;;;;;;;;;;ACvOA;;;AAGA;AACA;;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAkBA;AAPA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AApHA;AAsHA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA/EA;;;;;;;;;;;;;;ACvIA;;;AAGA;AACA;;AAEA;AAEA;AACA;AAcA;AACA;AAZA;AAEA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AA1CA;AACA;AACA;AACA;;AAXA;AADA;AAsDA;;;;;;;;;;;;;;AC/DA;;;AAGA;AACA;;AAEA;AACA;AAEA;AACA;AAGA;AAFA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhGA;AAkGA;AACA;AAGA;AAFA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAkBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5RA;AA8RA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AAFA;;;;;;;;;;;;;;ACnZA;;;AAGA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AApCA;AAsCA;AACA;AAoBA;AACA;AAnBA;AAoBA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAnCA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAwBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAlEA;AAoEA;;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAxCA;AA0CA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA7CA;AA+CA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA7BA;AA+BA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAtCA;AAwCA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7LA;;;;;;;;;;;;;;;ACrTA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AADA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAqBA;AAAA;AAAA;AAZA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAtRA;AAnBA;;;;;;;;;;;;;;;AC3CA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AAQA;AACA;AANA;AAOA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAtCA;;;;;;;;;;;;;;AClBA;;;AAGA;AACA;;AAEA;AAGA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAzDA;;;;;;;;;;;;;;ACtBA;;;AAGA;AACA;;AAEA;AAGA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AA7GA;;;;;;;;;;;;;;ACxBA;;;AAGA;AACA;;AAEA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;AAAA;AAFA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAlGA;AAoGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AAEA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AAEA;AACA;AACA;AACA;AANA;;;;;;;;;;;;;;AC5IA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAzCA;;;;;;;;;;;;;;ACXA;;;AAGA;AACA;AACA;;AAmCA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA6BA;AACA;AAAA;AAEA;AACA;AAAA;;;;;;;;;;;;;;ACpGA;;;AAGA;AACA;;AAEA;AACA;AAEA;AACA;AAQA;AAPA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAlEA;AAoEA;AACA;AASA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAnFA;AAqFA;AACA;AAKA;AAJA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA/BA;AAiCA;AACA;AAKA;AAJA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA/BA;AAiCA;AACA;AAMA;AALA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAlDA;AAoDA;;;;;;;;AAQA;AACA;AASA;AARA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAvEA;AAfA;AAyFA;;;;;;;;;;;;;;AC/XA;;;AAGA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AATA;AAWA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAgIA;AAjFA;AACA;AACA;AACA;AAwBA;AAuDA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AA7IA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAwBA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAeA;AAEA;AACA;AACA;AACA;AApBA;AAsBA;AACA;AA6DA;AACA;AA7DA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgDA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAtFA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA0DA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AASA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AALA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACx2CA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AA8CA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAdA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AARA;AASA;AAUA;;AAEA;AACA;AASA;AAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA7DA;AA+DA;;;;AAIA;AACA;AAAA;AACA;AAgHA;AA9GA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAjHA;AAmHA;;AAEA;AACA;AAAA;AACA;AAoCA;AAlCA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;AAWA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AArCA;AAkDA;;;;AAIA;AACA;AAUA;AACA;AAVA;AACA;AACA;AACA;AAQA;AACA;AACA;AAPA;AACA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AArIA;AAkKA;;AAEA;AACA;AASA;AACA;AATA;AACA;AASA;AACA;AAEA;AACA;AAXA;AACA;AAEA;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AApFA;AAgJA;;AAEA;AACA;AAGA;AACA;AAHA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA9HA;AAgIA;;AAEA;AACA;AAKA;AAHA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAzDA;AAkEA;;;;AAIA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AApGA;;;;;;;;;;;;;;ACh2BA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AACA;AAiBA;;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAhBA;AAyBA;;;;AAIA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAbA;AAsBA;;;;;AAKA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAbA;AAoBA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AAoCA;AACA;AAaA;AAPA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvLA;AAyLA;;;;AAIA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA3DA;;;;;;;;;;;;;;;ACrVA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AADA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAuBA;AACA;AAtBA;AAMA;AACA;AACA;AACA;AACA;AACA;AAYA;AAXA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAtNA;AACA;AArBA;;;;;;;;;;;;;;AC5CA;;;AAGA;AACA;;AAEA;AACA;AAIA;AAgBA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAwCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA2NA;AAzNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA1LA;AACA;AA/CA;AA2OA;;AAEA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhJA;AA2JA;AACA;AAwQA;AACA;AAvQA;AAEA;AAMA;AAEA;AACA;;;;AAIA;AACA;;;;AAIA;AAoPA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAvPA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA/eA;;;;;;;;;;;;;;AC1fA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAyBA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;AAsCA;;AAEA;AACA;AAAA;AAEA;AACA;AAuBA;AArBA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1BA;AA4BA;;AAEA;AACA;AAAA;AACA;AAOA;AALA;AACA;AAEA;AACA;AACA;AARA;AAUA;AACA;AAeA;AAdA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhDA;AAkDA;AACA;AACA;AACA;AACA;AAwBA;AAMA;AAFA;AAGA;AACA;AACA;AAEA;AACA;AA2DA;AACA;AA1DA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAyJA;AACA;AACA;AACA;AAkCA;AA2VA;AAuKA;AACA;AACA;AA7rBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAcA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA7nBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzVA;AAo9BA;;AAEA;AACA;AAMA;AACA;AAJA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AArKA;AAuKA;AACA;AAGA;AACA;AAHA;AAIA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AApDA;AAsDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;ACt+CA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAZA;AAcA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AA4CA;AA3CA;AACA;AA2CA;AACA;AA1CA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAxHA;AA6HA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAvFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiFA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAjDA;AACA;AACA;AACA;AACA;AAgDA;AAQA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AArDA;AACA;AACA;AACA;AACA;AAoDA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAjDA;AACA;AACA;AACA;AACA;AAgDA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AACA;;AA7BA;AAgCA;;AAEA;AACA;AAgJA;AA/IA;AACA;AAyBA;AAqHA;AA5IA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AA9KA;;;;;;;;;;;;;;AC1eA;;;AAGA;AACA;;AAEA;AAIA;AAaA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AAPA;AAsBA;;AAEA;AACA;AAWA;AAVA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;;AAEA;AA1GA;;;;;;;;;;;;;;ACnDA;;;AAGA;AACA;;AAGA;AA2CA;;;;;;;;;AASA;AAEA;AACA;AACA;AACA;AACA;AAHA;;;;;;;;;;;;;;AC9DA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAaA;;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAhBA;AAkBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;;AAEA;AACA;AA0DA;AAxDA;AAyDA;AACA;AAnDA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AA7DA;AA+DA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA5GA;AA8GA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAzDA;AA2DA;AACA;AAIA;AAFA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;;;;;;;;;;;;;;AC1eA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AAMA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA1CA;AA4CA;;AAEA;AACA;AAUA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AA9CA;;;;;;;;;;;;;;AChEA;;;AAGA;AACA;;AAEA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAuEA;AAEA;;;;AAIA;AAEA;;;;;;;;;;;;;;;AAeA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AA1DA;;;;;;;;;;;;;;AC7IA;;;AAGA;AACA;;AAKA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AAaA;AAEA;AACA;;;;;AAKA;AAEA;AACA;;;;;;;;;;;;;AAaA;AAEA;;;;;;;;;;;;AAYA;AAEA;;;AAGA;AAEA;;;;AAIA;AAEA;;;;;;;;;AASA;AAEA;;;;AAIA;AAEA;;;;;;;;;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AArHA;;;;;;;;;;;;;;ACnLA;;;AAGA;AACA;;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA4BA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAvCA;;;;;;;;;;;;;;AChDA;;;AAGA;AACA;;AAEA;AAGA;AAEA;AAEA;;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AApBA;;;;;;;;;;;;;;ACpBA;;;AAGA;AACA;;AAIA;AACA;AAEA;AACA;;;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAbA;;;;;;;;;;;;;;ACpBA;;;AAGA;AACA;;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAVA;;;;;;;;;;;;;;AChBA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAGA;;;;;;AAMA;AAEA;;;;;;;;;;;;;;AAcA;AAEA;AACA;;;;;;;;;;;;;;AAcA;AAEA;;;;AAIA;AAEA;;;;;;;;;;;;;;;;;;;;;;;AAuBA;AAEA;;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;ACxJA;;;AAGA;AACA;;AAQA;AACA;AACA;AAEA;AACA;AACA;;;;;AAKA;AACA;;AAEA;AACA;AACA;;;;AAIA;AACA;;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AApBA;;;;;;;;;;;;;;AC3DA;;;AAGA;AACA;;AAEA;AAIA;AACA;AAEA;AAEA;;;;;AAKA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAtBA;;;;;;;;;;;;;;ACvBA;;;AAGA;AACA;;AAMA;AACA;AAEA;;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAVA;AAYA;AAEA;AACA;AACA;AACA;AAFA;AAIA;AACA;;;;;;;;;AASA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;AAKA;AACA;;;;;;;;;;;;;;ACxIA;;;AAGA;AACA;;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AAEA;;;;;;;;;;;;;;;;;;;;;AAqBA;AAEA;;;;;;AAMA;AAEA;AACA;AAEA;AAEA;;;;;;;AAOA;AAEA;;;;;;;;;;AAUA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AArEA;;;;;;;;;;;;;;ACrFA;;;AAGA;AACA;;AAEA;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAdA;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;;AAEA;AAIA;AACA;AACA;AAEA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AA3BA;;;;;;;;;;;;;;ACtBA;;;AAGA;AACA;;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;;;;;;;;;;;;;;AClBA;;;AAGA;AACA;;AAEA;;AAEA;AACA;AAAA;AACA;;;;;AAKA;AAEA;;;;;AAKA;AAEA;;AAEA;AAEA;;;AAGA;AAEA;;AAEA;AAEA;;;;;;;;;;AAUA;AACA;;;;;;;;;;;;;;AChDA;;;AAGA;AACA;;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;AASA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;AAwBA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAkCA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;;;;;AC9JA;;;AAGA;AACA;;AAYA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AAEA;AACA;;;;AAIA;AAEA;;AAEA;AAEA;;;;;AAKA;AAEA;;;;;;AAMA;AAEA;;;;AAIA;AAEA;;;;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;AAcA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AA8BA;AACA;AAEA;AACA;AACA;;;;;AAKA;AAEA;;;;;AAKA;AAEA;;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAfA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;AAMA;AAEA;AACA;;;;;;;;;AASA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AA9CA;AAgDA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAoCA;AAEA;AACA;AACA;;;AAGA;AAEA;;;AAGA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;AAqBA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAfA;AAiBA;;;AAGA;AACA;AACA;AACA;AACA;AAHA;AAKA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAvBA;;;;;;;;;;;;;;ACrqBA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;;;;;;;AAQA;AAEA;;;;;;;;AAQA;AAEA;;;;AAIA;AAEA;;;;AAIA;AAEA;;;;;;;AAOA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AApBA;AAsBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAXA;AAaA;AACA;AAAA;AACA;AAEA;AAEA;;;;;AAKA;AAEA;;;;;AAKA;AAEA;;;;;;;;AAQA;AAEA;;;;;;;;AAQA;AACA;;;;;;;;;;;;;;ACvKA;;;AAGA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AAEA;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AApBA;AAsBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAVA;;;;;;;;;;;;;;AC5EA;;;AAGA;AACA;;AAOA;AACA;AAEA;;;;;;;AAOA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA8CA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAxBA;;;;;;;;;;;;;;ACxEA;;;AAGA;AACA;;AAIA;;;;;;;;;;;AAWA;AAEA;;;;AAIA;AAEA;;;;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAtBA;;;;;;;;;;;;;;AClCA;;;AAGA;AACA;;AAGA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;AAaA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;;;;;;;;;;;;;;;ACxBA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;AAsBA;AAEA;;;AAGA;AAEA;;;;;;AAMA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAhCA;AAkCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAXA;;;;;;;;;;;;;;AChIA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AArBA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AATA;;;;;;;;;;;;;;ACrDA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;AAKA;AAEA;AACA;AACA;AACA;AACA;;;;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;;;;;ACtDA;;;AAGA;AACA;;AAEA;AAQA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;;;;;;;;;;;;;;;;;;AAmBA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AA0BA;AAEA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA+CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AAWA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AAEA;;;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA0GA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAZA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;;;;;;;;;;;;;ACvWA;;;AAGA;AACA;;AAKA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;;;;;;;;;;;;;;ACdA;;;AAGA;AACA;;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AA1BA;;;;;;;;;;;;;;ACnBA;;;AAGA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;AAYA;AAEA;;;;;;;;;;AAUA;AAEA;AAEA;;;;;;;;;;;AAWA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AA7HA;;;;;;;;;;;;;;;ACtFA;;;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;AASA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AArDA;;;;;;;;;;;;;;AC5BA;;;AAGA;AACA;;AAEA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AAEA;AACA;AACA;AACA;;;;;;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxBA;AA0BA;;;;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AACA;AAbA;AAeA;AACA;;AAEA;AAEA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;AAWA;AAEA;AACA;;;;;;;;;;;AAWA;AAEA;;;;;;AAMA;AAEA;;;AAGA;AAEA;;AAEA;AAEA;;;;;AAKA;AACA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;AAoBA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAzDA;AA2DA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAFA;;;;;;;;;;;;;;AC3WA;;;AAGA;AACA;;AAGA;AACA;AACA;AACA;AAEA;;;;;;;;;;;AAWA;AAEA;;;;;;;;;;;;AAYA;AAEA;;;AAGA;AAEA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAjBA;;;;;;;;;;;;;;ACjDA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AAEA;;AAEA;AAEA;;AAEA;AAEA;AACA;;;;;;AAMA;AACA;;;AAGA;AACA;;;;;AAKA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAEA;;;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzBA;AA2BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlBA;AAoBA;AACA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAtBA;AAwBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAhBA;AAkBA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAhBA;AAkBA;AACA;AACA;AACA;AAFA;AAIA;AACA;AAAA;AACA;AACA;AACA;;;;;AAKA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;AClRA;;;AAGA;AACA;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AARA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AA6BA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;;;;;;;;;;;;;;ACrGA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AARA;;;;;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;ACxBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA5CA;AA6CA;AApDA;AAsDA;;;AAGA;AACA;AAcA;AACA;AADA;AAAA;AAAA;AAEA;AAfA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AArCA;AAsCA;;;;;;;;;;;;;;;ACpHA;;;AAGA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAVA;AAWA;AAhBA;AAiBA;;;;;;;;;;;;;;AC9BA;;;AAGA;AACA;;AAGA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AAGA;AAEA;;;AAGA;AAEA;AAEA;;AAEA;AACA;AAAA;AAwBA;;AAEA;AACA;AAOA;AACA;AANA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAnCA;AAoCA;AAzCA;AAuFA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApDA;AAsDA;;;;;;;;AAQA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AAlBA;AAoBA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AA9CA;AAqDA;;;;;;;;;;;AAWA;AAEA;;AAEA;AACA;AAyMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA3LA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA6BA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAnpBA;AAopBA;;;;;;;;;;;;;;;ACt9BA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAlBA;AAmBA;AA3BA;AA6BA;;;AAGA;AACA;AAeA;AACA;AADA;AAAA;AAAA;AAAA;AAEA;AAhBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAzGA;AA0GA;;;;;;;;;;;;;;AC3LA;;;AAGA;AACA;;AAEA;AAIA;AAKA;AASA;AAOA;;;;AAIA;AACA;AAAA;AA8BA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAxBA;AA0BA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AATA;AACA;AAUA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAzFA;AArBA;AAgHA;;;;;;;;;;;;;;AC9UA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAcA;AAIA;AACA;AACA;AACA;AAkBA;AAEA;AAEA;;AAEA;AACA;AAAA;AA8BA;;AAEA;AACA;AAwBA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAnCA;AACA;AAEA;AACA;AAgCA;AAtDA;AAwDA;AACA;AAUA;AAAA;AACA;AACA;AAAA;AAXA;AACA;AACA;AACA;AACA;AACA;;AAEA;AAOA;AACA;AAEA;;AAEA;AACA;AAkRA;AACA;AACA;AACA;AACA;AAlRA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA1nBA;AA2nBA;;;;;;;;;;;;;;;ACjyBA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AAAA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAnDA;AAoDA;;;;;;;;;;;;;;AC5FA;;;AAGA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAtCA;AAwCA;AACA;AAOA;AAAA;AANA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAvEA;AA0EA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAvCA;AA8CA;;;;;;;AAOA;AACA;AAOA;AACA;AACA;AANA;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AA7HA;AALA;;;;;;;;;;;;;;ACnPA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AAGA;;;;;;AAMA;AACA;AA0EA;;;;AAIA;AACA;AACA;AACA;AAUA;AA3FA;AA6FA;AACA;AA6FA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAlBA;AAmBA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAJA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AA2CA;AACA;AA3CA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAyBA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAvCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAwBA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;AC5lBA;;;AAGA;AACA;;AAEA;AACA;AAGA;AAEA;;AAEA;AACA;AAAA;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAIA;AAFA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA9DA;AAgEA;;;;;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAjBA;AAmBA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AANA;AAOA;;;;;;;;;;;;;;ACxKA;;;AAGA;AACA;;AAEA;AACA;AAIA;AAEA;;;AAGA;AACA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAlHA;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;;AAEA;AAUA;AAYA;AAaA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AA0BA;AATA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAnFA;AACA;AACA;AACA;AA7aA;AAggBA;AAEA;AACA;AA0EA;;;AAGA;AACA;AAqBA;AAfA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAzBA;AACA;AACA;AAEA;AACA;AACA;AAqBA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAtBA;AA3CA;AAoFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAdA;AAgCA;AAUA;;AAEA;AACA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAtBA;AACA;AA/EA;AAuGA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAlFA;AAoFA;;AAEA;AACA;AAoBA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAfA;AAiBA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AASA;AAAA;AAAA;AAAA;AAPA;AACA;AACA;AAKA;AAHA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA1BA;AA4BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AATA;AAWA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAPA;AASA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;;ACtmCA;;;AAGA;AACA;;AAEA;AASA;AAIA;AACA;AAEA;AACA;AACA;AAKA;AAYA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAsBA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AApHA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA6GA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AATA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AASA;AAJA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AADA;AAAA;AAHA;AAKA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAFA;AAGA;AACA;AAaA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAzDA;AA2DA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAnCA;AAqCA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAYA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;;AAEA;AACA;AAQA;AAHA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA7FA;AA+FA;;;AAGA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAhDA;AAkDA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAXA;;;;;;;;;;;;;;AC/8BA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAp/BA;AAs/BA;AAKA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;AAVA;AAaA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAnBA;AAqBA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AA8DA;AA3DA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;ACnuCA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AAAA;AAAA;AAAA;AAGA;AAqBA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AA/RA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAqSA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAxBA;AADA;AA4BA;AACA;AAGA;AAAA;AAAA;AADA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5CA;AADA;AAgDA;AACA;AAAA;;AAEA;AACA;AAkLA;AA7KA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAnLA;AADA;AAuLA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAjFA;AADA;AAqFA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA/DA;AADA;AAmEA;AACA;AAUA;AACA;AAJA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA9FA;AAgGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AArEA;AAuEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlCA;AAoCA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAhBA;AAkBA;AACA;AAcA;AACA;AADA;AAAA;AALA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AArfA;AAufA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AAMA;AAAA;AALA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlYA;AAoYA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AA0EA;AAxEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAvFA;;;;;;;;;;;;;;ACz2DA;;;AAGA;AACA;;AAEA;AAEA;AACA;AAKA;AAEA;;;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAGA;AAAA;AAAA;AAAA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;;AArBA;AACA;AAFA;AAyBA;AAMA;AAAA;AALA;AAKA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AApHA;AAsHA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5EA;AA6EA;;;;;;;;;;;;;;ACnPA;;;AAGA;AACA;;AAEA;AAGA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAMA;AAAA;AALA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAxMA;;;;;;;;;;;;;;AChIA;;;AAGA;AACA;;AAGA;AAEA;;;;AAIA;AACA;AAGA;AAAA;AAFA;AAGA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAlCA;;;;;;;;;;;;;;ACdA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;AAmBA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AA9FA;AACA;AAFA;;;;;;;;;;;;;;AC9BA;;;AAGA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAJA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AA0ZA;AAtZA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AA5ZA;AADA;AAgaA;AACA;AAAA;;AAEA;AAiGA;AA/FA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAjGA;AADA;;;;;;;;;;;;;;AC3fA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AARA;AADA;;;;;;;;;;;;;;ACXA;;;AAGA;AACA;;AAEA;AAGA;AACA;AACA;AAEA;;;AAGA;AACA;AAAA;;AAGA;AAgKA;AA9JA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AASA;;AAEA;AACA;AAEA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AAnKA;;;;;;;;;;;;;;ACjBA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;;AAGA;AACA;AACA;AACA;AACA;AAuiBA;AAriBA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5iBA;AACA;AAqBA;AA+BA;AAtDA;;;;;;;;;;;;;;AClEA;;;AAGA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAKA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AApCA;AA6CA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AAdA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvBA;AAwDA;;AAEA;AACA;AAqBA;AApBA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnFA;AA4FA;;AAEA;AACA;AASA;AACA;AATA;AAUA;AACA;AATA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAvDA;AA+DA;;;AAGA;AACA;AAEA;AACA;AAFA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAXA;AAaA;;;;AAIA;AACA;AAOA;AAKA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;;AAGA;AACA;;AA7DA;AACA;AACA;AACA;AAJA;AAiEA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;;;AAGA;AACA;AAAA;;AAEA;AACA;AA+OA;AA7OA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;AAGA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;;;AAGA;AACA;AAAA;AAAA;AAEA;;AAEA;AACA;AAEA;;;;;AAKA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;AAIA;AACA;AAEA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;;AAKA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAAA;AACA;AACA;;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;;AAEA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAlPA;AAoPA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAdA;AAgBA;;;AAGA;AACA;AAAA;AACA;AA4GA;AAzGA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;;;;;;AAMA;AACA;AACA;AA7GA;;;;;;;;;;;;;;AC/qBA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAIA;;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAnDA;AAqDA;AACA;AAAA;AACA;AACA;AAGA;AAFA;AACA;AACA;AALA;AAOA;AACA;AAQA;AAFA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AAnCA;AAqCA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAuKA;AAjKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAjLA;AAyLA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AAEA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;;AAEA;AACA;AAkEA;AACA;AAoOA;AA8DA;;;AAGA;AACA;AAEA;;;;AAIA;AACA;AAoyBA;AA3rCA;;;AAGA;AACA;AACA;;;AAGA;AACA;AACA;;;AAGA;AACA;AAEA;;;AAGA;AACA;AAqBA;AACA;AACA;AACA;AACA;AAEA;AACA;AAoBA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAeA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AA5pCA;AACA;AAEA;AACA;AAgBA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAvFA;AAktCA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AArGA;;;;;;;;;;;;;;ACzhDA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA4CA;;AAEA;AACA;AAmBA;AAAA;AAAA;AAlBA;AAkBA;AAjBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AA1BA;AA4BA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAdA;AAgBA;AACA;AAMA;AAAA;AALA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AA1GA;AA4GA;;AAEA;AACA;AAcA;AACA;AADA;AAAA;AAAA;AAXA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAvHA;AA1TA;AAobA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AAqEA;AApEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AA0GA;AAzGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AAgEA;AA/DA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AA+GA;AA9GA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;;AACA;AACA;AACA;AACA;AA0HA;AAzHA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAAA;AAFA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAUA;AAAA;AATA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AAEA;AAEA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAzLA;AACA;AA2LA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAJA;AADA;AAQA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAJA;AADA;AAQA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAJA;AADA;AAQA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAJA;AADA;AAQA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAJA;AADA;AAQA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAJA;AADA;AAQA;;AAEA;AACA;AAEA;AACA;AACA;AACA;;AAJA;AADA;AAQA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAlCA;AADA;AAsCA;;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAtBA;AADA;AA0BA;;AAEA;AACA;AAAA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AA4MA;AA1MA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAlNA;AADA;AAsNA;AACA;AAUA;AACA;AATA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAzMA;AADA;AA8MA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;;AANA;AADA;AAUA;;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;;AANA;AADA;AAUA;;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;;AAjBA;AADA;;;;;;;;;;;;ACvsEA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;A","sourceRoot":""}